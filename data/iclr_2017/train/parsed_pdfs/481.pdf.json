{
  "name" : "481.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Alexey Kurakin", "Ian J. Goodfellow", "Samy Bengio" ],
    "emails" : [ "kurakin@google.com", "ian@openai.com", "bengio@google.com" ],
    "sections" : [ {
      "heading" : "1 INTRODUCTION",
      "text" : "It has been shown that machine learning models are often vulnerable to adversarial manipulation of their input intended to cause incorrect classification (Dalvi et al., 2004). In particular, neural networks and many other categories of machine learning models are highly vulnerable to attacks based on small modifications of the input to the model at test time (Biggio et al., 2013; Szegedy et al., 2014; Goodfellow et al., 2014; Papernot et al., 2016b).\nThe problem can be summarized as follows. Let’s say there is a machine learning system M and input sample C which we call a clean example. Let’s assume that sample C is correctly classified by the machine learning system, i.e. M(C) = ytrue. It’s possible to construct an adversarial example A which is perceptually indistinguishable from C but is classified incorrectly, i.e. M(A) 6= ytrue. These adversarial examples are misclassified far more often than examples that have been perturbed by noise, even if the magnitude of the noise is much larger than the magnitude of the adversarial perturbation (Szegedy et al., 2014).\nAdversarial examples pose potential security threats for practical machine learning applications. In particular, Szegedy et al. (2014) showed that an adversarial example that was designed to be misclassified by a model M1 is often also misclassified by a model M2. This adversarial example transferability property means that it is possible to generate adversarial examples and perform a misclassification attack on a machine learning system without access to the underlying model. Papernot et al. (2016a) and Papernot et al. (2016b) demonstrated such attacks in realistic scenarios.\nIt has been shown (Goodfellow et al., 2014; Huang et al., 2015) that injecting adversarial examples into the training set (also called adversarial training) could increase robustness of neural networks to adversarial examples. Another existing approach is to use defensive distillation to train the network (Papernot et al., 2015). However all prior work studies defense measures only on relatively small datasets like MNIST and CIFAR10. Some concurrent work studies attack mechanisms on ImageNet (Rozsa et al., 2016), focusing on the question of how well adversarial examples transfer between different types of models, while we focus on defenses and studying how well different types of adversarial example generation procedures transfer between relatively similar models.\nIn this paper we studied adversarial training of Inception models trained on ImageNet. The contributions of this paper are the following:\n• We successfully used adversarial training to train an Inception v3 model (Szegedy et al., 2015) on ImageNet dataset (Russakovsky et al., 2014) and to significantly increase robustness against adversarial examples generated by the fast gradient sign method (Goodfellow et al., 2014) as well as other one-step methods.\n• We demonstrated that different types of adversarial examples tend to have different transferability properties between models. In particular we observed that those adversarial examples which are harder to resist using adversarial training are less likely to be transferrable between models.\n• We showed that models which have higher capacity (i.e. number of parameters) tend to be more robust to adversarial examples compared to lower capacity model of the same architecture. This provides additional cue which could help building more robust models.\n• We also observed an interesting property we call “label leaking”. Adversarial examples constructed with a single-step method making use of the true labels may be easier to classify than clean adversarial examples, because an adversarially trained model can learn to exploit regularities in the adversarial example construction process. This suggests using adversarial example construction processes that do not make use of the true label.\nThe rest of the paper is structured as follows: In section 2 we review different methods to generate adversarial examples. Section 3 describes details of our adversarial training algorithm. Finally, section 4 describes our experiments and results of adversarial training."
    }, {
      "heading" : "2 METHODS GENERATING ADVERSARIAL EXAMPLES",
      "text" : ""
    }, {
      "heading" : "2.1 TERMINOLOGY AND NOTATION",
      "text" : "In this paper we use the following notation and terminology regarding adversarial examples:\n1. X , the clean image — unmodified image from the dataset (either train or test set).\n2. Xadv , the adversarial image: the output of any procedure intended to produce an approximate worst-case modification of the clean image. We sometimes call this a candidate adversarial image to emphasize that an adversarial image is not necessarily misclassified by the neural network.\n3. Misclassified adversarial image — candidate adversarial image which is misclassified by the neural network. In addition we are typically interested only in those misclassified adversarial images when the corresponding clean image is correctly classified.\n4. : The size of the adversarial perturbation. In most cases, we require the L∞ norm of the perturbation to be less than , as done by Goodfellow et al. (2014). We always specify in terms of pixel values in the range [0, 255]. Note that some other work on adversarial examples minimizes the size of the perturbation rather than imposing a constraint on the size of the perturbation (Szegedy et al., 2014).\n5. The cost function used to train the model is denoted J(X, ytrue).\n6. ClipX, (A) denotes element-wise clipping A, with Ai,j clipped to the range [Xi,j − ,Xi,j + ].\n7. One-step methods of adversarial example generation generate a candidate adversarial image after computing only one gradient. They are often based on finding the optimal perturbation of a linear approximation of the cost or model. Iterative methods apply many gradient updates. They typically do not rely on any approximation of the model and typically produce more harmful adversarial examples when run for more iterations."
    }, {
      "heading" : "2.2 ATTACK METHODS",
      "text" : "We study a variety of attack methods:\nFast gradient sign method Goodfellow et al. (2014) proposed the fast gradient sign method (FGSM) as a simple way to generate adversarial examples:\nXadv = X + sign ( ∇XJ(X, ytrue) ) (1)\nThis method is simple and computationally efficient compared to more complex methods like LBFGS (Szegedy et al., 2014), however it usually has a lower success rate. On ImageNet, top-1 error rate on candidate adversarial images for the FGSM is about 63%− 69% for ∈ [2, 32].\nOne-step target class methods FGSM finds adversarial perturbations which increase the value of the loss function. An alternative approach is to maximize probability p(ytarget | X) of some specific target class ytarget which is unlikely to be the true class for a given image. For a neural network with cross-entropy loss this will lead to the following formula for the one-step target class method:\nXadv = X − sign ( ∇XJ(X, ytarget) ) (2)\nAs a target class we can use the least likely class predicted by the network yLL = argminy { p(y |\nX) }\n, as suggested by Kurakin et al. (2016). In such case we refer to this method as one-step least likely class or just “step l.l.” Alternatively we can use a random class as target class. In such a case we refer to this method as “step rnd.”.\nBasic iterative method A straightforward extension of FGSM is to apply it multiple times with small step size:\nXadv0 = X, X adv N+1 = ClipX, { XadvN + α sign ( ∇XJ(XadvN , ytrue) )} In our experiments we used α = 1, i.e. we changed the value of each pixel only by 1 on each step. We selected the number of iterations to be min( + 4, 1.25 ). See more information on this method in Kurakin et al. (2016). Below we refer to this method as “iter. basic” method.\nIterative least-likely class method By running multiple iterations of the “step l.l.” method we can get adversarial examples which are misclassified in more than 99% of the cases:\nXadv0 = X, X adv N+1 = ClipX, { XadvN − α sign ( ∇XJ(XadvN , yLL) )} α and number of iterations were selected in the same way as for the basic iterative method. Below we refer to this method as the “iter. l.l.”."
    }, {
      "heading" : "3 ADVERSARIAL TRAINING",
      "text" : "The basic idea of adversarial training is to inject adversarial examples into the training set, continually generating new adversarial examples at every step of training (Goodfellow et al., 2014). Adversarial training was originally developed for small models that did not use batch normalization. To scale adversarial training to ImageNet, we recommend using batch normalization (Ioffe & Szegedy, 2015). To do so successfully, we found that it was important for examples to be grouped into batches containing both normal and adversarial examples before taking each training step, as described in algorithm 1.\nWe use a loss function that allows independent control of the number and relative weight of adversarial examples in each batch:\nLoss = 1\n(m− k) + λk ( ∑ i∈CLEAN L(Xi|yi) + λ ∑ i∈ADV L(Xadvi |yi) ) where L(X|y) is a loss on a single example X with true class y; m is total number of training examples in the minibatch; k is number of adversarial examples in the minibatch and λ is a parameter which controls the relative weight of adversarial examples in the loss. We used λ = 0.3, m = 32,\nAlgorithm 1 Adversarial training of network N . Size of the training minibatch is m. Number of adversarial images in the minibatch is k.\n1: Randomly initialize network N 2: repeat 3: Read minibatch B = {X1, . . . , Xm} from training set 4: Generate k adversarial examples {X1adv, . . . , Xkadv} from corresponding clean examples {X1, . . . , Xk} using current state of the network N 5: Make new minibatch B′ = {X1adv, . . . , Xkadv, Xk+1, . . . , Xm} 6: Do one training step of network N using minibatch B′ 7: until training converged\nand k = 16. Note that we replace each clean example with its adversarial counterpart, for a total minibatch size of 32, which is a departure from previous approaches to adversarial training.\nFraction and weight of adversarial examples which we used in each minibatch differs from Huang et al. (2015) where authors replaced entire minibatch with adversarial examples. However their experiments was done on smaller datasets (MNIST and CIFAR-10) in which case adversarial training does not lead to decrease of accuracy on clean images. We found that our approach works better for ImageNet models (corresponding comparative experiments could be found in Appendix E).\nWe observed that if we fix during training then networks become robust only to that specific value of . We therefore recommend choosing randomly, independently for each training example. In our experiments we achieved best results when magnitudes were drawn from a truncated normal distribution defined in interval [0, 16] with underlying normal distribution N(µ = 0, σ = 8).1"
    }, {
      "heading" : "4 EXPERIMENTS",
      "text" : "We adversarially trained an Inception v3 model (Szegedy et al., 2015) on ImageNet. All experiments were done using synchronous distributed training on 50 machines, with a minibatch of 32 examples on each machine. We observed that the network tends to reach maximum accuracy at around 130k− 150k iterations. If we continue training beyond 150k iterations then eventually accuracy might decrease by a fraction of a percent. Thus we ran experiments for around 150k iterations and then used the obtained accuracy as the final result of the experiment.\nSimilar to Szegedy et al. (2015) we used RMSProp optimizer for training. We used a learning rate of 0.045 except where otherwise indicated.\nWe looked at interaction of adversarial training and other forms or regularization (dropout, label smoothing and weight decay). By default training of Inception v3 model uses all three of them. We noticed that disabling label smoothing and/or dropout leads to small decrease of accuracy on clean examples (by 0.1% - 0.5% for top 1 accuracy) and small increase of accuracy on adversarial examples (by 1% - 1.5% for top 1 accuracy). On the other hand reducing weight decay leads to decrease of accuracy on both clean and adversarial examples.\nWe experimented with delaying adversarial training by 0, 10k, 20k and 40k iterations. In such case we used only clean examples during the first N training iterations and after N iterations included both clean and adversarial examples in the minibatch. We noticed that delaying adversarial training has almost no effect on accuracy on clean examples (difference in accuracy within 0.2%) after sufficient number of training iterations (more than 70k in our case). At the same time we noticed that larger delays of adversarial training might cause up to 4% decline of accuracy on adversarial examples with high magnitude of adversarial perturbations. For small 10k delay changes of accuracy was not statistically significant to recommend against it. We used a delay of 10k because this allowed us to reuse the same partially trained model as a starting point for many different experiments.\nFor evaluation we used the ImageNet validation set which contains 50, 000 images and does not intersect with the training set.\n1 In TensorFlow this could be achieved by tf.abs(tf.truncated normal(shape, mean=0, stddev=8))."
    }, {
      "heading" : "4.1 RESULTS OF ADVERSARIAL TRAINING",
      "text" : "We experimented with adversarial training using several types of one-step methods. We found that adversarial training using any type of one-step method increases robustness to all types of one-step adversarial examples that we tested. However there is still a gap between accuracy on clean and adversarial examples which could vary depending on the combination of methods used for training and evaluation.\nAdversarial training caused a slight (less than 1%) decrease of accuracy on clean examples in our ImageNet experiments. This differs from results of adversarial training reported previously, where adversarial training increased accuracy on the test set (Goodfellow et al., 2014; Miyato et al., 2016b;a). One possible explanation is that adversarial training acts as a regularizer. For datasets with few labeled examples where overfitting is the primary concern, adversarial training reduces test error. For datasets like ImageNet where state-of-the-art models typically have high training set error, adding a regularizer like adversarial training can increase training set error more than it decreases the gap between training and test set error. Our results suggest that adversarial training should be employed in two scenarios:\n1. When a model is overfitting, and a regularizer is required. 2. When security against adversarial examples is a concern. In this case, adversarial training\nis the method that provides the most security of any known defense, while losing only a small amount of accuracy.\nBy comparing different one-step methods for adversarial training we observed that the best results in terms or accuracy on test set are achieved using “step l.l.” or “step rnd.” method. Moreover using these two methods helped the model to become robust to adversarial examples generated by other one-step methods. Thus for final experiments we used “step l.l.” adversarial method.\nFor brevity we omitted a detailed comparison of different one-step methods here, but the reader can find it in Appendix A.\nResults of adversarial training using “step l.l.” method are provided in Table 1. As it can be seen from the table we were able to significantly increase top-1 and top-5 accuracy on adversarial examples (up to 74% and 92% correspondingly) to make it to be on par with accuracy on clean images. However we lost about 0.8% accuracy on clean examples.\nWe were able to slightly reduce the gap in the accuracy on clean images by slightly increasing the size of the model. This was done by adding two additional Inception blocks to the model. For specific details about Inception blocks refer to Szegedy et al. (2015).\nUnfortunately, training on one-step adversarial examples does not confer robustness to iterative adversarial examples, as shown in Table 2.\nWe also tried to use iterative adversarial examples during training, however we were unable to gain any benefits out of it. It is computationally costly and we were not able to obtain robustness to adversarial examples or to prevent the procedure from reducing the accuracy on clean examples significantly. It is possible that much larger models are necessary to achieve robustness to such a large class of inputs."
    }, {
      "heading" : "4.2 LABEL LEAKING",
      "text" : "We discovered a label leaking effect: when a model is trained on FGSM adversarial examples and then evaluated using FGSM adversarial examples, the accuracy on adversarial images becomes much higher than the accuracy on clean images (see Table 3). This effect also occurs (but to a lesser degree) when using other one-step methods that require the true label as input.\nWe say that label for specific example has been leaked if and only if the model classifies an adversarial example correctly when that adversarial example is generated using the true label but misclassifies a corresponding adversarial example that was created without using the true label. If too many labels has been leaked then accuracy on adversarial examples might become bigger than accuracy on clean examples which we observed on ImageNet dataset.\nWe believe that the effect occurs because one-step methods that use the true label perform a very simple and predictable transformation that the model can learn to recognize. The adversarial example construction process thus inadvertently leaks information about the true label into the input. We found that the effect vanishes if we use adversarial example construction processes that do not use the true label. The effect also vanishes if an iterative method is used, presumably because the output of an iterative process is more diverse and less predictable than the output of a one-step process.\nOverall due to the label leaking effect, we do not recommend to use FGSM or other methods defined with respect to the true class label to evaluate robustness to adversarial examples; we recommend to use other one-step methods that do not directly access the label instead.\nWe recommend to replace the true label with the most likely label predicted by the model. Alternately, one can maximize the cross-entropy between the full distribution over all predicted labels given the clean input and the distribution over all predicted labels given the perturbed input (Miyato et al., 2016b).\nWe revisited the adversarially trained MNIST classifier from Goodfellow et al. (2014) and found that it too leaks labels. The most labels are leaked with = 0.3 on MNIST data in [0, 1]. With that , the model leaks 79 labels on the test set of 10,000 examples. However, the amount of label leaking is small compared to the amount of error caused by adversarial examples. The error rate on adversarial examples exceeds the error rate on clean examples for ∈ {.05, .1, .25, .3, .4, .45, .5}. This explains why the label leaking effect was not noticed earlier."
    }, {
      "heading" : "4.3 INFLUENCE OF MODEL CAPACITY ON ADVERSARIAL ROBUSTNESS",
      "text" : "We studied how the size of the model (in terms of number of parameters) could affect robustness to adversarial examples. We picked Inception v3 as a base model and varied its size by changing the number of filters in each convolution.\nFor each experiment we picked a scale factor ρ and multiplied the number of filters in each convolution by ρ. In other words ρ = 1 means unchanged Inception v3, ρ = 0.5 means Inception with half of the usual number of filters in convolutions, etc . . . For each chosen ρ we trained two independent models: one with adversarial training and another without. Then we evaluated accuracy on clean and adversarial examples for both trained models. We have run these experiments for ρ ∈ [0.5, 2.0]. In earlier experiments (Table 1) we found that deeper models benefit more from adversarial training. The increased depth changed many aspects of the model architecture. These experiments varying ρ examine the effect in a more controlled setting, where the architecture remains constant except for the number of feature maps in each layer.\nIn all experiments we observed that accuracy on clean images kept increasing with increase of ρ, though its increase slowed down as ρ became bigger. Thus as a measure of robustness we used the ratio of accuracy on adversarial images to accuracy on clean images because an increase of this ratio means that the gap between accuracy on adversarial and clean images becomes smaller. If this ratio reaches 1 then the accuracy on adversarial images is the same as on clean ones. For a successful adversarial example construction technique, we would never expect this ratio to exceed 1, since this would imply that the adversary is actually helpful. Some defective adversarial example construction techniques, such as those suffering from label leaking, can inadvertently produce a ratio greater than 1.\nResults with ratios of accuracy for various adversarial methods and are provided in Fig. 1.\nFor models without adversarial training, we observed that there is an optimal value of ρ yielding best robustness. Models that are too large or too small perform worse. This may indicate that models become more robust to adversarial examples until they become large enough to overfit in some respect.\nFor adversarially trained models, we found that robustness consistently increases with increases in model size. We were not able to train large enough models to find when this process ends, but we did find that models with twice the normal size have an accuracy ratio approaching 1 for one-step adversarial examples. When evaluated on iterative adversarial examples, the trend toward increasing robustness with increasing size remains but has some exceptions. Also, none of our models was large enough to approach an accuracy ratio of 1 in this regime.\nOverall we recommend exploring increase of accuracy (along with adversarial training) as a measure to improve robustness to adversarial examples."
    }, {
      "heading" : "4.4 TRANSFERABILITY OF ADVERSARIAL EXAMPLES",
      "text" : "From a security perspective, an important property of adversarial examples is that they tend to transfer from one model to another, enabling an attacker in the black-box scenario to create adversarial\nexamples for their own substitute model, then deploy those adversarial examples to fool a target model (Szegedy et al., 2014; Goodfellow et al., 2014; Papernot et al., 2016b).\nWe studied transferability of adversarial examples between the following models: two copies of normal Inception v3 (with different random initializations and order or training examples), Inception v4 (Szegedy et al., 2016) and Inception v3 which uses ELU activation (Clevert et al., 2015) instead of Relu2. All of these models were independently trained from scratch until they achieved maximum accuracy.\n2 We achieved 78.0% top 1 and 94.1% top 5 accuracy on Inception v3 with ELU activations, which is comparable with accuracy of Inception v3 model with Relu activations.\nIn each experiment we fixed the source and target networks, constructed adversarial examples from 1000 randomly sampled clean images from the test set using the source network and performed classification of all of them using both source and target networks. These experiments were done independently for different adversarial methods.\nWe measured transferability using the following criteria. Among 1000 images we picked only misclassified adversarial example for the source model (i.e. clean classified correctly, adversarial misclassified) and measured what fraction of them were misclassified by the target model.\nTransferability results for all combinations of models and = 16 are provided in Table 4. Results for various but fixed source and target model are provided in Fig. 2.\nAs can be seen from the results, FGSM adversarial examples are the most transferable, while “iter l.l.” are the least. On the other hand “iter l.l.” method is able to fool the network in more than 99% cases (top 1 accuracy), while FGSM is the least likely to fool the network. This suggests that there might be an inverse relationship between transferability of specific method and ability of the method to fool the network. We haven’t studied this phenomenon further, but one possible explanation could be the fact that iterative methods tend to overfit to specific network parameters.\nIn addition, we observed that for each of the considered methods transfer rate is increasing with increase of (see Fig. 2). Thus potential adversary performing a black-box attack have an incentive to use higher to increase the chance of success of the attack."
    }, {
      "heading" : "5 CONCLUSION",
      "text" : "In this paper we studied how to increase robustness to adversarial examples of large models (Inception v3) trained on large dataset (ImageNet). We showed that adversarial training provides robustness to adversarial examples generated using one-step methods. While adversarial training didn’t help much against iterative methods we observed that adversarial examples generated by iterative methods are less likely to be transferred between networks, which provides indirect robustness against black box adversarial attacks. In addition we observed that increase of model capacity could also help to increase robustness to adversarial examples especially when used in conjunction with adversarial training. Finally we discovered the effect of label leaking which resulted in higher accuracy on FGSM adversarial examples compared to clean examples when the network was adversarially trained."
    }, {
      "heading" : "A COMPARISON OF ONE-STEP ADVERSARIAL METHODS",
      "text" : "In addition to FGSM and “step l.l.” methods we explored several other one-step adversarial methods both for training and evaluation. Generally all of these methods can be separated into two large categories. Methods which try to maximize the loss (similar to FGSM) are in the first category. The second category contains methods which try to maximize the probability of a specific target class (similar to “step l.l.”). We also tried to use different types of random noise instead of adversarial images, but random noise didn’t help with robustness against adversarial examples.\nThe full list of one-step methods we tried is as follows:\n• Methods increasing loss function J – FGSM (described in details in Section 2.2):\nXadv = X + sign ( ∇XJ(X, ytrue) ) – FGSM-pred or fast method with predicted class. It is similar to FGSM but uses the\nlabel of the class predicted by the network instead of true class ytrue. – “Fast entropy” or fast method designed to maximize the entropy of the predicted dis-\ntribution, thereby causing the model to become less certain of the predicted class. – “Fast grad. L2” is similar to FGSM but uses the value of gradient instead of its sign.\nThe value of gradient is normalized to have unit L2 norm:\nXadv = X + ∇XJ(X, ytrue)∥∥∇XJ(X, ytrue)∥∥2\nMiyato et al. (2016b) advocate this method. – “Fast grad. L∞” is similar to “fast grad. L2” but uses L∞ norm for normalization.\n• Methods increasing the probability of the selected target class – “Step l.l.” is one-step towards least likely class (also described in Section 2.2):\nXadv = X − sign ( ∇XJ(X, ytarget) ) where ytarget = argminy { p(y |X) } is least likely class prediction by the network. – “Step rnd.” is similar to “step l.l.” but uses random class instead of least likely class. • Random perturbations\n– Sign of random perturbation. This is an attempt to construct random perturbation which has similar structure to perturbations generated by FGSM:\nXadv = X + sign ( N )\nwhere N is random normal variable with zero mean and identity covariance matrix. – Random truncated normal perturbation with zero mean and 0.5 standard deviation\ndefined on [− , ] and uncorrelated pixels, which leads to the following formula for perturbed images: Xadv = X + T where T is a random variable with truncated normal distribution.\nOverall, we observed that using only one of these single step methods during adversarial training is sufficient to gain robustness to all of them. Fig. 3 shows accuracy on various one-step adversarial examples when the network was trained using only “step l.l.” method.\nAt the same time we observed that not all one-step methods are equally good for adversarial training, as shown in Table 5. The best results (achieving both good accuracy on clean data and good accuracy on adversarial inputs) were obtained when adversarial training was done using “step l.l.” or “step rnd.” methods."
    }, {
      "heading" : "B ADDITIONAL RESULTS WITH SIZE OF THE MODEL",
      "text" : "Section 4.3 contains details regarding the influence of size of the model on robustness to adversarial examples. Here we provide additional Figure 4 which shows robustness calculated using top 5 accuracy. Generally it exhibits the same properties as the corresponding plots for top 1 accuracy."
    }, {
      "heading" : "C ADDITIONAL RESULTS ON TRANSFERABILITY",
      "text" : "Section 4.4 contains results with transfer rate of various adversarial examples between models. In addition to transfer rate computed only on misclassified adversarial examples it is also interesting to observe the error rate of all candidate adversarial examples generated for one model and classified by other model.\nThis result might be interesting because it models the following attack. Instead of trying to pick “good” adversarial images an adversary tries to modify all available images in order to get as much misclassified images as possible.\nTo compute the error rate we randomly generated 1000 adversarial images using the source model and then classified them using the target model. Results for various models, adversarial methods\nand fixed = 16 are provided in Table 6. Results for fixed source and target models and various are provided in Fig. 5.\nOverall the error rate of transferred adversarial examples exhibits the same behavior as the transfer rate described in Section 4.4."
    }, {
      "heading" : "D RESULTS WITH DIFFERENT ACTIVATION FUNCTIONS",
      "text" : "We evaluated robustness to adversarial examples when the network was trained using various nonlinear activation functions instead of the standard relu activation when used with adversarial training on “step l.l.” adversarial images. We tried to use following activation functions instead of relu:\n• tanh(x)\n• relu6(x) = min(relu(x), 6)\n• ReluDecayβ(x) = relu(x)1+βrelu(x)2 for β ∈ {0.1, 0.01, 0.001}\nTraining converged using all of these activations, however test performance was not necessarily the same as with relu.\ntanh and ReluDecayβ=0.1 lose about 2%-3% of accuracy on clean examples and about 10%-20% on “step l.l.” adversarial examples. relu6,ReluDecayβ=0.01 andReluDecayβ=0.001 demonstrated similar accuracy (within ±1%) to relu on clean images and few percent loss of accuracy on “step l.l.” images. At the same time all non-linear activation functions increased classification accuracy on some of the iterative adversarial images. Detailed results are provided in Table 7.\nOverall non linear activation functions could be used as an additional measure of defense against iterative adversarial images."
    }, {
      "heading" : "E RESULTS WITH DIFFERENT NUMBER OF ADVERSARIAL EXAMPLES IN THE MINIBATCH",
      "text" : "We studied how number of adversarial examples k in the minibatch affect accuracy on clean and adversarial examples. Results are summarized in Table 8.\nOverall we noticed that increase of k lead to increase of accuracy on adversarial examples and to decrease of accuracy on clean examples. At the same having more than half of adversarial examples in the minibatch (which correspond to k > 16 in our case) does not provide significant improvement of accuracy on adversarial images, however lead to up to 1% of additional decrease of accuracy\non clean images. Thus for most experiments in the paper we have chosen k = 16 as a reasonable trade-off between accuracy on clean and adversarial images."
    } ],
    "references" : [ {
      "title" : "Evasion attacks against machine learning at test time",
      "author" : [ "Battista Biggio", "Igino Corona", "Davide Maiorca", "Blaine Nelson", "Nedim Šrndić", "Pavel Laskov", "Giorgio Giacinto", "Fabio Roli" ],
      "venue" : "In Joint European Conference on Machine Learning and Knowledge Discovery in Databases,",
      "citeRegEx" : "Biggio et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Biggio et al\\.",
      "year" : 2013
    }, {
      "title" : "Fast and accurate deep network learning by exponential linear units (elus)",
      "author" : [ "Djork-Arné Clevert", "Thomas Unterthiner", "Sepp Hochreiter" ],
      "venue" : "CoRR, abs/1511.07289,",
      "citeRegEx" : "Clevert et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Clevert et al\\.",
      "year" : 2015
    }, {
      "title" : "Adversarial classification",
      "author" : [ "Nilesh Dalvi", "Pedro Domingos", "Sumit Sanghai", "Deepak Verma" ],
      "venue" : "In Proceedings of the tenth ACM SIGKDD international conference on Knowledge discovery and data mining,",
      "citeRegEx" : "Dalvi et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Dalvi et al\\.",
      "year" : 2004
    }, {
      "title" : "Explaining and harnessing adversarial examples",
      "author" : [ "Ian J. Goodfellow", "Jonathon Shlens", "Christian Szegedy" ],
      "venue" : "CoRR, abs/1412.6572,",
      "citeRegEx" : "Goodfellow et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Goodfellow et al\\.",
      "year" : 2014
    }, {
      "title" : "Learning with a strong adversary",
      "author" : [ "Ruitong Huang", "Bing Xu", "Dale Schuurmans", "Csaba Szepesvári" ],
      "venue" : "CoRR, abs/1511.03034,",
      "citeRegEx" : "Huang et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Huang et al\\.",
      "year" : 2015
    }, {
      "title" : "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
      "author" : [ "Sergey Ioffe", "Christian Szegedy" ],
      "venue" : null,
      "citeRegEx" : "Ioffe and Szegedy.,? \\Q2015\\E",
      "shortCiteRegEx" : "Ioffe and Szegedy.",
      "year" : 2015
    }, {
      "title" : "Adversarial examples in the physical world",
      "author" : [ "Alex Kurakin", "Ian Goodfellow", "Samy Bengio" ],
      "venue" : "Technical report,",
      "citeRegEx" : "Kurakin et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Kurakin et al\\.",
      "year" : 2016
    }, {
      "title" : "Virtual adversarial training for semi-supervised text classification",
      "author" : [ "Takeru Miyato", "Andrew M Dai", "Ian Goodfellow" ],
      "venue" : "arXiv preprint arXiv:1605.07725,",
      "citeRegEx" : "Miyato et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Miyato et al\\.",
      "year" : 2016
    }, {
      "title" : "Distributional smoothing with virtual adversarial training",
      "author" : [ "Takeru Miyato", "Shin-ichi Maeda", "Masanori Koyama", "Ken Nakae", "Shin Ishii" ],
      "venue" : "In International Conference on Learning Representations (ICLR2016), April 2016b",
      "citeRegEx" : "Miyato et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Miyato et al\\.",
      "year" : 2016
    }, {
      "title" : "Transferability in Machine Learning: from Phenomena to Black-Box Attacks using Adversarial Samples",
      "author" : [ "N. Papernot", "P. McDaniel", "I. Goodfellow" ],
      "venue" : "ArXiv e-prints, May 2016b. URL http://arxiv.org/abs/1605.07277",
      "citeRegEx" : "Papernot et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Papernot et al\\.",
      "year" : 2016
    }, {
      "title" : "Distillation as a defense to adversarial perturbations against deep neural networks",
      "author" : [ "Nicolas Papernot", "Patrick Drew McDaniel", "Xi Wu", "Somesh Jha", "Ananthram Swami" ],
      "venue" : "CoRR, abs/1511.04508,",
      "citeRegEx" : "Papernot et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Papernot et al\\.",
      "year" : 2015
    }, {
      "title" : "Practical black-box attacks against deep learning systems using adversarial examples",
      "author" : [ "Nicolas Papernot", "Patrick Drew McDaniel", "Ian J. Goodfellow", "Somesh Jha", "Z. Berkay Celik", "Ananthram Swami" ],
      "venue" : "CoRR, abs/1602.02697,",
      "citeRegEx" : "Papernot et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Papernot et al\\.",
      "year" : 2016
    }, {
      "title" : "Are accuracy and robustness correlated",
      "author" : [ "Andras Rozsa", "Manuel Günther", "Terrance E Boult" ],
      "venue" : "arXiv preprint arXiv:1610.04563,",
      "citeRegEx" : "Rozsa et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Rozsa et al\\.",
      "year" : 2016
    }, {
      "title" : "Imagenet large scale visual recognition challenge",
      "author" : [ "Olga Russakovsky", "Jia Deng", "Hao Su", "Jonathan Krause", "Sanjeev Satheesh", "Sean Ma", "Zhiheng Huang", "Andrej Karpathy", "Aditya Khosla", "Michael Bernstein" ],
      "venue" : "arXiv preprint arXiv:1409.0575,",
      "citeRegEx" : "Russakovsky et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Russakovsky et al\\.",
      "year" : 2014
    }, {
      "title" : "Intriguing properties of neural networks",
      "author" : [ "Christian Szegedy", "Wojciech Zaremba", "Ilya Sutskever", "Joan Bruna", "Dumitru Erhan", "Ian J. Goodfellow", "Rob Fergus" ],
      "venue" : "ICLR, abs/1312.6199,",
      "citeRegEx" : "Szegedy et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Szegedy et al\\.",
      "year" : 2014
    }, {
      "title" : "Rethinking the inception architecture for computer",
      "author" : [ "Christian Szegedy", "Vincent Vanhoucke", "Sergey Ioffe", "Jonathon Shlens", "Zbigniew Wojna" ],
      "venue" : "vision. CoRR,",
      "citeRegEx" : "Szegedy et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Szegedy et al\\.",
      "year" : 2015
    }, {
      "title" : "Inception-v4, inception-resnet and the impact of residual connections on learning",
      "author" : [ "Christian Szegedy", "Sergey Ioffe", "Vincent Vanhoucke" ],
      "venue" : "CoRR, abs/1602.07261,",
      "citeRegEx" : "Szegedy et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Szegedy et al\\.",
      "year" : 2016
    }, {
      "title" : "Fast grad. L∞” is similar to “fast grad. L2” but uses L∞ norm for normalization",
      "author" : [ "∥∥∇XJ(X", "ytrue)∥∥2 Miyato" ],
      "venue" : null,
      "citeRegEx" : "∥∥∇XJ.X and Miyato,? \\Q2016\\E",
      "shortCiteRegEx" : "∥∥∇XJ.X and Miyato",
      "year" : 2016
    } ],
    "referenceMentions" : [ {
      "referenceID" : 13,
      "context" : "In this research, we apply adversarial training to ImageNet (Russakovsky et al., 2014).",
      "startOffset" : 60,
      "endOffset" : 86
    }, {
      "referenceID" : 2,
      "context" : "It has been shown that machine learning models are often vulnerable to adversarial manipulation of their input intended to cause incorrect classification (Dalvi et al., 2004).",
      "startOffset" : 154,
      "endOffset" : 174
    }, {
      "referenceID" : 0,
      "context" : "In particular, neural networks and many other categories of machine learning models are highly vulnerable to attacks based on small modifications of the input to the model at test time (Biggio et al., 2013; Szegedy et al., 2014; Goodfellow et al., 2014; Papernot et al., 2016b).",
      "startOffset" : 185,
      "endOffset" : 277
    }, {
      "referenceID" : 14,
      "context" : "In particular, neural networks and many other categories of machine learning models are highly vulnerable to attacks based on small modifications of the input to the model at test time (Biggio et al., 2013; Szegedy et al., 2014; Goodfellow et al., 2014; Papernot et al., 2016b).",
      "startOffset" : 185,
      "endOffset" : 277
    }, {
      "referenceID" : 3,
      "context" : "In particular, neural networks and many other categories of machine learning models are highly vulnerable to attacks based on small modifications of the input to the model at test time (Biggio et al., 2013; Szegedy et al., 2014; Goodfellow et al., 2014; Papernot et al., 2016b).",
      "startOffset" : 185,
      "endOffset" : 277
    }, {
      "referenceID" : 14,
      "context" : "These adversarial examples are misclassified far more often than examples that have been perturbed by noise, even if the magnitude of the noise is much larger than the magnitude of the adversarial perturbation (Szegedy et al., 2014).",
      "startOffset" : 210,
      "endOffset" : 232
    }, {
      "referenceID" : 3,
      "context" : "It has been shown (Goodfellow et al., 2014; Huang et al., 2015) that injecting adversarial examples into the training set (also called adversarial training) could increase robustness of neural networks to adversarial examples.",
      "startOffset" : 18,
      "endOffset" : 63
    }, {
      "referenceID" : 4,
      "context" : "It has been shown (Goodfellow et al., 2014; Huang et al., 2015) that injecting adversarial examples into the training set (also called adversarial training) could increase robustness of neural networks to adversarial examples.",
      "startOffset" : 18,
      "endOffset" : 63
    }, {
      "referenceID" : 10,
      "context" : "Another existing approach is to use defensive distillation to train the network (Papernot et al., 2015).",
      "startOffset" : 80,
      "endOffset" : 103
    }, {
      "referenceID" : 12,
      "context" : "Some concurrent work studies attack mechanisms on ImageNet (Rozsa et al., 2016), focusing on the question of how well adversarial examples transfer between different types of models, while we focus on defenses and studying how well different types of adversarial example generation procedures transfer between relatively similar models.",
      "startOffset" : 59,
      "endOffset" : 79
    }, {
      "referenceID" : 0,
      "context" : "In particular, neural networks and many other categories of machine learning models are highly vulnerable to attacks based on small modifications of the input to the model at test time (Biggio et al., 2013; Szegedy et al., 2014; Goodfellow et al., 2014; Papernot et al., 2016b). The problem can be summarized as follows. Let’s say there is a machine learning system M and input sample C which we call a clean example. Let’s assume that sample C is correctly classified by the machine learning system, i.e. M(C) = ytrue. It’s possible to construct an adversarial example A which is perceptually indistinguishable from C but is classified incorrectly, i.e. M(A) 6= ytrue. These adversarial examples are misclassified far more often than examples that have been perturbed by noise, even if the magnitude of the noise is much larger than the magnitude of the adversarial perturbation (Szegedy et al., 2014). Adversarial examples pose potential security threats for practical machine learning applications. In particular, Szegedy et al. (2014) showed that an adversarial example that was designed to be misclassified by a model M1 is often also misclassified by a model M2.",
      "startOffset" : 186,
      "endOffset" : 1039
    }, {
      "referenceID" : 0,
      "context" : "In particular, neural networks and many other categories of machine learning models are highly vulnerable to attacks based on small modifications of the input to the model at test time (Biggio et al., 2013; Szegedy et al., 2014; Goodfellow et al., 2014; Papernot et al., 2016b). The problem can be summarized as follows. Let’s say there is a machine learning system M and input sample C which we call a clean example. Let’s assume that sample C is correctly classified by the machine learning system, i.e. M(C) = ytrue. It’s possible to construct an adversarial example A which is perceptually indistinguishable from C but is classified incorrectly, i.e. M(A) 6= ytrue. These adversarial examples are misclassified far more often than examples that have been perturbed by noise, even if the magnitude of the noise is much larger than the magnitude of the adversarial perturbation (Szegedy et al., 2014). Adversarial examples pose potential security threats for practical machine learning applications. In particular, Szegedy et al. (2014) showed that an adversarial example that was designed to be misclassified by a model M1 is often also misclassified by a model M2. This adversarial example transferability property means that it is possible to generate adversarial examples and perform a misclassification attack on a machine learning system without access to the underlying model. Papernot et al. (2016a) and Papernot et al.",
      "startOffset" : 186,
      "endOffset" : 1410
    }, {
      "referenceID" : 0,
      "context" : "In particular, neural networks and many other categories of machine learning models are highly vulnerable to attacks based on small modifications of the input to the model at test time (Biggio et al., 2013; Szegedy et al., 2014; Goodfellow et al., 2014; Papernot et al., 2016b). The problem can be summarized as follows. Let’s say there is a machine learning system M and input sample C which we call a clean example. Let’s assume that sample C is correctly classified by the machine learning system, i.e. M(C) = ytrue. It’s possible to construct an adversarial example A which is perceptually indistinguishable from C but is classified incorrectly, i.e. M(A) 6= ytrue. These adversarial examples are misclassified far more often than examples that have been perturbed by noise, even if the magnitude of the noise is much larger than the magnitude of the adversarial perturbation (Szegedy et al., 2014). Adversarial examples pose potential security threats for practical machine learning applications. In particular, Szegedy et al. (2014) showed that an adversarial example that was designed to be misclassified by a model M1 is often also misclassified by a model M2. This adversarial example transferability property means that it is possible to generate adversarial examples and perform a misclassification attack on a machine learning system without access to the underlying model. Papernot et al. (2016a) and Papernot et al. (2016b) demonstrated such attacks in realistic scenarios.",
      "startOffset" : 186,
      "endOffset" : 1438
    }, {
      "referenceID" : 15,
      "context" : "• We successfully used adversarial training to train an Inception v3 model (Szegedy et al., 2015) on ImageNet dataset (Russakovsky et al.",
      "startOffset" : 75,
      "endOffset" : 97
    }, {
      "referenceID" : 13,
      "context" : ", 2015) on ImageNet dataset (Russakovsky et al., 2014) and to significantly increase robustness against adversarial examples generated by the fast gradient sign method (Goodfellow et al.",
      "startOffset" : 28,
      "endOffset" : 54
    }, {
      "referenceID" : 3,
      "context" : ", 2014) and to significantly increase robustness against adversarial examples generated by the fast gradient sign method (Goodfellow et al., 2014) as well as other one-step methods.",
      "startOffset" : 121,
      "endOffset" : 146
    }, {
      "referenceID" : 14,
      "context" : "Note that some other work on adversarial examples minimizes the size of the perturbation rather than imposing a constraint on the size of the perturbation (Szegedy et al., 2014).",
      "startOffset" : 155,
      "endOffset" : 177
    }, {
      "referenceID" : 3,
      "context" : "In most cases, we require the L∞ norm of the perturbation to be less than , as done by Goodfellow et al. (2014). We always specify in terms of pixel values in the range [0, 255].",
      "startOffset" : 87,
      "endOffset" : 112
    }, {
      "referenceID" : 14,
      "context" : "(2014) proposed the fast gradient sign method (FGSM) as a simple way to generate adversarial examples: X = X + sign ( ∇XJ(X, ytrue) ) (1) This method is simple and computationally efficient compared to more complex methods like LBFGS (Szegedy et al., 2014), however it usually has a lower success rate.",
      "startOffset" : 234,
      "endOffset" : 256
    }, {
      "referenceID" : 3,
      "context" : "Fast gradient sign method Goodfellow et al. (2014) proposed the fast gradient sign method (FGSM) as a simple way to generate adversarial examples: X = X + sign ( ∇XJ(X, ytrue) ) (1) This method is simple and computationally efficient compared to more complex methods like LBFGS (Szegedy et al.",
      "startOffset" : 26,
      "endOffset" : 51
    }, {
      "referenceID" : 6,
      "context" : "As a target class we can use the least likely class predicted by the network yLL = argminy { p(y | X) } , as suggested by Kurakin et al. (2016). In such case we refer to this method as one-step least likely class or just “step l.",
      "startOffset" : 122,
      "endOffset" : 144
    }, {
      "referenceID" : 6,
      "context" : "See more information on this method in Kurakin et al. (2016). Below we refer to this method as “iter.",
      "startOffset" : 39,
      "endOffset" : 61
    }, {
      "referenceID" : 3,
      "context" : "The basic idea of adversarial training is to inject adversarial examples into the training set, continually generating new adversarial examples at every step of training (Goodfellow et al., 2014).",
      "startOffset" : 170,
      "endOffset" : 195
    }, {
      "referenceID" : 4,
      "context" : "Fraction and weight of adversarial examples which we used in each minibatch differs from Huang et al. (2015) where authors replaced entire minibatch with adversarial examples.",
      "startOffset" : 89,
      "endOffset" : 109
    }, {
      "referenceID" : 15,
      "context" : "We adversarially trained an Inception v3 model (Szegedy et al., 2015) on ImageNet.",
      "startOffset" : 47,
      "endOffset" : 69
    }, {
      "referenceID" : 14,
      "context" : "We adversarially trained an Inception v3 model (Szegedy et al., 2015) on ImageNet. All experiments were done using synchronous distributed training on 50 machines, with a minibatch of 32 examples on each machine. We observed that the network tends to reach maximum accuracy at around 130k− 150k iterations. If we continue training beyond 150k iterations then eventually accuracy might decrease by a fraction of a percent. Thus we ran experiments for around 150k iterations and then used the obtained accuracy as the final result of the experiment. Similar to Szegedy et al. (2015) we used RMSProp optimizer for training.",
      "startOffset" : 48,
      "endOffset" : 581
    }, {
      "referenceID" : 14,
      "context" : "For specific details about Inception blocks refer to Szegedy et al. (2015). Unfortunately, training on one-step adversarial examples does not confer robustness to iterative adversarial examples, as shown in Table 2.",
      "startOffset" : 53,
      "endOffset" : 75
    }, {
      "referenceID" : 3,
      "context" : "We revisited the adversarially trained MNIST classifier from Goodfellow et al. (2014) and found that it too leaks labels.",
      "startOffset" : 61,
      "endOffset" : 86
    }, {
      "referenceID" : 14,
      "context" : "examples for their own substitute model, then deploy those adversarial examples to fool a target model (Szegedy et al., 2014; Goodfellow et al., 2014; Papernot et al., 2016b).",
      "startOffset" : 103,
      "endOffset" : 174
    }, {
      "referenceID" : 3,
      "context" : "examples for their own substitute model, then deploy those adversarial examples to fool a target model (Szegedy et al., 2014; Goodfellow et al., 2014; Papernot et al., 2016b).",
      "startOffset" : 103,
      "endOffset" : 174
    }, {
      "referenceID" : 16,
      "context" : "We studied transferability of adversarial examples between the following models: two copies of normal Inception v3 (with different random initializations and order or training examples), Inception v4 (Szegedy et al., 2016) and Inception v3 which uses ELU activation (Clevert et al.",
      "startOffset" : 200,
      "endOffset" : 222
    }, {
      "referenceID" : 1,
      "context" : ", 2016) and Inception v3 which uses ELU activation (Clevert et al., 2015) instead of Relu2.",
      "startOffset" : 51,
      "endOffset" : 73
    } ],
    "year" : 2017,
    "abstractText" : "Adversarial examples are malicious inputs designed to fool machine learning models. They often transfer from one model to another, allowing attackers to mount black box attacks without knowledge of the target model’s parameters. Adversarial training is the process of explicitly training a model on adversarial examples, in order to make it more robust to attack or to reduce its test error on clean inputs. So far, adversarial training has primarily been applied to small problems. In this research, we apply adversarial training to ImageNet (Russakovsky et al., 2014). Our contributions include: (1) recommendations for how to succesfully scale adversarial training to large models and datasets, (2) the observation that adversarial training confers robustness to single-step attack methods, (3) the finding that multi-step attack methods are somewhat less transferable than singlestep attack methods, so single-step attacks are the best for mounting black-box attacks, and (4) resolution of a “label leaking” effect that causes adversarially trained models to perform better on adversarial examples than on clean examples, because the adversarial example construction process uses the true label and the model can learn to exploit regularities in the construction process.",
    "creator" : "LaTeX with hyperref package"
  }
}