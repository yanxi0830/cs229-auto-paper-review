{
  "name" : "381.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "PRUNING CONVOLUTIONAL NEURAL NETWORKS FOR RESOURCE EFFICIENT INFERENCE",
    "authors" : [ "Pavlo Molchanov", "Stephen Tyree", "Tero Karras", "Timo Aila", "Jan Kautz" ],
    "emails" : [ "jkautz}@nvidia.com" ],
    "sections" : [ {
      "heading" : "1 INTRODUCTION",
      "text" : "Convolutional neural networks (CNN) are used extensively in computer vision applications, including object classification and localization, pedestrian and car detection, and video classification. Many problems like these focus on specialized domains for which there are only small amounts of carefully curated training data. In these cases, accuracy may be improved by fine-tuning an existing deep network previously trained on a much larger labeled vision dataset, such as images from ImageNet (Russakovsky et al., 2015) or videos from Sports-1M (Karpathy et al., 2014). While transfer learning of this form supports state of the art accuracy, inference is expensive due to the time, power, and memory demanded by the heavyweight architecture of the fine-tuned network.\nWhile modern deep CNNs are composed of a variety of layer types, runtime during prediction is dominated by the evaluation of convolutional layers. With the goal of speeding up inference, we prune entire feature maps so the resulting networks may be run efficiently even on embedded devices. We interleave greedy criteria-based pruning with fine-tuning by backpropagation, a computationally efficient procedure that maintains good generalization in the pruned network.\nNeural network pruning was pioneered in the early development of neural networks (Reed, 1993). Optimal Brain Damage (LeCun et al., 1990) and Optimal Brain Surgeon (Hassibi & Stork, 1993) leverage a second-order Taylor expansion to select parameters for deletion, using pruning as regularization to improve training and generalization. This method requires computation of the Hessian matrix partially or completely, which adds memory and computation costs to standard fine-tuning.\nIn line with our work, Anwar et al. (2015) describe structured pruning in convolutional layers at the level of feature maps and kernels, as well as strided sparsity to prune with regularity within kernels. Pruning is accomplished by particle filtering wherein configurations are weighted by misclassification rate. The method demonstrates good results on small CNNs, but larger CNNs are not addressed.\nHan et al. (2015) introduce a simpler approach by fine-tuning with a strong `2 regularization term and dropping parameters with values below a predefined threshold. Such unstructured pruning is very effective for network compression, and this approach demonstrates good performance for intra-kernel pruning. But compression may not translate directly to faster inference since modern hardware\nexploits regularities in computation for high throughput. So specialized hardware may be needed for efficient inference of a network with intra-kernel sparsity (Han et al., 2016). This approach also requires long fine-tuning times that may exceed the original network training by a factor of 3 or larger. Group sparsity based regularization of network parameters was proposed to penalize unimportant parameters (Wen et al., 2016; Zhou et al., 2016; Alvarez & Salzmann, 2016; Lebedev & Lempitsky, 2016). Regularization-based pruning techniques require per layer sensitivity analysis which adds extra computations. In contrast, our approach relies on global rescaling of criteria for all layers and does not require sensitivity estimation. Moreover, our approach is faster as we directly prune unimportant parameters instead of waiting for their values to be made sufficiently small by optimization under regularization.\nOther approaches include combining parameters with correlated weights (Srinivas & Babu, 2015), reducing precision (Gupta et al., 2015; Rastegari et al., 2016) or tensor decomposition (Kim et al., 2015). These approaches usually require a separate training procedure or significant fine-tuning, but potentially may be combined with our method for additional speedups.\n2 METHOD\nThe proposed method for pruning consists of the following steps: 1) Fine-tune the network until convergence on the target task; 2) Alternate iterations of pruning and further fine-tuning; 3) Stop pruning after reaching the target trade-off between accuracy and pruning objective, e.g. floating point operations (FLOPs) or memory utilization.\nThe procedure is simple, but its success hinges on employing the right pruning criterion. In this section, we introduce several efficient pruning criteria and related technical considerations.\nConsider a set of training examples D = { X =\n{x0,x1, ...,xN},Y = {y0, y1, ..., yN} }\n, where x and y represent an input and a target output, respectively. The network’s parameters1W = {(w11, b11), (w21, b21), ...(w C` L , b C` L )} are optimized to minimize a cost value C(D|W). The most common choice for a cost function C(·) is a negative log-likelihood function. A cost function is selected independently of pruning and depends only on the task to be solved by the original network. In the case of transfer learning, we adapt a large network initialized with parametersW0 pretrained on a related but distinct dataset.\nDuring pruning, we refine a subset of parameters which preserves the accuracy of the adapted network, C(D|W ′) ≈ C(D|W). This corresponds to a combinatorial optimization:\nmin W′ ∣∣∣∣C(D|W ′)− C(D|W)∣∣∣∣ s.t. ||W ′||0 ≤ B, (1) where the `0 norm in ||W ′||0 bounds the number of non-zero parameters B in W ′. Intuitively, if W ′ = W we reach the global minimum of the error function, however ||W ′||0 will also have its maximum.\nFinding a good subset of parameters while maintaining a cost value as close as possible to the original is a combinatorial problem. It will require 2|W| evaluations of the cost function for a selected subset of data. For current networks it would be impossible to compute: for example, VGG-16 has |W| = 4224 convolutional feature maps. While it is impossible to solve this optimization exactly for networks of any reasonable size, in this work we investigate a class of greedy methods. Starting with a full set of parametersW , we iteratively identify and remove the least important parameters, as illustrated in Figure 1. By removing parameters at each iteration, we ensure the eventual satisfaction of the `0 bound onW ′.\n1A “parameter” (w, b) ∈ W might represent an individual weight, a convolutional kernel, or the entire set of kernels that compute a feature map; our experiments operate at the level of feature maps.\nSince we focus our analysis on pruning feature maps from convolutional layers, let us denote a set of image feature maps by z` ∈ RH`×W`×C` with dimensionality H` ×W` and C` individual maps (or channels).2 The feature maps can either be the input to the network, z0, or the output from a convolutional layer, z` with ` ∈ [1, 2, ..., L]. Individual feature maps are denoted z(k)` for k ∈ [1, 2, ..., C`]. A convolutional layer ` applies the convolution operation (∗) to a set of input feature maps z`−1 with kernels parameterized by w (k) ` ∈ RC`−1×p×p:\nz (k) ` = g (k) ` R ( z`−1 ∗w(k)` + b (k) ` ) , (2)\nwhere z(k)` ∈ RH`×W` is the result of convolving each ofC`−1 kernels of size p×p with its respective input feature map and adding bias b(k)` . We introduce a pruning gate gl ∈ {0, 1}Cl , an external switch which determines if a particular feature map is included or pruned during feed-forward propagation, such that when g is vectorized: W ′ = gW ."
    }, {
      "heading" : "2.1 ORACLE PRUNING",
      "text" : "Minimizing the difference in accuracy between the full and pruned models depends on the criterion for identifying the “least important” parameters, called saliency, at each step. The best criterion would be an exact empirical evaluation of each parameter, which we denote the oracle criterion, accomplished by ablating each non-zero parameter w ∈ W ′ in turn and recording the cost’s difference. We distinguish two ways of using this oracle estimation of importance: 1) oracle-loss quantifies importance as the signed change in loss, C(D|W ′)− C(D|W), and 2) oracle-abs adopts the absolute difference, |C(D|W ′) − C(D|W)|. While both discourage pruning which increases the loss, the oracle-loss version encourages pruning which may decrease the loss, while oracle-abs penalizes any pruning in proportion to its change in loss, regardless of the direction of change.\nWhile the oracle is optimal for this greedy procedure, it is prohibitively costly to compute, requiring ||W ′||0 evaluations on a training dataset, one evaluation for each remaining non-zero parameter. Since estimation of parameter importance is key to both the accuracy and the efficiency of this pruning approach, we propose and evaluate several criteria in terms of performance and estimation cost."
    }, {
      "heading" : "2.2 CRITERIA FOR PRUNING",
      "text" : "There are many heuristic criteria which are much more computationally efficient than the oracle. For the specific case of evaluating the importance of a feature map (and implicitly the set of convolutional kernels from which it is computed), reasonable criteria include: the combined `2-norm of the kernel weights, the mean, standard deviation or percentage of the feature map’s activation, and mutual information between activations and predictions. We describe these criteria in the following paragraphs and propose a new criterion which is based on the Taylor expansion.\nMinimum weight. Pruning by magnitude of kernel weights is perhaps the simplest possible criterion, and it does not require any additional computation during the fine-tuning process. In case of pruning according to the norm of a set of weights, the criterion is evaluated as: ΘMW : RC`−1×p×p → R, with ΘMW (w) = 1|w| ∑ i w 2 i , where |w| is dimensionality of the set of weights after vectorization. The motivation to apply this type of pruning is that a convolutional kernel with low `2 norm detects less important features than those with a high norm. This can be aided during training by applying `1 or `2 regularization, which will push unimportant kernels to have smaller values.\nActivation. One of the reasons for the popularity of the ReLU activation is the sparsity in activation that is induced, allowing convolutional layers to act as feature detectors. Therefore it is reasonable to assume that if an activation value (an output feature map) is small then this feature detector is not important for prediction task at hand. We may evaluate this by mean activation, ΘMA : RHl×W`×C` → R, with ΘMA(a) = 1|a| ∑ i ai for activation a = z (k) l , or by the standard deviation\nof the activation, ΘMA_std(a) = √ 1 |a| ∑ i(ai − µa)2.\n2While our notation is at times specific to 2D convolutions, the methods are applicable to 3D convolutions, as well as fully connected layers.\nMutual information. Mutual information (MI) is a measure of how much information is present in one variable about another variable. We apply MI as a criterion for pruning, ΘMI : RHl×W`×C` → R, with ΘMI(a) = MI(a, y), where y is the target of neural network. MI is defined for continuous variables, so to simplify computation, we exchange it with information gain (IG), which is defined for quantized variables IG(y|x) = H(x) +H(y)−H(x, y), where H(x) is the entropy of variable x. We accumulate statistics on activations and ground truth for a number of updates, then quantize the values and compute IG.\nTaylor expansion. We phrase pruning as an optimization problem, trying to findW ′ with bounded number of non-zero elements that minimize ∣∣∆C(hi)∣∣ = |C(D|W ′)− C(D|W)|. With this approach based on the Taylor expansion, we directly approximate change in the loss function from removing a particular parameter. Let hi be the output produced from parameter i. In the case of feature maps, h = {z(1)0 , z (2) 0 , ..., z (C`) L }. For notational convenience, we consider the cost function equally dependent on parameters and outputs computed from parameters: C(D|hi) = C(D|(w, b)i). Assuming independence of parameters, we have:∣∣∆C(hi)∣∣ = ∣∣C(D, hi = 0)− C(D, hi)∣∣, (3) where C(D, hi = 0) is a cost value if output hi is pruned, while C(D, hi) is the cost if it is not pruned. While parameters are in reality inter-dependent, we already make an independence assumption at each gradient step during training.\nTo approximate ∆C(hi), we use the first-degree Taylor polynomial. For a function f(x), the Taylor expansion at point x = a is\nf(x) = P∑ p=0 f (p)(a) p! (x− a)p +Rp(x), (4)\nwhere f (p)(a) is the p-th derivative of f evaluated at point a, and Rp(x) is the p-th order remainder. Approximating C(D, hi = 0) with a first-order Taylor polynomial near hi = 0, we have:\nC(D, hi = 0) = C(D, hi)− δC δhi hi +R1(hi = 0). (5)\nThe remainder R1(hi = 0) can be calculated through the Lagrange form:\nR1(hi = 0) = δ2C\nδ(h2i = ξ)\nh2i 2 , (6)\nwhere ξ is a real number between 0 and hi. However, we neglect this first-order remainder, largely due to the significant calculation required, but also in part because the widely-used ReLU activation function encourages a smaller second order term. Finally, by substituting Eq. (5) into Eq. (3) and ignoring the remainder, we have ΘTE : RHl×Wl×Cl → R+, with\nΘTE(hi) = ∣∣∆C(hi)∣∣ = ∣∣C(D, hi)− δC\nδhi hi − C(D, hi) ∣∣ = ∣∣∣∣ δCδhihi ∣∣∣∣. (7)\nIntuitively, this criterion prunes parameters that have an almost flat gradient of the cost function w.r.t. feature map hi. This approach requires accumulation of the product of the activation and the gradient of the cost function w.r.t. to the activation, which is easily computed from the same computations for back-propagation. ΘTE is computed for a multi-variate output, such as a feature map, by\nΘTE(z (k) l ) = ∣∣∣∣ 1M ∑ m δC δz (k) l,m z (k) l,m ∣∣∣∣, (8) where M is length of vectorized feature map. For a minibatch with T > 1 examples, the criterion is computed for each example separately and averaged over T .\nIndependently of our work, Figurnov et al. (2016) came up with similar metric based on the Taylor expansion, called impact, to evaluate importance of spatial cells in a convolutional layer. It shows that the same metric can be applied to evaluate importance of different groups of parameters.\nRelation to Optimal Brain Damage. The Taylor criterion proposed above relies on approximating the change in loss caused by removing a feature map. The core idea is the same as in Optimal Brain Damage (OBD) (LeCun et al., 1990). Here we consider the differences more carefully.\nThe primary difference is the treatment of the first-order term of the Taylor expansion, in our notation y = δCδhh for cost function C and hidden layer activation h. After sufficient training epochs, the gradient term tends to zero: δCδh → 0 and E(y) = 0. At face value y offers little useful information, hence OBD regards the term as zero and focuses on the second-order term.\nHowever, the variance of y is non-zero and correlates with the stability of the local function w.r.t. activation h. By considering the absolute change in the cost3 induced by pruning (as in Eq. 3), we use the absolute value of the first-order term, |y|. Under assumption that samples come from independent and identical distribution, E(|y|) = σ √ 2/ √ π where σ is the standard deviation of y, known as the expected value of the half-normal distribution. So, while y tends to zero, the expectation of |y| is proportional to the variance of y, a value which is empirically more informative as a pruning criterion.\nAs an additional benefit, we avoid the computation of the second-order Taylor expansion term, or its simplification - diagonal of the Hessian, as required in OBD.\nWe found important to compare proposed Taylor criteria to OBD. As described in the original papers (LeCun et al., 1990; 1998), OBD can be efficiently implemented similarly to standard back propagation algorithm doubling backward propagation time and memory usage when used together with standard fine-tuning. Efficient implementation of the original OBD algorithm might require significant changes to the framework based on automatic differentiation like Theano to efficiently compute only diagonal of the Hessian instead of the full matrix. Several researchers tried to tackle this problem with approximation techniques (Martens, 2010; Martens et al., 2012). In our implementation, we use efficient way of computing Hessian-vector product (Pearlmutter, 1994) and matrix diagonal approximation proposed by (Bekas et al., 2007), please refer to more details in appendix. With current implementation, OBD is 30 times slower than Taylor technique for saliency estimation, and 3 times slower for iterative pruning, however with different implementation can only be 50% slower as mentioned in the original paper.\nAverage Percentage of Zeros (APoZ). Hu et al. (2016) proposed to explore sparsity in activations for network pruning. ReLU activation function imposes sparsity during inference, and average percentage of positive activations at the output can determine importance of the neuron. Intuitively, it is a good criteria, however feature maps at the first layers have similar APoZ regardless of the network’s target as they learn to be Gabor like filters. We will use APoZ to estimate saliency of feature maps."
    }, {
      "heading" : "2.3 NORMALIZATION",
      "text" : "Some criteria return “raw” values, whose scale varies with the depth of the parameter’s layer in the network. A simple layer-wise `2-normalization can achieve adequate rescaling across layers:\nΘ̂(z (k) l )= Θ(z (k) l )√∑\nj\n( Θ(z (j) l ) )2 ."
    }, {
      "heading" : "2.4 FLOPS REGULARIZED PRUNING",
      "text" : "One of the main reasons to apply pruning is to reduce number of operations in the network. Feature maps from different layers require different amounts of computation due the number and sizes of input feature maps and convolution kernels. To take this into account we introduce FLOPs regularization:\nΘ(z (k) l ) = Θ(z (k) l )− λΘ flops l , (9)\nwhere λ controls the amount of regularization. For our experiments, we use λ = 10−3. Θflops is computed under the assumption that convolution is implemented as a sliding window (see Appendix). Other regularization conditions may be applied, e.g. storage size, kernel sizes, or memory footprint.\n3OBD approximates the signed difference in loss, while our method approximates absolute difference in loss. We find in our results that pruning based on absolute difference yields better accuracy."
    }, {
      "heading" : "3 RESULTS",
      "text" : "We empirically study the pruning criteria and procedure detailed in the previous section for a variety of problems. We focus many experiments on transfer learning problems, a setting where pruning seems to excel. We also present results for pruning large networks on their original tasks for more direct comparison with the existing pruning literature. Experiments are performed within Theano (Theano Development Team, 2016). Training and pruning are performed on the respective training sets for each problem, while results are reported on appropriate holdout sets, unless otherwise indicated. For all experiments we prune a single feature map at every pruning iteration, allowing fine-tuning and re-evaluation of the criterion to account for dependency between parameters."
    }, {
      "heading" : "3.1 CHARACTERIZING THE ORACLE RANKING",
      "text" : "We begin by explicitly computing the oracle for a single pruning iteration of a visual transfer learning problem. We fine-tune the VGG-16 network (Simonyan & Zisserman, 2014) for classification of bird species using the Caltech-UCSD Birds 200-2011 dataset (Wah et al., 2011). The dataset consists of nearly 6000 training images and 5700 test images, covering 200 species. We fine-tune VGG-16 for 60 epochs with learning rate 0.0001 to achieve a test accuracy of 72.2% using uncropped images.\nTo compute the oracle, we evaluate the change in loss caused by removing each individual feature map from the fine-tuned VGG-16 network. (See Appendix A.3 for additional analysis.) We rank feature maps by their contributions to the loss, where rank 1 indicates the most important feature map—removing it results in the highest increase in loss—and rank 4224 indicates the least important. Statistics of global ranks are shown in Fig. 2 grouped by convolutional layer. We observe: (1) Median global importance tends to decrease with depth. (2) Layers with max-pooling tend to be more important than those without. (VGG-16 has pooling after layers 2, 4, 7, 10, and 13.) However, (3) maximum and minimum ranks show that every layer has some feature maps that are globally important and others that are globally less important. Taken together with the results of subsequent experiments, we opt for encouraging a balanced pruning that distributes selection across all layers.\nNext, we iteratively prune the network using pre-computed oracle ranking. In this experiment, we do not update the parameters of the network or the oracle ranking between iterations. Training accuracy is illustrated in Fig. 3 over many pruning iterations. Surprisingly, pruning by smallest absolute change in loss (Oracle-abs) yields higher accuracy than pruning by the net effect on loss (Oracle-loss). Even though the oracle indicates that removing some feature maps individually may decrease loss, instability accumulates due the large absolute changes that are induced. These results support pruning by absolute difference in cost, as constructed in Eq. 1."
    }, {
      "heading" : "3.2 EVALUATING PROPOSED CRITERIA VERSUS THE ORACLE",
      "text" : "To evaluate computationally efficient criteria as substitutes for the oracle, we compute Spearman’s rank correlation, an estimate of how well two predictors provide monotonically related outputs,\neven if their relationship is not linear. Given the difference between oracle4 and criterion ranks di = rank(Θoracle(i))−rank(Θcriterion(i)) for each parameter i, the rank correlation is computed:\nS = 1− 6 N(N2 − 1) N∑ i=1 di 2, (10)\nwhere N is the number of parameters (and the highest rank). This correlation coefficient takes values in [−1, 1], where −1 implies full negative correlation, 0 no correlation, and 1 full positive correlation. We show Spearman’s correlation in Table 1 to compare the oracle-abs ranking to rankings by different criteria on a set of networks/datasets some of which are going to be introduced later. Data-dependent criteria (all except weight magnitude) are computed on training data during the fine-tuning before or between pruning iterations. As a sanity check, we evaluate random ranking and observe 0.0 correlation across all layers. “Per layer” analysis shows ranking within each convolutional layer, while “All layers” describes ranking across layers. While several criteria do not scale well across layers with raw values, a layer-wise `2-normalization significantly improves performance. The Taylor criterion has the highest correlation among the criteria, both within layers and across layers (with `2 normalization). OBD shows the best correlation across layers when no normalization used; it also shows best results for correlation on ImageNet dataset. (See Appendix A.2 for further analysis.)"
    }, {
      "heading" : "3.3 PRUNING FINE-TUNED IMAGENET NETWORKS",
      "text" : "We now evaluate the full iterative pruning procedure on two transfer learning problems. We focus on reducing the number of convolutional feature maps and the total estimated floating point operations (FLOPs). Fine-grained recognition is difficult for relatively small datasets without relying on transfer\n4We use Oracle-abs because of better performance in previous experiment\nlearning. Branson et al. (2014) show that training CNN from scratch on the Birds-200 dataset achieves test accuracy of only 10.9%. We compare results to training a randomly initialized CNN with half the number of parameters per layer, denoted \"from scratch\".\nFig. 4 shows pruning of VGG-16 after fine-tuning on the Birds-200 dataset (as described previously). At each pruning iteration, we remove a single feature map and then perform 30 minibatch SGD updates with batch-size 32, momentum 0.9, learning rate 10−4, and weight decay 10−4. The figure depicts accuracy relative to the pruning rate (left) and estimated GFLOPs (right). The Taylor criterion shows the highest accuracy for nearly the entire range of pruning ratios, and with FLOPs regularization demonstrates the best performance relative to the number of operations. OBD shows slightly worse performance of pruning in terms of parameters, however significantly worse in terms of FLOPs.\nIn Fig. 5, we show pruning of the CaffeNet implementation of AlexNet (Krizhevsky et al., 2012) after adapting to the Oxford Flowers 102 dataset (Nilsback & Zisserman, 2008), with 2040 training and 6129 test images from 102 species of flowers. Criteria correlation with oracle-abs is summarized in Table 1. We initially fine-tune the network for 20 epochs using a learning rate of 0.001, achieving a final test accuracy of 80.1%. Then pruning procedes as previously described for Birds-200, except with only 10 mini-batch updates between pruning iterations. We observe the superior performance of the Taylor and OBD criteria in both number of parameters and GFLOPs.\nWe observed that Taylor criterion shows the best performance which is closely followed by OBD with a bit lower Spearman’s rank correlation coefficient. Implementing OBD takes more effort because of computation of diagonal of the Hessian and it is 50% to 300% slower than Taylor criteria that relies on first order gradient only.\nFig. 6 shows pruning with the Taylor technique and a varying number of fine-tuning updates between pruning iterations. Increasing the number of updates results in higher accuracy, but at the cost of additional runtime of the pruning procedure.\nDuring pruning we observe a small drop in accuracy. One of the reasons is fine-tuning between pruning iterations. Accuracy of the initial network can be improved with longer fine tunning and search of better optimization parameters. For example accuracy of unpruned VGG16 network on Birds-200 goes up to 75% after extra 128k updates. And AlexNet on Flowers-102 goes up to 82.9% after 130k updates. It should be noted that with farther fine-tuning of pruned networks we can achieve higher accuracy as well, therefore the one-to-one comparison of accuracies is rough."
    }, {
      "heading" : "3.4 PRUNING A RECURRENT 3D-CNN NETWORK FOR HAND GESTURE RECOGNITION",
      "text" : "Molchanov et al. (2016) learn to recognize 25 dynamic hand gestures in streaming video with a large recurrent neural network. The network is constructed by adding recurrent connections to a 3D-CNN pretrained on the Sports-1M video dataset (Karpathy et al., 2014) and fine tuning on a gesture dataset. The full network achieves an accuracy of 80.7% when trained on the depth modality, but a single inference requires an estimated 37.8 GFLOPs, too much for deployment on an embedded GPU. After several iterations of pruning with the Taylor criterion with learning rate 0.0003, momentum 0.9, FLOPs regularization 10−3, we reduce inference to 3.0 GFLOPs, as shown in Fig. 7. While pruning\nincreases classification error by nearly 6%, additional fine-tuning restores much of the lost accuracy, yielding a final pruned network with a 12.6× reduction in GFLOPs and only a 2.5% loss in accuracy."
    }, {
      "heading" : "3.5 PRUNING NETWORKS FOR IMAGENET",
      "text" : "11.5 and 8 GFLOPs.\nWe also test our pruning scheme on the largescale ImageNet classification task. In the first experiment, we begin with a trained CaffeNet implementation of AlexNet with 79.2% top-5 validation accuracy. Between pruning iterations, we fine-tune with learning rate 10−4, momentum 0.9, weight decay 10−4, batch size 32, and drop-out 50%. Using a subset of 5000 training images, we compute oracle-abs and Spearman’s rank correlation with the criteria, as shown in Table 1. Pruning traces are illustrated in Fig. 8. We observe: 1) Taylor performs better than random or minimum weight pruning when 100 updates are used between pruning iterations. When results are displayed w.r.t. FLOPs, the difference with random pruning is only 0%−4%, but the difference is higher, 1%−10%, when plotted with the number of feature maps pruned. 2) Increasing the number of updates from 100 to 1000 improves performance of pruning significantly for both the Taylor criterion and random pruning."
    }, {
      "heading" : "Hardware Batch Accuracy Time, ms Accuracy Time (speed up) Accuracy Time (speed up)",
      "text" : "For a second experiment, we prune a trained VGG-16 network with the same parameters as before, except enabling FLOPs regularization. We stop pruning at two points, 11.5 and 8.0 GFLOPs, and fine-tune both models for an additional five epochs with learning rate 10−4. Fine-tuning after pruning significantly improves results: the network pruned to 11.5 GFLOPs improves from 83% to 87% top-5 validation accuracy, and the network pruned to 8.0 GFLOPs improves from 77.8% to 84.5%."
    }, {
      "heading" : "3.6 SPEED UP MEASUREMENTS",
      "text" : "During pruning we were measuring reduction in computations by FLOPs, which is a common practice (Han et al., 2015; Lavin, 2015a;b). Improvements in FLOPs result in monotonically decreasing inference time of the networks because of removing entire feature map from the layer. However, time consumed by inference dependents on particular implementation of convolution operator, parallelization algorithm, hardware, scheduling, memory transfer rate etc. Therefore we measure improvement in the inference time for selected networks to see real speed up compared to unpruned networks in Table 2. We observe significant speed ups by proposed pruning scheme."
    }, {
      "heading" : "4 CONCLUSIONS",
      "text" : "We propose a new scheme for iteratively pruning deep convolutional neural networks. We find: 1) CNNs may be successfully pruned by iteratively removing the least important parameters—feature maps in this case—according to heuristic selection criteria; 2) a Taylor expansion-based criterion demonstrates significant improvement over other criteria; 3) per-layer normalization of the criterion is important to obtain global scaling."
    }, {
      "heading" : "A APPENDIX",
      "text" : ""
    }, {
      "heading" : "A.1 FLOPS COMPUTATION",
      "text" : "To compute the number of floating-point operations (FLOPs), we assume convolution is implemented as a sliding window and that the nonlinearity function is computed for free. For convolutional kernels we have:\nFLOPs = 2HW (CinK2 + 1)Cout, (11)\nwhere H , W and Cin are height, width and number of channels of the input feature map, K is the kernel width (assumed to be symmetric), and Cout is the number of output channels.\nFor fully connected layers we compute FLOPs as:\nFLOPs = (2I − 1)O, (12)\nwhere I is the input dimensionality and O is the output dimensionality.\nWe apply FLOPs regularization during pruning to prune neurons with higher FLOPs first. FLOPs per convolutional neuron in every layer:\nVGG16: Θflops = [3.1, 57.8, 14.1, 28.9, 7.0, 14.5, 14.5, 3.5, 7.2, 7.2, 1.8, 1.8, 1.8, 1.8]\nAlexNet: Θflops = [2.3, 1.7, 0.8, 0.6, 0.6]\nR3DCNN: Θflops = [5.6, 86.9, 21.7, 43.4, 5.4, 10.8, 1.4, 1.4]"
    }, {
      "heading" : "A.2 NORMALIZATION ACROSS LAYERS",
      "text" : "Scaling a criterion across layers is very important for pruning. If the criterion is not properly scaled, then a hand-tuned multiplier would need to be selected for each layer. Statistics of feature map ranking by different criteria are shown in Fig. 10. Without normalization (Fig. 14a–14d), the weight magnitude criterion tends to rank feature maps from the first layers more important than last layers; the activation criterion ranks middle layers more important; and Taylor ranks first layers higher. After `2 normalization (Fig. 10d–10f), all criteria have a shape more similar to the oracle, where each layer has some feature maps which are highly important and others which are unimportant."
    }, {
      "heading" : "A.3 ORACLE COMPUTATION FOR VGG-16 ON BIRDS-200",
      "text" : "We compute the change in the loss caused by removing individual feature maps from the VGG-16 network, after fine-tuning on the Birds-200 dataset. Results are illustrated in Fig. 11a-11b for each feature map in layers 1 and 13, respectively. To compute the oracle estimate for a feature map, we remove the feature map and compute the network prediction for each image in the training set using the central crop with no data augmentation or dropout. We draw the following conclusions:\n• The contribution of feature maps range from positive (above the red line) to slightly negative (below the red line), implying the existence of some feature maps which decrease the training cost when removed.\n• There are many feature maps with little contribution to the network output, indicated by almost zero change in loss when removed.\n• Both layers contain a small number of feature maps which induce a significant increase in the loss when removed.\nTable 3 contains a layer-by-layer listing of Spearman’s rank correlation of several criteria with the ranking of oracle-abs. In this more detailed comparison, we see the Taylor criterion shows higher correlation for all individual layers. For several methods including Taylor, the worst correlations are observed for the middle of the network, layers 5-10. We also evaluate several techniques for normalization of the raw criteria values for comparison across layers. The table shows the best performance is obtained by `2 normalization, hence we select it for our method."
    }, {
      "heading" : "A.4 COMPARISON WITH WEIGHT REGULARIZATION",
      "text" : "Han et al. (2015) find that fine-tuning with high `1 or `2 regularization causes unimportant connections to be suppressed. Connections with energy lower than some threshold can be removed on the assumption that they do not contribute much to subsequent layers. The same work also finds that thresholds must be set separately for each layer depending on its sensitivity to pruning. The procedure to evaluate sensitivity is time-consuming as it requires pruning layers independently during evaluation.\nThe idea of pruning with high regularization can be extended to removing the kernels for an entire feature map if the `2 norm of those kernels is below a predefined threshold. We compare our approach with this regularization-based pruning for the task of pruning the last convolutional layer of VGG-16 fine-tuned for Birds-200. By considering only a single layer, we avoid the need to compute layerwise sensitivity. Parameters for optimization during fine-tuning are the same as other experiments with the Birds-200 dataset. For the regularization technique, the pruning threshold is set to σ = 10−5 while we vary the regularization coefficient γ of the `2 norm on each feature map kernel.5 We prune only kernel weights, while keeping the bias to maintain the same expected output.\nA comparison between pruning based on regularization and our greedy scheme is illustrated in Fig. 12. We observe that our approach has higher test accuracy for the same number of remaining unpruned feature maps, when pruning 85% or more of the feature maps. We observe that with high regularization all weights tend to zero, not only unimportant weights as Han et al. (2015) observe in the case of ImageNet networks. The intuition here is that with regularization we push all weights down and potentially can affect important connections for transfer learning, whereas in our iterative procedure we only remove unimportant parameters leaving others untouched."
    }, {
      "heading" : "A.5 COMBINATION OF CRITERIA",
      "text" : "One of the possibilities to improve saliency estimation is to combine several criteria together. One of the straight forward combinations is Taylor and mean activation of the neuron. We compute the joint criteria as Θjoint(z (k) l ) = (1− λ)Θ̂Taylor(z (k) l ) + λΘ̂Activation(z (k) l ) and perform a grid search of parameter λ in Fig.13. The highest correlation value for each dataset is marked with with vertical bar with λ and gain. We observe that the gain of linearly combining criteria is negligibly small (see ∆’s in the figure).\n5In our implementation, the regularization coefficient is multiplied by the learning rate equal to 10−4."
    }, {
      "heading" : "A.6 OPTIMAL BRAIN DAMAGE IMPLEMENTATION",
      "text" : "OBD computes saliency of a parameter by computing a product of the squared magnitude of the parameter and the corresponding element on the diagonal of the Hessian. For many deep learning frameworks, an efficient implementation of the diagonal evaluation is not straightforward and approximation techniques must be applied. Our implementation of Hessian diagonal computation was inspired by Dauphin et al. (2015) work, where the technique proposed by Bekas et al. (2007) was used to evaluate SGD preconditioned with the Jacobi preconditioner. It was shown that diagonal of the Hessian can be approximated as:\ndiag(H) = E[v Hv] = E[v ∇(∇C · v)], (13)\nwhere is the element-wise product, v are random vectors with entries ±1, and ∇ is the gradient operator. To compute saliency with OBD, we randomly draw v and compute the diagonal over 10 iterations for a single minibatch for 1000 mini batches. We found that this number of mini batches is required to compute close approximation of the Hessian’s diagonal (which we verified). Computing saliency this way is computationally expensive for iterative pruning, and we use a slightly different but more efficient procedure. Before the first pruning iteration, saliency is initialized from values computed off-line with 1000 minibatches and 10 iterations, as described above. Then, at every minibatch we compute the OBD criteria with only one iteration and apply an exponential moving averaging with a coefficient of 0.99. We verified that this computes a close approximation to the Hessian’s diagonal."
    }, {
      "heading" : "A.7 CORRELATION OF TAYLOR CRITERION WITH GRADIENT AND ACTIVATION",
      "text" : "The Taylor criterion is composed of both an activation term and a gradient term. In Figure 14, we depict the correlation between the Taylor criterion and each constituent part. We consider expected absolute value of the gradient instead of the mean, because otherwise it tends to zero. The plots are computed from pruning criteria for an unpruned VGG network fine-tuned for the Birds-200 dataset. (Values are shown after layer-wise normalization). Figure 14(a-b) depict the Taylor criterion in the y-axis for all neurons w.r.t. the gradient and activation components, respectively. The bottom 10% of neurons (lowest Taylor criterion, most likely to be pruned) are depicted in red, while the top 10% are shown in green. Considering all neurons, both gradient and activation components demonstrate a linear trend with the Taylor criterion. However, for the bottom 10% of neurons, as shown in Figure 14(c-d), the activation criterion shows much stronger correlation, with lower activations indicating lower Taylor scores."
    } ],
    "references" : [ {
      "title" : "Learning the Number of Neurons in Deep Networks",
      "author" : [ "Jose M Alvarez", "Mathieu Salzmann" ],
      "venue" : "Advances in Neural Information Processing Systems",
      "citeRegEx" : "Alvarez and Salzmann.,? \\Q2016\\E",
      "shortCiteRegEx" : "Alvarez and Salzmann.",
      "year" : 2016
    }, {
      "title" : "Structured pruning of deep convolutional neural networks",
      "author" : [ "Sajid Anwar", "Kyuyeon Hwang", "Wonyong Sung" ],
      "venue" : "arXiv preprint arXiv:1512.08571,",
      "citeRegEx" : "Anwar et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Anwar et al\\.",
      "year" : 2015
    }, {
      "title" : "An estimator for the diagonal of a matrix",
      "author" : [ "Costas Bekas", "Effrosyni Kokiopoulou", "Yousef Saad" ],
      "venue" : "Applied numerical mathematics,",
      "citeRegEx" : "Bekas et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Bekas et al\\.",
      "year" : 2007
    }, {
      "title" : "Bird species categorization using pose normalized deep convolutional nets",
      "author" : [ "Steve Branson", "Grant Van Horn", "Serge Belongie", "Pietro Perona" ],
      "venue" : "arXiv preprint arXiv:1406.2952,",
      "citeRegEx" : "Branson et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Branson et al\\.",
      "year" : 2014
    }, {
      "title" : "Equilibrated adaptive learning rates for nonconvex optimization",
      "author" : [ "Yann Dauphin", "Harm de Vries", "Yoshua Bengio" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Dauphin et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Dauphin et al\\.",
      "year" : 2015
    }, {
      "title" : "PerforatedCNNs: Acceleration through elimination of redundant convolutions",
      "author" : [ "Mikhail Figurnov", "Aizhan Ibraimova", "Dmitry P Vetrov", "Pushmeet Kohli" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Figurnov et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Figurnov et al\\.",
      "year" : 2016
    }, {
      "title" : "Deep learning with limited numerical precision",
      "author" : [ "Suyog Gupta", "Ankur Agrawal", "Kailash Gopalakrishnan", "Pritish Narayanan" ],
      "venue" : "CoRR, abs/1502.02551,",
      "citeRegEx" : "Gupta et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Gupta et al\\.",
      "year" : 2015
    }, {
      "title" : "Learning both weights and connections for efficient neural network",
      "author" : [ "Song Han", "Jeff Pool", "John Tran", "William Dally" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Han et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Han et al\\.",
      "year" : 2015
    }, {
      "title" : "EIE: Efficient inference engine on compressed deep neural network",
      "author" : [ "Song Han", "Xingyu Liu", "Huizi Mao", "Jing Pu", "Ardavan Pedram", "Mark A. Horowitz", "William J. Dally" ],
      "venue" : "In Proceedings of the 43rd International Symposium on Computer Architecture,",
      "citeRegEx" : "Han et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Han et al\\.",
      "year" : 2016
    }, {
      "title" : "Second order derivatives for network pruning: Optimal brain surgeon",
      "author" : [ "Babak Hassibi", "David G. Stork" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "Hassibi and Stork.,? \\Q1993\\E",
      "shortCiteRegEx" : "Hassibi and Stork.",
      "year" : 1993
    }, {
      "title" : "Network trimming: A data-driven neuron pruning approach towards efficient deep architectures",
      "author" : [ "Hengyuan Hu", "Rui Peng", "Yu-Wing Tai", "Chi-Keung Tang" ],
      "venue" : "arXiv preprint arXiv:1607.03250,",
      "citeRegEx" : "Hu et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Hu et al\\.",
      "year" : 2016
    }, {
      "title" : "Large-scale video classification with convolutional neural networks",
      "author" : [ "Andrej Karpathy", "George Toderici", "Sanketh Shetty", "Thomas Leung", "Rahul Sukthankar", "Li Fei-Fei" ],
      "venue" : "In CVPR,",
      "citeRegEx" : "Karpathy et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Karpathy et al\\.",
      "year" : 2014
    }, {
      "title" : "Compression of deep convolutional neural networks for fast and low power mobile applications",
      "author" : [ "Yong-Deok Kim", "Eunhyeok Park", "Sungjoo Yoo", "Taelim Choi", "Lu Yang", "Dongjun Shin" ],
      "venue" : "In Proceedings of the International Conference on Learning Representations (ICLR),",
      "citeRegEx" : "Kim et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Kim et al\\.",
      "year" : 2015
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks. In Advances in neural information processing",
      "author" : [ "Alex Krizhevsky", "Ilya Sutskever", "Geoffrey E Hinton" ],
      "venue" : null,
      "citeRegEx" : "Krizhevsky et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Krizhevsky et al\\.",
      "year" : 2012
    }, {
      "title" : "maxDNN: An Efficient Convolution Kernel for Deep Learning with Maxwell",
      "author" : [ "Andrew Lavin" ],
      "venue" : "GPUs. CoRR,",
      "citeRegEx" : "Lavin.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lavin.",
      "year" : 2015
    }, {
      "title" : "Fast algorithms for convolutional neural networks",
      "author" : [ "Andrew Lavin" ],
      "venue" : "arXiv preprint arXiv:1509.09308,",
      "citeRegEx" : "Lavin.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lavin.",
      "year" : 2015
    }, {
      "title" : "Fast convnets using group-wise brain damage",
      "author" : [ "Vadim Lebedev", "Victor Lempitsky" ],
      "venue" : "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
      "citeRegEx" : "Lebedev and Lempitsky.,? \\Q2016\\E",
      "shortCiteRegEx" : "Lebedev and Lempitsky.",
      "year" : 2016
    }, {
      "title" : "Optimal brain damage",
      "author" : [ "Yann LeCun", "J.S. Denker", "S. Solla", "R.E. Howard", "L.D. Jackel" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "LeCun et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "LeCun et al\\.",
      "year" : 1990
    }, {
      "title" : "Efficient BackProp, pp. 9–50",
      "author" : [ "Yann LeCun", "Leon Bottou", "Genevieve B. Orr", "Klaus Robert Müller" ],
      "venue" : null,
      "citeRegEx" : "LeCun et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "LeCun et al\\.",
      "year" : 1998
    }, {
      "title" : "Deep learning via Hessian-free optimization",
      "author" : [ "James Martens" ],
      "venue" : "In Proceedings of the 27th International Conference on Machine Learning",
      "citeRegEx" : "Martens.,? \\Q2010\\E",
      "shortCiteRegEx" : "Martens.",
      "year" : 2010
    }, {
      "title" : "Estimating the Hessian by back-propagating curvature",
      "author" : [ "James Martens", "Ilya Sutskever", "Kevin Swersky" ],
      "venue" : "arXiv preprint arXiv:1206.6464,",
      "citeRegEx" : "Martens et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Martens et al\\.",
      "year" : 2012
    }, {
      "title" : "Online detection and classification of dynamic hand gestures with recurrent 3d convolutional neural network",
      "author" : [ "Pavlo Molchanov", "Xiaodong Yang", "Shalini Gupta", "Kihwan Kim", "Stephen Tyree", "Jan Kautz" ],
      "venue" : "In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR),",
      "citeRegEx" : "Molchanov et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Molchanov et al\\.",
      "year" : 2016
    }, {
      "title" : "Automated flower classification over a large number of classes",
      "author" : [ "M-E. Nilsback", "A. Zisserman" ],
      "venue" : "In Proceedings of the Indian Conference on Computer Vision, Graphics and Image Processing,",
      "citeRegEx" : "Nilsback and Zisserman.,? \\Q2008\\E",
      "shortCiteRegEx" : "Nilsback and Zisserman.",
      "year" : 2008
    }, {
      "title" : "Fast Exact Multiplication by the Hessian",
      "author" : [ "Barak A. Pearlmutter" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "Pearlmutter.,? \\Q1994\\E",
      "shortCiteRegEx" : "Pearlmutter.",
      "year" : 1994
    }, {
      "title" : "XNOR-Net: ImageNet Classification",
      "author" : [ "Mohammad Rastegari", "Vicente Ordonez", "Joseph Redmon", "Ali Farhadi" ],
      "venue" : "Using Binary Convolutional Neural Networks. CoRR,",
      "citeRegEx" : "Rastegari et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Rastegari et al\\.",
      "year" : 2016
    }, {
      "title" : "Pruning algorithms-a survey",
      "author" : [ "Russell Reed" ],
      "venue" : "IEEE transactions on Neural Networks,",
      "citeRegEx" : "Reed.,? \\Q1993\\E",
      "shortCiteRegEx" : "Reed.",
      "year" : 1993
    }, {
      "title" : "ImageNet Large Scale Visual Recognition Challenge",
      "author" : [ "Olga Russakovsky", "Jia Deng", "Hao Su", "Jonathan Krause", "Sanjeev Satheesh", "Sean Ma", "Zhiheng Huang", "Andrej Karpathy", "Aditya Khosla", "Michael Bernstein", "Alexander C. Berg", "Li Fei-Fei" ],
      "venue" : "International Journal of Computer Vision (IJCV),",
      "citeRegEx" : "Russakovsky et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Russakovsky et al\\.",
      "year" : 2015
    }, {
      "title" : "Very deep convolutional networks for large-scale image recognition",
      "author" : [ "K. Simonyan", "A. Zisserman" ],
      "venue" : "CoRR, abs/1409.1556,",
      "citeRegEx" : "Simonyan and Zisserman.,? \\Q2014\\E",
      "shortCiteRegEx" : "Simonyan and Zisserman.",
      "year" : 2014
    }, {
      "title" : "Data-free parameter pruning for deep neural networks",
      "author" : [ "Suraj Srinivas", "R. Venkatesh Babu" ],
      "venue" : "Proceedings of the British Machine Vision Conference (BMVC),",
      "citeRegEx" : "Srinivas and Babu.,? \\Q2015\\E",
      "shortCiteRegEx" : "Srinivas and Babu.",
      "year" : 2015
    }, {
      "title" : "Learning structured sparsity in deep neural networks",
      "author" : [ "Wei Wen", "Chunpeng Wu", "Yandan Wang", "Yiran Chen", "Hai Li" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Wen et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Wen et al\\.",
      "year" : 2016
    }, {
      "title" : "Less is more: Towards compact cnns",
      "author" : [ "Hao Zhou", "Jose M. Alvarez", "Fatih Porikli" ],
      "venue" : "In European Conference on Computer Vision,",
      "citeRegEx" : "Zhou et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Zhou et al\\.",
      "year" : 2016
    }, {
      "title" : "A comparison between pruning based on regularization and our greedy scheme is illustrated in Fig. 12. We observe that our approach has higher test accuracy for the same number of remaining unpruned feature maps, when pruning 85% or more of the feature maps",
      "author" : [ "Han" ],
      "venue" : null,
      "citeRegEx" : "Han,? \\Q2015\\E",
      "shortCiteRegEx" : "Han",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 26,
      "context" : "In these cases, accuracy may be improved by fine-tuning an existing deep network previously trained on a much larger labeled vision dataset, such as images from ImageNet (Russakovsky et al., 2015) or videos from Sports-1M (Karpathy et al.",
      "startOffset" : 170,
      "endOffset" : 196
    }, {
      "referenceID" : 11,
      "context" : ", 2015) or videos from Sports-1M (Karpathy et al., 2014).",
      "startOffset" : 33,
      "endOffset" : 56
    }, {
      "referenceID" : 25,
      "context" : "Neural network pruning was pioneered in the early development of neural networks (Reed, 1993).",
      "startOffset" : 81,
      "endOffset" : 93
    }, {
      "referenceID" : 17,
      "context" : "Optimal Brain Damage (LeCun et al., 1990) and Optimal Brain Surgeon (Hassibi & Stork, 1993) leverage a second-order Taylor expansion to select parameters for deletion, using pruning as regularization to improve training and generalization.",
      "startOffset" : 21,
      "endOffset" : 41
    }, {
      "referenceID" : 1,
      "context" : "In line with our work, Anwar et al. (2015) describe structured pruning in convolutional layers at the level of feature maps and kernels, as well as strided sparsity to prune with regularity within kernels.",
      "startOffset" : 23,
      "endOffset" : 43
    }, {
      "referenceID" : 1,
      "context" : "In line with our work, Anwar et al. (2015) describe structured pruning in convolutional layers at the level of feature maps and kernels, as well as strided sparsity to prune with regularity within kernels. Pruning is accomplished by particle filtering wherein configurations are weighted by misclassification rate. The method demonstrates good results on small CNNs, but larger CNNs are not addressed. Han et al. (2015) introduce a simpler approach by fine-tuning with a strong `2 regularization term and dropping parameters with values below a predefined threshold.",
      "startOffset" : 23,
      "endOffset" : 420
    }, {
      "referenceID" : 8,
      "context" : "So specialized hardware may be needed for efficient inference of a network with intra-kernel sparsity (Han et al., 2016).",
      "startOffset" : 102,
      "endOffset" : 120
    }, {
      "referenceID" : 29,
      "context" : "Group sparsity based regularization of network parameters was proposed to penalize unimportant parameters (Wen et al., 2016; Zhou et al., 2016; Alvarez & Salzmann, 2016; Lebedev & Lempitsky, 2016).",
      "startOffset" : 106,
      "endOffset" : 196
    }, {
      "referenceID" : 30,
      "context" : "Group sparsity based regularization of network parameters was proposed to penalize unimportant parameters (Wen et al., 2016; Zhou et al., 2016; Alvarez & Salzmann, 2016; Lebedev & Lempitsky, 2016).",
      "startOffset" : 106,
      "endOffset" : 196
    }, {
      "referenceID" : 6,
      "context" : "Other approaches include combining parameters with correlated weights (Srinivas & Babu, 2015), reducing precision (Gupta et al., 2015; Rastegari et al., 2016) or tensor decomposition (Kim et al.",
      "startOffset" : 114,
      "endOffset" : 158
    }, {
      "referenceID" : 24,
      "context" : "Other approaches include combining parameters with correlated weights (Srinivas & Babu, 2015), reducing precision (Gupta et al., 2015; Rastegari et al., 2016) or tensor decomposition (Kim et al.",
      "startOffset" : 114,
      "endOffset" : 158
    }, {
      "referenceID" : 12,
      "context" : ", 2016) or tensor decomposition (Kim et al., 2015).",
      "startOffset" : 32,
      "endOffset" : 50
    }, {
      "referenceID" : 5,
      "context" : "Independently of our work, Figurnov et al. (2016) came up with similar metric based on the Taylor expansion, called impact, to evaluate importance of spatial cells in a convolutional layer.",
      "startOffset" : 27,
      "endOffset" : 50
    }, {
      "referenceID" : 17,
      "context" : "The core idea is the same as in Optimal Brain Damage (OBD) (LeCun et al., 1990).",
      "startOffset" : 59,
      "endOffset" : 79
    }, {
      "referenceID" : 17,
      "context" : "As described in the original papers (LeCun et al., 1990; 1998), OBD can be efficiently implemented similarly to standard back propagation algorithm doubling backward propagation time and memory usage when used together with standard fine-tuning.",
      "startOffset" : 36,
      "endOffset" : 62
    }, {
      "referenceID" : 19,
      "context" : "Several researchers tried to tackle this problem with approximation techniques (Martens, 2010; Martens et al., 2012).",
      "startOffset" : 79,
      "endOffset" : 116
    }, {
      "referenceID" : 20,
      "context" : "Several researchers tried to tackle this problem with approximation techniques (Martens, 2010; Martens et al., 2012).",
      "startOffset" : 79,
      "endOffset" : 116
    }, {
      "referenceID" : 23,
      "context" : "In our implementation, we use efficient way of computing Hessian-vector product (Pearlmutter, 1994) and matrix diagonal approximation proposed by (Bekas et al.",
      "startOffset" : 80,
      "endOffset" : 99
    }, {
      "referenceID" : 2,
      "context" : "In our implementation, we use efficient way of computing Hessian-vector product (Pearlmutter, 1994) and matrix diagonal approximation proposed by (Bekas et al., 2007), please refer to more details in appendix.",
      "startOffset" : 146,
      "endOffset" : 166
    }, {
      "referenceID" : 10,
      "context" : "Hu et al. (2016) proposed to explore sparsity in activations for network pruning.",
      "startOffset" : 0,
      "endOffset" : 17
    }, {
      "referenceID" : 13,
      "context" : "5, we show pruning of the CaffeNet implementation of AlexNet (Krizhevsky et al., 2012) after adapting to the Oxford Flowers 102 dataset (Nilsback & Zisserman, 2008), with 2040 training and 6129 test images from 102 species of flowers.",
      "startOffset" : 61,
      "endOffset" : 86
    }, {
      "referenceID" : 3,
      "context" : "Branson et al. (2014) show that training CNN from scratch on the Birds-200 dataset achieves test accuracy of only 10.",
      "startOffset" : 0,
      "endOffset" : 22
    }, {
      "referenceID" : 11,
      "context" : "The network is constructed by adding recurrent connections to a 3D-CNN pretrained on the Sports-1M video dataset (Karpathy et al., 2014) and fine tuning on a gesture dataset.",
      "startOffset" : 113,
      "endOffset" : 136
    }, {
      "referenceID" : 21,
      "context" : "Figure 7: Pruning of a recurrent 3D-CNN for dynamic hand gesture recognition (Molchanov et al., 2016).",
      "startOffset" : 77,
      "endOffset" : 101
    } ],
    "year" : 2017,
    "abstractText" : "We propose a new formulation for pruning convolutional kernels in neural networks to enable efficient inference. We interleave greedy criteria-based pruning with finetuning by backpropagation—a computationally efficient procedure that maintains good generalization in the pruned network. We propose a new criterion based on Taylor expansion that approximates the change in the cost function induced by pruning network parameters. We focus on transfer learning, where large pretrained networks are adapted to specialized tasks. The proposed criterion demonstrates superior performance compared to other criteria, e.g. the norm of kernel weights or feature map activation, for pruning large CNNs after adaptation to fine-grained classification tasks (Birds-200 and Flowers-102) relaying only on the first order gradient information. We also show that pruning can lead to more than 10× theoretical reduction in adapted 3D-convolutional filters with a small drop in accuracy in a recurrent gesture classifier. Finally, we show results for the largescale ImageNet dataset to emphasize the flexibility of our approach.",
    "creator" : "LaTeX with hyperref package"
  }
}