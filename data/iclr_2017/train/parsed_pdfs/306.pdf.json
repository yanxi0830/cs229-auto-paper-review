{
  "name" : "306.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "FEW-SHOT LEARNING", "Sachin Ravi", "Hugo Larochelle" ],
    "emails" : [ "sachinr@twitter.com", "hugo@twitter.com" ],
    "sections" : [ {
      "heading" : "1 INTRODUCTION",
      "text" : "Deep learning has shown great success in a variety of tasks with large amounts of labeled data in image classification (He et al., 2015), machine translation (Wu et al., 2016), and speech modeling (Oord et al., 2016). These achievements have relied on the fact that optimization of these deep, high-capacity models requires many iterative updates across many labeled examples. This type of optimization breaks down in the small data regime where we want to learn from very few labeled examples. In this setting, rather than have one large dataset, we have a set of datasets, each with few annotated examples per class. The motivation for this task lies not only in the fact that humans, even children, can usually generalize after just one example of a given object, but also because models excelling at this task would have many useful applications. Firstly, they would help alleviate data collection as we would not require millions of labeled examples to attain reasonable performance. Furthermore, in many fields, data exhibits the characteristic of having many different classes but few examples per class. Models that are able to generalize from few examples would be able to capture this type of data effectively.\nThere seem to be two main reasons why gradient-based optimization fails in the face of few labeled examples. Firstly, the variants of gradient-based optimization algorithms, such as momentum (Nesterov, 1983), Adagrad (Duchi et al., 2011), Adadelta (Zeiler, 2012), and ADAM (Kingma & Ba, 2014), weren’t designed specifically to perform well under the constraint of a set number of updates. Specifically when applied to non-convex optimization problems, with a reasonable choice of hyperparameters these algorithms don’t have very strong guarantees of speed of convergence, beyond that they will eventually converge to a good solution after what could be many millions of iterations. Secondly, for each separate dataset considered, the network would have to start from a random initialization of its parameters, which considerably hurts its ability to converge to a good solution after a few updates. Transfer learning (Caruana, 1995; Bengio et al., 2012; Donahue et al., 2013) can be applied to alleviate this problem by fine-tuning a pre-trained network from another task which has more labelled data; however, it has been observed that the benefit of a pre-trained network greatly decreases as the task the network was trained on diverges from the target task (Yosinski et al., 2014). What is needed is a systematic way to learn a beneficial common initialization that would\n∗Work done as an intern at Twitter. Sachin is a PhD student at Princeton University and can be reached at sachinr@princeton.edu.\nserve as a good point to start training for the set of datasets being considered. This would provide the same benefits as transfer learning, but with the guarantee that the initialization is an optimal starting point for fine-tuning.\nPrevious work has suggested one manner in which to acquire quick knowledge from few examples, through the idea of meta-learning (Thrun, 1998; Schmidhuber et al., 1997). Meta-learning suggests framing the learning problem at two levels. The first is quick acquisition of knowledge within each separate task presented. This process is guided by the second, which involves slower extraction of information learned across all the tasks.\nWe present a method here that addresses the weakness of neutral networks trained with gradientbased optimization on the few-shot learning problem by framing the problem within a meta-learning setting. We propose an LSTM-based meta-learner optimizer that is trained to optimize a learner neural network classifier. The meta-learner captures both short-term knowledge within a task and long-term knowledge common among all the tasks. By using an objective that directly captures an optimization algorithm’s ability to have good generalization performance given only a set number of updates, the meta-learner model is trained to converge a learner classifier to a good solution quickly on each task. Additionally, the formulation of our meta-learner model allows it to learn a task-common initialization for the learner classifier, which captures fundamental knowledge shared among all the tasks."
    }, {
      "heading" : "2 TASK DESCRIPTION",
      "text" : "We first begin by detailing the meta-learning formulation we use. In the typical machine learning setting, we are interested in a dataset D and usually split D so that we optimize parameters θ on a training set Dtrain and evaluate its generalization on the test set Dtest. In meta-learning, however, we are dealing with meta-sets D containing multiple regular datasets, where each D ∈ D has a split of Dtrain and Dtest.\nWe consider the k-shot, N -class classification task, where for each dataset D, the training set consists of k labelled examples for each of N classes, meaning that Dtrain consists of k ·N examples, and Dtest has a set number of examples for evaluation. We note that previous work (Vinyals et al., 2016) has used the term episode to describe each dataset consisting of a training and test set.\nIn meta-learning, we thus have different meta-sets for meta-training, meta-validation, and metatesting (Dmeta−train, Dmeta−validation, and Dmeta−test, respectively). On Dmeta−train, we are interested in training a learning procedure (the meta-learner) that can take as input one of its training setsDtrain and produce a classifier (the learner) that achieves high average classification performance on its corresponding test setDtest. Using Dmeta−validation we can perform hyper-parameter selection of the meta-learner and evaluate its generalization performance on Dmeta−test.\nFor this formulation to correspond to the few-shot learning setting, each training set in datasets D ∈ D will contain few labeled examples (we consider k = 1 or k = 5), that must be used to generalize to good performance on the corresponding test set. An example of this formulation is given in Figure 1."
    }, {
      "heading" : "3 MODEL",
      "text" : "We now move to the description of our proposed model for meta-learning."
    }, {
      "heading" : "3.1 MODEL DESCRIPTION",
      "text" : "Consider a single dataset, or episode, D ∈ Dmeta−train. Suppose we have a learner neural net classifier with parameters θ that we want to train on Dtrain. The standard optimization algorithms used to train deep neural networks are some variant of gradient descent, which uses updates of the form\nθt = θt−1 − αt∇θt−1Lt, (1)\nwhere θt−1 are the parameters of the learner after t − 1 updates, αt is the learning rate at time t, Lt is the loss optimized by the learner for its tth update, ∇θt−1Lt is the gradient of that loss with respect to parameters θt−1, and θt is the updated parameters of the learner.\nOur key observation that we leverage here is that this update resembles the update for the cell state in an LSTM (Hochreiter & Schmidhuber, 1997)\nct = ft ct−1 + it c̃t, (2) if ft = 1, ct−1 = θt−1, it = αt, and c̃t = −∇θt−1Lt. Thus, we propose training a meta-learner LSTM to learn an update rule for training a neural network. We set the cell state of the LSTM to be the parameters of the learner, or ct = θt, and the candidate cell state c̃t = ∇θt−1Lt, given how valuable information about the gradient is for optimization. We define parametric forms for it and ft so that the meta-learner can determine optimal values through the course of the updates.\nLet us start with it, which corresponds to the learning rate for the updates. We let it = σ ( WI · [ ∇θt−1Lt,Lt, θt−1, it−1 ] + bI ) ,\nmeaning that the learning rate is a function of the current parameter value θt−1, the current gradient ∇θt−1Lt, the current loss Lt, and the previous learning rate it−1. With this information, the metalearner should be able to finely control the learning rate so as to train the learner quickly while avoiding divergence.\nAs for ft, it seems possible that the optimal choice isn’t the constant 1. Intuitively, what would justify shrinking the parameters of the learner and forgetting part of its previous value would be if the learner is currently in a bad local optima and needs a large change to escape. This would correspond to a situation where the loss is high but the gradient is close to zero. Thus, one proposal for the forget gate is to have it be a function of that information, as well as the previous value of the forget gate:\nft = σ ( WF · [ ∇θt−1Lt,Lt, θt−1, ft−1 ] + bF ) .\nAdditionally, notice that we can also learn the initial value of the cell state c0 for the LSTM, treating it as a parameter of the meta-learner. This corresponds to the initial weights of the classifier (that\nthe meta-learner is training). Learning this initial value lets the meta-learner determine the optimal initial weights of the learner so that training begins from a beneficial starting point that allows optimization to proceed rapidly. Lastly, note that though the meta-learner’s update rule matches the cell state update of the LSTM, the meta-learner also bears similarity to the GRU (Cho et al., 2014) hidden state update, with the exception that the forget and input gates aren’t tied to sum to one."
    }, {
      "heading" : "3.2 PARAMETER SHARING & PREPROCESSING",
      "text" : "Because we want our meta-learner to produce updates for deep neural networks, which consist of tens of thousands of parameters, to prevent an explosion of meta-learner parameters we need to employ some sort of parameter sharing. Thus as in Andrychowicz et al. (2016), we share parameters across the coordinates of the learner gradient. This means each coordinate has its own hidden and cell state values but the LSTM parameters are the same across all coordinates. This allows us to use a compact LSTM model and additionally has the nice property that the same update rule is used for each coordinate, but one that is dependent on the respective history of each coordinate during optimization. We can easily implement parameter sharing by having the input be a batch of gradient coordinates and loss inputs (∇θt,iLt,Lt) for each dimension i. Because the different coordinates of the gradients and the losses can be of very different magnitudes, we need to be careful in normalizing the values so that the meta-learner is able to use them properly during training. Thus, we also found that the preprocessing method of Andrychowicz et al. (2016) worked well when applied to both the dimensions of the gradients and the losses at each time step:\nx→\n{( log(|x|) p , sgn(x) ) if |x| ≥ e−p\n(−1, epx) otherwise\nThis preprocessing adjusts the scaling of gradients and losses, while also separating the information about their magnitude and their sign (the latter being mostly useful for gradients). We found that the suggested value of p = 10 in the above formula worked well in our experiments."
    }, {
      "heading" : "3.3 TRAINING",
      "text" : "The question now is how do we train the LSTM meta-learner model to be effective at few-shot learning tasks? As observed in Vinyals et al. (2016), in order to perform well at this task, it is key to have training conditions match those of test time. During evaluation of the meta-learning, for each dataset (episode), D = (Dtrain, Dtest) ∈ Dmeta−test, a good meta-learner model will, given a series of learner gradients and losses on the training set Dtrain, suggest a series of updates for the classifier that pushes it towards good performance on the test set Dtest.\nThus to match test time conditions, when considering each dataset D ∈ Dmeta−train, the training objective we use is the loss Ltest of the produced classifier on D’s test set Dtest. While iterating over the examples in D’s training set Dtrain, at each time step t the LSTM meta-learner receives (∇θt−1Lt,Lt) from the learner (the classifier) and proposes the new set of parameters θt. The process repeats for T steps, after which the classifier and its final parameters are evaluated on the test set to produce the loss that is then used to train the meta-learner. The training algorithm is described in Algorithm 1 and the corresponding computational graph is shown in Figure 2."
    }, {
      "heading" : "3.3.1 GRADIENT INDEPENDENCE ASSUMPTION",
      "text" : "Notice that our formulation would imply that the losses Lt and gradients∇θt−1Lt of the learner are dependent on the parameters of the meta-learner. Gradients on the meta-learner’s parameters should normally take this dependency into account. However, as discussed by Andrychowicz et al. (2016), this complicates the computation of the meta-learner’s gradients. Thus, following Andrychowicz et al. (2016), we make the simplifying assumption that these contributions to the gradients aren’t important and can be ignored, which allows us to avoid taking second derivatives, a considerably expensive operation. We were still able to train the meta-learner effectively in spite of this simplifying assumption."
    }, {
      "heading" : "3.3.2 INITIALIZATION OF META-LEARNER LSTM",
      "text" : "When training LSTMs, it is advised to initialize the LSTM with small random weights and to set the forget gate bias to a large value so that the forget gate is initialized to be close to 1, thus enabling gradient flow (Zaremba, 2015). In addition to the forget gate bias setting, we found that we needed to initialize the input gate bias to be small so that the input gate value (and thus the learning rate) used by the meta-learner LSTM starts out being small. With this combined initialization, the metalearner starts close to normal gradient descent with a small learning rate, which helps initial stability of training."
    }, {
      "heading" : "3.4 BATCH NORMALIZATION",
      "text" : "Batch Normalization (Ioffe & Szegedy, 2015) is a recently proposed method to stabilize and thus speed up learning of deep neural networks by reducing internal covariate shift within the learner’s hidden layers. This reduction is achieved by normalizing each layer’s pre-activation, by subtracting by the mean and dividing by the standard deviation. During training, the mean and standard deviation are estimated using the current batch being trained on, whereas during evaluation a running average of both statistics calculated on the training set is used. We need to be careful with batch normalization for the learner network in the meta-learning setting, because we do not want to collect mean and standard deviation statistics during meta-testing in a way that allows information to leak between different datasets (episodes), being considered. One easy way to prevent this issue is to not collect statistics at all during the meta-testing phase, but just use our running averages from metatraining. This, however, has a bad impact on performance, because we have changed meta-training and meta-testing conditions, causing the meta-learner to learn a method of optimization that relies on batch statistics which it now does not have at meta-testing time. In order to keep the two phases as similar as possible, we found that a better strategy was to collect statistics for each datasetD ∈ D during Dmeta−test, but then erase the running statistics when we consider the next dataset. Thus, during meta-training, we use batch statistics for both the training and testing set whereas during meta-testing, we use batch statistics for the training set (and to compute our running averages) but then use the running averages during testing. This does not cause any information to leak between different datasets, but also allows the meta-learner to be trained on conditions that are matched between training and testing. Lastly, because we are doing very few training steps, we computed the running averages so that higher preference is given to the later values.\nAlgorithm 1 Train Meta-Learner Input: Meta-training set Dmeta−train, Learner M with parameters θ, Meta-Learner R with parameters Θ.\n1: Θ0 ← random initialization 2: 3: for d = 1, n do 4: Dtrain, Dtest ← random dataset from Dmeta−train 5: θ0 ← c0 . Intialize learner parameters 6: 7: for t = 1, T do 8: Xt,Yt ← random batch from Dtrain 9: Lt ← L(M(Xt; θt−1),Yt) . Get loss of learner on train batch 10: ct ← R((∇θt−1Lt,Lt); Θd−1) . Get output of meta-learner using Equation 2 11: θt ← ct . Update learner parameters 12: end for 13: 14: X,Y ← Dtest 15: Ltest ← L(M(X; θT ),Y) . Get loss of learner on test batch 16: Update Θd using∇Θd−1Ltest . Update meta-learner parameters 17: 18: end for"
    }, {
      "heading" : "4 RELATED WORK",
      "text" : "While this work falls within the broad literature of transfer learning in general, we focus here on positioning it relative to previous work on meta-learning and few-shot learning."
    }, {
      "heading" : "4.1 META-LEARNING",
      "text" : "Meta-learning has a long history, but has grown to prominence recently as many have advocated for it as a key to achieving human-level intelligence in the future (Lake et al., 2016). The ability to learn at two levels (learning within each task presented, while accumulating knowledge about the similarities and differences between tasks) is seen as being crucial to improving AI. Previous work has used a variety of techniques in the meta-learning setting.\nSchmidhuber (1992; 1993) explored using networks that learn how to modify their own weights over a number of computations steps on the input. The updating of the weights is defined in a parametric form that allows the prediction and weight-change process to be differentiable end-to-end. The work of Bengio et al. (1990; 1995) and Bengio (1993) considered learning update rules for neural networks that are biologically plausible. This property is enforced by allowing the parametric form of the update to only have as input local information at each hidden unit to determine the weight change. Different optimization methods, such as genetic programming or simulated annealing, are used to train the learning rule.\nIn Santoro et al. (2016), a memory-augmented neural network is trained to learn how to store and retrieve memories to use for each classification task. The work of Andrychowicz et al. (2016) uses an LSTM to train a neural network; however, they are interested in learning a general optimization algorithm to train neural networks for large-scale classification, whereas we are interested in the few-shot learning problem. This work also builds upon Hochreiter et al. (2001) and Bosc, both of which used LSTMs to train multi-layer perceptrons to learn on binary classification and timeseries prediction tasks. Another related method is the work of Bertinetto et al. (2016), who train a meta-learner to map a training example to the weights of a neural network that is then used to classify future examples from this class; however, unlike our method the classifier network is directly produced rather than being fine-tuned after multiple training steps. Our work also bears similarity to Maclaurin et al. (2015), who tune the hyperparameters of gradient descent with momentum by backpropagating through the chain of gradient steps to optimize the validation performance."
    }, {
      "heading" : "4.2 FEW-SHOT LEARNING",
      "text" : "The best performing methods for few-shot learning have been mainly metric learning methods. Deep siamese networks (Koch, 2015) train a convolutional network to embed examples so that items in the same class are close while items in different classes are far away, according to some distance metric. Matching networks (Vinyals et al., 2016) refine this idea so that training and testing conditions match, by defining a differentiable nearest neighbor loss involving the cosine similarities of embeddings produced by a convolutional network."
    }, {
      "heading" : "5 EVALUATION",
      "text" : "In this section, we describe the results of experiments, examining the properties of our model and comparing our method’s performance against different approaches∗. Following Vinyals et al. (2016), we consider the k-shot, N -class classification setting where a meta-learner trains on many related but small training sets of k examples for each of N classes. We first split the list of all classes in the data into disjoint sets and assign them to each meta-set of meta-training, meta-validation, and meta-testing. To generate each instance of a k-shot, N -class task dataset D = (Dtrain, Dtest) ∈ D , we do the following: we first sampleN classes from the list of classes corresponding to the meta-set we consider. We then sample k examples from each of those classes. These k examples together compose the training set Dtrain. Then, an additional fixed amount of the rest of the examples are sampled to yield a test set Dtest. We generally have 15 examples per class in the test sets. When training the meta-learner, we iterate by sampling these datasets (episodes) repeatedly. For metavalidation and meta-testing, however, we produce a fixed number of these datasets to evaluate each method. We produce enough datasets to ensure that the confidence interval of the mean accuracy is small.\nFor the learner, we use a simple CNN containing 4 convolutional layers, each of which is a 3 × 3 convolution with 32 filters, followed by batch normalization, a ReLU non-linearity, and lastly a 2× 2 max-pooling. The network then has a final linear layer followed by a softmax for the number of classes being considered. The loss function L is the average negative log-probability assigned by the learner to the correct class. For the meta-learner, we use a 2-layer LSTM, where the first layer is a normal LSTM and the second layer is our modified LSTM meta-learner. The gradients and losses are preprocessed and fed into the first layer LSTM, and the regular gradient coordinates are also used by the second layer LSTM to implement the state update rule shown in (1). At each time step, the learner’s loss and gradient is computed on a batch consisting of the entire training set Dtrain, because we consider training sets with only a total of 5 or 25 examples. We train our LSTM with ADAM using a learning rate of 0.001 and with gradient clipping using a value of 0.25."
    }, {
      "heading" : "5.1 EXPERIMENT RESULTS",
      "text" : "The Mini-ImageNet dataset was proposed by Vinyals et al. (2016) as a benchmark offering the challenges of the complexity of ImageNet images, without requiring the resources and infrastructure necessary to run on the full ImageNet dataset. Because the exact splits used in Vinyals et al. (2016) were not released, we create our own version of the Mini-Imagenet dataset by selecting a random 100 classes from ImageNet and picking 600 examples of each class. We use 64, 16, and 20 classes for training, validation and testing, respectively. We consider 1-shot and 5-shot classification for 5 classes. We use 15 examples per class for evaluation in each test set. We compare against two baselines and a recent metric-learning technique, Matching Networks (Vinyals et al., 2016), which has achieved state-of-the-art results in few-shot learning. The results are shown in Table 1.\nThe first baseline we use is a nearest-neighbor baseline (Baseline-nearest-neighbor), where we first train a network to classify between all the classes jointly in the original meta-training set. At metatest time, for each dataset D, we embed all the items in the training set using our trained network and then use nearest-neighbor matching among the embedded training examples to classify each test example. The second baseline we use (Baseline-finetune) represents a coarser version of our metalearner model. As in the first baseline, we start by training a network to classify jointly between all classes in the meta-training set. We then use the meta-validation set to search over SGD hyperparameters, where each training set is used to fine-tune the pre-trained network before evaluating on\n∗Code can be found at https://github.com/twitter/meta-learning-lstm.\nthe test set. We use a fixed number of updates for fine tuning and search over the learning rate and learning rate decay used during the course of these updates.\nFor Matching Networks, we implemented our own version of both the basic and the fully-conditional embedding (FCE) versions. In the basic version, a convolutional network is trained to learn independent embeddings for examples in the training and test set. In the FCE version, a bidirectional-LSTM is used to learn an embedding for the training set such that each training example’s embedding is also a function of all the other training examples. Additionally, an attention-LSTM is used so that a test example embedding is also a function of all the embeddings of the training set. We do not consider fine-tuning the network using the train set during meta-testing to improve performance as mentioned in Vinyals et al. (2016), but do note that our meta-learner could also be fine-tuned using this data. Note that to remain consistent with Vinyals et al. (2016), our baseline and matching net convolutional networks have 4 layers each with 64 filters. We also added dropout to each convolutional block in matching nets to prevent overfitting.\nFor our meta-learner, we train different models for the 1-shot and 5-shot tasks, that make 12 and 5 updates, respectively. We noticed that better performance for each task was attained if the metalearner is explicitly trained to do the set number of updates during meta-training that will be used during meta-testing.\nWe attain results that are much better than the baselines discussed and competitive with Matching Networks. For 5-shot, we are able to do much better than Matching Networks, whereas for 1-shot, the confidence interval for our performance intersects the interval for Matching Networks. Again, we note that the numbers do not match the ones provided by Vinyals et al. (2016) simply because we created our version of the dataset and implemented our own versions of their model. It is interesting to note that the fine-tuned baseline is worse than the nearest-neighbor baseline. Because we are not regularizing the classifier, with very few updates the fine-tuning model overfits, especially in the 1-shot case. This propensity to overfit speaks to the benefit of meta-training the initialization of the classifier end-to-end as is done in the meta-learning LSTM."
    }, {
      "heading" : "5.2 VISUALIZATION OF META-LEARNER",
      "text" : "We also visualize the optimization strategy learned by the meta-learner, in Figure 3. We can look at the it and ft gate values in Equation 2 at each update step, to try to get an understanding of how the meta-learner updates the learner during training. We visualize the gate values while training on different datasets Dtrain, to observe whether there are variations between training sets. We consider both 1-shot and 5-shot classification settings, where the meta-learner is making 10 and 5 updates, respectively. For the forget gate values for both tasks, the meta-learner seems to adopt a simple weight decay strategy that seems consistent across different layers. The input gate values are harder to interpret to glean the meta-learner’s strategy. However, there seems to a be a lot of variability between different datasets, indicating that the meta-learner isn’t simply learning a fixed optimization strategy. Additionally, there seem to be differences between the two tasks, suggesting that the meta-learner has adopted different methods to deal with the different conditions of each setting."
    }, {
      "heading" : "6 CONCLUSION",
      "text" : "We described an LSTM-based model for meta-learning, which is inspired from the parameter updates suggested by gradient descent optimization algorithms. Our LSTM meta-learner uses its state to represent the learning updates of the parameters of a classifier. It is trained to discover both a good initialization for the learner’s parameters, as well as a successful mechanism for updating the learner’s parameters to a given small training set for some new classification task. Our experiments demonstrate that our approach outperforms natural baselines and is competitive to the state-of-theart in metric learning for few-shot learning.\nIn this work, we focused our study to the few-shot and few-classes setting. However, it would be more valuable to train meta-learners that can perform well across a full spectrum of settings, i.e. for few or lots of training examples and for few or lots of possible classes. Our future work will thus consider moving towards this more challenging scenario."
    }, {
      "heading" : "ACKNOWLEDGMENTS",
      "text" : "We thank Jake Snell, Kevin Swersky, and Oriol Vinyals for helpful discussions of this work."
    } ],
    "references" : [ {
      "title" : "Learning to learn by gradient descent by gradient descent",
      "author" : [ "Marcin Andrychowicz", "Misha Denil", "Sergio Gomez", "Matthew W. Hoffman", "David Pfau", "Tom Schaul", "Nando de Freitas" ],
      "venue" : "CoRR, abs/1606.04474,",
      "citeRegEx" : "Andrychowicz et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Andrychowicz et al\\.",
      "year" : 2016
    }, {
      "title" : "Optimisation d’une régle d’apprentissage pour réseaux de neurones artificiels",
      "author" : [ "Samy Bengio" ],
      "venue" : "PhD thesis, Département d’Informatique et Recherche Opérationnelle. Université de Montréal,",
      "citeRegEx" : "Bengio.,? \\Q1993\\E",
      "shortCiteRegEx" : "Bengio.",
      "year" : 1993
    }, {
      "title" : "On the search for new learning rules for ANNs",
      "author" : [ "Samy Bengio", "Yoshua Bengio", "Jocelyn Cloutier" ],
      "venue" : "Neural Processing Letters,",
      "citeRegEx" : "Bengio et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Bengio et al\\.",
      "year" : 1995
    }, {
      "title" : "Learning a synaptic learning",
      "author" : [ "Yoshua Bengio", "Samy Bengio", "Jocelyn Cloutier" ],
      "venue" : "rule. Université de Montréal, Département d’informatique et de recherche opérationnelle,",
      "citeRegEx" : "Bengio et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "Bengio et al\\.",
      "year" : 1990
    }, {
      "title" : "Deep learning of representations for unsupervised and transfer learning",
      "author" : [ "Yoshua Bengio" ],
      "venue" : "ICML Unsupervised and Transfer Learning,",
      "citeRegEx" : "Bengio,? \\Q2012\\E",
      "shortCiteRegEx" : "Bengio",
      "year" : 2012
    }, {
      "title" : "Learning feed-forward one-shot learners",
      "author" : [ "Luca Bertinetto", "João F. Henriques", "Jack Valmadre", "Philip H.S. Torr", "Andrea Vedaldi" ],
      "venue" : "CoRR, abs/1606.05233,",
      "citeRegEx" : "Bertinetto et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Bertinetto et al\\.",
      "year" : 2016
    }, {
      "title" : "Learning many related tasks at the same time with backpropagation",
      "author" : [ "Rich Caruana" ],
      "venue" : "Advances in neural information processing systems,",
      "citeRegEx" : "Caruana.,? \\Q1995\\E",
      "shortCiteRegEx" : "Caruana.",
      "year" : 1995
    }, {
      "title" : "Learning phrase representations using RNN encoder-decoder for statistical machine translation",
      "author" : [ "Kyunghyun Cho", "Bart van Merrienboer", "Çaglar Gülçehre", "Fethi Bougares", "Holger Schwenk", "Yoshua Bengio" ],
      "venue" : "CoRR, abs/1406.1078,",
      "citeRegEx" : "Cho et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Cho et al\\.",
      "year" : 2014
    }, {
      "title" : "Decaf: A deep convolutional activation feature for generic visual recognition",
      "author" : [ "Jeff Donahue", "Yangqing Jia", "Oriol Vinyals", "Judy Hoffman", "Ning Zhang", "Eric Tzeng", "Trevor Darrell" ],
      "venue" : "CoRR, abs/1310.1531,",
      "citeRegEx" : "Donahue et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Donahue et al\\.",
      "year" : 2013
    }, {
      "title" : "Adaptive subgradient methods for online learning and stochastic optimization",
      "author" : [ "John Duchi", "Elad Hazan", "Yoram Singer" ],
      "venue" : "J. Mach. Learn. Res.,",
      "citeRegEx" : "Duchi et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Duchi et al\\.",
      "year" : 2011
    }, {
      "title" : "Deep residual learning for image recognition",
      "author" : [ "Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun" ],
      "venue" : "CoRR, abs/1512.03385,",
      "citeRegEx" : "He et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "He et al\\.",
      "year" : 2015
    }, {
      "title" : "Long short-term memory",
      "author" : [ "Sepp Hochreiter", "Jürgen Schmidhuber" ],
      "venue" : "Neural computation,",
      "citeRegEx" : "Hochreiter and Schmidhuber.,? \\Q1997\\E",
      "shortCiteRegEx" : "Hochreiter and Schmidhuber.",
      "year" : 1997
    }, {
      "title" : "Learning to learn using gradient descent",
      "author" : [ "Sepp Hochreiter", "A. Steven Younger", "Peter R. Conwell" ],
      "venue" : "In IN LECTURE NOTES ON COMP",
      "citeRegEx" : "Hochreiter et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Hochreiter et al\\.",
      "year" : 2001
    }, {
      "title" : "Batch normalization: Accelerating deep network training by reducing internal covariate",
      "author" : [ "Sergey Ioffe", "Christian Szegedy" ],
      "venue" : "shift. CoRR,",
      "citeRegEx" : "Ioffe and Szegedy.,? \\Q2015\\E",
      "shortCiteRegEx" : "Ioffe and Szegedy.",
      "year" : 2015
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "Diederik P. Kingma", "Jimmy Ba" ],
      "venue" : "CoRR, abs/1412.6980,",
      "citeRegEx" : "Kingma and Ba.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kingma and Ba.",
      "year" : 2014
    }, {
      "title" : "Siamese neural networks for one-shot image recognition",
      "author" : [ "Gregory Koch" ],
      "venue" : "PhD thesis, University of Toronto,",
      "citeRegEx" : "Koch.,? \\Q2015\\E",
      "shortCiteRegEx" : "Koch.",
      "year" : 2015
    }, {
      "title" : "Building machines that learn and think like people",
      "author" : [ "Brenden M. Lake", "Tomer D. Ullman", "Joshua B. Tenenbaum", "Samuel J. Gershman" ],
      "venue" : "CoRR, abs/1604.00289,",
      "citeRegEx" : "Lake et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Lake et al\\.",
      "year" : 2016
    }, {
      "title" : "Gradient-based hyperparameter optimization through reversible learning",
      "author" : [ "Dougal Maclaurin", "David Duvenaud", "Ryan P Adams" ],
      "venue" : "In Proceedings of the 32nd International Conference on Machine Learning,",
      "citeRegEx" : "Maclaurin et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Maclaurin et al\\.",
      "year" : 2015
    }, {
      "title" : "A method of solving a convex programming problem with convergence rate o (1/k2)",
      "author" : [ "Yurii Nesterov" ],
      "venue" : null,
      "citeRegEx" : "Nesterov.,? \\Q1983\\E",
      "shortCiteRegEx" : "Nesterov.",
      "year" : 1983
    }, {
      "title" : "Wavenet: A generative model for raw audio",
      "author" : [ "Aaron van den Oord", "Sander Dieleman", "Heiga Zen", "Karen Simonyan", "Oriol Vinyals", "Alex Graves", "Nal Kalchbrenner", "Andrew Senior", "Koray Kavukcuoglu" ],
      "venue" : "arXiv preprint arXiv:1609.03499,",
      "citeRegEx" : "Oord et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Oord et al\\.",
      "year" : 2016
    }, {
      "title" : "Oneshot learning with memory-augmented neural networks",
      "author" : [ "Adam Santoro", "Sergey Bartunov", "Matthew Botvinick", "Daan Wierstra", "Timothy P. Lillicrap" ],
      "venue" : "CoRR, abs/1605.06065,",
      "citeRegEx" : "Santoro et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Santoro et al\\.",
      "year" : 2016
    }, {
      "title" : "Learning to control fast-weight memories: An alternative to dynamic recurrent networks",
      "author" : [ "Jürgen Schmidhuber" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "Schmidhuber.,? \\Q1992\\E",
      "shortCiteRegEx" : "Schmidhuber.",
      "year" : 1992
    }, {
      "title" : "A neural network that embeds its own meta-levels",
      "author" : [ "Jürgen Schmidhuber" ],
      "venue" : "In Neural Networks,",
      "citeRegEx" : "Schmidhuber.,? \\Q1993\\E",
      "shortCiteRegEx" : "Schmidhuber.",
      "year" : 1993
    }, {
      "title" : "Shifting inductive bias with success-story algorithm, adaptive levin search, and incremental self-improvement",
      "author" : [ "Jürgen Schmidhuber", "Jieyu Zhao", "Marco Wiering" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Schmidhuber et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Schmidhuber et al\\.",
      "year" : 1997
    }, {
      "title" : "Lifelong learning algorithms",
      "author" : [ "Sebastian Thrun" ],
      "venue" : "In Learning to learn,",
      "citeRegEx" : "Thrun.,? \\Q1998\\E",
      "shortCiteRegEx" : "Thrun.",
      "year" : 1998
    }, {
      "title" : "Matching networks for one shot learning",
      "author" : [ "Oriol Vinyals", "Charles Blundell", "Timothy P. Lillicrap", "Koray Kavukcuoglu", "Daan Wierstra" ],
      "venue" : "CoRR, abs/1606.04080,",
      "citeRegEx" : "Vinyals et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Vinyals et al\\.",
      "year" : 2016
    }, {
      "title" : "Google’s neural machine translation system: Bridging the gap between human and machine translation",
      "author" : [ "Yonghui Wu", "Mike Schuster", "Zhifeng Chen", "Quoc V Le", "Mohammad Norouzi", "Wolfgang Macherey", "Maxim Krikun", "Yuan Cao", "Qin Gao", "Klaus Macherey" ],
      "venue" : "arXiv preprint arXiv:1609.08144,",
      "citeRegEx" : "Wu et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Wu et al\\.",
      "year" : 2016
    }, {
      "title" : "How transferable are features in deep neural networks",
      "author" : [ "Jason Yosinski", "Jeff Clune", "Yoshua Bengio", "Hod Lipson" ],
      "venue" : "CoRR, abs/1411.1792,",
      "citeRegEx" : "Yosinski et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Yosinski et al\\.",
      "year" : 2014
    }, {
      "title" : "An empirical exploration of recurrent network architectures",
      "author" : [ "Wojciech Zaremba" ],
      "venue" : null,
      "citeRegEx" : "Zaremba.,? \\Q2015\\E",
      "shortCiteRegEx" : "Zaremba.",
      "year" : 2015
    }, {
      "title" : "ADADELTA: an adaptive learning rate method",
      "author" : [ "Matthew D. Zeiler" ],
      "venue" : "CoRR, abs/1212.5701,",
      "citeRegEx" : "Zeiler.,? \\Q2012\\E",
      "shortCiteRegEx" : "Zeiler.",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 10,
      "context" : "Deep learning has shown great success in a variety of tasks with large amounts of labeled data in image classification (He et al., 2015), machine translation (Wu et al.",
      "startOffset" : 119,
      "endOffset" : 136
    }, {
      "referenceID" : 26,
      "context" : ", 2015), machine translation (Wu et al., 2016), and speech modeling (Oord et al.",
      "startOffset" : 29,
      "endOffset" : 46
    }, {
      "referenceID" : 19,
      "context" : ", 2016), and speech modeling (Oord et al., 2016).",
      "startOffset" : 29,
      "endOffset" : 48
    }, {
      "referenceID" : 18,
      "context" : "Firstly, the variants of gradient-based optimization algorithms, such as momentum (Nesterov, 1983), Adagrad (Duchi et al.",
      "startOffset" : 82,
      "endOffset" : 98
    }, {
      "referenceID" : 9,
      "context" : "Firstly, the variants of gradient-based optimization algorithms, such as momentum (Nesterov, 1983), Adagrad (Duchi et al., 2011), Adadelta (Zeiler, 2012), and ADAM (Kingma & Ba, 2014), weren’t designed specifically to perform well under the constraint of a set number of updates.",
      "startOffset" : 108,
      "endOffset" : 128
    }, {
      "referenceID" : 29,
      "context" : ", 2011), Adadelta (Zeiler, 2012), and ADAM (Kingma & Ba, 2014), weren’t designed specifically to perform well under the constraint of a set number of updates.",
      "startOffset" : 18,
      "endOffset" : 32
    }, {
      "referenceID" : 6,
      "context" : "Transfer learning (Caruana, 1995; Bengio et al., 2012; Donahue et al., 2013) can be applied to alleviate this problem by fine-tuning a pre-trained network from another task which has more labelled data; however, it has been observed that the benefit of a pre-trained network greatly decreases as the task the network was trained on diverges from the target task (Yosinski et al.",
      "startOffset" : 18,
      "endOffset" : 76
    }, {
      "referenceID" : 8,
      "context" : "Transfer learning (Caruana, 1995; Bengio et al., 2012; Donahue et al., 2013) can be applied to alleviate this problem by fine-tuning a pre-trained network from another task which has more labelled data; however, it has been observed that the benefit of a pre-trained network greatly decreases as the task the network was trained on diverges from the target task (Yosinski et al.",
      "startOffset" : 18,
      "endOffset" : 76
    }, {
      "referenceID" : 27,
      "context" : ", 2013) can be applied to alleviate this problem by fine-tuning a pre-trained network from another task which has more labelled data; however, it has been observed that the benefit of a pre-trained network greatly decreases as the task the network was trained on diverges from the target task (Yosinski et al., 2014).",
      "startOffset" : 293,
      "endOffset" : 316
    }, {
      "referenceID" : 24,
      "context" : "Previous work has suggested one manner in which to acquire quick knowledge from few examples, through the idea of meta-learning (Thrun, 1998; Schmidhuber et al., 1997).",
      "startOffset" : 128,
      "endOffset" : 167
    }, {
      "referenceID" : 23,
      "context" : "Previous work has suggested one manner in which to acquire quick knowledge from few examples, through the idea of meta-learning (Thrun, 1998; Schmidhuber et al., 1997).",
      "startOffset" : 128,
      "endOffset" : 167
    }, {
      "referenceID" : 25,
      "context" : "We note that previous work (Vinyals et al., 2016) has used the term episode to describe each dataset consisting of a training and test set.",
      "startOffset" : 27,
      "endOffset" : 49
    }, {
      "referenceID" : 7,
      "context" : "Lastly, note that though the meta-learner’s update rule matches the cell state update of the LSTM, the meta-learner also bears similarity to the GRU (Cho et al., 2014) hidden state update, with the exception that the forget and input gates aren’t tied to sum to one.",
      "startOffset" : 149,
      "endOffset" : 167
    }, {
      "referenceID" : 0,
      "context" : "Thus as in Andrychowicz et al. (2016), we share parameters across the coordinates of the learner gradient.",
      "startOffset" : 11,
      "endOffset" : 38
    }, {
      "referenceID" : 0,
      "context" : "Thus as in Andrychowicz et al. (2016), we share parameters across the coordinates of the learner gradient. This means each coordinate has its own hidden and cell state values but the LSTM parameters are the same across all coordinates. This allows us to use a compact LSTM model and additionally has the nice property that the same update rule is used for each coordinate, but one that is dependent on the respective history of each coordinate during optimization. We can easily implement parameter sharing by having the input be a batch of gradient coordinates and loss inputs (∇θt,iLt,Lt) for each dimension i. Because the different coordinates of the gradients and the losses can be of very different magnitudes, we need to be careful in normalizing the values so that the meta-learner is able to use them properly during training. Thus, we also found that the preprocessing method of Andrychowicz et al. (2016) worked well when applied to both the dimensions of the gradients and the losses at each time step:",
      "startOffset" : 11,
      "endOffset" : 915
    }, {
      "referenceID" : 25,
      "context" : "The question now is how do we train the LSTM meta-learner model to be effective at few-shot learning tasks? As observed in Vinyals et al. (2016), in order to perform well at this task, it is key to have training conditions match those of test time.",
      "startOffset" : 123,
      "endOffset" : 145
    }, {
      "referenceID" : 0,
      "context" : "However, as discussed by Andrychowicz et al. (2016), this complicates the computation of the meta-learner’s gradients.",
      "startOffset" : 25,
      "endOffset" : 52
    }, {
      "referenceID" : 0,
      "context" : "However, as discussed by Andrychowicz et al. (2016), this complicates the computation of the meta-learner’s gradients. Thus, following Andrychowicz et al. (2016), we make the simplifying assumption that these contributions to the gradients aren’t important and can be ignored, which allows us to avoid taking second derivatives, a considerably expensive operation.",
      "startOffset" : 25,
      "endOffset" : 162
    }, {
      "referenceID" : 28,
      "context" : "When training LSTMs, it is advised to initialize the LSTM with small random weights and to set the forget gate bias to a large value so that the forget gate is initialized to be close to 1, thus enabling gradient flow (Zaremba, 2015).",
      "startOffset" : 218,
      "endOffset" : 233
    }, {
      "referenceID" : 16,
      "context" : "Meta-learning has a long history, but has grown to prominence recently as many have advocated for it as a key to achieving human-level intelligence in the future (Lake et al., 2016).",
      "startOffset" : 162,
      "endOffset" : 181
    }, {
      "referenceID" : 1,
      "context" : "The work of Bengio et al. (1990; 1995) and Bengio (1993) considered learning update rules for neural networks that are biologically plausible.",
      "startOffset" : 12,
      "endOffset" : 57
    }, {
      "referenceID" : 16,
      "context" : "In Santoro et al. (2016), a memory-augmented neural network is trained to learn how to store and retrieve memories to use for each classification task.",
      "startOffset" : 3,
      "endOffset" : 25
    }, {
      "referenceID" : 0,
      "context" : "The work of Andrychowicz et al. (2016) uses an LSTM to train a neural network; however, they are interested in learning a general optimization algorithm to train neural networks for large-scale classification, whereas we are interested in the few-shot learning problem.",
      "startOffset" : 12,
      "endOffset" : 39
    }, {
      "referenceID" : 0,
      "context" : "The work of Andrychowicz et al. (2016) uses an LSTM to train a neural network; however, they are interested in learning a general optimization algorithm to train neural networks for large-scale classification, whereas we are interested in the few-shot learning problem. This work also builds upon Hochreiter et al. (2001) and Bosc, both of which used LSTMs to train multi-layer perceptrons to learn on binary classification and timeseries prediction tasks.",
      "startOffset" : 12,
      "endOffset" : 322
    }, {
      "referenceID" : 0,
      "context" : "The work of Andrychowicz et al. (2016) uses an LSTM to train a neural network; however, they are interested in learning a general optimization algorithm to train neural networks for large-scale classification, whereas we are interested in the few-shot learning problem. This work also builds upon Hochreiter et al. (2001) and Bosc, both of which used LSTMs to train multi-layer perceptrons to learn on binary classification and timeseries prediction tasks. Another related method is the work of Bertinetto et al. (2016), who train a meta-learner to map a training example to the weights of a neural network that is then used to classify future examples from this class; however, unlike our method the classifier network is directly produced rather than being fine-tuned after multiple training steps.",
      "startOffset" : 12,
      "endOffset" : 520
    }, {
      "referenceID" : 0,
      "context" : "The work of Andrychowicz et al. (2016) uses an LSTM to train a neural network; however, they are interested in learning a general optimization algorithm to train neural networks for large-scale classification, whereas we are interested in the few-shot learning problem. This work also builds upon Hochreiter et al. (2001) and Bosc, both of which used LSTMs to train multi-layer perceptrons to learn on binary classification and timeseries prediction tasks. Another related method is the work of Bertinetto et al. (2016), who train a meta-learner to map a training example to the weights of a neural network that is then used to classify future examples from this class; however, unlike our method the classifier network is directly produced rather than being fine-tuned after multiple training steps. Our work also bears similarity to Maclaurin et al. (2015), who tune the hyperparameters of gradient descent with momentum by backpropagating through the chain of gradient steps to optimize the validation performance.",
      "startOffset" : 12,
      "endOffset" : 859
    }, {
      "referenceID" : 15,
      "context" : "Deep siamese networks (Koch, 2015) train a convolutional network to embed examples so that items in the same class are close while items in different classes are far away, according to some distance metric.",
      "startOffset" : 22,
      "endOffset" : 34
    }, {
      "referenceID" : 25,
      "context" : "Matching networks (Vinyals et al., 2016) refine this idea so that training and testing conditions match, by defining a differentiable nearest neighbor loss involving the cosine similarities of embeddings produced by a convolutional network.",
      "startOffset" : 18,
      "endOffset" : 40
    }, {
      "referenceID" : 25,
      "context" : "Following Vinyals et al. (2016), we consider the k-shot, N -class classification setting where a meta-learner trains on many related but small training sets of k examples for each of N classes.",
      "startOffset" : 10,
      "endOffset" : 32
    }, {
      "referenceID" : 25,
      "context" : "We compare against two baselines and a recent metric-learning technique, Matching Networks (Vinyals et al., 2016), which has achieved state-of-the-art results in few-shot learning.",
      "startOffset" : 91,
      "endOffset" : 113
    }, {
      "referenceID" : 25,
      "context" : "The Mini-ImageNet dataset was proposed by Vinyals et al. (2016) as a benchmark offering the challenges of the complexity of ImageNet images, without requiring the resources and infrastructure necessary to run on the full ImageNet dataset.",
      "startOffset" : 42,
      "endOffset" : 64
    }, {
      "referenceID" : 25,
      "context" : "The Mini-ImageNet dataset was proposed by Vinyals et al. (2016) as a benchmark offering the challenges of the complexity of ImageNet images, without requiring the resources and infrastructure necessary to run on the full ImageNet dataset. Because the exact splits used in Vinyals et al. (2016) were not released, we create our own version of the Mini-Imagenet dataset by selecting a random 100 classes from ImageNet and picking 600 examples of each class.",
      "startOffset" : 42,
      "endOffset" : 294
    }, {
      "referenceID" : 25,
      "context" : "We do not consider fine-tuning the network using the train set during meta-testing to improve performance as mentioned in Vinyals et al. (2016), but do note that our meta-learner could also be fine-tuned using this data.",
      "startOffset" : 122,
      "endOffset" : 144
    }, {
      "referenceID" : 25,
      "context" : "We do not consider fine-tuning the network using the train set during meta-testing to improve performance as mentioned in Vinyals et al. (2016), but do note that our meta-learner could also be fine-tuned using this data. Note that to remain consistent with Vinyals et al. (2016), our baseline and matching net convolutional networks have 4 layers each with 64 filters.",
      "startOffset" : 122,
      "endOffset" : 279
    }, {
      "referenceID" : 25,
      "context" : "Again, we note that the numbers do not match the ones provided by Vinyals et al. (2016) simply because we created our version of the dataset and implemented our own versions of their model.",
      "startOffset" : 66,
      "endOffset" : 88
    } ],
    "year" : 2017,
    "abstractText" : "Though deep neural networks have shown great success in the large data domain, they generally perform poorly on few-shot learning tasks, where a classifier has to quickly generalize after seeing very few examples from each class. The general belief is that gradient-based optimization in high capacity classifiers requires many iterative steps over many examples to perform well. Here, we propose an LSTMbased meta-learner model to learn the exact optimization algorithm used to train another learner neural network classifier in the few-shot regime. The parametrization of our model allows it to learn appropriate parameter updates specifically for the scenario where a set amount of updates will be made, while also learning a general initialization of the learner (classifier) network that allows for quick convergence of training. We demonstrate that this meta-learning model is competitive with deep metric-learning techniques for few-shot learning.",
    "creator" : "LaTeX with hyperref package"
  }
}