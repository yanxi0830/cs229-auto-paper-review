{
  "name" : "673.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "HIERARCHICAL MEMORY NETWORKS",
    "authors" : [ "Sarath Chandar", "Sungjin Ahn", "Hugo Larochelle", "Pascal Vincent", "Gerald Tesauro", "Yoshua Bengio" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 INTRODUCTION",
      "text" : "Until recently, traditional machine learning approaches for challenging tasks such as image captioning, object detection, or machine translation have consisted in complex pipelines of algorithms, each being separately tuned for better performance. With the recent success of neural networks and deep learning research, it has now become possible to train a single model end-to-end, using backpropagation. Such end-to-end systems often outperform traditional approaches, since the entire model is directly optimized with respect to the final task at hand. However, simple encode-decode style neural networks often underperform on knowledge-based reasoning tasks like question-answering or dialog systems. Indeed, in such cases it is nearly impossible for regular neural networks to store all the necessary knowledge in their parameters.\nNeural networks with memory (Graves et al., 2014; Weston et al., 2015b) can deal with knowledge bases by having an external memory component which can be used to explicitly store knowledge. The memory is accessed by reader and writer functions, which are both made differentiable so that the entire architecture (neural network, reader, writer and memory components) can be trained end-to-end using backpropagation. Memory-based architectures can also be considered as generalizations of RNNs and LSTMs, where the memory is analogous to recurrent hidden states. However they are much richer in structure and can handle very long-term dependencies because once a vector (i.e., a memory) is stored, it is copied from time step to time step and can thus stay there for a very long time (and gradients correspondingly flow back time unhampered).\nThere exists several variants of neural networks with a memory component: Memory Networks (Weston et al., 2015b), Neural Turing Machines (NTM) (Graves et al., 2014), Dynamic Memory Net-\n∗Corresponding author: apsarathchandar@gmail.com\nworks (DMN) (Kumar et al., 2015). They all share five major components: memory, input module, reader, writer, and output module.\nMemory: The memory is an array of cells, each capable of storing a vector. The memory is often initialized with external data (e.g. a database of facts), by filling in its cells with a pre-trained vector representations of that data.\nInput module: The input module is to compute a representation of the input that can be used by other modules.\nWriter: The writer takes the input representation and updates the memory based on it. The writer can be as simple as filling the slots in the memory with input vectors in a sequential way (as often done in memory networks). If the memory is bounded, instead of sequential writing, the writer has to decide where to write and when to rewrite cells (as often done in NTMs).\nReader: Given an input and the current state of the memory, the reader retrieves content from the memory, which will then be used by an output module. This often requires comparing the input’s representation or a function of the recurrent state with memory cells using some scoring function such as a dot product.\nOutput module: Given the content retrieved by the reader, the output module generates a prediction, which often takes the form of a conditional distribution over multiple labels for the output.\nFor the rest of the paper, we will use the name memory network to describe any model which has any form of these five components. We would like to highlight that all the components except the memory are learnable. Depending on the application, any of these components can also be fixed. In this paper, we will focus on the situation where a network does not write and only reads from the memory.\nIn this paper, we focus on the application of memory networks to large-scale tasks. Specifically, we focus on large scale factoid question answering. For this problem, given a large set of facts and a natural language question, the goal of the system is to answer the question by retrieving the supporting fact for that question, from which the answer can be derived. Application of memory networks to this task has been studied by Bordes et al. (2015). However, Bordes et al. (2015) depended on keyword based heuristics to filter the facts to a smaller set which is manageable for training. However heuristics are invariably dataset dependent and we are interested in a more general solution which can be used when the facts are of any structure. One can design soft attention retrieval mechanisms, where a convex combination of all the cells is retrieved or design hard attention retrieval mechanisms where one or few cells from the memory are retrieved. Soft attention is achieved by using softmax over the memory which makes the reader differentiable and hence learning can be done using gradient descent. Hard attention is achieved by using methods like REINFORCE (Williams, 1992), which provides a noisy gradient estimate when discrete stochastic decisions are made by a model.\nBoth soft attention and hard attention have limitations. As the size of the memory grows, soft attention using softmax weighting is not scalable. It is computationally very expensive, since its complexity is linear in the size of the memory. Also, at initialization, gradients are dispersed so much that it can reduce the effectiveness of gradient descent. These problems can be alleviated by a hard attention mechanism, for which the training method of choice is REINFORCE. However, REINFORCE can be brittle due to its high variance and existing variance reduction techniques are complex. Thus, it is rarely used in memory networks (even in cases of a small memory).\nIn this paper, we propose a new memory selection mechanism based on Maximum Inner Product Search (MIPS) which is both scalable and easy to train. This can be considered as a hybrid of soft and hard attention mechanisms. The key idea is to structure the memory in a hierarchical way such that it is easy to perform MIPS, hence the name Hierarchical Memory Network (HMN). HMNs are scalable at both training and inference time. The main contributions of the paper are as follows:\n• We explore hierarchical memory networks, where the memory is organized in a hierarchical fashion, which allows the reader to efficiently access only a subset of the memory.\n• While there are several ways to decide which subset to access, we propose to pose memory access as a maximum inner product search (MIPS) problem.\n• We empirically show that exact MIPS-based algorithms not only enjoy similar convergence as soft attention models, but can even improve the performance of the memory network. • Since exact MIPS is as computationally expensive as a full soft attention model, we propose\nto train the memory networks using approximate MIPS techniques for scalable memory access. • We empirically show that unlike exact MIPS, approximate MIPS algorithms provide a\nspeedup and scalability of training, though at the cost of some performance."
    }, {
      "heading" : "2 HIERARCHICAL MEMORY NETWORKS",
      "text" : "In this section, we describe the proposed Hierarchical Memory Network (HMN). In this paper, HMNs only differ from regular memory networks in two of its components: the memory and the reader.\nMemory: Instead of a flat array of cells for the memory structure, HMNs leverages a hierarchical memory structure. Memory cells are organized into groups and the groups can further be organized into higher level groups. The choice for the memory structure is tightly coupled with the choice of reader, which is essential for fast memory access. We consider three classes of approaches for the memory’s structure: hashing-based approaches, tree-based approaches, and clustering-based approaches. This is explained in detail in the next section.\nReader: The reader in the HMN is different from the readers in flat memory networks. Flat memorybased readers use either soft attention over the entire memory or hard attention that retrieves a single cell. While these mechanisms might work with small memories, with HMNs we are more interested in achieving scalability towards very large memories. So instead, HMN readers use soft attention only over a selected subset of the memory. Selecting memory subsets is guided by a maximum inner product search algorithm, which can exploit the hierarchical structure of the organized memory to retrieve the most relevant facts in sub-linear time. The MIPS-based reader is explained in more detail in the next section.\nIn HMNs, the reader is thus trained to create MIPS queries such that it can retrieve a sufficient set of facts. While most of the standard applications of MIPS (Ram & Gray, 2012; Bachrach et al., 2014; Shrivastava & Li, 2014) so far have focused on settings where both query vector and database (memory) vectors are precomputed and fixed, memory readers in HMNs are learning to do MIPS by updating the input representation such that the result of MIPS retrieval contains the correct fact(s).\n3 MEMORY READER WITH K-MIPS ATTENTION\nIn this section, we describe how the HMN memory reader uses Maximum Inner Product Search (MIPS) during learning and inference.\nWe begin with a formal definition of K-MIPS. Given a set of points X = {x1, . . . , xn} and a query vector q, our goal is to find\nargmax (K) i∈X q >xi (1)\nwhere the argmax(K) returns the indices of the top-K maximum values. In the case of HMNs, X corresponds to the memory and q corresponds to the vector computed by the input module.\nA simple but inefficient solution for K-MIPS involves a linear search over the cells in memory by performing the dot product of q with all the memory cells. While this will return the exact result for K-MIPS, it is too costly to perform when we deal with a large-scale memory. However, in many practical applications, it is often sufficient to have an approximate result for K-MIPS, trading speed-up at the cost of the accuracy. There exist several approximate K-MIPS solutions in the literature (Shrivastava & Li, 2014; 2015; Bachrach et al., 2014; Neyshabur & Srebro, 2015).\nAll the approximate K-MIPS solutions add a form of hierarchical structure to the memory and visit only a subset of the memory cells to find the maximum inner product for a given query. Hashingbased approaches (Shrivastava & Li, 2014; 2015; Neyshabur & Srebro, 2015) hash cells into multiple bins, and given a query they search for K-MIPS cell vectors only in bins that are close to the bin\nassociated with the query. Tree-based approaches (Ram & Gray, 2012; Bachrach et al., 2014) create search trees with cells in the leaves of the tree. Given a query, a path in the tree is followed and MIPS is performed only for the leaf for the chosen path. Clustering-based approaches (Auvolat et al., 2015) cluster cells into multiple clusters (or a hierarchy of clusters) and given a query, they perform MIPS on the centroids of the top few clusters. We refer the readers to (Auvolat et al., 2015) for an extensive comparison of various state-of-the-art approaches for approximate K-MIPS.\nOur proposal is to exploit this rich approximate K-MIPS literature to achieve scalable training and inference in HMNs. Instead of filtering the memory with heuristics, we propose to organize the memory based on approximate K-MIPS algorithms and then train the reader to learn to perform MIPS. Specifically, consider the following softmax over the memory which the reader has to perform for every reading step to retrieve a set of relevant candidates:\nRout = softmax(h(q)M T ) (2)\nwhere h(q) ∈ Rd is the representation of the query, M ∈ RN×d is the memory with N being the total number of cells in the memory. We propose to replace this softmax with softmax(K) which is defined as follows:\nC = argmax(K) h(q)MT (3)\nRout = softmax (K)(h(q)MT ) = softmax(h(q)M [C]T ) (4)\nwhere C is the indices of top-K MIP candidate cells and M [C] is a sub-matrix of M where the rows are indexed by C.\nOne advantage of using the softmax(K) is that it naturally focuses on cells that would normally receive the strongest gradients during learning. That is, in a full softmax, the gradients are otherwise more dispersed across cells, given the large number of cells and despite many contributing a small gradient. As our experiments will show, this results in slower training.\nOne problematic situation when learning with the softmax(K) is when we are at the initial stages of training and the K-MIPS reader is not including the correct fact candidate. To avoid this issue, we always include the correct candidate to the top-K candidates retrieved by the K-MIPS algorithm, effectively performing a fully supervised form of learning.\nDuring training, the reader is updated by backpropagation from the output module, through the subset of memory cells. Additionally, the log-likelihood of the correct fact computed using Ksoftmax is also maximized. This second supervision helps the reader learn to modify the query such that the maximum inner product of the query with respect to the memory will yield the correct supporting fact in the top K candidate set.\nUntil now, we described the exact K-MIPS-based learning framework, which still requires a linear look-up over all memory cells and would be prohibitive for large-scale memories. In such scenarios, we can replace the exact K-MIPS in the training procedure with the approximate K-MIPS. This is achieved by deploying a suitable memory hierarchical structure. The same approximate K-MIPSbased reader can be used during inference stage as well. Of course, approximate K-MIPS algorithms might not return the exact MIPS candidates and will likely to hurt performance, but at the benefit of achieving scalability.\nWhile the memory representation is fixed in this paper, updating the memory along with the query representation should improve the likelihood of choosing the correct fact. However, updating the memory will reduce the precision of the approximate K-MIPS algorithms, since all of them assume that the vectors in the memory are static. Designing efficient dynamic K-MIPS should improve the performance of HMNs even further, a challenge that we hope to address in future work.\n3.1 READER WITH CLUSTERING-BASED APPROXIMATE K-MIPS\nClustering-based approximate K-MIPS was proposed in (Auvolat et al., 2015) and it has been shown to outperform various other state-of-the-art data dependent and data independent approximate KMIPS approaches for inference tasks. As we will show in the experiments section, clustering-based MIPS also performs better when used to training HMNs. Hence, we focus our presentation on the clustering-based approach and propose changes that were found to be helpful for learning HMNs.\nFollowing most of the other approximate K-MIPS algorithms, Auvolat et al. (2015) convert MIPS to Maximum Cosine Similarity Search (MCSS) problem:\nargmax (K) i∈X qTxi ||q|| ||xi|| = argmax (K) i∈X qTxi ||xi||\n(5)\nWhen all the data vectors xi have the same norm, then MCSS is equivalent to MIPS. However, it is often restrictive to have this additional constraint. Instead, Auvolat et al. (2015) append additional dimensions to both query and data vectors to convert MIPS to MCSS. In HMN terminology, this would correspond to adding a few more dimensions to the memory cells and input representations.\nThe algorithm introduces two hyper-parameters, U < 1 and m ∈ N∗. The first step is to scale all the vectors in the memory by the same factor, such that maxi ||xi||2 = U . We then apply two mappings, P and Q, on the memory cells and on the input vector, respectively. These two mappings simply concatenate m new components to the vectors and make the norms of the data points all roughly the same (Shrivastava & Li, 2015). The mappings are defined as follows:\nP (x) = [x, 1/2− ||x||22, 1/2− ||x||42, . . . , 1/2− ||x||2 m\n2 ] (6) Q(x) = [x, 0, 0, . . . , 0] (7)\nWe thus have the following approximation of MIPS by MCSS for any query vector q:\nargmax (K) i q >xi ' argmax(K)i Q(q)>P (xi)\n||Q(q)||2 · ||P (xi)||2 (8)\nOnce we convert MIPS to MCSS, we can use spherical K-means (Zhong, 2005) or its hierarchical version to approximate and speedup the cosine similarity search. Once the memory is clustered, then every read operation requires only K dot-products, where K is the number of cluster centroids.\nSince this is an approximation, it is error-prone. As we are using this approximation for the learning process, this introduces some bias in gradients, which can affect the overall performance of HMN. To alleviate this bias, we propose three simple strategies.\n• Instead of using only the top-K candidates for a single read query, we also add top-K candidates retrieved for every other read query in the mini-batch. This serves two purposes. First, we can do efficient matrix multiplications by leveraging GPUs since all the K-softmax in a minibatch are over the same set of elements. Second, this also helps to decrease the bias introduced by the approximation error.\n• For every read access, instead of only using the top few clusters which has a maximum product with the read query, we also sample some clusters from the rest, based on a probability distribution log-proportional to the dot product with the cluster centroids. This also decreases the bias.\n• We can also sample random blocks of memory and add it to top-K candidates.\nWe empirically investigate the effect of these variations in Section 5.5."
    }, {
      "heading" : "4 RELATED WORK",
      "text" : "Memory networks have been introduced in (Weston et al., 2015b) and have been so far applied to comprehension-based question answering (Weston et al., 2015a; Sukhbaatar et al., 2015), large scale question answering (Bordes et al., 2015) and dialogue systems (Dodge et al., 2015). While (Weston et al., 2015b) considered supervised memory networks in which the correct supporting fact is given during the training stage, (Sukhbaatar et al., 2015) introduced semi-supervised memory networks that can learn the supporting fact by itself. (Kumar et al., 2015; Xiong et al., 2016) introduced Dynamic Memory Networks (DMNs) which can be considered as a memory network with two types of memory: a regular large memory and an episodic memory. Another related class of model is the Neural Turing Machine (Graves et al., 2014), which uses softmax-based soft attention. Later (Zaremba & Sutskever, 2015) extended NTM to hard attention using reinforcement learning. (Dodge et al., 2015; Bordes et al., 2015) alleviate the problem of the scalability of soft attention by having\nan initial keyword based filtering stage, which reduces the number of facts being considered. Our work generalizes this filtering by using MIPS for filtering. This is desirable because MIPS can be applied for any modality of data or even when there is no overlap between the words in a question and the words in facts.\nThe softmax arises in various situations and most relevant to this work are scaling methods for large vocabulary neural language modeling. In neural language modeling, the final layer is a softmax distribution over the next word and there exist several approaches to achieve scalability. (Morin & Bengio, 2005) proposes a hierarchical softmax based on prior clustering of the words into a binary, or more generally n-ary tree, that serves as a fixed structure for the learning process of the model. The complexity of training is reduced from O(n) to O(log n). Due to its clustering and tree structure, it resembles the clustering-based MIPS techniques we explore in this paper. However, the approaches differ at a fundamental level. Hierarchical softmax defines the probability of a leaf node as the product of all the probabilities computed by all the intermediate softmaxes on the way to that leaf node. By contrast, an approximate MIPS search imposes no such constraining structure on the probabilistic model, and is better thought as efficiently searching for top winners of what amounts to be a large ordinary flat softmax. Other methods such as Noice Constrastive Estimation (Mnih & Gregor, 2014) and Negative Sampling (Mikolov et al., 2013) avoid an expensive normalization constant by sampling negative samples from some marginal distribution. By contrast, our approach approximates the softmax by explicitly including in its negative samples candidates that likely would have a large softmax value. Jean et al. (2015) introduces an importance sampling approach that considers all the words in a mini-batch as the candidate set. This in general might also not include the MIPS candidates with highest softmax values.\n(Spring & Shrivastava, 2016) is the only work that we know of, proposing to use MIPS during learning. It proposes hashing-based MIPS to sort the hidden layer activations and reduce the computation in every layer. However, a small scale application was considered and data-independent methods like hashing will likely suffer as dimensionality increases. Rae et al. (2016) have also independently proposed a model called SAM to use approximate search methods for memory access in NTM-like architectures. However, our motivation is different. While Rae et al. (2016) focus on architectures where the memory is written by the controller itself, we focus on handling memory access to large external knowledge bases. While both the models fix the memory access mechanism (HMN uses MIPS and SAM uses NNS), our controller works in a much more constrained setting. Moreover, our experiments suggest that the performance of SAM could be improved using a clustering-based approach as in our work, instead of tree/hash-based approaches for memory search used by SAM."
    }, {
      "heading" : "5 EXPERIMENTS",
      "text" : "In this section, we report experiments on factoid question answering using hierarchical memory networks. Specifically, we use the SimpleQuestions dataset Bordes et al. (2015). The aim of these experiments is not to achieve state-of-the-art results on this dataset. Rather, we aim to propose and analyze various approaches to make memory networks more scalable and explore the achieved tradeoffs between speed and accuracy."
    }, {
      "heading" : "5.1 DATASET",
      "text" : "We use SimpleQuestions (Bordes et al., 2015) which is a large scale factoid question answering dataset. SimpleQuestions consists of 108,442 natural language questions, each paired with a corresponding fact from Freebase. Each fact is a triple (subject,relation,object) and the answer to the question is always the object. The dataset is divided into training (75910), validation (10845), and test (21687) sets. Unlike Bordes et al. (2015) who additionally considered FB2M (10M facts) or FB5M (12M facts) with keyword-based heuristics for filtering most of the facts for each question, we only use SimpleQuestions, with no keyword-based heuristics. This allows us to do a direct comparison with the full softmax approach in a reasonable amount of time. Moreover, we would like to highlight that for this dataset, keyword-based filtering is a very efficient heuristic since all questions have an appropriate source entity with a matching word. Nevertheless, our goal is to design a general purpose architecture without such strong assumptions on the nature of the data."
    }, {
      "heading" : "5.2 MODEL",
      "text" : "Let Vq be the vocabulary of all words in the natural language questions. Let Wq be a |Vq| ∗ m matrix where each row is some m dimensional embedding for a word in the question vocabulary. This matrix is initialized with random values and learned during training. Given any question, we represent it with a bag-of-words representation by summing the vector representation of each word in the question. Let q = {wi}pi=1,\nh(q) = p∑ i=1 Wq[wi]\nThen, to find the relevant fact from the memory M, we call the K-MIPS-based reader module with h(q) as the query. This uses Equation 3 and 4 to compute the output of the reader Rout. The reader is trained by minimizing the Negative Log Likelihood (NLL) of the correct fact.\nJθ = N∑ i=1 −log(Rout[fi])\nwhere fi is the index of the correct fact in Wm. We are fixing the memory embeddings to the TransE (Bordes et al., 2013) embeddings and learning only the question embeddings.\nThis model is simpler than the one reported in (Bordes et al., 2015) so that it is esay to analyze the effect of various memory reading strategies."
    }, {
      "heading" : "5.3 TRAINING DETAILS",
      "text" : "We trained the model with the Adam optimizer (Kingma & Ba, 2014), with a fixed learning rate of 0.001. We used mini-batches of size 128. We used 200 dimensional embeddings for the TransE entities, yielding 600 dimensional embeddings for facts by concatenating the embeddings of the subject, relation and object. We also experimented with summing the entities in the triple instead of concatenating, but we found that it was difficult for the model to differentiate facts this way. The only learnable parameters by the HMN model are the question word embeddings. The entity distribution in SimpleQuestions is extremely sparse and hence, following Bordes et al. (2015), we also add artificial questions for all the facts for which we do not have natural language questions. Unlike Bordes et al. (2015), we do not add any other additional tasks like paraphrase detection to the model, mainly to study the effect of the reader. We stopped training for all the models when the validation accuracy consistently decreased for 3 epochs.\n5.4 EXACT K-MIPS IMPROVES ACCURACY\nIn this section, we compare the performance of the full soft attention reader and exact K-MIPS attention readers. Our goal is to verify that K-MIPS attention is in fact a valid and useful attention mechanism and see how it fares when compared to full soft attention. For K-MIPS attention, we tried K ∈ 10, 50, 100, 1000. We would like to emphasize that, at training time, along with K candidates for a particular question, we also add the K-candidates for each question in the minibatch. So the exact size of the softmax layer would be higer than K during training. In Table 1, we report the test performance of memory networks using the soft attention reader and K-MIPS attention reader. We also report the average softmax size during training. From the table, it is clear that the K-MIPS attention readers improve the performance of the network compared to soft attention reader. In fact, smaller the value of K is, better the performance. This result suggests that it is better to use a K-MIPS layer instead of softmax layer whenever possible. It is interesting to see that the convergence of the model is not slowed down due to this change in softmax computation (as shown in Figure 1).\nThis experiment confirms the usefulness of K-MIPS attention. However, exact K-MIPS has the same complexity as a full softmax. Hence, to scale up the training, we need more efficient forms of K-MIPS attention, which is the focus of next experiment.\nModel Test Acc. Avg. Softmax Size Full-softmax 59.5 108442\n10-MIPS 62.2 1290 50-MIPS 61.2 6180\n100-MIPS 60.6 11928 1000-MIPS 59.6 70941 Clustering 51.5 20006 PCA-Tree 32.4 21108 WTA-Hash 40.2 20008\nTable 1: Accuracy in SQ test-set and average size of memory used. 10-softmax has high performance while using only smaller amount of memory.\n5.5 APPROXIMATE K-MIPS BASED LEARNING\nAs mentioned previously, designing faster algorithms for K-MIPS is an active area of research. Auvolat et al. (2015) compared several state-of-the-art data-dependent and data-independent methods for faster approximate K-MIPS and it was found that clustering-based MIPS performs significantly better than other approaches. However the focus of the comparison was on performance during the inference stage. In HMNs, K-MIPS must be used at both training stage and inference stages. To verify if the same trend can been seen during learning stage as well, we compared three different approaches:\nClustering: This was explained in detail in section 3.\nWTA-Hash: Winner Takes All hashing (Vijayanarasimhan et al., 2014) is a hashing-based K-MIPS algorithm which also converts MIPS to MCSS by augmenting additional dimensions to the vectors. This method used n hash functions and each hash function does p different random permutations of the vector. Then the prefix constituted by the first k elements of each permuted vector is used to construct the hash for the vector.\nPCA-Tree: PCA-Tree (Bachrach et al., 2014) is the state-of-the-art tree-based method, which converts MIPS to NNS by vector augmentation. It uses the principal components of the data to construct a balanced binary tree with data residing in the leaves.\nFor a fair comparison, we varied the hyper-parameters of each algorithm in such a way that the average speedup is approximately the same. Table 1 shows the performance of all three methods, compared to a full softmax. From the table, it is clear that the clustering-based method performs significantly better than the other two methods. However, performances are lower when compared to the performance of the full softmax.\nAs a next experiment, we analyze various the strategies proposed in Section 3.1 to reduce the approximation bias of clustering-based K-MIPS:\nTop-K: This strategy picks the vectors in the top K clusters as candidates.\nSample-K: This strategy samples K clusters, without replacement, based on a probability distribution based on the dot product of the query with the cluster centroids. When combined with the Top-K strategy, we ignore clusters selected by the Top-k strategy for sampling.\nRand-block: This strategy divides the memory into several blocks and uniformly samples a random block as candidate.\nWe experimented with 1000 clusters and 2000 clusters. While comparing various training strategies, we made sure that the effective speedup is approximately the same. Memory access to facts per query for all the models is approximately 20,000, hence yielding a 5X speedup.\nResults are given in Table 2. We observe that the best approach is to combine the Top-K and SampleK strategies, with Rand-block not being beneficial. Interestingly, the worst performances correspond to cases where the Sample-K strategy is ignored."
    }, {
      "heading" : "6 CONCLUSION",
      "text" : "In this paper, we proposed a hierarchical memory network that exploits K-MIPS for its attentionbased reader. Unlike soft attention readers, K-MIPS attention reader is easily scalable to larger memories. This is achieved by organizing the memory in a hierarchical way. Experiments on the SimpleQuestions dataset demonstrate that exact K-MIPS attention is better than soft attention. However, existing state-of-the-art approximate K-MIPS techniques provide a speedup at the cost of some accuracy. Future research will investigate designing efficient dynamic K-MIPS algorithms, where the memory can be dynamically updated during training. This should reduce the approximation bias and hence improve the overall performance."
    } ],
    "references" : [ {
      "title" : "Clustering is efficient for approximate maximum inner product search",
      "author" : [ "Alex Auvolat", "Sarath Chandar", "Pascal Vincent", "Hugo Larochelle", "Yoshua Bengio" ],
      "venue" : "arXiv preprint arXiv:1507.05910,",
      "citeRegEx" : "Auvolat et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Auvolat et al\\.",
      "year" : 2015
    }, {
      "title" : "Speeding up the xbox recommender system using a euclidean transformation for inner-product spaces",
      "author" : [ "Yoram Bachrach" ],
      "venue" : "RecSys ’14,",
      "citeRegEx" : "Bachrach,? \\Q2014\\E",
      "shortCiteRegEx" : "Bachrach",
      "year" : 2014
    }, {
      "title" : "Translating embeddings for modeling multi-relational data",
      "author" : [ "Antoine Bordes", "Nicolas Usunier", "Alberto Garcia-Duran", "Jason Weston", "Oksana Yakhnenko" ],
      "venue" : "In Advances in NIPS,",
      "citeRegEx" : "Bordes et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Bordes et al\\.",
      "year" : 2013
    }, {
      "title" : "Large-scale simple question answering with memory networks",
      "author" : [ "Antoine Bordes", "Nicolas Usunier", "Sumit Chopra", "Jason Weston" ],
      "venue" : "arXiv preprint arXiv:1506.02075,",
      "citeRegEx" : "Bordes et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Bordes et al\\.",
      "year" : 2015
    }, {
      "title" : "Evaluating prerequisite qualities for learning end-to-end dialog systems",
      "author" : [ "Jesse Dodge", "Andreea Gane", "Xiang Zhang", "Antoine Bordes", "Sumit Chopra", "Alexander Miller", "Arthur Szlam", "Jason Weston" ],
      "venue" : "CoRR, abs/1511.06931,",
      "citeRegEx" : "Dodge et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Dodge et al\\.",
      "year" : 2015
    }, {
      "title" : "Neural turing machines",
      "author" : [ "Alex Graves", "Greg Wayne", "Ivo Danihelka" ],
      "venue" : "arXiv preprint arXiv:1410.5401,",
      "citeRegEx" : "Graves et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Graves et al\\.",
      "year" : 2014
    }, {
      "title" : "On using very large target vocabulary for neural machine translation",
      "author" : [ "Sébastien Jean", "KyungHyun Cho", "Roland Memisevic", "Yoshua Bengio" ],
      "venue" : "In Proceedings of ACL,2015,",
      "citeRegEx" : "Jean et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Jean et al\\.",
      "year" : 2015
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "Diederik P. Kingma", "Jimmy Ba" ],
      "venue" : "CoRR, abs/1412.6980,",
      "citeRegEx" : "Kingma and Ba.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kingma and Ba.",
      "year" : 2014
    }, {
      "title" : "Ask me anything: Dynamic memory networks for natural language processing",
      "author" : [ "Ankit Kumar" ],
      "venue" : "CoRR, abs/1506.07285,",
      "citeRegEx" : "Kumar,? \\Q2015\\E",
      "shortCiteRegEx" : "Kumar",
      "year" : 2015
    }, {
      "title" : "Efficient estimation of word representations in vector space",
      "author" : [ "Tomas Mikolov", "Kai Chen", "Greg Corrado", "Jeffrey Dean" ],
      "venue" : "In International Conference on Learning Representations, Workshop Track,",
      "citeRegEx" : "Mikolov et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Mikolov et al\\.",
      "year" : 2013
    }, {
      "title" : "Neural variational inference and learning in belief networks",
      "author" : [ "Andriy Mnih", "Karol Gregor" ],
      "venue" : "arXiv preprint arXiv:1402.0030,",
      "citeRegEx" : "Mnih and Gregor.,? \\Q2014\\E",
      "shortCiteRegEx" : "Mnih and Gregor.",
      "year" : 2014
    }, {
      "title" : "Hierarchical probabilistic neural network language model",
      "author" : [ "Frederic Morin", "Yoshua Bengio" ],
      "venue" : "Proceedings of AISTATS,",
      "citeRegEx" : "Morin and Bengio.,? \\Q2005\\E",
      "shortCiteRegEx" : "Morin and Bengio.",
      "year" : 2005
    }, {
      "title" : "On symmetric and asymmetric lshs for inner product search",
      "author" : [ "Behnam Neyshabur", "Nathan Srebro" ],
      "venue" : "In Proceedings of the 31st International Conference on Machine Learning,",
      "citeRegEx" : "Neyshabur and Srebro.,? \\Q2015\\E",
      "shortCiteRegEx" : "Neyshabur and Srebro.",
      "year" : 2015
    }, {
      "title" : "Scaling memory-augmented neural networks with sparse reads and writes",
      "author" : [ "Jack W Rae", "Jonathan J Hunt", "Tim Harley", "Ivo Danihelka", "Andrew Senior", "Greg Wayne", "Alex Graves", "Timothy P Lillicrap" ],
      "venue" : "Advances in NIPS",
      "citeRegEx" : "Rae et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Rae et al\\.",
      "year" : 2016
    }, {
      "title" : "Maximum inner-product search using cone trees",
      "author" : [ "Parikshit Ram", "Alexander G. Gray" ],
      "venue" : "KDD ’12,",
      "citeRegEx" : "Ram and Gray.,? \\Q2012\\E",
      "shortCiteRegEx" : "Ram and Gray.",
      "year" : 2012
    }, {
      "title" : "Asymmetric LSH (ALSH) for sublinear time maximum inner product search (MIPS)",
      "author" : [ "Anshumali Shrivastava", "Ping Li" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Shrivastava and Li.,? \\Q2014\\E",
      "shortCiteRegEx" : "Shrivastava and Li.",
      "year" : 2014
    }, {
      "title" : "Improved asymmetric locality sensitive hashing (alsh) for maximum inner product search (mips)",
      "author" : [ "Anshumali Shrivastava", "Ping Li" ],
      "venue" : "In Proceedings of Conference on Uncertainty in Artificial Intelligence (UAI),",
      "citeRegEx" : "Shrivastava and Li.,? \\Q2015\\E",
      "shortCiteRegEx" : "Shrivastava and Li.",
      "year" : 2015
    }, {
      "title" : "Scalable and sustainable deep learning via randomized hashing",
      "author" : [ "Ryan Spring", "Anshumali Shrivastava" ],
      "venue" : null,
      "citeRegEx" : "Spring and Shrivastava.,? \\Q2016\\E",
      "shortCiteRegEx" : "Spring and Shrivastava.",
      "year" : 2016
    }, {
      "title" : "End-to-end memory networks",
      "author" : [ "Sainbayar Sukhbaatar", "Arthur Szlam", "Jason Weston", "Rob Fergus" ],
      "venue" : "arXiv preprint arXiv:1503.08895,",
      "citeRegEx" : "Sukhbaatar et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Sukhbaatar et al\\.",
      "year" : 2015
    }, {
      "title" : "Deep networks with large output spaces",
      "author" : [ "Sudheendra Vijayanarasimhan", "Jon Shlens", "Rajat Monga", "Jay Yagnik" ],
      "venue" : "arXiv preprint arXiv:1412.7479,",
      "citeRegEx" : "Vijayanarasimhan et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Vijayanarasimhan et al\\.",
      "year" : 2014
    }, {
      "title" : "Towards ai-complete question answering: a set of prerequisite toy tasks",
      "author" : [ "Jason Weston", "Antoine Bordes", "Sumit Chopra", "Tomas Mikolov" ],
      "venue" : "arXiv preprint arXiv:1502.05698,",
      "citeRegEx" : "Weston et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Weston et al\\.",
      "year" : 2015
    }, {
      "title" : "Simple statistical gradient-following algorithms for connectionist reinforcement learning",
      "author" : [ "Ronald J. Williams" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Williams.,? \\Q1992\\E",
      "shortCiteRegEx" : "Williams.",
      "year" : 1992
    }, {
      "title" : "Dynamic memory networks for visual and textual question answering",
      "author" : [ "Caiming Xiong", "Stephen Merity", "Richard Socher" ],
      "venue" : null,
      "citeRegEx" : "Xiong et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Xiong et al\\.",
      "year" : 2016
    }, {
      "title" : "Reinforcement learning neural turing machines",
      "author" : [ "Wojciech Zaremba", "Ilya Sutskever" ],
      "venue" : "CoRR, abs/1505.00521,",
      "citeRegEx" : "Zaremba and Sutskever.,? \\Q2015\\E",
      "shortCiteRegEx" : "Zaremba and Sutskever.",
      "year" : 2015
    }, {
      "title" : "Efficient online spherical k-means clustering",
      "author" : [ "Shi Zhong" ],
      "venue" : "In Neural Networks,",
      "citeRegEx" : "Zhong.,? \\Q2005\\E",
      "shortCiteRegEx" : "Zhong.",
      "year" : 2005
    } ],
    "referenceMentions" : [ {
      "referenceID" : 5,
      "context" : "Neural networks with memory (Graves et al., 2014; Weston et al., 2015b) can deal with knowledge bases by having an external memory component which can be used to explicitly store knowledge.",
      "startOffset" : 28,
      "endOffset" : 71
    }, {
      "referenceID" : 5,
      "context" : ", 2015b), Neural Turing Machines (NTM) (Graves et al., 2014), Dynamic Memory Net-",
      "startOffset" : 39,
      "endOffset" : 60
    }, {
      "referenceID" : 21,
      "context" : "Hard attention is achieved by using methods like REINFORCE (Williams, 1992), which provides a noisy gradient estimate when discrete stochastic decisions are made by a model.",
      "startOffset" : 59,
      "endOffset" : 75
    }, {
      "referenceID" : 2,
      "context" : "Application of memory networks to this task has been studied by Bordes et al. (2015). However, Bordes et al.",
      "startOffset" : 64,
      "endOffset" : 85
    }, {
      "referenceID" : 2,
      "context" : "Application of memory networks to this task has been studied by Bordes et al. (2015). However, Bordes et al. (2015) depended on keyword based heuristics to filter the facts to a smaller set which is manageable for training.",
      "startOffset" : 64,
      "endOffset" : 116
    }, {
      "referenceID" : 0,
      "context" : "Clustering-based approaches (Auvolat et al., 2015) cluster cells into multiple clusters (or a hierarchy of clusters) and given a query, they perform MIPS on the centroids of the top few clusters.",
      "startOffset" : 28,
      "endOffset" : 50
    }, {
      "referenceID" : 0,
      "context" : "We refer the readers to (Auvolat et al., 2015) for an extensive comparison of various state-of-the-art approaches for approximate K-MIPS.",
      "startOffset" : 24,
      "endOffset" : 46
    }, {
      "referenceID" : 0,
      "context" : "Clustering-based approximate K-MIPS was proposed in (Auvolat et al., 2015) and it has been shown to outperform various other state-of-the-art data dependent and data independent approximate KMIPS approaches for inference tasks.",
      "startOffset" : 52,
      "endOffset" : 74
    }, {
      "referenceID" : 0,
      "context" : "Following most of the other approximate K-MIPS algorithms, Auvolat et al. (2015) convert MIPS to Maximum Cosine Similarity Search (MCSS) problem:",
      "startOffset" : 59,
      "endOffset" : 81
    }, {
      "referenceID" : 0,
      "context" : "Instead, Auvolat et al. (2015) append additional dimensions to both query and data vectors to convert MIPS to MCSS.",
      "startOffset" : 9,
      "endOffset" : 31
    }, {
      "referenceID" : 24,
      "context" : "Once we convert MIPS to MCSS, we can use spherical K-means (Zhong, 2005) or its hierarchical version to approximate and speedup the cosine similarity search.",
      "startOffset" : 59,
      "endOffset" : 72
    }, {
      "referenceID" : 18,
      "context" : ", 2015b) and have been so far applied to comprehension-based question answering (Weston et al., 2015a; Sukhbaatar et al., 2015), large scale question answering (Bordes et al.",
      "startOffset" : 80,
      "endOffset" : 127
    }, {
      "referenceID" : 3,
      "context" : ", 2015), large scale question answering (Bordes et al., 2015) and dialogue systems (Dodge et al.",
      "startOffset" : 40,
      "endOffset" : 61
    }, {
      "referenceID" : 4,
      "context" : ", 2015) and dialogue systems (Dodge et al., 2015).",
      "startOffset" : 29,
      "endOffset" : 49
    }, {
      "referenceID" : 18,
      "context" : ", 2015b) considered supervised memory networks in which the correct supporting fact is given during the training stage, (Sukhbaatar et al., 2015) introduced semi-supervised memory networks that can learn the supporting fact by itself.",
      "startOffset" : 120,
      "endOffset" : 145
    }, {
      "referenceID" : 22,
      "context" : "(Kumar et al., 2015; Xiong et al., 2016) introduced Dynamic Memory Networks (DMNs) which can be considered as a memory network with two types of memory: a regular large memory and an episodic memory.",
      "startOffset" : 0,
      "endOffset" : 40
    }, {
      "referenceID" : 5,
      "context" : "Another related class of model is the Neural Turing Machine (Graves et al., 2014), which uses softmax-based soft attention.",
      "startOffset" : 60,
      "endOffset" : 81
    }, {
      "referenceID" : 4,
      "context" : "(Dodge et al., 2015; Bordes et al., 2015) alleviate the problem of the scalability of soft attention by having",
      "startOffset" : 0,
      "endOffset" : 41
    }, {
      "referenceID" : 3,
      "context" : "(Dodge et al., 2015; Bordes et al., 2015) alleviate the problem of the scalability of soft attention by having",
      "startOffset" : 0,
      "endOffset" : 41
    }, {
      "referenceID" : 9,
      "context" : "Other methods such as Noice Constrastive Estimation (Mnih & Gregor, 2014) and Negative Sampling (Mikolov et al., 2013) avoid an expensive normalization constant by sampling negative samples from some marginal distribution.",
      "startOffset" : 96,
      "endOffset" : 118
    }, {
      "referenceID" : 6,
      "context" : "Jean et al. (2015) introduces an importance sampling approach that considers all the words in a mini-batch as the candidate set.",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 6,
      "context" : "Jean et al. (2015) introduces an importance sampling approach that considers all the words in a mini-batch as the candidate set. This in general might also not include the MIPS candidates with highest softmax values. (Spring & Shrivastava, 2016) is the only work that we know of, proposing to use MIPS during learning. It proposes hashing-based MIPS to sort the hidden layer activations and reduce the computation in every layer. However, a small scale application was considered and data-independent methods like hashing will likely suffer as dimensionality increases. Rae et al. (2016) have also independently proposed a model called SAM to use approximate search methods for memory access in NTM-like architectures.",
      "startOffset" : 0,
      "endOffset" : 588
    }, {
      "referenceID" : 6,
      "context" : "Jean et al. (2015) introduces an importance sampling approach that considers all the words in a mini-batch as the candidate set. This in general might also not include the MIPS candidates with highest softmax values. (Spring & Shrivastava, 2016) is the only work that we know of, proposing to use MIPS during learning. It proposes hashing-based MIPS to sort the hidden layer activations and reduce the computation in every layer. However, a small scale application was considered and data-independent methods like hashing will likely suffer as dimensionality increases. Rae et al. (2016) have also independently proposed a model called SAM to use approximate search methods for memory access in NTM-like architectures. However, our motivation is different. While Rae et al. (2016) focus on architectures where the memory is written by the controller itself, we focus on handling memory access to large external knowledge bases.",
      "startOffset" : 0,
      "endOffset" : 781
    }, {
      "referenceID" : 2,
      "context" : "Specifically, we use the SimpleQuestions dataset Bordes et al. (2015). The aim of these experiments is not to achieve state-of-the-art results on this dataset.",
      "startOffset" : 49,
      "endOffset" : 70
    }, {
      "referenceID" : 3,
      "context" : "We use SimpleQuestions (Bordes et al., 2015) which is a large scale factoid question answering dataset.",
      "startOffset" : 23,
      "endOffset" : 44
    }, {
      "referenceID" : 2,
      "context" : "We use SimpleQuestions (Bordes et al., 2015) which is a large scale factoid question answering dataset. SimpleQuestions consists of 108,442 natural language questions, each paired with a corresponding fact from Freebase. Each fact is a triple (subject,relation,object) and the answer to the question is always the object. The dataset is divided into training (75910), validation (10845), and test (21687) sets. Unlike Bordes et al. (2015) who additionally considered FB2M (10M facts) or FB5M (12M facts) with keyword-based heuristics for filtering most of the facts for each question, we only use SimpleQuestions, with no keyword-based heuristics.",
      "startOffset" : 24,
      "endOffset" : 439
    }, {
      "referenceID" : 2,
      "context" : "We are fixing the memory embeddings to the TransE (Bordes et al., 2013) embeddings and learning only the question embeddings.",
      "startOffset" : 50,
      "endOffset" : 71
    }, {
      "referenceID" : 3,
      "context" : "This model is simpler than the one reported in (Bordes et al., 2015) so that it is esay to analyze the effect of various memory reading strategies.",
      "startOffset" : 47,
      "endOffset" : 68
    }, {
      "referenceID" : 2,
      "context" : "The entity distribution in SimpleQuestions is extremely sparse and hence, following Bordes et al. (2015), we also add artificial questions for all the facts for which we do not have natural language questions.",
      "startOffset" : 84,
      "endOffset" : 105
    }, {
      "referenceID" : 2,
      "context" : "The entity distribution in SimpleQuestions is extremely sparse and hence, following Bordes et al. (2015), we also add artificial questions for all the facts for which we do not have natural language questions. Unlike Bordes et al. (2015), we do not add any other additional tasks like paraphrase detection to the model, mainly to study the effect of the reader.",
      "startOffset" : 84,
      "endOffset" : 238
    }, {
      "referenceID" : 19,
      "context" : "WTA-Hash: Winner Takes All hashing (Vijayanarasimhan et al., 2014) is a hashing-based K-MIPS algorithm which also converts MIPS to MCSS by augmenting additional dimensions to the vectors.",
      "startOffset" : 35,
      "endOffset" : 66
    }, {
      "referenceID" : 0,
      "context" : "Auvolat et al. (2015) compared several state-of-the-art data-dependent and data-independent methods for faster approximate K-MIPS and it was found that clustering-based MIPS performs significantly better than other approaches.",
      "startOffset" : 0,
      "endOffset" : 22
    } ],
    "year" : 2016,
    "abstractText" : "Memory networks are neural networks with an explicit memory component that can be both read and written to by the network. The memory is often addressed in a soft way using a softmax function, making end-to-end training with backpropagation possible. However, this is not computationally scalable for applications which require the network to read from extremely large memories. On the other hand, it is well known that hard attention mechanisms based on reinforcement learning are challenging to train successfully. In this paper, we explore a form of hierarchical memory network, which can be considered as a hybrid between hard and soft attention memory networks. The memory is organized in a hierarchical structure such that reading from it is done with less computation than soft attention over a flat memory, while also being easier to train than hard attention over a flat memory. Specifically, we propose to incorporate Maximum Inner Product Search (MIPS) in the training and inference procedures for our hierarchical memory network. We explore the use of various state-of-the art approximate MIPS techniques and report results on SimpleQuestions, a challenging large scale factoid question answering task.",
    "creator" : "LaTeX with hyperref package"
  }
}