{
  "name" : "1705.05427.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Repeated Inverse Reinforcement Learning",
    "authors" : [ "Kareem Amin", "Nan Jiang", "Satinder Singh" ],
    "emails" : [ "<nanjiang@umich.edu>." ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 5.\n05 42\n7v 2\n[ cs\n.A I]\n1 8\nM ay\n2 01\n7\nscribe to AI agents acting on our behalf in complex environments? Detailed & low-level specification of goals can be tedious and expensive to create, and abstract & high-level goals could lead to negative surprises as the agent may find behaviors that we would not want it to do, i.e., lead to unsafe AI. One approach to addressing this dilemma is for the agent to infer human goals by observing human behavior. This is the Inverse Reinforcement Learning (IRL) problem. However, IRL is generally ill-posed for there are typically many reward functions for which the observed behavior is optimal. While the use of heuristics to select from among the set of feasible reward functions has led to successful applications of IRL to learning from demonstration, such heuristics do not address AI safety. In this paper we introduce a novel repeated IRL problem that captures an aspect of AI safety as follows. The agent has to act on behalf of a human in a sequence of tasks and wishes to minimize the number of tasks that it surprises the human. Each time the human is surprised the agent is provided a demonstration of the desired behavior by the human. We formalize this problem, including how the sequence of tasks is chosen, in a few different ways and provide some foundational results."
    }, {
      "heading" : "1. Introduction",
      "text" : "One challenge in building AI agents that learn from experience is how to set their goals or rewards. In the Reinforcement Learning (RL) setting, one interesting answer to this question is inverse RL (or IRL) in which the agent infers the\n*Equal contribution 1Google Research, New York. This work was done when KA was a postdoctoral researcher at University of Michigan, Ann Arbor. 2University of Michigan, Ann Arbor. Correspondence to: Nan Jiang <nanjiang@umich.edu>.\n+This paper extends the following arXiv paper by the authors: https://arxiv.org/abs/1601.06569.\nrewards of a human by observing the human’s policy in a task (Ng & Russell, 2000). Unfortunately, the IRL problem is ill-posed for there are typically many reward functions for which the observed behavior is optimal in a single task (Abbeel & Ng, 2004). While the use of heuristics to select from among the set of feasible reward functions has led to successful applications of IRL to the problem of learning from demonstration (e.g., Abbeel et al., 2007), not identifying the reward function poses fundamental challenges to the question of how well and how safely the agent will perform when using the learned reward function in other tasks. This is particularly relevant because IRL is a possible approach to the concern about aligning the agent’s values/goals with those of humans for AI safety as society deploys more capable learning agents that impact more people in more ways (Russell et al., 2015; Amodei et al., 2016).\nAdding AI safety concerns to IRL could take many forms: which human’s reward function matters?, which task should we watch the human perform?, how does the agent generalize what it learns from one task to other tasks?, etc. Here we focus solely on extending IRL to the generalization across tasks aspect of AI safety. We formalize multiple variations of a new repeated IRL problem in which the agent and (the same) human are placed in multiple tasks. We separate the reward function into two components, one which is invariant across tasks and can be viewed as intrinsic to the human, and a second that is task specific. As a motivating example, consider a human doing tasks throughout a work day, e.g., getting coffee, driving to work, interacting with co-workers, and so on. Each of these tasks has a task-specific goal but the human brings to each task intrinsic goals that correspond to maintaining health, financial well-being, not violating moral and legal principles, etc. In our repeated IRL setting, the agent presents a policy for each new task that it thinks the human would do. If the agent’s policy “surprises” the human by being sub-optimal, the human presents the agent with the optimal policy. The objective of the agent is to minimize the number of surprises to the human, i.e., to generalize the human’s behavior to new tasks.\nQuite apart from the connection to AI safety, the repeated IRL problem we introduce and our results are of independent interest in resolving the question of unidentifiability\nof rewards from observations in standard IRL. Our contributions include: (1) an efficient identification algorithm when the agent can choose the tasks in which it observes human behavior; (2) an upper bound on the number of total surprises when no assumptions are made on the tasks, along with a corresponding lower bound; (3) an extension to the setting where the human provides sample trajectories instead of complete behavior; and (4) identification guarantees when the agent can only choose the task rewards but is given a fixed task environment."
    }, {
      "heading" : "2. Markov Decision Processes (MDPs)",
      "text" : "We are interested in environments that can be represented as MDPs. An MDP is specified by its state space S, action space A, initial state distribution µ ∈ ∆(S), transition (or dynamics) function P : S × A → ∆(S), reward function Y : S → R, and discount factor γ ∈ [0, 1). A policy π : S → A describes an agent’s behavior by specifying the action to take in each state. The (normalized) value function or long-term utility of π is defined as V π(s) = (1 − γ)E[ ∑∞ t=1 γ\nt−1Y (st)|s0 = s;π].1 Similarly, the Q-value function is Qπ(s, a) = (1 − γ)E[ ∑∞ t=1 γ\nt−1Y (st)|s0 = s, a0 = a;π]. Where necessary we will use the notation V πP,Y to avoid ambiguity about the environment and the reward function used in computing V π. Let π⋆ : S → A be an optimal policy, which maximizes V π and Qπ in all states (and actions) simultaneously.\nGiven an initial distribution over states, µ, a scalar value that measures the goodness of π is defined as Es∼µ[V π(s)]. We introduce some further notation to define Es∼µ[V π(s)] in vector-matrix form. Let ηπµ,P ∈ R|S| be the normalized state occupancy under initial distribution µ, dynamics P , and policy π, whose s-th entry is (1 − γ)E[∑∞t=1 γt−1I(st = s)|s0 ∼ µ;π]. This vector can be computed in closed-form as ηπµ,P = (1 − γ) ( µ⊤P π ( I|S| − γP π )−1)⊤ , where P π is an |S| × |S| matrix whose (s, s′)-th element is P (s′|s, π(s)), and I|S| is the |S| × |S| identity matrix. For convenience we will also treat the reward function Y as a vector in R|S|, and we have\nEs∼µ[V π(s)] = Y ⊤ηπµ,P . (1)"
    }, {
      "heading" : "3. Problem setup",
      "text" : "Here we define the repeated IRL problem. The human’s reward function θ⋆ captures his/her safety concerns and intrinsic/general preferences. This θ⋆ is unknown to the agent and is the object of interest herein, i.e., if θ⋆ were known to the agent, the concerns addressed in this paper would be\n1Here we differ (w.l.o.g.) from common IRL literature in assuming that reward occurs after transition.\nsolved. We assume that the human cannot directly communicate θ⋆ to the agent but can evaluate the agent’s behavior in a task as well as demonstrate optimal behavior.\nFormally, a task is defined by a pair (E,R), where E = (S,A, µ, P, γ) is the task environment (i.e., an MDP without a reward function), and R is the task-specific reward function (task reward). We assume that all tasks share the same S,A, γ, with |A| ≥ 2, but may differ in the initial distribution µ, dynamics P , and task reward R; all of the task-specifying quantities are known to the agent. In any task, the human’s optimal behavior is always with respect to the reward function Y := θ⋆ + R. We emphasize again that θ⋆ is intrinsic to the human and remains the same across all tasks. Our use of task specific reward functions R allows for greater generality than the usual IRL setting, but we note that our results apply equally to the case where the task reward is always zero.\nWhile θ⋆ is private to the human, the agent has some prior knowledge on θ⋆, represented as a set of possible parameters Θ0 ⊂ R|S| that contains θ⋆. Throughout, we assume that the human’s reward has bounded and normalized magnitude, that is, ‖θ⋆‖∞ ≤ 1. A demonstration in (E,R)means revealing π⋆ to the agent, which optimizes for Y := θ⋆ + R under environment E. A common assumption in the IRL literature is that the full mapping is revealed, which can be unrealistic if some states are unreachable from the initial distribution. We address the issue by requiring only the state occupancy vector ηπ ∗\nµ,P .\nIn Section 7 we show that this also allows an easy extension to the setting where the human only demonstrates trajectories instead of providing a policy.\nUnder the above framework for repeated IRL, we consider two settings that differ in how the sequence of tasks are chosen. In both settings, we will want to minimize the number of demonstrations needed.\n1. (Section 5) Agent chooses the tasks, observes the hu-\nman’s behavior in each of them, and infers the reward function. In this setting where the agent is powerful enough to choose tasks arbitrarily, we will show that the agent will be able to identify the human’s reward function which of course implies the ability to generalize to new tasks.\n2. (Section 6) Nature chooses the tasks, and the agent\nproposes a policy in each task. The human demonstrates a policy only if the agent’s policy is a mistake (a negative surprise), i.e., significantly suboptimal. In this setting we will derive upper and lower bounds on the number of mistakes our agent will make."
    }, {
      "heading" : "4. The challenge of identifying rewards",
      "text" : "Note that it is impossible to identify θ⋆ from watching human behavior in a single task. This is because any θ⋆ is fundamentally indistinguishable from an infinite set of reward functions that yield exactly the policy observed in the task. We introduce the idea of behavioral equivalence below to tease apart two separate issues wrapped up in the challenge of identifying rewards.\nDefinition 1. Two reward functions θ, θ′ ∈ R|S| are behaviorally equivalent in MDP tasks, if for any (E,R), the set of optimal policies for (R+ θ) and (R + θ′) are the same.\nWe argue that the task of identifying the reward function should amount only to identifying the (behaviorally) equivalence class to which θ⋆ belongs. In particular, identifying the equivalence class is sufficient to get perfect generalization to new tasks. Any remaining unidentifiability is merely representational and of no real consequence. Next we present a constraint that captures the reward functions that belong to the same equivalence class.\nProposition 1. Two reward functions θ and θ′ are behaviorally equivalent in MDP tasks if and only if θ − θ′ = c · 1|S| for some c ∈ R, where 1|S| is an all-1 vector of length |S|.\nProof. To show that θ − θ′ = c · 1|S| implies behavioral equivalence, we note that for any policy π the occupancy vector ηπµ,P always satisfies 1 ⊤ |S|η π µ,P = 1, so ∀π, |θT ηπµ,P − θ′T ηπµ,P | = c, and therefore the set of optimal policies is the same.\nTo show the other direction, we prove that if θ − θ′ /∈ span({1|S|}), then there exists (E,R) such that the sets of optimal policies differ. In particular, we choose R = −θ′, so that all policies are optimal under R + θ′ = 0. Since θ − θ′ /∈ span({1|S|}), there exists states i and j such that θ(i) + R(i) 6= θ(j) + R(j). Suppose i is the one with smaller sum of rewards, then we can make j an absorbing state, and have two deterministic actions in i that transition to i and j respectively. Under R + θ, the self-loop in state i is suboptimal, and this completes the proof.\nFor any class of θ’s that are equivalent to each other, we can choose a canonical element to represent this class. For example, we can fix an arbitrary reference state sref ∈ S, and fix the reward of this state to 0 for θ⋆ and all candidate θ’s. In the rest of the paper, we will always assume such canonicalization in the MDP setting, hence θ⋆ ∈ Θ0 ⊆ {θ ∈ [−1, 1]|S| : θ(sref) = 0}."
    }, {
      "heading" : "5. Agent chooses the tasks",
      "text" : "In this section, the protocol is that the agent chooses a sequence of tasks {(Et, Rt)}. For each task (Et, Rt), the human reveals π⋆t , which is optimal for environment Et and reward function θ⋆+Rt. Our goal is to design an algorithm which chooses {(Et, Rt)} and identifies θ⋆ to a desired accuracy (ǫ) using as few tasks as possible."
    }, {
      "heading" : "5.1. Omnipotent identification algorithm",
      "text" : "Theorem 1 shows that a simple algorithm can identify θ⋆ after only O(log(1/ǫ)) tasks, if any tasks may be chosen. Roughly speaking, the algorithm amounts to a binary search on each component of θ⋆ by manipulating the task reward Rt. 2 See the proof for the algorithm specification. Theorem 1. If θ⋆ ∈ Θ0 ⊆ {θ ∈ [−1, 1]|S| : θ(sref) = 0}, there exists an algorithm that outputs θ ∈ R|S| that satisfies ‖θ − θ⋆‖∞ ≤ ǫ after O(log(1/ǫ)) demonstrations.\nProof. The algorithm chooses the following fixed environment in all tasks: for each s ∈ S \\{sref}, let one action be a self-loop, and the other action transitions to sref. In sref, all actions cause self-loops. The initial distribution over states is uniformly at random over S \\ {sref}. Each task only differs in the task reward Rt (where Rt(sref) ≡ 0 always). After observing the state occupancy of the optimal policy, for each s we check if the occupancy is equal to 0. If so, it means that the demonstrated optimal policy chooses to go to sref from s in the first time step, and θ⋆(s) + Rt(s) ≤ θ⋆(sref) + Rt(sref) = 0; if not, we have θ⋆(s) +Rt(s) ≥ 0. Consequently, after each task we learn the relationship between θ⋆(s) and −Rt(s) on each s ∈ S \\{sref}, so conducting a binary search by manipulating Rt(s) will identify θ⋆ to ǫ-accuracy after O(log(1/ǫ)) tasks.\nAs noted before, once the agent has identified θ⋆ within an appropriate tolerance, it can compute a sufficiently-nearoptimal policy for all tasks, thus completing the generalization objective through the far stronger identification objective in this setting."
    }, {
      "heading" : "6. Nature chooses the tasks",
      "text" : "While Theorem 1 yields a strong identification guarantee, it also relies on a strong assumption, that {(Et, Rt)} may be chosen by the agent in an arbitrary manner. In this section, we let nature, who is allowed to be adversarial for the\n2While we present a proof that manipulates Rt, an only slightly more complex proof applies to the setting where all the Rt are exactly zero and the manipulation is limited to the environment; see full details in the previous version of the paper on arXiv (Amin & Singh, 2016).\npurpose of the analysis, choose {(Et, Rt)}. Generally speaking, we cannot obtain identification guarantees in such an adversarial setup. As an example, if Rt ≡ 0 and Et remains the same over time, we are essentially back to the classical IRL setting and suffer from the degeneracy issue. However, generalization to future tasks, which is our ultimate goal, is easy in this special case: after the initial demonstration, the agent can mimic it to behave optimally in all subsequent tasks without requiring further demonstrations.\nMore generally, if nature repeats similar tasks, then the agent obtains little new information, but presumably it knows how to behave in most cases; if nature chooses a task unfamiliar to the agent, then the agent is likely to err, but it may learn about θ⋆ from the mistake.\nTo formalize this intuition, we consider the following protocol: the nature chooses a sequence of tasks {(Et, Rt)} in an arbitrary manner. For every task (Et, Rt), the agent proposes a policy πt. The human examines the policy’s value under µt, and if the loss\nlt = Es∼µ [ V π⋆t Et, θ⋆+Rt (s) ] − Es∼µ [ V πtEt, θ⋆+Rt(s) ] (2)\nis less than some ǫ then the human is satisfied and no demonstration is needed; otherwise a mistake is counted and η π⋆t µt,Pt is revealed to the agent (note that η π⋆t µt,Pt can be computed by the agent if needed from π∗t and its knowledge of the task, so the reader can consider the case of the human presenting the policy w.l.o.g.). The main goal of this section is to design an algorithm that has a provable guarantee on the total number of mistakes.\nBefore describing and analyzing our algorithm, we first notice that the Equation 2 can be rewritten as\nlt = (θ⋆ +R) ⊤(η π⋆t µt,Pt − ηπtµt,Pt), (3)\nusing Equation 1. So effectively, the given environment Et in each round defines a set of state occupancy vectors {ηπµt,Pt : π ∈ (S → A)}, and we want the agent to choose the vector that has the largest dot product with θ⋆+R. The exponential size of the set will not be a concern because our main result (Theorem 2) has no dependence on the number of vectors, and only depends on the dimension of those vectors. The result is enabled by studying the linear bandit version of the problem, which subsumes the MDP setting for our purpose and is also a model of independent interest."
    }, {
      "heading" : "6.1. The linear bandit setting",
      "text" : "In the linear bandit setting, D is a finite action space with size |D| = K . Each task is denoted as a pair (X,R). X = [x(1) · · · x(K)] is a d×K feature matrix, where x(i) is the feature vector for the i-th action, and ‖x(i)‖1 ≤ 1.\nWhen we reduce MDPs to linear bandits, each element of D corresponds to an MDP policy, and the feature vector is the state occupancy of that policy.\nAs before,R, θ⋆ ∈ Rd are the task reward and the human’s unknown reward, respectively. The initial uncertainty set for θ⋆ is Θ0 ⊆ [−1, 1]d. The value of the i-th action is calculated as (θ⋆+R)\n⊤x(i), and a⋆ is the action that maximizes this value. Every round the agent proposes an action a ∈ D, whose loss is defined as\nlt = (θ⋆ +R) ⊤(xa ⋆ − xa).\nWe now show how to embed the previous MDP setting in linear bandits.\nExample 1. Given an MDP problem with variables S,A, γ, θ⋆, sref,Θ0, {(Et, Rt)}, we can convert it into a linear bandit problem as follows. All variables with prime belong to the linear bandit problem, and we use v\\i to denote the vector v with the i-th coordinate removed.\n• D = {π : S → A}, d = |S| − 1. • θ′⋆ = θ \\sref ⋆ ,Θ ′ 0 = {θ\\sref : θ ∈ Θ0}. • xπt = (ηπµt,Pt)\\sref . R′t = R \\sref t −Rt(sref) · 1d.\nThen for any sequence of policies chosen in the MDP problem, the corresponding sequence of actions in the linear bandit problem suffer exactly the same sequence of losses.\nNote that there is a more straightforward conversion by letting d = |S|, θ′⋆ = θ⋆,Θ′0 = Θ0, xπt = ηπµt,Pt , R′t = Rt, which also preserves losses. We perform a more succinct conversion in Example 1 by canonicalizing both θ⋆ (already assumed) andRt (explicitly done here) and dropping the coordinate for sref in all relevant vectors.\nMDPs with linear rewards In IRL literature, a generalization of the MDP setting is often considered, that reward is linear in state features φ(s) ∈ Rd (Ng & Russell, 2000; Abbeel & Ng, 2004). In this new setting, θ⋆ and R are reward parameters, and the actual reward is the dot product between the reward parameter and φ(s). This new setting can also be reduced to linear bandits similarly to Example 1, except that the state occupancy is replaced by the discounted sum of expected feature values. Our main result, Theorem 2, will still apply automatically, but now the guarantee will only depend on the dimension of the feature space and has no dependence on |S|. We include the conversion below but do not further discuss this setting in the rest of the paper.\nExample 2. Consider an MDP problem with state features, defined by S,A, γ, d ∈ Z+, θ⋆ ∈ Rd,Θ0 ⊆ [−1, 1]d, {(Et, φt ∈ Rd, Rt ∈ Rd)}, where task reward and background reward in state s are θ⊤⋆ φt(s) andR\n⊤φt(s) respectively, and θ⋆ ∈ Θ0. Suppose ‖φt(s)‖∞ ≤ 1 always\nAlgorithm 1 Ellipsoid Algorithm for Repeated Inverse Reinforcement Learning\n1: Input: Θ0. 2: Θ1 := MVEE(Θ0). 3: for t = 1, 2, . . . do 4: Nature reveals (Xt, Rt). 5: Learner plays at = argmaxa∈D c⊤t x a t , where ct is the center of Θt. 6: if lt > ǫ then 7: Human reveals a⋆t . 8: Θt+1 =\nMVEE({θ ∈ Θt : (θ − ct)⊤(xa ⋆ t\nt − xatt ) ≥ 0}). 9: else\n10: Θt+1 = Θt. 11: end if 12: end for\nholds, then we can convert it into a linear bandit problem as follows:\n• D = {π : S → A}; d, θ⋆, and Rt remain the same. • xπt = (1− γ) ∑∞ h=1 γ\nh−1E[φ(sh) |µt, Pt, π]/d. Note that the division of d in xπt is for normalization purpose, so that ‖xπt ‖1 ≤ ‖φ‖1/d ≤ ‖φ‖∞ ≤ 1."
    }, {
      "heading" : "6.2. Ellipsoid Algorithm for Repeated Inverse Reinforcement Learning",
      "text" : "We propose Algorithm 1, and provide the mistake bound in the following theorem. Note that the pseudo-code also contains the formal protocol of the process.\nTheorem 2. For Θ0 = [−1, 1]d, the number of mistakes made by Algorithm 1 is guaranteed to be O(d2 log(d/ǫ)).\nTo prove Theorem 2, we quote a result from linear programming literature in Lemma 1, which is found in standard lecture notes (e.g., O’Donnell 2011, Theorem 8.8; see also Grötschel et al. 2012, Lemma 3.1.34).\nLemma 1 (Volume reduction in ellipsoid algorithm). Given any non-degenerate ellipsoid B in Rd centered at c ∈ Rd, and any non-zero vector v ∈ Rd, let B+ be the minimum-volume enclosing ellipsoid (MVEE) of\n{u ∈ B : (u− c)⊤v ≥ 0}.\nWe have vol(B+)\nvol(B) ≤ e− 1 2(d+1) .\nProof of Theorem 2. Whenever a mistake is made and the optimal action a⋆t is revealed, we can induce the constraint (Rt+ θ⋆) ⊤(x a⋆t t −xatt ) > ǫ.Meanwhile, since at is greedy w.r.t. ct, we have (Rt + ct) ⊤(x a⋆t t − xatt ) ≤ 0, where ct is the center of Θt as in Line 5. Taking the difference of the\ntwo inequalities, we obtain\n(θ⋆ − ct)⊤(xa ⋆ t t − xatt ) > ǫ. (4)\nTherefore, the update rule on Line 8 preserves θ⋆ in Θt+1. Since the update makes a central cut through the ellipsoid, Lemma 1 applies and the volume shrinks by a multiplicative constant e− 1 2(d+1) every time a mistake is made.\nTo prove the theorem, it remains to upper bound the initial volume and lower bound the terminal volume of Θt. We first show that an update never eliminatesB∞(θ⋆, ǫ/2), the ℓ∞ ball centered at θ⋆ with radius ǫ/2. This is because, any eliminated θ satisfies (θ+ct) ⊤(x a⋆t t −xatt ) < 0. Combining this with Equation 4, we have\nǫ < (θ⋆ − θ)⊤(xa ⋆ t\nt − xatt ) ≤ ‖θ⋆ − θ‖∞‖xa ⋆ t t − xatt ‖1 ≤ 2‖θ⋆ − θ‖∞.\nThe last step follows from ‖x‖1 ≤ 1. So we conclude that any eliminated θ should be ǫ/2 far away from θ⋆ in ℓ∞ distance. Therefore, we can lower bound the volume of Θt for any t by that of Θ0 ⋂ B∞(θ⋆, ǫ/2), which contains an infinite-norm ball with radius ǫ/4 in the worst case (when θ⋆ is one ofΘ0’s vertices). To simplify calculation, we will further relax this ℓ∞ ball to its inscribed ℓ2 ball.\nFinally we put everything together: let MT be the number of mistakes made from round 1 to T , and Cd be the volume of the unit sphere in Rd, we have\nMT 2(d+ 1) ≤ log(vol(Θ1))− log(vol(ΘT+1))\n≤ log(Cd( √ d)d)− log(Cd(ǫ/4)d) = d log\n4 √ d\nǫ .\nSoMT ≤ 2d(d+ 1) log 4 √ d ǫ = O(d 2 log dǫ )."
    }, {
      "heading" : "6.3. Lower bound",
      "text" : "In Section 5, we get an O(log(1/ǫ)) upper bound on the number of demonstrations, which has no dependence on |S| (which corresponds to d + 1 in linear bandits). Comparing Theorem 2 to 1, one may wonder whether the polynomial dependence on d is an artifact of the inefficiency of Algorithm 1. We clarify this issue by proving a lower bound, showing that Ω(d log(1/ǫ)) mistakes are inevitable in the worst case when nature chooses the tasks. We provide a proof sketch below, and the complete proof is deferred to Appendix D.\nTheorem 3. For any randomized algorithm3 in the linear bandit setting, there always exists θ⋆ ∈ [−1, 1]d and 3While our Algorithm 1 is deterministic, randomization is often crucial for online learning in general (Shalev-Shwartz, 2011).\n{(Xt, Rt)} which are fixed before the execution of the algorithm,4 such that the expected number of mistakes made by the algorithm under θ⋆ and {(Xt, Rt)} isΩ(d log(1/ǫ)).\nProof Sketch. We randomize θ⋆ by sampling each element i.i.d. from Unif([−1, 1]). We will prove that there exists a strategy of choosing (Xt, Rt) such that any algorithm’s expected number of mistakes is Ω(d log(1/ǫ), which proves the theorem as max is no less than average.\nIn our construction,Xt = [0d, ejt ], where jt is some index to be specified. Hence, every round the agent is essentially asked to decided whether θ(jt) ≥ −Rt(jt). The adversary’s strategy goes in phases, and Rt remains the same during each phase. Every phase has d rounds where jt is enumerated over {1, . . . , d}. The adversary will use Rt to shift the posterior on θ(jt) + Rt(jt) so that it is (approximately) centered around the origin; in this way, the agent has about 1/2 probability to make an error (regardless of the algorithm), and the posterior interval will be halved. Overall, the agent makes d/2 mistakes in each phase, and there will be about log(1/ǫ) phases in total, which gives the lower bound.\nApplying the lower bound to MDPs The above lower bound is stated for linear bandits. In principle, we need to prove lower bound for MDPs separately, because linear bandits are more general than MDPs for our purpose, and the hard instances in linear bandits may not have correspondingMDP instances. In Lemma 2 below, we show that a certain type of linear bandit instances can always be emulated by MDPs with the same number of actions, and the hard instances constructed in Theorem 3 indeed satisfy the conditions for such a type; in particular, we require the feature vectors to be non-negative and have ℓ1 norm bounded by 1. As a corollary, an Ω(|S| log(1/ǫ)) lower bound for the MDP setting (even with a small action space |A| = 2) follows directly from Theorem 3.\nLemma 2 (Linear bandit to MDP conversion). Let (X,R) be a linear bandit task, and K be the number of actions. If every xa is non-negative and ‖xa‖1 ≤ 1, then there exists an MDP task (E,R′) with d+ 1 states andK actions, such that under some choice of sref, converting (E,R\n′) as in Example 1 recovers the original problem.\nThe proof of this lemma is deferred to Appendix A."
    }, {
      "heading" : "6.4. On identification when Nature Chooses Tasks",
      "text" : "While Theorem 2 successfully controls the number of total mistakes, it completely avoids the identification problem\n4This means that the lower bound can be realized by an oblivious adversary, who cannot adapt the tasks to the realization of the random variables drawn by the algorithm.\nand does not guarantee to recover θ⋆. In this section we explore further conditions under which we can obtain identification guarantees when Nature chooses the tasks.\nThe first condition, stated in Proposition 2, implies that if we have made all the possible mistakes, then we have indeed identified the θ⋆, where the identification accuracy is determined by the tolerance parameter ǫ that defines what is counted as a mistake.\nProposition 2. Consider the linear bandit setting. If there exists T0 such that for any round t ≥ T0, no more mistakes can be ever made by the algorithm for any choice of (Et, Rt) and any tie-braking mechanism, then we have θ⋆ ∈ B∞(cT0 , ǫ).\nProof. Assume towards contradiction that ‖cT0 − θ⋆‖∞ > ǫ. We will choose (Rt, x (1) t , x (2) t ) to make the algorithm err. In particular, let Rt = −cT0 , so that the algorithm acts greedily with respect to 0d. Since 0 ⊤ d x a t ≡ 0, any action would be a valid choice for the algorithm.\nOn the other hand, ‖cT0 − θ⋆‖∞ > ǫ implies that there exists a coordinate j such that |e⊤j (θ⋆ − cT0)| > ǫ, where ej is a basis vector. Let x (1) t = 0d and x (2) t = ej . So the value of action 1 is always 0 under any reward function (including θ⋆ + Rt), and the value of action 2 is (θ⋆ + Rt) ⊤x(2)t = (θ⋆ − cT0)⊤ej , whose absolute value is greater than ǫ. At least one of the 2 actions is more than ǫ suboptimal, and the algorithm may take any of them, so the algorithm can err again.\nWhile Proposition 2 shows that identification is guaranteed if the agent exhausts the mistakes, the agent has no ability to actively fulfill this condition when Nature chooses tasks. For a stronger identification guarantee, we may need to grant the agent some freedom in choosing the tasks.\nIdentification with fixed environment Here we consider a setting that fits in between Section 5 (completely active) and Section 6.1 (completely passive), where the environment E (hence the induced feature vectors {x(1), x(2), . . . , x(K)}) is given and fixed, and the agent can arbitrarily choose the task reward Rt. The goal is to obtain an identification guarantee in this new intermediate setting.\nUnfortunately, a degenerate case can be easily constructed that prevents the revelation of any information about θ⋆. In particular, if x(1) = x(2) = . . . = x(K), i.e., the environment is completely uncontrolled, then all actions are equally optimal and nothing can be learned.\nMore generally, if for some non-zero vector v we have v⊤x(1) = v⊤x(2) = . . . = v⊤x(K), then we may never recover θ⋆ along the direction of v. In fact, Proposition 1\ncan be viewed as an instance of this result where v = 1|S| (recall that the entries of the state occupancy vector always sum up to 1), and that is why we have to remove such redundancy in Example 1 in order to discuss identification in MDPs. Therefore, to guarantee identification in a fixed environment, the feature vectors must be substantially different in all directions, and we capture this intuition by defining a diversity score spread(X) (Definition 2) and showing that the identification accuracy depends inversely on the score (Theorem 4).\nDefinition 2. Given the feature matrix X =[ x(1) x(2) · · · x(K) ] whose size is d × K , define spread(X) as the d-th largest singular value of X̃ := X(IK − 1K1K1⊤K). Theorem 4. For a fixed feature matrix X , if spread(X) > 0, then there exists a sequence R1, R2, . . . , RT with T = O(d2 log(d/ǫ)) and a sequence of tie-break choices of the algorithm, such that after round T we have ‖cT − θ⋆‖∞ ≤ ǫ √ (K − 1)/2\nspread(X) .\nProof. It suffices to show that in any round t, if ‖ct − θ⋆‖∞ > ǫ √ (K−1)/2\nspread(X) , then lt > ǫ. The bound on T follows\ndirectly from Theorem 2. Similar to the proof of Proposition 2, our choice of the task reward is Rt = −ct, so that any a ∈ A would be a valid choice of at, and we will choose the worst action. Note that ∀a, a′ ∈ D,\nlt = (θ⋆ +Rt) ⊤(xa ⋆ t − xat) ≥ (θ⋆ − ct)⊤(xa − xa ′ ).\nSo it suffices to show that there exists a, a′ ∈ D, such that (θ⋆ − ct)⊤(xa − xa ′ ) > ǫ. Let yt = θ⋆ − ct, and the\nprecondition implies that ‖yt‖2 ≥ ‖yt‖∞ > ǫ √ (K−1)/2 spread(X) .\nDefine a matrix of size K × (K(K − 1))\nD =   1 1 · · · 0 −1 0 · · · 0 0 −1 · · · 0 . . .\n0 0 · · · −1 0 0 · · · 1\n  . (5)\nEvery column of this matrix contains exactly one 1 and one −1, and the columns enumerate all possible positions of them. With the help of this matrix, we can rewrite the desired result (∃ a, a′ ∈ A, s.t. (θ⋆ − ct)⊤(xa − xa ′ ) > ǫ) as ‖y⊤t XD‖∞ ≥ ǫ. We relax the LHS as ‖y⊤t XD‖∞ ≥ ‖y⊤t XD‖2/ √ K(K − 1), and will provide a lower bound on ‖y⊤t XD‖2. Note that\ny⊤t XD = y ⊤ t (X̃ + (X − X̃))D = y⊤t X̃D,\nbecause every row of (X − X̃) is some multiple of 1⊤K (recall Definition 2), and every column of D is orthogonal to 1K . Let (̂·) be the vector normalized to unit length,\n‖y⊤t X̃D‖2 = ‖yt‖2‖ŷ⊤t X̃D‖2\n= ‖yt‖2‖ŷ⊤t X̃‖2D‖2 = ‖yt‖2‖ŷ⊤t X̃‖2‖ ̂ ŷ⊤t X̃ D‖2.\nWe lower bound each of the 3 terms. For the first term, we have the precondition ‖yt‖2 > ǫ √ (K−1)/2 spread(X) . The second term is X̃ left multiplied by a unit vector, so its ℓ2 norm can be lower bounded by the smallest non-zero singular value of X̃ (recall that X̃ is full-rank), which is spread(X).\nTo lower bound the last term, note that DD⊤ = 2KIK − 21K1 ⊤ K , and rows of X̃ are orthogonal to 1 ⊤ K and so is y⊤t X̃ , so\n‖̂ŷ⊤t X̃ D‖22 ≥ inf‖z‖2=1, z⊥1K z⊤DD⊤z\n= inf ‖z‖2=1, z⊥1K\nz⊤(2KIK − 21K1⊤K)z\n= inf ‖z‖2=1, z⊥1K\n2Kz⊤z = 2K.\nPutting all the pieces together, we have\n‖y⊤t X̃D‖∞ ≥ ‖yt‖2‖ŷ⊤t X̃‖2‖ ̂ ŷ⊤t X̃ D‖2/\n√ d\n> ǫ √ (K − 1)/2\nspread(X) · spread(X) ·\n√ 2K√\nK(K − 1) = ǫ.\nThe √ K dependence in Theorem 4may be of concern asK can be exponentially large. However, Theorem 4 also holds if we replaceX by anymatrix that consists ofX’s columns, so we may choose a small yet most diverse set of columns as to optimize the bound. We also show in Appendix B that Theorem 4 is tight in the worst case."
    }, {
      "heading" : "7. Working with trajectories",
      "text" : "In previous sections, we have assumed that the human evaluates the agent’s performance based on the state occupancy of the agent’s policy, and demonstrates the optimal policy in terms of state occupancy as well. In practice, we would like to instead assume that for each task, the agent rolls out a trajectory, and the human shows an optimal trajectory if he/she finds the agent’s trajectory unsatisfying. We are still concerned about upper bounding the number of total mistakes, and aim to provide a parallel version of Theorem 2.\nUnlike in traditional IRL, in our setting the agent is also acting, which gives rise to many subtleties. First, the total reward on the agent’s single trajectory is a random variable, and may deviate from the expected value of its policy. Therefore, it is generally impossible to decide if the agent’s\npolicy is near-optimal, and instead we assume that the human can check if each action that the agent takes in the trajectory is near-optimal: when the agent takes a at state s, an error is counted if and only if Q⋆(s, a) < V ⋆(s)− ǫ. While this resolves the issue on the agent’s side, how should the human provide his/her optimal trajectory?. The most straightforward protocol is that the human rolls out a trajectory from the specified µt. We argue that this is not a reasonable protocol for two reasons: (1) in expectation, the reward collected by the human may be less than that by the agent, which is due to us conditioning on the event that an error is spotted; (2) the human may not encounter the problematic state in his/her own trajectory, hence the information provided in the trajectory may be irrelevant.\nTo resolve this issue, we consider a different protocol where the human rolls out a trajectory using optimal policy from the very state where the agent errs.\nNow we discuss how we can prove a parallel of Theorem 2 under this new protocol. First, let’s assume that the demonstration were still given in state occupancy induced by the optimal policy from the problematic state. In this case, we can treat the problematic state as the initial state, thanks to our assumption-free setup about (Et, Rt) (hence µt). To reduce to our previous solution in Section 6, it remains to show that the notion of error in this section (a suboptimal action) implies the notion of error in Section 6 (a suboptimal policy): let s be the problematic state and π be the agent’s policy, we have\nV π(s) = Qπ(s, π(s)) ≤ Q⋆(s, π(s)) < V ⋆(s)− ǫ.\nSo whenever a suboptimal action is spotted in state s, it indeed implies that the agent’s policy is suboptimal for s as the initial state. Hence, we can run Algorithm 1 and Theorem 2 immediately applies.\nTo tackle the remaining issue that the demonstration is in terms of a single trajectory, we will not update Θt after each mistake as in Algorithm 1, but only make an update after every mini-batch of mistakes, and aggregate them to form accurate update rules. See Algorithm 2. The choice of batch size n depends on the accuracy we need, and will be determined by the following concentration inequality.\nLemma 3 (Azuma’s inequality for martingales). Suppose {S0, S1, . . . , Sn} is a martingale and |Si − Si−1| ≤ b almost surely. Then with probability at least 1 − δ we have |Sn − S0| ≤ b √ 2n log(2/δ).\nTheorem 5. ∀δ ∈ (0, 1), with probability at least 1−δ, the number of mistakes made by Algorithm 2 with parameters\nΘ0 = {θ ∈ [−1, 1]d : θ(sref) = 0}, H = ⌈ log(12/ǫ)\n1−γ\n⌉ , and\nn =\n⌈ log( 4d(d+1) log 6 √ d ǫ\nδ )\n32ǫ2\n⌉ where d = |S| − 1, is at most\nAlgorithm 2 Trajectory version of Algorithm 1 for MDPs\n1: Input: Θ0, H, n. // variables with ′ are converted as in Example 1. 2: Θ1 := MVEE(Θ ′ 0), i ← 0, Z̄ ← 0, Z̄⋆ ← 0. 3: for t = 1, 2, . . . do 4: Nature reveals (Et, Rt). 5: Agent rolls-out a trajectory using πt greedily\nw.r.t. ct + R ′ t, where ct is the center of Θt.\n6: if agent takes a in swithQ⋆(s, a) < V ⋆(s)−ǫ then 7: Human produces an H-step trajectory from s,\nwhose empirical state occupancy vector (excluding the sref coordinate) is denoted as ẑ ⋆,H i .\n8: i ← i+ 1, Z̄⋆ ← Z̄⋆ + ẑ⋆,Hi . 9: Let zi be the state occupancy of πt from initial\nstate s, and Z̄ ← Z̄ + zi. 10: if i = n then 11: Θt+1 := MVEE({θ ∈ Θt : (θ−ct)⊤(Z̄⋆−Z̄) ≥ 0}). 12: i ← 0, Z̄ ← 0, Z̄⋆ ← 0. 13: else 14: Θt+1 = Θt. 15: end if 16: else 17: Θt+1 = Θt. 18: end if 19: end for\nÕ(d 2\nǫ2 log( d δǫ )). 5\nThe proof of Theorem 5 is deferred to Appendix E."
    }, {
      "heading" : "8. Related work & Conclusions",
      "text" : "Most existing work in IRL focused on inferring the reward function using data acquired from a fixed environment (Ng & Russell, 2000; Abbeel & Ng, 2004; Coates et al., 2008; Ziebart et al., 2008; Ramachandran & Amir, 2007; Syed & Schapire, 2007; Regan & Boutilier, 2010). There is prior work on using data collected from multiple — but exogenously fixed— environments to predict agent behavior (Ratliff et al., 2006). There are also applications where methods for single-environment MDPs have been adapted to multiple environments (Ziebart et al., 2008). Nevertheless, all these works consider the objective of mimicking an optimal behavior in the presented environment(s), and do not aim at generalization to new tasks.\nIn the economics literature, the problem of inferring an agent’s utility from behavior has long been studied under the heading of utility or preference elicitation (Chajewska et al., 2000; Von Neumann & Morgenstern, 2007; Regan & Boutilier,\n5A log log(1/ǫ) term is suppressed in Õ(·).\n2009; 2011; Rothkopf & Dimitrakakis, 2011). When these models analyze Markovian environments, they assume a fixed environment where the learner can ask certain types of queries, such as bound queries eliciting whether the reward in a state (and action) is above a threshold. While our result in Section 5 uses similar techniques to elicit the reward function, we do so purely by observing the human’s behavior without external source of information (e.g., query responses).\nThe issue of reward misspecification is often mentioned in AI safety articles (e.g., Bostrom, 2003; Russell et al., 2015; Amodei et al., 2016). These articles mostly discuss the ethical concerns and possible research directions, while our paper develops mathematical formulations and algorithmic solutions. Recently, Hadfield-Menell et al. (2016) proposed cooperative inverse reinforcement learning, where the human and the agent act in the same environment, allowing the human to actively resolve the agent’s uncertainty on the reward function. However, they only consider a single environment (or task), and the unidentifiability issue of IRL still exists. Combining their interesting framework with our resolution to unidentifiability (by multiple tasks) can be an interesting future direction."
    }, {
      "heading" : "A. Proof of Lemma 2",
      "text" : "The construction is as follows. Choose sref as the initial state, and make all other states absorbing. Let R′(sref) = 0 and R′ restricted on S \\ {sref} coincide with R. The remaining work is to design the transition distribution of each action in sref so that the induced state occupancy matches exactly one column ofX .\nFixing any action a, and let x be the feature that we want to associate a with. The next-state distribution of (sref, a) is as follows: with probability p = 1−‖x‖11−γ‖x‖1 the next-state is sref itself, and the probability of transitioning to the j-th state in S \\ {sref} is 1−γ1−γ‖x‖1x(j). Given ‖x‖1 ≤ 1 and x ≥ 0, it is easy to verify that this is a valid distribution. Nowwe calculate the occupancy of policy π(sref) = a. The normalized occupancy on sref is\n(1 − γ)(p+ γp2 + γ2p3 + · · · ) = p(1− γ) 1− γp = 1− ‖x‖1.\nThe remaining occupancy, with a total ℓ1 mass of ‖x‖1, is split among S \\ {sref} proportional to x. Therefore, when we convert the MDP problem as in Example 1, the corresponding feature vector is exactly x, so we recover the original linear bandit problem."
    }, {
      "heading" : "B. Theorem 4 is tight in the worst case",
      "text" : "We show that the theorem is tight up to a constant factor in the worst case. Let X = [ U −U ] where Ud×d is any orthonormal matrix, so K = 2d. This is a valid choice of X because its column vector x satisfies ‖x‖1 ≤ ‖x‖2 = 1. All d singular values ofX are √ 2, and X̃ = X ,\nso spread(X) = √ 2, and the bound is ǫ √ 2d− 1/2 = O(ǫ √ d). Since U is arbitrary, we choose its first row to be 1⊤d / √ d.\nThen we choose an ellipsoid center c and θ⋆ that are ǫ √ d/2 different from each other in ℓ∞ distance, and show that a mistake is impossible. In particular, let c be equal to θ⋆ except on the first coordinate where they differ by ǫ √ d/2. Let a be the action taken by the algorithm and a⋆ be an optimal action, and R be any task reward, we have\nloss = (θ⋆ +R)(x a⋆ − xa)\n≤ (θ⋆ +R)(xa ⋆ − xa)− (c+R)(xa⋆ − xa) = (θ⋆ − c)(xa ⋆ − xa) = |θ⋆(1)− c(1)||xa ⋆\n(1)− xa(1)| ≤ ǫ √ d/2 · (2/ √ d) = ǫ.\nIn addition, note that the same construction also works if we rescale X with any multiplicative constant C ∈ (0, 1),\nhence the bound is tight in the worst case not only for spread(X) = √ 2, but for a range spread(X) ∈ (0, √ 2].\nC. Bounding the ℓ ∞ distance between θ⋆ and\nthe ellipsoid center\nTo prove Theorem 5, we need an upper bound on ‖θ⋆ − c‖∞ for quantifying the error due toH-step truncation and sampling effects, where c is the ellipsoid center. As far as we know there is no standard result on this issue. However, a simple workaround, described below, allows us to assume ‖θ⋆ − c‖∞ ≤ 2 without loss of generality. Whenever ‖c‖∞ > 1, there exists coordinate j such that |cj | > 1. We can make a central cut e⊤j (θ − c) < 0 (or > 0 depending on the sign of cj), and replace the original ellipsoid with the MVEE of the remaining shape. This operation never excludes any point in Θ0, hence it allows the proofs of Theorem 2 and 5 to work. We keep making such cuts and update the ellipsoid accordingly, until the new center satisfies ‖c‖∞ ≤ 1. Since central cuts reduce volume substantially (Lemma 1) and there is a lower bound on the volume, the process must stop after finite number of operations. After the process stops, we have ‖θ⋆ − c‖∞ ≤ ‖θ⋆‖∞ + ‖c‖∞ ≤ 2."
    }, {
      "heading" : "D. Proof of Theorem 3",
      "text" : "As a standard trick, we randomize θ⋆ by sampling each element i.i.d. from Unif([−1, 1]). We will prove that there exists a strategy of choosing (Xt, Rt) such that any algorithm’s expected number of mistakes is Ω(d log(1/ǫ), where the expectation is with respect to the randomness of θ⋆ and the internal randomness of the algorithm. This immediately implies a worst-case result as max is no less than average (regarding the sampling of θ⋆).\nIn our construction,Xt = [0d, ejt ], where jt is some index to be specified. Hence, every round the agent is essentially asked to decided whether θ(jt) ≥ −Rt(jt). The adversary’s strategy goes in phases, and Rt remains the same during each phase. Every phase has d rounds where jt is enumerated over {1, . . . , d}. To fully specify the nature’s strategy, it remains to specify Rt for each phase.\nIn the 1st phase, Rt ≡ 0. For each coordinate j, the information revealed to the agent is one of the following: θ⋆(j) > ǫ, θ⋆(j) ≥ −ǫ, θ⋆(j) < −ǫ, θ⋆(j) ≤ ǫ. For clarity we first make an simplification, that the revealed information is either θ⋆(j) > 0 or θ⋆(j) ≤ 0; we will deal with the subtleties related to ǫ at the end of the proof.\nIn the 2nd phase, we fix Rt as\nRt(j) = { −1/2 if θ⋆(j) ≥ 0, 1/2 if θ⋆(j) < 0.\nSince θ⋆ is randomized i.i.d. for each coordinate, the posterior of θ⋆ + Rt conditioned on the revealed information is Unif[−1/2, 1/2], for any algorithm and any interaction history. Therefore the 2nd phase is almost identical to the 1st phase except that the intervals have shrunk by a factor of 2. Similarly in the 3rd phase we use Rt to offset the posterior of θ⋆ +Rt to Unif([−1/4, 1/4]), and so on. In phase m, the half-length of the interval is 2−m+1, and the probability that a mistake occurs is at least 1/2 − ǫ/2−m+2 for any algorithm. The whole process continues as long as this probability is greater than 0. By linearity of expectation, we can lower bound the total mistakes by the sum of expected mistakes in each phase, which gives\n∑\n2−m+1≥ǫ d(1/2− ǫ/2−m+2)\n≥ ∑\n2−m+1≥2ǫ d · 1/4 ≥ ⌊log2(1/ǫ)⌋d/4.\nThe above analysis made a simplification that the posterior of θ⋆ + Rt in phase m is [−2−m+1, 2−m+1]. We now remove the simplification. Note, however, that the actual posterior cannot be too different from this simplified version, and their end points can differ by at most ǫ. So the error probability is at least 1/2− 2ǫ/(2−m+2 − 2ǫ). The rest of the analysis is similar: we count the number of mistakes until the error probability drops below 1/4, and in each of these phases we get at least d/4 mistakes in expectation. The number of such phases is given by\n1/2− 2ǫ/(2−m+2 − 2ǫ) ≥ 1/4,\nwhich is satisfied if 2−m+2 ≥ 6ǫ, so m ≥ ⌊log2 23ǫ⌋. This completes the proof."
    }, {
      "heading" : "E. Proof of Theorem 5",
      "text" : "Since the update rule is still in the format of a central cut through the ellipsoid, Lemma 1 applies. It remains to show that the update rule preserves θ⋆ and a certain volume around it, and then we can follow the same argument as for Theorem 2.\nFixing a mini-batch, let t0 be the round on which the last update occurs, and Θ = Θt0 , c = ct0 . Note that Θt = Θ during the collection of the current mini-batch and does not change, and ct = c similarly.\nFor each i = 1, 2, . . . , n, define z⋆,Hi as the expected value of ẑ⋆,Hi , where expectation is with respect to the randomness of the trajectory produced by the human, and let z⋆i be the infinite-step expected state occupancy. Note that ẑ⋆,Hi , z ⋆,H i , z ⋆ i ∈ R|S|−1 because the occupancy on sref is not included.\nAs before, we have θ⊤⋆ (z ⋆ i − zi) > ǫ and c⊤(z⋆i − zi) ≤ 0, so (θ⋆ − c)⊤(z⋆i − zi) > ǫ. Taking average over i, we get (θ⋆ − c)⊤( 1n ∑n i=1 z ⋆ i − 1n ∑n i=1 zi) > ǫ. What we will show next is that (θ⋆ − c)⊤( Z̄ ⋆\nn − Z̄n ) > ǫ/3 for Z̄⋆ and Z̄ on Line 11, which implies that the update rule is valid and has enough slackness for lower bounding the volume of Θt as before. Note that\n(θ⋆ − c)⊤( Z̄ ⋆ n − Z̄n ) = (θ⋆ − c)⊤( 1n ∑n i=1 z ⋆ i − 1n ∑n i=1 zi)\n− (θ⋆ − c)⊤( 1n ∑n i=1 z ⋆ i − 1n ∑n i=1 z ⋆,H i ) − (θ⋆ − c)⊤( 1n ∑n i=1 z ⋆,H i − 1n ∑n i=1 ẑ ⋆,H i ).\nHere we decompose the expression of interest into 3 terms. The 1st term is lower bounded by ǫ as shown above, and we will upper bound each of the remaining 2 terms by ǫ/3. For the 2nd term, since ‖z⋆,Hi − z⋆i ‖1 ≤ γH , the ℓ1 norm of the average follows the same inequality due to convexity, and we can bound the term using Hölder’s inequality given ‖θ⋆ − c‖∞ ≤ 2 (see details of this result in Appendix C). To verify that the choice of H in the theorem statement is appropriate, we can upper bound the 2nd term as\n2γH = 2((1− (1 − γ)) 11−γ )log(6/ǫ) ≤ 2e− log(6/ǫ) = ǫ3 .\nFor the 3rd term, fixing θ⋆ and c, the partial sum∑i j=1(θ⋆ − c)⊤(z ⋆,H i − ẑ ⋆,H i ) is a martingale. Since ‖z⋆,Hi ‖1 ≤ 1, ‖ẑ ⋆,H i ‖1 ≤ 1, and ‖θ⋆ − c‖∞ ≤ 2, we can initiate Lemma 3 by letting b = 4, and setting n to sufficiently large to guarantee that the 3rd term is upper bounded by ǫ/3 with high probability.\nGiven (θ⋆ − c)⊤( Z̄ ⋆ n − Z̄n ) > ǫ/3, we can follow exactly the same analysis as for Theorem 2 to show that B∞(θ⋆, ǫ/6) is never eliminated, and the number of updates can be bounded by 2d(d + 1) log 12 √ d\nǫ . The number\nof total mistakes is the number of updates multiplied by n, the size of the mini-batches. Via Lemma 3, we can verify that the choice of n in the theorem statement satisfies |∑ij=1(θ⋆ − c)⊤(z ⋆,H i − ẑ ⋆,H i )| ≤ nǫ/3 with probability\nat least 1−δ/ ( 2d(d+ 1) log 12 √ d\nǫ\n) . Union bounding over\nall updates and the total failure probability can be bounded by δ."
    } ],
    "references" : [ {
      "title" : "Apprenticeship Learning via Inverse Reinforcement Learning",
      "author" : [ "Abbeel", "Pieter", "Ng", "Andrew Y" ],
      "venue" : "In Proceedings of the 21st International Conference on Machine learning,",
      "citeRegEx" : "Abbeel et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Abbeel et al\\.",
      "year" : 2004
    }, {
      "title" : "An application of reinforcement learning to aerobatic helicopter flight",
      "author" : [ "Abbeel", "Pieter", "Coates", "Adam", "Quigley", "Morgan", "Ng", "Andrew Y" ],
      "venue" : "Advances in neural information processing systems,",
      "citeRegEx" : "Abbeel et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Abbeel et al\\.",
      "year" : 2007
    }, {
      "title" : "Towards resolving unidentifiability in inverse reinforcement learning",
      "author" : [ "Amin", "Kareem", "Singh", "Satinder" ],
      "venue" : "arXiv preprint arXiv:1601.06569,",
      "citeRegEx" : "Amin et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Amin et al\\.",
      "year" : 2016
    }, {
      "title" : "Concrete problems in ai safety",
      "author" : [ "Amodei", "Dario", "Olah", "Chris", "Steinhardt", "Jacob", "Christiano", "Paul", "Schulman", "John", "Mané", "Dan" ],
      "venue" : "arXiv preprint arXiv:1606.06565,",
      "citeRegEx" : "Amodei et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Amodei et al\\.",
      "year" : 2016
    }, {
      "title" : "Ethical issues in advanced artificial intelligence. Science Fiction and Philosophy: From Time Travel to Superintelligence",
      "author" : [ "Bostrom", "Nick" ],
      "venue" : null,
      "citeRegEx" : "Bostrom and Nick.,? \\Q2003\\E",
      "shortCiteRegEx" : "Bostrom and Nick.",
      "year" : 2003
    }, {
      "title" : "Making rational decisions using adaptive utility elicitation",
      "author" : [ "Chajewska", "Urszula", "Koller", "Daphne", "Parr", "Ronald" ],
      "venue" : "In AAAI/IAAI, pp",
      "citeRegEx" : "Chajewska et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Chajewska et al\\.",
      "year" : 2000
    }, {
      "title" : "Geometric algorithms and combinatorial optimization, volume 2",
      "author" : [ "Grötschel", "Martin", "Lovász", "László", "Schrijver", "Alexander" ],
      "venue" : "Springer Science & Business Media,",
      "citeRegEx" : "Grötschel et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Grötschel et al\\.",
      "year" : 2012
    }, {
      "title" : "Cooperative inverse reinforcement learning",
      "author" : [ "Hadfield-Menell", "Dylan", "Russell", "Stuart J", "Abbeel", "Pieter", "Dragan", "Anca" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Hadfield.Menell et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Hadfield.Menell et al\\.",
      "year" : 2016
    }, {
      "title" : "Algorithms for inverse reinforcement learning",
      "author" : [ "Ng", "AndrewY", "Russell", "Stuart J" ],
      "venue" : "In Proceedings of the 17th International Conference onMachine Learning,",
      "citeRegEx" : "Ng et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Ng et al\\.",
      "year" : 2000
    }, {
      "title" : "Bayesian inverse reinforcement learning",
      "author" : [ "Ramachandran", "Deepak", "Amir", "Eyal" ],
      "venue" : "Urbana, 51:61801,",
      "citeRegEx" : "Ramachandran et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Ramachandran et al\\.",
      "year" : 2007
    }, {
      "title" : "Maximum margin planning",
      "author" : [ "Ratliff", "Nathan D", "Bagnell", "J Andrew", "Zinkevich", "Martin A" ],
      "venue" : "In Proceedings of the 23rd International Conference on Machine Learning,",
      "citeRegEx" : "Ratliff et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Ratliff et al\\.",
      "year" : 2006
    }, {
      "title" : "Regret-based reward elicitation for markov decision processes",
      "author" : [ "Regan", "Kevin", "Boutilier", "Craig" ],
      "venue" : "In Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Regan et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Regan et al\\.",
      "year" : 2009
    }, {
      "title" : "Robust policy computation in reward-uncertain mdps using nondominated policies",
      "author" : [ "Regan", "Kevin", "Boutilier", "Craig" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "Regan et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Regan et al\\.",
      "year" : 2010
    }, {
      "title" : "Eliciting additive reward functions for markov decision processes",
      "author" : [ "Regan", "Kevin", "Boutilier", "Craig" ],
      "venue" : "In IJCAI Proceedings-International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Regan et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Regan et al\\.",
      "year" : 2011
    }, {
      "title" : "Preference elicitation and inverse reinforcement learning",
      "author" : [ "Rothkopf", "Constantin A", "Dimitrakakis", "Christos" ],
      "venue" : "In Machine Learning and Knowledge Discovery in Databases,",
      "citeRegEx" : "Rothkopf et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Rothkopf et al\\.",
      "year" : 2011
    }, {
      "title" : "Research priorities for robust and beneficial artificial intelligence",
      "author" : [ "Russell", "Stuart", "Dewey", "Daniel", "Tegmark", "Max" ],
      "venue" : "AI Magazine,",
      "citeRegEx" : "Russell et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Russell et al\\.",
      "year" : 2015
    }, {
      "title" : "Online learning and online convex optimization",
      "author" : [ "Shalev-Shwartz", "Shai" ],
      "venue" : "Foundations and Trends in Machine Learning,",
      "citeRegEx" : "Shalev.Shwartz and Shai.,? \\Q2011\\E",
      "shortCiteRegEx" : "Shalev.Shwartz and Shai.",
      "year" : 2011
    }, {
      "title" : "A game-theoretic approach to apprenticeship learning",
      "author" : [ "Syed", "Umar", "Schapire", "Robert E" ],
      "venue" : "In Advances in neural information processing systems,",
      "citeRegEx" : "Syed et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Syed et al\\.",
      "year" : 2007
    }, {
      "title" : "Theory of games and economic behavior (60th Anniversary Commemorative Edition)",
      "author" : [ "Von Neumann", "John", "Morgenstern", "Oskar" ],
      "venue" : "Princeton university press,",
      "citeRegEx" : "Neumann et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Neumann et al\\.",
      "year" : 2007
    }, {
      "title" : "Maximum entropy inverse reinforcement learning",
      "author" : [ "Ziebart", "Brian D", "Maas", "Andrew L", "Bagnell", "J Andrew", "Dey", "Anind K" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "Ziebart et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Ziebart et al\\.",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 15,
      "context" : "This is particularly relevant because IRL is a possible approach to the concern about aligning the agent’s values/goals with those of humans for AI safety as society deploys more capable learning agents that impact more people in more ways (Russell et al., 2015; Amodei et al., 2016).",
      "startOffset" : 240,
      "endOffset" : 283
    }, {
      "referenceID" : 3,
      "context" : "This is particularly relevant because IRL is a possible approach to the concern about aligning the agent’s values/goals with those of humans for AI safety as society deploys more capable learning agents that impact more people in more ways (Russell et al., 2015; Amodei et al., 2016).",
      "startOffset" : 240,
      "endOffset" : 283
    }, {
      "referenceID" : 19,
      "context" : "Most existing work in IRL focused on inferring the reward function using data acquired from a fixed environment (Ng & Russell, 2000; Abbeel & Ng, 2004; Coates et al., 2008; Ziebart et al., 2008; Ramachandran & Amir, 2007; Syed & Schapire, 2007; Regan & Boutilier, 2010).",
      "startOffset" : 112,
      "endOffset" : 269
    }, {
      "referenceID" : 10,
      "context" : "There is prior work on using data collected from multiple — but exogenously fixed— environments to predict agent behavior (Ratliff et al., 2006).",
      "startOffset" : 122,
      "endOffset" : 144
    }, {
      "referenceID" : 19,
      "context" : "There are also applications where methods for single-environment MDPs have been adapted to multiple environments (Ziebart et al., 2008).",
      "startOffset" : 113,
      "endOffset" : 135
    }, {
      "referenceID" : 15,
      "context" : "The issue of reward misspecification is often mentioned in AI safety articles (e.g., Bostrom, 2003; Russell et al., 2015; Amodei et al., 2016).",
      "startOffset" : 78,
      "endOffset" : 142
    }, {
      "referenceID" : 3,
      "context" : "The issue of reward misspecification is often mentioned in AI safety articles (e.g., Bostrom, 2003; Russell et al., 2015; Amodei et al., 2016).",
      "startOffset" : 78,
      "endOffset" : 142
    }, {
      "referenceID" : 3,
      "context" : ", 2015; Amodei et al., 2016). These articles mostly discuss the ethical concerns and possible research directions, while our paper develops mathematical formulations and algorithmic solutions. Recently, Hadfield-Menell et al. (2016) proposed cooperative inverse reinforcement learning, where the human and the agent act in the same environment, allowing the human to actively resolve the agent’s uncertainty on the reward function.",
      "startOffset" : 8,
      "endOffset" : 233
    } ],
    "year" : 2017,
    "abstractText" : "How detailed should we make the goals we prescribe to AI agents acting on our behalf in complex environments? Detailed & low-level specification of goals can be tedious and expensive to create, and abstract & high-level goals could lead to negative surprises as the agent may find behaviors that we would not want it to do, i.e., lead to unsafe AI. One approach to addressing this dilemma is for the agent to infer human goals by observing human behavior. This is the Inverse Reinforcement Learning (IRL) problem. However, IRL is generally ill-posed for there are typically many reward functions for which the observed behavior is optimal. While the use of heuristics to select from among the set of feasible reward functions has led to successful applications of IRL to learning from demonstration, such heuristics do not address AI safety. In this paper we introduce a novel repeated IRL problem that captures an aspect of AI safety as follows. The agent has to act on behalf of a human in a sequence of tasks and wishes to minimize the number of tasks that it surprises the human. Each time the human is surprised the agent is provided a demonstration of the desired behavior by the human. We formalize this problem, including how the sequence of tasks is chosen, in a few different ways and provide some foundational results.",
    "creator" : "LaTeX with hyperref package"
  }
}