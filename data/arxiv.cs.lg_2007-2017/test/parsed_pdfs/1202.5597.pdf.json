{
  "name" : "1202.5597.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Hybrid Batch Bayesian Optimization",
    "authors" : [ "Javad Azimi", "Ali Jalali", "Xiaoli Fern" ],
    "emails" : [ "azimi@eecs.oregonstate.edu", "alij@utexas.edu", "xfern@eecs.oregonstate.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Bayesian optimization tries to optimize an unknown function f(·) by requesting a set of experiments when f(·) is costly to evaluate [8, 4]. In this work, we are interested in finding a point x∗ ∈ X d such that:\nx∗ = argmax x∈Xd f(x), (1)\nwhere X d is our d-dimensional compact input space and f(·) is the non-concave underlying function which has multiple local optima. The function f(·) might be the performance of a black box device characterized by input x. For example, in our motivating application we try to optimize the power output of nano-enhanced Microbial Fuel Cells (MFCs). MFCs [3] use micro-organisms to generate electricity. It has been shown that efficiency of generated electricity power significantly depends on the surface properties of the anode [12]. Our problem involves optimizing the surface properties of the anodes in order to maximize the output power. The goal is to develop an efficient BO algorithm for this application since running an experiment is very expensive and time consuming.\nFocusing on the task of function maximization, each run of BO consists of two main steps: estimating the values of the unknown function f(·) via a probabilistic model such as GP, and selecting the best next experiment(s) according to the probabilistic model via some selection criterion. The results of the experiment(s) are then be added to update the probabilistic model and this cycle is repeated until we meet a stopping criterion.\nMost of the proposed selection criteria in BO are sequential, where only one experiment is selected at each iteration [11, 8, 14, 9]. Sequential policies usually perform very well in practice, since they optimize the experiment selection at each iteration by using the maximum available information for each experiment. However, they are not time efficient in many applications where running an experiment takes a long time, and we have the capability to run multiple experiments in parallel. This motivates the batch algorithms in which more than one experiment is selected at each iteration.\nRecently, Azimi et al. [2] introduced a batch BO approach that selects a batch of k experiments at each iteration that approximates the behavior of a given sequential heuristic. Ginsbourger et al. [7] introduced a constant liar heuristic algorithm to select a batch of experiments based on the Expected Improvement (EI) [9] policy. Specifically, after\nar X\niv :1\n20 2.\n55 97\nv3 [\ncs .A\nI] 1\nM ay\nselecting an experiment by EI, the output of the selected point is set to a constant value. This experiment is then added to the prior and the procedure is repeated until k experiments are selected. Although these two batch algorithms [2, 7] can speedup the experiment selection by a factor of k, their results show that batch selection in general performs worse than the sequential EI policy, especially when the total number of experiments is small. This observation motivates us to introduce a Hybrid BO approach that dynamically alternates between sequential and batch selection to achieve improved time efficiency over sequential without degrading the optimization performance.\nIn this paper, we focus on a class of batch policies that is based on simulating a sequential policy and provide a systematic approach to analyze such batch BO policies. We analytically connect the mismatch between the BO’s probabilistic model and the underlying true function to the performance of the batch policy. We provide full characterization of simulated-based batch policies when the batch size is 2. For the purpose of illustration, consider a batch policy that selects 2 experiments. The first experiment matches the sequential policy. The choice of the second experiment, however, will depend on what is the simulated outcome of the first experiment. We show that the distance between the second experiment picked by a simulation-based batch policy (without the knowledge of the output of the first experiment) and the one picked by the sequential policy (with the knowledge of the output of the first experiment) is upper-bounded by a quantity that is proportional to the square root of the estimation error (of the outcome of the first experiment).\nThis analysis naturally gives rise to our hybrid batch/sequential algorithm. Our algorithm works as follows: At each step, given any sequential policy (EI in this paper), find the best next single experiment and estimate its possible outcome via BO’s probabilistic model (GP in this paper). Then, update the prior with that point and choose the next best single experiment and so on. We analytically show that this process can be continued until a certain stopping criterion is met. This stopping criterion measures how much a simulated experiment is going to bias our probabilistic model (mainly because of inaccuracy in estimation of the outcomes of the first experiment). If the bias is small, we continue to add more examples to our batch; and if it is large, we stop.\nThe proposed algorithm has the appealing property that it behaves more like a sequential policy in early stages when the number of observed experiments is small, and naturally transits to batch mode in later stages when more experiments are available. This is because the stopping criterion tends to be more stringent in early stages because the bias of the prior can be potentially large, forcing the algorithm to act sequentially. The beauty of this algorithm is that it evolves from a sequential algorithm to a batch algorithm in an optimal manner characterized by our theoretical results.\nExperimental results show that the proposed algorithm can achieve up to 78% speedup over the sequential policy without degrading the performance even with a very small number of experiments. We also show that, by increasing the number of experiments, the speedup rate is increased significantly which is consistent with the theoretical results presented in the paper.\nThe paper is organized as follows. We introduce the Gaussian Process which is used as our model in Section 2. The proposed dynamic batch algorithm is described in Section 3. Section 4 presents the experimental results and the paper is concluded in Section 5"
    }, {
      "heading" : "2 Gaussian Process",
      "text" : "A BO algorithm has two main ingredients: a probabilistic model for the unknown function, and, a selection criterion for choosing next best experiment(s) based on the model. We select GP [13] as our probabilistic model and EI [9] as our selection criterion. We study the properties of GP in this section and postpone the analysis of EI to the next section.\nWe use GP to build the posterior over the outcome values given our observation set O = (xO,yO), where, xO = {x1, x2, . . . , xn} is the set of inputs and yO = {y1, y2, . . . , yn} is the set of outcomes (of the experiment) such that yj = f(xj) and f(·) is the underlying unknown function.\nFor a new input point xi, GP models the unknown output yi = f(xi) as a normal random variable yi ∼ N (µxi|O, σ2xi|O), with µxi|O = k(xi,xO)k(xO,xO) −1yO and σ 2 xi|O = k(xi, xi)− k(xi,xO)k(xO,xO)\n−1k(xO, xi), where, k(·, ·) is any arbitrary kernel function.\nDefinition 1. Let x = {x1, x2, . . . , xm} ∈ X \\ xO be any unobserved set of points. Let ŷ = {ŷ1, ŷ2, . . . , ŷm} be our estimate of their outputs based on GP considering yi|O ∼ N (µxi|O, σ2xi|O). For any new point z ∈ X \\ {xO ∪ x}, let yz|O ∼ N (µz|O, σ2z|O) and yz|O, (x, ŷ) ∼ N (µ̂z|O,x, σ̂ 2 z|O,x).\nUnder the GP model, the variance of a point z depends only on the location of the observed points and is independent of their outputs, i.e., σ̂2z|O,x = σ 2 z|O,x. Therefore, we can update the variance of any point z after finalizing\nour new query set x without the knowledge of their true outputs y = f(x). The following theorem characterizes the change in the variance of z if we query x.\nTheorem 1. Assuming ∆(σz) := σ2z|O − σ 2 z|O,x, we have\n∆(σz) = ( CA−1BT− k(z,x) ) D ( CA−1BT− k(z,x) )T , (2)\nwhere, B = k(x,xO), A = k(xO,xO), C = k(z,xO) and D = (k(x,x)−BA−1BT )−1.\nFrom a practical point of view, this theorem enables us to update the variance of z via computing the difference ∆(σz) and add it to the previous value. This scheme is much faster than recalculating the variance of z directly. The computational bottleneck of this update is only the matrix inversion in D with complexity O(m3), considering the fact that k(xO,xO)−1 has been computed before, while the complexity of the direct variance computation is O ( (n+m)3 ) .\nThe actual expected value µz|O,x heavily depends on the true outputs y = f(x), which are not available. Without the knowledge of the true outputs, we make an estimation µ̂z|O,x based on the GP-suggested output values ŷ. We bound this estimation error in the next theorem. Theorem 2. Let γz = ∥∥(k(z,x)− CA−1BT )D∥∥\n2 . Then,∣∣µz|O,x − µ̂z|O,x∣∣ ≤ γz ∥∥y − ŷ∥∥2∣∣µz|O,x − µz|O∣∣ ≤ γz∥∥y − µx|O∥∥2.\nHere, ‖ · ‖2 is vector 2-norm. This theorem tells us that our estimation error at point z is proportional to the parameter γz , which is known to us without the knowledge of y. Intuitively, if γz is small, we would think that our estimation µ̂z|O,x is accurate and hence, we can make our decision about the point z without knowing y, i.e., before the result of experiment on x returns. This observation tells us that it is possible to do batch BO without a big loss in performance.\nRemark: If we want to minimize our estimation error of µ̂z|O,x in expectation, we should set ŷ = µx|O. This is in some sense trivial and even counter intuitive. One might claim that if the unknown function is upper-bounded by M , then the best choice for ŷ is M since it increases the expected value around the optimal point in the GP model. However, this theorem shows that this choice is overly optimistic.\nThe previous theorem provides a performance bound based on our estimation error on ŷ, however, from a practical point of view, that bound cannot be computed since we do not know the exact values of y. As a practical measure, we would like to focus on the expected value of the estimation error as opposed to the error itself. Next corollary provides an upper-bound on the expected error, by simply taking expectation from the result of theorem 2. Corollary 1. Let θx := √∑m\ni=1 σ 2 xi|O, then\nEy [ |µz|O,x − µz|O| ] ≤ γzθx.\nMoreover, Ey [ |µz|O,x − µ̂z|O,x| ] ≤ γz ( θx + ‖ŷ − µx|O‖2 ) .\nRemark 1: We focus on the second bound in this corollary, which has two terms. The first term (γzθx) measures “how close” the point z is to x. The second term captures the bias of our estimator ŷ. According to this corollary, the best choice for ŷ is the mean µx|O.\nRemark 2: This corollary entails that if for some small value of , we have γz ( θx + ‖ŷ − µx|O‖2 ) ≤ , (3)\nthen, we are guaranteed that Ey [ |µz|O,x − µ̂z|O,x| ] ≤ .\nSince γz and θx are both computable without the knowledge of y, this observation motivates us to use this as a stopping criterion for our algorithm to determine if the current estimation bias is too large to continue selecting more examples in the batch. In the nutshell, when we want to query a batch of samples, if this criterion is met, we are sure that our estimation of y is accurate and hence, we do not need to wait for the label of the selected examples before making the next selection."
    }, {
      "heading" : "3 Hybrid Batch Bayesian Optimization",
      "text" : "In a sequential approach, we query for only one experiment at a time using a selection criterion (policy), mainly because the selection criterion requires the output of the previous query to find the next best one. Suppose we have the capability of running nb experiments in parallel, and we are limited by the total number of possible experiments nl. At each iteration, the question is whether or not we can query more than one sample to speed up the experimental procedure without losing performance comparing to the sequential approach.\nWe use Expected Improvement (EI) as our base sequential selection criterion. Below we provide the formal definition for EI.\nDefinition 2. EI[9] at point x with associated GP prediction y|O ∼ N (µx|O, σ2x|O) is defined to be\nEI(x|O) = ( − uΦ(−u) + φ(u) ) σx|O, (4)\nwhere, u = (ymax − µx|O)/σx|O and ymax = max yi∈yO yi. Also, Φ(·) and φ(·) represent standard Gaussian distribution and density functions respectively.\nOur proposed algorithm selects a batch (possibly one) of samples at each iteration based on the EI policy, where the batch size is dynamically determined at each step. In particular, the algorithm will continue to select more experiments if the condition in (3) is satisfied for the select point z.\nTo explain the algorithm, suppose we are at the beginning of the first round of the algorithm. Thus far, we have observed yO = f(xO) at some randomly chosen sample points xO. To form our batch query, we start from an empty set of samples and gradually add the next best sample one at a time. The first sample we pick (x1) is identical to the first sample that sequential EI picks (x∗1), simply because both maximize the same objective, i.e., x1 = x ∗ 1. To pick our second sample, we estimate y∗1 = f(x ∗ 1) by some value ŷ1. This estimation, changes the EI function of all unobserved points to some ÊI function formulated as\nÊI(z|O, x∗1) = ( − ûΦ(−û) + φ(û) ) σz|O,x∗1 ,\nwhere, û = max(ymax,ŷ1)−µ̂z|O,x∗1\nσz|O,x∗1 . This is different from the true EI function:\nEI(z|O, x∗1) = ( − uΦ(−u) + φ(u) ) σz|O,x∗1 ,\nwhere, u = max(ymax,y\n∗ 1 )−µz|O,x∗1\nσz|O,x∗1 . Obviously, optimizing ÊI might not lead to the optimum of the true EI . However,\nthe next lemma shows that these two functions are close to each other for a good estimation ŷ1.\nLemma 1. At any point z, we have∣∣∣EI(z|O, x∗1)− ÊI(z|O, x∗1)∣∣∣ ≤ 1 2 ( 1 + σz|O σx∗1 |O )∣∣∣ŷ1 − y∗1 ∣∣∣. (5) In the light of this lemma, there is hope that x2 = arg max ÊI (a potential batch sample from our algorithm) is close to x∗2 = arg max EI (the optimal sample picked by sequential policy). The next theorem bounds the error of our algorithm in terms of the second selected point in comparison to the sequential EI.\nTheorem 3. Let Σmin be the minimum singular value of the Hessian matrix d 2ÊI dx2 (x) on the line intersecting x2 and x∗2. Then, ∥∥∥x∗2 − x2∥∥∥2 2 ≤ 2 Σmin ( 1 + max(σx2|O, σx∗2 |O)\nσx∗1 |O ) ∣∣∣ŷ1 − y∗1 ∣∣∣. (6) Here x2 is the second point selected by our simulation based batch method without knowing the outcome of x1, whereas x∗2 is the second point selected by the sequential EI method after knowing the outcome of x1. Remark 1: The parameter Σmin captures the curvature of the ÊI function around its optimal point x2. This curvature cannot be zero unless x∗2 is very far from x2, which is very unlikely due to the closeness of their expected values (see Corollary 1).\nRemark 2: This theorem shows that the sample estimation error is proportional to the square root of the estimation error of y∗1 . This means that the sample estimation is more sensitive to the output estimation error for functions taking value in [0, 1].\nThis line of analysis can be extended to next samples. These results show that an algorithm based on the estimation can be successful. In practice, after we optimized ÊI for x2, then, we check the condition (3) (i.e., γx2(θx∗1 + ‖ŷ1 − µy|O‖2) ≤ ) and if this condition is satisfied, we add x2 to our batch query and move on to x3 and so on. Algorithm 1 summarizes our proposed method for hybrid batch Bayesian optimization.\nAlgorithm 1 Hybrid Batch Expected Improvement Input: Total budget of experiments (nl), maximum batch size (nb), the predictor (ŷ), current observation O = (xO ,yO) and stopping threshold .\nwhile nl > 0 do x∗1 ← arg max\nx∈X EI(x|O).\nA ← (x∗1, ŷ1), nl ← nl − 1.\nz ← arg max x∈X ÊI(x|O ∪ A). while ( γz(θxA + ‖ŷA − µxA|O‖2) ≤ ) and (nl > 0) and (|A| < nb) do\nA ← A∪ (z, ŷz), nl ← nl − 1. z ← arg max\nx∈X ÊI(x|O ∪ A).\nend while yA ← RunExperiment(xA) O ← O ∪ (xA,yA)\nend while return max(yO)\nIn early stages, this algorithm behaves more like a sequential policy since the criterion for building up a batch is very hard to satisfy, mainly because θx is large when we have only a few samples in O. After collecting enough samples, the term θx starts decreasing and as it gets closer and closer to zero, we can select larger and larger batch sizes. Thus, the algorithm gradually transits into a batch policy while maintaining a close match to the performance to the pure sequential policy.\n4 Experimental Results\nBenchmarks. We consider 6 well-known synthetic benchmark functions: Cosines and Rosenbrock [1, 5] over [0, 1]2, Hartman(3)[6] over [0, 1]3, Hartman(6)[6] over [0, 1]6, Shekel[6] over [3, 6]4 and Michalewicz [10] over [0, π]5. The analytic expression for these functions are shown in Table 1.\nThe other two real benchmarks are Fuel Cell and Hydrogen. In Fuel Cell, the goal is to maximize the generated electricity from microbial fuel cells with by changing the nano structure properties of the anodes. We fit a regression model on the data to build our function f(·) for evaluation. In Hydrogen benchmark, the data has been collected as part of a study on Hydrogen production from a particular bacteria where the goal is to maximize the amount of Hydrogen production by optimizing the PH and Nitrogen levels of growth medium. Both Fuel cell and Hydrogen data are in [0, 1]2. Their contour plots are shown in Figure 1.\nSetting. We use a GP using a zero-mean prior and Gaussian kernel function k(x, y) = exp(− 1l ‖ x− y ‖ 2), with kernel width l = 0.01Σdi=1li, where, li is the length of the i th dimension [2]. For this kernel function, we can directly\ndrive the next two corollaries from theorems 1, 2.\nCorollary 2. For all points z ∈ X \\ {O, x∗1}, and kernel function k(x, y) = e− ‖x−y‖2 l , we have ∆(σz) ≥ if\n‖ z − x∗1 ‖2≤ −l ln (√ n ‖ A−1BT ‖2 +σx∗1 |O √ ) .\nThis corollary entails that after selecting the first experiment x∗1, the set of points z such that ∆(σz) ≥ are located inside a hyper sphere centered at x∗1. In other words, those inside the hyper sphere are those whose variance is affected significantly (more than ) when x∗1 is selected.\nCorollary 3. Under the assumption of Corollary 2, we have E[|µz|O,x − µ̂z|O,x|] ≥ if ‖ z − x∗1 ‖2≤ −l ln √ π 2\n2σ6x∗1 |O − n ‖ A−1BT ‖22.\nSimilar to corollary 2, the corollary 3 represents a hyper sphere centered at x∗1 and the points which are inside the hyper sphere are those whose expected values are affected more than when x∗1 is selected.\nWe run our algorithm on each benchmark for 100 independent times and the average simple regret is reported as the result. The simple regret is the difference between the maximum value of f(·), denoted by M , and ymax after finishing the experimental procedure. In each run, the algorithm starts with 2 initial random points for 2, 3-dimensional benchmarks and 5 initial random points for higher dimensional benchmarks. The total number of experiments nl is set to 15 for 2, 3-dimensional and 30 for the higher dimensional benchmarks. The maximum batch size at each iteration, nb, is set to 5. The parameter is set to 0.02 for 2, 3-dimensional and 0.2 for higher dimensional benchmarks. Note that, our experimental setup is designed to match typical scenarios encountered in real applications, where we typically start with a very small number of random experiments, and are restricted with a total budget.\nResults. Our algorithm requires us to select a specific estimation for ŷ. Recall that our theoretical analysis from Theorem 2 suggests that to minimize the estimation error of µ̂z|O,x in expectation, we should use ŷ = µx|O. Here we hope to confirm this by comparing different possible estimations for ŷ. In particular, we consider 6 different estimations of ŷ including: 1) ŷ = M , which means we expect to observe the best possible output for each experiment selected by\nEI; 2) ŷ = ymax, where ymax = maxyi∈yO yi is our current best observation; 3) ŷ = (1 + ζ)ymax, which means each step of EI algorithm is expected to improve the best current observation by margin ζ, we set the value of ζ to 0.1 in our experiment; 4) ŷ = µ̂x|O, which means we set the value of ŷ to be the expected output at that point; 5) ŷ = ymin, where ymin = minyi∈yO yi is the current minimum observed output; and 6) ŷ = random, which set ŷ to a uniform random value drawn in [ymin, ymax].\nTo demonstrate the effectiveness of our algorithm, we consider two state-of-the-art batch BO algorithms in the literature: 1) simulation matching (Matching) [2] and 2) the constant liar approach in which the output of the selected samples in the batch is set to their mean in order to select the next experiment (CL(µ̂)) [7]. For both methods, we set the batch size to k = 5. We have also reported the performance of the sequential EI and pure random selection policies.\nThe speedup of our proposed approach is calculated as the percentage of the samples in the whole experiment that are selected in batch mode. More specifically, if we finish nl samples in T steps, the speedup is calculated as 1 − Tnl . Clearly, the maximum speedup in our setting is %80, that can be only achieved if we select 5 experiments at each time steps. For example, the speedup of proposed baseline batch approaches, Matching and CL(µ̂), are %80. Table 2 shows the result.\nInterestingly, all of the 6 considered estimators achieved similar performance (comparable to EI) in terms of their regrets. The key difference between the different estimators is the level of speedup they achieve. In particular, we observe that the most speedup is achieved by ŷ = µ̂x|O, for which we are able to produce over 70% speedup (very close to fully batch) for the three high dimensional functions Michalewicz, Shekel and Hartman 6.\nFurther inspection of the speedup rates reveal that setting ŷ to a large value, for exampleM , ymax, and (1+ζ)ymax, generally leads to less speedup than the other choices. This can be explained by noting that a large value of ŷ will lead to higher chance of violating the condition required for making the next experiment selection in Algorithm 1, which is stated in Equation 3. In particular, for a large ŷ, the next point selected by EI will most likely be very close to x, since the mean of the points close to x are high. This will lead to a large γz . Further, the quantity ‖ŷ − µx|O‖2 is likely very large. Consequently, it is easy to violate this condition thus stop the selection process early on. In contrast, if ŷ = ymin, although ‖ŷ − µx|O‖2 is large, we expect γz to be small because the next point z selected by EI will likely to be far away from x since the mean and variance of the points close to x are very small. Considering the two terms jointly, we expect to achieve a higher speedup by setting ŷ = ymin comparing to setting ŷ to a large value, which is exactly what we observe in our experiments. Finally, by setting ŷ to µx|O, we have ‖ŷ− µx|O‖2 = 0 and the stopping criterion only depends on γzθx. Thus we expect to achieve the maximum speedup among the different choices we consider for ŷ.\nOur experimental investigation shows that the size of the batch generally increases as the experiment goes forward. This is consistent with our theoretical results in which the value of γz ( θx + ‖ŷ − µx|O‖2 ) decreases as the variances decreases. Note that, sampling at any arbitrary point when the number of observations is small would change the\nvariance of the input space significantly comparing to the case where there are a lot of observation points. Therefore, the stopping criteria of Algorithm 1 is less likely to be met in the early stages of the experimental procedure where there are a few observation points.\nThe µ-Constant Batch Approach. This part of the experiments is motivated by our theoretical analysis and the goal is to shed some lights on a batch method recently proposed by Ginsbourger et al. [7], which selects a batch of experiments that jointly maximize the EI objective. They show that finding such a batch of experiments is practically intractable. Therefore, they introduced a heuristic approach called Constant liar to select a batch of k experiments. After selecting the first experiment, Constant liar sets the output of the selected experiment as a constant value c. That experiment is then added to the set of observations and the next experiment is selected. This procedure is repeated until k experiments are selected. They introduced several possible ways for setting c, including c = M , c = µ̂ and c = ymin. They empirically demonstrated that setting c = M provided them a good result for their particular test functions. However, there is no theoretical justification or guidance toward what is the best c.\nOur theoretical analysis, in particular Corollary 1, indicates that by setting c (ŷ in this paper) to µ̂x|O, the condition for continued experiment selection can be easily met comparing to other settings, i.e., γzθx ≤ . Thus, a batch of k ≥ 1 experiments are requested at most iterations without degrading the performance. This theoretical result also justifies the choice of setting c = µ̂x|O in the constant liar approach. We call this approach µ-Constant Batch. We run this algorithm on proposed 8 benchmarks for different batch sizes 5 and 10. Figures 2 and 3 show the performance of µ-Constant along with 5 competitive approaches: 1) Sequential EI; 2) Constant liar with ŷ = M ; 3) Constant liar with ŷ = ymax; 4) Constant liar with ŷ = ymin; and 5) Matching, which is a recently proposed approach by Azimi et al. [2]. For this set of experiments, we use the same experimental setup as used in Table 2.\nThe results show that the µ-constant batch approach performs very competitively compared to the Matching approach, which is one of the best existing batch Bayesian optimization approach in the literature. In addition, it is more practical than the Matching approach for high dimensional applications since its computational complexity is significantly less than the Matching algorithm. Note that the performance of µ-Constant is also shown in Table 2 as CL(µ̂). It is worth emphasizing that while µ-Constant achieves highly competitive batch performance, it is consistently worse than sequential EI and the proposed Hybrid Batch EI algorithm. This result suggests that the stopping criterion used in Algorithm 1 is in fact effective toward identifying the condition under which we must stop increasing the batch size to avoid significant performance degradation compared to the sequential EI."
    }, {
      "heading" : "5 Conclusion",
      "text" : "In the Bayesian optimization framework, we investigated the problem of batch query selection with the goal of maintaining the performance of a sequential policy which using fewer iterations. Although our results are for general BO problems, for the sake of clarity, we focused on the task of maximizing an unknown non-convex/concave function.\nThere are two main contributions in this paper. Firstly, we introduce a systematic way to analyze the performance and limits of simulation-based batch BO methods by a) proving universal bounds on the bias caused by the simulation (estimation-of-outcome) error; and b) analyzing the selection of the second experiment when we have an estimate of the outcome of the first experiment. In all cases, we provide theoretical bounds on the error, relating the simulation error to the prediction error of the next best experiment.\nSecondly, based on the analysis above, we proposed an algorithm that behaves optimally in expectation. This algorithm at each step decides whether or not to pick another query to add to the current batch, and as such dynamically determines the appropriate batch size at each step. In early iterations, our algorithm behaves more similar to the sequential policy and gradually moves toward a batch policy with variable batch sizes.\nThe empirical evaluation over both synthetic and real data shows substantial speedup (up to 78% ) compared to the corresponding sequential policy, with little to nothing loss in the optimization performance. Our theoretical results also shed some interesting light on the Constant-liar approach, a recently proposed batch selection method based on the EI objective."
    }, {
      "heading" : "A Proof of Theorem 1",
      "text" : "Recalling the notation introduced in the Theorem statement, we have\n∆(σz) = CA −1CT − [C k(z,x)]\n[ A BT\nB k(x,x)\n]−1 [ CT\nk(z,x) ] = CA−1CT − [C k(z,x)] [ A−1 +A−1BTDBA−1 −A−1BTD\n−DBA−1 D\n] [ CT\nk(z,x) ] = ( CA−1BT − k(z,x) ) D ( BA−1CT − k(z,x) )T .\nThis concludes the proof of the theorem."
    }, {
      "heading" : "B Proof of Theorem 2",
      "text" : "By definition and block matrix inversion lemma, we have\nµz|O,x − µ̂z|O,x = k(z, {xO,x})k({xO,x}, {xO,x})−1 [ 0\ny − ŷ ] = (k(z,x)− CA−1BT )D(y − ŷ).\nFor the second part, we have\nµz|O − µz|O,x = CA−1yO − [C k(z,x)] [ A BT\nB k(x,x) ]−1 [ yO y ] = CA−1yO − [C k(z,x)] [ A−1 +A−1BTDBA−1 −A−1BTD\n−DBA−1 D\n] [ yO y∗ ] = ( CA−1BT − k(z,x) ) D ( BA−1yO − y\n) = ( CA−1BT − k(z,x) ) D ( µx|O − y ) .\nThis concludes the proof of the theorem."
    }, {
      "heading" : "C Proof of Lemma 1",
      "text" : "Let ∆z = max(ymax, y∗1)− µz|O,x∗1 . Using Theorem 2, we have\n∆̂z := max(ymax, ŷ1)− µ̂z|O,x∗1 = max(ymax, y ∗ 1)− µz|O,x∗1 + max(ymax, ŷ1)−max(ymax, y ∗ 1)\n− 1 σ2x∗1 |O\n( k(z, x∗1)− k(z,xO)k(xO,xO)−1k(xO, x∗1) )( ŷ1 − y∗1 ) = ∆z + max(ymax, ŷ1)−max(ymax, y∗1)− ρz,x∗1 σz|O\nσx∗1 |O\n( ŷ1 − y∗1 ) ︸ ︷︷ ︸\nδz\n= ∆z + δz.\nHere, ρz,x∗1 represents the correlation coefficient between x and x1. Thus, we have\n|δz| ≤ ( 1 + σz|O\nσx∗1 |O\n) |ŷ1 − y∗1 | .\nBy mean-value theorem, there exists α ∈ [0, 1], such that\n−∆̂zΦ ( − ∆̂z σz|O,x∗1 ) + σz|O,x∗1φ ( ∆̂x σz|O,x∗1 ) ︸ ︷︷ ︸\nÊI(z)\n= −∆xΦ ( − ∆x σz|O,x∗1 ) + σz|O,x∗1φ ( ∆x σz|O,x∗1 ) ︸ ︷︷ ︸\nEI(z)\n−Φ ( −∆z + αδz\nσz|O,x∗1\n) δz\nThus, ∣∣∣EI(z)− ÊI(z)∣∣∣ = Φ(−∆z + αδz σz|O,x∗1 )∣∣∣δz∣∣∣ ≤ 1\n2 ∣∣∣δz∣∣∣ ≤ 1 2 ( 1 + σz|O\nσx∗1 |O )∣∣∣ŷ1 − y∗1∣∣∣. This concludes the Proof of Lemma."
    }, {
      "heading" : "D Proof of Theorem 3",
      "text" : "By optimality of x2 and x∗2, we have\nEI(x2)− ÊI(x2) ≤ EI(x∗2)− ÊI(x2) ≤ EI(x∗2)− ÊI(x∗2).\nUsing Lemma 1, we get ∣∣∣EI(x∗2)− ÊI(x2)∣∣∣ ≤ 12 ( 1 + max(σx2|O, σx∗2 |O)\nσx∗1 |O )∣∣∣ŷ1 − y∗1∣∣∣. We can continue\nÊI(x2)− ÊI(x∗2) ≤ ∣∣∣ÊI(x2)− EI(x∗2)∣∣∣+ ∣∣∣EI(x∗2)− ÊI(x∗2)∣∣∣\n≤ ( 1 + max(σx2|O, σx∗2 |O)\nσx∗1 |O )∣∣∣ŷ1 − y∗1∣∣∣ By optimality of x∗2, the derivative of EI is zero at x ∗ 2 and Taylor series expansion yields that for some α ∈ [0, 1],\nwe have\nÊI(x∗2)− ÊI(x2) = 1\n2 (x∗2 − x2)T\nd2ÊI\ndx2\n( (1− α)x∗2 + αx2 ) (x∗2 − x2).\nFinally, we get ∥∥∥x∗2 − x2∥∥∥2 2 ≤\n2 ∣∣∣ÊI(x∗2)− ÊI(x2)∣∣∣\nΣmin ( d2ÊI dx2 ((1− α)x ∗ 2 + αx2) ) ≤ 2\nΣmin\n( 1 + max(σx2|O, σx∗2 |O)\nσx∗1 |O\n)∣∣∣ŷ1 − y∗1∣∣∣. (7)"
    }, {
      "heading" : "E Proof of Corollary 2",
      "text" : "From theorem 1, there is an interesting finding which shows that the difference of variance of any point z in the input space after adding the point x∗ to our observation set is exactly D ( k(z, x∗1)−BA−1CT )2 if we consider x∗1 as a single point. Since δ2z − δ2∗z > 0, therefore m ≥ 0. In addition, when |x∗| = 1, it can be shown that m−1 = σ∗2. Thus, we are interested in the points where δ2z − δ∗2 ≥ ≥ 0. Therefore we have:\nδ2z − δ2∗z − ≥ 0 Dk(x∗1, z) 2 − ( 2DCA−1BT ) k(x∗1, z) + ( D(CA−1BT )2 ) − ≥ 0\n(8)\nthis is a quadratic function of k(x∗1, z) with 2 real roots as follow:\nk(x∗1, z) =\n{ r1 = CA −1BT + √\nD\nr2 = CA −1BT − √ D\n(9)\nSo we are interested in the region where k(x∗1, z) ≥ r1 or k(x∗1, z) ≤ r2. For large value of the r2 < 0 and since k(x∗1, z) > 0, we are only interested in where k(x ∗ 1, z) ≥ r1. Therefore we have\n1 ≥ k(x∗1, z) = e −‖z−x∗1‖ 2 l ≥ CA−1BT + √\nD ≥ 0 (10)\nWe are trying to introduce an upper bound for r1 which is free from Pz . Clearly CA−1BT ≤ |CA−1BT |. Then we have,\n|CA−1BT | =‖ CA−1BT ‖2 ≤‖ C ‖2 ‖ A−1BT ‖2 Cauchy-Shwrz inequality ≤ √ n ‖ C ‖∞ ‖ A−1BT ‖2\n≤ √ n ‖ A−1BT ‖2 sinec 0 ≤‖ C ‖∞≤ 1\n(11)\nTherefore we are certain about the point satisfying the following equation\nk(x∗1, z) ≥ √ n ‖ A−1BT ‖2 +\n√\nD ‖ z − x∗ ‖2 ≤ −l ln (√ n ‖ A−1BT ‖2 + √\nD ) ‖ z − x∗ ‖2 ≤ −l ln (√ n ‖ A−1BT ‖2 +σ∗ √ )\n(12)"
    }, {
      "heading" : "F Proof of Corollary 3",
      "text" : "∥∥(CA−1BT − k(x∗1, z))D∥∥∞ √ 2\nπ ‖σx∗1|O‖1 ≥ ∣∣(CA−1BT − k(x∗1, z))∣∣ ≥ √\n2 π |σx∗1|O|D\n|(CA−1BT − k(x∗1, z))|2 ≥  √ 2 π |σx∗1|O|D 2\n(CA−1BT )2 + k(x∗1, z) 2 ≥ π\n2\n2σ2x∗1 |O D2\nk(x∗1, z) 2 ≥ π\n2\n2σ6x∗1 |O − n ‖ A−1BT ‖22\n‖ z − x∗ ‖2 ≤ −l ln √ π 2\n2σ6x∗1 |O − n ‖ A−1BT ‖22\n(13)\nNote that |a− b|2 ≤ 2 ∗ (a2 + b2). Therefore E[|µz|O,x − µ̂z|O,x|] ≥ if we have\n‖ z − x∗ ‖2≤ −l ln √ π 2\n2σ6x∗1 |O − n ‖ A−1BT ‖22 (14)"
    } ],
    "references" : [ {
      "title" : "A nonparametric approach to noisy and costly optimization",
      "author" : [ "B.S. Anderson", "A. Moore", "D. Cohn" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2000
    }, {
      "title" : "Batch bayesian optimization via simulation matching",
      "author" : [ "J. Azimi", "A. Fern", "X. Fern" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2010
    }, {
      "title" : "Electricity production by geobacter sulfurreducens attached to electrodes",
      "author" : [ "D. Bond", "D. Lovley" ],
      "venue" : "Applications of Environmental Microbiology,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2003
    }, {
      "title" : "A tutorial on Bayesian optimization of expensive cost functions, with application to active user modeling and hierarchical reinforcement learning",
      "author" : [ "E. Brochu", "V.M. Cora", "N. de Freitas" ],
      "venue" : "Technical Report TR-2009-23,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2009
    }, {
      "title" : "A memory-based rash optimizer",
      "author" : [ "M. Brunato", "R. Battiti", "S. Pasupuleti" ],
      "venue" : "Workshop on Heuristic Search, Memory Based Heuristics and Their applications",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2006
    }, {
      "title" : "The Global Optimization Problem: An Introduction Toward Global Optimization",
      "author" : [ "L. Dixon", "G. Szeg" ],
      "venue" : null,
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1978
    }, {
      "title" : "Kriging is well-suited to parallelize optimization",
      "author" : [ "D. Ginsbourger", "R.L. Riche", "L. Carraro" ],
      "venue" : "Computational Intelligence In Expensive Optimization Problems,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2010
    }, {
      "title" : "A taxonomy of global optimization methods based on response surfaces",
      "author" : [ "D. Jones" ],
      "venue" : "Journal of Global Optimization,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2001
    }, {
      "title" : "Bayesian algorithms for one-dimensional globaloptimization",
      "author" : [ "M. Locatelli" ],
      "venue" : "J. of Global Optimization,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1997
    }, {
      "title" : "Genetic algorithms + data structures = evolution programs (2nd, extended ed.)",
      "author" : [ "Z. Michalewicz" ],
      "venue" : null,
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1994
    }, {
      "title" : "Memory-based stochastic optimization",
      "author" : [ "A. Moore", "J. Schneider" ],
      "venue" : "In NIPS",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1995
    }, {
      "title" : "Improved fuel cell and electrode designs for producing electricity from microbial",
      "author" : [ "D. Park", "J. Zeikus" ],
      "venue" : "degradation. Biotechnol.Bioeng.,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2003
    }, {
      "title" : "Gaussian Processes for Machine Learning",
      "author" : [ "C.E. Rasmussen", "C.K.I. Williams" ],
      "venue" : null,
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "Bayesian optimization tries to optimize an unknown function f(·) by requesting a set of experiments when f(·) is costly to evaluate [8, 4].",
      "startOffset" : 132,
      "endOffset" : 138
    }, {
      "referenceID" : 3,
      "context" : "Bayesian optimization tries to optimize an unknown function f(·) by requesting a set of experiments when f(·) is costly to evaluate [8, 4].",
      "startOffset" : 132,
      "endOffset" : 138
    }, {
      "referenceID" : 2,
      "context" : "MFCs [3] use micro-organisms to generate electricity.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 11,
      "context" : "It has been shown that efficiency of generated electricity power significantly depends on the surface properties of the anode [12].",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 10,
      "context" : "Most of the proposed selection criteria in BO are sequential, where only one experiment is selected at each iteration [11, 8, 14, 9].",
      "startOffset" : 118,
      "endOffset" : 132
    }, {
      "referenceID" : 7,
      "context" : "Most of the proposed selection criteria in BO are sequential, where only one experiment is selected at each iteration [11, 8, 14, 9].",
      "startOffset" : 118,
      "endOffset" : 132
    }, {
      "referenceID" : 8,
      "context" : "Most of the proposed selection criteria in BO are sequential, where only one experiment is selected at each iteration [11, 8, 14, 9].",
      "startOffset" : 118,
      "endOffset" : 132
    }, {
      "referenceID" : 1,
      "context" : "[2] introduced a batch BO approach that selects a batch of k experiments at each iteration that approximates the behavior of a given sequential heuristic.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "[7] introduced a constant liar heuristic algorithm to select a batch of experiments based on the Expected Improvement (EI) [9] policy.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "[7] introduced a constant liar heuristic algorithm to select a batch of experiments based on the Expected Improvement (EI) [9] policy.",
      "startOffset" : 123,
      "endOffset" : 126
    }, {
      "referenceID" : 1,
      "context" : "Although these two batch algorithms [2, 7] can speedup the experiment selection by a factor of k, their results show that batch selection in general performs worse than the sequential EI policy, especially when the total number of experiments is small.",
      "startOffset" : 36,
      "endOffset" : 42
    }, {
      "referenceID" : 6,
      "context" : "Although these two batch algorithms [2, 7] can speedup the experiment selection by a factor of k, their results show that batch selection in general performs worse than the sequential EI policy, especially when the total number of experiments is small.",
      "startOffset" : 36,
      "endOffset" : 42
    }, {
      "referenceID" : 12,
      "context" : "We select GP [13] as our probabilistic model and EI [9] as our selection criterion.",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 8,
      "context" : "We select GP [13] as our probabilistic model and EI [9] as our selection criterion.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 8,
      "context" : "EI[9] at point x with associated GP prediction y|O ∼ N (μx|O, σ x|O) is defined to be",
      "startOffset" : 2,
      "endOffset" : 5
    }, {
      "referenceID" : 0,
      "context" : "This means that the sample estimation is more sensitive to the output estimation error for functions taking value in [0, 1].",
      "startOffset" : 117,
      "endOffset" : 123
    }, {
      "referenceID" : 0,
      "context" : "We consider 6 well-known synthetic benchmark functions: Cosines and Rosenbrock [1, 5] over [0, 1], Hartman(3)[6] over [0, 1], Hartman(6)[6] over [0, 1], Shekel[6] over [3, 6] and Michalewicz [10] over [0, π].",
      "startOffset" : 79,
      "endOffset" : 85
    }, {
      "referenceID" : 4,
      "context" : "We consider 6 well-known synthetic benchmark functions: Cosines and Rosenbrock [1, 5] over [0, 1], Hartman(3)[6] over [0, 1], Hartman(6)[6] over [0, 1], Shekel[6] over [3, 6] and Michalewicz [10] over [0, π].",
      "startOffset" : 79,
      "endOffset" : 85
    }, {
      "referenceID" : 0,
      "context" : "We consider 6 well-known synthetic benchmark functions: Cosines and Rosenbrock [1, 5] over [0, 1], Hartman(3)[6] over [0, 1], Hartman(6)[6] over [0, 1], Shekel[6] over [3, 6] and Michalewicz [10] over [0, π].",
      "startOffset" : 91,
      "endOffset" : 97
    }, {
      "referenceID" : 5,
      "context" : "We consider 6 well-known synthetic benchmark functions: Cosines and Rosenbrock [1, 5] over [0, 1], Hartman(3)[6] over [0, 1], Hartman(6)[6] over [0, 1], Shekel[6] over [3, 6] and Michalewicz [10] over [0, π].",
      "startOffset" : 109,
      "endOffset" : 112
    }, {
      "referenceID" : 0,
      "context" : "We consider 6 well-known synthetic benchmark functions: Cosines and Rosenbrock [1, 5] over [0, 1], Hartman(3)[6] over [0, 1], Hartman(6)[6] over [0, 1], Shekel[6] over [3, 6] and Michalewicz [10] over [0, π].",
      "startOffset" : 118,
      "endOffset" : 124
    }, {
      "referenceID" : 5,
      "context" : "We consider 6 well-known synthetic benchmark functions: Cosines and Rosenbrock [1, 5] over [0, 1], Hartman(3)[6] over [0, 1], Hartman(6)[6] over [0, 1], Shekel[6] over [3, 6] and Michalewicz [10] over [0, π].",
      "startOffset" : 136,
      "endOffset" : 139
    }, {
      "referenceID" : 0,
      "context" : "We consider 6 well-known synthetic benchmark functions: Cosines and Rosenbrock [1, 5] over [0, 1], Hartman(3)[6] over [0, 1], Hartman(6)[6] over [0, 1], Shekel[6] over [3, 6] and Michalewicz [10] over [0, π].",
      "startOffset" : 145,
      "endOffset" : 151
    }, {
      "referenceID" : 5,
      "context" : "We consider 6 well-known synthetic benchmark functions: Cosines and Rosenbrock [1, 5] over [0, 1], Hartman(3)[6] over [0, 1], Hartman(6)[6] over [0, 1], Shekel[6] over [3, 6] and Michalewicz [10] over [0, π].",
      "startOffset" : 159,
      "endOffset" : 162
    }, {
      "referenceID" : 2,
      "context" : "We consider 6 well-known synthetic benchmark functions: Cosines and Rosenbrock [1, 5] over [0, 1], Hartman(3)[6] over [0, 1], Hartman(6)[6] over [0, 1], Shekel[6] over [3, 6] and Michalewicz [10] over [0, π].",
      "startOffset" : 168,
      "endOffset" : 174
    }, {
      "referenceID" : 5,
      "context" : "We consider 6 well-known synthetic benchmark functions: Cosines and Rosenbrock [1, 5] over [0, 1], Hartman(3)[6] over [0, 1], Hartman(6)[6] over [0, 1], Shekel[6] over [3, 6] and Michalewicz [10] over [0, π].",
      "startOffset" : 168,
      "endOffset" : 174
    }, {
      "referenceID" : 9,
      "context" : "We consider 6 well-known synthetic benchmark functions: Cosines and Rosenbrock [1, 5] over [0, 1], Hartman(3)[6] over [0, 1], Hartman(6)[6] over [0, 1], Shekel[6] over [3, 6] and Michalewicz [10] over [0, π].",
      "startOffset" : 191,
      "endOffset" : 195
    }, {
      "referenceID" : 0,
      "context" : "Both Fuel cell and Hydrogen data are in [0, 1].",
      "startOffset" : 40,
      "endOffset" : 46
    }, {
      "referenceID" : 1,
      "context" : "01Σi=1li, where, li is the length of the i th dimension [2].",
      "startOffset" : 56,
      "endOffset" : 59
    }, {
      "referenceID" : 1,
      "context" : "To demonstrate the effectiveness of our algorithm, we consider two state-of-the-art batch BO algorithms in the literature: 1) simulation matching (Matching) [2] and 2) the constant liar approach in which the output of the selected samples in the batch is set to their mean in order to select the next experiment (CL(μ̂)) [7].",
      "startOffset" : 157,
      "endOffset" : 160
    }, {
      "referenceID" : 6,
      "context" : "To demonstrate the effectiveness of our algorithm, we consider two state-of-the-art batch BO algorithms in the literature: 1) simulation matching (Matching) [2] and 2) the constant liar approach in which the output of the selected samples in the batch is set to their mean in order to select the next experiment (CL(μ̂)) [7].",
      "startOffset" : 321,
      "endOffset" : 324
    }, {
      "referenceID" : 6,
      "context" : "[7], which selects a batch of experiments that jointly maximize the EI objective.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "[2].",
      "startOffset" : 0,
      "endOffset" : 3
    } ],
    "year" : 2012,
    "abstractText" : "Bayesian Optimization (BO) aims at optimizing an unknown function that is costly to evaluate. We focus on applications where concurrent function evaluations are possible. In such cases, BO could choose to either sequentially evaluate the function (sequential mode) or evaluate the function at a batch of multiple inputs at once (batch mode). The sequential mode generally leads to better optimization performance as each function evaluation is selected with more information, whereas the batch mode is more time efficient (smaller number of iterations). Our goal is to combine the strength of both settings. We systematically analyze BO using a Gaussian Process as the posterior estimator and provide a hybrid algorithm that dynamically switches between sequential and batch with variable batch sizes. We theoretically justify our algorithm and present experimental results on eight benchmark BO problems. The results show that our method achieves substantial speedup (up to 78%) compared to sequential, without suffering any significant performance loss.",
    "creator" : "LaTeX with hyperref package"
  }
}