{
  "name" : "1005.3681.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Learning Kernel-Based Halfspaces with the Zero-One Loss",
    "authors" : [ "Shai Shalev-Shwartz", "Karthik Sridharan" ],
    "emails" : [ "shais@cs.huji.ac.il", "ohadsh@cs.huji.ac.il", "karthik@tti-c.org" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n00 5.\n36 81\nv2 [\ncs .L\nG ]\n1 A\nug 2\n01 0"
    }, {
      "heading" : "1 Introduction",
      "text" : "A highly important hypothesis class in machine learning theory and applications is that of halfspaces in a Reproducing Kernel Hilbert Space (RKHS). Choosing a halfspace based on empirical data is often performed using Support Vector Machines (SVMs) [26]. SVMs replace the more natural 0- 1 loss function with a convex surrogate – the hinge-loss. By doing so, we can rely on convex optimization tools. However, there are no guarantees on how well the hinge-loss approximates the 0- 1 loss function. There do exist some recent results on the asymptotic relationship between surrogate convex loss functions and the 0-1 loss function [28, 4], but these do not come with finite-sample or finite-time guarantees. In this paper, we tackle the task of learning kernel-based halfspaces with respect to the non-convex 0-1 loss function. Our goal is to derive learning algorithms and to analyze them in the finite-sample finite-time setting.\nFollowing the standard statistical learning framework, we assume that there is an unknown distribution, D, over the set of labeled examples, X × {0, 1}, and our primary goal is to find a classifier, h : X → {0, 1}, with low generalization error,\nerrD(h) def = E (x,y)∼D [|h(x) − y|] . (1)\nThe learning algorithm is allowed to sample a training set of labeled examples, (x1, y1), . . . , (xm, ym), where each example is sampled i.i.d. from D, and it returns a classifier. Following the agnostic PAC learning framework [16], we say that an algorithm (ǫ, δ)-learns a concept class H of classifiers using m examples, if with probability of at least 1− δ over a random choice of m examples the algorithm returns a classifier ĥ that satisfies\nerrD(ĥ) ≤ inf h∈H errD(h) + ǫ . (2)\nWe note that ĥ does not necessarily belong to H . Namely, we are concerned with improper learning, which is as useful as proper learning for the purpose of deriving good classifiers. A common learning paradigm is the Empirical Risk Minimization (ERM) rule, which returns a classifier that minimizes the average error over the training set,\nĥ ∈ argmin h∈H\n1\nm\nm ∑\ni=1\n|h(xi)− yi| .\nThe class of (origin centered) halfspaces is defined as follows. Let X be a compact subset of a RKHS, which w.l.o.g. will be taken to be the unit ball around the origin. Let φ0−1 : R → R be the function φ0−1(a) = 1(a ≥ 0) = 12 (sgn(a) + 1). The class of halfspaces is the set of classifiers\nHφ0−1 def = {x 7→ φ0−1(〈w,x〉) : w ∈ X} .\nAlthough we represent the halfspace using w ∈ X , which is a vector in the RKHS whose dimensionality can be infinite, in practice we only need a function that implements inner products in the RKHS (a.k.a. a kernel function), and one can define w as the coefficients of a linear combination of examples in our training set. To simplify the notation throughout the paper, we represent w simply as a vector in the RKHS.\nIt is well known that if the dimensionality of X is n, then the VC dimension of Hφ0−1 equals n. This implies that the number of training examples required to obtain a guarantee of the form given in Equation (2) for the class of halfspaces scales at least linearly with the dimension n [26]. Since kernel-based learning algorithms allow X to be an infinite dimensional inner product space, we must use a different class in order to obtain a guarantee of the form given in Equation (2).\nOne way to define a slightly different concept class is to approximate the non-continuous function, φ0−1, with a Lipschitz continuous function, φ : R → [0, 1], which is often called a transfer function. For example, we can use a sigmoidal transfer function\nφsig(a) def =\n1\n1 + exp(−4La) , (3)\nwhich is a L-Lipschitz function. Other L-Lipschitz transfer functions are the erf function and the piece-wise linear function:\nφerf(a) def = 12 (\n1 + erf (√ π L a )) , φpw(a) def = max { min { 1 2 + La , 1 } 0 }\n(4)\nAn illustration of these transfer functions is given in Figure 1. Analogously to the definition of Hφ0−1 , for a general transfer function φ we define Hφ to be the set of predictors x 7→ φ(〈w,x〉). Since now the range of φ is not {0, 1} but rather the entire interval [0, 1], we interpret φ(〈w,x〉) as the probability to output the label 1. The definition of errD(h) remains1 as in Equation (1).\nThe advantage of using a Lipschitz transfer function can be seen via Rademacher generalization bounds [3]. In fact, a simple corollary of the contraction lemma implies the following:\nTheorem 1 Let ǫ, δ ∈ (0, 1) and let φ be an L-Lipschitz transfer function. Let m be an integer satisfying\nm ≥ ( 2L+ 3 √ 2 ln(8/δ)\nǫ\n)2\n.\nThen, for any distribution D over X × {0, 1}, the ERM algorithm (ǫ, δ)-learns the concept class Hφ using m examples.\n1 Note that in this case errD(h) can be interpreted as P(x,y)∼D,b∼φ(〈w,x〉)[y 6= b].\nThe above theorem tells us that the sample complexity of learning Hφ is Ω̃(L 2/ǫ2). Crucially, the sample complexity does not depend on the dimensionality of X , but only on the Lipschitz constant of the transfer function. This allows us to learn with kernels, when the dimensionality of X can even be infinite. A related analysis compares the error rate of a halfspace w to the number of margin mistakes w makes on the training set - see Section 4.1 for a comparison.\nFrom the computational complexity point of view, the result given in Theorem 1 is problematic, since the ERM algorithm should solve the non-convex optimization problem\nargmin w:‖w‖≤1\n1\nm\nm ∑\ni=1\n|φ(〈w,xi〉)− yi| . (5)\nSolving this problem in polynomial time is hard under reasonable assumptions (see Section 3 in which we present a formal hardness result). Adapting a technique due to [6] we show in Appendix A that it is possible to find an ǫ-accurate solution to Equation (5) (where the transfer function is φpw) in time poly ( exp ( L2\nǫ2 log( L ǫ ) )) . The main contribution of this paper is the derivation and analysis of a\nmore simple learning algorithm that (ǫ, δ)-learns the class Hsig using time and sample complexity of at most poly ( exp (\nL log(Lǫ ) ))\n. That is, the runtime of our algorithm is exponentially smaller than the runtime required to solve the ERM problem using the technique described in [6]. Moreover, the algorithm of [6] performs an exhaustive search over all (L/ǫ)2 subsets of the m examples in the training set, and therefore its runtime is always order of mL 2/ǫ2 . In contrast, our algorithm’s runtime depends on a parameter B, which is bounded by exp(L) only under a worst-case assumption. Depending on the underlying distribution, B can be much smaller than the worst-case bound. In practice, we will cross-validate for B, and therefore the worst-case bound will often be pessimistic.\nThe rest of the paper is organized as follows. In Section 2 we describe our main results. Next, in Section 3 we provide a hardness result, showing that it is not likely that there exists an algorithm that learns Hsig or Hpw in time polynomial in L. We outline additional related work in Section 4. In particular, the relation between our approach and margin-based analysis is described in Section 4.1, and the relation to approaches utilizing a distributional assumption is discussed in Section 4.2. We wrap up with a discussion in Section 5."
    }, {
      "heading" : "2 Main Results",
      "text" : "In this section we present our main result. Recall that we would like to derive an algorithm which learns the class Hsig. However, the ERM optimization problem associated with Hsig is non-convex. The main idea behind our construction is to learn a larger hypothesis class, denoted HB, which approximately contains Hsig, and for which the ERM optimization problem becomes convex. The price we need to pay is that from the statistical point of view, it is more difficult to learn the class HB than the class Hsig, therefore the sample complexity increases.\nThe class HB we use is a class of linear predictors in some other RKHS. The kernel function that implements the inner product in the newly constructed RKHS is\nK(x,x′) def =\n1\n1− ν〈x,x′〉 , (6)\nwhere ν ∈ (0, 1) is a parameter and 〈x,x′〉 is the inner product in the original RKHS. As mentioned previously, 〈x,x′〉 is usually implemented by some kernel function K ′(z, z′), where z and z′ are the pre-images of x and x′ with respect to the feature mapping induced by K ′. Therefore, the kernel in Equation (6) is simply a composition with K ′, i.e. K(z, z′) = 1/(1− νK ′(z, z′)).\nTo simplify the presentation we will set ν = 1/2, although in practice other choices might be more effective. It is easy to verify that K is a valid positive definite kernel function (see for example [21, 10]). Therefore, there exists some mapping ψ : X → V, where V is an RKHS with 〈ψ(x), ψ(x′)〉 = K(x,x′). The class HB is defined to be:\nHB def = {x 7→ 〈v, ψ(x)〉 : v ∈ V, ‖v‖2 ≤ B} . (7)\nThe main result we prove in this section is the following:\nTheorem 2 Let ǫ, δ ∈ (0, 1) and let L ≥ 3. Let B = 2L4 + exp ( 7L log ( 2L ǫ ) + 3 ) and let m be a sample size that satisfies m ≥ 8Bǫ2 ( 2 + 9 √ ln(8/δ) )2\n. Then, for any distribution D, with probability of at least 1− δ, any ERM predictor ĥ ∈ HB with respect to HB satisfies\nerrD(ĥ) ≤ min h∈Hsig errD(hsig) + ǫ .\nWe note that the bound on B is far from being the tightest possible in terms of constants and second-order terms. Also, the assumption of L ≥ 3 is rather arbitrary, and is meant to simplify the presentation of the bound.\nTo prove this theorem, we start with analyzing the time and sample complexity of learning HB. The sample complexity analysis follows directly from a Rademacher generalization bound [3]. In particular, the following theorem tells us that the sample complexity of learning HB with the ERM rule is order of B/ǫ2 examples.\nTheorem 3 Let ǫ, δ ∈ (0, 1), let B ≥ 1, and let m be a sample size that satisfies\nm ≥ 2B ǫ2 ( 2 + 9 √ ln(8/δ) )2 .\nThen, for any distribution D, the ERM algorithm (ǫ, δ)-learns HB.\nProof Since K(x,x) ≤ 2, the Rademacher complexity of HB is bounded by √\n2B/m (see also [14]). Additionally, using Cauchy-Schwartz inequality we have that the loss is bounded, |〈v, ψ(x)〉 − y| ≤√ 2B + 1. The result now follows directly from [3, 14].\nNext, we show that the ERM problem with respect to HB can be solved in time poly(m). The ERM problem associated with HB is\nmin v:‖v‖2≤B\n1\nm\nm ∑\ni=1\n|〈v, ψ(xi)〉 − yi| .\nSince the objective function is defined only via inner products with ψ(xi), and the constraint on v is defined by the ℓ2-norm, it follows by the Representer theorem [27] that there is an optimal solution v⋆ that can be written as v⋆ =\n∑m i=1 αiψ(xi). Therefore, instead of optimizing over v, we\ncan optimize over the set of weights α1, . . . , αm by solving the equivalent optimization problem\nmin α1,...,αm\n1\nm\nm ∑\ni=1\n∣ ∣ ∣ ∣ ∣ ∣ m ∑\nj=1\nαjK(xj ,xi)− yi\n∣ ∣ ∣ ∣ ∣ ∣ s.t. m ∑\ni,j=1\nαiαjK(xi,xj) ≤ B .\nThis is a convex optimization problem in Rm and therefore can be solved in time poly(m) using standard optimization tools.2 We therefore obtain:\nCorollary 1 Let ǫ, δ ∈ (0, 1) and let B ≥ 1. Then, for any distribution D, it is possible to (ǫ, δ)learn HB in sample and time complexity of poly ( B ǫ log(1/δ) ) .\nIt is left to understand why the class HB approximately contains the class Hsig. Recall that for any transfer function, φ, we define the class Hφ to be all the predictors of the form x 7→ φ(〈w,x〉). The first step is to show that HB contains the union of Hφ over all polynomial transfer functions that satisfy a certain boundedness condition on their coefficients.\nLemma 1 Let PB be the following set of polynomials (possibly with infinite degree)\nPB def =\n\n\n\np(a) =\n∞ ∑\nj=0\nβj a j :\n∞ ∑\nj=0\nβ2j 2 j ≤ B\n\n\n\n. (8)\nThen, ⋃\np∈PB Hp ⊂ HB .\nProof To simplify the proof, we first assume that X is simply the unit ball in Rn, for an arbitrarily large but finite n. Consider the mapping ψ : X → RN defined as follows: for any x ∈ X , we let ψ(x) be an infinite vector, indexed by k1 . . . , kj for all (k1, . . . , kj) ∈ {1, . . . , n}j and j = 0 . . .∞, where\n2 In fact, using stochastic gradient descent, we can (ǫ, δ)-learn HB in time O(m 2), where m is as defined\nin Theorem 3 —See for example [8, 22].\nthe entry at index k1 . . . , kj equals 2 −j/2xk1 ·xk2 · · ·xkj . The inner-product between ψ(x) and ψ(x′) for any x,x′ ∈ X can be calculated as follows,\n〈ψ(x), ψ(x′)〉 = ∞ ∑\nj=0\n∑\n(k1,...,kj)∈{1,...,n}j 2−jxk1x ′ k1 · · ·xkjx ′ kj =\n∞ ∑\nj=0\n2−j(〈x,x′〉)j = 1 1− 12 〈x,x′〉 .\nThis is exactly the kernel function defined in Equation (6) (recall that we set ν = 1/2) and therefore ψ maps to the RKHS defined by K. Consider any polynomial p(a) =\n∑∞ j=0 βja j in PB, and any\nw ∈ X . Let vw be an element in RN explicitly defined as being equal to βj2j/2wk1 · · ·wkj at index k1, . . . , kj (for all k1, . . . , kj ∈ {1, . . . , n}j, j = 0 . . .∞). By definition of ψ and vw, we have that\n〈vw, ψ(x)〉 = ∞ ∑\nj=0\n∑\nk1,...,kj\n2−j/2βj2 j/2wk1 · · ·wkjxk1 · · · ·xkj =\n∞ ∑\nj=0\nβj(〈w,x〉)j = p(〈w,x〉) .\nIn addition,\n‖vw‖2 = ∞ ∑\nj=0\n∑\nk1,...,kj\nβ2j 2 jw2k1 · · ·w 2 kj =\n∞ ∑\nj=0\nβ2j 2 j ∑\nk1\nw2k1\n∑\nk2\nw2k2 · · · ∑\nkj\nw2kj = ∞ ∑\nj=0\nβ2j 2 j ( ‖w‖2 )j ≤ B.\nThus, the predictor x 7→ 〈vw, ψ(x)〉 belongs to HB and is the same as the predictor x 7→ p(〈w,x〉). This proves that Hp ⊂ HB for all p ∈ PB as required. Finally, if X is an infinite dimensional RKHS, the only technicality is that in order to represent x as a (possibly infinite) vector, we need to show that our RKHS has a countable basis. This holds since the inner product 〈x,x′〉 over X is continuous and bounded (see [1]).\nFinally, the following lemma states that with a sufficiently large B, there exists a polynomial in PB which approximately equals to φsig. This implies that HB approximately contains Hsig.\nLemma 2 Let φsig be as defined in Equation (3), where for simplicity we assume L ≥ 3. For any ǫ > 0, let\nB = 2L4 + exp ( 7L log ( 2L ǫ ) + 3 ) .\nThen there exists p ∈ PB such that ∀x,w ∈ X , |p(〈w,x〉) − φsig(〈w,x〉)| ≤ ǫ .\nThe proof of the lemma is based on a Chebyshev approximation technique and is given in Appendix B. Since the proof is rather involved, we also present a similar lemma, whose proof is simpler, for the φerf transfer function (see Appendix C). It is interesting to note that φerf actually belongs to PB for a sufficiently large B, since it can be defined via its infinite-degree Taylor expansion. However, the bound for φerf depends on exp(L\n2), rather than exp(L) for the sigmoid transfer function φsig.\nFinally, Theorem 2 is obtained as follows: Combining Theorem 3 and Lemma 1 we get that with probability of at least 1− δ,\nerrD(ĥ) ≤ min h∈HB errD(h) + ǫ/2 ≤ min p∈PB min h∈Hp errD(h) + ǫ/2 . (9)\nFrom Lemma 2 we obtain that for any w ∈ X , if h(x) = φsig(〈w,x〉) then there exists a polynomial p0 ∈ PB such that if h′(x) = p0(〈w,x〉) then errD(h′) ≤ errD(h) + ǫ/2. Since it holds for all w, we get that\nmin p∈PB min h∈Hp errD(h) ≤ min h∈Hsig errD(h) + ǫ/2 .\nCombining this with Equation (9), Theorem 2 follows."
    }, {
      "heading" : "3 Hardness",
      "text" : "In this section we derive a hardness result for agnostic learning of Hsig or Hpw with respect to the zero-one loss. The hardness result relies on the hardness of standard (non-agnostic)3 PAC learning of intersection of halfspaces given in Klivans and Sherstov [17] (see also similar arguments in [12]). The hardness result is representation-independent —it makes no restrictions on the learning algorithm and in particular also holds for improper learning algorithms. The hardness result is based on the following cryptographic assumption:\n3In the standard PAC model, we assume that some hypothesis in the class has errD(h) = 0, while in the agnostic PAC model, which we study in this paper, errD(h) might be strictly greater than zero for all h ∈ H . Note that our definition of (ǫ, δ)-learning in this paper is in the agnostic model.\nAssumption 1 There is no polynomial time solution to the Õ(n1.5)-unique-Shortest-Vector-Problem.\nIn a nutshell, given a basis v1, . . . ,vn ∈ Rn, the Õ(n1.5)-unique-Shortest-Vector-Problem consists of finding the shortest nonzero vector in {a1v1 + . . . + anvn : a1, . . . , an ∈ Z}, even given the information that it is shorter by a factor of at least Õ(n1.5) than any other non-parallel vector. This problem is believed to be hard - there are no known sub-exponential algorithms, and it is known to be NP-hard if Õ(n1.5) is replaced by a small constant (see [17] for more details).\nWith this assumption, Klivans and Sherstov proved the following:\nTheorem 4 (Theorem 1.2 in Klivans and Sherstov [17]) Let X = {±1}n, let H = {x 7→ φ0,1(〈w,x〉 − θ − 1/2) : θ ∈ N,w ∈ Nn, |θ|+ ‖w‖1 ≤ poly(n)} ,\nand let Hk = {x 7→ (h1(x) ∧ . . . ∧ hk(x)) : ∀i, hi ∈ H}. Then, based on Assumption 1, Hk is not efficiently learnable in the standard PAC model for any k = nρ where ρ > 0 is a constant.\nThe above theorem implies the following.\nLemma 3 Based on Assumption 1, there is no algorithm that runs in time poly(n, 1/ǫ, 1/δ) and (ǫ, δ)-learns the class H defined in Theorem 4.\nProof To prove the lemma we show that if there is a polynomial time algorithm that learns H in the agnostic model, then there exists a weak learning algorithm (with a polynomial edge) that learns Hk in the standard (non-agnostic) PAC model. In the standard PAC model, weak learning implies strong learning [20], hence the existence of a weak learning algorithm that learns Hk will contradict Theorem 4.\nIndeed, let D be any distribution such that there exists h⋆ ∈ Hk with errD(h⋆) = 0. Let us rewrite h⋆ = h⋆1 ∧ . . .∧ h⋆k where for all i, h⋆i ∈ H . To show that there exists a weak learner, we first show that there exists some h ∈ H with errD(h) ≤ 1/2− 1/2k2.\nSince for each x if h⋆(x) = 0 then there exists j s.t. h⋆j (x) = 0, we can use the union bound to get that\n1 = P[∃j : h⋆j (x) = 0|h⋆(x) = 0] ≤ ∑\nj\nP[h⋆j (x) = 0|h⋆(x) = 0] ≤ kmax j P[h⋆j (x) = 0|h⋆(x) = 0] .\nSo, for j that maximizes P[h⋆j (x) = 0|h⋆(x) = 0] we get that P[h⋆j (x) = 0|h⋆(x) = 0] ≥ 1/k. Therefore,\nerrD(h ⋆ j ) = P[h ⋆ j (x) = 1 ∧ h⋆(x) = 0] = P[h⋆(x) = 0] P[h⋆j (x) = 1|h⋆(x) = 0]\n= P[h⋆(x) = 0] (1− P[h⋆j (x) = 0|h⋆(x) = 0]) ≤ P[h⋆(x) = 0] (1− 1/k) .\nNow, if P[h⋆(x) = 0] ≤ 1/2 + 1/k2 then the above gives\nerrD(h ⋆ j ) ≤ (1/2 + 1/k2)(1− 1/k) ≤ 1/2− 1/2k2 ,\nwhere the inequality holds for any positive integer k. Otherwise, if P[h⋆(x) = 0] > 1/2+ 1/k2, then the constant predictor h(x) = 0 has errD(h) < 1/2− 1/k2. In both cases we have shown that there exists a predictor in H with error of at most 1/2− 1/2k2.\nFinally, if we can agnostically learn H in time poly(n, 1/ǫ, 1/δ), then we can find h′ with errD(h′) ≤ minh∈H errD(h) + ǫ ≤ 1/2 − 1/2k2 + ǫ in time poly(n, 1/ǫ, 1/δ) (recall that k = nρ for some ρ > 0). This means that we can have a weak learner that runs in polynomial time, and this concludes our proof.\nLet h be a hypothesis in the class H defined in Theorem 4 and take any x ∈ {±1}n. Then, there exist an integer θ and a vector of integers w such that h(x) = φ0,1(〈w,x〉 − θ − 1/2). But since 〈w,x〉 − θ is also an integer, if we let L = 1 this means that h(x) = φpw(〈w,x〉 − θ − 1/2) as well. Furthermore, letting x′ ∈ Rn+1 denote the concatenation of x with the constant 1 and letting w′ ∈ Rn+1 denote the concatenation of w with the scalar (−θ− 1/2) we obtain that h(x) = φpw(〈w′,x′〉). Last, let us normalize w̃ = w′/‖w′‖, x̃ = x/‖x′‖, and redefine L to be ‖w′‖ ‖x′‖, we get that h(x) = φpw(〈w̃, x̃〉). That is, we have shown that H is contained in a class of the form Hpw with a Lipschitz constant bounded by poly(n). Combining the above with Lemma 3 we obtain the following:\nCorollary 2 Let L be a Lipschitz constant and let Hpw be the class defined by the L-Lipschitz transfer function φpw. Then, based on Assumption 1, there is no algorithm that runs in time poly(L, 1/ǫ, 1/δ) and (ǫ, δ)-learns the class Hpw.\nA similar argument leads to the hardness of learning Hsig.\nTheorem 5 Let L be a Lipschitz constant and let Hsig be the class defined by the L-Lipschitz transfer function φsig. Then, based on Assumption 1, there is no algorithm that runs in time poly(L, 1/ǫ, 1/δ) and (ǫ, δ)-learns the class Hsig.\nProof Let h be a hypothesis in the class H defined in Theorem 4 and take any x ∈ {±1}n. Then, there exist an integer θ and a vector of integers w such that h(x) = φ0,1(〈w,x〉− θ− 1/2). However, since 〈w,x〉 − θ is also an integer, we see that\n|φ0,1(〈w,x〉 − θ − 1/2)− φsig(〈w,x〉 − θ − 1/2)| ≤ 1\n1 + exp(2L) .\nThis means that for any ǫ > 0, if we pick L = log(2/ǫ−1)2 and define hsig(x) = φsig(〈w,x〉 − θ− 1/2), then |h(x) − hsig(x)| ≤ ǫ/2. Furthermore, letting x′ ∈ Rn+1 denote the concatenation of x with the constant 1 and letting w′ ∈ Rn+1 denote the concatenation of w with the scalar (−θ − 1/2) we obtain that hsig(x) = φsig(〈w′,x′〉). Last, let us normalize w̃ = w′/‖w′‖, x̃ = x/‖x′‖, and redefine L to be\nL = ‖w′‖‖x′‖ log(2/ǫ− 1)\n2 (10)\nso that hsig(x) = φsig(〈w̃, x̃〉). Thus we see that if there exists an algorithm that runs in time poly(L, 1/ǫ, 1/δ) and (ǫ/2, δ)-learns the class Hsig, then since for all h ∈ H exists hsig ∈ Hsig such that |hsig(x) − h(x)| ≤ ǫ/2, there also exists an algorithm that (ǫ, δ)-learns the concept class H defined in Theorem 4 in time polynomial in (L, 1/ǫ, 1/δ) (for L defined in Equation 10). But by definition of L in Equation 10 and the fact that ‖w′‖ and ‖x′‖ are of size poly(n), this means that there is an algorithm that runs in time polynomial in (n, 1/ǫ, 1/δ) and (ǫ, δ)-learns the class H , which contradicts Lemma 3."
    }, {
      "heading" : "4 Related work",
      "text" : "The problem of learning kernel-based halfspaces has been extensively studied before, mainly in the framework of SVM [26, 10, 21]. When the data is separable with a margin µ, it is possible to learn a halfspaces in polynomial time. The learning problem becomes much more difficult when the data is not separable with margin.\nIn terms of hardness results, [6] derive hardness results for proper learning with sufficiently small margins. There are also strong hardness of approximation results for proper learning without margin (see for example [13] and the references therein). We emphasize that we allow improper learning, which is just as useful for the purpose of learning good classifiers, and thus these hardness results do not apply. Instead, the hardness result we derived in Section 3 hold for improper learning as well. As mentioned before, the main tool we rely on for deriving the hardness result is the representation independent hardness result for learning intersections of halfspaces given in [17].\nPractical algorithms such as SVM often replace the 0-1 error function with a convex surrogate, and then apply convex optimization tools. However, there are no guarantees on how well the surrogate function approximates the 0-1 error function. Recently, [28, 4] studied the asymptotic relationship between surrogate convex loss functions and the 0-1 error function. In contrast, in this paper we show that even with a finite sample, surrogate convex loss functions can be competitive with the 0-1 error function as long as we replace inner-products with the kernel K(x,x′) = 1/(1− 0.5〈x,x′〉)."
    }, {
      "heading" : "4.1 Margin analysis",
      "text" : "Recall that we circumvented the dependence of the VC dimension of Hφ0−1 on the dimensionality of X by replacing φ0−1 with a Lipschitz transfer function. Another common approach is to require that the learned classifier will be competitive with the margin error rate of the optimal halfspace. Formally, the µ-margin error rate of a halfspace of the form hw(x) = 1(〈w,x〉 > 0) is defined as:\nerrD,µ(w) = Pr[hw(x) 6= y ∨ |〈w,x〉| ≤ µ] . (11)\nIntuitively, errD,µ(w) is the error rate of hw had we µ-shifted each point in the worst possible way. Margin based analysis restates the goal of the learner (as given in Equation (2)) and requires that the learner will find a classifier h that satisfies:\nerrD(h) ≤ min w:‖w‖=1 errD,µ(w) + ǫ . (12)\nBounds of the above form are called margin-based bounds and are widely used in the statistical analysis of Support Vector Machines and AdaBoost. It was shown [3, 19] that m = Θ(log(1/δ)/(µ ǫ)2) examples are sufficient (and necessary) to learn a classifier for which Equation (12) holds with probability of at least 1 − δ. Note that as in the sample complexity bound we gave in Theorem 1, the margin based sample complexity bound also does not depend on the dimension.\nIn fact, the Lipschitz approach used in this paper and the margin-based approach are closely related. First, it is easy to verify that if we set L = 1/(2µ), then for any w the hypothesis h(x) = φpw(〈w,x〉) satisfies errD(h) ≤ errD,µ(w). Therefore, an algorithm that (ǫ, δ)-learnsHpw also guarantees that Equation (12) holds. Second, it is also easy to verify that if we set L = 14µ log ( 2−ǫ ǫ ) then for any w the hypothesis h(x) = φsig(〈w,x〉) satisfies errD(h) ≤ errD,µ(w) + ǫ/2. Therefore, an algorithm that (ǫ/2, δ)-learns Hsig also guarantees that Equation (12) holds.\nAs a direct corollary of the above discussion we obtain that it is possible to learn a vector w that guarantees Equation (12) in time poly(exp(Õ(1/µ))).\nA computational complexity analysis under margin assumptions was first carried out in [6] (see also the hierarchical worst-case analysis recently proposed in [5]). The technique used in [6] is based on the observation that in the noise-free case, an optimal halfspace can be expressed as a linear sum of at most 1/µ2 examples. Therefore, one can perform an exhaustive search over all sub-sequences of 1/µ2 examples, and choose the optimal halfspace. Note that this algorithm will always run in time m1/µ 2 . Since the sample complexity bound requires that m will be order of 1/(µǫ)2, the runtime of the method described by [6] becomes poly(exp(Õ(1/µ2))). In comparison, our algorithm achieves a\nbetter runtime of poly(exp(Õ(1/µ))). Moreover, while the algorithm of [6] performs an exhaustive\nsearch, our algorithm’s runtime depends on the parameter B, which is poly(exp(Õ(1/µ))) only under a worst-case assumption. Since in practice we will cross-validate for B, it is plausible that in many real-world scenarios the runtime of our algorithm will be much smaller."
    }, {
      "heading" : "4.2 Distributional Assumptions",
      "text" : "The idea of approximating the zero-one transfer function with a polynomial was first proposed by [15] who studied the problem of agnostically learning halfspaces without kernels in Rn under distributional assumption. In particular, they showed that if the distribution over X is uniform over the unit ball, then it is possible to agnostically learn Hφ0−1 in time poly(n\n1/ǫ4). This was further generalized by [7], who showed that similar bounds hold for product distributions.\nBeside distributional assumptions, these works are characterized by explicit dependence on the dimension of X , and therefore are not adequate for the kernel-based setting we consider in this paper, in which the dimensionality of X can even be infinite. More precisely, while [15] try to approximate the zero-one transfer function with a low-degree polynomial, we require instead that the coefficients of the polynomials are bounded. The principle that when learning in high dimensions “the size of the parameters is more important than their number” was one of the main advantages in the analysis of the statistical properties of several learning algorithms (e.g. [2]).\nInterestingly, in [23] we show that the very same algorithm we use in this paper recover the same complexity bound of [15]."
    }, {
      "heading" : "5 Discussion",
      "text" : "In this paper we described and analyzed a new technique for agnostically learning kernel-based halfspaces with the zero-one loss function. The bound we derive has an exponential dependence on L, the Lipschitz coefficient of the transfer function. While we prove that (under a certain cryptographic assumption) no algorithm can have a polynomial dependence on L, the immediate open question is whether the dependence on L can be further improved.\nA perhaps surprising property of our analysis is that we propose a single algorithm, returning a single classifier, which is simultaneously competitive against all transfer functions p ∈ PB . In particular, it learns with respect to the “optimal” transfer function, where by optimal we mean the one which attains the smallest error rate, E[|p(〈w,x〉) − y|], over the distribution D.\nOur algorithm boils down to linear regression with the absolute loss function and while composing a particular kernel function over our original RKHS. It is possible to show that solving the vanilla\nSVM, with the hinge-loss, and composing again our particular kernel over the desired kernel, can also give similar guarantees. It is therefore interesting to study if there is something special about the kernel we propose or maybe other kernel functions (e.g. the Gaussian kernel) can give similar guarantees.\nAnother possible direction is to consider other types of margin-based analysis or transfer functions. For example, in the statistical learning literature, there are several definitions of “noise” conditions, some of them are related to margin, which lead to faster decrease of the error rate as a function of the number of examples (see for example [9, 25, 24]). Studying the computational complexity of learning under these conditions is left to future work."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We would like to thank Adam Klivans for helping with the Hardness results. This work was partially supported by a Google Faculty Research Grant."
    }, {
      "heading" : "A Solving the ERM problem given in Equation (5)",
      "text" : "In this section we show how to approximately solve Equation (5) when the transfer function is φpw. The technique we use is similar to the covering technique described in [6].\nFor each i, let bi = 2(yi − 1/2). It is easy to verify that the objective of Equation (5) can be rewritten as\n1\nm\nm ∑\ni=1\nf(bi〈w,xi〉) where f(a) = min{1,max{0, 1/2− La}} . (13)\nLet g(a) = max{0, 1/2−La}. Note that g is a convex function, g(a) ≥ f(a) for every a, and equality holds whenever a ≥ −1/2L.\nLet w⋆ be a minimizer of Equation (13) over the unit ball. We partition the set [m] into\nI1 = {i ∈ [m] : g(bi〈w⋆,xi〉) = f(bi〈w⋆,xi〉)} , I2 = [m] \\ I1 .\nNow, let ŵ be a vector that satisfies\n∑ i∈I1 g(bi〈ŵ,xi〉) ≤ min w:‖w‖≤1 ∑ i∈I1 g(bi〈w,xi〉) + ǫm . (14)\nClearly, we have\nm ∑\ni=1\nf(bi〈ŵ,xi〉) ≤ ∑\ni∈I1 g(bi〈ŵ,xi〉) +\n∑ i∈I2 f(bi〈ŵ,xi〉)\n≤ ∑\ni∈I1 g(bi〈ŵ,xi〉) + |I2|\n≤ ∑\ni∈I1 g(bi〈w⋆,xi〉) + ǫm+ |I2|\n= m ∑\ni=1\nf(bi〈w⋆,xi〉) + ǫm .\nDividing the two sides of the above by m we obtain that ŵ is an ǫ-accurate solution to Equation (13). Therefore, it suffices to show a method that finds a vector ŵ that satisfies Equation (14). To do so, we use a standard generalization bound (based on Rademacher complexity) as follows:\nLemma 4 Let us sample i1, . . . , ik i.i.d. according to the uniform distribution over I1. Let ŵ be a minimizer of ∑k\nj=1 g(bij 〈w,xij 〉) over w in the unit ball. Then,\nE\n[\n1 |I1|\n∑ i∈I1 g(bi〈ŵ,xi〉)− min w:‖w‖≤1 1 |I1| ∑ i∈I1 g(bi〈w,xi〉)\n]\n≤ 2L/ √ k ,\nwhere expectation is over the choice of i1, . . . , ik.\nProof Simply note that g is L-Lipschitz and then apply a Rademacher generalization bound with the contraction lemma.\nThe above lemma immediately implies that if k ≥ 4L2/ǫ2, then there exist i1, . . . , ik in I1 such that if ŵ ∈ argmin\nw:‖w‖≤1 ∑k j=1 g(bij 〈w,xij 〉) then ŵ satisfies Equation (14) and therefore it is an ǫ-accurate solution of Equation (13). The procedure will therefore perform an exhaustive search over all i1, . . . , ik in [m], for each such sequence the procedure will find ŵ ∈ argminw:‖w‖≤1 ∑k\nj=1 g(bij 〈w,xij 〉) (in polynomial time). Finally, the procedure will output the ŵ that minimizes the objective of Equation (13). The total runtime of the procedure is therefore poly(mk). Plugging in the value of k = ⌈4L2/ǫ2⌉ and the value of m according to the sample complexity bound given in Theorem 1 we obtain the total runtime of\npoly ( (L/ǫ)L 2/ǫ2 ) = poly ( exp ( L2 ǫ2 log(L/ǫ) )) ."
    }, {
      "heading" : "B Proof of Lemma 2",
      "text" : "In order to approximate φsig with a polynomial, we will use the technique of Chebyshev approximation (cf. [18]). One can write any continuous function on [−1,+1] as a Chebyshev expansion ∑∞\nn=0 αnTn(·), where each Tn(·) is a particular n-th degree polynomial denoted as the n-th Chebyshev polynomial (of the first kind). These polynomials are defined as T0(x) = 1, T1(x) = x, and then recursively via Tn+1(x) = 2xTn(x) − Tn−1(x). For any n, Tn(·) is bounded in [−1,+1]. The coefficients in the Chebyshev expansion of φsig are equal to\nαn = 1 + 1(n > 0)\nπ\n∫ 1\nx=−1\nφsig(x)Tn(x)√ 1− x2 dx. (15)\nTruncating the series after some threshold n = N provides an N -th degree polynomial which approximates the original function.\nIn order to obtain a bound on B, we need to understand the behavior of the coefficients in the Chebyshev approximation. These are determined in turn by the behavior of αn as well as the coefficients of each Chebyshev polynomial Tn(·). The following two lemmas provide the necessary bounds.\nLemma 5 For any n > 1, |αn| in the Chebyshev expansion of φsig on [−1,+1] is upper bounded as follows:\n|αn| ≤ 1/2L+ 1/π\n(1 + π/4L)n .\nAlso, we have |α0| ≤ 1, |α1| ≤ 2.\nProof The coefficients αn, n = 1, . . . in the Chebyshev series are given explicitly by\nαn = 2\nπ\n∫ 1\nx=−1\nφsig(x)Tn(x)√ 1− x2 dx. (16)\nFor α0, the same equality holds with 2/π replaced by 1/π, so α0 equals\n1\nπ\n∫ 1\nx=−1\nφsig(x)√ 1− x2 dx,\nwhich by definition of φsig(x), is at most (1/π) ∫ 1 x=−1 (√ 1− x2 )−1 dx = 1. As for α1, it equals\n2\nπ\n∫ 1\nx=−1\nφsig(x)x√ 1− x2 dx,\nwhose absolute value is at most (2/π) ∫ 1 x=−1 (√ 1− x2 )−1 dx = 2.\nTo evaluate the integral in Equation (16) for general n and L, we will need to use some tools from complex analysis. The calculation follows [11], to which we refer the reader for justification of the steps and further details4.\nOn the complex plane, the integral in Equation (16) can be viewed as a line integral over [−1,+1]. Using properties of Chebyshev polynomials, this integral can be converted into a more general complex-valued integral over an arbitrary closed curve C on the complex plane which satisfies certain regularity conditions:\nαn = 1\nπi\n∫\nC\nφsig(z)dz√ z2 − 1(z ± √ z2 − 1)n dz, (17)\nwhere the sign in ± is chosen so that |z ± √ z2 − 1| > 1. In particular, for any parameter ρ > 1, the set of points z satisfying |z ± √ z2 − 1| = ρ form an ellipse, which grows larger with ρ and with foci at z = ±1 and which grows larger with ρ. Since we are free to choose C, we choose it as this ellipse while letting ρ → ∞.\nTo understand what happens when ρ → ∞, we need to characterize the singularities of φsig(z), namely the points z where φsig(z) is not well defined. Recalling that φsig(z) = (1 + e\n−4Lz)−1, we see that the problematic points are i(π + 2πk)/4L for any k = ±1,±2, . . ., where the denominator in φsig(z) equals zero. Note that this forms a discrete set of isolated points - in other words, φsig is\n4We note that such calculations also appear in standard textbooks on the subject, but they are usually carried under asymptotic assumptions and disregarding coefficients which are important for our purposes.\na meromorphic function. The fact that φsig is ’well behaved’ in this sense allows us to perform the analysis below.\nThe behavior of the function at its singularities is defined via the residue of the function at each singularity c, which equals limz→c(z − c)φsig(z) assuming the limit exists (in that case, the singularity is called a simple pole, otherwise a higher order limit might be needed). In our case, the residue for the singularity at iπ/4L equals\nlim z→0\nz\n1 + e−iπ−4Lz = lim z→0 z 1− e−4Lz = limz→0 1/4L e−4Lz = 1/4L,\nwhere we used l’Hôpital’s rule to calculate the limit. The same residue also apply to all the other singularities.\nFor points in the complex plane uniformly bounded away from these singularities, |φsig(z)| is bounded, and therefore it can be shown that the integral in Equation (17) will tend to zero as we let C become an arbitrarily large ellipse (not passing too close to any of the singularities) by taking ρ → ∞. However, as ρ varies smoothly, the ellipse does cross over singularity points, and these contribute to the integral. For meromorphic functions, with a discrete set of isolated singularities, we can simply sum over all contributions, and it can be shown (see equation 10 in [11] and the subsequent discussion) that\nαn = −2 ∞ ∑\nk=−∞\nrk √\nz2k − 1 ( zk ± √ z2k − 1 )n ,\nwhere zk is the singularity point i(π + 2πk)/4L with corresponding residue rk. Substituting the results for our chosen function, we have\nαn =\n∞ ∑\nk=−∞\n1/4L √\n(i(π + 2πk)/4L)2 − 1 ( i(π + 2πk)/4L± √ (i(π + 2πk)/4L)2 − 1 )n .\nA routine simplification leads to the following5:\nαn = ∞ ∑\nk=−∞\n1/4L\nin+1 √ ((π + 2πk)/4L) 2 + 1\n(\n(π + 2πk)/4L± √ ((π + 2πk)/4L) 2 + 1\n)n .\nIt can be verified that ± should be chosen according to 1(k ≥ 0). Therefore,\n|αn| = ∞ ∑\nk=−∞\n1/4L √\n((π + 2πk)/4L) 2 + 1\n(\n|π + 2πk|/4L+ √ ((π + 2πk)/4L) 2 + 1\n)n\n≤ ∞ ∑\nk=−∞\n1/4L (|π + 2πk|1/4L+ 1)n ≤ 1/4L (1 + π/4L)n + 2\n∞ ∑\nk=1\n1/4L\n(1 + π(1 + 2k)/4L) n\n≤ 1/4L (1 + π/4L)n +\n∫ ∞\nk=0\n1/2L\n(1 + π(1 + 2k)/4L) n dk\nSolving the integral and simplifying gives us\n|αn| ≤ 1\n(1 + π/4L)n\n(\n1/4L+ 1 + π/4L\nπ(n− 1)\n)\n.\nSince n ≥ 2, the result in the lemma follows.\n5On first look, it might appear that αn takes imaginary values for even n, due to the i n+1 factor, despite αn being equal to a real-valued integral. However, it can be shown that αn = 0 for even n. This additional analysis can also be used to slightly tighten our final results in terms of constants in the exponent, but it was not included for simplicity.\nLemma 6 For any non-negative integer n and j = 0, 1, . . . , n, let tn,j be the coefficient of x j in Tn(x). Then tn,j = 0 for any j with a different parity than n, and for any j > 0,\n|tn,j | ≤ en+j√ 2π\nProof The fact that tn,j = 0 for j, n with different parities, and |tn,0| ≤ 1 is standard. Using an explicit formula from the literature (see [18], pg. 24), as well as Stirling approximation, we have that\n|tn,j | = 2n−(n−j)−1 n\nn− n−j2\n( n− n−j2 n−j 2 ) = 2jn n+ j ( n+j 2 ) ! ( n−j 2 ) !j!\n≤ 2 jn\nj!(n+ j)\n(\nn+ j\n2\n)j\n= n(n+ j)j (n+ j)j! ≤ n(n+ j) j (n+ j) √ 2πj(j/e)j = nej (n+ j) √ 2πj\n(\n1 + n\nj\n)j\n≤ ne j\n(n+ j) √ 2πj en.\nfrom which the lemma follows.\nWe are now in a position to prove a bound on B. As discussed earlier, φsig(x) in the domain [−1,+1] equals the expansion ∑∞n=0 αnTx. The error resulting from truncating the Chebyshev expanding at index N , for any x ∈ [−1,+1], equals\n∣ ∣ ∣ ∣ ∣ φsig(x) − N ∑\nn=0\nαnTn(x)\n∣ ∣ ∣ ∣ ∣ = ∣ ∣ ∣ ∣ ∣ ∞ ∑\nn=N+1\nαnTn(x)\n∣ ∣ ∣ ∣ ∣ ≤ ∞ ∑\nn=N+1\n|αn|,\nwhere in the last transition we used the fact that |Tn(x)| ≤ 1. Using Lemma 5 and assuming N > 0, this is at most\n∞ ∑\nn=N+1\n1/2L+ 1/π (1 + π/4L)n = 2 + 4L/π π(1 + π/4L)N .\nIn order to achieve an accuracy of less than ǫ in the approximation, we need to equate this to ǫ and solve for N , i.e.\nN =\n⌈\nlog1+π/4L\n(\n2 + 4L/π\nπǫ\n)⌉\n(18)\nThe series left after truncation is ∑N n=0 αnTn(x), which we can write as ∑N j=0 βjx j . Using Lemma 5 and Lemma 6, the absolute value of the coefficient βj for j > 1 can be upper bounded by\n∑\nn=j..N,n=j mod 2\n|an||tn,j | ≤ ∑\nn=j..N,n=j mod 2\n1/2L+ 1/π (1 + π/4L)n en+j√ 2π\n= (1/2L+ 1/π)ej√\n2π\n∑\nn=j..N,n=j mod 2\n(\ne\n1 + π/4L\n)n\n= (1/2L+ 1/π)ej√\n2π\n(\ne\n1 + π/4L\n)j ⌊N−j2 ⌋ ∑\nn=0\n(\ne\n1 + π/4L\n)2n\n≤ (1/2L+ 1/π)e j\n√ 2π\n(\ne\n1 + π/4L\n)j (e/(1 + π/4L))N−j+2 − 1\n(e/(1 + π/4L))2 − 1 .\nSince we assume L ≥ 3, we have in particular e/(1 + π/4L) > 1, so we can upper bound the expression above by dropping the 1 in the numerator, to get\n1/2L+ 1/π√ 2π((e/(1 + π/4L))2 − 1)\n(\ne\n1 + π/4L\n)N+2\nej .\nThe cases β0, β1 need to be treated separately, due to the different form of the bounds on α0, α1. Repeating a similar analysis (using the actual values of tn,1, tn,0 for any n), we get\nβ0 ≤ 1 + 1\nπ +\n2L\nπ2\nβ1 ≤ 2 + 3(1 + 2L/π)(4L+ π)\n2π2 .\nNow that we got a bound on the βj , we can plug it into the bound on B, and get\nB =\nN ∑\nj=0\n2jβ2j ≤ β20 + 2β21 + N ∑\nj=2\n(\n1/2L+ 1/π√ 2π((e/(1 + π/4L))2 − 1)\n)2 ( e\n1 + π/4L\n)2N+4\n(2e2)j\n≤ β20 + 2β21 + ( 1/2L+ 1/π√ 2π((e/(1 + π/4L))2 − 1) )2 ( e 1 + π/4L )2N+4 (2e2)N+1 e2 − 1\n= β20 + 2β 2 1 +\n2(1/2L+ 1/π)2e6\n(e2 − 1)2π((e/(1 + π/4L))2 − 1)2(1 + π/4L)4\n( √ 2e2\n1 + π/4L\n)2N\n.\nTo make the expression more readable, we use the (rather arbitrary) assumption that L ≥ 3. In that case, by some numerical calculations, it is not difficult to show that we can upper bound the above by\n2L4 + 0.15\n( √ 2e2\n1 + π/4L\n)2N\n≤ 2L4 + 0.15(2e4)N .\nCombining this with Equation (18), we get that this is upper bounded by\n2L4 + 0.15(2e4)log1+π/4L( 2+4L/π πǫ )+1,\nor at most\n2L4 + exp\n\n\nlog(2e4) log (\n2+4L/π πǫ\n)\nlog(1 + π/4L) + 3\n\n .\nUsing the fact that log(1 + x) ≥ x − x2 for x ≥ 0, and the assumption that L ≥ 3, we can bound the exponent by\nlog(2e4) log (\n2+4L/π πǫ\n)\nπ 4L\n( 1− π8L ) + 3 ≤ 7 log(2L/ǫ)L+ 3.\nSubstituting back, we get the result stated in Lemma 2."
    }, {
      "heading" : "C The φerf(·) Function",
      "text" : "In this section, we prove a result anaologous to Lemma 2, using the φerf(·) transfer function. In a certain sense, it is stronger, because we can show that φerf(·) actually belongs to PB for sufficiently large B. However, the resulting bound is worse than Lemma 2, as it depends on exp(L2) rather than exp(L). However, the proof is much simpler, which helps to illustrate the technique.\nThe relevant lemma is the following:\nLemma 7 Let φerf(·) be as defined in Equation (4), where for simplicity we assume L ≥ 3. For any ǫ > 0, let\nB ≤ 1 4 + 2L2 ( 1 + 3πeL2e4πL 2 ) .\nThen φerf(·) ∈ PB.\nProof By a standard fact, φerf(·) is equal to its infinite Taylor series expansion at any point, and this series equals\nφerf(a) = 1\n2 + 1√ π\n∞ ∑\nn=0\n(−1)n(√πLa)2n+1 n!(2n+ 1) .\nLuckily, this is an infinite degree polynomial, and it is only left to calculate for which values of B does it belong to PB. Plugging in the coefficients in the bound on B, we get that\nB ≤ 1 4 + 1 π\n∞ ∑\nn=0\n(2πL2)2n+1\n(n!)2(2n+ 1)2 ≤ 1 4 + 1 π\n∞ ∑\nn=0\n(2πL2)2n+1\n(n!)2\n= 1\n4 + 2L2\n(\n1 +\n∞ ∑\nn=1\n(2πL2)2n\n(n!)2\n)\n≤ 1 4 + 2L2\n(\n1 +\n∞ ∑\nn=1\n(2πL2)2n\n(n/e)2n\n)\n= 1\n4 + 2L2\n(\n1 +\n∞ ∑\nn=1\n(\n2πeL2\nn\n)2n )\n.\nThinking of (2πeL2/n)2n as a continuous function of n, a simple derivative exercise shows that it is maximized for n = 2πL2, with value e4πL 2\n. Therefore, we can upper bound the series in the expression above as follows:\n∞ ∑\nn=1\n(\n2πeL2\nn\n)2n\n=\n⌊2 √ 2πeL2⌋ ∑\nn=1\n(\n2πeL2\nn\n)2n\n+\n∞ ∑\nn=⌈2 √ 2πeL2⌉\n(\n2πeL2\nn\n)2n\n≤ 2 √ 2πeL2e4πL 2 +\n∞ ∑\nn=⌈2 √ 2πeL2⌉\n(\n1\n2\n)n\n≤ 3πeL2e4πL2 .\nwhere the last transition is by the assumption that L ≥ 3. Substituting into the bound on B, we get the result stated in the lemma."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2010,
    "abstractText" : "<lb>We describe and analyze a new algorithm for agnostically learning kernel-based halfspaces<lb>with respect to the zero-one loss function. Unlike most previous formulations which rely on<lb>surrogate convex loss functions (e.g. hinge-loss in SVM and log-loss in logistic regression),<lb>we provide finite time/sample guarantees with respect to the more natural zero-one loss<lb>function. The proposed algorithm can learn kernel-based halfspaces in worst-case time<lb>poly(exp(L log(L/ǫ))), for any distribution, where L is a Lipschitz constant (which can be<lb>thought of as the reciprocal of the margin), and the learned classifier is worse than the<lb>optimal halfspace by at most ǫ. We also prove a hardness result, showing that under a<lb>certain cryptographic assumption, no algorithm can learn kernel-based halfspaces in time<lb>polynomial in L.<lb>",
    "creator" : "LaTeX with hyperref package"
  }
}