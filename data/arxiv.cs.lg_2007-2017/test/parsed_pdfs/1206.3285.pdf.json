{
  "name" : "1206.3285.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Dyna-Style Planning with Linear Function Approximation and Prioritized Sweeping",
    "authors" : [ "Richard S. Sutton", "Csaba Szepesvári", "Alborz Geramifard", "Michael Bowling" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "We consider the problem of efficiently learning optimal control policies and value functions over large state spaces in an online setting in which estimates must be available after each interaction with the world. This paper develops an explicitly model-based approach extending the Dyna architecture to linear function approximation. Dynastyle planning proceeds by generating imaginary experience from the world model and then applying model-free reinforcement learning algorithms to the imagined state transitions. Our main results are to prove that linear Dyna-style planning converges to a unique solution independent of the generating distribution, under natural conditions. In the policy evaluation setting, we prove that the limit point is the least-squares (LSTD) solution. An implication of our results is that prioritized-sweeping can be soundly extended to the linear approximation case, backing up to preceding features rather than to preceding states. We introduce two versions of prioritized sweeping with linear Dyna and briefly illustrate their performance empirically on the Mountain Car and Boyan Chain problems."
    }, {
      "heading" : "1 Online learning and planning",
      "text" : "Efficient decision making when interacting with an incompletely known world can be thought of as an online learning and planning problem. Each interaction provides additional information that can be used to learn a better model of the world’s dynamics, and because this change could result in a different action being best (given the model), the planning process should be repeated to take this into account. However, planning is inherently a complex process; on large problems it not possible to repeat it on every time step without greatly slowing down the response time of the system. Some form of incremental planning is required that, though\nincomplete on each step, still efficiently computes optimal actions in a timely manner.\nThe Dyna architecture (Sutton 1990) provides an effective and flexible approach to incremental planning while maintaining responsiveness. There are two ideas underlying the Dyna architecture. One is that planning, acting, and learning are all continual, operating as fast as they can without waiting for each other. In practice, on conventional computers, each time step is shared between planning, acting, and learning, with proportions that can be set arbitrarily according to available resources and required response times.\nThe second idea underlying the Dyna architecture is that learning and planning are similar in a radical sense. Planning in the Dyna architecture consists of using the model to generate imaginary experience and then processing the transitions of the imaginary experience by model-free reinforcement learning algorithms as if they had actually occurred. This can be shown, under various conditions, to produce exactly the same results as dynamic-programming methods in the limit of infinite imaginary experience.\nThe original papers on the Dyna architecture and most subsequent extensions (e.g., Singh 1992; Peng & Williams 1993; Moore & Atkeson 1993; Kuvayev & Sutton 1996) assumed a Markov environment with a tabular representation of states. This table-lookup representation limits the applicability of the methods to relatively small problems. Reinforcement learning has been combined with function approximation to make it applicable to vastly larger problems than could be addressed with a tabular approach. The most popular form of function approximation is linear function approximation, in which states or state-action pairs are first mapped to feature vectors, which are then mapped in a linear way, with learned parameters, to value or next-state estimates. Linear methods have been used in many of the successful large-scale applications of reinforcement learning (e.g., Silver, Sutton & Müller 2007; Schaeffer, Hlynka & Jussila 2001). Linear function approximation is also simple, easy to understand, and possesses some of the strongest convergence and performance guarantees among function approximation methods. It is\nnatural then to consider extending Dyna for use with linear function approximation, as we do in this paper.\nThere has been little previous work addressing planning with linear function approximation in an online setting. Paduraru (2007) treated this case, focusing mainly on sampling stochastic models of a cascading linear form, but also briefly discussing deterministic linear models. Degris, Sigaud and Wuillemin (2006) developed a version of Dyna based on approximations in the form of dynamic Bayes networks and decision trees. Their system, SPITI, included online learning and planning based on an incremental version of structured value iteration (Boutilier, Dearden & Goldszmidt 2000). Singh (1992) developed a version of Dyna for variable resolution but still tabular models. Others have proposed linear least-squares methods for policy evaluation that are efficient in the amount of data used (Bradtke & Barto 1996; Boyan 1999, 2002; Geramifard, Bowling & Sutton 2006). These methods can be interpreted as forming and then planning with a linear model of the world’s dynamics, but so far their extensions to the control case have not been well suited to online use (Lagoudakis & Parr 2003; Peters, Vijayakumar & Schaal 2005; Bowling, Geramifard, & Wingate 2008), whereas our linear Dyna methods are naturally adapted to this case. We discuss more specifically the relationship of our work to LSTD methods in a later section. Finally, Atkeson (1993) and others have explored linear, learned models with off-line planning methods suited to low-dimensional continuous systems."
    }, {
      "heading" : "2 Notation",
      "text" : "We use the standard framework for reinforcement learning with linear function approximation (Sutton & Barto 1998), in which experience consists of the time indexed stream s0, a0, r1, s1, a1, r2, s2, . . ., where st ∈ S is a state, at ∈ A is an action, and rt ∈ R is a reward. The actions are selected by a learning agent, and the states and rewards are selected by a stationary environment. The agent does not have access to the states directly but only through a corresponding feature vector φt ∈ Rn = φ(st). The agent selects actions according to a policy, π : Rn ×A → [0, 1] such that ∑ a∈A π(φ, a) = 1, ∀φ. An important step towards finding a good policy is to estimate the value function for a given policy (policy evaluation). The value function is approximated as a linear function with parameter vector θ ∈ Rn:\nθ>φ(s) ≈ V π(s) = Eπ { ∞∑ t=1 γt−1rt | s0 = s } ,\nwhere γ ∈ [0, 1). In this paper we consider policies that are greedy or -greedy with respect to the approximate statevalue function.\nAlgorithm 1 : Linear Dyna for policy evaluation, with random sampling and gradient-descent model learning\nObtain initial φ, θ, F, b For each time step:\nTake action a according to the policy. Receive r, φ′ θ ← θ + α[r + γθ>φ′ − θ>φ]φ F ← F + α(φ′ − Fφ)φ> b← b+ α(r − b>φ)φ temp← φ′ Repeat p times (planning):\nGenerate a sample φ from some distribution µ φ′ ← Fφ r ← b>φ θ ← θ + α[r + γθ>φ′ − θ>φ]φ\nφ← temp"
    }, {
      "heading" : "3 Theory for policy evaluation",
      "text" : "The natural place to begin a study of Dyna-style planning is with the policy evaluation problem of estimating a statevalue function from a linear model of the world. The model consists of a forward transition matrix F ∈ Rn × Rn (incorporating both environment and policy) and an expected reward vector b ∈ Rn, constructed such that Fφ and b>φ can be used as estimates of the feature vector and reward that follow φ. A Dyna algorithm for policy evaluation goes through a sequence of planning steps, on each of which a starting feature vector φ is generated according to a probability distribution µ, and then a next feature vector φ′ = Fφ and next reward r = b>φ are generated from the model. Given this imaginary experience, a conventional modelfree update is performed, for example, according to the linear TD(0) algorithm (Sutton 1988):\nθ ← θ + α(r + γθ>φ′ − θ>φ)φ, (1)\nor according to the residual gradient algorithm (Baird 1995):\nθ ← θ + α(r + γθ>φ′ − θ>φ)(φ− γφ′), (2)\nwhere α > 0 is a step-size parameter. A complete algorithm using TD(0), including learning of the model, is given in Algorithm 1."
    }, {
      "heading" : "3.1 Convergence and fixed point",
      "text" : "There are two salient theoretical questions about the Dyna planning iterations (1) and (2): Under what conditions on µ and F do they converge? and What do they converge to? Both of these questions turn out to have interesting answers. First, note that the convergence of (1) is in question in part because it is known that linear TD(0) may diverge if the distribution of starting states during training does not match the distribution created by the normal dynamics of\nthe system, that is, if TD(0) is used off-policy. This suggests that the sampling distribution used here, µ, might have to be strongly constrained in order for the iteration to be stable. On the other hand, the data here is from the model, and the model is not a general system: it is deterministic1 and linear. This special case could be much better behaved. In fact, convergence of linear Dyna-style policy evaluation, with either the TD(0) or residual-gradient iterations, is not affected by µ, but only by F , as long as µ exercises all directions in the full n-dimensional vector space. Moreover, not only is the fact of convergence unaffected by µ, but so is the value converged to. In fact, we show below that convergence is to a deterministic fixed point, a value of θ such that the iterations (1) and (2) leave it unchanged not just in expected value, but for every individual φ that could be generated by µ. The only way this could be true is if the TD error (the first expression in parentheses in each iteration) were exactly zero, that is, if\n0 = r + γθ>φ′ − θ>φ = b>φ+ γθ>Fφ− θ>φ = (b+ γF>θ − θ)>φ.\nAnd the only way that this can be true for all φ is for the expression in parenthesis above to be zero:\n0 = b+ γF>θ − θ = b+ (γF> − I)θ,\nwhich immediately implies that\nθ = (I − γF>)−1b, (3)\nassuming that the inverse exists. Note that this expression for the fixed point does not depend on µ, as promised.\nIf I − γF> is nonsingular, then there might be no fixed point. This could happen for example if F were an expansion, or more generally if the limit (γF )∞ were not zero. These cases correspond to world models that say the feature vectors diverge to infinity over time. Failure to converge in these cases should not be considered a problem for the Dyna iterations as planning algorithms; these are cases in which the planning problem is ill posed. If the feature vectors diverge, then so too may the rewards, in which case the true values given the model are infinite. No real finite Markov decision process could behave in this way.\nIt remains to show the conditions on F under which the iterations converge to the fixed point if one exists. We prove next that under the TD(0) iteration (1), convergence is guaranteed if the numerical radius of F is less than one,2 and\n1The model is deterministic because it generates the expectation of the next feature vector; the system itself may be stochastic.\n2The numerical radius of a real-valued square matrix A is defined by r(A) = max‖x‖2=1 x T Ax.\nthen that under the residual-gradient iteration (2), convergence is guaranteed for any F as long as the fixed point exists. That F ’s numerical radius be less than 1 is a stronger condition than nonsingularity of I − γF>, but it is similar in that both conditions pertain to the matrix trending toward expansion when multiplied by itself.\nTheorem 3.1 (Convergence of linear TD(0) Dyna for policy evaluation). Consider the TD(0) iteration with a nonnegative step-size sequence (αk):\nθk+1 = θk + αk(b>φk + γθ>k Fφk − θ>k φk)φk, (4)\nwhere θ0 ∈ Rn is arbitrary. Assume that (i) the step-size sequence satisfies ∑∞ k=0 αk = ∞, ∑∞ k=0 α 2 k < ∞, (ii) r(F ) ≤ 1, (iii) (φk) are uniformly bounded i.i.d. random variables, and that (iv) C = E [ φkφ > k ] is non-singular. Then the parameter vector θk converges with probability one to (I − γF>)−1b.\nProof. The idea of the proof is to view the algorithm as a stochastic gradient descent method. In particular, we apply Proposition 4.1 of (Bertsekas & Tsitsiklis 1996).\nBefore verifying the conditions of this result, let us rewrite (4) in terms of the matrix G = I − γF :\nθk+1 = θk + αk(b>φk + θ>k (γF − I)φk)φk = θk + αk(b>φk − θ>k Gφk)φk = θk + αksk.\nHere sk is defined by the last equation.\nThe cited proposition requires the definition of a potential function J(θ) and will allow us to conclude that limk→∞∇J(θk) = 0 with probability one. Let us choose J(θ) = 1/2 E [ (b>φk + γθ>Fφk − θ>φk)2 ] . Note that by our i.i.d. assumptions on the features, J(θ) is welldefined. We need to check four conditions (because the step-size conditions are automatically satisfied): (i) The nonnegativity of the potential function; (ii) The Lipschitz continuity of ∇J(θ); (iii) The pseudo-gradient property of the expected update direction; and (iv) The boundedness of the expected magnitude of the update, more precisely that E [ ‖sk‖22|θk ] ≤ O(‖∇J(θk)‖22). Nonnegativity is satisfied by definition and the boundedness condition (iv) is satisfied thanks to the boundedness of the features.\nLet us show now that the pseudo-gradient property (iii) is satisfied. This condition requires the demonstration of a positive constant c such that\nc‖∇J(θk)‖22 ≤ −∇J(θk)>E [sk|θk] . (5)\nDefine sk = E [sk|θk] = Cb − CG>θk. A simple calculation gives ∇J(θk) = −Gsk. Hence ‖∇J(θk)‖22 = s>k G\n>Gsk and −(∇J(θk))>sk = s>k Gsk. Therefore (5) is equivalent to c s>k G\n>Gsk ≤ s>k Gsk. In order to make this true with a sufficiently small c, it suffices to show that\ns>Gs > 0 holds for any non-zero vector s. An elementary reasoning shows that this is equivalent to 1/2(G+G>) being positive definite, which in turn is equivalent to r(F ) ≤ 1, showing that (iii) is satisfied.\nHence, we have verified all the assumptions of the cited proposition and can therefore we conclude that limk→∞∇J(θk) = 0 with probability one. Plugging in the expression of∇J(θk), we get limt→∞(Cb−CG>θk) = 0. Because C and G are invertible (this latter follows from r(F ) ≤ 1), it follows that the limit of θk exists and limk→∞ θk = (G>)−1b = (I − γF>)−1b.\nSeveral extensions of this result are possible. First, the requirement of i.i.d. sampling can be considerably relaxed. With an essentially unchanged proof, it is possible to show that the theorem remains true if the feature vectors are generated by a Markov process given that they satisfy appropriate ergodicity conditions. Moreover, building on a result by Delyon (1996), one can show that the result continues to hold even if the sequence of features is generated in an algorithmic manner, again provided that some ergodicity conditions are met. The major assumption then is that C = limK→∞ 1/K ∑K k=1 φkφ > k exists and is nonsingular. Further, because there is no “noise” to reject, there is no need to decay the step-sizes towards zero (the condition ∑∞ k=0 α 2 k < +∞ in the proofs is used to “filter out noise”). In particular, we conjecture that sufficiently small constant step-sizes would work as well (for a result of this type see Proposition 3.4 by Bertsekas & Tsitsiklis 1996).\nOn the other hand the requirement on the numerical radius of F seems to be necessary for the convergence of the TD(0) iteration. By studying the ODE associated with (4), we see that it is stable if and only if CG is a positive stable matrix (i.e., iff all its eigenvalues have positive real part). From this it seems necessary to require that G is positive stable. However, to ensure that CG is positive stable the strictly stronger condition that G + G> is positive definite must be satisfied. This latter condition is equivalent to r(F ) ≤ 1.\nWe turn now to consider the convergence of Dyna planning using the residual-gradient Dyna iteration (2). This update rule can be derived by taking the gradient of J(θ, φk) = (b>φk + γθ>φk − θ>φk)2 w.r.t. θ. Thus, as an immediate consequence of Proposition 4.1 of (Bertsekas & Tsitsiklis 1996) we get the following result:\nTheorem 3.2 (Convergence of residual-gradient Dyna for policy evaluation). Assume that θk is updated according to\nθk+1 = θk + αk(b>φk + γθ>k Fφk − θ>k φk)(φk − γFφk),\nwhere θ0 ∈ Rn is arbitrary. Assume that the non-negative step-size sequence (αk) satisfies the summability condition (i) of Theorem 3.1 and that (φk) are uniformly bounded i.i.d. random variables. Then the parameter vector θk con-\nverges with probability one to (I − γF>)−1b, assuming that (I − γF>) is non-singular.\nProof. As all the conditions of Proposition 4.1 of (Bertsekas & Tsitsiklis 1996) are trivially satisfied with the choice J(θ) = E [J(θ, φk)], we can conclude that θk converges w.p.1 to the minimizer of J(θ). In the previous theorem we have seen that the minimizer of J(θ) is indeed θ = (I − γF>)−1b, finishing the proof."
    }, {
      "heading" : "3.2 Convergence to the LSTD solution",
      "text" : "So far we have discussed the convergence of planning given a model, but we have said nothing about the relationship of the model to data, or about the quality of the resultant solution. Suppose the model were the best linear fit to a finite dataset of observed feature-vector-to-feature-vector transitions with accompanying rewards. In this case we can show that the fixed point of the Dyna updates is the least squares temporal-difference solution. This is the solution for which the mean TD(0) update is zero and is also the solution found by the LSTD(0) algorithm (Barto & Bradtke 1996).\nTheorem 3.3. Given a training dataset of feature, reward, next-state feature triples D = [φ1, r1, φ′1, . . . , φn, rn, φ ′ n], let F, b be the least-squares model built on D. Assume that C = ∑n k=1 φkφ > k has full rank. Then the solution (3) is the same as the LSTD solution on this training set.\nProof. It suffices to show that the respective solution sets of the equations\n0 = n∑ k=1 φk(rk + γ(φ′k) >θ − φ>k θ), (6) 0 = b+ (γF> − I)θ (7)\nare the same. This is because the LSTD parameter vectors are obtained by solving the first equation and the TD(0) Dyna solutions are derived from the second equation.\nLet D = ∑n k=1 φk(φ ′ k) >, and r = ∑n k=1 φkrk. A standard calculation shows that"
    }, {
      "heading" : "F> = C−1D and b = C−1 r.",
      "text" : "Plugging in C, D into (6) and factoring out θ shows that any solution of (6) also satisfies\n0 = r + (γD − C) θ. (8)\nIf we multiply both sides of (8) by C−1 from the left we get (7). Hence any solution of (6) is also a solution of (7). Because all the steps of the above derivation are reversible, we get that the reverse statement holds as well.\nAlgorithm 2 : Linear Dyna with PWMA prioritized sweeping (policy evaluation)\nObtain initial φ, θ, F, b For each time step:\nTake action a according to the policy. Receive r, φ′ δ ← r + γθ>φ′ − θ>φ θ ← θ + αδφ F ← F + α(φ′ − Fφ)φ> b← b+ α(r − b>φ)φ For all i such that φ(i) 6= 0:\nFor all j such that F ij 6= 0: Put j on the PQueue with priority |F ijδφ(i)|\nRepeat p times while PQueue is not empty: i← pop the PQueue δ ← b(i) + γθ>Fei − θ(i) θ(i)← θ(i) + αδ For all j such that F ij 6= 0: Put j on the queue with priority |F ijδ| φ← φ′"
    }, {
      "heading" : "4 Linear prioritized sweeping",
      "text" : "We have shown that the convergence and fixed point of policy evaluation by linear Dyna are not affected by the way the starting feature vectors are chosen. This opens the possibility of selecting them cleverly so as to speed the convergence of the planning process. One natural idea—the idea behind prioritized sweeping—is to work backwards from states that have changed in value to the states that lead into them. The lead-in states are given priority for being updated because an update there is likely to change the state’s value (because they lead to a state that has changed in value). If a lead-in state is updated and its value is changed, then its lead-in states are in turn given priority for updating, and so on. In the table-lookup context in which this idea was developed (Moore & Atkeson 1993; Peng 1993; see also Wingate & Seppi 2005), there could be many states preceding each changed state, but only one could be updated at a time. The states waiting to be updated were kept in a queue, prioritized by the size of their likely effect on the value function. As high-priority states were popped off the queue and updated, it would sometimes give rise to highly efficient sweeps of updates across the state space; this is what gave rise to the name “prioritized sweeping”.\nWith function approximation it is not possible to identify and work backwards from individual states, but alternatively one could work backwards feature by feature. If there has just been a large change in θ(i), the component of the parameter vector corresponding to the ith feature, then one can look backwards through the model to find the features j whose components θ(j) are likely to have changed as a result. These are the features j for which the elements F ij of F are large. One can then preferentially construct\nAlgorithm 3 : Linear Dyna with MG prioritized sweeping (policy evaluation)\nObtain initial φ, θ, F, b For each time step:\nTake action a according to the policy. Receive r, φ′ δ ← r + γθ>φ′ − θ>φ θ ← θ + αδφ F ← F + α(φ′ − Fφ)φ> b← b+ α(r − b>φ)φ For all i such that φ(i) 6= 0:\nPut i on the PQueue with priority |δφ(i)| Repeat p times while PQueue is not empty: i← pop the PQueue For all j such that F ij 6= 0: δ ← b(j) + γθ>Fej − θ(j) θ(j)← θ(j) + αδ Put j on the PQueue with priority |δ| φ← φ′\nstarting feature vectors φ that have non-zero entries at these j components. In our algorithms we choose the starting vectors to be the unit basis vectors ej , all of whose components are zero except the jth, which is 1. (Our theoretical results assure us that this cannot affect the result of convergence.) Using unit basis vectors is very efficient computationally, as the vector matrix multiplication Fφ is reduced to pulling out a single column of F .\nThere are two tabular prioritized sweeping algorithms in the literature. The first, due simultaneously to Peng and Williams (1993) and to Moore and Atkeson (1993), which we call PWMA prioritized sweeping, adds the predecessors of every state encountered in real experience to the priority queue whether or not the value of the encountered state was significantly changed. The second form of prioritized sweeping, due to McMahan and Gordon (2005), and which we call MG prioritized sweeping, puts each encountered state on the queue, but not its predecessors. For McMahan and Gordon this resulted in a more efficient planner. A complete specification of our feature-by-feature versions of these two forms of prioritized sweeping are given above, with TD(0) updates and gradient-descent model learning, as Algorithms 2 and 3. These algorithms differ slightly from previous prioritized sweeping algorithms in that they update the value function from the real experiences and not just from model-generated experience. With function approximation, real experience is always more informative than model-generated experience, which will be distorted by the function approximator. We found this to be a significant effect in our empirical experiments (Section 6).\nAlgorithm 4: Linear Dyna with MG prioritized sweeping and TD(0) updates (control)\nObtain initial φ, θ, F, b For each time step: a← arg maxa [ b>a φ+ γθ >Faφ ]\n(or -greedy) Take action a, receive r, φ′ δ ← r + γθ>φ′ − θ>φ θ ← θ + αδφ Fa ← Fa + α(φ′ − Faφ)φ> ba ← ba + α(r − b>a φ)φ For all i such that φ(i) 6= 0:\nPut i on the PQueue with priority |δφ(i)| Repeat p times while PQueue is not empty: i← pop the PQueue For all j s.t. there exists an a s.t. F ija 6= 0: δ ← maxa [ ba(j) + γθ>Faej ] − θ(j)\nθ(j)← θ(j) + αδ Put j on the PQueue with priority |δ|\nφ← φ′"
    }, {
      "heading" : "5 Theory for Control",
      "text" : "We now turn to the full case of control, in which separate models Fa, ba are learned and are then available for each action a. These are constructed such that Faφ and b>a φ can be used as estimates of the feature vector and reward that follow φ if action a is taken. A linear Dyna algorithm for the control case goes through a sequence of planning steps on each of which a starting feature vector φ and an action a are chosen, and then a next feature vector φ′ = Faφ and next reward r = baφ are generated from the model. Given this imaginary experience, a conventional model-free update is performed. The simplest case is to again apply (1). A complete algorithm including prioritized sweeping is given in Algorithm 4.\nThe theory for the control case is less clear than for policy evaluation. The main issue is the stability of the “mixture” of the forward model matrices. The corollary below is stated for an i.i.d. sequence of features, but by the remark after Theorem 3.1 it can be readily extended to the case where the policy to be evaluated is used to generate the trajectories.\nCorollary 5.1 (Convergence of linear TD(0) Dyna with action models). Consider the Dyna recursion (4) with the modification that in each step, instead of Fφk, we use Fπ(φk)φk, where π is a policy mapping feature vectors to actions and {Fa} is a collection of forward-model matrices. Similarly, b>φk is replaced by b>π(φk)φk. As before, assume that φk is an unspecified i.i.d. process. Let (F, b) be the least squares model of π: F = arg minG E [ ‖Gφk − Fπ(φk)φk‖22 ] and b =\narg minu E [ (u>φk − b>π(φk)φk) 2 ]\nIf the numerical radius of F is bounded by one, then the conclusions of Theo-\nrem 3.1 hold: the parameter vector θk converges with probability one to (I − γF>)−1b.\nProof. The proof is immediate from the normal equation for F , which states that E [ Fφkφ > k ] = E [ Fπ(φk)φkφ > k ] , and once we observe that, in the proof of Theorem 3.1, F appears only in expressions of the form E [ Fφkφ > k ] .\nAs in the case of policy evaluation, there is a corresponding corollary for the residual gradient iteration, with an immediate proof. These corollaries say that, for any policy with a corresponding model that is stable, the Dyna recursion can be used to compute its value function. Thus we can perform a form of policy iteration—continually computing an approximation to the value function for the greedy policy."
    }, {
      "heading" : "6 Empirical results",
      "text" : "In this section we illustrate the empirical behavior of the four Dyna algorithms and make comparisons to model-free methods using variations of two standard test problems: Boyan Chain and Mountain Car. Our Boyan Chain environment is an extension of that by Boyan (1999, 2002) from 13 to 98 states, and from 4 to 25 features (Geramifard, Bowling & Sutton 2006). Figure 1 depicts this environment in the general form. Each episode starts at state N = 98 and terminates in state 0. For all states s > 2, there is an equal probability of transitioning to states s− 1 or s−2 with a reward of−3. From states 2 and 1, there are deterministic transitions to states 1 and 0 with respective rewards of−2 and 0. Our Mountain Car environment is exactly as described by Sutton (1996; Sutton & Barto 1998), re-implemented in Matlab. An underpowered car must be driven to the top of a hill by rocking back and forth in a valley. The state variables are a pair (position,velocity) initialized to (−0.5, 0.0) at the beginning of each episode. The reward is−1 per time step. There are three discrete actions (accelerate, reverse, and coast). We used a value function representation based on tile-coding feature vectors exactly as in Sutton’s (1996) experiments, with 10 tilings over the combined (position, velocity) pair, and with the tiles hashed down to 10,000 features. In the policy evaluation experiments with this domain, the policy was to accelerate in\nthe direction of the current velocity, and we added noise to the domain that switched the selected action to a random action with 10% probability. Complete code for our test problems as standard RL-Glue environments is available from the RL-Library hosted at the University of Alberta.\nIn all experiments, the step size parameter α took the form αt = α0 N0+1N0+t1.1 , in which t is the episode number and the pair (N0, α0) was selected based on empirically finding the best combination out of α0 ∈ {.01, .1, 1} and N0 ∈ {100, 1000, 106} separately for each algorithm and domain. All methods observed the same trajectories in policy evaluation. All graphs are averages of 30 runs; error bars indicate standard errors in the means. Other parameter settings were = 0.1, γ = 1, and λ = 0.\nWe performed policy evaluation experiments with four algorithms: Dyna-Random, Dyna-PWMA, Dyna-MG (as in Algorithms 1–3), and model-free TD(0). In the case of the Dyna-Random algorithm, the starting feature vectors in planning were chosen to be unit basis vectors with the 1 in a random location. Figure 2 shows the policy evaluation performance of the four methods in the Boyan Chain and Mountain Car environments. For the Boyan Chain domain, the loss was the root-mean-squared error of the learned value function compared to the exact analytical value, averaged over all states. In the Mountain Car domain, the states are visited very non-uniformly, and a more sophisticated measure is needed. Note that all of the methods drive θ toward an asymptotic value in which the expected TD(0) update is zero; we can use the distance from this as a loss measure. Specifically, we evaluated each learned value function by freezing it and then running a fixed set of 200,000 episodes with it while running the TD(0) algorithm (but not allowing θ to actually change). The norm of the sum of the (attempted) update vectors was then computed and used as the loss. In practice, this measure can be computed very efficiently as ||A∗θ−b∗|| (in the notation of\nLSTD(0), see Bradtke & Barto 1996).\nIn the Boyan Chain environment, the Dyna algorithms generally learned more rapidly than model-free TD(0). DynaMG was initially slower than the other algorithms, then caught up and surpassed them. The relatively poor early performance of Dyna-MG was actually due to its being a better planning method. After few episodes the model tends to be of very high variance, and so therefore is the best value-function estimate given it. We tested this hypothesis by running the Dyna methods starting with a fixed, well-learned model; in this case Dyna-MG was the best of all the methods from the beginning. All of these data are for one step of planning for each real step of interaction with the world (p = 1). In preliminary experiments with larger values of p, up to p = 10, we found further improvements in learning rate of the Dyna algorithms over TD(0), and again Dyna-MG was best.\nThe results for Mountain Car are less clear. Dyna-MG quickly does significantly better than TD(0), but the other Dyna algorithms lag initially and never surpass TD(0). Note that, for any value of p, Dyna-MG does many more θ updates than the other two Dyna algorithms (because these updates are in an inner loop, cf. Algorithms 2 and 3). Even so, because of its other efficiencies Dyna-MG tended to run faster overall in our implementation. Obviously, there is a lot more interesting empirical work that could be done here.\nWe performed one Mountain Car experiment with DynaMG as a control algorithm (Algorithm 4), comparing it with model-free Sarsa (i.e., Algorithm 4 with p = 0). The results are shown in Figure 3. As before, Dyna-MG showed a distinct advantage over the model-free method in terms of learning rate. There was no clear advantage for either method in the second half of the experiment. We note that, asymptotically, model-free methods are never worse than model-based methods, and are often better because the model does not converge exactly to the true system because\nof structural modeling assumptions. (The case we treat here—linear models and value functions with one-step TD methods—is a rare case in which asymptotic performance of model-based and model-free methods should be identical.) The benefit of models, and of planning generally, is in rapid adaptation to new problems and situations.\nThese empirical results are not extensive and in some cases are preliminary, but they nevertheless illustrate some of the potential of linear Dyna methods. The results on the Boyan Chain domain show that Dyna-style planning can result in a significant improvement in learning speed over modelfree methods. In addition, we can see trends that have been observed in the tabular case re-occurring here with linear function approximation. In particular, prioritized sweeping can result in more efficient learning than simply updating features at random, and the MG version of prioritized sweeping seems to be better than the PWMA version.\nFinally, we would like to note that we have done extensive experimental work (not reported here) attempting to adapt least squares methods such as LSTD to online control domains, in particular to the Mountain Car problem. A major difficulty with these methods is that they place equal weight on all past data whereas, in a control setting, the policy changes and older data becomes less relevant and may even be misleading. Although we have tried a variety of forgetting strategies, it is not easy to obtain online control performance with these methods that is superior to modelfree methods. One reason we consider the Dyna approach to be promising is that no special changes are required for this case; it seems to adapt much more naturally and effectively to the online control setting."
    }, {
      "heading" : "7 Conclusion",
      "text" : "In this paper we have taken important steps toward establishing the theoretical and algorithmic foundations of Dyna-style planning with linear function approximation. We have established that Dyna-style planning with familiar reinforcement learning update rules converges under weak conditions corresponding roughly, in some cases, to the existence of a finite solution to the planning problem, and that convergence is to a unique least-squares solution independent of the distribution used to generate hypothetical experience. These results make possible our second main contribution: the introduction of algorithms that extend prioritized sweeping to linear function approximation, with correctness guarantees. Our empirical results illustrate the use of these algorithms and their potential for accelerating reinforcement learning. Overall, our results support the conclusion that Dyna-style planning may be a practical and competitive approach to achieving rapid, online control in stochastic sequential decision problems with large state spaces."
    }, {
      "heading" : "Acknowledgements",
      "text" : "The authors gratefully acknowledge the substantial contributions of Cosmin Paduraru and Mark Ring to the early stages of this work. This research was supported by iCORE, NSERC and Alberta Ingenuity."
    } ],
    "references" : [ {
      "title" : "Using local trajectory optimizers to speed up global optimization in dynamic programming",
      "author" : [ "C. Atkeson" ],
      "venue" : "Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Atkeson,? \\Q1993\\E",
      "shortCiteRegEx" : "Atkeson",
      "year" : 1993
    }, {
      "title" : "Residual algorithms: Reinforcement learning with function approximation",
      "author" : [ "L.C. Baird" ],
      "venue" : "In Proceedings of the Twelfth International Conference on Machine Learning,",
      "citeRegEx" : "Baird,? \\Q1995\\E",
      "shortCiteRegEx" : "Baird",
      "year" : 1995
    }, {
      "title" : "Stochastic dynamic programming with factored representations",
      "author" : [ "C. Boutilier", "R. Dearden", "M. Goldszmidt" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "Boutilier et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Boutilier et al\\.",
      "year" : 2000
    }, {
      "title" : "Sigma point policy iteration",
      "author" : [ "M. Bowling", "A. Geramifard", "D. Wingate" ],
      "venue" : "In Proceedings of the Seventh International Conference on Autonomous Agents and Multiagent Systems",
      "citeRegEx" : "Bowling et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Bowling et al\\.",
      "year" : 2008
    }, {
      "title" : "Least-squares temporal difference learning",
      "author" : [ "J.A. Boyan" ],
      "venue" : "In Proceedings of the Sixteenth International Conference on Machine Learning,",
      "citeRegEx" : "Boyan,? \\Q1999\\E",
      "shortCiteRegEx" : "Boyan",
      "year" : 1999
    }, {
      "title" : "Technical update: Least-squares temporal difference learning",
      "author" : [ "J.A. Boyan" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Boyan,? \\Q2002\\E",
      "shortCiteRegEx" : "Boyan",
      "year" : 2002
    }, {
      "title" : "Learning the structure of factored markov decision processes in reinforcement learning problems",
      "author" : [ "T. Degris", "O. Sigaud", "P. Wuillemin" ],
      "venue" : "Proceedings of the 23rd International Conference on Machine Learning",
      "citeRegEx" : "Degris et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Degris et al\\.",
      "year" : 2006
    }, {
      "title" : "General results on the convergence of stochastic algorithms",
      "author" : [ "B. Delyon" ],
      "venue" : "IEEE Transactions on Automatic Control,",
      "citeRegEx" : "Delyon,? \\Q1996\\E",
      "shortCiteRegEx" : "Delyon",
      "year" : 1996
    }, {
      "title" : "Incremental least-square temporal difference learning",
      "author" : [ "A. Geramifard", "M. Bowling", "R.S. Sutton" ],
      "venue" : "Proceedings of the National Conference on Artificial Intelligence,",
      "citeRegEx" : "Geramifard et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Geramifard et al\\.",
      "year" : 2006
    }, {
      "title" : "Model-based reinforcement learning with an approximate, learned model",
      "author" : [ "L. Kuvayev", "R.S. Sutton" ],
      "venue" : "Proceedings of the Ninth Yale Workshop on Adaptive and Learning Systems,",
      "citeRegEx" : "Kuvayev and Sutton,? \\Q1996\\E",
      "shortCiteRegEx" : "Kuvayev and Sutton",
      "year" : 1996
    }, {
      "title" : "Least squares policy iteration",
      "author" : [ "M. Lagoudakis", "R. Parr" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Lagoudakis and Parr,? \\Q2003\\E",
      "shortCiteRegEx" : "Lagoudakis and Parr",
      "year" : 2003
    }, {
      "title" : "Fast exact planning in Markov decision processes",
      "author" : [ "B. McMahan H", "J. Gordon G" ],
      "venue" : "Proceedings of the 15th International Conference on Automated Planning and Scheduling",
      "citeRegEx" : "H. and G.,? \\Q2005\\E",
      "shortCiteRegEx" : "H. and G.",
      "year" : 2005
    }, {
      "title" : "Prioritized sweeping: Reinforcement learning with less data and less real time",
      "author" : [ "A.W. Moore", "C.G. Atkeson" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Moore and Atkeson,? \\Q1993\\E",
      "shortCiteRegEx" : "Moore and Atkeson",
      "year" : 1993
    }, {
      "title" : "Planning with Approximate and Learned Models of Markov Decision Processes",
      "author" : [ "C. Paduraru" ],
      "venue" : "MSc thesis,",
      "citeRegEx" : "Paduraru,? \\Q2007\\E",
      "shortCiteRegEx" : "Paduraru",
      "year" : 2007
    }, {
      "title" : "Efficient learning and planning within the Dyna framework, Adaptive Behavior",
      "author" : [ "J. Peng", "R.J. Williams" ],
      "venue" : null,
      "citeRegEx" : "Peng and Williams,? \\Q1993\\E",
      "shortCiteRegEx" : "Peng and Williams",
      "year" : 1993
    }, {
      "title" : "Natural actor-critic",
      "author" : [ "J. Peters", "S. Vijayakumar", "S. Schaal" ],
      "venue" : "Proceedings of the 16th European Conference on Machine Learning,",
      "citeRegEx" : "Peters et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Peters et al\\.",
      "year" : 2005
    }, {
      "title" : "Temporal difference learning applied to a high-performance game-playing program",
      "author" : [ "J. Schaeffer", "M. Hlynka", "V. Jussila" ],
      "venue" : "Proceedings of the International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Schaeffer et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Schaeffer et al\\.",
      "year" : 2001
    }, {
      "title" : "Reinforcement learning of local shape in the game of Go",
      "author" : [ "D. Silver", "R.S. Sutton", "M. Müller" ],
      "venue" : "Proceedings of the 20th International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Silver et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Silver et al\\.",
      "year" : 2007
    }, {
      "title" : "Reinforcement learning with a hierarchy of abstract models",
      "author" : [ "S.P. Singh" ],
      "venue" : "Proceedings of the Tenth National Conference on Artificial Intelligence,",
      "citeRegEx" : "Singh,? \\Q1992\\E",
      "shortCiteRegEx" : "Singh",
      "year" : 1992
    }, {
      "title" : "Learning to predict by the method of temporal differences",
      "author" : [ "R.S. Sutton" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Sutton,? \\Q1988\\E",
      "shortCiteRegEx" : "Sutton",
      "year" : 1988
    }, {
      "title" : "Integrated architectures for learning, planning, and reacting based on approximating dynamic programming",
      "author" : [ "R.S. Sutton" ],
      "venue" : "Proceedings of the Seventh International Conference on Machine Learning,",
      "citeRegEx" : "Sutton,? \\Q1990\\E",
      "shortCiteRegEx" : "Sutton",
      "year" : 1990
    }, {
      "title" : "Generalization in reinforcement learning: Successful examples using sparse coarse coding",
      "author" : [ "R.S. Sutton" ],
      "venue" : "Advances in Neural Information Processing Systems: Proceedings of the 1995 Conference,",
      "citeRegEx" : "Sutton,? \\Q1996\\E",
      "shortCiteRegEx" : "Sutton",
      "year" : 1996
    }, {
      "title" : "Reinforcement Learning: An Introduction",
      "author" : [ "R.S. Sutton", "A.G. Barto" ],
      "venue" : null,
      "citeRegEx" : "Sutton and Barto,? \\Q1998\\E",
      "shortCiteRegEx" : "Sutton and Barto",
      "year" : 1998
    }, {
      "title" : "Prioritization methods for accelerating MDP solvers",
      "author" : [ "D. Wingate", "K.D. Seppi" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Wingate and Seppi,? \\Q2005\\E",
      "shortCiteRegEx" : "Wingate and Seppi",
      "year" : 2005
    } ],
    "referenceMentions" : [ {
      "referenceID" : 20,
      "context" : "The Dyna architecture (Sutton 1990) provides an effective and flexible approach to incremental planning while maintaining responsiveness.",
      "startOffset" : 22,
      "endOffset" : 35
    }, {
      "referenceID" : 10,
      "context" : "Paduraru (2007) treated this case, focusing mainly on sampling stochastic models of a cascading linear form, but also briefly discussing deterministic linear models.",
      "startOffset" : 0,
      "endOffset" : 16
    }, {
      "referenceID" : 10,
      "context" : "Paduraru (2007) treated this case, focusing mainly on sampling stochastic models of a cascading linear form, but also briefly discussing deterministic linear models. Degris, Sigaud and Wuillemin (2006) developed a version of Dyna based on approximations in the form of dynamic Bayes networks and decision trees.",
      "startOffset" : 0,
      "endOffset" : 202
    }, {
      "referenceID" : 10,
      "context" : "Paduraru (2007) treated this case, focusing mainly on sampling stochastic models of a cascading linear form, but also briefly discussing deterministic linear models. Degris, Sigaud and Wuillemin (2006) developed a version of Dyna based on approximations in the form of dynamic Bayes networks and decision trees. Their system, SPITI, included online learning and planning based on an incremental version of structured value iteration (Boutilier, Dearden & Goldszmidt 2000). Singh (1992) developed a version of Dyna for variable resolution but still tabular models.",
      "startOffset" : 0,
      "endOffset" : 486
    }, {
      "referenceID" : 0,
      "context" : "Finally, Atkeson (1993) and others have explored linear, learned models with off-line planning methods suited to low-dimensional continuous systems.",
      "startOffset" : 9,
      "endOffset" : 24
    }, {
      "referenceID" : 19,
      "context" : "Given this imaginary experience, a conventional modelfree update is performed, for example, according to the linear TD(0) algorithm (Sutton 1988):",
      "startOffset" : 132,
      "endOffset" : 145
    }, {
      "referenceID" : 1,
      "context" : "or according to the residual gradient algorithm (Baird 1995):",
      "startOffset" : 48,
      "endOffset" : 60
    }, {
      "referenceID" : 7,
      "context" : "Moreover, building on a result by Delyon (1996), one can show that the result continues to hold even if the sequence of features is generated in an algorithmic manner, again provided that some ergodicity conditions are met.",
      "startOffset" : 34,
      "endOffset" : 48
    }, {
      "referenceID" : 12,
      "context" : "The first, due simultaneously to Peng and Williams (1993) and to Moore and Atkeson (1993), which we call PWMA prioritized sweeping, adds the predecessors of every state encountered in real experience to the priority queue whether or not the value of the encountered state was significantly changed.",
      "startOffset" : 33,
      "endOffset" : 58
    }, {
      "referenceID" : 0,
      "context" : "The first, due simultaneously to Peng and Williams (1993) and to Moore and Atkeson (1993), which we call PWMA prioritized sweeping, adds the predecessors of every state encountered in real experience to the priority queue whether or not the value of the encountered state was significantly changed.",
      "startOffset" : 75,
      "endOffset" : 90
    }, {
      "referenceID" : 0,
      "context" : "The first, due simultaneously to Peng and Williams (1993) and to Moore and Atkeson (1993), which we call PWMA prioritized sweeping, adds the predecessors of every state encountered in real experience to the priority queue whether or not the value of the encountered state was significantly changed. The second form of prioritized sweeping, due to McMahan and Gordon (2005), and which we call MG prioritized sweeping, puts each encountered state on the queue, but not its predecessors.",
      "startOffset" : 75,
      "endOffset" : 373
    }, {
      "referenceID" : 4,
      "context" : "In this section we illustrate the empirical behavior of the four Dyna algorithms and make comparisons to model-free methods using variations of two standard test problems: Boyan Chain and Mountain Car. Our Boyan Chain environment is an extension of that by Boyan (1999, 2002) from 13 to 98 states, and from 4 to 25 features (Geramifard, Bowling & Sutton 2006). Figure 1 depicts this environment in the general form. Each episode starts at state N = 98 and terminates in state 0. For all states s > 2, there is an equal probability of transitioning to states s− 1 or s−2 with a reward of−3. From states 2 and 1, there are deterministic transitions to states 1 and 0 with respective rewards of−2 and 0. Our Mountain Car environment is exactly as described by Sutton (1996; Sutton & Barto 1998), re-implemented in Matlab. An underpowered car must be driven to the top of a hill by rocking back and forth in a valley. The state variables are a pair (position,velocity) initialized to (−0.5, 0.0) at the beginning of each episode. The reward is−1 per time step. There are three discrete actions (accelerate, reverse, and coast). We used a value function representation based on tile-coding feature vectors exactly as in Sutton’s (1996) experiments, with 10 tilings over the combined (position, velocity) pair, and with the tiles hashed down to 10,000 features.",
      "startOffset" : 172,
      "endOffset" : 1231
    } ],
    "year" : 2008,
    "abstractText" : "We consider the problem of efficiently learning optimal control policies and value functions over large state spaces in an online setting in which estimates must be available after each interaction with the world. This paper develops an explicitly model-based approach extending the Dyna architecture to linear function approximation. Dynastyle planning proceeds by generating imaginary experience from the world model and then applying model-free reinforcement learning algorithms to the imagined state transitions. Our main results are to prove that linear Dyna-style planning converges to a unique solution independent of the generating distribution, under natural conditions. In the policy evaluation setting, we prove that the limit point is the least-squares (LSTD) solution. An implication of our results is that prioritized-sweeping can be soundly extended to the linear approximation case, backing up to preceding features rather than to preceding states. We introduce two versions of prioritized sweeping with linear Dyna and briefly illustrate their performance empirically on the Mountain Car and Boyan Chain problems. 1 Online learning and planning Efficient decision making when interacting with an incompletely known world can be thought of as an online learning and planning problem. Each interaction provides additional information that can be used to learn a better model of the world’s dynamics, and because this change could result in a different action being best (given the model), the planning process should be repeated to take this into account. However, planning is inherently a complex process; on large problems it not possible to repeat it on every time step without greatly slowing down the response time of the system. Some form of incremental planning is required that, though incomplete on each step, still efficiently computes optimal actions in a timely manner. The Dyna architecture (Sutton 1990) provides an effective and flexible approach to incremental planning while maintaining responsiveness. There are two ideas underlying the Dyna architecture. One is that planning, acting, and learning are all continual, operating as fast as they can without waiting for each other. In practice, on conventional computers, each time step is shared between planning, acting, and learning, with proportions that can be set arbitrarily according to available resources and required response times. The second idea underlying the Dyna architecture is that learning and planning are similar in a radical sense. Planning in the Dyna architecture consists of using the model to generate imaginary experience and then processing the transitions of the imaginary experience by model-free reinforcement learning algorithms as if they had actually occurred. This can be shown, under various conditions, to produce exactly the same results as dynamic-programming methods in the limit of infinite imaginary experience. The original papers on the Dyna architecture and most subsequent extensions (e.g., Singh 1992; Peng & Williams 1993; Moore & Atkeson 1993; Kuvayev & Sutton 1996) assumed a Markov environment with a tabular representation of states. This table-lookup representation limits the applicability of the methods to relatively small problems. Reinforcement learning has been combined with function approximation to make it applicable to vastly larger problems than could be addressed with a tabular approach. The most popular form of function approximation is linear function approximation, in which states or state-action pairs are first mapped to feature vectors, which are then mapped in a linear way, with learned parameters, to value or next-state estimates. Linear methods have been used in many of the successful large-scale applications of reinforcement learning (e.g., Silver, Sutton & Müller 2007; Schaeffer, Hlynka & Jussila 2001). Linear function approximation is also simple, easy to understand, and possesses some of the strongest convergence and performance guarantees among function approximation methods. It is natural then to consider extending Dyna for use with linear function approximation, as we do in this paper. There has been little previous work addressing planning with linear function approximation in an online setting. Paduraru (2007) treated this case, focusing mainly on sampling stochastic models of a cascading linear form, but also briefly discussing deterministic linear models. Degris, Sigaud and Wuillemin (2006) developed a version of Dyna based on approximations in the form of dynamic Bayes networks and decision trees. Their system, SPITI, included online learning and planning based on an incremental version of structured value iteration (Boutilier, Dearden & Goldszmidt 2000). Singh (1992) developed a version of Dyna for variable resolution but still tabular models. Others have proposed linear least-squares methods for policy evaluation that are efficient in the amount of data used (Bradtke & Barto 1996; Boyan 1999, 2002; Geramifard, Bowling & Sutton 2006). These methods can be interpreted as forming and then planning with a linear model of the world’s dynamics, but so far their extensions to the control case have not been well suited to online use (Lagoudakis & Parr 2003; Peters, Vijayakumar & Schaal 2005; Bowling, Geramifard, & Wingate 2008), whereas our linear Dyna methods are naturally adapted to this case. We discuss more specifically the relationship of our work to LSTD methods in a later section. Finally, Atkeson (1993) and others have explored linear, learned models with off-line planning methods suited to low-dimensional continuous systems.",
    "creator" : "TeX"
  }
}