{
  "name" : "1502.04137.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Non-Adaptive Learning a Hidden Hipergraph",
    "authors" : [ "Hasan Abasi", "Nader H. Bshouty", "Hanna Mazzawi" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 2.\n04 13\n7v 1\n[ cs\n.L G\n] 1\n3 Fe"
    }, {
      "heading" : "1 Introduction",
      "text" : "Let Gs,r be a set of all labeled hypergraphs of rank at most r on the set V = {1, 2, . . . , n} with at most s edges. Given a hidden hypergraph G ∈ Gs,r, we need to identify it by asking edge-detecting queries. An edge-detecting query QG(S), for S ⊆ V is: does S contain at least one edge of G? Our objective is to non-adaptively learn the hypergraph G by asking as few queries as possible.\nThis problem has many applications in chemical reactions, molecular biology and genome sequencing. In chemical reactions, we are given a set of chemicals, some of which react and some which do not. When multiple chemicals are combined in one test tube, a reaction is detectable if and only if at least one set of the chemicals in the tube reacts. The goal is to identify which sets react using as few experiments as possible. The time needed to compute which experiments to do is a secondary consideration, though it is polynomial for the algorithms we present. See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.\nIn all of the above applications the rank of the hypergraph is much smaller than the number of edges and both are much smaller than the number of vertices n. Therefore, throughout the paper, we will assume that r ≤ s and s = o(n).\nThe above hypergraph learning problem is equivalent to the problem of nonadaptively learning a monotone DNF with at most s monomials (monotone term), where each monomial contains at most r variables (s-term r-MDNF) from membership queries [1,6]. In this paper we will use the later terminology rather than the hypergraph one.\nThe adaptive learnability of s-term r-MDNF was studied in [5,20,6,4]. In [4], Abasi et. al. gave a polynomial time adaptive learning algorithm for s-term r-MDNF with almost optimal query complexity. The non-adaptive learnability of s-term r-MDNF was studied in [33,27,28,24,20,19,12].\n2 Torney ,[33], first introduced the problem and gave some applications in molecular biology. The first explicit non-adaptive learning algorithm for s-term rMDNF was given by Gao et. al., [24]. They show that this class can be learned using (n, (s, r))-cover-free family ((n, (s, r))-CFF). This family is a set A ⊆ {0, 1}n of assignments such that for every distinct i1, . . . , is, j1, . . . , jr ∈ {1, . . . , n} there is a ∈ A such that ai1 = · · · = ais = 0 and aj1 = · · · = ajr = 1. Given such a set, the algorithm simply takes all the monomials M of size at most r that satisfy (∀a ∈ A)(M(a) = 1 ⇒ f(a) = 1). It is easy to see that the disjunction of all such monomials is equivalent to the target function. Assuming a set of (n, (s, r))-CFF of size N can be constructed in time T , this algorithm learns s-term r-MDNF with N queries in time O( (\nn r\n)\n+ T ).\nIn [20,9], it is shown that any set A ⊂ {0, 1}n that non-adaptively learns s-term r-MDNF is an (n, (s − 1, r))-CFF. Therefore, the minimum size of an (n, (s−1, r))-CFF is also a lower bound for the number of queries (and therefore also for the time) for non-adaptively learning s-term r-MDNF. It is known, [31], that any (n, (s, r))-CFF must have size at least Ω(N(s, r) log n) where\nN(s, r) = s+ r\nlog ( s+r r )\n(\ns+ r\nr\n)\n. (1)\nTherefore, any non-adaptive algorithm for learning s-term r-DNF must ask at least N(s− 1, r) logn = Ω(N(s, r) log n) queries and runs in at least Ω(N(s, r)n logn) time.\nGao et. al. constructed an (n, (s, r))-CFF of size S = (2s logn/ log(s logn))r+1\nin time Õ(S). It follows from [32] that an (n, (s, r))-CFF of sizeO ( (sr)log ∗ n log n ) can be constructed in polynomial time. A polynomial time almost optimal constructions of size N(s, r)1+o(1) logn for (n, (s, r))-CFF were given in [11,10,12,23] which give better query complexities, but still, the above algorithms have exponential time complexity O( ( n\nr\n)\n), when r is not constant. The latter result implies\nthat there is a non-adaptive algorithm that asks Q := N(s, r)1+o(1) logn queries and runs in exponential time O( (\nn r\n)\n). Though, when r = O(1) is constant, the above algorithms run in polynomial time and are optimal. Therefore, we will assume r = ω(1).\nChin et. al. claim in [19] that they have a polynomial time algorithm that constructs an (n, (s, r))-CFF of optimal size. Their analysis is misleading.3 The size is indeed optimal but the time complexity of the construction is O( (\nn r+s\n)\n). But even if a (n, (s, r))-CFF can be constructed in polynomial time, the above learning algorithm still takes O( ( n\nr\n)\n) time.\nMacula et. al., [27,28], gave several randomized non-adaptive algorithms. We first use their ideas combined with the constructions of (n, (r, s))-CFF in [11,10,12,23] to give a new non-adaptive algorithm that asks N(s, r)1+o(1) log2 n queries and runs in poly(n,N(s, r)) time. This algorithm is almost optimal in s and r but quadratic in logn. We then use a new technique that changes any non-adaptive\n3 Some parts of the construction can indeed be performed in polynomial time, but not the whole construction\n3 learning algorithm that asks Q(r, s, n) queries to a non-adaptive learning algorithm that asks (rs)2 · Q(r, s, (rs)2) log n queries. This give a non-adaptive learning algorithm that asks N(s, r)1+o(1) logn queries and runs in n logn · poly(N(s, r)) time.\nThe following table summarizes the results (r = ω(1))\nReferences Query Complexity Time Complexity\n[24] N(s, r) · (r logn/ log(s logn))r+1 ( n\nr\n)\n[19] N(s, r) log n ( n r+s )\n[11,10,12,23] N(s, r)1+o(1) logn ( n\nr\n)\nOurs+[27,28]+[12] N(s, r)1+o(1) log2 n poly(n,N(s, r))\nOurs N(s, r)1+o(1) logn (n logn) · poly(N(s, r))\nOurs, r = o(s) N(s, r)1+o(1) logn (n logn) ·N(s, r)1+o(1)\nLower Bound [20] N(s, r) log n (n logn) ·N(s, r)\nThis paper is organized as follows. Section 2 gives some definitions and preliminary results that will be used throughout the paper. Section 3 gives the first algorithm that asks N(s, r)1+o(1) log2 n membership queries and runs in time poly(n,N(s, r)). Section 4 gives the reduction and shows how to use it to give the second algorithm that asks N(s, r)1+o(1) logn membership queries and runs in time (n logn) ·N(s, r)1+o(1). All the algorithms in this paper are deterministic. In the full paper we will also consider randomized algorithms that slightly improve (in the o(1) of the exponent) the query and time complexity."
    }, {
      "heading" : "2 Definitions",
      "text" : ""
    }, {
      "heading" : "2.1 Monotone Boolean Functions",
      "text" : "For a vector w, we denote by wi the ith entry of w. Let {e (i) | i = 1, . . . , n} ⊂ {0, 1}n be the standard basis. That is, e (i) j = 1 if i = j and e (i) j = 0 otherwise. For a positive integer j, we denote by [j] the set {1, 2, . . . , j}. For two assignments a, b ∈ {0, 1}n we denote by (a ∧ b) ∈ {0, 1}n the bitwise AND assignment. That is, (a ∧ b)i = ai ∧ bi.\nLet f(x1, x2, . . . , xn) be a boolean function from {0, 1} n to {0, 1}. For 1 ≤\ni1 < i2 < · · · < ik ≤ n and σ1, . . . , σk ∈ {0, 1} ∪ {x1, . . . , xn} we denote by\nf |xi1←σ1,xi2←σ2,···,xik←σk\nthe function f(y1, . . . , yn) where yij = σj for all j ∈ [k] and yi = xi for all i ∈ [n]\\{i1, . . . , ik}. We say that the variable xi is relevant in f if f |xi←0 6≡ f |xi←1. A variable xi is irrelevant in f if it is not relevant in f . We say that the class is closed under variable projections if for every f ∈ C and every two variables xi and xj , i, j ≤ n, we have f |xi←xj ∈ C.\nFor two assignments a, b ∈ {0, 1}n, we write a ≤ b if for every i ∈ [n], ai ≤ bi. A Boolean function f : {0, 1}n → {0, 1} is monotone if for every two assignments\n4 a, b ∈ {0, 1}n, if a ≤ b then f(a) ≤ f(b). Recall that every monotone boolean function f has a unique representation as a reduced monotone DNF, [1]. That is, f = M1∨M2∨· · ·∨Ms where each monomial Mi is an ANDs of input variables, and for every monomial Mi there is a unique assignment a (i) ∈ {0, 1}n such that f(a(i)) = 1 and for every j ∈ [n] where a (i) j = 1 we have f(a\n(i)|xj←0) = 0. We call such assignment a minterm of the function f . Notice that every monotone DNF can be uniquely determined by its minterms [1]. That is, a ∈ {0, 1}n is a minterm of f iff M := ∧i∈{j:aj=1}xi is a monomial in f .\nAn s-term r-MDNF is a monotone DNF with at most s monomials, where each monomial contains at most r variables. It is easy to see that the class s-term r-MDNF is closed under variable projections."
    }, {
      "heading" : "2.2 Learning from Membership Queries",
      "text" : "Consider a teacher that has a target function f : {0, 1}n → {0, 1} that is s-term r-MDNF. The teacher can answer membership queries. That is, when receiving a ∈ {0, 1}n it returns f(a). A learning algorithm is an algorithm that can ask the teacher membership queries. The goal of the learning algorithm is to exactly learn (exactly find) f with minimum number of membership queries and optimal time complexity.\nLet c and H ⊃ C be classes of boolean formulas. We say that C is learnable from H in time T (n) with Q(n) membership queries if there is a learning algorithm that, for a target function f ∈ C, runs in time T (n), asks at most Q(n) membership queries and outputs a function h in H that is equivalent to C. When H = C then we say that C is properly learnable in time T (n) with Q(n) membership queries.\nIn adaptive algorithms the queries can depend on the answers to the previous queries where in non-adaptive algorithms the queries are independent of the answers to the previous queries and therefore all the queries can be asked in parallel, that is, in one step."
    }, {
      "heading" : "2.3 Learning a Hypergraph",
      "text" : "Let Gs,r be a set of all labeled hypergraphs on the set of vertices V = {1, 2, . . . , n} with s edges of rank (size) at most r. Given a hidden hypergraph G ∈ Gs,r, we need to identify it by asking edge-detecting queries. An edge-detecting query QG(S), for S ⊆ V is: does S contain at least one edge of G? Our objective is to learn (identify) the hypergraph G by asking as few queries as possible.\nThis problem is equivalent to learning s-term r-MDNF f from membership queries. Each edge e in the hypergraph corresponds to the monotone term ∧i∈exi in f and the edge-detecting query QG(S) corresponds to asking membership queries of the assignment a(S) where a (S) i = 1 if and only if i ∈ S. Therefore, the class Gs,r can be regarded as the set of s-term r-MDNF. The class of s-term r-MDNF is denoted by G∗s,r. Now it obvious that any learning algorithm for G ∗ s,r is also a learning algorithm for Gs,r.\n5 The following example shows that we cannot allow two edges e1 ⊂ e2. Let G1 be a graph where V1 = {1, 2} and E1 = {{1}, {1, 2}}. This graph corresponds to the function f = x1 ∨ x1x2 that is equivalent to x1 which corresponds to the graph G2 where V2 = {1, 2} and E2 = {{1}}. Also, no edge-detecting query can distinguish between G1 and G2.\nWe say that A ⊆ {0, 1} is an identity testing set for G∗s,r if for every two distinct s-term r-MDNF f1 and f2 there is a ∈ A such that f1(a) 6= f2(a). Obviously, every identity testing set for G∗s,r can be used as queries to nonadaptively learns G∗s,r."
    }, {
      "heading" : "2.4 Cover Free Families",
      "text" : "An (n, (s, r))-cover free family ((n, (s, r))-CFF), [22], is a set A ⊆ {0, 1}n such that for every 1 ≤ i1 < i2 < · · · < id ≤ n where d = s + r and every J ⊆ [d] of size |J | = s there is a ∈ A such that aik = 0 for all k ∈ J and aij = 1 for all j ∈ [d]\\J . Denote by N(n, (s, r)) the minimum size of such set. Again here we assume that r ≤ s and s = o(n). The lower bound in [31,29] is\nN(n, (s, r)) ≥ Ω (N(s, r) · logn) (2)\nwhere N(s, r) is as defined in (1). It is known that a set of random\nm = O\n(\nr1.5 ( log (s\nr + 1\n))\n(\nN(s, r) · logn+ N(s, r)\ns+ r log\n1\nδ\n))\n= N(s, r)1+o(1)(logn+ log(1/δ)) (3)\nassignments a(i) ∈ {0, 1}n, where each a (i) j is 1 with probability r/(s+ r), is an (n, (s, r))-CFF with probability at least 1− δ. It follows from [11,10,12,23] that there is a polynomial time (in the size of the CFF) deterministic construction of (n, (s, r))-CFF of size\nN(s, r)1+o(1) logn (4)\nwhere the o(1) is with respect to r. When r = o(s) the construction runs in linear time [10,12]."
    }, {
      "heading" : "2.5 Perfect Hash Function",
      "text" : "Let H be a family of functions h : [n] → [q]. For d ≤ q we say that H is an (n, q, d)-perfect hash family ((n, q, d)-PHF) [7] if for every subset S ⊆ [n] of size |S| = d there is a hash function h ∈ H such that h|S is injective (one-to-one) on S, i.e., |h(S)| = d.\nIn [10] Bshouty shows\nLemma 1. Let q ≥ 2d2. There is a (n, q, d)-PHF of size\nO\n(\nd2 logn\nlog(q/d2)\n)\nthat can be constructed in time O(qd2n logn/ log(q/d2)).\n6 We now give the following folklore results that will be used for randomized learning algorithms\nLemma 2. Let q > d(d− 1)/2 be any integer. Fix any set S ⊂ [n] of d integers. Consider\nN := log(1/δ)\nlog (\n1 1−g(q,d)\n) ≤ log(1/δ)\nlog 2q d(d−1)\nuniform random hash functions hi : [n] → [q], i = 1, . . . , N where\ng(q, d) :=\n(\n1− 1\nq\n)(\n1− 2\nq\n)\n· · ·\n(\n1− d− 1\nq\n)\nWith probability at least 1− δ one of the hash functions is one-to-one on S."
    }, {
      "heading" : "3 The First Algorithm",
      "text" : "In this section we give the first algorithm that asks N(s, r)1+o(1) log2 n queries and runs in time poly(n,N(s, r))\nThe first algorithm is based on the ideas in [27,28] that were used to give a Monte Carlo randomized algorithm.\nLemma 3. Let A be an (n, (1, r))-CFF and B be an (n, (s− 1, r))-CFF. There is a non-adaptive proper learning algorithm for s-term r-MDNF that asks all the queries in A ∧B := {a ∧ b | a ∈ A, b ∈ B} and finds the target function in time |A ∧B| · n.\nProof. Let f be the target function. For every b ∈ B, let Ab = A∧b := {a∧b | a ∈ A}. Let Ib be the set of all i ∈ [n] such that (a∧ b)i ≥ f(a∧ b) for all a ∈ A. Let Tb := ∧i∈Ibxi. We will show that\n1. If T is a term in f then there is b ∈ B such that Tb ≡ T . 2. Either Tb = ∧i∈[n]xi or Tb is a subterm of one of terms of f .\nTo prove 1, let T be a term in f and let b ∈ B be an assignment that satisfies T and does not satisfy the other terms. Such assignment exists because B is (n, (s − 1, r))-CFF. Notice that f(x ∧ b) = T (x) = T (x ∧ b). If xi is in T and f(a ∧ b) = 1 then T (a ∧ b) = T (a) = f(a ∧ b) = 1 and (a ∧ b)i = 1. Therefore i ∈ Ib and xi in Tb. If xi not in T then since A is (n, (1, r))-CFF there is a\n′ ∈ A such that T (a′) = 1 and a′i = 0. Then (a ′∧b)i = 0 where f(a ′∧b) = 1. Therefore i is not in Ib and xi is not in Tb. Thus, Tb ≡ T . We now prove 2. We have shown in 1 that if b satisfies one term T then Tb ≡ T . If b does not satisfy any one of the terms in f then f(a ∧ b) = 0 for all a ∈ A and then Tb = ∧i∈[n]xi. Now suppose b satisfies at least two terms T1 and T2. Consider any variable xi. If xi not in T1 then as before xi will not be in Tb. This shows that Tb is a subterm of T1. ⊓⊔\nThis gives the following algorithm We now have\nTheorem 1. There is a non-adaptive proper learning algorithm for sterm rMDNF that asks\nN(s, r)1+o(1) log2 n\nqueries and runs in time poly(n,N(s, r)).\nProof. Constructing a (n, (1, r))-CFF of size |A| = r2 logn and a (n, (s− 1, r))CFF of size |B| = N(s−1, r)1+o(1) logn = N(s, r)1+o(1) logn takes poly(n,N(s, r)) time [11,10,12,23]. By Lemma 3, the learning takes time |A ∧ B| · n = poly (n,N(s, r)) time. The number of queries of the algorithm is |A∧B| ≤ |A| · |B| = N(s, r)1+o(1) log2 n. ⊓⊔"
    }, {
      "heading" : "4 The Second Algorithm",
      "text" : "In this section we give the second algorithm We first prove the following result\nLemma 4. Let C be a class of boolean function that is closed under variable projection. Let H be a class of boolean functions and suppose there is an algorithm that finds the relevant variables of f ∈ H in time R(n).\nIf C is non-adaptively learnable from H in time T (n) with Q(n) membership queries then C is non-adaptively learnable from H in time\nO\n(\nqd2n logn+ d2 logn\nlog(q/d2) (T (q)n+R(q))\n)\nwith\nO\n(\nd2Q(q)\nlog(q/d2) logn\n)\nmembership queries where d is an upper bound on the number of relevant variables in f ∈ C and q ≥ 2d2.\n8 Proof. Consider the algorithm in Figure 2. LetA(n) be a non-adaptive algorithm that learns C from H in time T (n) with Q(n) membership queries. Let f ∈ Cn be the target function. Consider the (n, q, d + 1)-PHF P that is constructed in Lemma 1 (Step 1 in the algorithm). Since C is closed under variable projection, for every h ∈ P the function fh := f(xh(1), . . . , xh(n)) is in Cq. Since the membership queries to fh can be simulated by membership queries to f there is a set of |P | ·Q(q) assignments from {0, 1}n that can be generated from A(q) that non-adaptively learn fh for all h ∈ P (Step 2 in the algorithm). The algorithm A(q) learns f ′h ∈ H that is equivalent to fh.\nThen the algorithm finds the relevant variables of each f ′h ∈ H (Step 3 in the algorithm). Let Vh be the set of relevant variables of f ′ h and let dmax = maxh |Vh|. Suppose xi1 , . . . , xid′ , d ′ ≤ d are the relevant variables in the target function f . There is a map h′ ∈ P such that h′(i1), . . . , h ′(id′) are distinct and therefore f ′ h′ depends on d′ variables. In particular, d′ = dmax (Step 4 in the algorithm). After finding d′ = dmax we have: Every h for which f ′ h depends on d ′ variables necessarily satisfies h(i1), . . . , h(id′) are distinct. Consider any other non-relevant variable xj 6∈ {xi1 , . . . , xid′ }. Since P is (n, q, d + 1)-PHF, there is h′′ ∈ P such that h′′(j), h′′(i1), . . . , h ′′(id′) are distinct. Then f ′ h′′ depends on xh′′(i1), . . . , xh′′(id′) and not in xh′′(j). This way the non-relevant variables can be eliminated. This is Step 6 in the algorithm. Since the above is true for every non-relevant variable, after Step 6 in the algorithm, the set X contains only the relevant variables of f . Then in Steps 7 and 8, the target function f can be recovered from any f ′h0 that satisfies |V (h0)| = d ′. ⊓⊔\nWe now prove\n9 Theorem 2. There is a non-adaptive proper learning algorithm for s-term rMDNF that asks\nN(s, r)1+o(1) logn\nqueries and runs in time (n logn) · poly(N(s, r)) time.\nProof. We use Lemma 4. C = H is the class of s-term r-MDNF. This class is closed under variable projection. Given f that is s-term r-MDNF, one can find all the relevant variables in R(n) = poly(s) time. The algorithm in the previous section runs in time T (n) = poly(n,N(s, r)) and asksQ(n) = N(s, r)1+o(1) log2 n queries. The number of variables in the target is bounded by d = rs. Let q = 3r2s2 ≥ 2d2. By Lemma 4, there is a non-adaptive algorithm that runs in time\nO\n(\nqd2n logn+ d2 logn\nlog(q/d2) (T (q)n+R(q))\n)\n= (n logn)poly(N(r, s))\nand asks\nO\n(\nd2Q(q)\nlog(q/d2) logn\n)\n= N(s, r)1+o(1) logn\nmembership queries. ⊓⊔"
    } ],
    "references" : [ {
      "title" : "Queries and Concept Learning",
      "author" : [ "D. Angluin" ],
      "venue" : "Machine Learning",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1987
    }, {
      "title" : "Learning a Hidden Subgraph",
      "author" : [ "N. Alon", "V. Asodi" ],
      "venue" : "SIAM J. Discrete Math",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2005
    }, {
      "title" : "Learning a Hidden Matching",
      "author" : [ "N. Alon", "R. Beigel", "S. Kasif", "S. Rudich", "B. Sudakov" ],
      "venue" : "SIAM J. Comput",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2004
    }, {
      "title" : "On Exact Learning Monotone DNF from Membership Queries",
      "author" : [ "H. Abasi", "N.H. Bshouty", "H. Mazzawi" ],
      "venue" : "CoRR abs/1405.0792",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2014
    }, {
      "title" : "Learning a Hidden Hypergraph",
      "author" : [ "D. Angluin", "J. Chen" ],
      "venue" : "Journal of Machine Learning Research",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2006
    }, {
      "title" : "Learning a Hidden Graph using O(log n) Queries per Edge",
      "author" : [ "D. Angluin", "J. Chen" ],
      "venue" : "J. Comput. Syst. Sci",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2008
    }, {
      "title" : "Algorithmic construction of sets for k-restrictions",
      "author" : [ "N. Alon", "D. Moshkovitz", "S. Safra" ],
      "venue" : "ACM Transactions on Algorithms",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2006
    }, {
      "title" : "A survey on nonadaptive group testing algorithms through the angle of decoding",
      "author" : [ "H-B. Chen", "F.K. Hwang" ],
      "venue" : "J. Comb. Optim",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2008
    }, {
      "title" : "Exact Learning from Membership Queries: Some Techniques, Results and New Directions",
      "author" : [ "N.H. Bshouty" ],
      "venue" : "ALT",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2013
    }, {
      "title" : "Linear time Constructions of some d-Restriction Problems",
      "author" : [ "N.H. Bshouty" ],
      "venue" : "CoRR abs/1406.2108",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2014
    }, {
      "title" : "Testers and their Applications",
      "author" : [ "N.H. Bshouty" ],
      "venue" : "Electronic Collouium on Computational Complexity (ECCC) 19:11,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2012
    }, {
      "title" : "An Optimal procedure for gap Closing in whole Genome Shotgun Sequencing",
      "author" : [ "R. Beigel", "N. Alon", "S. Kasif", "M. Serkan Apaydin", "L. Fortnow" ],
      "venue" : "RECOMB",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2001
    }, {
      "title" : "Asking Questions to Minimize Errors",
      "author" : [ "N.H. Bshouty", "S.A. Goldman", "Thomas R. Hancock", "Sleiman Matar" ],
      "venue" : "J. Comput. Syst. Sci",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1996
    }, {
      "title" : "Combinatorial Search on Graphs Motivated by Bioinformatics Applications: A Brief Survey",
      "author" : [ "M. Bouvel", "V. Grebinski", "G. Kucherov" ],
      "venue" : "WG",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2005
    }, {
      "title" : "Attribute-Efficient Learning in Query and Mistakebound Models",
      "author" : [ "N.H. Bshouty", "L. Hellerstein" ],
      "venue" : "COLT",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1996
    }, {
      "title" : "Reconstruction of hidden graphs and threshold group testing",
      "author" : [ "H. Chang", "H.-B. Chen", "H.-L. Fu", "C.-H. Shi" ],
      "venue" : "J. Comb. Optim",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2011
    }, {
      "title" : "Learning a hidden graph",
      "author" : [ "H. Chang", "H-L. Fu", "C-H. Shih" ],
      "venue" : null,
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2014
    }, {
      "title" : "Non-adaptive complex group testing with multiple positive sets",
      "author" : [ "F.Y.L. Chin", "H.C.M. Leung", "S.-M. Yiu" ],
      "venue" : "Theor. Comput. Sci",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2013
    }, {
      "title" : "Pooling Design and Nonadaptive Group Testing: Important Tools for DNA Sequencing",
      "author" : [ "D.Z. Du", "F. Hwang" ],
      "venue" : "World Scientific, Singapore",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2006
    }, {
      "title" : "Families of finite sets in which no intersection of l sets is covered by the union of s others",
      "author" : [ "A. D’yachkov", "P. Vilenkin", "A. Macula. D. Torney" ],
      "venue" : "J. Comb Theory Ser A",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2002
    }, {
      "title" : "Nonrandom binary superimposed codes",
      "author" : [ "W.H. Kautz", "R.C. Singleton" ],
      "venue" : "IEEE Trans. Inform. Theory",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1964
    }, {
      "title" : "Efficient Computation of Representative Sets with Applications in Parameterized and Exact Algorithms",
      "author" : [ "F.V. Fomin", "D. Lokshtanov", "S. Saurabh" ],
      "venue" : "SODA",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2014
    }, {
      "title" : "Construction of d(H)-disjunct matrix for group testing in hypergraphs",
      "author" : [ "H. Gao", "F.K. Hwang", "M.T. Thai", "W. Wu", "T. Znati" ],
      "venue" : "J. Comb. Optim",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2006
    }, {
      "title" : "Reconstructing a Hamiltonian Cycle by Querying the Graph: Application to DNA Physical Mapping",
      "author" : [ "V. Grebinski", "G. Kucherov" ],
      "venue" : "Discrete Applied Mathematics",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1998
    }, {
      "title" : "Families of k-independent sets",
      "author" : [ "D.J. Kleitman", "J. Spencer" ],
      "venue" : "Discrete Mathematics",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 1972
    }, {
      "title" : "Trivial two-stage group testing for complexes using almost disjunct matrices",
      "author" : [ "A.J. Macula", "V.V. Rykov", "S. Yekhanin" ],
      "venue" : "Discrete Applied Mathematics",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2004
    }, {
      "title" : "On Bounds of Cover-Free Families",
      "author" : [ "X. Ma", "R. Wei" ],
      "venue" : "Designs, Codes and Cryptography,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2004
    }, {
      "title" : "Learning and Verifying Graphs Using Queries with a Focus on Edge Counting",
      "author" : [ "L. Reyzin", "N. Srivastava" ],
      "venue" : "ALT",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2007
    }, {
      "title" : "Some New Bounds for Cover free Families",
      "author" : [ "D.R. Stinson", "R. Wei", "L. Zhu" ],
      "venue" : "Journal of Combinatorial Theory, Series A,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2000
    }, {
      "title" : "New constructions for perfect hash families and related structures using combintorial designs and codes",
      "author" : [ "D.R. Stinson", "R. Wei", "L. Zhu" ],
      "venue" : "J. Combin. Designs",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2000
    }, {
      "title" : "Sets pooling designs",
      "author" : [ "D.C. Torney" ],
      "venue" : "Ann. Comb",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 1999
    } ],
    "referenceMentions" : [ {
      "referenceID" : 23,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 30,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 11,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 19,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 2,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 25,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 1,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 13,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 4,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 18,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 27,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 7,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 5,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 15,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 17,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 16,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 3,
      "context" : "See [25,33,13,21,3,28,27,2,15,5,20,30,8,6,17,19,18,4] for more details and many other applications in molecular biology.",
      "startOffset" : 4,
      "endOffset" : 53
    }, {
      "referenceID" : 0,
      "context" : "The above hypergraph learning problem is equivalent to the problem of nonadaptively learning a monotone DNF with at most s monomials (monotone term), where each monomial contains at most r variables (s-term r-MDNF) from membership queries [1,6].",
      "startOffset" : 239,
      "endOffset" : 244
    }, {
      "referenceID" : 5,
      "context" : "The above hypergraph learning problem is equivalent to the problem of nonadaptively learning a monotone DNF with at most s monomials (monotone term), where each monomial contains at most r variables (s-term r-MDNF) from membership queries [1,6].",
      "startOffset" : 239,
      "endOffset" : 244
    }, {
      "referenceID" : 4,
      "context" : "The adaptive learnability of s-term r-MDNF was studied in [5,20,6,4].",
      "startOffset" : 58,
      "endOffset" : 68
    }, {
      "referenceID" : 18,
      "context" : "The adaptive learnability of s-term r-MDNF was studied in [5,20,6,4].",
      "startOffset" : 58,
      "endOffset" : 68
    }, {
      "referenceID" : 5,
      "context" : "The adaptive learnability of s-term r-MDNF was studied in [5,20,6,4].",
      "startOffset" : 58,
      "endOffset" : 68
    }, {
      "referenceID" : 3,
      "context" : "The adaptive learnability of s-term r-MDNF was studied in [5,20,6,4].",
      "startOffset" : 58,
      "endOffset" : 68
    }, {
      "referenceID" : 3,
      "context" : "In [4], Abasi et.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 30,
      "context" : "The non-adaptive learnability of s-term r-MDNF was studied in [33,27,28,24,20,19,12].",
      "startOffset" : 62,
      "endOffset" : 84
    }, {
      "referenceID" : 25,
      "context" : "The non-adaptive learnability of s-term r-MDNF was studied in [33,27,28,24,20,19,12].",
      "startOffset" : 62,
      "endOffset" : 84
    }, {
      "referenceID" : 22,
      "context" : "The non-adaptive learnability of s-term r-MDNF was studied in [33,27,28,24,20,19,12].",
      "startOffset" : 62,
      "endOffset" : 84
    }, {
      "referenceID" : 18,
      "context" : "The non-adaptive learnability of s-term r-MDNF was studied in [33,27,28,24,20,19,12].",
      "startOffset" : 62,
      "endOffset" : 84
    }, {
      "referenceID" : 17,
      "context" : "The non-adaptive learnability of s-term r-MDNF was studied in [33,27,28,24,20,19,12].",
      "startOffset" : 62,
      "endOffset" : 84
    }, {
      "referenceID" : 30,
      "context" : "Torney ,[33], first introduced the problem and gave some applications in molecular biology.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 22,
      "context" : ", [24].",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 18,
      "context" : "In [20,9], it is shown that any set A ⊂ {0, 1} that non-adaptively learns s-term r-MDNF is an (n, (s − 1, r))-CFF.",
      "startOffset" : 3,
      "endOffset" : 9
    }, {
      "referenceID" : 8,
      "context" : "In [20,9], it is shown that any set A ⊂ {0, 1} that non-adaptively learns s-term r-MDNF is an (n, (s − 1, r))-CFF.",
      "startOffset" : 3,
      "endOffset" : 9
    }, {
      "referenceID" : 28,
      "context" : "It is known, [31], that any (n, (s, r))-CFF must have size at least Ω(N(s, r) log n) where",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 29,
      "context" : "It follows from [32] that an (n, (s, r))-CFF of sizeO ( (sr) ∗ n log n )",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 10,
      "context" : "A polynomial time almost optimal constructions of size N(s, r) logn for (n, (s, r))-CFF were given in [11,10,12,23] which give better query complexities, but still, the above algorithms have exponential time complexity O( ( n r )",
      "startOffset" : 102,
      "endOffset" : 115
    }, {
      "referenceID" : 9,
      "context" : "A polynomial time almost optimal constructions of size N(s, r) logn for (n, (s, r))-CFF were given in [11,10,12,23] which give better query complexities, but still, the above algorithms have exponential time complexity O( ( n r )",
      "startOffset" : 102,
      "endOffset" : 115
    }, {
      "referenceID" : 21,
      "context" : "A polynomial time almost optimal constructions of size N(s, r) logn for (n, (s, r))-CFF were given in [11,10,12,23] which give better query complexities, but still, the above algorithms have exponential time complexity O( ( n r )",
      "startOffset" : 102,
      "endOffset" : 115
    }, {
      "referenceID" : 17,
      "context" : "claim in [19] that they have a polynomial time algorithm that constructs an (n, (s, r))-CFF of optimal size.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 25,
      "context" : ", [27,28], gave several randomized non-adaptive algorithms.",
      "startOffset" : 2,
      "endOffset" : 9
    }, {
      "referenceID" : 10,
      "context" : "We first use their ideas combined with the constructions of (n, (r, s))-CFF in [11,10,12,23] to give a new non-adaptive algorithm that asks N(s, r) log n queries and runs in poly(n,N(s, r)) time.",
      "startOffset" : 79,
      "endOffset" : 92
    }, {
      "referenceID" : 9,
      "context" : "We first use their ideas combined with the constructions of (n, (r, s))-CFF in [11,10,12,23] to give a new non-adaptive algorithm that asks N(s, r) log n queries and runs in poly(n,N(s, r)) time.",
      "startOffset" : 79,
      "endOffset" : 92
    }, {
      "referenceID" : 21,
      "context" : "We first use their ideas combined with the constructions of (n, (r, s))-CFF in [11,10,12,23] to give a new non-adaptive algorithm that asks N(s, r) log n queries and runs in poly(n,N(s, r)) time.",
      "startOffset" : 79,
      "endOffset" : 92
    }, {
      "referenceID" : 22,
      "context" : "[24] N(s, r) · (r logn/ log(s logn)) ( n r )",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 17,
      "context" : "[19] N(s, r) log n ( n r+s )",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[11,10,12,23] N(s, r) logn ( n r )",
      "startOffset" : 0,
      "endOffset" : 13
    }, {
      "referenceID" : 9,
      "context" : "[11,10,12,23] N(s, r) logn ( n r )",
      "startOffset" : 0,
      "endOffset" : 13
    }, {
      "referenceID" : 21,
      "context" : "[11,10,12,23] N(s, r) logn ( n r )",
      "startOffset" : 0,
      "endOffset" : 13
    }, {
      "referenceID" : 25,
      "context" : "Ours+[27,28]+[12] N(s, r) log n poly(n,N(s, r)) Ours N(s, r) logn (n logn) · poly(N(s, r)) Ours, r = o(s) N(s, r) logn (n logn) ·N(s, r) Lower Bound [20] N(s, r) log n (n logn) ·N(s, r)",
      "startOffset" : 5,
      "endOffset" : 12
    }, {
      "referenceID" : 18,
      "context" : "Ours+[27,28]+[12] N(s, r) log n poly(n,N(s, r)) Ours N(s, r) logn (n logn) · poly(N(s, r)) Ours, r = o(s) N(s, r) logn (n logn) ·N(s, r) Lower Bound [20] N(s, r) log n (n logn) ·N(s, r)",
      "startOffset" : 149,
      "endOffset" : 153
    }, {
      "referenceID" : 0,
      "context" : "Recall that every monotone boolean function f has a unique representation as a reduced monotone DNF, [1].",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 0,
      "context" : "Notice that every monotone DNF can be uniquely determined by its minterms [1].",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 20,
      "context" : "An (n, (s, r))-cover free family ((n, (s, r))-CFF), [22], is a set A ⊆ {0, 1} such that for every 1 ≤ i1 < i2 < · · · < id ≤ n where d = s + r and every J ⊆ [d] of size |J | = s there is a ∈ A such that aik = 0 for all k ∈ J and aij = 1 for all j ∈ [d]\\J .",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 28,
      "context" : "The lower bound in [31,29] is",
      "startOffset" : 19,
      "endOffset" : 26
    }, {
      "referenceID" : 26,
      "context" : "The lower bound in [31,29] is",
      "startOffset" : 19,
      "endOffset" : 26
    }, {
      "referenceID" : 10,
      "context" : "It follows from [11,10,12,23] that there is a polynomial time (in the size of the CFF) deterministic construction of (n, (s, r))-CFF of size",
      "startOffset" : 16,
      "endOffset" : 29
    }, {
      "referenceID" : 9,
      "context" : "It follows from [11,10,12,23] that there is a polynomial time (in the size of the CFF) deterministic construction of (n, (s, r))-CFF of size",
      "startOffset" : 16,
      "endOffset" : 29
    }, {
      "referenceID" : 21,
      "context" : "It follows from [11,10,12,23] that there is a polynomial time (in the size of the CFF) deterministic construction of (n, (s, r))-CFF of size",
      "startOffset" : 16,
      "endOffset" : 29
    }, {
      "referenceID" : 9,
      "context" : "When r = o(s) the construction runs in linear time [10,12].",
      "startOffset" : 51,
      "endOffset" : 58
    }, {
      "referenceID" : 6,
      "context" : "For d ≤ q we say that H is an (n, q, d)-perfect hash family ((n, q, d)-PHF) [7] if for every subset S ⊆ [n] of size |S| = d there is a hash function h ∈ H such that h|S is injective (one-to-one) on S, i.",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 9,
      "context" : "In [10] Bshouty shows Lemma 1.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 25,
      "context" : "In this section we give the first algorithm that asks N(s, r) log n queries and runs in time poly(n,N(s, r)) The first algorithm is based on the ideas in [27,28] that were used to give a Monte Carlo randomized algorithm.",
      "startOffset" : 154,
      "endOffset" : 161
    }, {
      "referenceID" : 10,
      "context" : "Constructing a (n, (1, r))-CFF of size |A| = r logn and a (n, (s− 1, r))CFF of size |B| = N(s−1, r) logn = N(s, r) logn takes poly(n,N(s, r)) time [11,10,12,23].",
      "startOffset" : 147,
      "endOffset" : 160
    }, {
      "referenceID" : 9,
      "context" : "Constructing a (n, (1, r))-CFF of size |A| = r logn and a (n, (s− 1, r))CFF of size |B| = N(s−1, r) logn = N(s, r) logn takes poly(n,N(s, r)) time [11,10,12,23].",
      "startOffset" : 147,
      "endOffset" : 160
    }, {
      "referenceID" : 21,
      "context" : "Constructing a (n, (1, r))-CFF of size |A| = r logn and a (n, (s− 1, r))CFF of size |B| = N(s−1, r) logn = N(s, r) logn takes poly(n,N(s, r)) time [11,10,12,23].",
      "startOffset" : 147,
      "endOffset" : 160
    } ],
    "year" : 2015,
    "abstractText" : "We give a new deterministic algorithm that non-adaptively learns a hidden hypergraph from edge-detecting queries. All previous non-adaptive algorithms either run in exponential time or have nonoptimal query complexity. We give the first polynomial time non-adaptive learning algorithm for learning hypergraph that asks almost optimal number of queries.",
    "creator" : "LaTeX with hyperref package"
  }
}