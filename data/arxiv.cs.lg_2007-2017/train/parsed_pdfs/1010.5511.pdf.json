{
  "name" : "1010.5511.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Efficient Minimization of Decomposable Submodular Functions",
    "authors" : [ "Peter Stobbe", "Andreas Krause" ],
    "emails" : [ "stobbe@caltech.edu", "krausea@caltech.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Convex optimization has become a key tool in many machine learning algorithms. Many seemingly multimodal optimization problems such as nonlinear classification, clustering and dimensionality reduction can be cast as convex programs. When minimizing a convex loss function, we can rest assured to efficiently find an optimal solution, even for large problems. Convex optimization is a structural property of continuous optimization problems. However, many machine learning problems, such as structure learning, variable selection, MAP inference in discrete graphical models, require solving discrete, combinatorial optimization problems.\nIn recent years, another fundamental problem structure, which has similar beneficial properties, has emerged as very useful in many combinatorial optimization problems arising in machine learning: Submodularity is an intuitive diminishing returns property, stating that adding an element to a smaller set helps more than adding it to a larger set. Similarly to convexity, submodularity allows one to efficiently find provably (near-)optimal solutions. In particular, the minimum of a submodular function can be found in strongly polynomial time [11]. Unfortunately, while polynomial-time solvable, exact techniques for submodular minimization require a number of function evaluations on the order of n5 [12], where n is the number of variables in the problem (e.g., number of random variables in the MAP inference task), rendering the algorithms impractical for many real-world problems.\nFortunately, several submodular minimization problems arising in machine learning have structure that allows solving them more efficiently. Examples include symmetric functions that can be solved in O(n3) evaluations using Queyranne’s algorithm [19], and functions that decompose into attractive, pairwise potentials, that can be solved using graph cutting techniques [7]. In this paper, we introduce a novel class of submodular minimization problems that can be solved efficiently. In particular, we develop an algorithm SLG, that can minimize a class of submodular functions that we call decomposable: These are functions that can be decomposed into sums of concave functions applied to modular (additive) functions. Our algorithm is based on recent techniques of smoothed convex minimization [18] applied to the Lovász extension. We demonstrate the usefulness of\nar X\niv :1\n01 0.\n55 11\nv1 [\ncs .L\nG ]\n2 6\nO ct\nour algorithm on a joint classification-and-segmentation task involving tens of thousands of variables, and show that it outperforms state-of-the-art algorithms for general submodular function minimization by several orders of magnitude."
    }, {
      "heading" : "2 Background on Submodular Function Minimization",
      "text" : "We are interested in minimizing set functions that map subsets of some base set E to real numbers. I.e., given f : 2E → R we wish to solve for A∗ ∈ arg minA f(A). For simplicity of notation, we use the base set E = {1, . . . n}, but in an application the base set may consist of nodes of a graph, pixels of an image, etc. Without loss of generality, we assume f(∅) = 0. If the function f has no structure, then there is no way solve the problem other than checking all 2n subsets. In this paper, we consider functions that satisfy a key property that arises in many applications: submodularity (c.f., [16]). A set function f is called submodular iff, for all A,B ∈ 2E , we have\nf(A ∪B) + f(A ∩B) ≤ f(A) + f(B). (1) Submodular functions can alternatively, and perhaps more intuitively, be characterized in terms of their discrete derivatives. First, we define ∆kf(A) = f(A∪{k})−f(A) to be the discrete derivative of f with respect to k ∈ E at A; intuitively this is the change in f ’s value by adding the element k to the set A. Then, f is submodular iff:\n∆kf(A) ≥ ∆kf(B), for all A ⊆ B ⊆ E and k ∈ E \\B. Note the analogy to concave functions; the discrete derivative is smaller for larger sets, in the same way that φ(x+h)−φ(x) ≥ φ(y+h)−φ(y) for all x ≤ y, h ≥ 0 if and only if φ is a concave function on R. Thus a simple example of a submodular function is f(A) = φ(|A|) where φ is any concave function. Yet despite this connection to concavity, it is in fact ‘easier’ to minimize a submodular function than to maximize it1, just as it is easier to minimize a convex function. One explanation for this is that submodular minimization can be reformulated as a convex minimization problem.\nTo see this, consider taking a set function minimization problem, and reformulating it as a minimization problem over the unit cube [0, 1]n ⊂ Rn. Define eA ∈ Rn to be the indicator vector of the set A, i.e.,\neA[k] = { 0 if k /∈ A 1 if k ∈ A\nWe use the notation x[k] for the kth element of the vector x. Also we drop brackets and commas in subscripts, so ekl = e{k,l} and ek = e{k} as with the standard unit vectors. A continuous extension of a set function f is a function f̃ on the unit cube f̃ : [0, 1]n → R with the property that f(A) = f̃(eA). In order to be useful, however, one needs the minima of the set function to be related to minima of the extension:\nA∗ ∈ arg min A∈2E f(A)⇒ eA∗ ∈ arg min x∈[0,1]n f̃(x). (2)\nA key result due to Lovász [16] states that each submodular function f has an extension f̃ that not only satisfies the above property, but is also convex and efficient to evaluate. We can define the Lovász extension in terms of the submodular polyhedron Pf :\nPf = {v ∈ Rn : v · eA ≤ f(A), for all A ∈ 2E}, f̃(x) = sup v∈Pf v · x.\nThe submodular polyhedron Pf is defined by exponentially many inequalities, and evaluating f̃ requires solving a linear program over this polyhedron. Perhaps surprisingly, as shown by Lovász, f̃ can be very efficiently computed as follows. For a fixed x let σ : E → E be a permutation such that x[σ(1)] ≥ . . . ≥ x[σ(n)], and then define the set Sk = {σ(1), . . . , σ(k)}. Then we have a formula for f̃ and a subgradient:\nf̃(x) = n∑ k=1 x[σ(k)](f(Sk)− f(Sk−1)), ∂f̃(x) 3 n∑ k=1 eσ(k)(f(Sk)− f(Sk−1)).\nNote that if two components of x are equal, the above formula for f̃ is independent of the permutation chosen, but the subgradient is not unique.\n1With the additional assumption that f is nondecreasing, maximizing a submodular function subject to a cardinality constraint |A| ≤M is ‘easy’; a greedy algorithm is known to give a near-optimal answer [17].\nEquation (2) was used to show that submodular minimization can be achieved in polynomial time [16]. However, algorithms which directly minimize the Lovasz extension are regarded as impractical. Despite being convex, the Lovász extension is non-smooth, and hence a simple subgradient descent algorithm would need O(1/ 2) steps to achieve O( ) accuracy.\nRecently, Nesterov showed that if knowledge about the structure of a particular non-smooth convex function is available, it can be exploited to achieve a running time of O(1/ ) [18]. One way this is done is to construct a smooth approximation of the non-smooth function, and then use an accelerated gradient descent algorithm which is highly effective for smooth functions. Connections of this work with submodularity and combinatorial optimization are also explored in [4] and [2]. In fact, in [2], Bach shows that computing the smoothed Lovász gradient of a general submodular function is equivalent to solving a submodular minimization problem. In this paper, we do not treat general submodular functions, but rather a large class of submodular minimization functions that we call decomposable. (To apply the smoothing technique of [18], special structural knowledge about the convex function is required, so it is natural that we would need special structural knowledge about the submodular function to leverage those results.) We further show that we can exploit the discrete structure of submodular minimization in a way that allows terminating the algorithm early with a certificate of optimality, which leads to drastic performance improvements."
    }, {
      "heading" : "3 The Decomposable Submodular Minimization Problem",
      "text" : "In this paper, we consider the problem of minimizing functions of the following form: f(A) = c · eA + ∑ j φj(wj · eA), (3)\nwhere c,wj ∈ Rn and 0 ≤ wj ≤ 1 and φj : [0,wj · 1] → R are arbitrary concave functions. It is shown in the Appendix that functions of this form are submodular. We call this class of functions decomposable submodular functions, as they decompose into a sum of concave functions applied to nonnegative modular functions2. Below, we give examples of decomposable submodular functions arising in applications.\nWe first focus on the special case where all the concave functions are of the form φj(·) = dj min(yj , ·) for some yj , dj > 0. Since these potentials are of key importance, we define the submodular functions Ψw,y(A) = min(y,w · eA) and call them threshold potentials. In Section 5, we will show in how to generalize our approach to arbitrary decomposable submodular functions.\nExamples. The simplest example is a 2-potential, which has the form φ(|A∩{k, l}|), where φ(1)− φ(0) ≥ φ(1)− φ(2). It can be expressed as a sum of a modular function and a threshold potential:\nφ(|A ∩ {k, l}|) = φ(0) + (φ(2)− φ(1))ekl · eA + (2φ(1)− φ(0)− φ(2))Ψekl,1(A) Why are such potential functions interesting? They arise, for example, when finding the Maximum a Posteriori configuration of a pairwise Markov Random Field model in image classification schemes such as in [20]. On a high level, such an algorithm computes a value c[k] that corresponds to the log-likelihood of pixel k being of one class vs. another, and for each pair of adjacent pixels, a value dkl related to the log-likelihood that pixels k and l are of the same class. Then the algorithm classifies pixels by minimizing a sum of 2-potentials: f(A) = c ·eA + ∑ k,l dkl(1− |1−ekl ·eA|). If the value dkl is large, this encourages the pixels k and l to be classified similarly.\nMore generally, consider a higher order potential function: a concave function of the number of elements in some activation set S, φ(|A ∩ S|) where φ is concave. It can be shown that this can be written as a sum of a modular function and a positive linear combination of |S| − 1 threshold potentials. Recent work [14] has shown that classification performance can be improved by adding terms corresponding to such higher order potentials φj(|Rj∩A|) to the objective function where the functions φj are piecewise linear concave functions, and the regions Rj of various sizes generated from a segmentation algorithm. Minimization of these particular potential functions can then be reformulated as a graph cut problem [13], but this is less general than our approach.\nAnother canonical example of a submodular function is a set cover function. Such a function can be reformulated as a combination of concave cardinality functions (details in appendix). So all\n2A function is called modular if (1) holds with equality. It can be written as A 7→ w ·eA for some w ∈ Rn.\nfunctions which are weighted combinations of set cover functions can be expressed as threshold potentials. However, threshold potentials with nonuniform weights are strictly more general than concave cardinality potentials. That is, there existsw and y such that Ψw,y(A) cannot be expressed as ∑ j φj(|Rj ∩A|) for any collection of concave φj and sets Rj .\nAnother example of decomposable functions arises in multiclass queuing systems [10]. These are of the form f(A) = c · eA + u · eAφ(v · eA), where u,v are nonnegative weight vectors and φ is a nonpositive nonincreasing concave function. With the proper choice of φj and wj (again details are in appendix), this can in fact be reformulated as sum of the type in Eq. 3 with n terms.\nIn our own experiments, shown in Section 6, we use an implementation of TextonBoost [20] and augment it with quadratic higher order potentials. That is, we use TextonBoost to generate per-pixel scores c, and then minimize f(A) = c ·eA+ ∑ j |A∩Rj ||Rj \\A|, where the regionsRj are regions of pixels that we expect to be of the same class (e.g., by running a cheap region-growing heuristic). The potential function |A∩Rj ||Rj\\A| is smallest whenA contains all ofRj or none of it. It gives the largest penalty when exactly half of Rj is contained in A. This encourages the classification scheme to classify most of the pixels in a region Rj the same way. We generate regions with a basic regiongrowing algorithm with random seeds. See Figure 1(a) for an illustration of examples of regions that we use. In our experience, this simple idea of using higher-order potentials can dramatically increase the quality of the classification over one using only 2-potentials, as can be seen in Figure 2.\n4 The SLG Algorithm for Threshold Potentials We now present our algorithm for efficient minimization of a decomposable submodular function f based on smoothed convex minimization. We first show how we can efficiently smooth the Lovász extension of f . We then apply accelerated gradient descent to the gradient of the smoothed function. Lastly, we demonstrate how we can often obtain a certificate of optimality that allows us to stop early, drastically speeding up the algorithm in practice."
    }, {
      "heading" : "4.1 The Smoothed Extension of a Threshold Potential",
      "text" : "The key challenge in our algorithm is to efficiently smooth the Lovász extension of f , so that we can resort to algorithms for accelerated convex minimization. We now show how we can efficiently smooth the threshold potentials Ψw,y(A) = min(y,w · eA) of Section 3, which are simple enough to allow efficient smoothing, but rich enough when combined to express a large class of submodular functions. For x ≥ 0, the Lovász extension of Ψw,y is Ψ̃w,y(x) = supv · x s.t. v ≤ w,v · eA ≤ y for all A ∈ 2E . Note that when x ≥ 0, the arg max of the above linear program always contains a point v which satisfies v · 1 = y, and v ≥ 0. So we can restrict the domain of the dual variable v to those points which satisfy these two conditions, without changing the value of Ψ̃(x):\nΨ̃w,y(x) = max v∈D(w,y)\nv · x where D(w, y) = {v : 0 ≤ v ≤ w,v · 1 = y}.\nRestricting the domain of v allows us to define a smoothed Lovász extension (with parameter µ) that is easily computed:\nΨ̃µw,y(x) = max v∈D(w,y) v · x− µ 2 ‖v‖2\nTo compute the value of this function we need to solve for the optimal vector v∗, which is also the gradient of this function, as we have the following characterization:\n∇Ψ̃µw,y(x) = arg max v∈D(w,y) v · x− µ 2 ‖v‖2 = arg min v∈D(w,y) ∥∥∥∥xµ − v ∥∥∥∥ . (4)\nTo derive an expression for v∗, we begin by forming the Lagrangian and deriving the dual problem:\nΨ̃µw,y(x) = min t∈R,λ1,λ2≥0 ( max v∈Rn v · x− µ 2 ‖v‖2 + λ1 · v + λ2 · (w − v) + t(y − v · 1) ) = min\nt∈R,λ1,λ2≥0\n1\n2µ ‖x− t1 + λ1 − λ2‖2 + λ2 ·w + ty.\nIf we fix t, we can solve for the optimal dual variables λ∗1 and λ ∗ 2 componentwise. By strong duality, we know the optimal primal variable is given by v∗ = 1µ (x− t ∗1 + λ∗1 − λ∗2). So we have: λ∗1 = max(t ∗1− x,0), λ∗2 = max(x− t∗1− µw,0)⇒ v∗ = min (max ((x− t∗1)/µ,0) ,w) .\nThis expresses v∗ as a function of the unknown optimal dual variable t∗. For the simple case of 2-potentials, we can solve for t∗ explicitly and get a closed form expression:\n∇Ψ̃µekl,1(x) =  ek if x[k] ≥ x[l] + µ el if x[l] ≥ x[k] + µ 1 2 (ekl + 1 µ (x[k]− x[l])(ek − el)) if |x[k]− x[l]| < µ\nHowever, in general to find t∗ we note that v∗ must satisfy v∗ · 1 = y. So define ρµx,w(t) as:\nρµx,w(t) = min(max((x− t1)/µ,0),w) · 1 Then we note this function is a monotonic continuous piecewise linear function of t, so we can use a simple root-finding algorithm to solve ρµx,w(t\n∗) = y. This root finding procedure will take no more than O(n) steps in the worst case.\n4.2 The SLG Algorithm for Minimizing Sums of Threshold Potentials Stepping beyond a single threshold potential, we now assume that the submodular function to be minimized can be written as a nonnegative linear combination of threshold potentials and a modular function, i.e.,\nf(A) = c · eA + ∑ j djΨwj ,yj (A).\nThus, we have the smoothed Lovász extension, and its gradient: f̃µ(x) = c · x+ ∑ j djΨ̃ µ wj ,yj (x) and∇f̃ µ(x) = c+ ∑ j dj∇Ψ̃µwj ,yj (x).\nWe now wish to use the accelerated gradient descent algorithm of [18] to minimize this function. This algorithm requires that the smoothed objective has a Lipschitz continuous gradient. That is, for some constant L, it must hold that ‖∇f̃µ(x1) − ∇f̃µ(x2)‖ ≤ L‖x1 − x2‖, for all x1,x2 ∈ Rn. Fortunately, by construction, the smoothed threshold extensions Ψ̃µwj ,yj (x) all have 1/µ Lipschitz gradient, a direct consequence of the characterization in Equation 4. Hence we have a loose upper bound for the Lipschitz constant of f̃µ: L ≤ Dµ , where D = ∑ j dj . Furthermore, the smoothed threshold extensions approximate the threshold extensions uniformly: |Ψ̃µwj ,yj (x)− Ψ̃wj ,yj (x)| ≤ µ 2 for all x, so |f̃ µ(x)− f̃(x)| ≤ µD2 .\nOne way to use the smoothed gradient is to specify an accuracy ε, then minimize f̃µ for sufficiently small µ to guarantee that the solution will also be an approximate minimizer of f̃ . Then we simply apply the accelerated gradient descent algorithm of [18]. See also [3] for a description. Let PC(x) = arg minx′∈C ‖x − x′‖ be the projection of x onto the convex set C. In particular, P[0,1]n(x) = min(max(x,0),1). Algorithm 1 formalizes our Smoothed Lovász Gradient (SLG) algorithm:\nAlgorithm 1: SLG: Smoothed Lovász Gradient Input: Accuracy ε; decomposable function f . begin\nµ = ε2D , L = D µ , x−1 = z−1 = 1 21; for t = 0, 1, 2, . . . do gt = ∇f̃µ(xt−1)/L; zt = P[0,1]n ( z−1 − ∑t s=0 ( s+1 2 ) gs ) ; yt = P[0,1]n(xt − gt);\nif gapt ≤ ε/2 then stop; xt = (2zt + (t+ 1)yt)/(t+ 3);\nxε = yt; Output: ε-optimal xε to minx∈[0,1]n f̃(x)\nThe optimality gap of a smooth convex function at the iterate yt can be computed from its gradient:\ngapt = max x∈[0,1]n (yt − x) · ∇f̃µ(yt) = yt · ∇f̃µ(yt) + max(−∇f̃µ(yt),0) · 1.\nIn summary, as a consequence of the results of [18], we have the following guarantee about SLG:\nTheorem 1 SLG is guaranteed to provide an ε-optimal solution after running forO(Dε ) iterations.\nSLG is only guaranteed to provide an ε-optimal solution to the continuous optimization problem. Fortunately, once we have an ε-optimal point for the Lovász extension, we can efficiently round it to set which is ε-optimal for the original submodular function using Alg. 2 (see [9] for more details).\nAlgorithm 2: Set generation by rounding the continuous solution Input: Vector x ∈ [0, 1]n; submodular function f . begin\nBy sorting, find any permutation σ satisfying: x[σ(1)] ≥ . . . ≥ x[σ(n)]; Sk = {σ(1), . . . , σ(k)}; K∗ = arg mink∈{0,1,...,n} f(Sk); C = {Sk : k ∈ K∗};\nOutput: Collection of sets C, such that f(A) ≤ f̃(x) for all A ∈ C"
    }, {
      "heading" : "4.3 Early Stopping based on Discrete Certificates of Optimality",
      "text" : "In general, if the minimum of f is not unique, the output of SLG may be in the interior of the unit cube. However, if f admits a unique minimum A∗, then the iterates will tend toward the corner eA∗ . One natural question one may ask, if a trend like this is observed, is it necessary to wait for the iterates to converge all the way to the optimal solution of the continuous problem minx∈[0,1]n f̃(x), when one is actually iterested in solving the discrete problem minA∈2E f(A)? Below, we show that it is possible to use information about the current iterates to check optimality of a set and terminate the algorithm before the continuous problem has converged.\nTo prove optimality of a candidate set A, we can use a subgradient of f̃ at eA. If g ∈ ∂f̃(eA), then we can compute an optimality gap:\nf(A)− f∗ ≤ max x∈[0,1]n (eA − x) · g = ∑ k∈A max(0, g[k](eA[k]− eE\\A[k])). (5)\nIn particular if g[k] ≤ 0 for k ∈ A and g[k] ≥ 0 for k ∈ E \\ A, then A is optimal. But if we only have knowledge of candidate set A, then finding a subgradient g ∈ ∂f̃(eA) which demonstrates optimality may be extremely difficult, as the set of subgradients is a polyhedron with exponentially many extreme points. But our algorithm naturally suggests the subgradient we could use; the gradient of the smoothed extension is one such subgradient – provided a certain condition is satisfied, as described in the following Lemma.\nLemma 1 Suppose f is a decomposable submodular function, with Lovász extension f̃ , and smoothed extension f̃µ as in the previous section. Suppose x ∈ Rn and A ∈ 2E satisfy the following property:\nmin k∈A,l∈E\\A x[k]− x[l] ≥ 2µ Then ∇f̃µ(x) ∈ ∂f̃(eA) This is a consequence of our formula for∇Ψ̃µ, but see the appendix for a detailed proof. Lemma 1 states that if the components of point x corresponding to elements of A are all larger than all the other components by at least 2µ, then the gradient at x is a subgradient for f̃ at eA (which by Equation 5 allows us to compute an optimality gap). In practice, this separation of components naturally occurs as the iterates move in the direction of the point eA, long before they ever actually reach the point eA. But even if the components are not separated, we can easily add a positive multiple of eA to separate them and then compute the gradient there to get an optimality gap. In summary, we have the following algorithm to check the optimality of a candidate set: Of critical\nAlgorithm 3: Set Optimality Check Input: Set A; decomposable function f ; scale µ; x ∈ Rn. begin\nγ = 2µ+ maxk∈A,l∈E\\A x[l]− x[k]; g = ∇f̃µ(x+ γeA); gap = ∑ k∈A max(0, g[k](eA[k]− eE\\A[k]));\nOutput: gap, which satisfies gap ≥ f(A)− f∗\nimportance is how to choose the candidate set A. But by Equation 5, for a set to be optimal, we want the components of the gradient ∇f̃µ(A + γeA)[k] to be negative for k ∈ A and positive for k ∈ E \\ A. So it is natural to choose A = {k : ∇f̃µ(x)[k] ≤ 0}. Thus, if adding γeA does not change the signs of the components of the gradient, then in fact we have found the optimal set. This stopping criterion is very effective in practice, and we use it in all of our experiments."
    }, {
      "heading" : "5 Extension to General Concave Potentials",
      "text" : "To extend our algorithm to work on general concave functions, we note that an arbitrary concave function can be expressed as an integral of threshold potential functions. This is a simple consequence of integration by parts, which we state in the following lemma:\nLemma 2 For φ ∈ C2([0, T ]), φ(x) = φ(0) + φ′(T )x− ∫ T 0 min(x, y)φ′′(y)dy, ∀x ∈ [0, T ]\nThis means that for a general sum of concave potentials as in Equation (3), we have:\nf(A) = c · eA + ∑ j ( φj(0) + φ ′(wj · 1)wj · eA − ∫ wj ·1 0 Ψwj ,y(A)φ ′′ j (y)dy ) .\nThen we can define f̃ and f̃µ by replacing Ψ with Ψ̃ and Ψ̃µ respectively. Our SLG algorithm is essentially unchanged, the conditions for optimality still hold, and so on. Conceptually, we just use a different smoothed gradient, but calculating it is more involved. We need to compute the integrals of the form ∫ ∇Ψ̃µw,y(x)φ′′(y)dy. Since ∇Ψ̃µw,y(x) is a piecewise linear function with repect to y which we can compute, we can evaluate the integral by parts so that we need only evaluate φ, but not its derivatives. We leave this formula for the appendix."
    }, {
      "heading" : "6 Experiments",
      "text" : "Synthetic Data. We reproduce the experimental setup of [8] designed to compare submodular minimization algorithms. Our goal is to find the minimum cut of a randomly generated graph (which requires submodular minimization of a sum of 2-potentials) with the graph generated by the specifications in [1]. We compare against the state of the art combinatorial algorithms (LEX2, HYBRID, SFM3, PR [6]) that are guaranteed to find the exact solution in polynomial time, as well as the Minimum Norm algorithm of [8], a practical alternative with unknown running time. Figures 1(b) and 1(c) compare the running time of SLG against the running times reported in [8]. In some cases, SLG was 6 times faster than the MinNorm algorithm. However the comparison to the MinNorm algorithm is inconclusive in this experiment, since while we used a faster machine, we also used a simple MATLAB implementation. What is clear is that SLG scales at least as well as MinNorm on these problems, and is practical for problem sizes that the combinatorial algorithms cannot handle.\nImage Segmentation Experiments. We also tested our algorithm on the joint image segmentation-and-classification task introduced in Section 3. We used an implementation of TextonBoost [20], then trained on and tested subsampled images from [5]. As seen in Figures 2(e) and 2(g), using only the per-pixel score from our TextonBoost implementation gets the general area of the object, but does not do a good job of identifying the shape of a classified object. Compare to the ground truth in Figures 2(b) and 2(d). We then perform MAP inference in a Markov Random Field with 2-potentials (as done in [20]). While this regularization, as shown in Figures 2(f) and 2(h), leads to improved performance, it still performs poorly on classifying the boundary.\nFinally, we used SLG to regularize with higher order potentials. To generate regions for our potentials, we randomly picked seed pixels and grew the regions based on HSV channels of the image. We picked our seed pixels with a preference for pixels which were included in the least number of previously generated regions. Figure 1(a) shows what the regions typically looked like. For our experiments, we used 90 total regions. We used SLG to minimize f(A) = c·eA+ ∑ j |A∩Rj ||Rj\\A|, where c was the output from TextonBoost, scaled appropriately. Figures 2(i) and 2(k) show the classification output. The continuous variables x at the end of each run are shown in Figures 2(j) and 2(l); while it has no formal meaning, in general one can interpret a very high or low value of x[k] to correspond to high confidence in the classification of the pixel k. To generate the result shown in Figure 2(k), a problem with 104 variables and 90 concave potentials, our MATLAB/mex implementation of SLG took 71.4 seconds. In comparison, the MinNorm implementation of the SFO toolbox [15] gave the same result, but took 6900 seconds. Similar problems on an image of twice the resolution (4× 104 variables) were tested using SLG, resulting in a runtimes of roughly 1600 seconds."
    }, {
      "heading" : "7 Conclusion",
      "text" : "We have developed a novel method for efficiently minimizing a large class of submodular functions of practical importance. We do so by decomposing the function into a sum of threshold potentials, whose Lovász extensions are convenient for using modern smoothing techniques of convex optimization. This allows us to solve submodular minimization problems with thousands of variables, that cannot be expressed using only pairwise potentials. Thus we have achieved a middle ground between graph-cut-based algorithms which are extremely fast but only able to handle very specific types of submodular minimization problems, and combinatorial algorithms which assume nothing but submodularity but are impractical for large-scale problems.\nAcknowledgements This research was partially supported by NSF grant IIS-0953413, a gift from Microsoft Corporation and an Okawa Foundation Research Grant. Thanks to Alex Gittens and Michael McCoy for use of their TextonBoost implementation."
    }, {
      "heading" : "A Submodularity of Decomposable Functions",
      "text" : "Since the sum of submodular functions is submodular, we need only prove that the submodularity of f(A) = φ(w · eA), where φ is an arbitrary concave function on R and w ≥ 0. By definition of concavity, for all θ ∈ [0, 1], we have:\nφ(θ(y + h) + (1− θ)x) + φ((1− θ)(y + h) + θx) ≥ φ(y + h) + φ(x) If x ≤ y and h ≥ 0, then setting θ = h/(y − x+ h) in the above gives us:\nφ(x+ h)− φ(x) ≥ φ(y + h)− φ(y) (6) Then, for all k ∈ E \\A, we compute the the discrete derivative ∆kf(A): ∆kf(A) = φ(w · eA +w[k])− φ(w · eA) (7) So if A ⊆ B ⊆ E and k ∈ E \\B, thenw · eA ≤ w · eB , so by Eqs. 6 and 7, ∆kf(A) ≥ ∆kf(B), and hence f is submodular."
    }, {
      "heading" : "B Reformulation of Set Cover Functions",
      "text" : "A set cover function can be formulated as the function: f(A) = |∪i∈ABi|\nWhere Bi are subsets of some base set F , and the Bi form some collection of subsets indexed by E. For every k ∈ F , we define the vectors wk ∈ R|E| as follows:\nwk[i] = { 0 k /∈ Bi 1 k ∈ Bi\nWe claim: f(A) = ∑ k∈F min(1,wk · eA) The kth term in the sum equals 1 if k ∈ Bi for some i ∈ A and 0 otherwise. The sum of all such terms will give the cardinality of the union of the Bi with i ∈ A, which is exactly the set cover function."
    }, {
      "heading" : "C Strict Generality of Threshold Potentials",
      "text" : "As mentioned in the text, any concave cardinality function can be decomposed into the sum of several threshold potentials. This is effectively the discrete version of Lemma 2:\nφ(|A ∩ S|) = φ(0) + (φ(|S|)− φ(|S| − 1))eS · eA + |S|−1∑ k=1 (2φ(k)− φ(k − 1)− φ(k + 1)) min(k, eS · eA)\nSince φ is concave, the coefficients (2φ(k) − φ(k − 1) − φ(k + 1)) are nonnegative. So without loss of generality, any sum of concave cardinality functions can be expressed as a sum of a modular function and nonnegative linear combination of threshold potentials:∑\nj\nφj(|Rj ∩A|) = c · eA + ∑\nSk⊂E,|S|>1\n|S|−1∑ k=1 dkl min(k, eSk · eA)\nThere are ∑ m=2 ( n m ) (m − 1) coefficients dkl and they all must be nonnegative. So to check if a submodular function f(A) can be expressed as such a sum, we can just write out the 2n constraints for each subset:\nf(A) = c · eA + ∑\nSk⊂E,|S|>1\n|S|−1∑ k=1 dkl min(k, eSk · eA) for all A ∈ 2E (8)\nIf n = 4, we have 24 linear constraints, 4 unconstrained variables from c, and 19 nonnegative variables dkl. This is small enough that one can check for feasibility using a linear algebra package. We discovered that simple threshold potential f(A) = min(y,w · eA) with w = [1, 2, 3, 4]/4 and y = 1 does not have a feasible solution to Eq. 8."
    }, {
      "heading" : "D Reformulation of a Class of Functions",
      "text" : "Another example of decomposable functions are the problems under consideration in [10], which are of the following form:\nf(A) = c · eA + (u · eA)φ(v · eA)\nWhere u,v are nonnegative weight vectors and φ is a nonincreasing concave function. Suppose we can choose vectors wj and concave φ̃ to satisfy:\nφ̃(wj · eA) = {\n0 if j /∈ A φ(v · eA)− φ(0) if j ∈ A\n(9)\nThen we claim the following is an equivalent formulation for f in decomposable form:\nf ′(A) = (c+ φ(0)u) · eA + n∑ j=1 u[j]φ̃(wj · eA) (10)\nIndeed, plugging Eq. 9 to the above gives: f ′(A) = (c+ φ(0)u) · eA + ∑ j∈A u[j](φ(v · eA)− φ(0)) = f(A)\nTo satisfy Eq. 9 we define φ̃ as follows:\nφ̃(t) = { 0 if t ≤ 1 · v φ(t− 1 · v)− φ(0) if t > 1 · v\nAnd let wj = v + (1 · v)ej . It is straightforward to check that these definitions satisfy Eq. 9. Note φ̃ is concave because φ is nonincreasing concave. Incidentally, the decomposition in Eq. 10 proves that f is submodular."
    }, {
      "heading" : "E Proof of Lemma 1",
      "text" : "By linearity, it is sufficient to consider the case f = Ψµw,y . First we claim that if the hypothesis of the Lemma holds, adding a positive multiple of eA will not change the gradient. That is, ∇Ψ̃µw,y(x) = ∇Ψ̃µw,y(x+ αeA) for α > 0. Recall the formula for the gradient:\n∇Ψ̃µw,y(x) = min(max((x− t∗1)/µ,0) where t∗ satisfies min(max((x− t∗1)/µ,0),w) · 1 = y\nConsider the effect of adding αeA to x in this formula; either t∗ is increased by α or it is unchanged; in either case the gradient itself is unchanged. Next, note the following scale relationship which follows directly from the definition of Ψ̃µw,y:\nΨ̃µw,y(αx) = αΨ̃ µ/α w,y (x).\nBut combined with our first observation this implies\n∇Ψ̃µw,y(x) = ∇Ψ̃µ/αw,y (x/α+ eA)\nBut the right-hand side of that equation must converge to a subgradient of the nonsmooth function as α→∞:\nlim α→∞\n∇Ψ̃µ/αw,y (x/α+ eA) ∈ ∂Ψ̃w,y(eA)\nwhich gives the result."
    }, {
      "heading" : "F Proof of Lemma 2",
      "text" : "This is straightforward calculation:∫ T 0 min(x, y)φ′′(y)dy = ∫ x 0 yφ′′(y)dy + ∫ T x xφ′′(y)dy\n= (yφ′(y)− φ(y)) ∣∣x 0 + xφ′(y) ∣∣T x = xφ′(x)− φ(x) + φ(0) + xφ′(T )− xφ′(x) = φ(0) + xφ′(T )− φ(x)\nIntuitively, this is a consequence of integration by parts and the fact that ∂ 2\n∂x2 min(x, y) = −δ(x−y) (the Dirac delta)."
    }, {
      "heading" : "G General Smoothed Gradient Formula",
      "text" : "Let f(A) = φ(w · eA) be a general concave potential. For ease of notation, in the following let g(y) = ∇Ψ̃µw,y(x) be the gradient of the smoothed extension of a threshold potential. Then by Lemma 2, we have this formula for the gradient of smoothed extention of f :\n∇f̃µ(x) = φ′(w · 1)w − ∫ w·1 0 g(y)φ′′(y)dy\nNote that g is a piecewise linear function of y. Let the intervals [yi, yi+1] with 0 = y0 ≤ . . . ≤ yN = w · 1 be the intervals that g is linear on. Let θi = g(yi), so then 0 = θ0 ≤ . . . ≤ θN = w. Finally let gi(y) be the linear functions that g equals on these intervals,:\ng(y) = gi(y) for y ∈ [yi−1, yi]\nDenote by g′i = (θi − θi−1)/(yi − yi−1) the vector which is derivative of gi(y) with respect to y. So then our smoothed gradient can be evaluated:\n∇f̃µ(x) = φ′(yN )w − N∑ i=1 ∫ yi yi−1 gi(y)φ ′′(y)dy\n= φ′(yN )w + N∑ i=1 (g′iφ(y)− gi(y)φ′(y)) ∣∣yi yi−1\n= φ′(yN )w + N∑ i=1 g′i(φ(yi)− φ(yi−1))− N∑ i=1 (θiφ ′(yi)− θi−1φ′(yi−1))\n= N∑ i=1 (g(yi)− g(yi−1))(φ(yi)− φ(yi−1)) yi − yi−1\nNote there are at most 2n points yi, and they can be found all in O(n log n) time, since it requires a sort. So the overall operation count of evaluating this formula is O(n2) since it requires adding up O(n) n-dimensional vectors."
    } ],
    "references" : [ {
      "title" : "Structured sparsity-inducing norms through submodular functions",
      "author" : [ "F. Bach" ],
      "venue" : "Advances in Neural Information Processing Systems ",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Nesta: A fast and accurate first-order method for sparse recovery",
      "author" : [ "S. Becker", "J. Bobin", "E.J. Candes" ],
      "venue" : "Arxiv preprint arXiv 904 ",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Efficient solutions to relaxations of combinatorial problems with submodular penalties via the Lovász extension and non-smooth convex optimization",
      "author" : [ "F.A. Chudak", "K. Nagano" ],
      "venue" : "Proceedings of the eighteenth annual ACM-SIAM symposium on Discrete algorithms, Society for Industrial and Applied Mathematics",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "and A",
      "author" : [ "M. Everingham", "L. Van Gool", "C.K.I. Williams", "J. Winn" ],
      "venue" : "Zisserman, The PASCAL Visual Object Classes Challenge 2009 ",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "A push-relabel framework for submodular function minimization and applications to parametric optimization",
      "author" : [ "L. Fleischer", "S. Iwata" ],
      "venue" : "Discrete Applied Mathematics 131 ",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Energy minimization via graph cuts: Settling what is possible",
      "author" : [ "D. Freedman", "P. Drineas" ],
      "venue" : "IEEE Computer Society Conference on Computer Vision and Pattern Recognition, 2005. CVPR 2005, vol. 2",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "The Minimum-Norm-Point Algorithm Applied to Submodular Function",
      "author" : [ "Satoru Fujishige", "Takumi Hayashi", "Shigueo Isotani" ],
      "venue" : "Minimization and Linear Programming,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2006
    }, {
      "title" : "Beyond convexity: Online submodular minimization, Advances in Neural Information Processing Systems",
      "author" : [ "Elad Hazan", "Satyen Kale" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2009
    }, {
      "title" : "Computational geometric approach to submodular function minimization for multiclass queueing systems",
      "author" : [ "T. Itoko", "S. Iwata" ],
      "venue" : "Integer Programming and Combinatorial Optimization ",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "A combinatorial strongly polynomial algorithm for minimizing submodular functions",
      "author" : [ "S. Iwata", "L. Fleischer", "S. Fujishige" ],
      "venue" : "Journal of the ACM (JACM) 48 ",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "A simple combinatorial algorithm for submodular function minimization",
      "author" : [ "S. Iwata", "J.B. Orlin" ],
      "venue" : "Proceedings of the Nineteenth Annual ACM-SIAM Symposium on Discrete Algorithms, Society for Industrial and Applied Mathematics",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Robust Higher Order Potentials for Enforcing Label Consistency",
      "author" : [ "Pushmeet Kohli", "Lubor Ladický", "Philip H.S. Torr" ],
      "venue" : "International Journal of Computer Vision",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2009
    }, {
      "title" : "SFO: A Toolbox for Submodular Function Optimization",
      "author" : [ "A. Krause" ],
      "venue" : "The Journal of Machine Learning Research 11 ",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Submodular functions and convexity",
      "author" : [ "L. Lovász" ],
      "venue" : "Mathematical programming: the state of the art, Bonn ",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1982
    }, {
      "title" : "An analysis of the approximations for maximizing submodular set functions",
      "author" : [ "G. Nemhauser", "L. Wolsey", "M. Fisher" ],
      "venue" : "Mathematical Programming 14 ",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1978
    }, {
      "title" : "Smooth minimization of non-smooth functions",
      "author" : [ "Yu. Nesterov" ],
      "venue" : "Mathematical Programming",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2004
    }, {
      "title" : "Minimizing symmetric submodular functions",
      "author" : [ "Maurice Queyranne" ],
      "venue" : "Mathematical Programming",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1998
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "In particular, the minimum of a submodular function can be found in strongly polynomial time [11].",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 10,
      "context" : "Unfortunately, while polynomial-time solvable, exact techniques for submodular minimization require a number of function evaluations on the order of n [12], where n is the number of variables in the problem (e.",
      "startOffset" : 151,
      "endOffset" : 155
    }, {
      "referenceID" : 16,
      "context" : "Examples include symmetric functions that can be solved in O(n) evaluations using Queyranne’s algorithm [19], and functions that decompose into attractive, pairwise potentials, that can be solved using graph cutting techniques [7].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 5,
      "context" : "Examples include symmetric functions that can be solved in O(n) evaluations using Queyranne’s algorithm [19], and functions that decompose into attractive, pairwise potentials, that can be solved using graph cutting techniques [7].",
      "startOffset" : 227,
      "endOffset" : 230
    }, {
      "referenceID" : 15,
      "context" : "Our algorithm is based on recent techniques of smoothed convex minimization [18] applied to the Lovász extension.",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 13,
      "context" : ", [16]).",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 13,
      "context" : "A key result due to Lovász [16] states that each submodular function f has an extension f̃ that not only satisfies the above property, but is also convex and efficient to evaluate.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 14,
      "context" : "With the additional assumption that f is nondecreasing, maximizing a submodular function subject to a cardinality constraint |A| ≤M is ‘easy’; a greedy algorithm is known to give a near-optimal answer [17].",
      "startOffset" : 201,
      "endOffset" : 205
    }, {
      "referenceID" : 13,
      "context" : "Equation (2) was used to show that submodular minimization can be achieved in polynomial time [16].",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 15,
      "context" : "Recently, Nesterov showed that if knowledge about the structure of a particular non-smooth convex function is available, it can be exploited to achieve a running time of O(1/ ) [18].",
      "startOffset" : 177,
      "endOffset" : 181
    }, {
      "referenceID" : 2,
      "context" : "Connections of this work with submodularity and combinatorial optimization are also explored in [4] and [2].",
      "startOffset" : 96,
      "endOffset" : 99
    }, {
      "referenceID" : 0,
      "context" : "Connections of this work with submodularity and combinatorial optimization are also explored in [4] and [2].",
      "startOffset" : 104,
      "endOffset" : 107
    }, {
      "referenceID" : 0,
      "context" : "In fact, in [2], Bach shows that computing the smoothed Lovász gradient of a general submodular function is equivalent to solving a submodular minimization problem.",
      "startOffset" : 12,
      "endOffset" : 15
    }, {
      "referenceID" : 15,
      "context" : "(To apply the smoothing technique of [18], special structural knowledge about the convex function is required, so it is natural that we would need special structural knowledge about the submodular function to leverage those results.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 11,
      "context" : "Recent work [14] has shown that classification performance can be improved by adding terms corresponding to such higher order potentials φj(|Rj∩A|) to the objective function where the functions φj are piecewise linear concave functions, and the regions Rj of various sizes generated from a segmentation algorithm.",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 8,
      "context" : "Another example of decomposable functions arises in multiclass queuing systems [10].",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 15,
      "context" : "We now wish to use the accelerated gradient descent algorithm of [18] to minimize this function.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 15,
      "context" : "Then we simply apply the accelerated gradient descent algorithm of [18].",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 1,
      "context" : "See also [3] for a description.",
      "startOffset" : 9,
      "endOffset" : 12
    }, {
      "referenceID" : 15,
      "context" : "In summary, as a consequence of the results of [18], we have the following guarantee about SLG:",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 7,
      "context" : "2 (see [9] for more details).",
      "startOffset" : 7,
      "endOffset" : 10
    }, {
      "referenceID" : 6,
      "context" : "We reproduce the experimental setup of [8] designed to compare submodular minimization algorithms.",
      "startOffset" : 39,
      "endOffset" : 42
    }, {
      "referenceID" : 4,
      "context" : "We compare against the state of the art combinatorial algorithms (LEX2, HYBRID, SFM3, PR [6]) that are guaranteed to find the exact solution in polynomial time, as well as the Minimum Norm algorithm of [8], a practical alternative with unknown running time.",
      "startOffset" : 89,
      "endOffset" : 92
    }, {
      "referenceID" : 6,
      "context" : "We compare against the state of the art combinatorial algorithms (LEX2, HYBRID, SFM3, PR [6]) that are guaranteed to find the exact solution in polynomial time, as well as the Minimum Norm algorithm of [8], a practical alternative with unknown running time.",
      "startOffset" : 202,
      "endOffset" : 205
    }, {
      "referenceID" : 6,
      "context" : "Figures 1(b) and 1(c) compare the running time of SLG against the running times reported in [8].",
      "startOffset" : 92,
      "endOffset" : 95
    }, {
      "referenceID" : 3,
      "context" : "We used an implementation of TextonBoost [20], then trained on and tested subsampled images from [5].",
      "startOffset" : 97,
      "endOffset" : 100
    }, {
      "referenceID" : 12,
      "context" : "In comparison, the MinNorm implementation of the SFO toolbox [15] gave the same result, but took 6900 seconds.",
      "startOffset" : 61,
      "endOffset" : 65
    } ],
    "year" : 2010,
    "abstractText" : "Many combinatorial problems arising in machine learning can be reduced to the problem of minimizing a submodular function. Submodular functions are a natural discrete analog of convex functions, and can be minimized in strongly polynomial time. Unfortunately, state-of-the-art algorithms for general submodular minimization are intractable for larger problems. In this paper, we introduce a novel subclass of submodular minimization problems that we call decomposable. Decomposable submodular functions are those that can be represented as sums of concave functions applied to modular functions. We develop an algorithm, SLG, that can efficiently minimize decomposable submodular functions with tens of thousands of variables. Our algorithm exploits recent results in smoothed convex minimization. We apply SLG to synthetic benchmarks and a joint classification-and-segmentation task, and show that it outperforms the state-of-the-art general purpose submodular minimization algorithms by several orders of magnitude.",
    "creator" : "TeX"
  }
}