{
  "name" : "1409.7202.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Boosting Framework on Grounds of Online Learning",
    "authors" : [ "Tofigh Naghibi", "Beat Pfister" ],
    "emails" : [ "naghibi@tik.ee.ethz.ch,", "pfister@tik.ee.ethz.ch" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 9.\n72 02\nv3 [\ncs .L\nG ]\n2 3\nN ov"
    }, {
      "heading" : "1 Introduction",
      "text" : "A boosting algorithm can be seen as a meta-algorithm that maintains a distribution over the sample space. At each iteration a weak hypothesis is learned and the distribution is updated, accordingly. The output (strong hypothesis) is a convex combination of the weak hypotheses. Two dominant views to describe and design boosting algorithms are “weak to strong learner” (WTSL), which is the original viewpoint presented in [1, 2], and boosting by “coordinate-wise gradient descent in the functional space” (CWGD) appearing in later works [3, 4, 5]. A boosting algorithm adhering to the first view guarantees that it only requires a finite number of iterations (equivalently, finite number of weak hypotheses) to learn a (1− ǫ)-accurate hypothesis. In contrast, an algorithm resulting from the CWGD viewpoint (usually called potential booster) may not necessarily be a boosting algorithm in the probability approximately correct (PAC) learning sense. However, while it is rather difficult to construct a boosting algorithm based on the first view, the algorithmic frameworks, e.g., AnyBoost [4], resulting from the second viewpoint have proven to be particularly prolific when it comes to developing new boosting algorithms. Under the CWGD view, the choice of the convex loss function to be minimized is (arguably) the cornerstone of designing a boosting algorithm. This, however, is a severe disadvantage in some applications.\nIn CWGD, the weights are not directly controllable (designable) and are only viewed as the values of the gradient of the loss function. In many applications, some characteristics of the desired distribution are known or given as problem requirements while, finding a loss function that generates such a distribution is likely to be difficult. For instance, what loss functions can generate sparse distributions?2 What family of loss functions results in a smooth distribution?3 We even can go further and imagine the scenarios in which a loss function needs to put more weights on a given subset of examples than others, either because that subset has more reliable labels or it is a prob-\n1Boosting algorithms in this paper can be found in ‘maboost’ R package 2In the boosting terminology, sparsity usually refers to the greedy hypothesis-selection strategy of boosting methods in the functional space. However, sparsity in this paper refers to the sparsity of the distribution (weights) over the sample space.\n3A smooth distribution is a distribution that does not put too much weight on any single sample or in other words, a distribution emulated by the booster does not dramatically diverge from the target distribution [6, 7].\nlem requirement to have a more accurate hypothesis for that part of the sample space. Then, what loss function can generate such a customized distribution? Moreover, does it result in a provable boosting algorithm? In general, how can we characterize the accuracy of the final hypothesis?\nAlthough, to be fair, the so-called loss function hunting approach has given rise to useful boosting algorithms such as LogitBoost, FilterBoost, GiniBoost and MadaBoost [5, 8, 9, 10] which (to some extent) answer some of the above questions, it is an inflexible and relatively unsuccessful approach to addressing the boosting problems with distribution constraints.\nAnother approach to designing a boosting algorithm is to directly follow the WTSL viewpoint [11, 6, 12]. The immediate advantages of such an approach are, first, the resultant algorithms are provable boosting algorithms, i.e., they output a hypothesis of arbitrary accuracy. Second, the booster has direct control over the weights, making it more suitable for boosting problems subject to some distribution constraints. However, since the WTSL view does not offer any algorithmic framework (as opposed to the CWGD view), it is rather difficult to come up with a distribution update mechanism resulting in a provable boosting algorithm. There are, however, a few useful, and albeit fairly limited, algorithmic frameworks such as TotalBoost [13] that can be used to derive other provable boosting algorithms. The TotalBoost algorithm can maximize the margin by iteratively solving a convex problem with the totally corrective constraint. A more general family of boosting algorithms was later proposed by Shalev-Shwartz et. al. [15], where it was shown that weak learnability and linear separability are equivalent, a result following from von Neumann’s minmax theorem. Using this theorem, they constructed a family of algorithms that maintain smooth distributions over the sample space, and consequently are noise tolerant. Their proposed algorithms find an (1− ǫ)-accurate solution after performing at most O(log(N)/ǫ2) iterations, where N is the number of training examples."
    }, {
      "heading" : "1.1 Our Results",
      "text" : "We present a family of boosting algorithms that can be derived from well-known online learning algorithms, including projected gradient descent [16] and its generalization, mirror descent (both active and lazy updates, see [17]) and composite objective mirror descent (COMID) [18]. We prove the PAC learnability of the algorithms derived from this framework and we show that this framework in fact generates maximum margin algorithms. That is, given a desired accuracy level ν, it outputs a hypothesis of margin γmin − ν with γmin being the minimum edge that the weak classifier guarantees to return.\nThe duality between (linear) online learning and boosting is by no means new. This duality was first pointed out in [2] and was later elaborated and formalized by using the von Neumann’s minmax theorem [19]. Following this line, we provide several proof techniques required to show the PAC learnability of the derived boosting algorithms. These techniques are fairly versatile and can be used to translate many other online learning methods into our boosting framework. To motivate our boosting framework, we derive two practically and theoretically interesting algorithms: (I) SparseBoost algorithm which by maintaining a sparse distribution over the sample space tries to reduce the space and the computation complexity. In fact this problem, i.e., applying batch boosting on the successive subsets of data when there is not sufficient memory to store an entire dataset, was first discussed by Breiman in [20], though no algorithm with theoretical guarantee was suggested. SparseBoost is the first provable batch booster that can (partially) address this problem. By analyzing this algorithm, we show that the tuning parameter of the regularization term ℓ1 at each round t should not exceed γt 2 ηt to still have a boosting algorithm, where ηt is the coefficient of the tth weak hypothesis and γt is its edge. (II) A smooth boosting algorithm that requires only O(log 1/ǫ) number of rounds to learn a (1− ǫ)-accurate hypothesis. This algorithm can also be seen as an agnostic boosting algorithm4 due to the fact that smooth distributions provide a theoretical guarantee for noise tolerance in various noisy learning settings, such as agnostic boosting [22, 23].\nFurthermore, we provide an interesting theoretical result about MadaBoost [10]. We give a proof (to the best of our knowledge the only available unconditional proof) for the boosting property of (a variant of) MadaBoost and show that, unlike the common presumption, its convergence rate is of O(1/ǫ2) rather than O(1/ǫ).\n4Unlike the PAC model, the agnostic learning model allows an arbitrary target function (labeling function) that may not belong to the class studied, and hence, can be viewed as a noise tolerant learning model [21].\nFinally, we show our proof technique can be employed to generalize some of the known online learning algorithms. Specifically, consider the Lazy update variant of the online Mirror Descent (LMD) algorithm (see for instance [17]). The standard proof to show that the LMD update scheme achieves vanishing regret bound is through showing its equivalence to the FTRL algorithm [17] in the case that they are both linearized, i.e., the cost function is linear. However, this indirect proof is fairly restrictive when it comes to generalizing the LMD-type algorithms. Here, we present a direct proof for it, which can be easily adopted to generalize the LMD-type algorithms."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "Let {(xi, ai)}, 1 ≤ i ≤ N , be N training samples, where xi ∈ X and ai ∈ {−1,+1}. Assume h ∈ H is a real-valued function mapping X into [−1, 1]. Denote a distribution over the training data by w = [w1, . . . , wN ]⊤ and define a loss vector d = [−a1h(x1), . . . ,−aNh(xN )]⊤. We define γ = −w⊤d as the edge of the hypothesis h under the distribution w and it is assumed to be positive when h is returned by a weak learner. In this paper we do not consider the branching program based boosters and adhere to the typical boosting protocol (described in Section 1).\nSince a central notion throughout this paper is that of Bregman divergences, we briefly revisit some of their properties. A Bregman divergence is defined with respect to a convex function R as\nBR(x,y)= R(x) −R(y) −∇R(y)(x − y) ⊤ (1)\nand can be interpreted as a distance measure between x and y. Due to the convexity of R, a Bregman divergence is always non-negative, i.e., BR(x,y) ≥ 0. In this work we consider R to be a β-strongly convex function5 with respect to a norm ||.||. With this choice of R, the Bregman divergence BR(x,y) ≥ β 2 ||x− y||2. As an example, if R(x) = 1 2 x⊤x (which is 1-strongly convex with respect to ||.||2), then BR(x,y) = 12 ||x − y|| 2 2 is the Euclidean distance. Another example is the negative entropy function R(x) = ∑N\ni=1 xi log xi (resulting in the KL-divergence) which is known to be 1-strongly convex over the probability simplex with respect to ℓ1 norm.\nThe Bregman projection is another fundamental concept of our framework.\nDefinition 1 (Bregman Projection). The Bregman projection of a vector y onto a convex set S with respect to a Bregman divergence BR is\nΠS(y) = argmin x∈S BR(x,y) (2)\nMoreover, the following generalized Pythagorean theorem holds for Bregman projections.\nLemma 1 (Generalized Pythagorean) [24, Lemma 11.3]. Given a point y ∈ RN , a convex set S and ŷ= ΠS(y) as the Bregman projection of y onto S, for all x ∈ S we have\nExact: BR(x,y) ≥ BR(x, ŷ) +BR(ŷ,y) (3)\nRelaxed: BR(x,y) ≥ BR(x, ŷ) (4)\nThe relaxed version follows from the fact that BR(ŷ,y)≥0 and thus can be ignored.\nLemma 2. For any vectors x,y, z, we have\n(x− y)⊤(∇R(z) −∇R(y)) = BR(x,y) −BR(x, z) +BR(y, z) (5)\nThe above lemma follows directly from the Bregman divergence definition in (1). Additionally, the following definitions from convex analysis are useful throughout the paper.\nDefinition 2 (Norm & dual norm). Let ||.||A be a norm. Then its dual norm is defined as\n||y||A∗ = sup{y ⊤x, ||x||A ≤ 1} (6)\nFor instance, the dual norm of ||.||2 = ℓ2 is ||.||2∗ = ℓ2 norm and the dual norm of ℓ1 is ℓ∞ norm. Further,\nLemma 3. For any vectors x,y and any norm ||.||A, the following inequality holds:\nx⊤y ≤ ||x||A||y||A∗ ≤ 1\n2 ||x||2A +\n1 2 ||y||2A∗ (7)\n5That is, its second derivative (Hessian in higher dimensions) is bounded away from zero by at least β.\nThroughout this paper, we use the shorthands ||.||A = ||.|| and ||.||A∗ = ||.||∗ for the norm and its dual, respectively.\nFinally, before continuing, we establish our notations. Vectors are lower case bold letters and their entries are non-bold letters with subscripts, such as xi of x, or non-bold letter with superscripts if the vector already has a subscript, such as xit of xt. Moreover, an N-dimensional probability simplex is denoted by S = {w|\n∑N i=1 wi = 1, wi ≥ 0}. The proofs of the theorems and the lemmas can be\nfound in the Supplement."
    }, {
      "heading" : "3 Boosting Framework",
      "text" : "Let R(x) be a 1-strongly convex function with respect to a norm ||.|| and denote its associated Bregman divergence BR. Moreover, let the dual norm of a loss vector dt be upper bounded, i.e., ||dt||∗ ≤ L. It is easy to verify that for dt as defined in MABoost, L = 1 when ||.||∗ = ℓ∞ and L = N when ||.||∗ = ℓ2. The following Mirror Ascent Boosting (MABoost) algorithm is our boosting framework.\nAlgorithm 1: Mirror Ascent Boosting (MABoost)\nInput: R(x) 1-strongly convex function, w1 = [ 1N , . . . , 1 N ]⊤ and z1 = [ 1N , . . . , 1 N ]⊤\nFor t = 1, . . . , T do (a) Train classifier with wt and get ht, let dt = [−a1ht(x1), . . . ,−aNht(xN )]\nand γt = −w⊤t dt.\n(b) Set ηt = γt L\n(c) Update weights: ∇R(zt+1) = ∇R(zt) + ηtdt (lazy update) ∇R(zt+1) = ∇R(wt) + ηtdt (active update)\n(d) Project onto S: wt+1 = argmin w∈S BR(w, zt+1)\nEnd Output: The final hypothesis f(x)= sign (\n∑T t=1 ηtht(x)\n)\n.\nThis algorithm is a variant of the mirror descent algorithm [17], modified to work as a boosting algorithm. The basic principle in this algorithm is quite clear. As in ADABoost, the weight of a wrongly (correctly) classified sample increases (decreases). The weight vector is then projected onto the probability simplex in order to keep the weight sum equal to 1. The distinction between the active and lazy update versions and the fact that the algorithm may behave quite differently under different update strategies should be emphasized. In the lazy update version, the norm of the auxiliary variable zt is unbounded which makes the lazy update inappropriate in some situations. In the active update version, on the other hand, the algorithm always needs to access (compute) the previous projected weight wt to update the weight at round t and this may not be possible in some applications (such as boosting-by-filtering).\nDue to the duality between online learning and boosting, it is not surprising that MABoost (both the active and lazy versions) is a boosting algorithm. The proof of its boosting property, however, reveals some interesting properties which enables us to generalize the MABoost framework. In the following, only the proof of the active update is given and the lazy update is left to Section 3.4.\nTheorem 1. Suppose that MABoost generates weak hypotheses h1, . . . , hT whose edges are γ1, . . . , γT . Then the error ǫ of the combined hypothesis f on the training set is bounded as:\nR(w) = 1\n2 ||w||22 : ǫ ≤\n1\n1 + ∑T\nt=1 γ 2 t\n(8)\nR(w)=\nN ∑\ni=1\nwi logwi : ǫ ≤ e −\n∑ T\nt=1 1 2 γ2 t (9)\nIn fact, the first bound (8) holds for any 1-strongly convex R, though for some R (e.g., negative entropy) a much tighter bound as in (9) can be achieved.\nProof : Assume w∗ = [w∗1 , . . . , w ∗ N ] ⊤ is a distribution vector where w∗i = 1 Nǫ\nif f(xi) 6= ai, and 0 otherwise. w∗ can be seen as a uniform distribution over the wrongly classified samples by the ensemble hypothesis f . Using this vector and following the approach in [17], we derive the upper bound of\n∑T t=1 ηt(w ∗⊤dt−w⊤t dt) where dt = [d 1 t , . . . ,d N t ] is a loss vector as defined in\nAlgorithm 1.\n(w∗−wt) ⊤ηtdt= (w ∗ −wt) ⊤(∇R(zt+1)−∇R(wt) )\n(10a)\n= BR(w ∗,wt)−BR(w ∗, zt+1) +BR(wt, zt+1) (10b) ≤ BR(w ∗,wt)−BR(w\n∗,wt+1) +BR(wt, zt+1) (10c) where the first equation follows Lemma 2 and inequality (10c) results from the relaxed version of Lemma 1. Note that Lemma 1 can be applied here because w∗∈ S.\nFurther, the BR(wt, zt+1) term is bounded. By applying Lemma 3\nBR(wt, zt+1) +BR(zt+1,wt) = (zt+1 −wt) ⊤ηtdt ≤\n1 2 ||zt+1 −wt|| 2 + 1 2 η2t ||dt|| 2 ∗ (11)\nand since BR(zt+1,wt) ≥ 12 ||zt+1 −wt|| 2 due to the 1-strongly convexity of R, we have\nBR(wt, zt+1) ≤ 1\n2 η2t ||dt|| 2 ∗ (12)\nNow, replacing (12) into (10c) and summing it up from t = 1 to T , yields T ∑\nt=1\nw∗⊤ηtdt−w ⊤ t ηtdt ≤\nT ∑\nt=1\n1 2 η2t ||dt|| 2 ∗ +BR(w ∗,w1)−BR(w ∗,wT+1) (13)\nMoreover, it is evident from the algorithm description that for mistakenly classified samples\n−aif(xi)= −aisign\n( T ∑\nt=1\nηtht(xi)\n)\n= sign\n( T ∑\nt=1\nηtd i t\n)\n≥ 0 ∀xi ∈ {x|f(xi) 6= ai} (14)\nFollowing (14), the first term in (13) will be w∗⊤ ∑T\nt=1 ηtdt ≥ 0 and thus, can be ignored. Moreover, by the definition of γ, the second term is\n∑T t=1 −w ⊤ t ηtdt = ∑T t=1 ηtγt. Putting all these\ntogether, ignoring the last term in (13) and replacing ||dt||2∗ with its upper bound L, yields\n−BR(w ∗,w1) ≤ L\nT ∑\nt=1\n1 2 η2t −\nT ∑\nt=1\nηtγt (15)\nReplacing the left side with −BR = − 12 ||w ∗−w1||2 = ǫ−1 2Nǫ\nfor the case of quadratic R, and with −BR = log(ǫ) when R is a negative entropy function, taking the derivative w.r.t ηt and equating it to zero (which yields ηt = γt L\n) we achieve the error bounds in (8) and (9). Note that in the case of R being the negative entropy function, Algorithm 1 degenerates into ADABoost with a different choice of ηt.\nBefore continuing our discussion, it is important to mention that the cornerstone concept of the proof is the choice of w∗. For instance, a different choice of w∗ results in the following max-margin theorem.\nTheorem 2. Setting ηt = γt L √ t , MABoost outputs a hypothesis of margin at least γmin − ν, where ν is a desired accuracy level and tends to zero in O( log T√ T ) rounds of boosting.\nObservations: Two observations follow immediately from the proof of Theorem 1. First, the requirement of using Lemma 1 is w∗ ∈ S, so in the case of projecting onto a smaller convex set Sk⊆S, as long as w∗∈Sk holds, the proof is intact. Second, only the relaxed version of Lemma 1 is required in the proof (to obtain inequality (10c)). Hence, if there is an approximate projection operator Π̂S that satisfies the inequality BR(w∗, zt+1) ≥ BR ( w∗, Π̂S(zt+1) )\n, it can be substituted for the exact projection operator ΠS and the active update version of the algorithm still works. A practical approximate operator of this type can be obtained through a double-projection strategy.\nLemma 4. Consider the convex sets K and S, where S ⊆ K. Then for any x ∈ S and y ∈ RN , Π̂S(y)=ΠS ( ΠK(y) ) is an approximate projection that satisfies BR(x,y)≥BR ( x, Π̂S(y) ) .\nThese observations are employed to generalize Algorithm 1. However, we want to emphasis that the approximate Bregman projection is only valid for the active update version of MABoost."
    }, {
      "heading" : "3.1 Smooth Boosting",
      "text" : "Let k > 0 be a smoothness parameter. A distribution w is smooth w.r.t a given distribution D if wi ≤ kDi for all 1≤ i≤ N . Here, we consider the smoothness w.r.t to the uniform distribution, i.e., Di = 1N . Then, given a desired smoothness parameter k, we require a boosting algorithm that only constructs distributions w such that wi ≤ kN , while guaranteeing to output a (1− 1 k )- accurate hypothesis. To this end, we only need to replace the probability simplex S with Sk = {w|\n∑N i=1 wi = 1, 0≤ wi ≤ k N } in MABoost to obtain a smooth distribution boosting algorithm,\ncalled smooth-MABoost. That is, the update rule is: wt+1 = argmin w∈Sk BR(w, zt+1).\nNote that the proof of Theorem 1 holds for smooth-MABoost, as well. As long as ǫ≥ 1 k , the error distribution w∗ (w∗i = 1 Nǫ if f(xi) 6= ai, and 0 otherwise) is in Sk because 1Nǫ ≤ k N\n. Thus, based on the first observation, the error bounds achieved in Theorem 1 hold for ǫ≥ 1\nk . In particular, ǫ= 1\nk is reached after a finite number of iterations. This projection problem has already appeared in the literature. An entropic projection algorithm (R is negative entropy), for instance, was proposed in [15]. Using negative entropy and their suggested projection algorithm results in a fast smooth boosting algorithm with the following convergence rate.\nTheorem 3. Given R(w) = ∑N\ni=1 wi logwi and a desired ǫ, smooth-MABoost finds a (1 − ǫ)accurate hypothesis in O(log(1\nǫ )/γ2) of iterations."
    }, {
      "heading" : "3.2 Combining Datasets",
      "text" : "Let’s assume we have two sets of data. A primary dataset A and a secondary dataset B. The goal is to train a classifier that achieves (1− ǫ) accuracy on A while limiting the error on dataset B to ǫB ≤ 1 k\n. This scenario has many potential applications including transfer learning [25], weighted combination of datasets based on their noise level and emphasizing on a particular region of a sample space as a problem requirement (e.g., a medical diagnostic test that should not make a wrong diagnosis when the sample is a pregnant woman). To address this problem, we only need to replace S in MABoost with Sc= {w| ∑N i=1 wi= 1, 0≤ wi ∀i ∈ A ∧ 0≤ wi≤ k N\n∀i ∈ B} where i ∈ A shorthands the indices of samples in A. By generating smooth distributions on B, this algorithm limits the weight of the secondary dataset, which intuitively results in limiting its effect on the final hypothesis. The proof of its boosting property is quite similar to Theorem 1 (see supplement)."
    }, {
      "heading" : "3.3 Sparse Boosting",
      "text" : "Let R(w)= 1 2 ||w||22. Since in this case the projection onto the simplex is in fact an ℓ1-constrained optimization problem, it is plausible that some of the weights are zero (sparse distribution), which is already a useful observation. To promote the sparsity of the weight vector, we want to directly regularize the projection with the ℓ1 norm, i.e., adding ||w||1 to the objective function in the projection step. It is, however, not possible in MABoost, since ||w||1 is trivially constant on the simplex. Therefore, we split the projection step into two consecutive steps. The first projection is onto R+={y | 0≤ yi}.\nSurprisingly, projection onto R+ implicitly regularizes the weights of the correctly classified samples with a weighted ℓ1 norm term (see supplement). To further enhance sparsity, we may introduce an explicit ℓ1 norm regularization term into the projection step with a regularization factor denoted by αtηt. The solution of the projection step is then normalized to get a feasible point on the probability simplex. This algorithm is listed in Algorithm 2. αtηt is the regularization factor of the explicit ℓ1 norm at round t. Note that the dominant regularization factor is ηtdit which only pushes the weights of the correctly classified samples to zero .i.e., when dit < 0. This can become evident by substituting the update step in the projection step for zt+1.\nFor simplicity we consider two cases: when αt= min(1, 12γt||yt||1)and when αt=0. The following theorem bounds the training error.\nTheorem 4. Suppose that SparseBoost generates weak hypotheses h1, . . . , hT whose edges are γ1, . . . , γT . Then the error ǫ of the combined hypothesis f on the training set is bounded as follows:\nǫ ≤ 1\n1 + c ∑T\nt=1 γ 2 t ||yt|| 2 1\n(16)\nNote that this bound holds for any choice of α ∈ [ 0,min(1, γt||yt||1) )\n. Particularly, in our two cases constant c is 1 for αt=0, and 14 when αt= min(1, 1 2 γt||yt||1).\nFor αt = 0, the ℓ1 norm of the weights ||yt||1 can be bounded away from zero by 1N (see supplement). Thus, the error ǫ tends to zero by O( N 2\nγ2T ). That is, in this case Sparseboost is a\nprovable boosting algorithm. However, for αt 6= 0, the ℓ1 norm ||yt||1 may rapidly go to zero which consequently results in a non-vanishing upper bound (as T increases) for the training error in (16). In this case, it may not be possible to conclude that the algorithm is in fact a boosting algorithm6. It is noteworthy that SparseBoost can be seen as a variant of the COMID algorithm in [18].\nAlgorithm 2: SparseBoost\nLet R+={y | 0≤ yi}; Set y1 = [ 1N , . . . , 1 N ]⊤; At t = 1, . . . , T , train ht, set (ηt= γt||yt||1\nN , αt=0) or (ηt= γt||yt||1 2N , αt= 1 2 γt||yt||1), and\nupdate\nzt+1 = yt + ηtdt\nyt+1 = argmin y∈R+\n1 2 ||y − zt+1|| 2 + αtηt||y||1 → y i t+1 = max(0, y i t + ηtd i t − αtηt)\nwt+1 = yt+1\n∑N i=1 yi\nOutput the final hypothesis f(x)= sign\n(\n∑T t=1 ηtht(x)\n)\n."
    }, {
      "heading" : "3.4 Lazy Update Boosting",
      "text" : "In this section, we present the proof for the lazy update version of MABoost (LAMABoost) in Theorem 1. The proof technique is novel and can be used to generalize several known online learning algorithms such as OMDA in [27] and Meta algorithm in [28]. Moreover, we show that MadaBoost [10] can be presented in the LAMABoost setting. This gives a simple proof for MadaBoost without making the assumption that the edge sequence is monotonically decreasing (as in [10]).\nProof : Assume w∗ = [w∗1 , . . . , w ∗ N ] ⊤ is a distribution vector where w∗i = 1 Nǫ\nif f(xi) 6= ai, and 0 otherwise. Then, (w∗−wt) ⊤ηtdt= (wt+1 −wt) ⊤(∇R(zt+1)−∇R(zt) )\n+ (zt+1 −wt+1) ⊤(∇R(zt+1)−∇R(zt) ) + (w∗ − zt+1) ⊤(∇R(zt+1)−∇R(zt) )\n≤ 1\n2 ||wt+1 −wt||\n2 + 1\n2 η2t ||dt|| 2 ∗ +BR(wt+1, zt+1)−BR(wt+1, zt) +BR(zt+1, zt)\n−BR(w ∗, zt+1) +BR(w ∗, zt)−BR(zt+1, zt)\n≤ 1\n2 ||wt+1 −wt||\n2 + 1\n2 η2t ||dt|| 2 ∗ −BR(wt+1,wt)\n+BR(wt+1, zt+1)−BR(wt, zt)−BR(w ∗, zt+1) +BR(w ∗, zt) (17)\nwhere the first inequality follows applying Lemma 3 to the first term and Lemma 2 to the rest of the terms and the second inequality is the result of applying the exact version of Lemma 1 to BR(wt+1, zt). Moreover, since BR(wt+1,wt)−12 ||wt+1−wt||\n2 ≥ 0, they can be ignored in (17). Summing up the inequality (17) from t = 1 to T , yields\n−BR(w ∗, z1) ≤ L\nT ∑\nt=1\n1 2 η2t −\nT ∑\nt=1\nηtγt (18)\nwhere we used the facts that w∗⊤ ∑T t=1 ηtdt ≥ 0 and ∑T t=1 −w ⊤ t ηtdt = ∑T t=1 ηtγt. The above inequality is exactly the same as (15), and replacing −BR with ǫ−1Nǫ or log(ǫ) yields the same\n6Nevertheless, for some choices of αt 6=0 such as αt ∝ 1t2 , the boosting property of the algorithm is still provable.\nerror bounds in Theorem 1. Note that, since the exact version of Lemma 1 is required to obtain (17), this proof does not reveal whether LAMABoost can be generalized to employ the doubleprojection strategy. In some particular cases, however, we may show that a double-projection variant of LAMABoost is still a provable boosting algorithm.\nIn the following, we briefly show that MadaBoost can be seen as a double-projection LAMABoost.\nAlgorithm 3: Variant of MadaBoost\nLet R(w) be the negative entropy and K a unit hypercube; Set z1 = [1, . . . , 1]⊤;\nAt t = 1, . . . , T , train ht with wt, set ft(x)= sign\n(\n∑t t′=1 ηt′ht′(x)\n)\nand calculate\nǫt =\n∑N i=1 1 2 |ft(xi)− ai| N , set ηt = ǫtγt and update\n∇R(zt+1) = ∇R(zt) + ηtdt → z i t+1 = z i te\nηtd i\nt\nyt+1 = argmin y∈K\nBR(y, zt+1) → y i t+1 = min(1, z i t+1)\nwt+1 = argmin w∈S\nBR(w,yt+1) → w i t+1 = yit+1 ||yt+1||1\nOutput the final hypothesis f(x)= sign\n(\n∑T t=1 ηtht(x)\n)\n.\nAlgorithm 3 is essentially MadaBoost, only with a different choice of ηt. It is well-known that the entropy projection onto the probability simplex results in the normalization and thus, the second projection of Algorithm 3. The entropy projection onto the unit hypercube, however, maybe less known and thus, its proof is given in the Supplement.\nTheorem 5. Algorithm 3 yields a (1− ǫ)-accurate hypothesis after at most T = O( 1 ǫ2γ2 ).\nThis is an important result since it shows that MadaBoost seems, at least in theory, to be slower than what we hoped, namely O( 1\nǫγ2 )."
    }, {
      "heading" : "4 Conclusion and Discussion",
      "text" : "In this work, we provided a boosting framework that can produce provable boosting algorithms. This framework is mainly suitable for designing boosting algorithms with distribution constraints. A sparse boosting algorithm that samples only a fraction of examples at each round was derived from this framework. However, since our proposed algorithm cannot control the exact number of zeros in the weight vector, a natural extension to this algorithm is to develop a boosting algorithm that receives the sparsity level as an input. However, this immediately raises the question: what is the maximum number of examples that can be removed at each round from the dataset, while still achieving a (1− ǫ)-accurate hypothesis?\nThe boosting framework derived in this work is essentially the dual of the online mirror descent algorithm. This framework can be generalized in different ways. Here, we showed that replacing the Bregman projection step with the double-projection strategy, or as we call it approximate Bregman projection, still results in a boosting algorithm in the active version of MABoost, though this may not hold for the lazy version. In some special cases (MadaBoost for instance), however, it can be shown that this double-projection strategy works for the lazy version as well. Our conjecture is that under some conditions on the first convex set, the lazy version can also be generalized to work with the approximate projection operator. Finally, we provided a new error bound for the MadaBoost algorithm that does not depend on any assumption. Unlike the common conjecture, the convergence rate of MadaBoost (at least with our choice of η) is of O(1/ǫ2)."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This work was partially supported by SNSF. We would like to thank Professor Rocco Servedio for an inspiring email conversation and our colleague Hui Liang for his helpful comments."
    }, {
      "heading" : "Supplement",
      "text" : "Before proceeding with the proofs, some definitions and facts need to be reminded."
    }, {
      "heading" : "Definition: Margin",
      "text" : "Given a final hypothesis f(x) = ∑T\nt=1 ηtht(x), the margin of a sample (xj , aj) is defined as m(xj) = ajf(xj)/ ∑T\nt=1 ηt. Moreover, the margin of a set of examples denoted by mD is the minimum of margins over the examples, i.e., mD=minx m(xj).\nFact: Duality between max-margin and min-edge\nThe minimum edge γmin that can be achieved over all possible distributions of the training set is equal to the maximum margin (m∗ = maxη mD) of any linear combination of hypotheses from the hypotheses space.\nThis fact is discussed in details in [29] and [30]. It is the direct result of von Neumann’s minmax theorem and simply means that the maximum achievable margin is γmin."
    }, {
      "heading" : "Proof of Theorem 2",
      "text" : "The proof for the maximum margin property of MABoost, is almost the same as the proof of Theorem 1.\nLet’s assume the ith sample has the worst margin, i.e., mD = m(xi). Let all entries of the error vector w∗ to be zero except its ith entry which is set to be 1. Following the same approach as in Theorem 1, (see equation (13)), we get\nT ∑\nt=1\nw ∗⊤ηtdt−w⊤t ηtdt ≤\nT ∑\nt=1\n1 2 η2t ||dt||2∗ +BR(w∗,w1)−BR(w∗,wT+1) (19)\nWith our choice of w∗ it is easy to verify that the first term on the left side of the inequality is mD ∑T\nt=1 ηt=\n−∑T t=1w ∗⊤ηtdt. By setting C = BR(w∗,w1), ignoring the last term BR(w∗,wT+1), replacing ||dt||2∗ with its upper bound L and using the identity ∑T\nt=1 w ⊤ t ηtdt= − ∑T\nt=1 ηtγt the above inequality is simplified to\n−mD T ∑\nt=1\nηt ≤ L T ∑\nt=1\n1 2 η2t −\nT ∑\nt=1\nηtγt + C (20)\nReplacing ηt with the value suggested in Theorem 2, i.e., ηt = γt\nL √ t and dividing both sides by ∑T t=1 ηt, gives\n∑T t=1( 1√ t − 1 t )γ2t\n∑T t=1 1√ t γt\n− LC ∑T\nt=1 1√ t γt\n≤ mD (21)\nThe first term is minimized when γt=γmin . Similarly to the first term, the second term is maximized when γt is replaced by its minimum value. This gives the following lower bound for mD:\nγmin\n∑T t=1 1√ t − 1\nt ∑T\nt=1 1√ t\n− LC γmin ∑T\nt=1 1√ t\n≤ mD (22)\nConsidering the facts that ∫ T+1 1 dx√ x ≤ ∑T t=1 1√ t and 1 + ∫ T 1 dx x ≥ ∑T t=1 1 t , we get\nγmin − 1 + log T 2 √ T + 1− 2 γmin − LC γmin( √ T + 1− 1) ≤ mD (23)\nNow by taking ν = 1+log T 2 √ T+1−2γmin + LC γmin( √ T+1−1) , we have γmin − ν ≤ γmin. It is clear from (23) that ν approaches zero as T tends to infinity with a convergence rate proportional to log T√ T . It is noteworthy that this convergence rate is slightly worse than that of TotalBoost which is O( 1√ T )."
    }, {
      "heading" : "Proof of Lemma 4",
      "text" : "Remember that Π̂S(y)= ΠS ( ΠK(y) ) . Our goal is to show that BR(x,y) ≥ BR ( x, Π̂S(y) ) .\nTo this end, we only need to repeatedly apply Lemma 1, as follows BR(x,y) ≥ BR ( x,ΠK(y) )\n(24)\nBR ( x,ΠK(y) ) ≥ BR ( x, Π̂S(y) )\n(25) which completes the proof.\nProof of combining datasets boosting algorithm\nWe have to show that when the convex set is defined as\nSc= {w| N ∑\ni=1\nwi= 1, 0≤ wi ∀i ∈ A ∧ 0≤ wi≤ k N ∀i ∈ B} (26)\nthe error of the final hypothesis on A, i.e., ǫA, converges to zero while the error on B is guaranteed to be ǫB ≤ 1k . First, we show the convergence of ǫA to zero. This is easily obtained by setting w∗ to be an error vector with zero weights over the training samples from B and 1ǫANA weights over the training set A. One can verify that w∗ ∈ Sc, thus the proof of Theorem 1 holds and subsequently, the error bounds in (8) stating that ǫA → 0 as the number of iterations increases.\nTo show the second part of the theorem that is ǫB ≤ 1k , vector w ∗ is selected to be an error vector with zero weights over the training samples from A and 1ǫBNB weights over the training set B. Note that, as long as ǫB is greater than 1\nk , this w∗ ∈ Sc. Thus, for all 1k ≤ ǫB the proof of Theorem 1 holds and as the bounds in (8)\nshow, the error decreases as the number of iterations increases. In particular in a finite number of rounds, the classification error on B reduces to 1\nk which completes the proof."
    }, {
      "heading" : "Proof of Theorem 4",
      "text" : "We use proof techniques similar to those given in [18], with a slight change to take the normalization step into account.\nBy replacing zt+1 in the projection step from the update step, the projection step can be rewritten as\nyt+1 = argmin y∈R+\n1 2 ||y − yt|| − ηty⊤dt + αtηt||y||1 (27)\nThis optimization problem can be highly simplified by noting that the variables are not coupled. Thus, each coordinate can be independently optimized. In other words, it can be decoupled intoN independent 1-dimensional optimization problems.\nyit+1 = argmin 0≤yi\n1 2 ||yi − yit|| − ηtyidit + αtηtyi (28)\nThe solution of (28) can be written as\nyit+1 = max(0, y i t + ηtd i t − αtηt) (29)\nThis simple solution gives a very efficient and simple implementation for SparseBoost. From (28) it is clear that for dit < 0 (i.e., when i\nth sample is classified correctly), −ηtydit acts as the ℓ1 norm regularization and pushes yit+1 towards zero while αtηt enhance sparsity by pushing all weights to zero.\nLet w∗ to be the same error vector as defined in Theorem 1. We start this proof by again deriving the progress bounds on each step of the algorithm. The optimality of yt+1 for (27) implies that (w∗ − yt+1)⊤(−ηtdt + αtηtr′(y) + yt+1 − yt) ≥ 0 (30) where r′(y) is a sub-gradient vector of the ℓ1 norm function r(y) = ∑N\ni=1 yi. Moreover, due to the convexity of r(y), we have\nαtηtr(yt+1) ⊤(w∗ − yt+1) ≤ αtηt ( r(w∗)− r(yt+1) )\n(31)\nWe thus have\n(w∗− yt)⊤ηtdt + αtηt ( r(yt+1)− r(w∗) ) ≤ (w∗− yt)⊤ηtdt + αtηt(yt+1 −w∗)⊤r′(yt+1) = (w∗− yt+1)⊤ηtdt + αtηt(yt+1 −w∗)⊤r′(yt+1) + (yt+1 − yt)⊤ηtdt = (w∗− yt+1)⊤(ηtdt − αtηtr′(yt+1)− yt+1 + yt) + (w∗− yt+1)⊤(yt+1 − yt) + (yt+1 − yt)⊤ηtdt (32)\nwhere the first inequality follows (31). Now, from the optimality condition in (30), the first term in the last equation is non-positive and thus, can be ignored.\n(w∗− yt)⊤ηtdt + αtηt ( r(yt+1)− r(w∗) ) ≤ (w∗− yt+1)⊤(yt+1 − yt) + (yt+1 − yt)⊤ηtdt\n= 1 2 ||w∗− yt||22 − 1 2 ||yt+1− yt||22 − 1 2 ||w∗− yt+1||22 + (yt+1 − yt)⊤ηtdt ≤ 1 2 ||w∗− yt||22 − 1 2 ||yt+1− yt||22 − 1 2 ||w∗− yt+1||22 + 1 2 ||yt+1− yt||22 + 1 2 η2t ||dt||2∗ (33)\nwhere the first equation follows from Lemma 2 (or direct algebraic expansion in this case) and the second inequality from Lemma 3.\nBy summing the left and right sides of the inequality from 1 to T , replacing ||dt||2∗ with its upperbound N and substituting 1 for r(w∗), we get\nT ∑\nt=1\nw ∗⊤ηtdt ≤\nT ∑\nt=1\ny ⊤ t ηtdt +\nT ∑\nt=1\nN 2 η2t + 1 2 ||w∗− y1||22 +\nT ∑\nt=1\nαtηt ( 1− r(yt+1) )\n(34)\nNow, replacing r(yt+1) with its lower bound, i.e, 0 and using the fact that ∑T t=1w ∗⊤ηtdt ≥ 0 (as shown in (14)) and ∑T\nt=1 y ⊤ t ηtdt= − ∑T t=1 ηtγt||yt||1, yields\n0 ≤ − T ∑\nt=1\nηtγt||yt||1 + T ∑\nt=1\nN 2 η2t + 1 2 ||w∗− y1||22 +\nT ∑\nt=1\nαtηt (35)\nTaking derivative w.r.t ηt and setting it to zero, gives the optimal ηt as follows\nηt = γt||yt||1 − αt\nN (36)\nThis equation implies that αt should be smaller than γt||yt||1 or otherwise ηt becomes smaller than zero. Setting αt = (1 − k)γt||yt||1 where k is a constant smaller than or equal to 1, results in ηt = kN γt||yt||1. Replacing this value for ηt in (35) and noting that 12 ||w\n∗− y1||22 = 1−ǫ2Nǫ gives the following bound on the training error\nǫ ≤ 1 1 + c ∑T\nt=1 γ 2 t ||yt||21\n(37)\nwhere c = 1 k2 is a constant factor depending on the choice of αt. To prove that ǫ approaches zero as T increases, we still have to provide an evidence that ∑T\nt=1 γ 2 t ||yt||21 is a divergent series. There are different\npossibilities to approach this problem. Here, we show that in the case of αt=0, the ℓ1 norm of weights ||yt||1 can be bounded away from zero (i.e., ||yt||1 ≥ C > 0) and thus, ∑T t=1 γ 2 t ||yt||21 ≥ Tγ2minC2.\nTo this end, we rewrite yit from (29) as\nyit = max(0, y i t−1 + ηt−1d i t−1 − αt−1ηt−1)\n≥ yit−1 + ηt−1dit−1 − αt−1ηt−1\n≥ 1 N +\nt−1 ∑\nt′=1\nηt′dt′ − t−1 ∑\nt′=1\nαt′ηt′ (38)\nwhere the last inequality is achieved by recursively applying the first inequality to yit−1. At any arbitrary round t, either the algorithm has already converged and ǫ=0 or there is at least one sample that is classified wrongly by the ensemble classifier Ht(x) = ∑t l=1 ηlhl(x). Now, without loss of generality, assume the i th sample is wrongly classified at round t. That is, ∑t−1\nt′=1 ηt′dt′ > 0 (look at (14)). Now, for αt = 0, the weight of the wrongly classified sample i is\nyit ≥ 1\nN +\nt−1 ∑\nt′=1\nηt′dt′ ≥ 1\nN (39)\nThat is, ||yt||1 ≥ 1N . This gives a lousy (but sufficient for our purpose) lower bound on ||yt||1. Replacing ||yt||1 with its lower bound 1N in (37), yields\nǫ ≤ N 2\n1 + Tγ2 (40)\nwhere γ is the minimum edge over all γt."
    }, {
      "heading" : "Proof of Entropy Projection onto Hypercube (Second Update Step in MadaBoost)",
      "text" : "Lemma 5. Let R(w)= ∑N i=1 wi logwi−wi. Then the Bregman projection of a positive vector z ∈ RN+ onto the unit hypercube K = [0, 1]N is yi = min(1, zi), i = 1, . . . , N . To show the correctness of the above lemma, i.e., that the solution of the Bregman projection\ny = argmin y∈K BR(y, z) (41)\nis yi = min(1, zi), we only need to show that y satisfies the optimality condition\n(v− y)⊤∇BR(y, z) ≥ 0 ∀v ∈ K (42)\nGiven R(w)= ∑N i=1 wi logwi−wi, the gradient of BR is\n∇BR(y, z) = T ∑\ni=1\nlog yi zi\n(43)\nHence,\n(v − y)⊤∇BR(y, z) = ∑\ni∈{i:zi≥1} (vi − yi) log\nyi zi + ∑\ni∈{i:zi<1} (vi − yi) log\nyi zi\n(44)\nFor zi ≥ 1, yi is equal to 1. That is, log yizi = log 1 zi < 0. On the other hand, since vi ≤ 1, (vi − yi) = (vi − 1) ≤ 0. Thus, the first sum in (44) is always non-negative. The second sum is always zero since log yi\nzi = log 1 = 0. That is, the optimality condition (44) is non-negative for all v which completes the proof."
    }, {
      "heading" : "Proof of Theorem 5",
      "text" : "Its proof is essentially the same as the proof of the lazy version of MABoost with a few differences. Before proceeding further, some definitions and facts should be re-emphasized.\nFirst of all, since R(w) = ∑N i=1 wi logwi − wi is 1N -strongly convex (see [31, p. 136]) with respect to ℓ1 norm (and not 1-strongly as in Theorem 1), the following inequality holds for the Bregman divergence:\nBR(x,y) ≥ 1\n2N ||x− y||21 (45)\nMoreover, the following lemma which bounds ||yt|| is essential for our proof.\nLemma 6. For all t, ||yt||1 ≥ Nǫt where ǫt is the error of the ensemble hypothesis Ht(x) = ∑t\nl=1 ηlhl(x) at round t.\nThis lemma holds due to the fact that\nyit = min(1, z i t) = min(1, e\n∑ t\nl=1 ηld i l ) = min(1, e−aiHt(xi)) (46)\nwhere Ht(x) = ∑t\nl=1 ηlhl(x) is the output of the algorithm at round t. If Ht(xi) makes a mistake on classifying xi, −aiHt(xi) will be greater than zero and thus, yit = 1. For the samples that are classified correctly, −aiHt(xi) ≤ 0 and thus, 0 ≤ yit ≤ 1. That is, Nǫt = number of wrongly classified samples at round t ≤ ∑N\ni=1 y i t = ||yt||1 .\nWe are now ready to proceed with the proof of Theorem 5. Let w∗ = [w∗1 , · · ·, w∗N ]⊤ to be a vector where w∗i = 1 if f(xi) 6= ai, and 0 otherwise. Similar to the proof of the lazy update, we are going to bound the ∑T\nt=1(w ∗− yt)⊤ηtdt.\n(w∗− yt)⊤ηtdt= (yt+1 − yt)⊤ ( ∇R(zt+1)−∇R(zt) )\n+ (zt+1 − yt+1)⊤ ( ∇R(zt+1)−∇R(zt) ) + (w∗ − zt+1)⊤ ( ∇R(zt+1)−∇R(zt) )\n≤ 1 2N ||yt+1 − yt||2 + N 2 η2t ||dt||2∗ +BR(yt+1, zt+1)−BR(yt+1, zt) +BR(zt+1, zt) −BR(w∗, zt+1) +BR(w∗, zt)−BR(zt+1, zt)\n≤ 1 2N ||yt+1 − yt||2 + N 2 η2t ||dt||2∗ −BR(yt+1,yt)\n+BR(yt+1, zt+1)−BR(yt, zt)−BR(w∗, zt+1) +BR(w∗, zt) (47) where the first inequality follows from applying Lemma 3 to the first term and Lemma 2 to the rest of the terms and the second inequality is the result of applying the exact version of Lemma 1 to BR(yt+1, zt). Moreover, according to inequality (45) BR(yt+1,yt) − 12N ||yt+1 − yt||\n2 ≥ 0 and hence these terms can be ignored in (47). Summing up the inequality (47) from t = 1 to T , yields:\n−BR(w∗, z1) ≤ T ∑\nt=1\nN 2 η2t −\nT ∑\nt=1\nηtγt||yt||1 (48)\nIt is important to remark that ||yt||1 appearing in the last term is due to the fact that wt = yt||yt||1 and thus, y⊤t ηtdt = w ⊤ t ηtdt||yt||1 = ηtγt||yt||1.\nNow, by replacing ηt = ǫtγt in the above equation and noting that BR(w∗, z1) = N −Nǫ, we get:\n−N(1− ǫ) ≤ T ∑\nt=1\nN 2 ǫ2tγ 2 t −\nT ∑\nt=1\nǫtγ 2 t ||yt||1 (49)\nFrom Lemma 6, it is evident that ||yt||1 ≥ Nǫt. Moreover, since ǫ ≤ ǫt, it can be replaced by ǫ, as well (though very pessimistic). As usuall, γt is also replaced with the min edge, denoted by γ. Applying these lower bounds to the equation (49), yields\nǫ2 ≤ 2(1− ǫ) Tγ2 ≤ 1 Tγ2\n(50)\nwhich indicates that the proposed version of MadaBoost needs at most O( 1 ǫ2γ2 ) iterations to converge."
    } ],
    "references" : [ {
      "title" : "The strength of weak learnability",
      "author" : [ "R.E. Schapire" ],
      "venue" : "Mach. Learn.,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1990
    }, {
      "title" : "A decision-theoretic generalization of on-line learning and an application to boosting",
      "author" : [ "Y. Freund", "R.E. Schapire" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1997
    }, {
      "title" : "Prediction games and arcing algorithms",
      "author" : [ "L. Breiman" ],
      "venue" : "Neural Comput.,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1999
    }, {
      "title" : "Boosting algorithms as gradient descent",
      "author" : [ "L. Mason", "J. Baxter", "P. Bartlett", "M. Frean" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1999
    }, {
      "title" : "Additive logistic regression: a statistical view of boosting",
      "author" : [ "J. Friedman", "T. Hastie", "R. Tibshirani" ],
      "venue" : "Annals of Statistics,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1998
    }, {
      "title" : "Smooth boosting and learning with malicious noise",
      "author" : [ "R.A. Servedio" ],
      "venue" : "J. Mach. Learn. Res.,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2003
    }, {
      "title" : "Optimally-smooth adaptive boosting and application to agnostic learning",
      "author" : [ "D. Gavinsky" ],
      "venue" : "J. Mach. Learn. Res.,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2003
    }, {
      "title" : "Filterboost: Regression and classification on large datasets",
      "author" : [ "J.K. Bradley", "R.E. Schapire" ],
      "venue" : "In NIPS",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2008
    }, {
      "title" : "Smooth boosting using an information-based criterion",
      "author" : [ "K. Hatano" ],
      "venue" : "In Algorithmic Learning Theory",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2006
    }, {
      "title" : "Madaboost: A modification of AdaBoost",
      "author" : [ "C. Domingo", "O. Watanabe" ],
      "venue" : "In COLT,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2000
    }, {
      "title" : "Boosting a weak learning algorithm by majority",
      "author" : [ "Y. Freund" ],
      "venue" : null,
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1995
    }, {
      "title" : "On boosting with polynomially bounded distributions",
      "author" : [ "N.H. Bshouty", "D. Gavinsky", "M. Long" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2002
    }, {
      "title" : "Totally corrective boosting algorithms that maximize the margin",
      "author" : [ "M.K. Warmuth", "J. Liao", "G. Rätsch" ],
      "venue" : "In ICML,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2006
    }, {
      "title" : "Logistic regression, adaboost and bregman distances",
      "author" : [ "M. Collins", "R.E. Schapire", "Y. Singer" ],
      "venue" : "Mach. Learn.,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2002
    }, {
      "title" : "On the equivalence of weak learnability and linear separability: new relaxations and efficient boosting algorithms",
      "author" : [ "S. Shalev-Shwartz", "Y. Singer" ],
      "venue" : "In COLT,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2008
    }, {
      "title" : "Online convex programming and generalized infinitesimal gradient ascent",
      "author" : [ "M. Zinkevich" ],
      "venue" : "In ICML,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2003
    }, {
      "title" : "A survey: The convex optimization approach to regret minimization",
      "author" : [ "E. Hazan" ],
      "venue" : "Working draft,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2009
    }, {
      "title" : "Composite objective mirror descent",
      "author" : [ "J.C. Duchi", "S. Shalev-shwartz", "Y. Singer", "A. Tewari" ],
      "venue" : "In COLT,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2010
    }, {
      "title" : "Game theory, on-line prediction and boosting",
      "author" : [ "Y. Freund", "R.E. Schapire" ],
      "venue" : "In COLT,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1996
    }, {
      "title" : "Pasting bites together for prediction in large data sets and on-line",
      "author" : [ "L. Breiman" ],
      "venue" : "Technical report, Dept. Statistics, Univ. California,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1997
    }, {
      "title" : "Toward efficient agnostic learning",
      "author" : [ "M.J. Kearns", "R.E. Schapire", "L.M. Sellie" ],
      "venue" : "In COLT,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1992
    }, {
      "title" : "Potential-based agnostic boosting",
      "author" : [ "A. Kalai", "V. Kanade" ],
      "venue" : "In NIPS",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2009
    }, {
      "title" : "Agnostic boosting",
      "author" : [ "S. Ben-David", "P. Long", "Y. Mansour" ],
      "venue" : "In Computational Learning Theory. Springer,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2001
    }, {
      "title" : "Prediction, Learning, and Games",
      "author" : [ "N. Cesa-Bianchi", "G. Lugosi" ],
      "venue" : null,
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2006
    }, {
      "title" : "Boosting for transfer learning",
      "author" : [ "W. Dai", "Q. Yang", "G. Xue", "Y. Yong" ],
      "venue" : "In ICML,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2007
    }, {
      "title" : "Projection onto the probability simplex: An efficient algorithm with a simple proof, and an application",
      "author" : [ "W. Wang", "M.A. Carreira-Perpiñán" ],
      "venue" : null,
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2013
    }, {
      "title" : "Online learning with predictable sequences",
      "author" : [ "A. Rakhlin", "K. Sridharan" ],
      "venue" : "In COLT,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2013
    }, {
      "title" : "Online optimization with gradual variations",
      "author" : [ "C. Chiang", "T. Yang", "C. Lee", "M. Mahdavi", "C. Lu", "R. Jin", "S. Zhu" ],
      "venue" : "In COLT,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2012
    }, {
      "title" : "Experiments with a New Boosting Algorithm",
      "author" : [ "Y. Freund", "R.E. Schapire" ],
      "venue" : "In ICML,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 1996
    }, {
      "title" : "Efficient margin maximization with boosting",
      "author" : [ "G. Rätsch", "M. Warmuth" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2005
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Two dominant views to describe and design boosting algorithms are “weak to strong learner” (WTSL), which is the original viewpoint presented in [1, 2], and boosting by “coordinate-wise gradient descent in the functional space” (CWGD) appearing in later works [3, 4, 5].",
      "startOffset" : 144,
      "endOffset" : 150
    }, {
      "referenceID" : 1,
      "context" : "Two dominant views to describe and design boosting algorithms are “weak to strong learner” (WTSL), which is the original viewpoint presented in [1, 2], and boosting by “coordinate-wise gradient descent in the functional space” (CWGD) appearing in later works [3, 4, 5].",
      "startOffset" : 144,
      "endOffset" : 150
    }, {
      "referenceID" : 2,
      "context" : "Two dominant views to describe and design boosting algorithms are “weak to strong learner” (WTSL), which is the original viewpoint presented in [1, 2], and boosting by “coordinate-wise gradient descent in the functional space” (CWGD) appearing in later works [3, 4, 5].",
      "startOffset" : 259,
      "endOffset" : 268
    }, {
      "referenceID" : 3,
      "context" : "Two dominant views to describe and design boosting algorithms are “weak to strong learner” (WTSL), which is the original viewpoint presented in [1, 2], and boosting by “coordinate-wise gradient descent in the functional space” (CWGD) appearing in later works [3, 4, 5].",
      "startOffset" : 259,
      "endOffset" : 268
    }, {
      "referenceID" : 4,
      "context" : "Two dominant views to describe and design boosting algorithms are “weak to strong learner” (WTSL), which is the original viewpoint presented in [1, 2], and boosting by “coordinate-wise gradient descent in the functional space” (CWGD) appearing in later works [3, 4, 5].",
      "startOffset" : 259,
      "endOffset" : 268
    }, {
      "referenceID" : 3,
      "context" : ", AnyBoost [4], resulting from the second viewpoint have proven to be particularly prolific when it comes to developing new boosting algorithms.",
      "startOffset" : 11,
      "endOffset" : 14
    }, {
      "referenceID" : 5,
      "context" : "A smooth distribution is a distribution that does not put too much weight on any single sample or in other words, a distribution emulated by the booster does not dramatically diverge from the target distribution [6, 7].",
      "startOffset" : 212,
      "endOffset" : 218
    }, {
      "referenceID" : 6,
      "context" : "A smooth distribution is a distribution that does not put too much weight on any single sample or in other words, a distribution emulated by the booster does not dramatically diverge from the target distribution [6, 7].",
      "startOffset" : 212,
      "endOffset" : 218
    }, {
      "referenceID" : 4,
      "context" : "Then, what loss function can generate such a customized distribution? Moreover, does it result in a provable boosting algorithm? In general, how can we characterize the accuracy of the final hypothesis? Although, to be fair, the so-called loss function hunting approach has given rise to useful boosting algorithms such as LogitBoost, FilterBoost, GiniBoost and MadaBoost [5, 8, 9, 10] which (to some extent) answer some of the above questions, it is an inflexible and relatively unsuccessful approach to addressing the boosting problems with distribution constraints.",
      "startOffset" : 372,
      "endOffset" : 385
    }, {
      "referenceID" : 7,
      "context" : "Then, what loss function can generate such a customized distribution? Moreover, does it result in a provable boosting algorithm? In general, how can we characterize the accuracy of the final hypothesis? Although, to be fair, the so-called loss function hunting approach has given rise to useful boosting algorithms such as LogitBoost, FilterBoost, GiniBoost and MadaBoost [5, 8, 9, 10] which (to some extent) answer some of the above questions, it is an inflexible and relatively unsuccessful approach to addressing the boosting problems with distribution constraints.",
      "startOffset" : 372,
      "endOffset" : 385
    }, {
      "referenceID" : 8,
      "context" : "Then, what loss function can generate such a customized distribution? Moreover, does it result in a provable boosting algorithm? In general, how can we characterize the accuracy of the final hypothesis? Although, to be fair, the so-called loss function hunting approach has given rise to useful boosting algorithms such as LogitBoost, FilterBoost, GiniBoost and MadaBoost [5, 8, 9, 10] which (to some extent) answer some of the above questions, it is an inflexible and relatively unsuccessful approach to addressing the boosting problems with distribution constraints.",
      "startOffset" : 372,
      "endOffset" : 385
    }, {
      "referenceID" : 9,
      "context" : "Then, what loss function can generate such a customized distribution? Moreover, does it result in a provable boosting algorithm? In general, how can we characterize the accuracy of the final hypothesis? Although, to be fair, the so-called loss function hunting approach has given rise to useful boosting algorithms such as LogitBoost, FilterBoost, GiniBoost and MadaBoost [5, 8, 9, 10] which (to some extent) answer some of the above questions, it is an inflexible and relatively unsuccessful approach to addressing the boosting problems with distribution constraints.",
      "startOffset" : 372,
      "endOffset" : 385
    }, {
      "referenceID" : 10,
      "context" : "Another approach to designing a boosting algorithm is to directly follow the WTSL viewpoint [11, 6, 12].",
      "startOffset" : 92,
      "endOffset" : 103
    }, {
      "referenceID" : 5,
      "context" : "Another approach to designing a boosting algorithm is to directly follow the WTSL viewpoint [11, 6, 12].",
      "startOffset" : 92,
      "endOffset" : 103
    }, {
      "referenceID" : 11,
      "context" : "Another approach to designing a boosting algorithm is to directly follow the WTSL viewpoint [11, 6, 12].",
      "startOffset" : 92,
      "endOffset" : 103
    }, {
      "referenceID" : 12,
      "context" : "There are, however, a few useful, and albeit fairly limited, algorithmic frameworks such as TotalBoost [13] that can be used to derive other provable boosting algorithms.",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 14,
      "context" : "[15], where it was shown that weak learnability and linear separability are equivalent, a result following from von Neumann’s minmax theorem.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 15,
      "context" : "1 Our Results We present a family of boosting algorithms that can be derived from well-known online learning algorithms, including projected gradient descent [16] and its generalization, mirror descent (both active and lazy updates, see [17]) and composite objective mirror descent (COMID) [18].",
      "startOffset" : 158,
      "endOffset" : 162
    }, {
      "referenceID" : 16,
      "context" : "1 Our Results We present a family of boosting algorithms that can be derived from well-known online learning algorithms, including projected gradient descent [16] and its generalization, mirror descent (both active and lazy updates, see [17]) and composite objective mirror descent (COMID) [18].",
      "startOffset" : 237,
      "endOffset" : 241
    }, {
      "referenceID" : 17,
      "context" : "1 Our Results We present a family of boosting algorithms that can be derived from well-known online learning algorithms, including projected gradient descent [16] and its generalization, mirror descent (both active and lazy updates, see [17]) and composite objective mirror descent (COMID) [18].",
      "startOffset" : 290,
      "endOffset" : 294
    }, {
      "referenceID" : 1,
      "context" : "This duality was first pointed out in [2] and was later elaborated and formalized by using the von Neumann’s minmax theorem [19].",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 18,
      "context" : "This duality was first pointed out in [2] and was later elaborated and formalized by using the von Neumann’s minmax theorem [19].",
      "startOffset" : 124,
      "endOffset" : 128
    }, {
      "referenceID" : 19,
      "context" : ", applying batch boosting on the successive subsets of data when there is not sufficient memory to store an entire dataset, was first discussed by Breiman in [20], though no algorithm with theoretical guarantee was suggested.",
      "startOffset" : 158,
      "endOffset" : 162
    }, {
      "referenceID" : 21,
      "context" : "This algorithm can also be seen as an agnostic boosting algorithm4 due to the fact that smooth distributions provide a theoretical guarantee for noise tolerance in various noisy learning settings, such as agnostic boosting [22, 23].",
      "startOffset" : 223,
      "endOffset" : 231
    }, {
      "referenceID" : 22,
      "context" : "This algorithm can also be seen as an agnostic boosting algorithm4 due to the fact that smooth distributions provide a theoretical guarantee for noise tolerance in various noisy learning settings, such as agnostic boosting [22, 23].",
      "startOffset" : 223,
      "endOffset" : 231
    }, {
      "referenceID" : 9,
      "context" : "Furthermore, we provide an interesting theoretical result about MadaBoost [10].",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 20,
      "context" : "Unlike the PAC model, the agnostic learning model allows an arbitrary target function (labeling function) that may not belong to the class studied, and hence, can be viewed as a noise tolerant learning model [21].",
      "startOffset" : 208,
      "endOffset" : 212
    }, {
      "referenceID" : 16,
      "context" : "Specifically, consider the Lazy update variant of the online Mirror Descent (LMD) algorithm (see for instance [17]).",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 16,
      "context" : "The standard proof to show that the LMD update scheme achieves vanishing regret bound is through showing its equivalence to the FTRL algorithm [17] in the case that they are both linearized, i.",
      "startOffset" : 143,
      "endOffset" : 147
    }, {
      "referenceID" : 16,
      "context" : "This algorithm is a variant of the mirror descent algorithm [17], modified to work as a boosting algorithm.",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 16,
      "context" : "Using this vector and following the approach in [17], we derive the upper bound of ∑T t=1 ηt(w ∗⊤dt−w⊤ t dt) where dt = [d 1 t , .",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 14,
      "context" : "An entropic projection algorithm (R is negative entropy), for instance, was proposed in [15].",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 24,
      "context" : "This scenario has many potential applications including transfer learning [25], weighted combination of datasets based on their noise level and emphasizing on a particular region of a sample space as a problem requirement (e.",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 17,
      "context" : "It is noteworthy that SparseBoost can be seen as a variant of the COMID algorithm in [18].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 26,
      "context" : "The proof technique is novel and can be used to generalize several known online learning algorithms such as OMDA in [27] and Meta algorithm in [28].",
      "startOffset" : 116,
      "endOffset" : 120
    }, {
      "referenceID" : 27,
      "context" : "The proof technique is novel and can be used to generalize several known online learning algorithms such as OMDA in [27] and Meta algorithm in [28].",
      "startOffset" : 143,
      "endOffset" : 147
    }, {
      "referenceID" : 9,
      "context" : "Moreover, we show that MadaBoost [10] can be presented in the LAMABoost setting.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 9,
      "context" : "This gives a simple proof for MadaBoost without making the assumption that the edge sequence is monotonically decreasing (as in [10]).",
      "startOffset" : 128,
      "endOffset" : 132
    } ],
    "year" : 2014,
    "abstractText" : "By exploiting the duality between boosting and online learning, we present a boosting framework which proves to be extremely powerful thanks to employing the vast knowledge available in the online learning area. Using this framework, we develop various algorithms to address multiple practically and theoretically interesting questions including sparse boosting, smooth-distribution boosting, agnostic learning and, as a by-product, some generalization to double-projection online learning algorithms1.",
    "creator" : "LaTeX with hyperref package"
  }
}