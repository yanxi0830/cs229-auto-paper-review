{
  "name" : "1402.1473.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Near-Optimal Joint Object Matching via Convex Relaxation",
    "authors" : [ "Yuxin Chen", "Leonidas J. Guibas", "Qi-Xing Huang" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "In this paper, we propose an algorithm to jointly match multiple objects that exhibit only partial similarities, given a few (possibly highly incomplete) pairwise matches that are densely corrupted. By encoding a consistent partial map collection into a 0-1 semidefinite matrix, we propose to recover the ground-truth maps via a parameter-free convex program called MatchLift, following a spectral method that pre-estimates the total number of distinct elements to be matched. Numerically, this program can be efficiently solved via alternating direction methods of multipliers (ADMM) along with a greedy rounding strategy. Theoretically, MatchLift exhibits near-optimal error-correction ability, i.e. in the asymptotic regime it is guaranteed to work even when a dominant fraction 1 − Θ ( log2 n√\nn\n) of the input maps behave\nlike random outliers. Furthermore, MatchLift succeeds with minimal input complexity, namely, perfect matching can be achieved as soon as the provided maps form a connected map graph. We evaluate the proposed algorithm on various benchmark data sets including synthetic examples and real-world examples, all of which confirm the practical applicability and usefulness of MatchLift.\nIndex Terms: Joint graph matching, shape mapping, cycle consistency, dense error correction, partial similarity, convex relaxation, spectral methods, robust PCA, matrix completion, graph clustering, ADMM, MatchLift"
    }, {
      "heading" : "1 Introduction",
      "text" : "Finding consistent relations across multiple objects is a fundamental scientific problem spanning many fields. A partial list includes jigsaw puzzle solving [1, 2], structure from motion [3, 4], re-assembly of fragmented objects and documents [5, 6], and DNA/RNA shotgun assembly sequencing [7]. Compared with the rich literature in pairwise matching (e.g. of graphs, images or shapes), joint matching of multiple objects has not been well explored. A naive approach for joint object matching is to pick a base object and perform pairwise matching with each of the remaining objects. However, as pairwise matching algorithms typically generate noisy results, the performance of such approaches is often far from satisfactory in practice. This gives rise to the question as to how to aggregate and exploit information from all pairwise maps that one computes, in order to improve joint object matching in a consistent and efficient manner.\nIn this paper, we represent each object as a discrete set of points or elements, and investigate the problem of joint matching over n different sets, for which the input / observation is a collection of pairwise maps ∗Y. Chen is with the Department of Electrical Engineering, Stanford University (email: yxchen@stanford.edu). †L. J. Guibas is with the Department of Computer Science, Stanford University (email: guibas@stanford.edu). ‡Q-X. Huang is with the Department of Computer Science, Stanford University (email: huangqx@stanford.edu).\nar X\niv :1\n40 2.\n14 73\nv1 [\ncs .L\nG ]\n6 F\neb 2\n01 4\ncomputed in isolation. A natural and popular criterion to preserve the global relational compatibility is called cycle-consistency, i.e., that composition of maps between two objects should be independent of the connecting path chosen. Such criterion has recently been invoked in many algorithms [3,8–11] to detect outliers among the pairwise input maps. These works have shown experimentally that one can use inconsistent cycles to prune outliers, provided that the corruption rate is sufficiently small.\nDespite the empirical advances of these works, little is known on the theoretical side, namely, under what conditions can the underlying ground-truth maps be reliably recovered. Recent work by [12] provided the first theoretical guarantee for robust and consistent joint matching. However, there are several fundamental issues left unaddressed that must be faced in order to accommodate practical challenges.\n1. Dense Input Errors: The state-of-the-art results (e.g. [12]) did not provide theoretical support when more than 50% of the input matches are corrupted. This gives rise to the question regarding their applicability in the presence of highly noisy sources, in which case the majority of the input maps can be corrupted. Observe that as the number n of objects to be matched increases, the amount of pairwise maps one can obtain significantly exceeds n. As a result, dense error correction is information theoretically possible as long as the global consistency across pairwise maps can be appropriately exploited. While one would expect an ideal algorithm to work even when most input maps are random outliers, the challenge remains as to whether there exist computationally feasible methods that can provably detect and separate dense outliers.\n2. Partial Similarity: To the best of our knowledge, all prior approaches dealt only with a restricted scenario where the ground-truth maps are given by full isomorphisms (i.e. one-to-one correspondences between any two sets). In reality, a collection of objects usually exhibit only partial similarity, as in the case of images of the same scene but from different camera positions. These practical scenarios require consistent matching of multiple objects that are only partially similar to each other.\n3. Incomplete Input Maps: Computing pairwise maps across all object pairs are often expensive, sometimes inadmissible, and in fact unnecessary. Depending on the characteristics of input sources, one might be able to infer unobserved maps from a small sample of noisy pairwise matches. While [12] considered incomplete inputs, the tradeoff between the undersampling factor and the error-correction ability remains unknown.\nAll in all, practical applications require matching partially similar objects from a small fraction of densely corrupted pairwise maps — a goal this paper aims to achieve."
    }, {
      "heading" : "1.1 Contributions",
      "text" : "This paper is concerned with joint object matching under dense input errors. Our main contributions in this regard are three-fold.\n1. Algorithms: Inspired by the recent evidence on the power of convex relaxation, we propose to solve the joint matching problem via a semidefinite program called MatchLift. The algorithm relaxes the binaryvalue constraints, and attempts to maximize the compatibility between the input and the recovered maps. The program is established upon a semidefinite conic constraint that relies on the total number m of distinct elements to be matched. To this end, we propose to pre-estimatem via a spectral method. Our methodology is essentially parameter free, and can be solved by scalable optimization algorithms.\n2. Theory: We derive performance guarantees for exact matching. Somewhat surprisingly, MatchLift admits perfect map recovery even in the presence of dense input corruptions. Our findings reveal the near-optimal error-correction ability of MatchLift, i.e. as n grows, the algorithm is guaranteed to work even when a dominant fraction – more precisely, a fraction 1 − Ω ( log2 n√\nn\n) – of the inputs behave as\nrandom outliers. Besides, while the presence of partial similarity unavoidably incurs more severe types of input errors, MatchLift exhibits a strong recovery ability nearly order-wise equivalent to that in the full-similarity scenario, as long as the fraction of each object being disclosed is bounded away from zero. Finally, in many situations, MatchLift succeeds even with minimal input complexity, in the sense that it can reliably fill in all unobserved maps based on very few noisy partial inputs, as soon as the provided maps form a connected graph. This is information theoretically optimal.\n3. Practice: We have evaluated the performance of MatchLift on several benchmark datasets. These datasets include several synthetic examples as well as real examples from several popular benchmarks. Experimental results on synthetic examples corroborate our theoretical findings. On real datasets, the quality of the maps generated by MatchLift outperforms the state-of-the-art object matching and graph clustering algorithms."
    }, {
      "heading" : "1.2 Prior Art",
      "text" : "There has been numerous work studying the problem of object matching, either in terms of shape mapping, graph matching, or image mapping, which is impossible to enumerate. We list below a small sample of development on joint object matching, as well as its relation and distinction to the well-renowned graph clustering problem.\n• Object Matching. Early work on object matching focused primarily on matching pairs of objects in isolation (e.g. [13–15]). Due to the limited and biased information present in an isolated object pair, pairwise matching techniques can easily, sometimes unavoidably, generate false correspondences. Last few years have witnessed a flurry of activity in joint object matching, e.g. [9–12], which exploited the global cycle-consistency criterion to prune noisy maps. The fundamental understanding has recently been advanced by [12]. Nevertheless, none of the prior work have demonstrated provable recovery ability when the majority of input maps/correspondences are outliers, nor were they able to accommodate practical scenarios where different objects only exhibit partial similarity. Recent work [16] employed spectral methods for denoising in the full-similarity case. However, the errors considered therein are modeled as Gaussian-Wigner additive noise, which is not applicable in our setting. Another line of work [17, 18] proposed to recover global rigid transform between points via convex relaxation, where the point coordinates might only be partially observed. While this line of work is relevant, the problem considered therein is more specialized than the point-based joint matching studied in this paper; also, none of these paradigms are able to enable dense error correction.\n• Matrix Completion and Robust PCA. In a broader sense, our approach is inspired by the pioneering work in low-rank matrix completion [19,20] and robust principal component analysis [21–25], which reveal the power of convex relaxation in recovering low-dimensional structures among high-dimensional objects. In fact, the ground truth herein is equivalent to a block-constant low-rank matrix [26], as occurred in various graph-related problems. Nevertheless, their theoretical analyses fail to provide tight bounds in our setting, as the low-rank matrix relevant in our cases is highly sparse as well. That said, additional structural assumptions need to be incorporated in order to achieve optimal performance.\n• Graph Clustering. The joint matching problem can be treated as a structured graph clustering (GC) problem, where graph nodes represent points on objects and the edge set encodes all correspondences. In this regard, any GC algorithm [27–32] provides a heuristic to estimate graph matching. Nevertheless, there are several intrinsic structural properties herein that are not explored by any generic GC approaches. First, our input takes a block-matrix form, where each block is highly structured (i.e. doubly-substochastic), sparse, and inter-dependent. Second, the points belonging to the same object are mutually exclusive to each other. Third, the corruption rate for different entries can be highly nonsymmetric – when translated into GC languages, this means that in-cluster edges might suffer from an order-of-magnitude larger error rate than inter-cluster edges. As a result, the findings for generic GC methods do not deliver encouraging guarantees when applied to our setting. Detailed theoretical and empirical comparisons are provided in Sections 4 and 5, respectively."
    }, {
      "heading" : "1.3 Organization",
      "text" : "The rest of the paper is organized as follows. Section 2 formally presents the problem setup, including the input model and the expected output. Our two-step recovery procedure – a spectral method followed by a convex program called MatchLift – is described in Section 3. A scalable alternating direction method of multipliers (ADMM) together with a greedy rounding strategy is also introduced in Section 3. Section 4 presents the main theoretical performance guarantees for our method under a natural randomized model.\nAll proofs of the main theorems are deferred to the appendices. We introduce numerical experiments demonstrating the practicability of our method in Section 5, as well as empirical comparison with other best-known algorithms. Finally, Section 6 concludes the paper with a summary of our findings."
    }, {
      "heading" : "2 Problem Formulation and Preliminaries",
      "text" : "This section presents the problem setup for matching multiple partially similar objects, and introduces an algebraic form for representing a collection of pairwise maps."
    }, {
      "heading" : "2.1 Terminology",
      "text" : "Below we formally define several important notions that will be used throughout this paper.\n• Set. We represent objects to be matched as discrete sets. For example, these sets can represent the vertex sets in the graph matching problem, or encode feature points when matching images.\n• Partial Map. Given two discrete sets S and S ′, a subset φ ⊂ S × S ′ is termed a partial map if each element of S (resp. S ′) is paired with at most one element of S ′ (resp. S) — in particular, not all elements need to be paired.\n• Map Graph. A graph G = (V, E) is called a map graph w.r.t. n sets S1, · · · ,Sn if (i) V := {S1, · · · ,Sn}, and (ii) (Si,Sj) ∈ E implies that pairwise estimates on the partial maps φij and φji between Si and Sj are available."
    }, {
      "heading" : "2.2 Input and Output",
      "text" : "The input and expected output for the joint object matching problem are described as follows.\n• Input (Noisy Pairwise Maps). Given n sets S1, · · · ,Sn with respective cardinality m1, · · · ,mn and a (possibly sparse) map graph G, the input to the recovery algorithm consists of partial maps φinij ((i, j) ∈ G) between Si and Sj estimated in isolation, using any off-the-shelf pairwise matching method. Note that the input maps φinij one obtain might not agree, partially or totally, with the ground truth.\n• Output (Consistent Global Matching). The main objective of this paper is to detect and prune incorrect pairwise input maps in an efficient and reliable manner. Specifically, we aim at proposing a tractable algorithm that returns a full collection of partial maps {φij | 1 ≤ i, j ≤ n} that are (i) globally consistent, and (ii) close to the provided pairwise maps – and under some conditions provably the ground-truth maps.\nAs will be detailed later, the key idea of our approach is to explore global consistency across all pairwise maps. In fact, points across different objects must form several clusters, and the ground-truth maps only exhibit in-cluster edges. We will introduce a novel convex relaxation tailored to the structure of the input maps (Section 3) and investigate its theoretical performance (Section 4)."
    }, {
      "heading" : "2.3 Joint Matching in Matrix Form",
      "text" : "In the same spirit as most convex relaxation techniques (e.g., [12, 30]), we use matrices to encode maps between objects. Specifically, we encode a partial map φij : Si 7→ Sj as a binary matrix Xij ∈ {0, 1}|Si|×|Sj | such that Xij(s, s′) = 1 iff (s, s′) ∈ φij . Valid partial map matrices Xij shall satisfy the following doubly sub-stochastic constraints:\n0 ≤Xij1 ≤ 1, 0 ≤X>ij1 ≤ 1. (1)\nWe then use an n × n block matrix X ∈ {0, 1}N×N to encode the entire collection of partial maps {φij | 1 ≤ i, j ≤ n} over {S1, · · · ,Sn}:\nX =  Im1 X12 · · · X1n X21 Im2 · · · X2n ... ... . . .\n... Xn1 · · · · · · Imn  , (2) where mi := |Si| and N := ∑n i=1mi. Note that all diagonal blocks are identity matrices, as each object is isomorphic to itself. For notational simplicity, we will use X in throughout to denote the collection of pairwise input maps, i.e. each obtained pairwise estimate φinij is encoded as a binary map matrix X in ij ∈ {0, 1}\nmi×mj obeying the constraint (1). Some other useful notation is summarized in Table 1."
    }, {
      "heading" : "3 Methodology",
      "text" : "This section presents a novel methodology, based on a theoretically rigorous and numerically efficient framework."
    }, {
      "heading" : "3.1 MatchLift: A Novel Two-Step Algorithm",
      "text" : "We start by discussing the consistency constraint on the underlying ground-truth maps. Assume that there exists a universe S = {1, · · · ,m} of m elements such that i) each object Si is a (partial) image of S; ii) each element in S is contained in at least one object Si. Then the ground-truth correspondences shall connect points across objects that are associated with the same element.\nFormally speaking, let the binary matrix Y i ∈ {0, 1}mi×m encode the underlying correspondences between each point and the universe, i.e. for any si ∈ Si and s ∈ S,\nY i(si, s) = 1, iff si corresponds to s.\nThis way one can express X = Y Y >\nwith Y = (Y >1 , · · · ,Y >n )>, which makes clear that\nrank(X) = m.\nThis is equivalent to the graph partitioning setting with m cliques. Consequently, a natural candidate is to seek a low-rank and positive semidefinite (PSD) matrix to approximate the input. However, this strategy does not effectively explore the sparsity structure underlying the map collection.\nTo obtain a more powerful formulation, the proposed algorithm is based on the observation that even under dense input corruption, we are often able to obtain reliable estimates on m – the universe size, using spectral techniques. This motivates us to incorporate the information of m into the formulation so as to develop tighter relaxation. Specifically, we lift X with one more dimension and consider[\nm 1>\n1 X\n] = [ 1>\nY\n] [ 1 Y > ] 0, (3)\nwhich is strictly tighter than merely imposing X 0. Intuitively, the formulation (3) entitles us one extra degree of freedom to assist in outlier pruning, which turns out to be crucial in “debiasing” the errors. Encouragingly, this tightened constraint leads to remarkably improved theoretical guarantees, as will be shown in Section 4. In the following, we formally present our two-step matching procedure.\n• Step I: Estimating m. We estimate m by tracking the spectrum of the input X in. According to common wisdom (e.g. [33]), a block-sparse matrix X in must first be trimmed in order to remove the undesired bias effect caused by over-represented rows / columns. One candidate trimming procedure is provided as follows.\n– Trimming Procedure. Set dmin to be the smallest vertex degree of G, and we say the a vertex is over-represented if its vertex degree in G exceeds 2dmin. Then for each overrepresented vertex i, randomly sample 2dmin edges incident to it and set to zero all blocks X inij associated with the remaining edges.\nWith this trimming procedure, we propose to pre-estimate m via Algorithm 1.\nAlgorithm 1 Estimating the size m of the universe S\n1) trim X in, and let X̃ in\nbe the output. 2) perform eigenvalue decomposition on X̃ in ; denote by λi the ith largest eigenvalue. 3) output: m̂ := arg maxM≤i<N |λi − λi+1|, where M = max{2,max1≤i≤nmi}.\nIn short, Algorithm 1 returns an estimate of m via spectral methods, which outputs the number of dominant principal components of X in.\n• Step II: Map Recovery. Now that we have obtained an estimate on m, we are in position to present our optimization heuristic that exploits the structural property (3). In order to guarantee that the recovery is close to the provided maps φinij , one alternative is to maximize correspondence agreement (i.e. the number of compatible non-zero entries) between the input and output. This results in an objective function: ∑\n(i,j)∈G\n〈X inij ,Xij〉.\nAdditionally, since a non-negative map matrix X is inherently sparse, it is natural to add an `1 regularization term to encourage sparsity, which in our case reduces to\n〈1 · 1>,X〉.\nSince searching over all 0-1 map matrices is intractable, we propose to relax the binary constraints. Putting these together leads to the following semidefinite program referred to as MatchLift :\n(MatchLift) maximize X∈RN×N ∑ (i,j)∈G 〈X inij ,Xij〉 − λ〈1 · 1>,X〉\nsubject to Xii = Imi , 1 ≤ i ≤ n, X ≥ 0,[ m 1>\n1 X\n] 0. (4)\nRemark 1. Here, λ represents the regularization parameter that balances the compatibility to the input and the sparsity structure. As we will show, the recovery ability of MatchLift is not sensitive to the choice of λ. By default, one can set\nλ =\n√ |E|\n2n , (5)\nwhich results in a parameter-free formulation.\nRemark 2. Careful readers will note that the set of doubly stochastic constraints (1) can be further added into the program. Nevertheless, while enforcement of these constraints (1) results in a strictly tighter relaxation, it only leads to marginal improvement when (4) is present. As a result, we remove them for the sake of computational efficiency. We note, however, that in the scenario where m is difficulty to estimate, imposing (1) will “become crucial in allowing a constant fraction (e.g. 50%) of error rate, although dense error correction might not be guaranteed.\nThis algorithm, all at once, attempts to disentangle the ground truth and outliers as well as predict unobserved maps via convex relaxation, inspired by recent success in sparse and low-rank matrix decomposition [21, 22]. Since the ground truth matrix is simultaneously low-rank and sparse; existing methodologies, which focus on dense low-rank matrices, typically yield loose, uninformative bounds in our setting.\nFinally, we note that our matching algorithm and main results are well suited for a broad class of scenarios where each pairwise input can be modeled as a (partial) permutation matrix. For instance, our setting subsumes phase correlation [34], angular synchronization [35], and multi-signal alignment [36] as special cases."
    }, {
      "heading" : "3.2 Alternating Direction Methods of Multipliers (ADMM)",
      "text" : "Most advanced off-the-shelf SDP solvers like SeDuMi or MOSEK are typically based on interior point methods, and such second-order methods are unable to handle problems with large dimensionality. For practical applicability, we propose a first-order optimization algorithm for approximately solving MatchLift, which is a variant of the ADMM method for semidefinite programs presented in [37]. Theoretically it is guaranteed to converge. Empirically, it is often the case that ADMM converges to modest accuracy within a reasonable amount of time, and produces desired results with the assistance of appropriate rounding procedures. This feature makes ADMM practically appealing in our case since the ground-truth matrix is known to be a 0-1 matrix, for which moderate entry-wise precision is sufficient to ensure good rounding accuracy. The details of the ADMM algorithm are deferred to Appendix A."
    }, {
      "heading" : "3.3 Rounding Strategy",
      "text" : "As MatchLift solves a relaxed program of the original convex problem, it may return fractional solutions. In this case, we propose a greedy rounding method to generate valid partial maps. Given the solution X̂ to MatchLift, the proposed strategy proceeds as in Algorithm 2. One can verify that this simple deterministic rounding strategy returns a matrix that encodes a consistent collection of partial maps. Note that vTi denotes the ith row of a matrix V .\nAlgorithm 2 Rounding Strategy\ninitialize compute the top r eigenvalues Σ = diag(σ1, · · · , σr) and eigenvectors U = (u1, · · · ,ur) of X̂, where r is an estimate of the total number distinctive points to be recovered. Form V = UΣ 1 2 . repeat 1) Let O be a unitary matrix that obeys Ov1 = e1, and set V ← V O>. 2) For each of the remaining rows vi belonging to each set Sj (i ∈ Sj), perform\nvi ← e1, if 〈vi,v1〉 > 0.5 and i = arg max l∈Sj 〈vl,v1〉 .\n3) All indices i obeying vi = e1 are declared to be matched with each other, and are then removed. Repeat 1) for the next row that has not been fixed.\nuntil all the rows of V have been fixed."
    }, {
      "heading" : "4 Theoretical Guarantees: Exact Recovery",
      "text" : "Our heuristic algorithm MatchLift recovers, under a natural randomized setting, the ground-truth maps even when only a vanishing portion of the input correspondences are correct. Furthermore, MatchLift succeeds with minimal input complexity, namely, the algorithm is guaranteed to work as soon as those input maps that coincide with the ground truth maps form a connected map graph."
    }, {
      "heading" : "4.1 Randomized Model",
      "text" : "In the following, we present a natural randomized model, under which the feature of MatchLift is easiest to interpret. Specifically, consider a universe [m] := {1, 2, · · · ,m}. The randomized setting consider herein is generated through the following procedure.\n• For each set Si (1 ≤ i ≤ n), each point s ∈ [m] is included in Si independently with probability pset.\n• Each X inij is observed / computed independently with probability pobs.\n• Each observed X inij coincides with the ground truth independently with probability ptrue = 1− pfalse.\n• Each observed but incorrect X inij is independently drawn from a set of partial map matrices satisfying\nEX inij = 1\nm 1 · 1>, if X inij is observed and corrupted. (6)\nRemark 3. The above mean condition (6) holds, for example, when the augmented block (i.e. that obtained by enhancing Si and Sj to have all m elements) is drawn from the entire set of permutation matrices or other symmetric groups uniformly at random. While we impose (6) primarily to simplify our presentation of the analysis, we remark that this assumption can be significantly relaxed without degrading the matching performance. Remark 4. We also note that the outliers do not need to be generated in an i.i.d. fashion. Our main results hold as long as they are jointly independent and satisfy the mean condition (6)."
    }, {
      "heading" : "4.2 Main Theorem: Near-Optimal Matching",
      "text" : "We are now in position to state our main results, which provide theoretical performance guarantees for our algorithms.\nTheorem 1 (Accurate Estimation of m). Consider the above randomized model. There exists an absolute constant c1 > 0 such that with probability exceeding 1− 1m5n5 , the estimate on m returned by Algorithm 1 is exact as long as\nptrue ≥ c1 log 2 (mn) √ npobspset . (7)\nProof. See Appendix B.\nTheorem 1 ensures that one can obtain perfect estimate on the universe size or, equivalently, the rank of the ground truth map matrix via spectral methods. With accurate information on m, MatchLift allows perfect matching from densely corrupted inputs, as revealed below.\nTheorem 2 (Exact and Robust Matching). Consider the randomized model described above. There exist universal constants c0, c1, c2 > 0 such that for any\nc1 ( pobs m + √ pobs log(mn)\nnp3set\n) ≤ λ ≤ √ pobs log (mn)\npset , (8)\nif the non-corruption rate obeys\nptrue > c0 log 2 (mn) √ npobsp2set , (9)\nthen the solution to MatchLift is exact and unique with probability exceeding 1− (mn)−3.\nProof. See Appendix C. Note that the performance is not sensitive to λ as it can be arbitrarily chosen between Θ (√\npobs n\n) and\nΘ( √ pobs). The implications of Theorem 2 are summarized as follows.\n1. Near-Optimal Recovery under Dense Errors. Under the randomized model, MatchLift succeeds in pruning all outliers and recovering the ground truth with high probability. Somewhat surprisingly, this is guaranteed to work even when the non-corrupted pairwise maps account for only a vanishing fraction of the inputs. As a result, MatchLift achieves near-optimal recovery performance in the sense that as the number n of objects grows, its outlier-tolerance rate can be arbitrarily close to 1. Equivalently speaking, in the asymptotic regime, almost all input maps – more precisely, a fraction\n1− Ω (\nlog2 n√ n\n) (10)\nof inputs – can be badly corrupted by random errors without degrading the matching accuracy. This in turn highlights the significance of joint object matching: no matter how noisy the input sources are, perfect matching can be obtained as long as sufficiently many instances are available.\nTo the best of our knowledge, none of the prior results can support perfect recovery with more than 50% corruptions, regardless of how large n can be. The only comparative performance is reported for the robust PCA setting, where semidefinite relaxation enables dense error correction [24,25]. However, their condition cannot be satisfied in our case. Experimentally, applying RPCA on joint matching is unable to tolerate dense errors (see Section 5).\n2. Exact Matching of Partially Similar Objects. The challenge for matching partially similar objects arises in that the overlapping ratio between each pair of objects is in the order of p2set while the size of each object is in the order of pset. As correct correspondences only come from overlapping regions, it is expected that with a fixed pfalse, the matching ability degrades when pset decreases, which coincides with the bound in (9). However, the order of fault-tolerance rate with n is independent of pset as long as pset is bounded away from 0.\n3. Minimal Input Complexity. Suppose that pset and pfalse are both constants bounded away from 0 and 1, and that m = nO(poly log(n)). Condition (9) asserts that: the algorithm is able to separate outliers and fill in all missing maps reliably with no errors, as soon as the input complexity (i.e. the number of pairwise maps provided) is about the order of npoly log(n). Recall that the connectivity threshold for an Erdős–Renyi graph G(n, pobs) is pobs > lognn (see [38]). This implies that MatchLift allows exact recovery nearly as soon as the input complexity exceeds the information theoretic limits."
    }, {
      "heading" : "4.3 Comparison with Prior Approaches",
      "text" : "Our exact recovery condition significantly outperforms the best-known performance guarantees, including various SDP heuristics for matching problems, as well as general graph clustering approaches when applied to object matching, detailed below.\n• Semidefinite Programming: The SDP formulation proposed by Wang and Singer [17] admits exact recovery in the full-similarity setting when ptrue > c1 for some absolute constant c1 ≈ 50% in the asymptotic regime. One might also attempt recovery by minimizing a weighted sum of nuclear norm and `1 norm as suggested in matrix completion [19] and robust PCA [21,22]. In order to enable dense error correction, robust PCA requires the sparse components (which is X in − Xgt here with Xgt denoting the ground truth) to exhibit random signs [24, 25]. This cannot be satisfied in our setting since the sign pattern of X in−Xgt is highly biased (i.e. all non-negative entries of X in−Xgt lying in the support of Xgt have negative signs, while all non-negative entries of X in−Xgt outside the support of Xgt have positive signs).\n• Graph Clustering: Various approaches for general graph clustering have been proposed with theoretical guarantees under different randomized settings [28,29,31]. These results typically operate under the assumption that in-cluster and inter-cluster correspondences are independently corrupted, which does not apply in our model. Due to the block structure input model, these two types of corruptions are highly correlated and usually experience order-of-magnitude difference in corruption rate (i.e. (1− ptrue) m−1m for in-cluster edges and (1− ptrue) 1 m for inter-cluster edges). To facilitate comparison,\nwe evaluate the most recent deterministic guarantees obtained by [31]. The key metric Dmax therein can be easily bounded by Dmax ≥ 1 − ptrue due to a significant degree of in-cluster edge errors. The recovery condition therein requires\nDmax < 1\nm+ 1 , ⇒ ptrue >\nm\nm+ 1 ,\nwhich does not deliver encouraging guarantees compared with ptrue > Θ ( log2 n√ n ) achieved by MatchLift."
    }, {
      "heading" : "5 Experimental Evaluation",
      "text" : "In this section, we evaluate the performance of MatchLift and compare it against [29] and other graph matching methods. We consider both synthetic examples, which are used to verify the exact recovery conditions described above, as well as popular benchmark datasets for evaluating the practicability on realworld images."
    }, {
      "heading" : "5.1 Synthetic Examples",
      "text" : "We follow the randomized model described in Section 4 to generate synthetic examples. For simplicity, we only consider the full observation mode, which establishes input maps between all pairs of objects. In all examples, we fix the universe size such that it consists of m = 16 points. We then vary the remaining parameters, i.e., n, pset and pfalse, to assess the performance of an algorithm. We evaluate 31 × 36 sets of parameters for each scenario, where each parameter configuration is simulated by 10 Monte Carlo trials. The empirical success probability is reflected by the color of each cell. Blue denotes perfect recovery in all experiments, and red denotes failure for all trials.\nFigure 1(a) illustrates the phase transition for pset = 0.6, when the number of objects n and pfalse vary. We can see that MatchLift is exact even when the majority of the input correspondences are incorrect (e.g., 75% when n = 150). This is consistent with the theoretical result that the lower bound on ptrue for exact recovery is O(log2 n/ √ n).\nFigure 1(c) shows the phase transition for n = 100, when pset and pfalse vary. We can see that MatchLift tolerates more noise when pset is large. This is also consistent with the result that the error-correction ability improves with pset.\nIn comparison, Figure 1(b) and Figure 1(d) illustrate the phase transition diagrams achieved by the algorithm proposed in [29]. One can see that MatchLift is empirically superior, as [29] is unable to allow dense error correction in our case."
    }, {
      "heading" : "5.2 Real-World Examples",
      "text" : "We have applied our algorithm on six benchmark datasets, i.e., CMU-House, CMU-Hotel, two datasets (Graf and Bikes) from [39]1 and two new datasets (referred as Chair and Building, respectively) designed for evaluating joint partial object matching. As shown in Figures 2 and 3, the Building data set contains 16 images taken around a building [4], while the Chair data set contains 16 images of a chair model from different viewpoints. In the following, we first discuss the procedure for generating the input to our algorithm, i.e., the input sets and the initial maps. We then present the evaluation setup and analyze the results.\n• Feature points and initial maps. To make fair comparisons with previous techniques on CMUHouse and CMU-Hotel, we use the features points provided in [15] and apply the spectral matching\n1available online: robots.ox.ac.uk/ vgg/research/affine\nInput MatchLift RPCA LearnI LearnII House 68.2% 100% 92.2% 99.8% 96% Hotel 64.1% 100% 90.1% 99.8% 90%\nknowledge of data-driven effect, where large object collections possess stronger self-correction power than small object collections."
    }, {
      "heading" : "6 Conclusions",
      "text" : "This paper delivers some encouraging news: given a few noisy object matches computed in isolation, a collection of partially similar objects can be accurately matched via semidefinite relaxation – an approach which provably works under dense errors. The proposed algorithm is essentially parameter-free, and can be solved by ADMM achieving remarkable efficiency and accuracy, with the assistance of a greedy rounding strategy.\nThe proposed algorithm achieves near-optimal error-correction ability, as it is guaranteed to work even when a dominant fraction of inputs are corrupted. This in turn underscore the importance of joint object matching: however low the quality of input sources is, perfect matching is achievable as long as we obtain sufficiently many instances. Also, while partial matching may incur much more severe input errors than those occurring in full-similarity matching, in many situations, the recovery ability of our algorithm is nearly the same as that in the full-similarity case (up to some constant factor). In a broader sense, our findings suggest that a large class of combinatorial / integer programming problems might be solved perfectly by semidefinite relaxation."
    }, {
      "heading" : "A Alternating Direction Method of Multipliers (ADMM)",
      "text" : "This section presents the procedure for the ADMM algorithm. For notational simplicity, we represent the convex program as follows:\nminimize X 〈W ,X〉 dual variable\nsubject to A(X) = b, yA X ≥ 0, Z ≥ 0 X 0, S 0\nwhere we denote X := [ m 1>\n1 X\n] . The matrices and operators are defined as follows\n(i) W encapsulate all block coefficient matrices W ij for all (i, j) ∈ G; (ii) A(X) = b represents the constraint that Xii = Imi (1 ≤ i ≤ n) and the constraint X = [ m 1>\n1 X\n] ;\n(iii) The variables on the right hand, i.e., yA,Z and S, represent dual variables associated with respective constraints.\nThe Lagrangian associated with the convex program can be given as follows L = 〈 W ,X 〉 + 〈 yA,A(X)− b 〉 − 〈Z,X〉 − 〈 S,X 〉 = 〈 W +A∗(yA)−Z − S,X 〉 − 〈b,yA〉 .\nwhere A∗ denotes the conjugate operator w.r.t. an operator A. The augmented Lagrangian for the convex program can now be written as\nL1/µ = 〈b,yA〉+ 〈 Z + S −W −A∗(yA),X 〉 + 1\n2µ ‖Z + S −W −A∗(yA)‖2F.\nHere, the linear terms above represent the negative standard Lagrangian, whereas the quadratic parts represent the augmenting terms. µ is the penalty parameter that balances the standard Lagrangian and the augmenting terms. The ADMM then proceeds by alternately optimizing each primal and dual variable with others fixed, which results in closed-form solution for each subproblem. Denote by superscript k the iteration number, then we can present the ADMM iterative update procedures as follows\ny (k+1) A = (AA\n∗) −1 { A ( −W + S(k) + µX(k) + Z(k) ) − µb } ,\nZ(k+1) = ( W +A∗ ( y\n(k+1) A\n) − S(k) − µX(k) ) + ,\nS(k+1) = Ppsd ( W +A∗ ( y (k+1) A ) −Z(k+1) − µX(k) ) , (11)\nX (k+1) = X k + 1\nµ\n( Z(k+1) + S(k+1) −W −A∗ ( y\n(k+1) A\n)) (12)\n=− 1 µ Pnsd\n( W +A∗ ( y\n(k+1) A\n) −Z(k+1) − µX(k) ) . (13)\nHere, the operator Ppsd (resp. Pnsd) denotes the projection onto the positive (resp. negative) semidefinite cone, and (·)+ operator projects all entries of a vector / matrix to non-negative values. Within a reasonable amount of time, ADMM typically returns moderately acceptable results."
    }, {
      "heading" : "B Proof of Theorem 1",
      "text" : "The key step to the proof of Theorem 1 is to show that the set of outliers, even when they account for a dominant portion of the input matrix, behave only as a small perturbation to the spectrum of the noncorrupted components. Under the randomized model described in Section 4.1, it can be easily seen that\nthe trimming procedure is not invoked with high probability. Consequently, Theorem 1 can be established through the following lemma.\nLemma 1. Given any set of n permutation matrices P i ∈ Rm×m (1 ≤ i ≤ n), generate a random matrix M via the following procedure.\n1. Generate a symmetric block matrix A = [Aij ]1≤i,j≤n such that\nAii = I, 1 ≤ i ≤ n\nand for all i < j,\nAij =  0, if µij = 0, P iP > j , if νij = 1 and µij = 1,\nU ij , else, (14)\nwhere νij ∼ Bernoulli (p) and µij ∼ Bernoulli (τ) are independent binary variables, and U ij ∈ Rm×m are independent random permutation matrices obeying EU ij = 1m1m · 1 > m.\n2. M is a principal minor of A from rows / columns at indices from a set I ⊆ {1, 2, · · · ,mn}, where each 1 ≤ i ≤ mn is contained in I independently with probability q.\nThen there exist absolute constants c1, c2 > 0 such that if p ≥ c1 log 2(mn) q √ τn\n, one has{ λi (M) ≥ ( 1− 1log(mn) ) τpqn, if 1 ≤ i ≤ m\nλi (M) ≤ c2 √ τn log (mn) < τpqnlog(mn) , if i > m\n(15)\nwith probability exceeding 1− 1m5n5 . Here, λi(M) represents the ith largest eigenvalue of M .\nProof of Lemma 1. Without loss of generality, we assume that P i = Im for all 1 ≤ i ≤ n, since rearranging rows / columns of A does not change its eigenvalues. For convenience of presentation, we write A = Y +Z such that\nY ii = τ ( (1− p) m 1m · 1>m + pIm ) , 1 ≤ i ≤ n\nand for all 1 ≤ i ≤ j ≤ n:\nY ij =  0, if µij = 0, Im, if νij = 1 and µij = 1, U ij , else.\n(16)\nThis means that\nZij = { Im − Y ii, if i = j, 0, else.\n(17)\nApparently, Z is a block diagonal matrix satisfying\n‖Z‖ ≤ 2, (18)\nwhich is only a mild perturbation of Y . This way we have reduced to the case where all blocks (including diagonal blocks) are i.i.d., which is slightly more convenient to analyze.\nDecompose Y into 2 components Y = Y mean + Y var such that\n∀1 ≤ i ≤ j ≤ n : Y meanij = τ (\n(1− p) m\n1m · 1>m + pIm ) , (19)\n∀1 ≤ i ≤ n : Y varii = 0, (20)\nand\n∀1 ≤ i < j ≤ n : Y varij =  −τ ( (1−p) m 1m · 1 > m + pIm ) , if µij = 0, (1− τp) Im − (1−p)m 1m · 1 > m, if νij = 1 and µij = 1, U ij − τ ( (1−p) m 1m · 1 > m + pIm ) , else.\n(21)\nIn other words, Y mean represents the mean component of Y , while Y var comprises all variations around the mean component. It is straightforward to check that\nY mean 0, rank (Y mean) ≤ m+ 1.\nIf we denote by Y meanI the principal minor coming from the rows and columns of Y at indices from I, then from Weyl’s inequality one can easily see that\nλi (M) ≥ λi (Y meanI )− ‖Y var‖ − ‖Z‖ ≥ λi (Y meanI )− ‖Y var‖ − 2, 1 ≤ i ≤ m (22)\nand λi (M) ≤ λi (Y meanI ) + ‖Y var‖+ ‖Z‖ ≤ λi (Y meanI ) + ‖Y var‖+ 2, i > m. (23)\nIn light of this, it suffices to evaluate ‖Y var‖ as well as the eigenvalues of Y meanI . We are now in position to quantify the eigenvalues of Y meanI . Without affecting its eigenvalue distribution, one can rearrange the rows / columns of Y meanI so that\nY meanI (permutation) = τp  1n1 · 1 > n1\n. . . 1nm · 1>nm\n+ τ (1− p) m 1N · 1>N . (24)\nHere, ni (1 ≤ i ≤ m) denotes the cardinality of a set Ii generated by independently sampling n elements each with probability q, and we set N := n1 + · · ·+nm for simplicity. From Bernstein inequality, there exist universal constants c5, c6 > 0 such that if q > c5 log(mn) n , then\n|ni − nq| ≤ c6 √ nq log (mn), 1 ≤ i ≤ m (25)\nholds with probability exceeding 1− (mn)−10. Since Y meanI is positive semidefinite, from (24) one can easily check that all non-zero eigenvalues of Y mean I are also eigenvalues of the following (m+ 1)× (m+ 1) matrix\nY mean I : = τ  √ p1>n1 √ p1>n2 . . .\n√ p1>nm√\n1−p m 1>N\n  √ p1n1 √ p1n2 . . .\n√ p1nm\n√ 1−p m 1N \n= τ  pn1\n√ p(1−p)\nm n1\npn2\n√ p(1−p)\nm n2\n. . . ...\npnm\n√ p(1−p)\nm nm√\np(1−p) m n1\n√ p(1−p)\nm n2 · · ·\n√ p(1−p)\nm nm\n1−p m N\n (26)\n= τqn  p\n√ p(1−p)\nm\n. . . ... p √\np(1−p) m√\np(1−p) m\n· · · √\np(1−p) m\n1− p  ︸ ︷︷ ︸\nY I,0\n+ τ  p∆1\n√ p(1−p)\nm ∆1\n. . . ...\np∆m\n√ p(1−p)\nm ∆m√\np(1−p) m ∆1 · · · √ p(1−p) m ∆m 1−p m ∆N  ︸ ︷︷ ︸\nY I,∆\n, (27)\nwhere ∆i = ni − nq 1 ≤ i ≤ m,\nand ∆N = N − qnm,\nwhich satisfies |∆N | ≤ mmax1≤i≤m |∆i|. By Schur complement condition for positive definite matrices [46], if [ C B\nB> D\n] 0, then C 0 and\nD −B>C−1B 0. Applying this condition to Y I,0 suggests that Y I,0 0 can only hold when\n(1− p)− p (1− p) m 1 p 1>m · 1m > 0,\nwhich however cannot be satisfied since (1− p)− p(1−p)m 1 p1 > m · 1m = 0. Thus, Y I,0 is rank deficient.\nIn fact, all non-zero eigenvalues of Y I,0 can be quantified as well. Specifically, for any vector\nzi := ei − 1\nm [ 1m 0 ] , 1 ≤ i ≤ m− 1,\none can compute Y I,0 · zi = (τqpn) zi, 1 ≤ i ≤ m− 1. (28)\nThat said, τqpn is an eigenvalue of Y I,0 with multiplicity m− 1. On the other hand, we have Y I,0 · [ 1m√ (1−p)m p ] = τqn [ 1m√ (1−p)m p ] , z>i · [ 1m√ (1−p)m\np\n] = 0,\n(29)\nindicating that τqn is another eigenvalue of Y I,0. Putting these together yields\nλi ( Y I,0 ) =  τqn, i = 1\nτpqn, 2 ≤ i ≤ m, 0, i > m.\n(30)\nFurthermore, the residual component Y I,∆ can be bounded as follows\n∥∥Y I,∆∥∥ ≤ τ ∥∥∥∥∥∥∥∥  p∆1 . . .\np∆m 1−p m ∆N\n ∥∥∥∥∥∥∥∥+ τ ∥∥∥∥∥∥∥∥∥∥  0\n√ p(1−p)\nm ∆1\n. . . ... 0 √\np(1−p) m ∆m√ p(1−p)\nm ∆1 · · ·\n√ p(1−p)\nm ∆m 0\n ∥∥∥∥∥∥∥∥∥∥\nF ≤ τ max { p max\n1≤i≤m |∆i| , 1− p m |∆N |\n} + τ √\n2p (1− p) max 1≤i≤m |∆i|\n≤ 2τ max 1≤i≤m\n|∆i| ≤ 2c6τ √ nq log (mn),\nwhere the last inequality follows from (25). This taken collectively with (27) and (30) yields that: when p > 2c6 log\n2(mn)√ nq or, equivalently, when 2c6\n√ nq log (mn) < 1\nlog1.5(mn) npq, one has λi (Y mean I ) ≥ ( 1− 1 log 3 2 (mn) ) τpqn, 1 ≤ i ≤ m,\nλi (Y mean I ) ≤ 2c6τ\n√ nq log (mn) ≤ 1\nlog 3 2 (mn)\nτpqn, i > m. (31)\nFurthermore, observe that EY varij = 0, E ∥∥∥ 12√τY varij ∥∥∥2 ≤ 1, and 12√τ ∥∥Y varij ∥∥ ≤ 1√τ . When τ > 1n , Lemma\n3 yields that ‖Y var‖ ≤ 2c0 √ τn log (mn) (32)\nwith probability at least 1− (mn)−5. Hence, ‖Y var‖ = o (τpqn) if p > c10 log 2 n\nq √ τn for some constant c10 > 0. Finally, the claim follows by substituting (31) and (32) into (22) and (23)."
    }, {
      "heading" : "C Proof of Theorem 2",
      "text" : "To prove Theorem 2, we first analyze the Karush–Kuhn–Tucker (KKT) condition for exact recovery, which provides a sufficient and almost necessary condition for uniqueness and optimality. Valid dual certificates are then constructed to guarantee exact recovery.\nC.1 Preliminaries and Notations Without loss of generality, we can treat Xgt as a sub-matrix of an augmented square matrix Xgtsup such that\nXgtsup := 1 · 1> ⊗ In, (33)\nand\nXgt :=  Π1 Π2 . . .\nΠn\nXgtsup  Π>1 Π>2\n. . . Π>n  , (34) where the matrices Πi ∈ R|Si|×m are defined such that Πi denotes the submatrix of Im coming from its rows at indices from Si. For instance, if Si = {2, 3}, then one has\nΠi = [ 0 1 0 · · · 0 0 0 1 · · · 0 ] .\nWith this notation, ΠiMΠ>j represents a submatrix of M ∈ Rm×m coming from the rows at indices from Si and columns at indices from Sj . Conversely, for any matrix M̃ ∈ R|Si|×|Sj |, the matrix Π>i M̃Πj converts M̃ to an m×m matrix space via zero padding.\nWith this notation, we can represent X in as a submatrix of X insup, which is a corrupted version of X gt sup\nand obeys X inij := Πi ( X insup ) ij Π>j . (35)\nFor notational simplicity, we set\nW ij := { −X inij + λ1 · 1>, if (i, j) ∈ G, λ1 · 1>, else.\n(36)\nBefore continuing to the proof, it is convenient to introduce some notations that will be used throughout. Denote by Ωgt and Ω⊥gt the support of X\ngt and its complement support, respectively, and let PΩgt and PΩ⊥gt represent the orthogonal projection onto the linear space of matrices supported on Ωgt and its complement support Ω⊥gt, respectively. Define Tgt to be the tangent space at X\ngt w.r.t. all symmetric matrices of rank at most m, i.e. the space of symmetric matrices of the form\nTgt :=   Π1 Π2 ...\nΠn\nM + M> [ Π>1 Π>2 · · · Π>n ] : M ∈ Rm×N  , (37)\nand denote by T⊥gt its orthogonal complement. We then denote by PTgt (resp. PT⊥gt ) the orthogonal projection onto Tgt (resp. T⊥gt). In passing, if we define\nΣ := Diag\n{[ n\nn1 , · · · , n nm\n]} , (38)\nthen the columns of\nU := 1√ n  Π1 Π2 ...\nΠn Σ 12 (39) form the set of eigenvectors of Xgt, and for any symmetric matrix M ,\nPT⊥gt (M) = ( I −UU> ) M ( I −UU> ) . (40)\nFurthermore, we define a vector d to be\nd :=  Π1 Π2 ...\nΠn Σ1m. (41) Put another way, if any row index j of Xgt is associated with the element s ∈ [m], then dj = nns . One can then easily verify that 〈\nd · d>,Xgt − 1 m\n1 · 1> 〉 = 〈 d · d>,Xgt 〉 − 1 m ( 1> · d )2 = 0. (42)\nIn fact, when ni’s are sufficiently close to each other, d · d> is a good approximation of 1 · 1>, as claimed in the following lemma. Lemma 2. Consider a set of Bernoulli random variables νi ∼ Bernoulli (p) (1 ≤ i ≤ n), and set s :=∑n i=1 νi. Let ni (1 ≤ i ≤ m) be independent copies of s, and denote N = n1 + · · ·+ nm. If p > c7 log 2(mn) n , then the matrix\nA := (np) 2  1 n1 1n1 1 n2 1n2 ...\n1 nm 1nm  [ 1n1 1>n1 1n2 1>n2 · · · 1nm 1>nm ] (43) satisfies ∥∥∥∥ 1mA− 1m1N · 1>N\n∥∥∥∥ ≤ c8√np log(mn) (44) and ∥∥A− 1N · 1>N∥∥∞ ≤ c9 √ log(mn)\nnp (45)\nwith probability exceeding 1− 1m5n5 , where c7, c8, c9 are some universal constants.\nProof. See Appendix D.1.\nSince p2d · d> is equivalent to A defined in (43) up to row / column permutation, Lemma 2 reveals that∥∥∥∥p2md · d> − 1m1N · 1>N ∥∥∥∥ ≤ c8√np log(mn)\nwith high probability. The following bound on the operator norm of a random block matrix is useful for deriving our main results.\nLemma 3. Let M = [M ij ]1≤i,j≤n be a symmetric block matrix, where M ij’s are jointly independent mi×mj matrices satisfying\nEM ij = 0, E ‖M ij‖2 ≤ 1, and ‖M ij‖ ≤ √ n, (1 ≤ i, j ≤ n). (46)\nBesides, mi ≤ m holds for all 1 ≤ i ≤ n. Then there exists an absolute constant c0 > 0 such that\n‖M‖ ≤ c0 √ n log (mn)\nholds with probability exceeding 1− 1m5n5 .\nProof. See Appendix D.2.\nAdditionally, the second smallest eigenvalue of the Laplacian matrix of a random Erdős–Rényi graph can be bounded below by the following lemma.\nLemma 4. Consider an Erdős–Rényi graph G ∼ G(n, p) and any positive integer m, and let L ∈ Rn×n represent its (unnormalized) Laplacian matrix. There exist absolute constants c3, c4 > 0 such that if p > c3 log 2 (mn) /n, then the algebraic connectivity a (G) of G (i.e. the second smallest eigenvalue of L) satisfies\na (G) ≥ np− c4 √ np log (mn) (47)\nwith probability exceeding 1− 2(mn)5 .\nProof. See Appendix D.3.\nFinally, if we denote by ns (resp. ns,t) the number of sets Si (1 ≤ i ≤ n) containing the element s (resp. containing s and t simultaneously), then these quantities sharply concentrate around their mean values, as stated in the following lemma.\nLemma 5. There are some universal constants c8, c9 > 0 such that if p2set > log(mn) n , then\n|ns − npset| ≤ √ c8npset log (mn), ∀1 ≤ s ≤ m,∣∣ns,t − np2set∣∣ ≤√c8np2set log (mn), ∀1 ≤ s < t ≤ m,\nhold with probability exceeding 1− 1(mn)10 .\nProof. In passing, the claim follows immediately from the Bernstein inequality that\nP (∣∣∣∣∣ n∑ i=1 νi − np ∣∣∣∣∣ > t ) ≤ 2 exp ( −\n1 2 t 2\nnp(1− p) + 13 t ) where νi ∼ Bernoulli(p) are i.i.d. random variables. Interested readers are referred to [47] for a tutorial.\nC.2 Optimality and Uniqueness Condition Recall that ni := |Ii| denotes the number of sets Sj containing the element i. The convex relaxation is exact if one can construct valid dual certificates, as summarized in the following lemma.\nLemma 6. Suppose that there exist dual certificates α > 0, Z = [Zij ]1≤i,j≤n ∈ S N×N and Y = [Y ij ]1≤i,j≤n ∈ SN×N obeying\nY − αdd> 0, (48) PΩgt (Z) = 0, PΩ⊥gt (Z) ≥ 0, (49)\nY ij = W ij −Zij , 1 ≤ i < j ≤ n, (50) Y − αdd> ∈ T⊥gt . (51)\nThen Xgt is the unique solution to MatchLift if either of the following two conditions is satisfied: i) All entries of Zij (∀i 6= j) within the support Ω⊥gt are strictly positive; ii) For all M satisfying PT⊥gt (M) 0,〈\nY − αdd>,PT⊥gt (M) 〉 > 0, (52)\nand, additionally, n\nni +\nn nj 6= n\n2\nninj , 1 ≤ i, j ≤ m. (53)\nProof. See Appendix D.4.\nThat said, to prove Theorem 2, it is sufficient (under the hypotheses of Theorem 2) to generate, with high probability, valid dual certificates Y , Z and α > 0 obeying the optimality conditions of Lemma 6. This is the objective of the next subsection.\nC.3 Construction of Dual Certificates Decompose the input X in into two components X in = X false + Xtrue, where\nXtrue = PΩgt ( X in ) , and X false = PΩ⊥gt ( X in ) . (54)\nThat said, Xtrue (resp. X false) consists of all correct (resp. incorrect) correspondences (i.e. non-zero entries) encoded in X in. This allows us to write\nW ij =\n{ −X falseij + λEij −X true ij + λE ⊥ ij , if (i, j) ∈ G,\nλEij + λE ⊥ ij , else,\n(55)\nwhere E and E⊥ are defined to be\nE := PΩgt ( 1 · 1> ) , and E⊥ := 1 · 1> −E. (56)\nWe propose constructing the dual certificate Y by producing three symmetric matrix components Y true,1, Y true,2, and Y L separately, as follows.\n1. Construction of Zm and Rm. For any β ≥ 0, define αβ to be\nαβ := arg min α:β1·1>−αd·d>≥0 ∥∥∥β1 · 1> − αd · d>∥∥∥ ∞ . (57)\nBy setting β0 := λ− (1−ptrue)pobsm − √ c10pobs log(mn) np3set , we produce Zm and Rm as follows\nZm = PΩ⊥gt\n(( λ− (1− ptrue) pobs\nm\n) 1 · 1> − αβ0d · d > )\n(58)\nand Rm = PΩgt (( λ− (1− ptrue) pobs\nm\n) 1 · 1> − αβ0d · d > )\n(59)\nfor some sufficiently large constant c10 > 0.\n2. Construction of Y true,1 and Y true,2. We set\nY true,1ij =\n{ −Xtrueij +\n(1−ptrue)pobs m Eij , if i < j,∑n\nj=1 ( Xtrueij − (1−ptrue)pobs m Eij ) ΠjΠ > i , if i = j,\nand\nY true,2ij = { Rmij , if i < j, − ∑n j=1 R m ijΠjΠ > i , if i = j.\n1 2 1 3 2 3 4 2 3 1 0 0 0 0 0 0 0 0 0 2 0 0 0 −1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 3 0 −1 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0\n1 2 1 3 2 3 4 2 3 1 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0.5 0 0 0.5 1 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0.5 0 0 0.5 0 2 0 0 0 0.5 0 −0.5 0 0 0 3 0 0.5 0 0 −0.5 0 0 0 0 4 0 0 0 0 0 0 0 0 0 2 0 0 0 0.5 0 0 0 0 −0.5 3 0 0.5 0 0 0 0 0 −0.5 0\n(a) Input Y 0 (b) ZL\nRemark 5. Below is a toy example to illustrate the proposed procedure for constructing ZL. Consider three sets S1 = {1, 2}, S2 = {1, 3}, S3 = {2, 3, 4}, and S4 = {1, 3}. Suppose that Y L,0 only contains two non-zero entries that incorrectly maps elements 1 to 3 in Y L,012 , as illustrated in Fig. 7(a). The resulting Z\nL is shown in Fig. 7(b). Clearly, Y L,0 + ZL obeys Y L,0 + ZL ∈ T⊥gt .\nWith the above construction procedure, one can easily verify that: (1) Y true,1, Y true,2 and Y L are all contained in the space T⊥gt ; (2) PΩgt (Z) = 0; (3) If we set Mm := αβ0d · d >, then for any i 6= j,\nY ij =Y true,1 ij + Y true,2 ij + Y L ij + M m ij\n=−Xtrueij + (1− ptrue) pobs\nm Eij + R\nm ij −X false ij + (1− ptrue) pobs m E⊥ij + Z L ij + M m ij\n=−Xtrueij −X false ij + λ1 · 1> −\n(( λ− (1− ptrue) pobs\nm\n) 1 · 1> −Rmij ) + ZLij + M m ij\n=W ij − ( Zmij −Z L ij ) . (62)\nFurthermore, from Lemma 2 one can obtain\n∥∥∥d · d> − 1 · 1>∥∥∥ ∞ = O\n(√ log (mn)\nnpset\n) .\nThis taken collectively with (57) and the assumption (8) ensures that\nαβ0 = λ− (1− ptrue) pobs\nm −O\n(√ c10pobs log (mn)\nnp3set\n) > 0 (63)\nas long as p3set > c15 log(mn) n for some constant c15 > 0. Consequently, we will establish that Y and Z are valid dual certificates if they satisfy{\nall entries of Zmij −Z L ij (∀i 6= j) within Ω⊥gt are strictly positive; Y true,1 + Y true,2 + Y L 0. (64)\nSuch conditions will be established through the following lemmas.\nLemma 7. There are some universal constants c0, c1 > 0 such that∥∥∥Y L∥∥∥ ≤ c0 √ npobs log (mn)\np2set\nand ∥∥∥ZLij∥∥∥∞ ≤ √ c1pobs log (mn) np3set , 1 ≤ i < j ≤ n\nwith probability exceeding 1− 1(mn)4 .\nProof. See Appendix D.5.\nLemma 8. There are some universal constants c5, c6, c7 > 0 such that if ptruepobspset > c7 log 2(mn) n and\nλ <\n√ pobs log(mn)\npset , then with probability exceeding 1− 1(mn)10 , one has∥∥Y true,2∥∥ ≤ c5√npobs\npset log (mn) ,\nand 〈 vv>,Y true,1 〉 ≥ 1\n2 npsetptruepobs − c6\n√ npsetpobs log (mn)\nfor all unit vector v satisfying vv> ∈ T⊥gt .\nProof. See Appendix D.6.\nCombining Lemmas 7 and 8 yields that there exists an absolute constant c0 > 0 such that if\nptrue > c0 log2 (mn)√ npobsp4set ,\nthen Y = Y true,1 + Y true,2 + Y L 0.\nOn the other hand, observe that all entries of the non-negative matrix Zm lying in the index set Ω⊥gt are bounded below in magnitude by √\nc10pobs log(mn) np3set . For sufficiently large c10, one can conclude that all entries\nof Zmil −Z L il outside Ωgt are strictly positive.\nSo far we have justified that Y and Z satisfy (64), thereby certifying that the proposed algorithm correctly recovers the ground-truth matching."
    }, {
      "heading" : "D Proofs of Auxiliary Lemmas",
      "text" : "D.1 Proof of Lemma 2 Denote by A := 1N · 1TN . From Bernstein inequality, ni sharply concentrates around np such that if p > c6 log\n2(mn) n\n|ni − np| ≤ c5 √ np log(mn), ∀1 ≤ i ≤ m (65)\nwith probability exceeding 1− (mn)−10, where c5, c6 > 0 are some absolute constants. The bound (65) also implies that∥∥∥∥∥∥∥∥∥I −  np n1 np n2\n. . . np nm\n ∥∥∥∥∥∥∥∥∥ ≤ max1≤i≤m |ni − np| ni ≤ c5 √ np log(mn) np− c5 √ np log(mn)\n≤ 2c5\n√ log(mn)\nnp .\nSimilarly, one has |N − nmp| ≤ c5 √ pmn log(mn)\nwith probability exceeding 1− (mn)−10, which implies that∥∥A∥∥ = N ≤ nmp+ c5√pmn log(mn) < 2nmp. Rewrite A as\nA :=  np n1 Diag (1n1)\n. . . np nm Diag (1nm)\n ·A ·  np n1 Diag (1n1)\n. . . np nm Diag (1nm)\n .\nThis allows us to bound the deviation of A from A as follows ∥∥A−A∥∥ ≤ ∥∥∥∥∥∥∥A−  np n1 Diag (1n1)\n. . . np nm Diag (1nm)\nA ∥∥∥∥∥∥∥+ ∥∥∥∥∥∥∥  np n1 Diag (1n1)\n. . . np nm Diag (1nm)\nA−A ∥∥∥∥∥∥∥\n≤  ∥∥∥∥∥∥∥  np n1 Diag (1n1)\n. . . np nm Diag (1nm)\n ∥∥∥∥∥∥∥+ 1 ∥∥A∥∥ ∥∥∥∥∥∥∥I −  np n1 Diag (1n1)\n. . . np nm Diag (1nm)\n ∥∥∥∥∥∥∥\n≤ ( 1 + c5 √ log(mn)\nnp + 1\n) 2nmp · 2c5 √ log(mn)\nnp ≤ c6m √ np log(mn)\nfor some universal constant c6 > 0. On the other hand, it follows immediately from (65) that\n∥∥A− 1 · 1>∥∥∞ = max1≤i,j≤m ∣∣∣∣∣ (np)2ninj − 1 ∣∣∣∣∣ = max1≤i,j≤m ∣∣∣∣pn (pn− nj) + (pn− ni)njninj ∣∣∣∣ ≤ max\n1≤i,j≤m ∣∣∣pn+ c5√np log(mn)∣∣∣( pn− c5 √ np log(mn)\n)2 c5√np log(mn) ≤ c9 √ log(mn)\nnp\nfor some absolute constant c9 > 0.\nD.2 Proof of Lemma 3 The norm of M can be bounded via the moment method, which attempts to control tr(Mk) for some even integer k. See [48, Section 2.3.4] for a nice introduction.\nSpecifically, observe that Etr(Mk) can be expanded as follows\nEtr ( Mk ) = ∑ 1≤i1,··· ,ik≤n Etr (M i1i2M i2i3 · · ·M iki1) ,\na trace sum over all k-cycles in the vertex set {1, · · · , n}. Note that (i, i) are also treated as valid edges. For each term Etr(M i1i2M i2i3 · · ·M iki1), if there exists an edge occurring exactly once, then the term vanishes due to the independence assumption. Thus, it suffices to examine the terms in which each edge is repeated at least twice. Consequently, there are at most k/2 relevant edges, which span at most k/2+1 distinct vertices. We also need to assign vertices to k/2 edges, which adds up to no more than (k/2)k different choices.\nBy following the same procedure and notation as adopted in [48, Page 119], we divide all non-vanishing k-cycles into (k/2)k classes based on the above labeling order; each class is associated with j (1 ≤ j ≤ k/2) edges e1, · · · , ej with multiplicities a1, · · · , aj , where (e1, · · · , a1, · · · , aj) determines the class of cycles and a1 + · · ·+ aj = k. Since there are at most nj+1 distinct vertices, one can see that no more than nj+1 cycles falling within this particular class. For notational simplicity, set K = √ n, and hence ‖M ij‖ ≤ K. By assumption (46), one has\nEtr (M i1i2M i2i3 · · ·M iki1) ≤ mE ( ‖M e1‖ a1 · · · ∥∥M ej∥∥aj)\n≤ mE ‖M e1‖ 2 · · ·E ∥∥M ej∥∥2Ka1−2 · · ·Kaj−2 ≤ mKk−2j .\nThus, the total contribution of this class does not exceed\nmnj+1Kk−2j = mn k 2 +1.\nBy summing over all classes one obtains the crude bound\nEtr ( Mk ) ≤ m ( k\n2\n)k n k 2 +1,\nwhich follows that\nE ‖M‖k ≤ Etr ( Mk ) ≤ m ( k\n2\n)k n k 2 +1.\nIf we set k = log (mn), then from Markov’s inequality we have\nP ( ‖M‖ ≥ k\n2 n\n1 2 + 1 k (mn) 5 k m 1 k ) ≤ E ‖M‖\nk( k 2n 1 2 + 1 k (mn) 5 k m 1 k\n)k ≤ m ( k 2 )k n k 2 +1\nm ( k 2 )k n k 2 +1 (mn) 5 ≤ 1 (mn) 5 .\nSince n 1 log n = O (1), there exists a constant c0 > 0 such that\nP ( ‖M‖ ≥ c0n 1 2 log (mn) ) ≤ 1 m5n5 ,\nwhich completes the proof.\nD.3 Proof of Lemma 4 When G ∼ G(n, p), the adjacency matrixA consists of independent Bernoulli components (except for diagonal entries), each with mean p and variance p(1− p). Lemma 3 immediately implies that if p > 2 log(mn)n , then\n1√ p(1− p) ∥∥A− p1n · 1>n ∥∥ ≤ c0√n log (mn) + 1 (66) with probability at least 1− (mn)−5. That said, there exists an absolute constant c1 > 0 such that∥∥A− p1n · 1>n ∥∥ ≤ c1√pn log (mn) (67) with probability exceeding 1− (mn)−5.\nOn the other hand, from Bernstein inequality, the degree of each vertex exceeds dmin := pn− c2 √ pn log (mn) (68)\nwith probability at least 1 − (mn)−10, where c2 is some constant. When p > 2 log(mn)n , G is connected, and hence the least eigenvalue of L is zero with the eigenvector 1n. This taken collectively with (67) and (68) suggests that when p > c 2 3 log\n2(mn) n , one has\na (G) ≥ dmin − ∥∥A− p1n · 1>n ∥∥ ≥ pn− c3√pn log (mn)\nwith high probability.\nD.4 Proof of Lemma 6 Suppose that Xgt + H is the solution to MatchLift for some perturbation H 6= 0. By Schur complement\ncondition for positive definiteness, the feasibility constraint [ m 1>\n1 Xgt + H\n] 0 is equivalent to\n{ Xgt + H 0, Xgt + H − 1m1 · 1 > 0,\nwhich immediately yields PT⊥gt (H) = ( I −UU> ) ( Xgt + H ) ( I −UU> ) 0, (69) and 〈 d · d>,H 〉 = 〈 d · d>,Xgt − 1\nm 1 · 1> + H\n〉 ≥ 0. (70)\nThe above inequalities follow from the facts PT⊥gt ( Xgt ) = 0 and 〈 d · d>,Xgt − 1m1 · 1 > 〉\n= 0. From Assumption (51), one can derive〈\nY − αd · d>,PT⊥gt (H) 〉 + 〈 αd · d>,H 〉 = 〈 Y − αd · d>,H 〉 + 〈 αd · d>,H 〉 = 〈Y ,H〉 =\n∑ i 6=j 〈Y ij ,Hij〉 . (71)\nThis allows us to bound 〈 Y − αd · d>,PT⊥gt (H) 〉 + ∑ i6=j 〈Zij ,Hij〉\n≤ 〈 Y − αd · d>,PT⊥gt (H) 〉 + 〈 αd · d>,H 〉 + ∑ i 6=j 〈Zij ,Hij〉 (72)\n= ∑ i 6=j 〈Y ij ,Hij〉+ ∑ i 6=j 〈Zij ,Hij〉 (73)\n= ∑ i 6=j 〈W ij ,Hij〉 , (74)\nwhere the first inequality follows from (70), and the last equality follows from Assumption (50). In order to preclude the possibility that Xgt + H is the solution to MatchLift, we need to show that∑ i 6=j 〈W ij ,Hij〉 > 0. From (74) it suffices to establish that〈\nY − αd · d>,PT⊥gt (H) 〉 + ∑ i6=j 〈Zij ,Hij〉 > 0 (75)\nfor any feasible H 6= 0. In fact, since Y − αd · d> and PT⊥gt (H) are both positive semidefinite, one must have 〈\nY − αd · d>,PT⊥gt (H) 〉 ≥ 0. (76)\nOn the other hand, the constraints\nsupp (Z) ⊆ Ω⊥gt, PΩ⊥gt (Z) ≥ 0, and PΩ⊥gt (H) ≥ 0\ntaken together imply that ∑ i 6=j 〈Zij ,Hij〉 ≥ 0. (77)\nPutting (76) and (77) together gives〈 Y − αd · d>,PT⊥gt (H) 〉 + ∑ i 6=j 〈Zij ,Hij〉 ≥ 0.\nComparing this with (75), we only need to establish either 〈 Y − αd · d>,PT⊥gt (H) 〉 > 0 or ∑ i6=j 〈Zij ,Hij〉 > 0.\ni) Suppose first that all entries of Zij (∀i 6= j) in the support Ω⊥gt are strictly positive. If the identity∑ i 6=j 〈Zij ,Hij〉 = 0 holds, then the strict positivity assumption of Zij on Ω⊥gt as well as the constraint PΩ⊥gt (H) ≥ 0 immediately leads to PΩ⊥gt (H) = 0.\nBesides, the feasibility constraint requires that PΩgt (Hij) ≤ 0. If PΩgt (Hij) 6= 0, then all non-zero entries of Hij are negative, and hence 〈\nd · d>,H 〉 = 〈 d · d>,PΩgt (H) 〉 < 0,\nwhich follows since all entries of d are strictly positive. This contradicts with (70). Consequently, we must either have H = 0 or ∑ i 6=j 〈Zij ,Hij〉 > 0. This together with (75) establishes the claim.\nii) Next, we prove the claim under Assumptions (52) and (53). In fact, Assumption (52) together with (69) asserts that 〈 Y ,PT⊥gt (H) 〉 ≤ 0 can only occur if PT⊥gt (H) = 0. This necessarily leads to H = 0, as claimed by Lemma 9.\nLemma 9. Suppose that Xgt + H is feasible for MatchLift, and assume that\nn ni + n nj 6= n\n2\nninj , ∀1 ≤ i, j ≤ m. (78)\nIf PT⊥gt (H) = 0, then one has H = 0.\nProof. See Appendix D.7.\nIn summary, we can conclude that Xgt is the unique optimizer in both cases.\nD.5 Proof of Lemma 7 First, we would like to bound the operator norm of Y L. Since each randommatrixX inijI{Xinij is observed and corrupted} is independently drawn with mean (1−ptrue)pobsm 1 · 1 >, it is straightforward to see that\nEY L,0 = E ( −X false + (1− ptrue) pobs m E⊥ ) = 0.\nBy observing that ZL is constructed as a linear transform of Y L,0, one can also obtain\nEZL = 0, ⇒ EY L = EZL + EY L,0 = 0. Thus, it suffices to examine the deviation of ∥∥∥Y L∥∥∥ incurred by the uncertainty of X false.\nDenote by Ai,j ∈ RN×N the component of ZL generated due to the (i, j)th block −X falseij , which clearly satisfies\nZL = Ai,j − EAi,j .\nFor each non-zero entry of X falseij , if it encodes an incorrect correspondence between elements s and t, then it will affect no more than 6ns,t entries in Ai,j , where each of these entries are affected in magnitude by an amount at most 1ns,t . Recall that ns,t represents the number of sets Si (1 ≤ i ≤ n) containing s and t\nsimultaneously, which sharply concentrates within [ np2set ±O (√ np2set log (mn) )] as asserted in Lemma 5. As a result, the sum of squares of these affected entries is bounded by\n6ns,t n2s,t = O\n( 1\nns,t\n) . (79)\nMoreover, since each row / column of X falseij can have at most one non-zero entry, we can rearrange A i,j with row / column permutation such that Ai,j becomes a block-diagonal matrix, where the components\naffected by different entries of X falseij are separated into distinct diagonal blocks. This together with (79) leads to ∥∥Ai,j∥∥ ≤ ∥∥Ai,j∥∥\nF ≤ max\ns 6=t\n√ 8\nns,t ,\nand hence ∥∥∥EAi,j (Ai,j)>∥∥∥ ≤ pobs(max s6=t √ 8\nns,t\n)2 ≤ c16pobs\nnp2set\nfor some absolute constant c16 > 0, where the last inequality follows from Lemma 5. Observe that Ai,j − EAi,j (i 6= j) are independently generated with mean zero, whose operator norm\nis bounded above by 2 maxs 6=t √\n8 ns,t . Applying the matrix Bernstein inequality [49, Theorem 1.4] suggests\nthat there exist universal constants c5, c6 > 0 such that for any t = O ( √ npoly log (mn)),\nP ∥∥∥∥∥∥ ∑\n(i,j)∈G\nAi,j − EAi,j ∥∥∥∥∥∥ > t  ≤ n2 exp − 12 t2\nn2 ( c16pobs np2set ) + 2 maxs 6=t √ 8 ns,t 3  . Put in another way, there exists a universal constant c6 > 0 such that∥∥∥ZL∥∥∥ =\n∥∥∥∥∥∥ ∑ i 6=j Ai,j − EAi,j ∥∥∥∥∥∥ < c6 √ npobs p2set log (mn) (80)\nholds with probability exceeding 1− 1(mn)10 . This follows from Lemma 5. Additionally, observe that EY L,0ij = 0 and∥∥∥∥ 1√pobsY L,0ij\n∥∥∥∥ ≤ √n as long as pobs > 1n . Applying Lemma 3 suggests that∥∥∥Y L,0∥∥∥ < c0√npobs log (mn) with probability at least 1− 1(mn)5 . This combined with (80) yields∥∥∥Y L∥∥∥ ≤ ∥∥∥Y L,0∥∥∥+ ∥∥∥ZL∥∥∥ < c11 √ npobs log (mn)\np2set\nwith probability at least 1− 3(mn)5 , where c11 is some universal constant. On the other hand, for each (s, t) entry of ZLil (i 6= l), it can only be affected by those observed blocks X falseij (or X false jl ) satisfying t ∈ Sj (or s ∈ Sj). Consequently, each entry of Z L il can be expressed as a sum of Θ (npsetpobs) zero-mean independent variables, each of them being bounded in magnitude by 1(mins 6=t ns,t) . From Hoeffding’s inequality one can derive\nP (∥∥∥ZLil∥∥∥∞ > t) ≤ m2P − t2c7npsetpobs 1( min s 6=t ns,t )2  ≤ m2P ( − t 2 c̃7pobs 1 np3set )\nfor some constants c7, c̃7 > 0, indicating that∥∥∥ZLil∥∥∥∞ ≤ √ c8pobs log (mn) np3set , ∀i 6= l\nwith probability exceeding 1− 1 (mn)10 .\nD.6 Proof of Lemma 8 By construction of Y true,1, one can see that all non-zero entries lie within the support Ωgt. One important feature of Xgtij is that it can be converted, via row / column permutation, into a block diagonal matrix that consists of m all-one blocks, where the ith block is of size ni (1 ≤ i ≤ m). From Lemma 5, one has\nni ∈ [ npset ± √ c8npset log (mn) ] , 1 ≤ i ≤ m\nwith high probability. Thus, Y true,1 can also be rearranged such that its non-zero entries form m disjoint diagonal blocks. We will quantify the eigenvalues of Y true,1 by bounding the spectrum of each of these matrix blocks.\nWe first decompose the matrix Y true,1 into two parts Y true,1 and Ỹ true,1 such that\n∀i 6= j, Y true,1ij =\n{ −X inij , if X in ij is observed and not corrupted,\n0, else;\nand\n∀i 6= j, Y true,1ij =\n{ −X inij + (1−ptrue)pobs m , if X in ij is observed and corrupted,\n(1−ptrue)pobs m , else.\nThat said, Y true,1 ij consists of all non-corrupted components, while Ỹ true,1\nconsists of all “debiased” random outliers.\nBy Lemma 4, one can verify that for all unit vector v such that vv> ∈ T⊥gt ,〈 vv>,Y true,1 〉 ≥ min\n1≤s≤m (nsptruepobs − c4\n√ nspobs log (mn))\n≥ 1 2 npsetptruepobs − c5 √ npsetpobs log (mn) (81)\nfor some absolute constant c5 > 0, where the second inequality follows from the concentration result stated in Lemma 5.\nIn addition, each entry of Ỹ true,1 ij (i 6= j) lying in the support Ωgt has mean zero and variance (1−ptrue)pobs\nm\n( 1− (1−ptrue)pobsm ) .\nLemma 3 then suggests that the norm of each non-zero block of Ỹ true,1\n(the ones with size ni) is bounded above by O (√ pobsni log (nm) ) . As a result,∥∥∥Ỹ true,1∥∥∥ ≤ c15 max\n1≤s≤m\n√ pobsns log (nm) < c̃15 √ npsetpobs log (nm) .\nThis taken collectively with (81) yields that〈 vv>,Y true,1 〉 ≥ 1\n2 npsetptruepobs − (c5 + c̃15)\n√ npsetpobs log (mn) . (82)\nOn the other hand, we know from the construction procedure and Lemma 2 that\n‖Rm‖∞ ≤\n√ c10pobs log (mn)\nnp3set + λ ∥∥∥d · d> − 1 · 1>∥∥∥ ∞\n≤ c̃10\n(√ pobs log (mn)\nnp3set +\n√ pobs log (mn)\npset\n√ log (mn)\nnpset\n)\n≤ 2c̃10 √\npobs np3set log (mn)\nfor some constants c10, c̃10 > 0. Since Rm ∈ Ωgt, we can also rearrange Rm into m diagonal blocks each of size ni (1 ≤ i ≤ m). Hence, a crude upper bound yields∥∥Y true,2∥∥ ≤ ∥∥Y true,2∥∥ 1 ≤ (\nmax 1≤i≤m ni\n)( 2c̃10 √ pobs np3set log (mn) ) ≤ c11npset √ npobs p3set log (mn)\n= c11n √ npobs pset log (mn)\nfor some universal constant c11 > 0.\nD.7 Proof of Lemma 9 Define an augmented matrix Hsup such that\nHsupij = Π > i HijΠj . (83)\nRecall that ni denotes the number of sets containing element i, and that\nΣ :=  n n1 n n2\n. . . n nm  . The assumption that PT⊥gt (H) = 0 can be translated into(\nI − 1 n\n(1n ⊗ Im) Σ (1n ⊗ Im) ) Hsup ( I − 1\nn (1n ⊗ Im) Σ (1n ⊗ Im)\n) = 0.\nWe can easily compute that\nHsupii −ΣH sup ·i −H sup i· Σ + ΣH sup ·· Σ = 0, 1 ≤ i ≤ n,\nwhere  H sup ·i := 1 n ∑n j=1 H sup ji , H sup i· := 1 n ∑n j=1 H sup ij ,\nH sup\n·· := 1 n2 ∑n i=1 ∑n j=1 H sup ij .\nThis combined with the identity Hii = 0 (and hence H sup ii = 0) yields\nΣH sup ·· Σ = ΣH sup ·i + H sup i· Σ, 1 ≤ i ≤ n.\nSumming over all i leads to\nΣH sup\n·· Σ = Σ\n( 1\nn n∑ i=1 H sup ·i\n) + ( 1\nn n∑ i=1 H sup i·\n) Σ = ΣH sup\n·· + H sup ·· Σ.\nExpanding it yields n2\nninj\n( H sup\n·· ) i,j = ( n ni + n nj )( H sup ·· ) i,j , 1 ≤ i, j ≤ m.\nFrom our assumption that n 2\nninj 6= nni + n nj , we can derive\nH sup\n·· = 0. (84)\nDue to the feasibility constraint, all diagonal entries of Hsupij are non-positive, and all off-diagonal entries of Hsupij are non-negative. These conditions together with (84) establish that H = 0."
    } ],
    "references" : [ {
      "title" : "A probabilistic image jigsaw puzzle solver",
      "author" : [ "T.S. Cho", "S. Avidan", "W.T. Freeman" ],
      "venue" : "IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2010, pp. 183–190.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "A global approach to automatic solution of jigsaw puzzles",
      "author" : [ "D. Goldberg", "C. Malon", "M. Bern" ],
      "venue" : "Comput. Geom. Theory Appl., vol. 28, pp. 165–174, June 2004.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Disambiguating visual relations using loop constraints",
      "author" : [ "C. Zach", "M. Klopschitz", "M. Pollefeys" ],
      "venue" : "IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2010, pp. 1426–1433.",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Discrete-continuous optimization for largescale structure from motion",
      "author" : [ "D. Crandall", "A. Owens", "N. Snavely", "D. Huttenlocher" ],
      "venue" : "IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2011, pp. 3001–3008.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Reassembling fractured objects by geometric matching",
      "author" : [ "Q.-X. Huang", "S. Flöry", "N. Gelfand", "M. Hofer", "H. Pottmann" ],
      "venue" : "ACM Transactions on Graphics (TOG), vol. 25, no. 3. ACM, 2006, pp. 569–578.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Globally consistent reconstruction of ripped-up documents",
      "author" : [ "L. Zhu", "Z. Zhou", "D. Hu" ],
      "venue" : "IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 30, no. 1, pp. 1–13, 2008.",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Mitochondrial DNA as a genomic jigsaw puzzle",
      "author" : [ "W. Marande", "G. Burger" ],
      "venue" : "Science, vol. 318, no. 5849, pp. 415–415, 2007.",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Structure from motion for scenes with large duplicate structures",
      "author" : [ "R. Roberts", "S.N. Sinha", "R. Szeliski", "D. Steedly" ],
      "venue" : "IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2011, pp. 3137–3144.",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "An optimization approach to improving collections of shape maps",
      "author" : [ "A. Nguyen", "M. Ben-Chen", "K. Welnicka", "Y. Ye", "L. Guibas" ],
      "venue" : "Computer Graphics Forum, vol. 30, no. 5. Wiley Online Library, 2011, pp. 1481–1491.",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "An optimization approach for extracting and encoding consistent maps in a shape collection",
      "author" : [ "Q. Huang", "G. Zhang", "L. Gao", "S. Hu", "A. Butscher", "L. Guibas" ],
      "venue" : "ACM Transactions on Graphics, vol. 31, no. 6, p. 167, 2012.",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Exploring collections of 3d models using fuzzy correspondences",
      "author" : [ "V. Kim", "W. Li", "N. Mitra", "S. DiVerdi", "T. Funkhouser" ],
      "venue" : "ACM SIGGRAPH, 2012.",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Consistent shape maps via semidefinite programming",
      "author" : [ "Q. Huang", "L. Guibas" ],
      "venue" : "Computer Graphics Forum, vol. 32, no. 5, pp. 177–186, 2013.",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Probabilistic subgraph matching based on convex relaxation",
      "author" : [ "C. Schellewald", "C. Schnörr" ],
      "venue" : "Energy minimization methods in computer vision and pattern recognition. Springer, 2005, pp. 171–186.",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Balanced graph matching",
      "author" : [ "T. Cour", "P. Srinivasan", "J. Shi" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS), 2007.",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Learning graph matching",
      "author" : [ "T.S. Caetano", "J.J. McAuley", "L. Cheng", "Q.V. Le", "A.J. Smola" ],
      "venue" : "IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 31, no. 6, pp. 1048–1058, 2009.",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Solving the multi-way matching problem by permutation synchronization.",
      "author" : [ "D. Pachauri", "R. Kondor", "V. Singh" ],
      "venue" : "Advanced in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2013
    }, {
      "title" : "Exact and stable recovery of rotations for robust synchronization",
      "author" : [ "L. Wang", "A. Singer" ],
      "venue" : "arxiv:1211.2441, 2013.",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Global registration of multiple point clouds using semidefinite programming",
      "author" : [ "K. Chaudhury", "Y. Khoo", "A. Singer", "D. Cowburn" ],
      "venue" : "arXiv:1306.5226, 2013. 34",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Exact matrix completion via convex optimization",
      "author" : [ "E.J. Candes", "B. Recht" ],
      "venue" : "Foundations of Computational Mathematics, vol. 9, no. 6, pp. 717–772, April 2009.",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Matrix completion from a few entries",
      "author" : [ "R.H. Keshavan", "A. Montanari", "S. Oh" ],
      "venue" : "IEEE Transactions on Information Theory, vol. 56, no. 6, pp. 2980–2998, 2010.",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Robust principal component analysis?",
      "author" : [ "E.J. Candès", "X. Li", "Y. Ma", "J. Wright" ],
      "venue" : "Journal of ACM,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2011
    }, {
      "title" : "Rank-sparsity incoherence for matrix decomposition",
      "author" : [ "V. Chandrasekaran", "S. Sanghavi", "P. Parrilo", "A.S. Willsky" ],
      "venue" : "SIAM Journal on Optimization, vol. 21, no. 2, 2011.",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Robust pca via outlier pursuit",
      "author" : [ "H. Xu", "C. Caramanis", "S. Sanghavi" ],
      "venue" : "Advances on Neural Information Processing Systems (NIPS), 2010.",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Dense error correction for low-rank matrices via principal component pursuit",
      "author" : [ "A. Ganesh", "J. Wright", "X. Li", "E.J. Candes", "Y. Ma" ],
      "venue" : "IEEE International Symposium on Information Theory Proceedings (ISIT), 2010, pp. 1513–1517.",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Low-rank matrix recovery from errors and erasures",
      "author" : [ "Y. Chen", "A. Jalali", "S. Sanghavi", "C. Caramanis" ],
      "venue" : "IEEE Transactions on Information Theory, vol. 59, no. 7, pp. 4324–4337, July 2013.",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Jointly clustering rows and columns of binary matrices: Algorithms and trade-offs",
      "author" : [ "J. Xu", "R. Wu", "K. Zhu", "B. Hajek", "R. Srikant", "L. Ying" ],
      "venue" : "arxiv:1310.0512, 2013.",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Correlation clustering",
      "author" : [ "N. Bansal", "A. Blum", "S. Chawla" ],
      "venue" : "Machine Learning, vol. 56, no. 1-3, pp. 89–113, 2004.",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Correlation clustering with noisy input",
      "author" : [ "C. Mathieu", "W. Schudy" ],
      "venue" : "ACM-SIAM SODA, 2010, pp. 712–728.",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Clustering partially observed graphs via convex optimization",
      "author" : [ "A. Jalali", "Y. Chen", "S. Sanghavi", "H. Xu" ],
      "venue" : "International Conf. on Machine Learning (ICML), 2011.",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Clustering sparse graphs",
      "author" : [ "Y. Chen", "S. Sanghavi", "H. Xu" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS), 2012.",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Clustering using max-norm constrained optimization",
      "author" : [ "A. Jalali", "N. Srebro" ],
      "venue" : "International Conference on Machine Learning (ICML), June 2012.",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Breaking the small cluster barrier of graph clustering",
      "author" : [ "N. Ailon", "Y. Chen", "X. Huan" ],
      "venue" : "International Conference on Machine Learning (2013), 2013.",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Matrix completion from noisy entries",
      "author" : [ "R.H. Keshavan", "A. Montanari", "S. Oh" ],
      "venue" : "Journal of Machine Learning Research, vol. 99, pp. 2057–2078, 2010.",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Phase-only matched filtering",
      "author" : [ "J.L. Horner", "P.D. Gianino" ],
      "venue" : "Applied optics, vol. 23, no. 6, pp. 812–816, 1984.",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 1984
    }, {
      "title" : "Angular synchronization by eigenvectors and semidefinite programming",
      "author" : [ "A. Singer" ],
      "venue" : "Applied and computational harmonic analysis, vol. 30, no. 1, pp. 20–36, 2011.",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Multireference alignment using semidefinite programming",
      "author" : [ "A.S. Bandeira", "M. Charikar", "A. Singer", "A. Zhu" ],
      "venue" : "Conference on Innovations in Theoretical Computer Science, 2014, pp. 459–470.",
      "citeRegEx" : "36",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Alternating direction augmented lagrangian methods for semidefinite programming",
      "author" : [ "Z. Wen", "D. Goldfarb", "W. Yin" ],
      "venue" : "Mathematical Programming Computation, vol. 2, no. 3-4, pp. 203–230, 2010.",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Random graph dynamics",
      "author" : [ "R. Durrett" ],
      "venue" : "Cambridge university press,",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2007
    }, {
      "title" : "A performance evaluation of local descriptors",
      "author" : [ "K. Mikolajczyk", "C. Schmid" ],
      "venue" : "IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 27, no. 10, pp. 1615–1630, 2005. 35",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "A spectral technique for correspondence problems using pairwise constraints",
      "author" : [ "M. Leordeanu", "M. Hebert" ],
      "venue" : "IEEE International Conference on Computer Vision (ICCV), vol. 2, 2005, pp. 1482–1489.",
      "citeRegEx" : "40",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Distinctive image features from scale-invariant keypoints",
      "author" : [ "D.G. Lowe" ],
      "venue" : "International journal of computer vision, vol. 60, no. 2, pp. 91–110, 2004.",
      "citeRegEx" : "41",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Random sample consensus: a paradigm for model fitting with applications to image analysis and automated cartography",
      "author" : [ "M.A. Fischler", "R.C. Bolles" ],
      "venue" : "Commun. ACM, vol. 24, no. 6, pp. 381–395, Jun. 1981.",
      "citeRegEx" : "42",
      "shortCiteRegEx" : null,
      "year" : 1981
    }, {
      "title" : "Non-rigid dense correspondence with applications for image enhancement",
      "author" : [ "Y. HaCohen", "E. Shechtman", "D. Goldman", "D. Lischinski" ],
      "venue" : "ACM Trans. Graph., vol. 30, no. 4, pp. 70:1–70:10, Jul. 2011.",
      "citeRegEx" : "43",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Dense correspondence finding for parametrization-free animation reconstruction from video.",
      "author" : [ "N. Ahmed", "C. Theobalt", "C. Rossl", "S. Thrun", "H. Seidel" ],
      "venue" : null,
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 2008
    }, {
      "title" : "Unsupervised learning for graph matching",
      "author" : [ "M. Leordeanu", "R. Sukthankar", "M. Hebert" ],
      "venue" : "International journal of computer vision, vol. 96, no. 1, pp. 28–45, 2012.",
      "citeRegEx" : "45",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "The probabilistic method (3rd Edition)",
      "author" : [ "N. Alon", "J.H. Spencer" ],
      "venue" : null,
      "citeRegEx" : "47",
      "shortCiteRegEx" : "47",
      "year" : 2008
    }, {
      "title" : "Topics in random matrix theory",
      "author" : [ "T. Tao" ],
      "venue" : "AMS Bookstore,",
      "citeRegEx" : "48",
      "shortCiteRegEx" : "48",
      "year" : 2012
    }, {
      "title" : "User-friendly tail bounds for sums of random matrices",
      "author" : [ "J.A. Tropp" ],
      "venue" : "Foundations of Computational Mathematics, vol. 12, no. 4, pp. 389–434, 2012. 36",
      "citeRegEx" : "49",
      "shortCiteRegEx" : null,
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "A partial list includes jigsaw puzzle solving [1, 2], structure from motion [3, 4], re-assembly of fragmented objects and documents [5, 6], and DNA/RNA shotgun assembly sequencing [7].",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 1,
      "context" : "A partial list includes jigsaw puzzle solving [1, 2], structure from motion [3, 4], re-assembly of fragmented objects and documents [5, 6], and DNA/RNA shotgun assembly sequencing [7].",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 2,
      "context" : "A partial list includes jigsaw puzzle solving [1, 2], structure from motion [3, 4], re-assembly of fragmented objects and documents [5, 6], and DNA/RNA shotgun assembly sequencing [7].",
      "startOffset" : 76,
      "endOffset" : 82
    }, {
      "referenceID" : 3,
      "context" : "A partial list includes jigsaw puzzle solving [1, 2], structure from motion [3, 4], re-assembly of fragmented objects and documents [5, 6], and DNA/RNA shotgun assembly sequencing [7].",
      "startOffset" : 76,
      "endOffset" : 82
    }, {
      "referenceID" : 4,
      "context" : "A partial list includes jigsaw puzzle solving [1, 2], structure from motion [3, 4], re-assembly of fragmented objects and documents [5, 6], and DNA/RNA shotgun assembly sequencing [7].",
      "startOffset" : 132,
      "endOffset" : 138
    }, {
      "referenceID" : 5,
      "context" : "A partial list includes jigsaw puzzle solving [1, 2], structure from motion [3, 4], re-assembly of fragmented objects and documents [5, 6], and DNA/RNA shotgun assembly sequencing [7].",
      "startOffset" : 132,
      "endOffset" : 138
    }, {
      "referenceID" : 6,
      "context" : "A partial list includes jigsaw puzzle solving [1, 2], structure from motion [3, 4], re-assembly of fragmented objects and documents [5, 6], and DNA/RNA shotgun assembly sequencing [7].",
      "startOffset" : 180,
      "endOffset" : 183
    }, {
      "referenceID" : 2,
      "context" : "Such criterion has recently been invoked in many algorithms [3,8–11] to detect outliers among the pairwise input maps.",
      "startOffset" : 60,
      "endOffset" : 68
    }, {
      "referenceID" : 7,
      "context" : "Such criterion has recently been invoked in many algorithms [3,8–11] to detect outliers among the pairwise input maps.",
      "startOffset" : 60,
      "endOffset" : 68
    }, {
      "referenceID" : 8,
      "context" : "Such criterion has recently been invoked in many algorithms [3,8–11] to detect outliers among the pairwise input maps.",
      "startOffset" : 60,
      "endOffset" : 68
    }, {
      "referenceID" : 9,
      "context" : "Such criterion has recently been invoked in many algorithms [3,8–11] to detect outliers among the pairwise input maps.",
      "startOffset" : 60,
      "endOffset" : 68
    }, {
      "referenceID" : 10,
      "context" : "Such criterion has recently been invoked in many algorithms [3,8–11] to detect outliers among the pairwise input maps.",
      "startOffset" : 60,
      "endOffset" : 68
    }, {
      "referenceID" : 11,
      "context" : "Recent work by [12] provided the first theoretical guarantee for robust and consistent joint matching.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 11,
      "context" : "[12]) did not provide theoretical support when more than 50% of the input matches are corrupted.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "While [12] considered incomplete inputs, the tradeoff between the undersampling factor and the error-correction ability remains unknown.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 12,
      "context" : "[13–15]).",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 13,
      "context" : "[13–15]).",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 14,
      "context" : "[13–15]).",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 8,
      "context" : "[9–12], which exploited the global cycle-consistency criterion to prune noisy maps.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 9,
      "context" : "[9–12], which exploited the global cycle-consistency criterion to prune noisy maps.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 10,
      "context" : "[9–12], which exploited the global cycle-consistency criterion to prune noisy maps.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 11,
      "context" : "[9–12], which exploited the global cycle-consistency criterion to prune noisy maps.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 11,
      "context" : "The fundamental understanding has recently been advanced by [12].",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 15,
      "context" : "Recent work [16] employed spectral methods for denoising in the full-similarity case.",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 16,
      "context" : "Another line of work [17, 18] proposed to recover global rigid transform between points via convex relaxation, where the point coordinates might only be partially observed.",
      "startOffset" : 21,
      "endOffset" : 29
    }, {
      "referenceID" : 17,
      "context" : "Another line of work [17, 18] proposed to recover global rigid transform between points via convex relaxation, where the point coordinates might only be partially observed.",
      "startOffset" : 21,
      "endOffset" : 29
    }, {
      "referenceID" : 18,
      "context" : "In a broader sense, our approach is inspired by the pioneering work in low-rank matrix completion [19,20] and robust principal component analysis [21–25], which reveal the power of convex relaxation in recovering low-dimensional structures among high-dimensional objects.",
      "startOffset" : 98,
      "endOffset" : 105
    }, {
      "referenceID" : 19,
      "context" : "In a broader sense, our approach is inspired by the pioneering work in low-rank matrix completion [19,20] and robust principal component analysis [21–25], which reveal the power of convex relaxation in recovering low-dimensional structures among high-dimensional objects.",
      "startOffset" : 98,
      "endOffset" : 105
    }, {
      "referenceID" : 20,
      "context" : "In a broader sense, our approach is inspired by the pioneering work in low-rank matrix completion [19,20] and robust principal component analysis [21–25], which reveal the power of convex relaxation in recovering low-dimensional structures among high-dimensional objects.",
      "startOffset" : 146,
      "endOffset" : 153
    }, {
      "referenceID" : 21,
      "context" : "In a broader sense, our approach is inspired by the pioneering work in low-rank matrix completion [19,20] and robust principal component analysis [21–25], which reveal the power of convex relaxation in recovering low-dimensional structures among high-dimensional objects.",
      "startOffset" : 146,
      "endOffset" : 153
    }, {
      "referenceID" : 22,
      "context" : "In a broader sense, our approach is inspired by the pioneering work in low-rank matrix completion [19,20] and robust principal component analysis [21–25], which reveal the power of convex relaxation in recovering low-dimensional structures among high-dimensional objects.",
      "startOffset" : 146,
      "endOffset" : 153
    }, {
      "referenceID" : 23,
      "context" : "In a broader sense, our approach is inspired by the pioneering work in low-rank matrix completion [19,20] and robust principal component analysis [21–25], which reveal the power of convex relaxation in recovering low-dimensional structures among high-dimensional objects.",
      "startOffset" : 146,
      "endOffset" : 153
    }, {
      "referenceID" : 24,
      "context" : "In a broader sense, our approach is inspired by the pioneering work in low-rank matrix completion [19,20] and robust principal component analysis [21–25], which reveal the power of convex relaxation in recovering low-dimensional structures among high-dimensional objects.",
      "startOffset" : 146,
      "endOffset" : 153
    }, {
      "referenceID" : 25,
      "context" : "In fact, the ground truth herein is equivalent to a block-constant low-rank matrix [26], as occurred in various graph-related problems.",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 26,
      "context" : "In this regard, any GC algorithm [27–32] provides a heuristic to estimate graph matching.",
      "startOffset" : 33,
      "endOffset" : 40
    }, {
      "referenceID" : 27,
      "context" : "In this regard, any GC algorithm [27–32] provides a heuristic to estimate graph matching.",
      "startOffset" : 33,
      "endOffset" : 40
    }, {
      "referenceID" : 28,
      "context" : "In this regard, any GC algorithm [27–32] provides a heuristic to estimate graph matching.",
      "startOffset" : 33,
      "endOffset" : 40
    }, {
      "referenceID" : 29,
      "context" : "In this regard, any GC algorithm [27–32] provides a heuristic to estimate graph matching.",
      "startOffset" : 33,
      "endOffset" : 40
    }, {
      "referenceID" : 30,
      "context" : "In this regard, any GC algorithm [27–32] provides a heuristic to estimate graph matching.",
      "startOffset" : 33,
      "endOffset" : 40
    }, {
      "referenceID" : 31,
      "context" : "In this regard, any GC algorithm [27–32] provides a heuristic to estimate graph matching.",
      "startOffset" : 33,
      "endOffset" : 40
    }, {
      "referenceID" : 11,
      "context" : ", [12, 30]), we use matrices to encode maps between objects.",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 29,
      "context" : ", [12, 30]), we use matrices to encode maps between objects.",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 32,
      "context" : "[33]), a block-sparse matrix X in must first be trimmed in order to remove the undesired bias effect caused by over-represented rows / columns.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "This algorithm, all at once, attempts to disentangle the ground truth and outliers as well as predict unobserved maps via convex relaxation, inspired by recent success in sparse and low-rank matrix decomposition [21, 22].",
      "startOffset" : 212,
      "endOffset" : 220
    }, {
      "referenceID" : 21,
      "context" : "This algorithm, all at once, attempts to disentangle the ground truth and outliers as well as predict unobserved maps via convex relaxation, inspired by recent success in sparse and low-rank matrix decomposition [21, 22].",
      "startOffset" : 212,
      "endOffset" : 220
    }, {
      "referenceID" : 33,
      "context" : "For instance, our setting subsumes phase correlation [34], angular synchronization [35], and multi-signal alignment [36] as special cases.",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 34,
      "context" : "For instance, our setting subsumes phase correlation [34], angular synchronization [35], and multi-signal alignment [36] as special cases.",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 35,
      "context" : "For instance, our setting subsumes phase correlation [34], angular synchronization [35], and multi-signal alignment [36] as special cases.",
      "startOffset" : 116,
      "endOffset" : 120
    }, {
      "referenceID" : 36,
      "context" : "For practical applicability, we propose a first-order optimization algorithm for approximately solving MatchLift, which is a variant of the ADMM method for semidefinite programs presented in [37].",
      "startOffset" : 191,
      "endOffset" : 195
    }, {
      "referenceID" : 23,
      "context" : "The only comparative performance is reported for the robust PCA setting, where semidefinite relaxation enables dense error correction [24,25].",
      "startOffset" : 134,
      "endOffset" : 141
    }, {
      "referenceID" : 24,
      "context" : "The only comparative performance is reported for the robust PCA setting, where semidefinite relaxation enables dense error correction [24,25].",
      "startOffset" : 134,
      "endOffset" : 141
    }, {
      "referenceID" : 37,
      "context" : "Recall that the connectivity threshold for an Erdős–Renyi graph G(n, pobs) is pobs > logn n (see [38]).",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 16,
      "context" : "• Semidefinite Programming: The SDP formulation proposed by Wang and Singer [17] admits exact recovery in the full-similarity setting when ptrue > c1 for some absolute constant c1 ≈ 50% in the asymptotic regime.",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 18,
      "context" : "One might also attempt recovery by minimizing a weighted sum of nuclear norm and `1 norm as suggested in matrix completion [19] and robust PCA [21,22].",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 20,
      "context" : "One might also attempt recovery by minimizing a weighted sum of nuclear norm and `1 norm as suggested in matrix completion [19] and robust PCA [21,22].",
      "startOffset" : 143,
      "endOffset" : 150
    }, {
      "referenceID" : 21,
      "context" : "One might also attempt recovery by minimizing a weighted sum of nuclear norm and `1 norm as suggested in matrix completion [19] and robust PCA [21,22].",
      "startOffset" : 143,
      "endOffset" : 150
    }, {
      "referenceID" : 23,
      "context" : "In order to enable dense error correction, robust PCA requires the sparse components (which is X in − X here with X denoting the ground truth) to exhibit random signs [24, 25].",
      "startOffset" : 167,
      "endOffset" : 175
    }, {
      "referenceID" : 24,
      "context" : "In order to enable dense error correction, robust PCA requires the sparse components (which is X in − X here with X denoting the ground truth) to exhibit random signs [24, 25].",
      "startOffset" : 167,
      "endOffset" : 175
    }, {
      "referenceID" : 27,
      "context" : "• Graph Clustering: Various approaches for general graph clustering have been proposed with theoretical guarantees under different randomized settings [28,29,31].",
      "startOffset" : 151,
      "endOffset" : 161
    }, {
      "referenceID" : 28,
      "context" : "• Graph Clustering: Various approaches for general graph clustering have been proposed with theoretical guarantees under different randomized settings [28,29,31].",
      "startOffset" : 151,
      "endOffset" : 161
    }, {
      "referenceID" : 30,
      "context" : "• Graph Clustering: Various approaches for general graph clustering have been proposed with theoretical guarantees under different randomized settings [28,29,31].",
      "startOffset" : 151,
      "endOffset" : 161
    }, {
      "referenceID" : 30,
      "context" : "To facilitate comparison, we evaluate the most recent deterministic guarantees obtained by [31].",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 28,
      "context" : "In this section, we evaluate the performance of MatchLift and compare it against [29] and other graph matching methods.",
      "startOffset" : 81,
      "endOffset" : 85
    }, {
      "referenceID" : 28,
      "context" : "Figure 1: Phase Transition Diagrams of the proposed approach (MatchLift) and [29].",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 28,
      "context" : "We can see that MatchLift can recover the ground-truth maps even the majority of the input correspondences are wrong, while the exact recovery of [29] requires that the percentage of incorrect correspondences is less than 50%.",
      "startOffset" : 146,
      "endOffset" : 150
    }, {
      "referenceID" : 28,
      "context" : "In comparison, Figure 1(b) and Figure 1(d) illustrate the phase transition diagrams achieved by the algorithm proposed in [29].",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 28,
      "context" : "One can see that MatchLift is empirically superior, as [29] is unable to allow dense error correction in our case.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 38,
      "context" : ", CMU-House, CMU-Hotel, two datasets (Graf and Bikes) from [39]1 and two new datasets (referred as Chair and Building, respectively) designed for evaluating joint partial object matching.",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 3,
      "context" : "As shown in Figures 2 and 3, the Building data set contains 16 images taken around a building [4], while the Chair data set contains 16 images of a chair model from different viewpoints.",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 14,
      "context" : "To make fair comparisons with previous techniques on CMUHouse and CMU-Hotel, we use the features points provided in [15] and apply the spectral matching 1available online: robots.",
      "startOffset" : 116,
      "endOffset" : 120
    }, {
      "referenceID" : 44,
      "context" : "We compare the proposed MatchLift algorithm with Robust PCA (RPCA) and two learning based graph matching methods: LearnI [45] and LearnII [15].",
      "startOffset" : 121,
      "endOffset" : 125
    }, {
      "referenceID" : 14,
      "context" : "We compare the proposed MatchLift algorithm with Robust PCA (RPCA) and two learning based graph matching methods: LearnI [45] and LearnII [15].",
      "startOffset" : 138,
      "endOffset" : 142
    }, {
      "referenceID" : 39,
      "context" : "algorithm described in [40] to establish initial maps between features points.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 40,
      "context" : "We first detect dense SIFT feature points [41] on each image.",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 41,
      "context" : "We then apply RANSAC [42] to obtain correspondences between each pair of images.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 42,
      "context" : "On Chair, Building, Graf and Bikes, we apply the metric described in [43], which evaluates the deviations of manual feature correspondences.",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 43,
      "context" : "As the feature points computed on each image do not necessarily align with the manual features, we apply [44] to interpolate feature level correspondences into pixel-wise correspondences for evaluation.",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 28,
      "context" : "In contrast, the method of [29] can only recover 92.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 14,
      "context" : "Note that, MatchLift also outperforms state-of-the-art learning based graph matching algorithms [15,45].",
      "startOffset" : 96,
      "endOffset" : 103
    }, {
      "referenceID" : 44,
      "context" : "Note that, MatchLift also outperforms state-of-the-art learning based graph matching algorithms [15,45].",
      "startOffset" : 96,
      "endOffset" : 103
    }, {
      "referenceID" : 28,
      "context" : "Moreover, MatchLift significantly outperforms [29], as the fault-tolerance rate of [29] is limited by a small constant barrier.",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 28,
      "context" : "Moreover, MatchLift significantly outperforms [29], as the fault-tolerance rate of [29] is limited by a small constant barrier.",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 45,
      "context" : "Interested readers are referred to [47] for a tutorial.",
      "startOffset" : 35,
      "endOffset" : 39
    } ],
    "year" : 2014,
    "abstractText" : "Joint matching over a collection of objects aims at aggregating information from a large collection of similar instances (e.g. images, graphs, shapes) to improve maps between pairs of them. Given multiple objects and matches computed between a few object pairs in isolation, the goal is to recover an entire collection of maps that are (1) globally consistent, and (2) close to the provided maps — and under certain conditions provably the ground-truth maps. Despite recent advances on this problem, the best-known recovery guarantees are limited to a small constant barrier — none of the existing methods find theoretical support when more than 50% of input correspondences are corrupted. Moreover, prior approaches focus mostly on fully similar objects, while it is practically more demanding to match instances that are only partially similar to each other (e.g., different views of a single physical object). In this paper, we propose an algorithm to jointly match multiple objects that exhibit only partial similarities, given a few (possibly highly incomplete) pairwise matches that are densely corrupted. By encoding a consistent partial map collection into a 0-1 semidefinite matrix, we propose to recover the ground-truth maps via a parameter-free convex program called MatchLift, following a spectral method that pre-estimates the total number of distinct elements to be matched. Numerically, this program can be efficiently solved via alternating direction methods of multipliers (ADMM) along with a greedy rounding strategy. Theoretically, MatchLift exhibits near-optimal error-correction ability, i.e. in the asymptotic regime it is guaranteed to work even when a dominant fraction 1 − Θ ( log n √ n ) of the input maps behave like random outliers. Furthermore, MatchLift succeeds with minimal input complexity, namely, perfect matching can be achieved as soon as the provided maps form a connected map graph. We evaluate the proposed algorithm on various benchmark data sets including synthetic examples and real-world examples, all of which confirm the practical applicability and usefulness of MatchLift.",
    "creator" : "LaTeX with hyperref package"
  }
}