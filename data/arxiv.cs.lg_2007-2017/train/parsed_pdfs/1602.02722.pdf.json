{
  "name" : "1602.02722.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Contextual-MDPs for PAC-Reinforcement Learning with Rich Observations",
    "authors" : [ "Akshay Krishnamurthy", "Alekh Agarwal", "John Langford" ],
    "emails" : [ "akshaykr@cs.cmu.edu", "alekha@microsoft.com", "jcl@microsoft.com" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "The Atari Reinforcement Learning research program [20] has highlighted a critical deficiency of reinforcement learning algorithms: they cannot effectively solve problems that require systematic exploration. How can we construct Reinforcement Learning (RL) algorithms which effectively plan and plan to explore?\nIn RL theory, this is an effectively solved problem for Markov Decision Processes (MDPs) [11, 4, 24]. Why do these results not apply?\nAn easy response is, “because the hard games are not MDPs.” This may be true for some of the hard games, but it is misleading—the algorithms used do not even engage in minimal planning and global exploration1 as is required to solve MDPs efficiently. MDP-optimized global exploration has also been avoided because of a polynomial dependence on the number of unique observations which is intractably large with observations from a visual sensor. ∗akshaykr@cs.cmu.edu †alekha@microsoft.com ‡jcl@microsoft.com 1We use “global exploration” to distinguish the structural exploration strategies required to solve an MDP efficiently from exponentially less efficient alternative such as -greedy.\nar X\niv :1\n60 2.\n02 72\n2v 1\n[ cs\n.L G\n] 8\nF eb\nIn contrast, supervised and contextual bandit learning algorithms have no dependence on the number of observations and at most a logarithmic dependence on the size of the underlying policy set. Approaches to RL with a weak dependence on these quantities exist [13], but suffer from an exponential dependence on the time horizon—with K actions and a horizon of H , they require KH samples. Examples show this dependence is necessary, although such examples require a large number of states. Can we find an RL algorithm with no dependence on the number of unique observations and a polynomial dependence on the number of actionsK, the number of necessary statesM , the horizonH , and the policy complexity log(|Π|)?\nTo begin answering this question we consider a simplified setting by assuming:\n1. episodic reinforcement learning. 2. the policy space can represent the exact-best solution. 3. state transition dynamics are deterministic.\nThese simplifications make the problem significantly more tractable without trivializing the core goal of designing a Poly(K,M,H, log(|Π|))) algorithm. To this end, our contributions are:\n1. A new class of models (Contextual-MDPs) for the design and analysis of reinforcement learning algorithms. Contextual-MDPs generalize both contextual bandits and MDPs, but, unlike Partially Observable MDPs (POMDPs), the optimal policy in a Contextual-MDP depends only on the most recent observation rather than the entire trajectory.\n2. A new reinforcement learning algorithm and a guarantee that it PAC-learns Contextual-MDPs (with the above assumptions) using O(MK2H3 log(|Π|)) samples. This is done by combining ideas from contextual bandits with a novel state equality test, yielding the first Poly(K,M,H, log(|Π|)) reinforcement learning algorithm with no dependence on the number of unique observations. Like initial contextual bandit approaches, the algorithm is computationally inefficient since it requires enumeration of the policy class, an aspect we hope to address in future work.\nOur algorithm uses a function class to approximate future rewards, and thus lends theoretical backing for reinforcement learning with function approximation, which is the empirical state-of-the-art."
    }, {
      "heading" : "2 The Model",
      "text" : "In this section, we introduce the model we study throughout the paper, which we call episodic ContextualMDPs. We first setup basic notation. LetH ∈ N be a time horizon,X denote a high-dimensional observation space,A a finite set of actions, and let S denote a finite set of latent states. Let K = |A|. We partition S into H disjoint groups S1, . . . ,SH , each of size at most M . For a set P , ∆(P ) denotes the set of distributions over P ."
    }, {
      "heading" : "2.1 Basic Definitions",
      "text" : "An episodic Contextual-MDP is defined by the tuple (ΓH ,Γ, D) where H ∈ N is the episode length, ΓH ∈ ∆(SH) denotes a starting state distribution, Γ : (S × A) → ∆(S) denotes the transition dynamics, and D : S → ∆(X × [0, 1]K) associates a distribution over (observation, reward) pairs with each state. We use Ds ∈ ∆(X × [0, 1]K) to denote the (observation, reward) distribution associated with state s and also the marginal distribution over observations (usage will be clear from context). We useDs|x to denote conditional distribution of the reward given the observation x in state s. The marginal and conditional distributions are referred to as Ds(x) and Ds|x(r).\nWe assume that the process is layered (also known as loop-free or acyclic in the literature) so that for a state sh ∈ Sh and for any action a ∈ A, Γ(sh, a) ∈ ∆(Sh−1). Since the state space is partitioned into disjoint sets, each state is available only at a single time point, and the environment transitions from the state space SH down to S1 via a sequence of actions. Layered structure allows us to avoid indexing policies and Q-functions with time, which enables more concise notation but is mathematically equivalent to an alternative reformulation without layered structure.\nAn episode proceeds as follows. The environment chooses sH ∼ ΓH , (xH , rH) ∼ DsH , and xH is revealed to the learner, who chooses an action aH . The learner observes rH(aH) and the environment transitions to state sH−1 ∼ Γ(sH , aH), draws (xH−1, rH−1) ∼ DsH−1 and reveals xH−1 to the learner. The learner chooses an action aH−1 and the process continues for a total of H rounds of interaction, at which point the episode ends.\nOver the course of an episode, the reward obtained by the learner is ∑H h=1 rh(ah), and the goal is to\nmaximize the expected cumulative reward,\nR = E[ H∑ h=1 rh(ah)], (1)\nwhere the expectation accounts for all randomness in the model and the learner. We assume that almost surely ∑H h=1 rh(ah) ∈ [0, 1] for any action sequence.\nThe record of interaction observed by the learner is (xH , aH , rH(aH), . . . , x1, a1, r1(a1)). The full record of interaction for a single episode is the tuple (sH , xH , rH , aH , . . . s1, x1, r1, a1) where sH ∼ ΓH , sh ∼ Γ(sh+1, ah+1), (xh, rh) ∼ Dsh and all actions ah are chosen by the learner. Notice that all state information and rewards for alternative actions are unobserved by the learning algorithm. Figure 1 illustrates the observed and unobserved quantities over one round of interaction.\nA policy π : X → A is a strategy for navigating the search space by taking actions π(x) given observation x. A policy generates a sequence of interactions as (xH , π(xH), rH(π(xH)), . . . , x1, π(x1), r1(π(x1))) with expected reward defined recursively through\nV (π) = Es∼ΓH [V (s, π)] and, V (s, π) = E(x,r)∼Ds [ r(π(x)) + Es′∼Γ(s,π(x))V (s ′, π) ] .\nAs the base case, we assume that for states s ∈ S1, all actions transition deterministically to a terminal state s0 with V (s0, π) = 0 for all π.\nThe optimal expected reward achievable can be similarly computed recursively as\nV ? = Es∼ΓH [V ?(s)] and, (2)\nV ?(s) = Ex∼Ds max a\nEr∼Ds|x [ r(a) + Es′∼Γ(s,a)V ?(s′) ] .\nFor each (s, x) pair such that Ds(x) > 0 we can also define a Q? function as\nQ?s(x, a) = Er∼Ds|x [ r(a) + Es′∼Γ(s,a)V ?(s′) ] . (3)\nThis function captures the optimal choice of action given this (state, observation) pair and therefore encodes optimal behavior in the model. With no further assumptions, the above model is a layered episodic Partially Observable Markov Decision Process (POMDP)."
    }, {
      "heading" : "2.2 The Contextual-MDP Model",
      "text" : "The Contextual-MDP is as described above, but with an important restriction on the structure of the Q? function defined in Equation (3).\nDefinition 1 (Contextual-MDP). Let (S,A,X ,ΓH ,Γ, D) be a layered episodic POMDP. Let Q? be correspondingly defined as in Equation 3 and a?(s, x) = argmaxa∈AQ ? s(x, a). The POMDP is called a Contextual-MDP if for any two states s, s′ such that Ds(x), Ds′(x) > 0 we have a?(s, x) = a?(s′, x).\nRestated, a Contextual-MDP requires the optimal action for maximizing long-term reward to be dependent solely on the observation x irrespective of the state. This is depicted in Figure 1, where the optimal action a? depends only on the current observation. In the following section, we describe how this condition relates to other reinforcement learning models in the literature. However, we first describe some examples where the condition holds.\nExample 1 (Disjoint contexts). The simplest example for a Contextual-MDP is one where each state s can be identified with a subset Xs so that Ds(x) > 0 only for x ∈ Xs and where Xs ∩ Xs′ = ∅ when s 6= s′. In this case, a realized context x uniquely identifies the underlying state s so that the function Q?s(x, a) need not explicitly depend on the state s. On the other hand, this underlying mapping from s to Xs is unknown to the learning agent so the problem cannot be easily reduced to a classical tabular MDP with a small number of states. Our algorithm will not try to explicitly learn this mapping as the sample complexity could be prohibitive, but resolve it implicitly using the learner’s policy class. The setting naturally extends to scenarios where any tuple of τ successive contexts have non-overlapping support for some τ ≥ 1. In this case, we can define a new state space that consists of all concatenations of τ states in the underlying state space and new observation distributions that concatenate corresponding observations.\nExample 2 (Path-augmented contexts). If the transition function Γ is deterministic, one can associate each state swith a sequence of actions (a path) that ends at state s and augment the context with some featurization of this sequence, including a featurization of the states visited along this path. As paths uniquely identify states in this case, this is an instance of the disjoint context scenario in Example 1.\nMore generally, Contextual-MDPs provides a convenient framework to reason about reinforcement learning with function approximation as we will see. This is highly desirable as such approaches are the empirical state-of-the-art, but the limited supporting theory provides little advice on systematic global exploration."
    }, {
      "heading" : "2.3 Connections to Other Models",
      "text" : "Our model is closely related to several well-studied models in the literature, namely:\nContextual Bandits: IfH = 1, then Contextual-MDPs reduce to stochastic contextual bandits [14, 6], a well-studied simplification of the general reinforcement learning problem. In contextual bandits, the learning algorithm repeatedly takes an action on the basis of a context (or observation), and accumulates reward for the chosen action. The main difference is that the choice of action does not influence the future observations; in the stochastic contextual bandits problem all (observation, reward) pairs are drawn independently and identically from some distribution. Thus Contextual-MDPs force the learning algorithm to use long-term decision making, which is not required for contextual bandits.\nMarkov Decision Processes: If X = S and the distribution over observations for each state s is concentrated on s, then Contextual-MDPs reduce to Markov Decision Processes (MDPs). MDPs with small state spaces can be efficiently solved by tabular approaches that maintain and update statistics about each state [11, 4, 24]. The main difference in our setting is that the observation space X is extremely large or infinite and the underlying state is unobserved, so tabular approaches are not viable. Thus, ContextualMDPs force the learning algorithm to generalize across observations, which is not required in MDPs.\nSample complexity bounds for reinforcement learning with large state or observation spaces do exist, but the results require unrealistic assumptions and/or the bounds are rather weak. One example is the metricE3 algorithm of Kakade et al. [10] (see also [8]) that has sample complexity independent of the number of unique states, but assumes the ability to cover the state space in a metric a priori known to the learner. Moreover, the sample complexity scales linearly in the cover size as opposed to a more typical logarithmic dependence as in supervised learning. The sparse sampling planner of Kearns et al. [13] also implies a sample complexity bound that is independent of the observation space size for episodic MDPs, but grows as O(KH). More recently, Abbasi-Yadkori and Neu [1] propose a model for MDPs with side-information, but this model requires mapping side-information to a small-state MDP, rather than mapping an observation to an action as in Contextual-MDPs.\nPolicy gradient methods that apply (stochastic) optimization methods to find a parameterized policy with high value can also be applied to large-state MDPs and to Contextual-MDPs. However, these methods use local search techniques and consequently do not achieve global optimality [25, 9] in theory as well as empirically, unlike our algorithm which is guaranteed to find the globally optimal policy.\nPOMDPs: By definition a Contextual-MDP is a Partially Observable Markov Decision Process (POMDP) where the optimal action at any state depends only on the current observation. Thus in ContextualMDPs, the learning algorithm does not have to reason over belief states as is required in POMDPs.\nBorrowing terminology, a Contextual-MDP is precisely a POMDP where a reactive policy, which uses only the current observation, is optimal. While there are POMDP methods for learning reactive policies, or more generally policies with bounded memory [19], they are based on policy gradient techniques, which suffer both theoretical and empirical drawbacks as we mentioned.\nThere are some sample complexity guarantees for learning in arbitrarily complex POMDPs, but the bounds we are aware of are quite weak as they scale linearly with |Π| [12, 18].\nPredictive State Representations (PSRs): PSRs [17] encode states as a a collection of tests, a test being a sequence of (a, x) pairs observed in the history. Representationally, PSRs are even more powerful than POMDPs [23] which make them also more general than Contextual-MDPs. However, we are not aware of finite sample bounds for learning PSRs."
    }, {
      "heading" : "2.4 Connections to Other Techniques",
      "text" : "State Abstraction: Our work is closely related to the literature on state abstraction (See [16] for a survey), which primarily focuses on understanding what optimality properties are preserved in an MDP after the state space is compressed. However, Contextual-MDPs do not necessarily admit non-trivial state abstraction functions that are easy to discover (i.e. that do not amount to learning the optimal behavior) as the optimal behavior can depend on the observation in an arbitrary manner. Moreover, while there are finite sample results for learning state abstractions, they all make strong assumptions that limit the scope of application. A recent example is the work of Jiang et al. [7] which finds a good abstraction from a set of successively finer ones, but cannot search over the exponentially many abstractions functions.\nFunction Approximation: Our solution uses function approximation to address the generalization problem implicit in Contextual-MDPs. Function approximation is the empirical state-of-the-art in reinforcement learning [20], but theoretical analysis has been quite limited. Several authors have studied linear function approximation (See [26, 21]) but none of these results give finite sample bounds, as they do not address the exploration question. Baird [3] analyzes more general function approximation for predicting the value function in a Markov Chain, but does not show convergence when the agent is also selecting actions. More closely to our work, Li and Littman [15] do give finite sample bounds for RL with function approximation, but they assume access to a particular “Knows-what-it-knows” oracle, which cannot exist even for simple problems. We are not aware of finite sample results for approximating Q? with a function class, which is precisely what we do here."
    }, {
      "heading" : "3 Our Approach",
      "text" : "In this paper, we consider the task of probably approximately correct (PAC) learning Contextual-MDPs. Given a policy class Π, we say that an algorithm PAC learns a Contextual-MDP if for any , δ ∈ (0, 1), the algorithm outputs a policy π̂ with V (π̂) ≥ maxπ∈Π V (π) − with probability at least 1 − δ. The sample complexity of the algorithm is the number of episodes of the Contextual-MDP that the algorithm executes before returning an -suboptimal policy. Formally, the sample complexity is a function n : (0, 1)2 → N such that for any , δ ∈ (0, 1), the algorithm returns an -suboptimal policy with probability at least 1 − δ using only n( , δ) episodes."
    }, {
      "heading" : "3.1 Additional Assumptions for the Result",
      "text" : "Our algorithm operates on Contextual-MDPs with two additional assumptions. The first assumption posits the ability to approximate the Q? function (3) well and seems essential for a function approximation based approach.\nAssumption 1 (Realizability). We identify our set of policies Π with a set of regression functions F ⊂ (X ×A)→ [0, 1]. Specifically, we set Π = {πf : f ∈ F} where πf = argmaxa f(x, a). We assume that F is available to the learner and make a realizability assumption, meaning that there exists a function f? ∈ F , such that for every x ∈ X and a ∈ A, f?(x, a) = Q?s(x, a), for any state s such that Ds(x) > 0. We use N to denote |F| = |Π|.\nNote that the above assumption tacitly forces the function Q?s(x, a) to be consistent across all states s withDs(x) > 0. This is stronger than only assuming the consistency of the argmax ofQ? as in Definition 1, but Q? may still be a complex function of the observation x and action a.\nThe regressor class induces a family of value functions defined for each f ∈ F , s ∈ S, and for any policy π : X → A,\nV f (s, π) = Ex∼Dsf(x, π(x)).\nWorking through definitions, it is easy to see that,\nV ?(s) = V f ?\n(s, πf?),\nfor all s so that V ? = Es∼ΓH [V f?(s, πf?(s))]. Recalling the earlier definition, PAC-learning in the realizable setting requires finding a policy π̂ with V (π̂) ≥ V ? − . Assumption 2 (Deterministic Transitions). We further assume that the transition model is deterministic. This means that the starting distribution ΓH is a point-mass on some state sH and the transition dynamics map state action pairs deterministically to future states, i.e. Γ : (S × A) → S , preserving the layered structure.\nEven with deterministic transitions, PAC-learning Contextual-MDPs requires systematic exploration that is unaddressed in previous work."
    }, {
      "heading" : "3.2 Algorithm",
      "text" : "We seek an algorithm that can PAC-learn realizable deterministic-transition Contextual-MDPs with sample complexity that is Poly(M,K,H, , log(N), log(1/δ)), and we refer to such a sample complexity bound as polynomial in all relevant parameters. Notably, the algorithm should have no dependence on |X | which can be infinite. In this section, we develop such an algorithm, and we prove the sample complexity bound in Section 4. Our focus is on statistical efficiency, so we ignore computational considerations in the present work.\nBefore turning to the algorithm, it is worth clarifying some additional notation. Since we are focused on the deterministic transition setting, it is natural to think about the Contextual-MDP as an exponentially large search tree with fan-out K and depth H . Each node in the search tree is labeled with a state s ∈ S, and each edge is labeled with an action a ∈ A, both of which are consistent with the transition model. A path p ∈ A? corresponds to a sequence of actions from the root of the search tree, and we also use p to denote the state reached after executing the corresponding sequence of actions from the root. We often call such a path a roll-in, in line with existing terminology. For a roll-in p, we use p ◦ a to denote a path formed by executing all actions in p and then execution action a.\nPseudocode for our algorithm is displayed in Algorithm 1. The algorithm is tail-recursive in nature and mimics depth first search, starting at the root of the search tree. The first call to the algorithm should be cMDPLearn(∅,F , , δ) where ∅ denotes the empty path (i.e., the root of the search tree), F is the given class of regression functions, is the target accuracy and δ is the target failure probability.\nThe Elimination Component: At a high level, the algorithm aims to maintain only the regressors that approximate the Q? function well, and it makes progress by discarding regressors that have a poor fit to the Q? function. This is achieved by training in a bottom-up fashion, so that when training at some path p, we ensure convergence at all descendants. At path p, we train by retaining only the regressors that have low excess risk on a carefully constructed regression problem (See TD-Elim, displayed in Algorithm 3). The regression problem in TD-Elim is motivated by Assumption 1 and the definition of Q? in Eq. (3), which imply that for any state s generating observation x,\nf?(x, a) = Er∼Ds|xr(a) + V (Γ(s, a), πf?)\n=Er∼Ds|xr(a) + Ex′∼DΓ(s,a)f ?(x′, πf?(x ′)). (4)\nAlgorithm 1 cMDPLearn (p,F , , δ) Set φ =\n40H √ K , test = (H−|p|−1/4) 2H .\nif StateLearned(p,F , test, φ, δ/2MKH ) then Return F . # Learned in state p already end if for a ∈ A do F ← cMDPLearn(p ◦ a,F , , δ). # Recurse end for F̂ ← TD-Elim ( p,F , φ, δ/2MH ) . # Learn in state p\nReturn F̂ .\nThus f? is consistent between its estimate at the current state s and the future state s′ = Γ(s, a). The regression problem we create is essentially a finite sample version of this identity. However some care must be taken as the target for each regression function f , V f (s′, πf ), is the value of the future as predicted by f . This target differs for each function but can be estimated from samples. To ensure correct behavior of the regression problem, we must obtain high-quality estimates of these future value predictions. Nevertheless if constructed carefully, these regression problems ensure that the algorithm retains only good regressors, which induce good policies.\nTD-Elim is inspired by the RegressorElimination algorithm of Agarwal et al. [2] for contextual bandit learning in the realizable setting. Apart from the differences between the regression problem, motivated by the discussion above, the other main difference between the algorithms is the choice of action-selection distribution. RegressorElimination must carefully choose actions to balance exploration and exploitation which leads to an optimal regret bound. In contrast, we are pursuing a PAC-guarantee here, for which it suffices to focus exclusively on exploration.\nThe Exploration Component: The other main component of the algorithm, which is crucial for obtaining polynomial sample complexity, is a global exploration technique (See Algorithm 2). This is based on testing if the learning mechanism has already converged in a state (path), which can be done by estimating the value predictions for all surviving regressors. Specifically, if this test returns true, then all the surviving regressors agree on the value of the current state. As shown below, this condition is sufficient to learn at ancestor states. Furthermore, if we have already trained on the (observation, reward) distribution induced by the path p, then this test returns true with high probability, thus implicitly performing a state equality test at a level needed by the class F . The first property ensures that we learn properly, while the second property gives a strong sample complexity guarantee.\nThis test is performed at each path visited by the algorithm before making the recursive call on descendant paths, and if the learning process has converged, the algorithm does not visit the descendant paths. Thus, the algorithm does not traverse a large fraction the entire search tree provided that the convergence test succeeds often enough. The number of times the test does not report true at each level is upper bounded by the number of states M leading to a polynomial sample complexity bound."
    }, {
      "heading" : "4 Theoretical Analysis",
      "text" : "In this section we prove a PAC-learning guarantee for cMDPLearn on Contextual-MDPs.\nTheorem 1 (PAC bound). For any , δ ∈ (0, 1) and any Contextual-MDP (Definition 1) with deterministic\nAlgorithm 2 StateLearned(p,F , test, φ, δ) Set ntest = 2 log(2N/δ)/φ2. Collect ntest observations xi ∼ Dp. Compute Monte-Carlo estimates for each value function,\nV̂ f (p, πf ) = 1\nntest ntest∑ i=1 f(xi, πf (xi)) ∀f ∈ F\nif |V̂ f (p, πf )− V̂ g(p, πg)| ≤ test for all f, g ∈ F then return true end if Return false.\nAlgorithm 3 TD-Elim(p,F , φ, δ) Require estimates V̂ f (p ◦ a, πf ),∀f ∈ F , a ∈ A. Set ntrain = 24 log(2N/δ)/φ2\nCollect ntrain observations (xi, ai, ri) where xi ∼ Dp, ai is chosen uniformly at random, and ri = ri(ai). Update F to {\nf ∈ F : R̃(f) ≤ min f ′∈F\nR̃(f) + 2φ2 + 22 log(N/δ)\nntrain\n} ,\nwith R̃(f) = 1\nntrain ntrain∑ i=1 (f(xi, ai)− ri − V̂ f (p ◦ ai, πf ))2\nReturn F .\ntransitions for whichQ? ∈ F , with probability at least 1−δ, any policy returned by cMDPLearn(∅,F , , δ) is at most -suboptimal. Moreover, cMDPLearn(∅,F , , δ) requires at most O ( MH3K2 2 log ( NMHK\nδ )) episodes.\nThis theorem states that cMDPLearn learns a policy that is at most -suboptimal for a ContextualMDP using a number of episodes that is polynomial in all relevant parameters. Looking a little closer into the result, our overall sample complexity is shown to beMHntrain +MHKntest. Since ntrain and ntest are set to be of the same order, this reveals that we lose a factor of K more samples while testing for state equality in the StateLearned routine. Consequently, the sample complexity can be improved by a factor of K whenever we do not need to test for state equality, or if collecting several exploration observations x for a path p without observing reward signal is cheap.\nSince Contextual-MDPs generalize both contextual bandits and MDPs, it is worth comparing the results.\n1. In contextual bandits, we have M = H = 1 so that the sample complexity of cMDPLearn is Õ(K2/ 2), in contrast with the optimal Õ(K/ 2) sample complexity for contextual bandit learning. As discussed above, the gap is due to the Kntest factor, which goes away in contextual bandits since there is only one state. Thus with minor modification, cMDPLearn matches the optimal sample complexity for contextual bandits.\n2. Assumptions vary with the paper, but broadly prior results establish the sample complexity for learning layered episodic MDPs with deterministic transitions is Õ(MKpoly(H)/ 2) [5, 22]. Again the discrepancy is the additional factor ofK present in Theorem 1, which can be avoided given that the states are known in an MDP. In this setting, cMDPLearn can easily be modified to have Õ(MKH3/ 2) sample complexity for layered episodic MDPs."
    }, {
      "heading" : "4.1 Preliminaries for the Proof",
      "text" : "The proof of the theorem hinges on analysis of the two subroutines. We turn first to the TD-Elim routine, for which we show the following guarantee.\nTheorem 2. Consider running TD-Elim at path p with regressors F , parameters φ, δ and with ntrain = 24 log(2N/δ)/φ2. Suppose that the following are true:\n1. Estimation Precondition: We have access to estimates V̂f (p ◦ a, πf ) for all f ∈ F , a ∈ A such that,|V̂ f (p ◦ a, πf )− V f (p ◦ a, πf )| ≤ φ.\n2. Bias Precondition: For all f, g ∈ F and for all a ∈ A, |V f (p ◦ a, πf )− V g(p ◦ a, πg)| ≤ τ1.\nThen the following hold simultaneously with probability at least 1− δ:\n1. f? is retained by the algorithm. 2. Estimation Bound:\n|V̂ f (p, πf )− V f (p, πf )| ≤ φ√ 12\n(5)\n3. Bias Bound:\n|V f (p, πf )− V g(p, πg)| ≤ 8φ √ K + 2φ+ τ1 (6)\n4. Risk Bound:\nV ?(p)− V (p, πf ) ≤ 4φ √ 2K + 2φ+ 2τ1 (7)\nThe last three bounds hold for all surviving f, g ∈ F .\nThe proof is intricate so we sketch a proof here and defer details to Appendix A.\nProof Sketch. The proof involves relating the value predictions V f (p, πf ) to the empirical squared loss quantity controlled explicitly by the algorithm. The first step is similar to Agarwal et al. [2] and shows that R̃(f) is close to its expectation, which implies that f∗ is never eliminated and all surviving regressors have small expected squared error.\nThe second step relates the differences V f (p, πf ) − V g(p, πg) to E[R̃(f) − R̃(g)] as well as the bias and estimation precondition bounds at the descendants p ◦ a. It is crucial that the bias bound (6) retains a constant of 1 on τ1 which leads to additive growth of the bias and avoids an exponential dependence onH in our later analysis. Similar ideas are applied for the risk bound where a multiplicative factor is unavoidable, but fortunately we will only use this bound once at the root.\nAnalysis of the StateLearned subroutine requires only standard concentration-of-measure arguments.\nTheorem 3. Consider running StateLearned on path p with ntest = 2 log(2N/δ)/φ2 and test ≥ 2φ+τ2.\n1. If |V f (p, πf )−V g(p, πg)| ≤ τ2,∀f, g ∈ F , then with probability at least 1− δ, the algorithm returns true. 2. If the algorithm returns true, then with probability at least 1− δ, we have (a) value estimates V̂ f (p, πf ) with |V̂ f (p, πf )− V f (p, πf )| ≤ φ ∀f ∈ F , and (b) |V f (p, πf )− V g(p, πg)| ≤ 2φ+ test ∀f, g ∈ F .\nAppendix B provides the proof."
    }, {
      "heading" : "4.2 Proof of Theorem 1",
      "text" : "For now assume that all calls to TD-Elim and StateLearned succeed. Later we will bound the total number of calls and hence the total failure probability.\nLet be the error parameter passed to cMDPLearn and recall that φ = 40H √ K . We first argue that in all calls to TD-Elim the estimation precondition is satisfied. To see this, notice that by design, the algorithm only calls TD-Elim at path p after the recursive step, which means for each p ◦ a either we ran TD-Elim or StateLearned returned true. Since both Theorems 2 and 3 guarantee estimation error of order φ, the estimation precondition for path p holds. This argument applies to all paths p for which we call TD-Elim so that the estimation precondition is always satisfied.\nWe next analyze the bias term, for which we prove the following claim by induction. Inductive Claim: For all paths pwith h actions remaining and any pair f, g ∈ F of surviving regressors,\n|V f (p, πf )− V g(p, πg)| ≤ 20h √ K φ.\nBase Case: The claim clearly holds at time point 0, since all regressors estimate future reward as zero. Inductive Step: Assume that the inductive claim holds for all accessed paths with h− 1 actions remaining. Consider any path p with h actions remaining that we access; we want to show that the claim holds for p.\nSince we access the path p, either we call TD-Elim or StateLearned returns true. If we call TD-Elim, then by the inductive hypothesis, we have already filtered the regressor class so that for all, a ∈ A, f, g ∈ F , we have\n|V f (p ◦ a, πf )− V g(p ◦ a, πg)| ≤ 20(h− 1) √ Kφ.\nWe will therefore instantiate τ1 = 20(h− 1) √ Kφ in the bias precondition of Theorem 2. Of course we also have that the estimation precondition is satisfied with parameter φ. Therefore, the bias bound in Theorem 2 shows that, for all f, g ∈ F retained by the algorithm,\n|V f (p, πf )− V g(p, πg)| ≤ 8φ √ K + 2φ+ τ1\n≤ 10 √ Kφ+ 20(h− 1) √ Kφ ≤ 20 ( h− 1\n2\n)√ Kφ. (8)\nThus, the inductive step holds in this case. The other case we must consider is if StateLearned returns true. In this case, we call StateLearned at level h with parameter test = (h−1/4) 2H = 20 ( h − 14 )√ Kφ recalling the setting of\nφ and noting that H − |p| is exactly the number of actions remaining after rolling in with p. Then by Theorem 3, if it returns true, we have the bias bound,\n|V f (p, πf )− V g(p, πg)| ≤ 2φ+ 20 ( h− 1\n4\n)√ Kφ\n≤ 20h √ Kφ. (9)\nThus we have established the inductive claim. Establishing the PAC guarantee: Since the inductive claim holds for all paths accessed at level H − 1, we may apply the risk bound in Theorem 2 at the root of the tree. The estimation and bias preconditions are satisfied with parameters φ and τ1 = 20(H − 1) √ Kφ, respectively, so Theorem 2 implies that for any surviving regressor f ∈ F ,\nV ?(sH)− V (sH , πf )\n≤ φ(4 √ 2K + 2) + 40(H − 1) √ Kφ ≤ 40H √ Kφ = , (10)\nby our choice for φ. Thus, we satisfy the PAC guarantee, since all surviving policies πf are at most - suboptimal.\nWorking through definitions, this means if we set\nntrain = 24 log(2N/δ) φ2 ≥ (4× 10 4)H2K 2 log (2N/δ)\nntest = 2 log(2N/δ) φ2 ≥ 3200H\n2K\nlog(2N/δ),\nthen we obtain the PAC guarantee. Bounding the Sample Complexity: We now bound the number of calls to each subroutine, which reveals how to allocate the failure probability and gives the sample complexity bound. Again, assume that all calls succeed.\nFirst notice that if we call StateLearned on some state s ∈ Sh for which we have already called TD-Elim, then StateLearned returns true (assuming all calls to subroutines succeed). This follows because TD-Elim guarantees that the population predicted values for this state distribution are at most 20(h− 1/2) √ Kφ apart (Eq. (8)), which becomes the choice of τ2 in application of Theorem 3. This is legal since 2φ+ 20(h− 1/2) √ Kφ ≤ 20(h− 1/4) √ Kφ = test,\nso that precondition for Theorem 3 holds. Therefore, at any level h, we can call TD-Elim at most one time per state s ∈ Sh. In total, this yields MH calls to TD-Elim.\nNext, since we only make recursive calls when we execute TD-Elim, we expand at most M paths per level. This means that we call StateLearned on at most MK paths per level, since the fan-out of the tree is K. Thus, the number of calls to StateLearned is at most MKH .\nBy the setting of δ in the calls to these subroutines (i.e. δ/(2MKH) in all calls to StateLearned and δ/(2MH) in all calls to TD-Elim), and by Theorems 2 and 3, the total failure probability is therefore at most δ.\nFinally, the number of episodes (trajectories) executed is\nMHntrain +MKHntest = O ( MH3K2\n2 log\n( NMHK\nδ\n)) ,\nwhich concludes the proof."
    }, {
      "heading" : "5 Discussion",
      "text" : "This paper introduces a new model, Contextual-MDPs, in which it is possible to design and analyze principled reinforcement learning algorithms that engage in global exploration. As a first step, we develop cMDPLearn and show that it learns near-optimal behavior in Contextual-MDPs with polynomial sample complexity. To our knowledge, this is the first polynomial sample complexity bound for reinforcement learning with general function approximation.\nHowever, there are many avenues for future work:\n1. cMDPLearn has two main undesirable properties. Firstly, it requires a deterministic transition model which is unrealistic in some practical settings. Secondly, the algorithm involves enumerating the class of regression functions, so while its sample complexity is logarithmic in the function class size, its running time is linear, which is typically intractably slow. Resolving both of these deficiencies may lead to a new practical reinforcement learning algorithm.\n2. Our algorithm also crucially relies on the realizability assumption, which on one hand is implicitly assumed by state-of-the-art reinforcement learning algorithms, but is known to be unnecessary in the contextual bandit setting. Is it possible to design completely agnostic algorithms for learning in Contextual-MDPs?\nWe look forward to pursuing these directions."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We thank Akshay Balsubramani and Hal Daumé III for formative discussions, and we thank Tzu-Kuo Huang for a careful reading of an early draft of this paper."
    }, {
      "heading" : "A Proof of Theorem 2",
      "text" : "The proof of Theorem 2 is quite technical, and we compartmentalize into several components. We begin with several technical lemmas. Throughout we will use the preconditions of the theorem, which we reproduce here.\nCondition 1. For all f ∈ F and a ∈ A, we have estimates V̂ f (p ◦ a, πf ) such that,\n|V̂ f (p ◦ a, πf )− V f (p ◦ a, πf )| ≤ φ.\nCondition 2. For all f, g ∈ F and a ∈ A we have,\n|V f (p ◦ a, πf )− V g(p ◦ a, πg)| ≤ τ1.\nWe will make frequent use of the parameters φ and τ1 which are specified by these two conditions, and explicit in the theorem statement.\nRecall the notation,\nV f (p, πg) = Ex∼Dpf(x, πg(x))\nwhich will be used heavily throughout the proof. As notational convenience, we will suppress dependence on the distributionDp, since we are considering one invocation of TD-Elim and we always roll into path p. This means that all (observation, reward) tuples will be drawn from Dp. Secondly it will be convenient to introduce the shorthand V f (p) = V f (p, πf ) and similarly for the estimates. Finally, we will further shorten the value functions for paths p ◦ a by defining,\nV fa = Ex∼Dp◦af(x, πf (x)) = V f (p ◦ a, πf ).\nWe will also use V̂ fa to denote the estimated versions which we have access to according to Condition 1. Lastly, our proof makes extensive use of the following random variable, which is defined for a particular regressor, although we omit the explicit dependence.\nY , (f(x, a)− r(a)− V̂ f (p ◦ a))2 − (f?(x, a)− r(a)− V̂ f ? (p ◦ a))2.\nHere (x, r) ∼ Dp and a ∈ A is drawn uniformly at random as prescribed by Algorithm 3. When multiple regressors are involved, we use Y (f) to denote the random variable associated with regressor f .\nTo proceed, we first compute the expectation and variance of this random variable.\nLemma 1 (Properties of TD Squared Loss). Assume Conditions 1 and 2 hold. Then for any f ∈ F , the random variable Y satisfies,\nEx,a,r[Y ] = Ex,a [ (f(x, a)− V̂ f (p ◦ a)− f?(x, a) + V f ? (p ◦ a))2 ] − Ex,a [ (V̂ f ? (p ◦ a)− V f ? (p ◦ a))2 ]\nVar x,a,r\n[Y ] ≤ 32Ex,a[Y ] + 64φ2\nProof. For further shorthand, denote f = f(x, a), f? = f?(x, a) and recall the definition of V fa and V̂ f a .\nEx,a,rY = Ex,a,r [ (f − V̂ fa − r(a))2 − (f? − V̂ f ? a − r(a))2 ]\n= Ex,a,r [ (f − V̂ fa )2 − 2r(a)(f − V̂ fa − f? + V̂ f ? a )− (f? − V̂ f ? a ) 2 ]\nNow recall that E[r(a)|x, a] = f∗(x, a)− V f?a by the definition of f∗, which allows us to further obtain\nEx,a,rY = Ex,a [ (f − V̂ fa )2 − 2(f? − V f ? a )(f − V̂ fa ) + 2(f? − V̂ f ? a + V̂ f? a − V f ? a )(f ? − V̂ f ? a )− (f? − V̂ f ? a ) 2 ]\n= Ex,a [ (f − V̂ fa )2 − 2(f? − V f ? a )(f − V̂ fa ) + (f? − V̂ f ? a ) 2 + 2(V̂ f ? a − V f ? a )(f ? − V̂ f ? a ) ]\n= Ex,a [ (f − V̂ fa )2 − 2(f? − V f ? a )(f − V̂ fa ) + (f? − V f ? a + V f? a − V̂ f ? a ) 2 + 2(V̂ f ? a − V f ? a )(f ? − V̂ f ? a ) ]\n= Ex,a [ (f − V̂ fa − f? + V f ? a ) 2 + 2(V f ? a − V̂ f ? a )(f ? − V f ? a ) + (V f? a − V̂ f ? a ) 2 + 2(V̂ f ? a − V f ? a )(f ? − V̂ f ? a ) ]\n= Ex,a [ (f − V̂ fa − f? + V f ? a ) 2 − (V f ? a − V̂ f ? a ) 2 ]\nFor the second claim, notice that we can write,\nY = (f − V̂ fa − f? + V̂ f ? a )(f − V̂ fa + g − V̂ f ? a − 2r(a)),\nso that,\nY 2 ≤ 16(f − V̂ fa − f? + V̂ f ? a ) 2.\nThis holds because all quantities in the second term are bounded in [0, 1]. Therefore,\nVar(Y ) ≤ E[Y 2] ≤ 16Ex,a [ (f(x, a)− V̂ fa − f?(x, a) + V̂ f ? a ) 2 ]\n= 16Ex,a [ (f(x, a)− V̂ fa − f?(x, a) + V f ? a + V̂ f? a − V f ? a ) 2 ]\n≤ 32Ex,a [ (f(x, a)− V̂ fa − f?(x, a) + V f ? a ) 2 ] + 32φ2\n≤ 32Ex,aY + 64φ2\nThe first inequality is straightforward, while the second inequality is from the argument above. The third inequality uses the fact that (a+ b)2 ≤ 2a2 + 2b2 and the fact that for each a, the estimate V̂ f?a has absolute error at most φ (By Condition 1). The last inequality adds and subtracts the term involving (V f ?\na − V̂ f ? a ) 2\nto obtain Ex,aY .\nThe next step is to relate the empirical squared loss to the population squared loss, which is done by application of Bernstein’s inequality.\nLemma 2 (Squared Loss Deviation Bounds). Assume Conditions 1 and 2 hold. With probability at least 1− δ/2, where δ is a parameter of the algorithm, f? survives the filtering step of Algorithm 3 and moreover, any surviving f satisfies,\nEY (f) ≤ 10φ2 + 120 log(2N/δ) ntrain .\nProof. We will apply Bernstein’s inequality on the centered random variable, ntrain∑ i=1 Yi(f)− EYi(f),\nand then take a union bound over all f ∈ F . Here the expectation is over the ntrain samples (xi, ai, ri) where (xi, r) ∼ Dp, ai is chosen uniformly at random, and ri = r(ai). Notice that since actions are chosen uniformly at random, all terms in the sum are identically distributed, so that EYi(f) = EY (f).\nTo that end, fix one f ∈ F and notice that |Y −EY | ≤ 8 almost surely, as each quantity in the definition of Y is bounded in [0, 1], so each of the four terms can be at most 4, but two are non-positive and two are non-negative in Y − EY . We will use Lemma 1 to control the variance. Bernstein’s inequality implies that, with probability at least 1− δ,\nntrain∑ i=1 EYi − Yi ≤ √ 2 ∑ i Var(Yi) log(1/δ) + 16 log(1/δ) 3\n≤ √ 64 ∑ i (E(Yi) + 2φ2) log(1/δ) + 16 log(1/δ) 3\nThe first inequality here is Bernstein’s inequality while the second is based on the variance bound in Lemma 1. Now letting X = √∑\ni(E(Yi) + 2φ 2), Z = ∑ i Yi and C = √ log(1/δ), the inequality above is\nequivalent to,\nX2 − 2ntrainφ2 − Z ≤ 8XC + 16\n3 C2\n⇒ X2 − 8XC + 16C2 − Z ≤ 2ntrainφ2 + 22C2\n⇒ (X − 4C2)− Z ≤ 2ntrainφ2 + 22C2\n⇒ −Z ≤ 2ntrainφ2 + 22C2\nUsing the definition of −Z, this last inequality implies that, ntrain∑ i=1 (f?(xi, ai)− ri(ai)− V̂ f ? (p ◦ ai))2 ≤ ntrain∑ i=1 (f(xi, ai)− ri(ai)− V̂ f (p ◦ ai))2 + 2ntrainφ2 + 22 log(1/δ)\nVia a union bound over all f ∈ F , and rebinding δ ← δ/(2N), we have,\nR̃(f?) ≤ min f∈F\nR̃(f) + 2φ2 + 22 log(N/δ)\nntrain\nSince this is precisely the threshold used in filtering regressors, we ensure that f? survives. Now for any other surviving regressor f , we are ensured that Z is upper bounded. Specifically we have,\n(X − 4C)2 ≤ Z + 2ntrainφ2 + 22C2 ≤ 4ntrainφ2 + 44C2 ⇒ X2 ≤ ( √ 4ntrainφ2 + 44C2 + 4C) 2\n≤ 8ntrainφ2 + 120C2\nThis proves the claim sinceX2 = ntrainEY (f)+2ntrainφ2 (Recall that the Yis are identically distributed).\nThis deviation bound allows us to establish the three claims in Theorem 2. We start with the estimation error claim, which is straightforward.\nLemma 3 (Estimation Error). Assume Conditions 1 and 2 hold. Let δ ∈ (0, 1). Then with probablity at least 1− δ, for all f ∈ F that are retained by the Algorithm 3, we have estimates V̂ f (p, πf ) with,\n|V̂ f (p, πf )− V f (p, πf )| ≤\n√ 2 log(N/δ)\nntrain .\nProof. The proof is a consequence of Hoeffding’s inequality and a union bound. Clearly the Monte Carlo estimate,\nV̂ f (p, πf ) = 1\nntrain ntrain∑ i=1 f(xi, πf (xi)),\nis unbiased for V f (p, πf ) and the centered quantity is bounded in [−1, 1]. Thus Hoeffding’s inequality gives precisely the bound in the lemma.\nNext we turn to the claim regarding bias.\nLemma 4 (Bias Accumulation). Assume Conditions 1 and 2 hold. In the same 1− δ event in Lemma 2, for any pair f, g ∈ F retained by Algorithm 3, we have,\nV f (p, πf )− V g(p, πg) ≤ 2 √ K √ 11φ2 + 120 log(N/δ)\nntrain + 2φ+ τ1\nProof. We start by expanding definitions,\nV f (p, πf )− V g(p, πg) = Ex∼Dp [f(x, πf (x))− g(x, πg(x))]\nNow, since g prefers πg(x) to πf (x), it must be the case that g(x, πg(x)) ≥ g(x, πf (x)), so that,\nV f (p, πf )− V g(p, πg) ≤Ex∼Dpf(x, πf (x))− g(x, πf (x)) = Ex∼Dp [f(x, πf (x))− V̂ f (p ◦ πf (x), πf )− f?(x, πf (x)) + V̂ f ?\n(p ◦ πf (x), πf?)] − Ex∼Dp [g(x, πf (x))− V̂ g(p ◦ πf (x), πg)− f?(x, πf (x)) + V̂ f ?\n(p ◦ πf (x), πf?)] + Ex∼Dp [V̂ f (p ◦ πf (x), πf )− V̂ g(p ◦ πf (x), πg)]\nThis last equality is just based on adding and subtracting several terms. The first two terms look similar, and we will relate them to the squared loss. For the first, by Lemma 1, we have that for each x ∈ X ,\nEr,a|x[Y (f)] + Ea|x[(V̂ f?(p ◦ a, πf?)− V f ? (p ◦ a, πf?))2] = Ea|x [ (f(x, a)− V̂ f (p ◦ a, πf )− f?(x, a) + V f ? (p ◦ a, πf?))2 ]\n≥ 1 K\n[ (f(x, πf (x))− V̂ f (p ◦ πf (x), πf )− f?(x, πf (x)) + V f ? (p ◦ πf (x), πf?))2 ]\nNow by Jensen’s inequality the first term can be upper bounded as,\nEx∼Dp [f(x, πf (x))− V̂ f (p ◦ πf (x), πf )− f?(x, πf (x)) + V̂ f ? (p ◦ πf (x), πf?)] ≤ √\nEx∼Dp [(f(x, πf (x))− V̂ f (p ◦ πf (x), πf )− f?(x, πf (x)) + V̂ f ?(p ◦ πf (x), πf?))2]\n= √ KEx∼Dp [ 1\nK (f(x, πf (x))− V̂ f (p ◦ πf (x), πf )− f?(x, πf (x)) + V̂ f?(p ◦ πf (x), πf?))2 ] ≤ √ K ( Ex,a,r[Y (f)] + Ex,a[(V̂ f ?(p ◦ a, πf?)− V f?(p ◦ a, πf?))2]\n) ≤ √ K √ EY (f) + φ2\n≤ √ K √ 11φ2 + 120 log(N/δ)\nntrain ,\nwhere the last step follows from Lemma 2. This bounds the first term in the expansion of V f (p, πf ) − V g(p, πg). Now for the term involving g, we can apply essentially the same argument,\n− Ex∼Dp [g(x, πf (x))− V̂ g(p ◦ πf (x), πg)− f?(x, πf (x)) + V̂ f ? (p ◦ πf (x), πf?)] ≤ √\nEx∼Dp [(g(x, πf (x))− V̂ g(p ◦ πf (x), πg)− f?(x, πf (x)) + V̂ f ?(p ◦ πf (x), πf?))2]\n≤ √ K √ 11φ2 + 120 log(N/δ)\nntrain\nSummarizing, the current bound we have is,\nV f (p, πf )− V g(p, πg) ≤ 2 √ K √ 11φ2 + 120 log(N/δ)\nntrain + Ex∼Dp [V̂\nf (p ◦ πf (x), πf )− V̂ g(p ◦ πf (x), πg)]\nThe last term is easily bounded by the preconditions in the statement of Theorem 2. For each a, we have,\nV̂ f (p ◦ a, πf )− V̂ g(p ◦ a, πg) ≤ |V̂ f (p ◦ a, πf )− V f (p ◦ a, πf )|+ |V f (p ◦ a, πf )− V g(p ◦ a, πg)|+ |V g(p ◦ a, πg)− V̂ g(p ◦ πf (x), πg)| ≤ 2φ+ τ1,\nfrom Conditions 1 and 2. Consequently\nEx∼Dp [V̂ f (p ◦ πf (x), πf )− V̂ g(p ◦ πf (x), πg)] = ∑ a∈A Ex [ 1[πf (x) = a](V̂ f (p ◦ a, πf )− V̂ g(p ◦ a, πg)) ]\n≤ 2φ+ τ1\nThis proves the claim.\nLastly, we must show how the squared loss relates to the risk, which establishes the last claim of the Theorem. The proof is similar to that of the bias bound but has subtle differences that require reproducing the argument.\nLemma 5 (Regret Bound). Assume Conditions 1 and 2 hold. In the same 1 − δ event in Lemma 2, for any regressor f ∈ F retained by Algorithm 3, we have,\nV f ? (p, πf?)− V f ? (p, πf ) ≤ √ 2K √ 11φ2 + 120 log(N/δ)\nntrain + 2(φ+ τ1).\nProof.\nV f ? (p, πf?)− V f ? (p, πf ) = Ex[f ?(x, πf?(x))− f?(x, πf (x))]\n≤ Ex[f?(x, πf?(x))− f(x, πf?(x)) + f(x, πf (x))− f?(x, πf (x))]\nThis follows since f prefers its own action to that of f?, so that f(x, πf (x)) ≥ f(x, πf?(x)). For any observation x ∈ X and action a ∈ A, define,\n∆x,a = (f(x, a)− V̂ f (p ◦ a, πf )− f?(x, a) + V f ? (p ◦ a, πf?))\nso that we can write,\nV f ? (p, πf?)− V f ? (p, πf )\n≤ Ex[∆x,πf (x) −∆x,πf? (x) + (V̂ f (p ◦ πf (x))− V f\n? (p ◦ πf (x))− V̂ f (p ◦ πf?(x)) + V f ? (p ◦ πf?(x)))]\nThe term involving both ∆s can be bounded as in the proof of Lemma 4. For any x ∈ X\nEr,a|xY (f) + Ea|x[(V̂ f?(p ◦ a)− V f ? (p ◦ a))2] = Ea|x [ (f(x, a)− V̂ f (p ◦ a)− f?(x, a) + V f ? (p ◦ a))2 ]\n≥ ∆2x,πf (x) + ∆ 2 x,πf? (x)\nK ≥\n(∆x,πf? (x) −∆x,πf (x))2\n2K\nThus,\nEx[∆x,πf (x) −∆x,πf? (x)] ≤\n√ 2KE (∆x,πf (x) −∆x,πf? (x))2\n2K\n≤ √ 2K √ EY (f) + φ2 ≤ √ 2K √ 11φ2 + 120 log(N/δ)\nntrain\nWe are left to bound the residual term,\n(V̂ f (p ◦ πf (x))− V f ? (p ◦ πf (x))− V̂ f (p ◦ πf?(x)) + V f ?\n(p ◦ πf?(x))) ≤ (V f (p ◦ πf (x))− V f ? (p ◦ πf (x))− V f (p ◦ πf?(x)) + V f ?\n(p ◦ πf?(x))) + 2φ ≤ 2(φ+ τ1)\nProof of Theorem 2: Equipped with the above Lemmas, we can proceed to prove the theorem. By assumption of the theorem, Conditions 1 and 2 hold, so all lemmas are applicable. Apply Lemma 3 with failure probability δ/2, where δ is the parameter in the algorithm, and apply Lemma 2, which also fails with\nprobability at most δ/2. A union bound over these two events implies that the failure probability of the algorithm is at most δ.\nOutside of this failure probability event, all three of Lemmas 3, 4, and 5 hold. If we set ntrain = 24 log(2N/δ)/φ2 then these three bounds give,\n|V̂ f (p, πf )− V f (p, πf )| ≤ φ√ 12 |V f (p, πf )− V g(p, πg)| ≤ 8φ √ K + 2φ+ τ1\nV f ? (p, πf?)− V f ? (p, πf ) ≤ 4φ √ 2K + 2φ+ 2τ1.\nThese bounds hold for all f, g ∈ F that are retained by the algorithm. Of course by Lemma 2, we are also ensured that f? is retained by the algorithm. This proves the four claims in the theorem."
    }, {
      "heading" : "B Proof of Theorem 3",
      "text" : "This result is a straightforward application of Hoeffding’s inequality. We collect ntest observations xi ∼ Dp by rolling into p and use the Monte Carlo estimates,\nV̂ f (p, πf ) = 1\nntest ntest∑ i=1 f(xi, πf (xi))\nBy Hoeffding’s inequality, via a union bound over all f ∈ F , we have that with probability at least 1− δ,\n∣∣∣V̂ f (p, πf )− V f (p, πf )∣∣∣ ≤ √ 2 log(2N/δ)\nntest\nSetting ntest = 2 log(2N/δ)/φ2, gives that our empirical estimates are at most φ away from the population versions.\nNow for the first claim, if the population versions are already within τ2 of each other, then the empirical versions are at most 2φ+ τ2 apart by the triangle inequality,\n|V̂ f (p, πf )− V̂ g(p, πg)| ≤ |V̂ f (p, πf )− V f (p, πf )|+ |V f (p, πf )− V g(p, πg)|+ |V g(p, πg)− V̂ g(p, πg)| ≤ 2φ+ τ2.\nThis applies for any pair f, g ∈ F whose population value predictions are within τ2 of each other. Since the threshold in Algorithm 2 is set to 2φ+ τ2, this implies that the procedure returns true.\nFor the second claim, if the procedure returns true, then all empirical value predictions are at most test apart, so the population versions are at most 2φ + test apart, again by the triangle inequality. Specifically, for any pair f, g ∈ F we have,\n|V f (p, πf )− V g(p, πg)| ≤ |V f (p, πf )− V̂ f (p, πf )|+ |V̂ f (p, πf )− V̂ g(p, πg)|+ |V̂ g(p, πg)− V g(p, πg)| ≤ 2φ+ test.\nBoth arguments apply for all pairs f, g ∈ F , which proves the claim."
    } ],
    "references" : [ {
      "title" : "Online learning in mdps with side information",
      "author" : [ "Yasin Abbasi-Yadkori", "Gergely Neu" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2014
    }, {
      "title" : "Contextual bandit learning with predictable rewards",
      "author" : [ "Alekh Agarwal", "Miroslav Dudı́k", "Satyen Kale", "John Langford", "Robert E Schapire" ],
      "venue" : "In International Conference on Artificial Intelligence and Statistics (AISTATS),",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2012
    }, {
      "title" : "Residual algorithms: Reinforcement learning with function approximation",
      "author" : [ "Leemon Baird" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1995
    }, {
      "title" : "R-max-a general polynomial time algorithm for nearoptimal reinforcement learning",
      "author" : [ "Ronen I Brafman", "Moshe Tennenholtz" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2003
    }, {
      "title" : "Sample complexity of episodic fixed-horizon reinforcement learning",
      "author" : [ "Christoph Dann", "Emma Brunskill" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2015
    }, {
      "title" : "Efficient optimal learning for contextual bandits",
      "author" : [ "Miroslav Dudik", "Daniel Hsu", "Satyen Kale", "Nikos Karampatziakis", "John Langford", "Lev Reyzin", "Tong Zhang" ],
      "venue" : "In Uncertainty in Artificial Intelligence (UAI),",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2011
    }, {
      "title" : "Abstraction selection in model-based reinforcement learning",
      "author" : [ "Nan Jiang", "Alex Kulesza", "Satinder Singh" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2015
    }, {
      "title" : "Model-based exploration in continuous state spaces",
      "author" : [ "Nicholas K Jong", "Peter Stone" ],
      "venue" : "In Abstraction, Reformulation, and Approximation,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2007
    }, {
      "title" : "Approximately optimal approximate reinforcement learning",
      "author" : [ "Sham Kakade", "John Langford" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2002
    }, {
      "title" : "Exploration in metric state spaces",
      "author" : [ "Sham Kakade", "Michael Kearns", "John Langford" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2003
    }, {
      "title" : "Near-optimal reinforcement learning in polynomial time",
      "author" : [ "Michael Kearns", "Satinder Singh" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2002
    }, {
      "title" : "Approximate planning in large pomdps via reusable trajectories",
      "author" : [ "Michael J Kearns", "Yishay Mansour", "Andrew Y Ng" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1999
    }, {
      "title" : "A sparse sampling algorithm for near-optimal planning in large markov decision processes",
      "author" : [ "Michael J. Kearns", "Yishay Mansour", "Andrew Y. Ng" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2002
    }, {
      "title" : "The epoch-greedy algorithm for multi-armed bandits with side information",
      "author" : [ "John Langford", "Tong Zhang" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2008
    }, {
      "title" : "Reducing reinforcement learning to kwik online regression",
      "author" : [ "Lihong Li", "Michael L Littman" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2010
    }, {
      "title" : "Towards a unified theory of state abstraction for mdps",
      "author" : [ "Lihong Li", "Thomas J Walsh", "Michael L Littman" ],
      "venue" : "In International Symposium on Artificial Intelligence and Mathematics (ISAIM),",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2006
    }, {
      "title" : "Predictive representations of state",
      "author" : [ "Michael L Littman", "Richard S Sutton", "Satinder P Singh" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2001
    }, {
      "title" : "Reinforcement learning and mistake bounded algorithms",
      "author" : [ "Yishay Mansour" ],
      "venue" : "In Conference on Computational Learning Theory (COLT),",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1999
    }, {
      "title" : "Learning finite-state controllers for partially observable environments",
      "author" : [ "Nicolas Meuleau", "Leonid Peshkin", "Kee-Eung Kim", "Leslie Pack Kaelbling" ],
      "venue" : "In Uncertainty in Artificial Intelligence (UAI),",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1999
    }, {
      "title" : "Human-level control through deep reinforcement learning",
      "author" : [ "Volodymyr Mnih", "Koray Kavukcuoglu", "David Silver", "Andrei A Rusu", "Joel Veness", "Marc G Bellemare", "Alex Graves", "Martin Riedmiller", "Andreas K Fidjeland", "Georg Ostrovski" ],
      "venue" : null,
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2015
    }, {
      "title" : "A convergent form of approximate policy iteration",
      "author" : [ "Theodore J Perkins", "Doina Precup" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2002
    }, {
      "title" : "Efficient pac learning for episodic tasks with acyclic state spaces",
      "author" : [ "Spyros Reveliotis", "Theologos Bountourelis" ],
      "venue" : "Discrete Event Dynamic Systems,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2007
    }, {
      "title" : "Predictive state representations: A new theory for modeling dynamical systems. In Uncertainty in Artificial Intelligence (UAI)",
      "author" : [ "Satinder Singh", "Michael R James", "Matthew R Rudary" ],
      "venue" : null,
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2004
    }, {
      "title" : "Pac model-free reinforcement learning",
      "author" : [ "Alexander L Strehl", "Lihong Li", "Eric Wiewiora", "John Langford", "Michael L Littman" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2006
    }, {
      "title" : "Policy gradient methods for reinforcement learning with function approximation",
      "author" : [ "Richard S Sutton", "David A McAllester", "Satinder P Singh", "Yishay Mansour" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1999
    } ],
    "referenceMentions" : [ {
      "referenceID" : 19,
      "context" : "The Atari Reinforcement Learning research program [20] has highlighted a critical deficiency of reinforcement learning algorithms: they cannot effectively solve problems that require systematic exploration.",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 10,
      "context" : "How can we construct Reinforcement Learning (RL) algorithms which effectively plan and plan to explore? In RL theory, this is an effectively solved problem for Markov Decision Processes (MDPs) [11, 4, 24].",
      "startOffset" : 193,
      "endOffset" : 204
    }, {
      "referenceID" : 3,
      "context" : "How can we construct Reinforcement Learning (RL) algorithms which effectively plan and plan to explore? In RL theory, this is an effectively solved problem for Markov Decision Processes (MDPs) [11, 4, 24].",
      "startOffset" : 193,
      "endOffset" : 204
    }, {
      "referenceID" : 23,
      "context" : "How can we construct Reinforcement Learning (RL) algorithms which effectively plan and plan to explore? In RL theory, this is an effectively solved problem for Markov Decision Processes (MDPs) [11, 4, 24].",
      "startOffset" : 193,
      "endOffset" : 204
    }, {
      "referenceID" : 12,
      "context" : "Approaches to RL with a weak dependence on these quantities exist [13], but suffer from an exponential dependence on the time horizon—with K actions and a horizon of H , they require K samples.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 0,
      "context" : "1 Basic Definitions An episodic Contextual-MDP is defined by the tuple (ΓH ,Γ, D) where H ∈ N is the episode length, ΓH ∈ ∆(SH) denotes a starting state distribution, Γ : (S × A) → ∆(S) denotes the transition dynamics, and D : S → ∆(X × [0, 1]) associates a distribution over (observation, reward) pairs with each state.",
      "startOffset" : 237,
      "endOffset" : 243
    }, {
      "referenceID" : 0,
      "context" : "We use Ds ∈ ∆(X × [0, 1]) to denote the (observation, reward) distribution associated with state s and also the marginal distribution over observations (usage will be clear from context).",
      "startOffset" : 18,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "We assume that almost surely ∑H h=1 rh(ah) ∈ [0, 1] for any action sequence.",
      "startOffset" : 45,
      "endOffset" : 51
    }, {
      "referenceID" : 13,
      "context" : "3 Connections to Other Models Our model is closely related to several well-studied models in the literature, namely: Contextual Bandits: IfH = 1, then Contextual-MDPs reduce to stochastic contextual bandits [14, 6], a well-studied simplification of the general reinforcement learning problem.",
      "startOffset" : 207,
      "endOffset" : 214
    }, {
      "referenceID" : 5,
      "context" : "3 Connections to Other Models Our model is closely related to several well-studied models in the literature, namely: Contextual Bandits: IfH = 1, then Contextual-MDPs reduce to stochastic contextual bandits [14, 6], a well-studied simplification of the general reinforcement learning problem.",
      "startOffset" : 207,
      "endOffset" : 214
    }, {
      "referenceID" : 10,
      "context" : "MDPs with small state spaces can be efficiently solved by tabular approaches that maintain and update statistics about each state [11, 4, 24].",
      "startOffset" : 130,
      "endOffset" : 141
    }, {
      "referenceID" : 3,
      "context" : "MDPs with small state spaces can be efficiently solved by tabular approaches that maintain and update statistics about each state [11, 4, 24].",
      "startOffset" : 130,
      "endOffset" : 141
    }, {
      "referenceID" : 23,
      "context" : "MDPs with small state spaces can be efficiently solved by tabular approaches that maintain and update statistics about each state [11, 4, 24].",
      "startOffset" : 130,
      "endOffset" : 141
    }, {
      "referenceID" : 9,
      "context" : "[10] (see also [8]) that has sample complexity independent of the number of unique states, but assumes the ability to cover the state space in a metric a priori known to the learner.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "[10] (see also [8]) that has sample complexity independent of the number of unique states, but assumes the ability to cover the state space in a metric a priori known to the learner.",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 12,
      "context" : "[13] also implies a sample complexity bound that is independent of the observation space size for episodic MDPs, but grows as O(K).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "More recently, Abbasi-Yadkori and Neu [1] propose a model for MDPs with side-information, but this model requires mapping side-information to a small-state MDP, rather than mapping an observation to an action as in Contextual-MDPs.",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 24,
      "context" : "However, these methods use local search techniques and consequently do not achieve global optimality [25, 9] in theory as well as empirically, unlike our algorithm which is guaranteed to find the globally optimal policy.",
      "startOffset" : 101,
      "endOffset" : 108
    }, {
      "referenceID" : 8,
      "context" : "However, these methods use local search techniques and consequently do not achieve global optimality [25, 9] in theory as well as empirically, unlike our algorithm which is guaranteed to find the globally optimal policy.",
      "startOffset" : 101,
      "endOffset" : 108
    }, {
      "referenceID" : 18,
      "context" : "While there are POMDP methods for learning reactive policies, or more generally policies with bounded memory [19], they are based on policy gradient techniques, which suffer both theoretical and empirical drawbacks as we mentioned.",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 11,
      "context" : "There are some sample complexity guarantees for learning in arbitrarily complex POMDPs, but the bounds we are aware of are quite weak as they scale linearly with |Π| [12, 18].",
      "startOffset" : 166,
      "endOffset" : 174
    }, {
      "referenceID" : 17,
      "context" : "There are some sample complexity guarantees for learning in arbitrarily complex POMDPs, but the bounds we are aware of are quite weak as they scale linearly with |Π| [12, 18].",
      "startOffset" : 166,
      "endOffset" : 174
    }, {
      "referenceID" : 16,
      "context" : "Predictive State Representations (PSRs): PSRs [17] encode states as a a collection of tests, a test being a sequence of (a, x) pairs observed in the history.",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 22,
      "context" : "Representationally, PSRs are even more powerful than POMDPs [23] which make them also more general than Contextual-MDPs.",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 15,
      "context" : "4 Connections to Other Techniques State Abstraction: Our work is closely related to the literature on state abstraction (See [16] for a survey), which primarily focuses on understanding what optimality properties are preserved in an MDP after the state space is compressed.",
      "startOffset" : 125,
      "endOffset" : 129
    }, {
      "referenceID" : 6,
      "context" : "[7] which finds a good abstraction from a set of successively finer ones, but cannot search over the exponentially many abstractions functions.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 19,
      "context" : "Function approximation is the empirical state-of-the-art in reinforcement learning [20], but theoretical analysis has been quite limited.",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 20,
      "context" : "Several authors have studied linear function approximation (See [26, 21]) but none of these results give finite sample bounds, as they do not address the exploration question.",
      "startOffset" : 64,
      "endOffset" : 72
    }, {
      "referenceID" : 2,
      "context" : "Baird [3] analyzes more general function approximation for predicting the value function in a Markov Chain, but does not show convergence when the agent is also selecting actions.",
      "startOffset" : 6,
      "endOffset" : 9
    }, {
      "referenceID" : 14,
      "context" : "More closely to our work, Li and Littman [15] do give finite sample bounds for RL with function approximation, but they assume access to a particular “Knows-what-it-knows” oracle, which cannot exist even for simple problems.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 0,
      "context" : "We identify our set of policies Π with a set of regression functions F ⊂ (X ×A)→ [0, 1].",
      "startOffset" : 81,
      "endOffset" : 87
    }, {
      "referenceID" : 1,
      "context" : "[2] for contextual bandit learning in the realizable setting.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "Assumptions vary with the paper, but broadly prior results establish the sample complexity for learning layered episodic MDPs with deterministic transitions is Õ(MKpoly(H)/ ) [5, 22].",
      "startOffset" : 175,
      "endOffset" : 182
    }, {
      "referenceID" : 21,
      "context" : "Assumptions vary with the paper, but broadly prior results establish the sample complexity for learning layered episodic MDPs with deterministic transitions is Õ(MKpoly(H)/ ) [5, 22].",
      "startOffset" : 175,
      "endOffset" : 182
    }, {
      "referenceID" : 1,
      "context" : "[2] and shows that R̃(f) is close to its expectation, which implies that f∗ is never eliminated and all surviving regressors have small expected squared error.",
      "startOffset" : 0,
      "endOffset" : 3
    } ],
    "year" : 2017,
    "abstractText" : "We propose and study a new tractable model for reinforcement learning with high-dimensional observation called Contextual-MDPs, generalizing contextual bandits to a sequential decision making setting. These models require an agent to take actions based on high-dimensional observations (features) with the goal of achieving long-term performance competitive with a large set of policies. Since the size of the observation space is a primary obstacle to sample-efficient learning, Contextual-MDPs are assumed to be summarizable by a small number of hidden states. In this setting, we design a new reinforcement learning algorithm that engages in global exploration while using a function class to approximate future performance. We also establish a sample complexity guarantee for this algorithm, proving that it learns near optimal behavior after a number of episodes that is polynomial in all relevant parameters, logarithmic in the number of policies, and independent of the size of the observation space. This represents an exponential improvement on the sample complexity of all existing alternative approaches and provides theoretical justification for reinforcement learning with function approximation.",
    "creator" : "LaTeX with hyperref package"
  }
}