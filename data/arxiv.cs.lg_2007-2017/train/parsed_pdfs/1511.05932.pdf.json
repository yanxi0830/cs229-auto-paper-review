{
  "name" : "1511.05932.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "On the Global Linear Convergence of Frank-Wolfe Optimization Variants",
    "authors" : [ "Simon Lacoste-Julien", "Martin Jaggi" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "The Frank-Wolfe algorithm [9] (also known as conditional gradient) is one of the earliest existing methods for constrained convex optimization, and has seen an impressive revival recently due to its nice properties compared to projected or proximal gradient methods, in particular for sparse optimization and machine learning applications.\nOn the other hand, the classical projected gradient and proximal methods have been known to exhibit a very nice adaptive acceleration property, namely that the the convergence rate becomes linear for strongly convex objective, i.e. that the optimization error of the same algorithm after t iterations will decrease geometrically with O((1 − ρ)t) instead of the usual O(1/t) for general convex objective functions. It has become an active research topic recently whether such an acceleration is also possible for Frank-Wolfe type methods.\nContributions. We clarify several variants of the Frank-Wolfe algorithm and show that they all converge linearly for any strongly convex function optimized over a polytope domain, with a constant bounded away from zero that only depends on the geometry of the polytope. Our analysis does not depend on the location of the true optimum with respect to the domain, which was a disadvantage of earlier existing results such as [34, 12, 5], and the newer work of [28], as well as the line of work of [1, 19, 26] which rely on Robinson’s condition [30]. Our analysis yields a weaker sufficient condition than Robinson’s condition; in particular we can have linear convergence even in some cases when the function has more than one global minima, and is not globally strongly convex. The constant also naturally separates as the product of the condition number of the function with a novel notion of condition number of a polytope, which might have applications in complexity theory.\nRelated Work. For the classical Frank-Wolfe algorithm, [5] showed a linear rate for the special case of quadratic objectives when the optimum is in the strict interior of the domain, a result already subsumed by the more general [12]. The early work of [23] showed linear convergence for strongly\nar X\niv :1\n51 1.\n05 93\n2v 1\n[ m\nat h.\nO C\n] 1\n8 N\nov 2\nconvex constraint sets, under the strong requirement that the gradient norm is not too small (see [11] for a discussion). The away-steps variant of the Frank-Wolfe algorithm, that can also remove weight from ‘bad’ atoms in the current active set, was proposed in [34], and later also analyzed in [12]. The precise method is stated below in Algorithm 1. [12] showed a (local) linear convergence rate on polytopes, but the constant unfortunately depends on the distance between the solution and its relative boundary, a quantity that can be arbitrarily small. More recently, [1, 19, 26] have obtained linear convergence results in the case that the optimum solution satisfies Robinson’s condition [30]. In a different recent line of work, [10, 22] have studied a variation of FW that repeatedly moves mass from the worst vertices to the standard FW vertex until a specific condition is satisfied, yielding a linear rate on strongly convex functions. Their algorithm requires the knowledge of several constants though, and moreover is not adaptive to the best-case scenario, unlike the Frank-Wolfe algorithm with away steps and line-search. None of these previous works was shown to be affine invariant, and most require additional knowledge about problem specific parameters.\nSetup. We consider general constrained convex optimization problems of the form:\nmin x∈M f(x) , M = conv(A), with only access to: LMOA(r) ∈ arg min x∈A 〈r,x〉, (1) where A ⊆ Rd is a finite set of vectors that we call atoms.1 We assume that the function f is µstrongly convex with L-Lipschitz continuous gradient overM. We also consider weaker conditions than strong convexity for f in Section 4. AsA is finite,M is a (convex and bounded) polytope. The methods that we consider in this paper only require access to a linear minimization oracle LMOA(.) associated with the domain M through a generating set of atoms A. This oracle is defined as to return a minimizer of a linear subproblem overM = conv(A), for any given direction r ∈ Rd.2\nExamples. Optimization problems of the form (1) appear widely in machine learning and signal processing applications. The set of atoms A can represent combinatorial objects of arbitrary type. Efficient linear minimization oracles often exist in the form of dynamic programs or other combinatorial optimization approaches. As an example from tracking in computer vision, A could be the set of integer flows on a graph [16, 7], where LMOA can be efficiently implemented by a minimum cost network flow algorithm. In this case,M can also be described with a polynomial number of linear inequalities. But in other examples,M might not have a polynomial description in terms of linear inequalities, and testing membership inM might be much more expensive than running the linear oracle. This is the case when optimizing over the base polytope, an object appearing in submodular function optimization [3]. There, the LMOA oracle is a simple greedy algorithm. Another example is whenA represents the possible consistent value assignments on cliques of a Markov random field (MRF);M is the marginal polytope [32], where testing membership is NP-hard in general, though efficient linear oracles exist for some special cases [17]. Optimization over the marginal polytope appears for example in structured SVM learning [21] and variational inference [18].\nThe Original Frank-Wolfe Algorithm. The Frank-Wolfe (FW) optimization algorithm [9], also known as conditional gradient [23], is particularly suited for the setup (1) whereM is only accessed through the linear minimization oracle. It works as follows: At a current iterate x(t), the algorithm finds a feasible search atom st to move towards by minimizing the linearization of the objective function f over M (line 3 in Algorithm 1) – this is where the linear minimization oracle LMOA is used. The next iterate x(t+1) is then obtained by doing a line-search on f between x(t) and st (line 11 in Algorithm 1). One reason for the recent increased popularity of Frank-Wolfe-type algorithms is the sparsity of their iterates: in iteration t of the algorithm, the iterate can be represented as a sparse convex combination of at most t+ 1 atoms S(t) ⊆ A of the domainM, which we write as x(t) = ∑ v∈S(t) α (t) v v. We write S(t) for the active set, containing the previously discovered search atoms sr for r < t that have non-zero weight α (t) sr > 0 in the expansion (potentially also including the starting point x(0)). While tracking the active set S(t) is not necessary for the original FW algorithm, the improved variants of FW that we discuss will require that S(t) is maintained.\nZig-Zagging Phenomenon. When the optimal solution lies at the boundary of M, the convergence rate of the iterates is slow, i.e. sublinear: f(x(t))−f(x∗) ≤ O ( 1/t ) , for x∗ being an optimal solution [9, 6, 8, 15]. This is because the iterates of the classical FW algorithm start to zig-zag 1The atoms do not have to be extreme points (vertices) ofM. 2All our convergence results can be carefully extended to approximate linear minimization oracles with multiplicative approximation guarantees; we state them for exact oracles in this paper for simplicity.\nbetween the vertices defining the face containing the solution x∗ (see left of Figure 1). In fact, the 1/t rate is tight for a large class of functions: Canon and Cullum [6], Wolfe [34] showed (roughly) that f(x(t))−f(x∗) ≥ Ω ( 1/t1+δ ) for any δ > 0 when x∗ lies on a face ofM with some additional\nregularity assumptions. Note that this lower bound is different than the Ω ( 1/t )\none presented in [15, Lemma 3] which holds for all one-atom-per-step algorithms but assumes high dimensionality d ≥ t."
    }, {
      "heading" : "1 Improved Variants of the Frank-Wolfe Algorithm",
      "text" : "Algorithm 1 Away-steps Frank-Wolfe algorithm: AFW(x(0),A, ) 1: Let x(0) ∈ A, and S(0) := {x(0)} (so that α(0)v = 1 for v = x(0) and 0 otherwise) 2: for t = 0 . . . T do 3: Let st := LMOA ( ∇f(x(t)) ) and dFWt := st − x(t) (the FW direction)\n4: Let vt ∈ arg max v∈S(t)\n〈 ∇f(x(t)),v 〉 and dAt := x (t) − vt (the away direction)\n5: if gFWt := 〈 −∇f(x(t)),dFWt 〉 ≤ then return x(t) (FW gap is small enough, so return)\n6: if 〈 −∇f(x(t)),dFWt 〉 ≥ 〈 −∇f(x(t)),dAt 〉 then 7: dt := dFWt , and γmax := 1 (choose the FW direction) 8: else 9: dt := dAt , and γmax := αvt/(1− αvt) (choose away direction; maximum feasible step-size)\n10: end if 11: Line-search: γt ∈ arg min γ∈[0,γmax] f ( x(t) + γdt ) 12: Update x(t+1) := x(t) + γtdt (and accordingly for the weights α(t+1), see text) 13: Update S(t+1) := {v ∈ A s.t. α(t+1)v > 0} 14: end for\nAlgorithm 2 Pairwise Frank-Wolfe algorithm: PFW(x(0),A, ) 1: . . . as in Algorithm 1, except replacing lines 6 to 10 by: dt = dPFWt := st−vt, and γmax := αvt .\nAway-Steps Frank-Wolfe. To address the zig-zagging problem of FW, Wolfe [34] proposed to add the possibility to move away from an active atom in S(t) (see middle of Figure 1); this simple modification is sufficient to make the algorithm linearly convergent for strongly convex functions. We describe the away-steps variant of Frank-Wolfe in Algorithm 1.3 The away direction dAt is defined in line 4 by finding the atom vt in S(t) that maximizes the potential of descent given by gAt := 〈 −∇f(x(t)),x(t) − vt 〉 . Note that this search is over the (typically small) active set S(t), and is fundamentally easier than the linear oracle LMOA. The maximum step-size γmax as defined on line 9 ensures that the new iterate x(t) + γdAt stays inM. In fact, this guarantees that the convex representation is maintained, and we stay inside conv(S(t)) ⊆ M. WhenM is a simplex, then the barycentric coordinates are unique and x(t) +γmaxdAt truly lies on the boundary ofM. On the other hand, if |A| > dim(M) + 1 (e.g. for the cube), then it could hypothetically be possible to have a step-size bigger than γmax which is still feasible. Computing the true maximum feasible step-size would require the ability to know when we cross the boundary of M along a specific line, which is not possible for generalM. Using the conservative maximum step-size of line 9 ensures that we\n3The original algorithm presented in [34] was not convergent; this was corrected by Guélat and Marcotte [12], assuming a tractable representation ofM with linear inequalities and called it the modified Frank-Wolfe (MFW) algorithm. Our description in Algorithm 1 extends it to the more general setup of (1).\ndo not need this more powerful oracle. This is why Algorithm 1 requires to maintain S(t) (unlike standard FW). Finally, as in classical FW, the FW gap gFWt is an upper bound on the unknown suboptimality, and can be used as a stopping criterion:\ngFWt := 〈 −∇f(x(t)),dFWt 〉 ≥ 〈 −∇f(x(t)),x∗ − x(t) 〉 ≥ f(x(t))− f(x∗) (by convexity).\nIf γt = γmax, then we call this step a drop step, as it fully removes the atom vt from the currently active set of atoms S(t) (by settings its weight to zero). The weight updates for lines 12 and 13 are of the following form: For a FW step, we have S(t+1) = {st} if γt = 1; otherwise S(t+1) = S(t)∪{st}. Also, we have α(t+1)st := (1−γt)α (t) st +γt and α (t+1) v := (1−γt)α(t)v for v ∈ S(t)\\{st}. For an away step, we have S(t+1) = S(t) \\{vt} if γt = γmax (a drop step); otherwise S(t+1) = S(t). Also, we have α(t+1)vt := (1 + γt)α (t) vt − γt and α (t+1) v := (1 + γt)α (t) v for v ∈ S(t) \\ {vt}.\nPairwise Frank-Wolfe. The next variant that we present is inspired by an early algorithm by Mitchell et al. [25], called the MDM algorithm, originally invented for the polytope distance problem. Here the idea is to only move weight mass between two atoms in each step. More precisely, the generalized method as presented in Algorithm 2 moves weight from the away atom vt to the FW atom st, and keeps all other α weights un-changed. We call such a swap of mass between the two atoms a pairwise FW step, i.e. α(t+1)vt = α (t) vt − γ and α (t+1) st = α (t) st + γ for some step-size γ ≤ γmax := α(t)vt . In contrast, classical FW shrinks all active weights at every iteration. The pairwise FW direction will also be central to our proof technique to provide the first global linear convergence rate for away-steps FW, as well as the fully-corrective variant and Wolfe’s minnorm-point algorithm.\nAs we will see in Section 2.2, the rate guarantee for the pairwise FW variant is more loose than for the other variants, because we cannot provide a satisfactory bound on the number of the problematic swap steps (defined just before Theorem 1). Nevertheless, the algorithm seems to perform quite well in practice, often outperforming away-steps FW, especially in the important case of sparse solutions, that is if the optimal solution x∗ lies on a low-dimensional face ofM (and thus one wants to keep the active set S(t) small). The pairwise FW step is arguably more efficient at pruning the coordinates in S(t). In contrast to the away step which moves the mass back uniformly onto all other active elements S(t) (and might require more corrections later), the pairwise FW step only moves the mass onto the (good) FW atom st. A slightly different version than Algorithm 2 was also proposed by Ñanculef et al. [26], though their convergence proofs were incomplete (see Appendix A.3). The algorithm is related to classical working set algorithms, such as the SMO algorithm used to train SVMs [29]. We refer to [26] for an empirical comparison for SVMs, as well as their Section 5 for more related work. See also Appendix A.3 for a link between pairwise FW and [10].\nFully-Corrective Frank-Wolfe, and Wolfe’s Min-Norm Point Algorithm. When the linear oracle is expensive, it might be worthwhile to do more work to optimize over the active set S(t) in between each call to the linear oracle, rather than just performing an away or pairwise step. We give in Algorithm 3 the fully-corrective Frank-Wolfe (FCFW) variant, that maintains a correction polytope defined by a set of atoms A(t) (potentially larger than the active set S(t)). Rather than obtaining the next iterate by line-search, x(t+1) is obtained by re-optimizing f over conv(A(t)). Depending on how the correction is implemented, and how the correction atoms A(t) are maintained, several variants can be obtained. These variants are known under many names, such as the extended FW method by Holloway [14] or the simplicial decomposition method [31, 13]. Wolfe’s min-norm point (MNP) algorithm [35] for polytope distance problems is often confused with FCFW for quadratic objectives. The major difference is that standard FCFW optimizes f over conv(A(t)), whereas MNP implements the correction as a sequence of affine projections that potentially yield a different update, but can be computed more efficiently in several practical applications [35]. We describe precisely in Appendix A.1 a generalization of the MNP algorithm as a specific case of the correction subroutine from step 7 of the generic Algorithm 3. The original convergence analysis of the FCFW algorithm [14] (and also MNP algorithm [35]) only showed that they were finitely convergent, with a bound on the number of iterations in terms of the cardinality of A (unfortunately an exponential number in general). Holloway [14] also argued that FCFW had an asymptotic linear convergence based on the flawed argument of Wolfe [34]. As far as we know, our work is the first to provide global linear convergence rates for FCFW and MNP for\nAlgorithm 3 Fully-corrective Frank-Wolfe with approximate correction: FCFW(x(0),A, ) 1: Input: Set of atoms A, active set S(0), starting point x(0) = ∑\nv∈S(0) α(0)v v, stopping criterion .\n2: Let A(0) := S(0) (optionally, a bigger A(0) could be passed as argument for a warm start) 3: for t = 0 . . . T do 4: Let st := LMOA ( ∇f(x(t)) ) (the FW atom)\n5: Let dFWt := st − x(t) and gFWt = 〈 −∇f(x(t)),dFWt 〉 (FW gap) 6: if gFWt ≤ then return x(t) 7: (x(t+1),A(t+1)) := Correction(x(t),A(t), st, ) (approximate correction step) 8: end for\nAlgorithm 4 Approximate correction: Correction(x(t),A(t), st, ) 1: Return (x(t+1),A(t+1)) with the following properties: 2: S(t+1) is the active set for x(t+1) and A(t+1) ⊇ S(t+1). 3: f(x(t+1)) ≤ min\nγ∈[0,1] f ( x(t) + γ(st − x(t)) ) (make at least as much progress as a FW step)\n4: gAt+1 := max v∈S(t+1)\n〈 −∇f(x(t+1)),x(t+1) − v 〉 ≤ (the away gap is small enough)\ngeneral strongly convex functions. Moreover, the proof of convergence for FCFW does not require an exact solution to the correction step; instead, we show that the weaker properties stated for the approximate correction procedure in Algorithm 4 are sufficient for a global linear convergence rate (this correction could be implemented using away-steps FW, as done for example in [18])."
    }, {
      "heading" : "2 Global Linear Convergence Analysis",
      "text" : ""
    }, {
      "heading" : "2.1 Intuition for the Convergence Proofs",
      "text" : "We first give the general intuition for the linear convergence proof of the different FW variants, starting from the work of Guélat and Marcotte [12]. We assume that the objective function f is smooth over a compact set M, i.e. its gradient is Lipschitz continuous with constant L. Also let M := diam(M). Let dt be the direction in which the line-search is executed by the algorithm (Line 11 in Algorithm 1). By the standard descent lemma [see e.g. (1.2.5) in 27], we have:\nf(x(t+1)) ≤ f(x(t) + γdt) ≤ f(x(t)) + γ 〈 ∇f(x(t)),dt 〉 + γ2\n2 L‖dt‖2 ∀γ ∈ [0, γmax]. (2)\nWe let rt := −∇f(x(t)) and let ht := f(x(t)) − f(x∗) be the suboptimality error. Supposing for now that γmax ≥ γ∗t := 〈rt,dt〉 /(L‖dt‖2). We can set γ = γ∗t to minimize the RHS of (2), subtract f(x∗) on both sides, and re-organize to get a lower bound on the progress:\nht − ht+1 ≥ 〈rt,dt〉2\n2L‖dt‖2 =\n1\n2L 〈rt, d̂t〉2 , (3)\nwhere we use the ‘hat’ notation to denote normalized vectors: d̂t := dt/‖dt‖. Let et := x∗ − x(t) be the error vector. By µ-strong convexity of f , we have:\nf(x(t) + γet) ≥ f(x(t)) + γ 〈 ∇f(x(t)), et 〉 + γ2\n2 µ‖et‖2 ∀γ ∈ [0, 1]. (4)\nThe RHS is lower bounded by its minimum as a function of γ (unconstrained), achieved using γ := 〈rt, et〉/(µ‖et‖2). We are then free to use any value of γ on the LHS and maintain a valid bound. In particular, we use γ = 1 to obtain f(x∗). Again re-arranging, we get:\nht ≤ 〈rt, êt〉2\n2µ , and combining with (3), we obtain: ht − ht+1 ≥\nµ\nL\n〈rt, d̂t〉2 〈rt, êt〉2 ht. (5)\nThe inequality (5) is fairly general and valid for any line-search method in direction dt. To get a linear convergence rate, we need to lower bound (by a positive constant) the term in front of ht on the RHS, which depends on the angle between the update direction dt and the negative gradient rt. If we assume that the solution x∗ lies in the relative interior ofMwith a distance of at least δ > 0 from the boundary, then 〈rt,dt〉 ≥ δ‖rt‖ for the FW direction dFWt , and by combining with ‖dt‖ ≤ M , we get a linear rate with constant 1 − µL ( δ M )\n2 (this was the result from [12]). On the other hand, if x∗ lies on the boundary, then 〈r̂t, d̂t〉 gets arbitrary close to zero for standard FW (the zig-zagging phenomenon) and the convergence is sublinear.\nProof Sketch for AFW. The key insight to prove the global linear convergence for AFW is to relate 〈rt,dt〉 with the pairwise FW direction dPFWt := st − vt. By the way the direction dt is chosen on lines 6 to 10 of Algorithm 1, we have:\n2〈rt,dt〉 ≥ 〈rt,dFWt 〉+ 〈rt,dAt 〉 = 〈rt,dFWt + dAt 〉 = 〈rt,dPFWt 〉. (6) We thus have 〈rt,dt〉 ≥ 〈rt,dPFWt 〉/2. Now the crucial property of the pairwise FW direction is that for any potential negative gradient direction rt, the worst case inner product 〈r̂t,dPFWt 〉\ndFWt\ndAt\ndpFWt\nx vt\nst rt can be lower bounded away from zero by a quantity depending only on the geometry ofM (unless we are at the optimum). We call this quantity the pyramidal width of A. The figure on the right shows the six possible pairwise FW directions dPFWt for a triangle domain, depending on which colored area the rt direction falls into. We will see that the pyramidal width is related to the smallest width of pyramids that we can construct from A in a specific way related to the choice of the away and towards atoms vt and st. See (9) and our main Theorem 3 in Section 3.\nThis gives the main argument for the linear convergence of AFW for steps where γ∗t ≤ γmax. When γmax is too small, AFW will perform a drop step, as the line-search will truncate the step-size to γt = γmax. We cannot guarantee sufficient progress in this case, but the drop step decreases the active set size by one, and thus they cannot happen too often (not more than half the time). These are the main elements for the global linear convergence proof for AFW. The rest is to carefully consider various boundary cases. We can re-use the same techniques to prove the convergence for pairwise FW, though unfortunately the latter also has the possibility of problematic swap steps. While their number can be bounded, so far we only found the extremely loose bound quoted in Theorem 1.\nProof Sketch for FCFW. For FCFW, by line 4 of the correction Algorithm 4, the away gap satisfies gAt ≤ at the beginning of a new iteration. Supposing that the algorithm does not exit at line 6 of Algorithm 3, we have gFWt > and therefore 2〈rt,dFWt 〉 ≥ 〈rt,dPFWt 〉 using a similar argument as in (6). Finally, by line 3 of Algorithm 4, the correction is guaranteed to make at least as much progress as a line-search in direction dFWt , and so the progress bound (5) applies also to FCFW."
    }, {
      "heading" : "2.2 Convergence Results",
      "text" : "We now give the global linear convergence rates for the four variants of the FW algorithm: awaysteps FW (AFW Alg. 1); pairwise FW (PFW Alg. 2); fully-corrective FW (FCFW Alg. 3 with approximate correction Alg. 4); and Wolfe’s min-norm point algorithm (Alg. 3 with MNP-correction as Alg. 5 in Appendix A.1). For the AFW, MNP and PFW algorithms, we call a drop step when the active set shrinks |S(t+1)| < |S(t)|. For the PFW algorithm, we also have the possibility of a swap step where γt = γmax but |S(t+1)| = |S(t)| (i.e. the mass was fully swapped from the away atom to the FW atom). A nice property of FCFW is that it does not have any drop step (it executes both FW steps and away steps simultaneously while guaranteeing enough progress at every iteration). Theorem 1. Suppose that f has L-Lipschitz gradient4 and is µ-strongly convex over M = conv(A). Let M = diam(M) and δ = PWidth(A) as defined by (9). Then the suboptimality ht of the iterates of all the four variants of the FW algorithm decreases geometrically at each step that is not a drop step nor a swap step (i.e. when γt < γmax, called a ‘good step’), that is\nht+1 ≤ (1− ρ)ht , where ρ := µ\n4L\n( δ\nM\n)2 .\nLet k(t) be the number of ‘good steps’ up to iteration t. We have k(t) = t for FCFW; k(t) ≥ t/2 for MNP and AFW; and k(t) ≥ t/(3|A|!+1) for PFW (because of the swap steps). This yields a global linear convergence rate of ht ≤ h0 exp(−ρ k(t)) for all variants. If µ = 0 (general convex), then ht = O(1/k(t)) instead. See Theorem 8 in Appendix D for an affine invariant version and proof.\nNote that to our knowledge, none of the existing linear convergence results showed that the duality gap was also linearly convergent. The result for the gap follows directly from the simple manipulation of (2); putting the FW gap to the LHS and optimizing the RHS for γ ∈ [0, 1]. Theorem 2. Suppose that f has L-Lipschitz gradient overM with M := diam(M). Then the FW gap gFWt for any algorithm is upper bounded by the primal error ht as follows:\ngFWt ≤ ht + LM2/2 when ht > LM2/2, gFWt ≤M √\n2htL otherwise . (7) 4For AFW and PFW, we actually require that∇f is L-Lipschitz over the larger domainM+M−M."
    }, {
      "heading" : "3 Pyramidal Width",
      "text" : "We now describe the claimed lower bound on the angle between the negative gradient and the pairwise FW direction, which depends only on the geometric properties of M. According to our argument about the progress bound (5) and the PFW gap (6), our goal is to find a lower bound on 〈rt,dPFWt 〉/〈rt, êt〉. First note that 〈rt,dPFWt 〉=〈rt, st−vt〉= max\ns∈M,v∈S(t) 〈rt, s−v〉 where S(t) is a pos-\nsible active set for x(t). This looks like the directional width of a pyramid with base S(t) and summit st. To be conservative, we consider the worst case possible active set for x(t); this is what we will call the pyramid directional width PdirW (A, rt,x(t)). We start with the following definitions. Directional Width. The directional width of a set A with respect to a direction r is defined as dirW (A, r) := maxs,v∈A 〈 r ‖r‖ , s− v 〉 . The width of A is the minimum directional width over all possible directions in its affine hull. Pyramidal Directional Width. We define the pyramidal directional width of a set A with respect to a direction r and a base point x ∈M to be\nPdirW (A, r,x) := min S∈Sx dirW (S ∪ {s(A, r)}, r) = min S∈Sx max s∈A,v∈S\n〈 r ‖r‖ , s− v 〉 , (8)\nwhere Sx := {S | S ⊆ A such that x is a proper5 convex combination of all the elements in S}, and s(A, r) := arg maxv∈A〈r,v〉 is the FW atom used as a summit.\nPyramidal Width. To define the pyramidal width of a set, we take the minimum over the cone of possible feasible directions r (in order to avoid the problem of zero width). A direction r is feasible for A from x if it points inwards conv(A), (i.e. r ∈ cone(A− x)). We define the pyramidal width of a set A to be the smallest pyramidal width of all its faces, i.e.\nPWidth(A) := min K∈faces(conv(A))\nx∈K r∈cone(K−x)\\{0}\nPdirW (K ∩A, r,x). (9)\nTheorem 3. Let x ∈ M = conv(A) be a suboptimal point and S be an active set for x. Let x∗ be an optimal point and corresponding error direction ê = (x∗−x)/ ‖x∗ − x‖, and negative gradient r := −∇f(x) (and so 〈r, ê〉 > 0). Let d = s−v be the pairwise FW direction obtained over A and S with negative gradient r. Then\n〈r,d〉 〈r, ê〉 ≥ PWidth(A). (10)"
    }, {
      "heading" : "3.1 Properties of Pyramidal Width and Consequences",
      "text" : "Examples of Values. The pyramidal width of a setA is lower bounded by the minimal width over all subsets of atoms, and thus is strictly greater than zero if the number of atoms is finite. On the other hand, this lower bound is often too loose to be useful, as in particular, vertex subsets of the unit cube in dimension d can have exponentially small width O(d− d 2 ) [see Corollary 27 in 36]. On the other hand, as we show here, the pyramidal width of the unit cube is actually 1/ √ d, justifying why we kept the tighter but more involved definition (9). See Appendix B.1 for the proof. Lemma 4. The pyramidal width of the unit cube in Rd is 1/ √ d.\nFor the probability simplex with d vertices, the pyramidal width is actually the same as its width, which is 2/ √ d when d is even, and 2/ √ d−1/d when d is odd [2] (see Appendix B.1). In contrast, the pyramidal width of an infinite set can be zero. For example, for a curved domain, the set of active atoms S can contain vertices forming a very narrow pyramid, yielding a zero width in the limit.\nCondition Number of a Set. The inverse of the rate constant ρ appearing in Theorem 1 is the product of two terms: L/µ is the standard condition number of the objective function appearing in the rates of gradient methods in convex optimization. The second quantity (M/δ)2 (diameter over pyramidal width) can be interpreted as a condition number of the domain M, or its eccentricity. The more eccentric the constraint set (large diameter compared to its pyramidal width), the slower the convergence. The best condition number of a function is when its level sets are spherical; the analog in term of the constraint sets is actually the regular simplex, which has the maximum widthto-diameter ratio amongst all simplices [see Corollary 1 in 2]. Its eccentricity is (at most) d/2. In contrast, the eccentricity of the unit cube is d2, which is much worse.\n5By proper convex combination, we mean that all coefficients are non-zero in the convex combination.\nWe conjecture that the pyramidal width of a set of vertices (i.e. extrema of their convex hull) is non-increasing when another vertex is added (assuming that all previous points remain vertices). For example, the unit cube can be obtained by iteratively adding vertices to the regular probability simplex, and the pyramidal width thereby decreases from 2/ √ d to 1/ √ d. This property could provide lower bounds for the pyramidal width of more complicated polytopes, such as 1/ √ d for the d-dimensional marginal polytope, as it can be obtained by removing vertices from the unit cube.\nComplexity Lower Bounds. Combining the convergence Theorem 1 and the condition number of the unit simplex, we get a complexity of O(dLµ log( 1 )) to reach -accuracy when optimizing a strongly convex function over the unit simplex. Here the linear dependence on d should not come as a surprise, in view of the known lower bound of 1/t for t ≤ d for Frank-Wolfe type methods [15]. Applications to Submodular Minimization. See Appendix A.2 for a consequence of our linear rate for the popular MNP algorithm for submodular function optimization (over the base polytope)."
    }, {
      "heading" : "4 Non-Strongly Convex Generalization",
      "text" : "Building on the work of Beck and Shtern [4] and Wang and Lin [33], we can generalize our global linear convergence results for all Frank-Wolfe variants for the more general case where f(x) := g(Ax) + 〈b,x〉, for A ∈ Rp×d, b ∈ Rd and where g is µg-strongly convex and continuously differentiable over AM. We note that for a general matrix A, f is convex but not necessarily strongly convex. In this case, the linear convergence still holds but with the constant µ appearing in the rate of Theorem 1 replaced with the generalized constant µ̃ appearing in Lemma 9 in Appendix F.\n5 Illustrative Experiments\nWe illustrate the performance of the presented algorithm variants in two numerical experiments, shown in Figure 2. The first example is a constrained Lasso problem (`1-regularized least squares regression), that is minx∈M f(x) = ‖Ax− b‖2, withM = 20 · L1 a scaled L1-ball. We used a random Gaussian matrix A ∈ R200×500, and a noisy measurement b = Ax∗ with x∗ being a sparse vector with 50 entries ±1, and 10% of additive noise. For the L1-ball, the linear minimization oracle LMOA just selects the column of A of best inner product with the residual vector. The second application comes from video co-localization. The approach used by [16] is formulated as a quadratic program (QP) over a flow polytope, the convex hull of paths in a network. In this application, the linear minimization oracle is equivalent to finding a shortest path in the network, which can be done easily by dynamic programming. For the LMOA, we re-use the code provided by [16] and their included aeroplane dataset resulting in a QP over 660 variables. In both experiments, we see that the modified FW variants (away-steps and pairwise) outperform the original FW algorithm, and exhibit a linear convergence. In addition, the constant in the convergence rate of Theorem 1 can also be empirically shown to be\nfairly tight for AFW and PFW by running them on an increasingly obtuse triangle (see Appendix E).\nDiscussion. Building on a preliminary version of our work [20], Beck and Shtern [4] also proved a linear rate for away-steps FW, but with a simpler lower bound for the LHS of (10) using linear duality arguments. However, their lower bound [see e.g. Lemma 3.1 in 4] is looser: they get a d2 constant for the eccentricity of the regular simplex instead of the tighter d that we proved. Finally, the recently proposed generic scheme for accelerating first-order optimization methods in the sense of Nesterov from [24] applies directly to the FW variants given their global linear convergence rate that we proved. This gives for the first time first-order methods that only use linear oracles and obtain the “near-optimal” Õ(1/k2) rate for smooth convex functions, or the accelerated Õ( √ L/µ) constant in the linear rate for strongly convex functions. Given that the constants also depend on the dimensionality, it remains an open question whether this acceleration is practically useful. Acknowledgements. We thank J.B. Alayrac, E. Hazan, A. Hubard, A. Osokin and P. Marcotte for helpful discussions. This work was partially supported by the MSR-Inria Joint Center and a Google Research Award."
    }, {
      "heading" : "A More on Frank-Wolfe Algorithm Variants",
      "text" : ""
    }, {
      "heading" : "A.1 Wolfe’s Min-Norm Point (MNP) algorithm",
      "text" : "A generalization of Wolfe’s min-norm point (MNP) algorithm [35] for general convex functions is to run Algorithm 3 with the correction subroutine in step 7 implemented as presented below in Algorithm 5. In Wolfe’s paper [35], the correction step is called the minor cycle; whereas the FW outer loop is called the major cycle.\nAs we have mentioned in Section 1, MNP for polytope distance is often confused with fullycorrective FW as presented in Algorithm 3, for quadratic objectives. In fact, standard FCFW optimizes f over conv(A(t)), whereas MNP implements the correction as a sequence of affine projections on the active set that potentially yield a different update.\nAlgorithm 5 Generalized version of Wolfe’s MNP correction: MNP-Correction(x(t),A(t), st) 1: Let S(0) := A(t) ⋃ {st}, and z0 := x(t). Note that x(t) = ∑ v∈A(t) αv v and we assume that\nthe elements of A(t) are affinely independent. 2: for k = 1 . . . |S(0)| do 3: Let yk be the minimizer of f on the affine hull of S(k−1) 4: if yk is in the relative interior of conv(S(k−1)) then 5: return (yk,S(k−1)) (S(k−1) is active set for yk) 6: else 7: Let zk be the solution of doing line-search from zk−1 to yk. [step 2(d)(iii) of Alg. 1 in 39] 8: (Note that zk now lies on the boundary of conv(S(k−1)), and so some atoms were removed) 9: Let S(k) be the (affinely independent) active atoms in the expansion of zk.\n10: end if 11: end for\nThere are two main differences between FCFW and the MNP algorithm. First, after a correction step, MNP guarantees that x(t+1) is both the minimizer of f over the affine hull of A(t+1) and also conv(A(t+1)) (where A(t+1) might be much smaller than A(t) ∪ {st}), whereas FCFW guarantees that x(t+1) is the minimizer of f over conv(A(t) ∪ {st}) – this is usually not the case for MNP unless at most one atom was dropped from the correction polytope, as is apparent from our convergence proof. Secondly, the correction atoms A(t) are always affinely independent for MNP and are identical to the active set S(t), whereas FCFW can use both redundant as well as inactive atoms. The advantage of the MNP implementation using affine hull projections is that the correction can be efficiently implemented when f is the Euclidean norm, especially when a triangular array repre-\nsentation of the active set is maintained (see the careful implementation details in Wolfe’s original paper [35]).\nThe MNP variant indeed only makes sense when the minimization of f over the affine hull ofM is well-defined (and is efficient). Note though that the line-search in step 7 does not require any new information aboutM, as it is made only with respect to conv(S(k−1)), for which we have an explicit list of vertices. This line-search can be efficiently computed in O(|S(k−1)|), and is well described for example in step 2(d)(iii) of Algorithm 1 of Chakrabarty et al. [39]."
    }, {
      "heading" : "A.2 Applications to Submodular Minimization",
      "text" : "An interesting consequence of our global linear convergence result for FW algorithm variants here is the potential to reduce the gap between the known theoretical rates and the impressive empirical performance of MNP for submodular function minimization (over the base polytope). While Bach [3] already showed convergence of FW in this case, Chakrabarty et al. [39] later gave a weaker convergence rate for Wolfe’s MNP variant. For exact submodular function optimization, the overall complexity by [39] was O(d5F 2) (with some corrections6), where F is the maximum absolute value of the integer-valued submodular function. This is in contrast toO(d5 log(dF )) for the fastest algorithms [40]. Using our linear convergence, the F factor can be put back in the log term for MNP,7 matching their empirical observations that the MNP algorithm was not too sensitive to F . The same follows for AFW and FCFW, which is novel."
    }, {
      "heading" : "A.3 Pairwise Frank-Wolfe",
      "text" : "Our new analysis of the pairwise Frank-Wolfe variant as introduced in Section 1 is motivated by the work of Garber and Hazan [10], who provided the first variant of Frank-Wolfe with a global linear convergence rate with explicit constants that do not depend on the location of the optimum x∗, for a more complex extension of such a pairwise algorithm. An important contribution of the work of Garber and Hazan [10] was to define the concept of local linear oracle, which (approximately) minimizes a linear function on the intersection ofM and a small ball around x(t) (hence the name local). They showed that if such a local linear oracle was available, then one could replace the step that moves towards st in the standard FW procedure with a constant step-size move towards the point returned by the local linear oracle to obtain a globally linearly convergent algorithm. They then demonstrated how to implement such a local linear oracle by using only one call to the linear oracle (to get st), as well as sorting the atoms in S(t) in decreasing order of their inner product with ∇f(x(t)) (note that the first element then is the away atom vt from Algorithm 1). The procedure implementing the local linear oracle amounts to iteratively swapping the mass from the away atom vt to the FW atom st until enough mass has been moved (given by some precomputed constants). If the amount of mass to move is bigger than α(t)vt , then one sets α (t) vt to zero and start moving mass from the second away atom, and so on, until enough mass has been moved (which is why the sorting is needed). We call such a swap of mass between the away atom and the FW atom a pairwise FW step, i.e. α(t+1)vt = α (t) vt − γ and α (t+1) st = α (t) st + γ for some step-size γ ≤ γmax := α (t) vt . The local linear oracle is implemented as a sequence of pairwise FW steps, always keeping the same FW atom st as the target, but updating the away atom to move from as we set their coordinates to zero.\nA major disadvantage of the algorithm presented by Garber and Hazan [10] is that their algorithm is not adaptive: it requires the computation of several (loose) constants to determine the step-sizes, which means that the behavior of the algorithm is stuck in its worst-case analysis. The pairwise Frank-Wolfe variant is obtained by simply doing one line-search in the pairwise Frank-Wolfe direction dPFWt := st − vt (see Algorithm 2). This gives a fully adaptive algorithm, and it turns out that this is sufficient to yield a global linear convergent rate.\n6Chakrabarty et al. [39] quoted a complexity of O(d7F 2) for MNP. However, this fell short of the earlier result of Bach [3] for classic FW in the submodular minimization case, which was better by two O(d) factors. [39] counted O(d3) per iteration of the MNP algorithm whereas Wolfe had provided a O(d2) implementation; and they missed that there were at least t/2 good cycles (‘non drop steps’) after t iterations, rather than O(t/d) as they have used.\n7This is assuming that the eccentricity of the base polytope does not depend on F , which remains to be proven.\nNotes on Convergence Proofs in [26]. We here point out some corrections to the convergence proofs given in [26] for a variant of pairwise FW that chooses between a standard FW step and a pairwise FW step by picking the one which makes the most progress on the objective after a line-search. [26, Proposition 1] states the global convergence of their algorithm by arguing that 〈−∇f(x(t)),dPFWt 〉 ≥ 〈−∇f(x(t)),dFWt 〉 and then stating that they can re-use the same pattern as the standard FW convergence proof but with the direction dPFWt . But this is forgetting the fact that the maximal step-size γmax = αvt for a pairwise FW step can be too small to make sufficient progress. Their global convergence statement is still correct as every step of their algorithm makes more progress than a FW step, which already has a global convergence result, but this is not the argument they made. Similarly, they state a global linear convergence result in their Proposition 4, citing a proof from [37]. On the other hand, the relevant used Proposition 3 in [37] forgot to consider the possibility of problematic swap steps that we had to painfully bound in our convergence Theorem 8; they only considered drop steps or ‘good steps’, thereby missing a bound on the number of swap steps to get a valid global bound."
    }, {
      "heading" : "A.4 Other Related Work",
      "text" : "Very recently, following the earlier workshop version of our article [20], Pena et al. [28] presented an alternative geometric quantity measuring the linear convergence speed of the AFW algorithm variant. Their approach is motivated by a special case of the Frank-Wolfe method, the von Neumann algorithm. Their complexity constant – called the restricted width – is also bounded away from zero, but its value does depend on the location of the optimal solution, which is a disadvantage shared with the earlier existing results of [34, 12, 5], as well as the line of work of [1, 19, 26] that relies on Robinson’s condition [30]. More precisely, the bound on the constant given in [28, Theorem 4] applies to the translated atoms Ã relative to the optimum point. The constant is not affine-invariant, whereas the constants µAf (22) and C A f (26) in our setting are so, see the discussion in Section C. It would still be interesting to compare the value of our respective constants on standard polytopes."
    }, {
      "heading" : "B Pyramidal Width",
      "text" : ""
    }, {
      "heading" : "B.1 Pyramidal Width of the Cube and Probability Simplex",
      "text" : "Lemma’ 4. The pyramidal width of the unit cube in Rd is 1/ √ d.\nProof of Lemma 4. First consider a point x in the interior of the cube, and let r be the unit length direction achieving the smallest pyramidal width for x. Let s = s(A, r) (the FW atom in direction r). Without loss of generality, by symmetry,8 we can rotate the cube so that s lies at the origin. This implies that each coordinate of r is non-positive. Represent a vertex v of the cube as its set of indices for which vi = 1. Then 〈r, s− v〉 = ∑ i∈v −ri ≥ maxi∈v |ri|. Consider any possible active set S; as x has all its coordinate strictly positive, for each dimension i, there must exist an element of S with its i coordinate equals to 1. This means that maxv∈S〈r, s − v〉 ≥ ‖r‖∞. But as r has unit Euclidean norm, then ‖r‖∞ ≥ 1/ √ d. Now consider x to lie on a facet of the cube (i.e. the active set S is lower dimensional); and let I := {i : ri < 0}. Since r has to be feasible from x, for each i ∈ I , we cannot have xi = 0 and thus there exists an element of the active set with its ith coordinate equal to 1. We thus have that maxv∈S〈r, s − v〉 ≥ ‖r‖∞ ≥ 1/ √ |I| ≥ 1/ √ d.\nUsing the same argument on a lower dimensional K give a lower bound of 1/ √\ndim(K) which is bigger. These cover all the possibilities appearing in the definition of the pyramidal width, and thus the lower bound is correct. It is achieved by choosing an x in the interior, the canonical basis as the active set S, and the direction defined by ri = −1/ √ d for each i.\nWe note that both the active set definition S and the feasibility condition on r were crucially used in the above proof to obtain such a large value for the pyramidal width of the unit cube, thus justifying the somewhat involved definition appearing in (9). On the other hand, the astute reader might have noticed that the important quantity to lower bound for the linear convergence rate of the different FW variants is 〈rt,d̂t〉〈rt,êt〉 (as in (5)), rather than the looser value 1 M 〈rt,dt〉 〈rt,êt〉 that we used to handle the\n8We thank Jean-Baptiste Alayrac for inspiring us to use symmetry in the proof.\nproof of the difficult Theorem 3 (where we recall that M is the diameter of M). One could thus hope to get a tighter measure for the condition number of a set by considering ‖s− v‖ (with s and v the minimizing witnesses for the pyramidal width) instead of the diameter M in the ratio diameter / pyramidal width. This might give a tighter constant for general sets, but in the case of the cube, it does not change the general Ω(d2) dependence for its condition number. To see this, suppose that d is even and let k = d/2. Consider the direction r with ri := −1 for 1 ≤ i ≤ k, and ri := − for (k+1) ≤ i ≤ d. We thus have that the FW atom s(A, r) is the origin as before. Consider x such that xi := 1/k for 1 ≤ i ≤ k, and xi := 1 for (k+1) ≤ i ≤ d, that is, x is the uniform convex combination of the k vertices which has only one non-zero in the first k coordinates, and the last k coordinates all equal to 1. We have that r is a feasible direction from x, and that all vertices in the active set for x have the same inner product with r: maxv∈S〈r, s− v〉 = 1 + k . We thus have:〈\nr\n‖r‖ , s− v ‖s− v‖\n〉 =\n1 + k\n( √ k √ 1 + 2)( √ k + 1) ≤ 1 k for small enough.\nSquaring the inverse, we thus get that the condition number of the cube is at least k2 = d2/4 even using this tighter definition, thus not changing the Ω(d2) dependence.\nPyramidal Width for the Probability Simplex. For any x in the relative interior of the probability simplex on d vertices, we have that S = A, and thus the pyramidal directional width (8) in the feasible direction r with base point x is the same as the standard directional width. Moreover, any face of the probability simplex is just a probability simplex in lower dimensions (with bigger width). This is why the pyramidal width of the probability simplex is the same as its standard width. The width of a regular simplex was implicitly given in [2]; we provide more details here on this citation. Alexander [2] considers a regular simplex with k vertices and side length ∆. For any partition of the k points into a set of r and k − r points (for r ≤ bk/2c), one can compute the distance c(r,∆) between the flats (affine hulls) of the two sets (which also corresponds to a specific directional width). Alexander gives a formula on the third line of p. 91 in [2] for the square of this distance:\n(c(r,∆)) 2 = ∆2 k\n2r(k − r) . (11)\nThe width of the regular simplex is obtained by taking the minimum of (11) with respect to r ≤ bk/2c. As (11) is a decreasing function up to r = k/2, we obtain its minimum by substituting r = bk/2c. By using ∆ = √ 2, k = d and r = bd/2c in (11), we get that the width for the probability simplex on d vertices is 2/ √ d when d is even and the slightly bigger 2/ √ d− 1/d when d is odd.\nFrom the pyramidal width perspective, one can obtain these numbers by considering any relative interior point of the probability simplex as x and considering the following feasible r. For d even, we let ri := 1 for 1 ≤ i ≤ d/2 and ri := −1 for i > d/2. Note that ∑ i ri = 0 and thus r is a feasible direction for a point in the relative interior of the probability simplex. Then maxs,v∈A〈 r‖r‖ , s−v〉 = 1√ d (1 + 1) = 2√ d as claimed. For d odd, we can choose ri := 2d−1 for 1 ≤ i ≤ d−1 2 , and ri := 2 d+1\nfor i ≥ d+12 . Then ‖r‖ = √ 4d d2−1 and maxs,v∈A〈 r ‖r‖ , s − v〉 = √ 4d d2−1 = 2/ √ d− 1/d as claimed. Showing that these obtained values were the minimum possible ones is non-trivial though, which is why we appealed to the width of the regular simplex computed from [2]."
    }, {
      "heading" : "B.2 Proof of Theorem 3 on the Pyramidal Width",
      "text" : "In this section, we prove the main technical result in our paper: a geometric lower bound for the crucial quantity appearing in the linear convergence rate for the FW optimization variants.\nTheorem’ 3. Let x ∈M = conv(A) be a suboptimal point and S be an active set for x. Let x∗ be an optimal point and corresponding error direction ê = (x∗−x)/ ‖x∗ − x‖, and negative gradient r := −∇f(x) (and so 〈r, ê〉 > 0). Let dPFW be the pairwise FW direction obtained over A and S with negative gradient r. Then we have:\n〈r,dPFW〉 〈r, ê〉 ≥ PWidth(A). (12)\nWe first give a proof sketch, and then give the full proof.\nRecall that a direction r is feasible forA from x if it points inwards conv(A), i.e. r ∈ cone(A−x).\nWarm-Up Proof Sketch. By Cauchy-Schwarz, the denominator of (12) is at most ‖r‖. If r is a feasible direction from x for A, then the LHS is lower bounded by PdirW (A, r,x) as dPFW is included as a possible s−v direction considered in the definition of PdirW (8). If r is not feasible from x, this means that x lies on the boundary ofM. One can then show that the potential x∗ that can maximize 〈r, ê〉 has also to lie on a facet K ofM containing x (see Lemma 5 below). The idea is then to project r ontoK, and re-do the argument withK replacingM and show that the inequality is in the right direction. This explains why all the subfaces ofM are considered in the definition of the pyramidal width (9), and that only feasible directions are considered.\nLemma 5 (Minimizing angle is on a facet). Let x be at the origin, inside a polytope K and suppose that r ∈ span(K) is not a feasible direction for K from x (i.e. r /∈ cone(K)). Then a feasible direction in K minimizing the angle with r lies on a facet9 K′ of K that includes the origin x. That is:\nmax e∈K\n〈 r, e\n‖e‖\n〉 = max\ne∈K′\n〈 r, e\n‖e‖\n〉 = max\ne∈K′\n〈 r′, e\n‖e‖\n〉 (13)\nwhere K′ contains x, ‖ · ‖ is the Euclidean norm and r′ is defined as the orthogonal projection of r on span(K′).\nProof. This seems like an obvious geometric fact (see Figure 3), but we prove it formally, as sometimes high dimensional geometry is tricky (for example, the result is false without the assumption that r ∈ span(K) or if ‖·‖ is not the Euclidean norm). Rewrite the optimization variable on the LHS of (13) as ê = e‖e‖ . The optimization domain for ê is thus the intersection between the unit sphere and cone(K). We now show that any maximizer ê∗ cannot lie in the relative interior of cone(K), and thus it has to lie on a facet of cone(K), implying then that a corresponding maximizer e∗ is lying on a facet of K containing x, concluding the proof for the first equality in (13). First, as r ∈ span(K), we can consider without loss of generality that cone(K) is full dimensional by projecting on its affine hull if needed. We want to solve maxê 〈r, ê〉 s.t. ‖ê‖2 = 1 and ê ∈ cone(K).\n9As a reminder, we define a k-face ofM (a k-dimensional face ofM) a set K such that K =M∩ {y : 〈r,y − x〉 = 0} for some normal vector r and fixed reference point x ∈ K with the additional property that M lies on one side of the given half-space determined by r i.e. 〈r,y − x〉 ≤ 0 ∀y ∈ M. k is the dimensionality of the affine hull ofK. We call a k-face of dimensions k = 0, 1, dim(M)− 2 and dim(M)− 1 a vertex, edge, ridge and facet respectively. M is a k-face of itself with k = dim(M). See Definition 2.1 in the book of Ziegler [41], which we also recommend for more background material on polytopes.\nBy contradiction, we suppose that ê∗ lies in the interior of cone(K), and so we can remove the polyhedral cone constraint. The gradient of the objective is the constant r and the gradient of the equality constraint is 2ê. By the Karush-Kuhn-Tucker (KKT) necessary conditions for a stationary point to the problem with the only equality constraint ‖ê‖2 = 1 (see e.g. [Proposition 3.3.1 in 38]), then the gradient of the objective is collinear to the gradient of the equality constraint, i.e. we have ê∗ = ±r̂. Since r̂ is not feasible, then ê∗ = −r̂, which is actually a local minimum of the inner product by Cauchy-Schwarz. We thus conclude that the maximizing ê∗ lies on the boundary of cone(K), concluding the proof for the first equality in (13). For the second equality in (13), we simply use the fact that r−r′ is orthogonal to the elements ofK′ by the definition of the orthogonal projection.\nProof of Theorem 3. Let ê(x∗) := x ∗−x\n‖x∗−x‖ be the normalized error vector. We consider the worstcase possibility for x∗. As x is not optimal, we require that 〈r, ê(x∗)〉 > 0. We recall that by definition of the pairwise FW direction:〈\nr\n‖r‖ ,dPFW\n〉 = max\ns∈A,v∈S\n〈 r\n‖r‖ , s− v 〉 ≥ min S′∈Sx max s∈A,v∈S′ 〈 r ‖r‖ , s− v 〉 = PdirW (A, r,x).\n(14) By Cauchy-Schwarz, we always have 〈r, ê(x∗)〉 ≤ ‖r‖. If r is a feasible direction from x in conv(A), then r appears in the set of directions considered in the definition of the pyramidal width (9) for A and so from (14), we have that the inequality (12) holds. If r is not a feasible direction, then we iteratively project it on the faces ofM until we get a feasible direction r′, obtaining a term PdirW (A ∩ K, r′,x) for some face K of M as appearing in the definition of the pyramidal width (9). The rest of the proof formalizes this process. As x is fixed, we work on the centered polytope at x to simplify the statements, i.e. let M̃ := M− x. We have the following worst case lower bound for (12):\n〈r,dPFW〉 〈r, ê〉\n≥ (\nmax s∈A,v∈S\n〈r, s− v〉 )(\nmax e∈M̃ 〈r, e ‖e‖ 〉 )−1 . (15)\nThe first term on the RHS of (15) just comes from the definition of dPFW (with equality), whereas the second term is considering the worst case possibility for x∗ to lower bound the LHS. Note also that the second term has to be strictly greater to zero since x is not optimal.\nWithout loss of generality, we can assume that r ∈ span(M̃) (otherwise, just project it), as any orthogonal component would not change the inner products appearing in (15). If (this projected) r is feasible from x, then maxe∈M̃ 〈r, e ‖e‖ 〉 = ‖r‖, and we again have the lower bound (14) arising in the definition of the pyramidal width.\nWe thus now suppose that r is not feasible. By the Lemma 5, we have the existence of a facet K′ of M̃ that includes the origin x such that:\nmax e∈M̃\n〈 r, e\n‖e‖\n〉 = max\ne∈K′\n〈 r, e\n‖e‖\n〉 = max\ne∈K′\n〈 r′, e\n‖e‖\n〉 , (16)\nwhere r′ is the result of the orthogonal projection of r on span(K′). We now look at how the numerator of (15) transforms when considering r′ and K′:\nmax s∈A,v∈S 〈r, s− v〉 = max s∈M 〈r, s− x〉+ max v∈S 〈−r,v − x〉\n≥ max s∈(K′+x) 〈r, s− x〉+ max v∈S∩(K′+x) 〈−r,v − x〉\n= max s∈(K′+x) 〈r′, s− x〉+ max v∈S 〈−r′,v − x〉\n= max s∈A∩(K′+x),v∈S\n〈r′, s− v〉 . (17)\nTo go from the first to the second line, we use the fact that the first term yields an inequality as (K′ + x) ⊆ (M̃ + x) = M. Also, since x is in the relative interior of conv(S) (as x is a proper convex combination of elements of S by definition), we have that (S−x) ⊆ K for any faceK of M̃\ncontaining the origin x. Thus S = S ∩ (K′+x), and the second term on the first line actually yields an equality for the second line. The third line uses the fact that r − r′ is orthogonal to members of K′, as r′ is obtained by orthogonal projection. Plugging (16) and (17) into the inequality (15), we get:\n〈r,dPFW〉 〈r, ê〉\n≥ (\nmax s∈A∩(K′+x),\nv∈S\n〈r′, s− v〉 )(\nmax e∈K′ 〈r′, e ‖e‖ 〉 )−1 . (18)\nWe are back to a similar situation to (15), with the lower dimensional K′ playing the role of the polytope M̃, and r′ ∈ span(K′) playing the role of r. If r′ is feasible from x in K′, then re-using the previous argument, we get PdirW (A ∩ (K′ + x), r′,x) as the lower bound, which is part of the definition of the pyramidal width ofA (note that we have (K′+x) as K′ is a face of the centered polytope M̃). Otherwise (if r 6∈ cone(K′)), then we use Lemma 5 again to get a facet K′′ of K′ as well as a new direction r′′ which is the orthogonal projection of r′ on span(K′′) such that we can re-do the manipulations for (16) and (18), yielding PdirW (A ∩ (K′′ + x), r′′,x) as a lower bound if r′′ is feasible from x in K′′. As long as we do not obtain a feasible direction, we keep re-using Lemma 5 to project the direction on a lower dimensional face of M̃ that contains x. This process must stop at some point; ultimately, we will reach the lowest dimensional face Kx that contains x. As x lies in the relative interior of Kx, then all directions in span(Kx) are feasible, and so the projected r will have to be feasible. Moreover, by stringing together the equalities of the type (16) for all the projected directions, we know that maxe∈Kx〈rfinal, e‖e‖ 〉 > 0 (as we originally had 〈r, ê〉 > 0), and thus Kx is at least one-dimensional and we also have rfinal 6= 0 (this last condition is crucial to avoid having a lower bound of zero!). This concludes the proof, and also explains why in the definition of the pyramidal width (9), we consider the pyramidal directional width for all the faces of conv(A) and respective non-zero feasible direction r."
    }, {
      "heading" : "C Affine Invariant Formulation",
      "text" : "Here we provide linear convergence proofs in terms of affine invariant quantities, since all the FrankWolfe algorithm variants presented in this paper are affine invariant. The statements presented in the main paper above are special cases of the following more general theorems, by using the bounds (20) for the curvature constant Cf , and Theorem 6 for the affine invariant strong convexity µAf .\nAn optimization method is called affine invariant if it is invariant under affine transformations of the input problem: If one chooses any re-parameterization of the domainM by a surjective linear or affine map A : M̂ → M, then the “old” and “new” optimization problems minx∈M f(x) and minx̂∈M̂ f̂(x̂) for f̂(x̂) := f(Ax̂) look completely the same to the algorithm.\nMore precisely, every “new” iterate must remain exactly the transform of the corresponding old iterate; an affine invariant analysis should thus yield the convergence rate and constants unchanged by the transformation. It is well known that Newton’s method is affine invariant under invertible A, and the Frank-Wolfe algorithm and all the variants presented here are affine invariant in the even stronger sense under arbitrary surjective A [15]. (This is directly implied if the algorithm and all constants appearing in the analysis only depend on inner products with the gradient, which are preserved since∇f̂ = AT∇f .) Note however that the property of being an extremum point (vertex) of M is not affine invariant (see [4, Section 3.1] for an example). This explains why we presented all algorithms here as working with atoms A rather than vertices of the domain, thus maintaining the affine invariance of the algorithms as well as their convergence analysis.\nAffine Invariant Measures of Smoothness. The affine invariant convergence analysis of the standard Frank-Wolfe algorithm by [15] crucially relies on the following measure of non-linearity of the objective function f over the domainM. The (upper) curvature constant Cf of a convex and differentiable function f : Rd → R, with respect to a compact domainM is defined as\nCf := sup x,s∈M, γ∈[0,1], y=x+γ(s−x)\n2 γ2\n( f(y)− f(x)− 〈∇f(x),y − x〉 ) . (19)\nThe definition ofCf closely mimics the fundamental descent lemma (2). The assumption of bounded curvature Cf closely corresponds to a Lipschitz assumption on the gradient of f . More precisely, if ∇f is L-Lipschitz continuous on M with respect to some arbitrary chosen norm ‖.‖ in dual pairing, i.e. ‖∇f(x)−∇f(y)‖∗ ≤ L ‖x− y‖, then\nCf ≤ Ldiam‖.‖(M)2 , (20)\nwhere diam‖.‖(.) denotes the ‖.‖-diameter, see [15, Lemma 7]. While the early papers [9, 8] on the Frank-Wolfe algorithm relied on such Lipschitz constants with respect to a norm, the curvature constant Cf here is affine invariant, does not depend on any norm, and gives tighter convergence rates. The quantity Cf combines the complexity of the domainM and the curvature of the objective function f into a single quantity. The advantage of this combination is well illustrated in [21, Lemma A.1], where Frank-Wolfe was used to optimize a quadratic function over product of probability simplices with an exponential number of dimensions. In this case, the Lipschitz constant could be exponentially worse than the curvature constant which does take the simplex geometry ofM into account.\nAn Affine Invariant Notion of Strong Convexity which Depends on the Geometry ofM. We now present the affine invariant analog of the strong convexity bound (4), which could be interpreted as the lower curvature µAf analog of Cf . The role of γ in the definition (19) of Cf was to define an affine invariant scale by only looking at proportions over lines (as line segments between x and s in this case). The trick here is to use anchor points inA in order to define standard lengths (by looking at proportions on lines). These anchor points (sf (x) and vf (x) defined below) are motivated directly from the FW atom and the away atom appearing in the away-steps FW algorithm. Specifically, let x∗ be a potential optimal point and x a non-optimal point; thus we have 〈−∇f(x),x∗ − x〉 > 0 (i.e. x∗−x is a strict descent direction from x for f ). We then define the positive step-size quantity:\nγA(x,x∗) := 〈−∇f(x),x∗ − x〉\n〈−∇f(x), sf (x)− vf (x)〉 . (21)\nThis quantity is motivated from both (6) and the linear rate inequality (5), and enables to transfer lengths from the error et = x∗ − xt to the pairwise FW direction dPFWt = sf (xt) − vf (xt). More precisely, sf (x) := arg minv∈A 〈∇f(x),v〉 is the standard FW atom. To define the awayatom, we consider all possible expansions of x as a convex combination of atoms.10 We recall that set of possible active sets is Sx := {S | S ⊆ A such that x is a proper convex combination of all the elements in S}. For a given set S, we write vS(x) := arg maxv∈S 〈∇f(x),v〉 for the away atom in the algorithm supposing that the current set of active atoms is S. Finally, we define vf (x) := arg min\n{v=vS(x) | S∈Sx} 〈∇f(x),v〉 to be the worst-case away atom (that is, the atom which would\nyield the smallest away descent).\nWe then define the geometric strong convexity constant µAf which depends both on the function f and the domainM = conv(A):\nµAf := inf x∈M\ninf x∗∈M\ns.t. 〈∇f(x),x∗−x〉<0\n2 γA(x,x∗)2 ( f(x∗)− f(x)− 〈∇f(x),x∗ − x〉 ) . (22)"
    }, {
      "heading" : "C.1 Lower Bound for the Geometric Strong Convexity Constant µAf",
      "text" : "The geometric strong convexity constant µAf , as defined in (22), is affine invariant, since it only depends on the inner products of feasible points with the gradient. Also, it combines both the complexity of the function f and the geometry of the domain M. Theorem 6 allows us to lower bound the constant µAf in terms of the strong convexity of the objective function, combined with a purely geometric complexity measure of the domainM (its pyramidal width PWidth(A) (9)). In the following Section D below, we will show the linear convergence of the four variants of the FW algorithm presented in this paper under the assumption that µAf > 0.\n10As we are working with general polytopes, the expansion of a point as a convex combination of atoms is not necessarily unique.\nIn view of the following Theorem 6, we have that the condition µAf > 0 is slightly weaker than the strong convexity of the objective function11 over a polytope domain (it is implied by strong convexity). Theorem 6. Let f be a convex differentiable function and suppose that f is µ-strongly convex w.r.t. to the Euclidean norm ‖·‖ over the domainM = conv(A) with strong-convexity constant µ ≥ 0. Then\nµAf ≥ µ · (PWidth(A)) 2 . (23)\nProof. By definition of strong convexity with respect to a norm, we have that for any x,y ∈M,\nf(y)− f(x)− 〈∇f(x),y − x〉 ≥ µ2 ‖y − x‖ 2 . (24)\nUsing the strong convexity bound (24) with y := x∗ on the right hand side of equation (22) (and using the shorthand rx := −∇f(x) ), we thus get:\nµAf ≥ inf x,x∗∈M\ns.t. 〈rx,x∗−x〉>0\nµ ( 〈rx, sf (x)− vf (x)〉 〈rx,x∗ − x〉 ‖x∗ − x‖ )2\n= µ inf x 6=x∗∈M\ns.t. 〈rx,ê〉>0\n( 〈rx, sf (x)− vf (x)〉 〈rx, ê(x∗,x)〉 )2 , (25)\nwhere ê(x∗,x) := x ∗−x ‖x∗−x‖ is the unit length feasible direction from x to x ∗. We are thus taking an infimum over all possible feasible directions starting from x (i.e. which moves withinM) with the additional constraint that it makes a positive inner product with the negative gradient rx, i.e. it is a strict descent direction. This is only possible if x is not already optimal, i.e. x ∈ M \\ X ∗ where X ∗ := {x∗ ∈M : 〈rx∗ ,x− x∗〉 ≤ 0 ∀x ∈M} is the set of optimal points. We note that sf (x) − vf (x) is a valid pairwise FW direction for a specific active set S for x, and so we can re-use (12) from Theorem 3 for the right hand side of (25) to conclude the proof.\nWe now proceed to present the main linear convergence result in the next section, using only the mentioned affine invariant quantities."
    }, {
      "heading" : "D Linear Convergence Proofs",
      "text" : "Curvature Constants. Because of the additional possibility of the away step in Algorithm 1, we need to define the following slightly modified additional curvature constant, which will be needed for the linear convergence analysis of the algorithm:\nCAf := sup x,s,v∈M, γ∈[0,1],\ny=x+γ(s−v)\n2 γ2 ( f(y)− f(x)− γ〈∇f(x), s− v〉 ) . (26)\nBy comparing with Cf (19), we see that the modification is that y is defined with any direction s−v instead of a standard FW direction s− x. This allows to use the away direction or the pairwise FW direction even though these might yield some y’s which are outside of the domainM when using γ > γmax (in fact, y ∈ MA := M + (M−M) in the Minkowski sense). On the other hand, by re-using a similar argument as in [15, Lemma 7], we can obtain the same bound (20) for CAf , with the only difference that the Lipschitz constant L for the gradient function has to be valid on MA instead of justM. Remark 7. For all pairs of functions f and compact domains M, it holds that µAf ≤ Cf (and Cf ≤ CAf ).\n11As an example of function that is not strongly convex but can still have µAf > 0, consider f(x) := g(Ax) where g is µg-strongly convex, but the matrix A is rank deficient. Then by using the affine invariance of the definition of µAf and using Theorem (6) applied on the equivalent problem on g with domain conv(AA), we get µAf ≥ µg · (PWidth(AA))2 > 0.\nProof. Let x be a vertex of M, so that S = {x}. Then x = vf (x). Pick x∗ := sf (x) and substitute in the definition for µAf (22). Then γ\nA(x,x∗) = 1 and so we have y := x∗ = x + γ(x∗ − x) with γ = 1 which can also be used in the definition of Cf (19). Thus, we have µAf ≤ 2 (f(y)− f(x)− 〈∇f(x),y − x〉) ≤ Cf .\nWe now give the global linear convergence rates for the four variants of the FW algorithm: awaysteps FW (AFW Algorithm 1); pairwise FW (PFW Algorithm 2); fully-corrective FW (FCFW Algorithm 3 with approximate correction as per Algorithm 4); and Wolfe’s min-norm point algorithm (Algorithm 3 with MNP-correction given in Algorithm 5). For the AFW, MNP and PFW algorithms, we call a drop step when the active set shrinks, i.e. |S(t+1)| < |S(t)|. For the PFW algorithm, we also have the possibility of a swap step, where γt = γmax but the size of the active set stays constant |S(t+1)| = |S(t)| (i.e. the mass gets fully swapped from the away atom to the FW atom). We note that a nice property of the FCFW variant is that it does not have any drop steps (it executes both FW steps and away steps simultaneously while guaranteeing enough progress at every iteration).\nTheorem 8. Suppose that f has smoothness constant CAf (Cf for FCFW and MNP), as well as geometric strong convexity constant µAf as defined in (22). Then the suboptimality ht := f(x\n(t))− f(x∗) of the iterates of all the four variants of the FW algorithm decreases geometrically at each step that is not a drop step nor a swap step (i.e. when γt < γmax, called a ‘good step’12), that is\nht+1 ≤ (1− ρf )ht , where:\nρf := µAf\n4CAf for the AFW algorithm, ρf := min\n{ 1\n2 , µAf CAf\n} for the PFW algorithm,\nρf := µAf 4Cf for the FCFW algorithm, ρf := min\n{ 1\n2 , µAf Cf } for the MNP algorithm, or FCFW with exact correction.\nMoreover, the number of drop steps up to iteration t is bounded by t/2. This yields the global linear convergence rate of ht ≤ h0 exp(− 12ρf t) for the AFW and MNP variants. FCFW does not need the extra 1/2 factor as it does not have any bad step. Finally, the PFW algorithm has at most 3|A|! swap steps between any two ‘good steps’.\nIf µAf = 0 (i.e. the case of general convex objectives), then all the four variants have a O(1/k(t)) convergence rate where k(t) is the number of ‘good steps’ up to iteration t. More specifically, we can summarize the suboptimality bounds for the four variants as:\nht ≤ 4C\nk(t) + 4 for k(t) ≥ 1,\nwhere C = 2µAf + h0 for AFW; C = 2Cf + h0 for FCFW with approximate correction; C = Cf/2 for MNP; andC = CAf /2 for PFW. The number of good steps is k(t) = t for FCFW; it is k(t) ≥ t/2 for MNP and AFW; and k(t) ≥ t/(3|A|! + 1) for PFW.\nProof. Proof for AFW. The general idea of the proof is to use the definition of the geometric strong convexity constant to upper bound ht, while using the definition of the curvature constant CAf to lower bound the decrease in primal suboptimality ht − ht+1 for the ‘good steps’ of Algorithm 1. Then we upper bound the number of ‘bad steps’ (the drop steps).\nUpper bounding ht. In the whole proof, we assume that x(t) is not already optimal, i.e. that ht > 0. If ht = 0, then because line-search is used, we will have ht+1 ≤ ht = 0 and so the geometric rate of decrease is trivially true in this case. Let x∗ be an optimum point (which is not necessarily unique). As ht > 0, we have that 〈 −∇f(x(t)),x∗ − x(t) 〉 > 0. We can thus apply the geometric strong\n12Note that any step with γmax ≥ 1 can also be considered a ‘good step’, even if γt = γmax, as is apparent from the proof. The problematic steps arise only when γmax 1.\nconvexity bound (22) at the current iterate x := x(t) using x∗ as an optimum reference point to get (with γ := γA(x(t),x∗) as defined in (21)):\nγ2\n2 µAf ≤ f(x∗)− f(x(t)) +\n〈 −∇f(x(t)),x∗ − x(t) 〉 (27)\n= −ht + γ 〈 −∇f(x(t)), sf (x(t))− vf (x(t)) 〉 ≤ −ht + γ 〈 −∇f(x(t)), st − vt\n〉 = −ht + γgt ,\nwhere we define gt := 〈 −∇f(x(t)), st − vt 〉 (note that ht ≤ gt and so gt also gives a primal suboptimality certificate). For the third line, we have used the definition of vf (x) which implies〈 ∇f(x(t)),vf (x(t)) 〉 ≤ 〈 ∇f(x(t)),vt 〉 . Therefore ht ≤ −γ 2 2 µ A f + γgt, which is always upper bounded13 by ht ≤ gt 2\n2µAf . (28)\nLower bounding progress ht − ht+1. We here use the key aspect in the proof that we had described in the main text with (6). Because of the way the direction dt is chosen in the AFW Algorithm 1, we have 〈\n−∇f(x(t)),dt 〉 ≥ gt/2, (29)\nand thus gt characterizes the quality of the direction dt. To see this, note that 2 〈 ∇f(x(t)),dt 〉 ≤〈\n∇f(x(t)),dFWt 〉 + 〈 ∇f(x(t)),dAt 〉 = 〈 ∇f(x(t)),dFWt + dAt 〉 = −gt.\nWe first consider the case γmax ≥ 1. Let xγ := x(t)+γdt be the point obtained by moving with stepsize γ in direction dt, where dt is the one chosen by Algorithm 1. By using s := x(t)+dt (a feasible point as γmax ≥ 1), x := x(t) and y := xγ in the definition of the curvature constant Cf (19), and solving for f(xγ), we get the affine invariant version of the descent lemma (2):\nf(xγ) ≤ f(x(t)) + γ 〈 ∇f(x(t)),dt 〉 + γ2\n2 Cf , valid ∀γ ∈ [0, 1]. (30)\nAs γt is obtained by line-search and that [0, 1] ⊆ [0, γmax], we also have that f(x(t+1)) = f(xγt) ≤ f(xγ) ∀γ ∈ [0, 1]. Combining these two inequalities, subtracting f(x∗) on both sides, and using Cf ≤ CAf to simplify the possibilities yields ht+1 ≤ ht + γ 〈 ∇f(x(t)),dt 〉 + γ 2 2 C A f .\nUsing the crucial gap inequality (29), we get ht+1 ≤ ht − γ gt2 + γ2 2 C A f , and so:\nht − ht+1 ≥ γ gt 2 − γ\n2\n2 CAf ∀γ ∈ [0, 1]. (31)\nWe can minimize the bound (31) on the right hand side by letting γ = γBt := gt 2CAf . Supposing that γBt ≤ 1, we then get ht − ht+1 ≥ g2t\n8CAf (we cover the case γBt > 1 later). By combining this\ninequality with the one from geometric strong convexity (28), we get\nht − ht+1 ≥ µAf\n4CAf ht (32)\nimplying that we have a geometric rate of decrease ht+1 ≤ ( 1− µ A f\n4CAf\n) ht (this is a ‘good step’).\nBoundary cases. We now consider the case γBt > 1 (with γmax ≥ 1 still). The condition γBt > 1 then translates to gt ≥ 2CAf , which we can use in (31) with γ = 1 to get ht−ht+1 ≥ gt 2 − gt 4 = gt 4 .\n13Here we have used the trivial inequality 0 ≤ a2−2ab+b2 for the choice of numbers a := gt µA f and b := γ. An alternative way to obtain the bound is to look at the unconstrained maximum of the RHS which is a concave function of γ by letting γ = gt/µAf , as we did in the main paper to obtain the upper bound on ht in (5).\nCombining this inequality with ht ≤ gt gives the geometric decrease ht+1 ≤ ( 1− 14 ) ht (also a ‘good step’). ρAf is obtained by considering the worst-case of the constants obtained from γ B t > 1 and γBt ≤ 1. (Note that µAf ≤ CAf by Remark 7, and thus 14 ≥ µAf\n4CAf ).\nFinally, we are left with the case that γmax < 1. This is thus an away step and so dt = dAt = x (t)−vt. Here, we use the away version CAf : by letting s := x (t), v = vt and y := xγ in (26), we also get\nthe bound f(xγ) ≤ f(x(t)) + γ 〈 ∇f(x(t)),dt 〉 + γ 2 2 C A f , valid ∀γ ∈ [0, 1] (but note here that the points xγ are not feasible for γ > γmax – the bound considers some points outside of M). We now have two options: either γt = γmax (a drop step) or γt < γmax. In the case γt < γmax (the line-search yields a solution in the interior of [0, γmax]), then because f(xγ) is convex in γ, we know that minγ∈[0,γmax] f(xγ) = minγ≥0 f(xγ) and thus minγ∈[0,γmax] f(xγ) = f(x\n(t+1)) ≤ f(xγ) ∀γ ∈ [0, 1]. We can then re-use the same argument above equation (31) to get the inequality (31), and again considering both the case γBt ≤ 1 (which yields inequality (32)) and the case γBt > 1 (which yields (1 − 14 ) as the geometric rate constant), we get a ‘good step’ with 1 − ρf as the worst-case geometric rate constant.\nFinally, we can easily bound the number of drop steps possible up to iteration t with the following argument (the drop steps are the ‘bad steps’ for which we cannot show good progress). Let At be the number of steps that added a vertex in the expansion (only standard FW steps can do this) and let Dt be the number of drop steps. We have that |S(t)| = |S(0)|+At−Dt. Moreover, we have that At+Dt ≤ t. We thus have 1 ≤ |S(t)| ≤ |S(0)|+t−2Dt, implying thatDt ≤ 12 (|S\n(0)|−1+t) = t2 , as stated in the theorem.\nProof for FCFW. In the case of FCFW, we do not need to consider away steps: by the quality of the approximate correction in Algorithm 4 (as specified in Line 4), we know that at the beginning of a new iteration, the away gap gAt ≤ . Supposing that the algorithm does not exit at line 6 of Algorithm 3, then gFWt > and thus we have that 2〈rt,dFWt 〉 ≥ 〈rt,dPFWt 〉 using a similar argument as in (6) (i.e. if one would be to run the AFW algorithm at this point, it would take a FW step). Finally, by property of the line 3 of the approximate correction Algorithm 4, the correction is guaranteed to make at least as much progress as a line-search in direction dFWt , and so the lower bound (31) can be used for FCFW as well (but using Cf as the constant instead of CAf given that it was a FW step).\nProof for MNP. After a correction step in the MNP algorithm, we have that the current iterate is the minimizer over the active set, and thus gAt = 0. We thus have 〈rt,dFWt 〉 = 〈rt,dPFWt 〉 = gt, which means that a standard FW step would yield a geometric decrease of error.14 It thus remains to show that the MNP-correction is making as much progress as a FW line-search. Consider y1 as defined in Algorithm 5. If it belongs to conv(V(0)), then it has made more progress than a FW line-search as st and x(t) belongs to conv(V(0)). The next possibility is the crucial step in the proof: suppose that exactly one atom was removed from the correction polytope and that y1 does not belong to conv(V(0)) (as this was covered in the above case). This means that y2 belongs to the relative interior of conv(V(1)). Because y2 is by definition the affine minimizer of f on conv(V(1)), the negative gradient−∇f(y2) is pointing away to the polytope conv(V(1)) (by the optimality condition). But conv(V(1)) is a facet of conv(V(0)), this means that −∇f(y2) determines a facet of conv(V(0)) (i.e. 〈−∇f(y2),y − y2〉 ≤ 0 for all y ∈ conv(V(0))). This means that y2 is also the minimizer of f on conv(V(0)) and thus has made more progress than a FW line-search.\nIn the case that two atoms are removed from conv(V(0)), we cannot make this argument anymore (it is possible that y3 makes less progress than a FW line-search); but in this case, the size of the active set is reduced by one (we have a drop step), and thus we can use the same argument as in the AFW algorithm to bound the number of such steps.\n14Moreover, as we do not have the factor of 2 relating 〈rt,dFWt 〉 and gt unlike in the AFW and approximate FCFW case, we can remove the factor of 1\n2 in front of gt in (31), removing the factor of 14 appearing in (32),\nand also giving a geometric decrease with factor (1− 1 2 ) when γBt > 1.\nProof for PFW. In this case, 〈rt,dt〉 = 〈rt,dPFWt 〉, so we do not even need a factor of 2 to relate the gaps (with the same consequence as in MNP in getting slightly bigger constants). We can re-use the same argument as in the AFW algorithm to get a geometric progress when γt < γmax. When γt = γmax we can either have a drop step if st was already in S(t), or a swap step if st was also added to S(t) and so |S(t+1)| = |S(t)|. The number of drop steps can be bounded similarly as in the AFW algorithm. On the other hand, in the worst case, there could be a very large number of swap steps. We provide here a very loose bound, though it would be interesting to use other properties of the objective to prove that this worst case scenario cannot happen.\nWe thus bound the maximum number of swap steps between two ‘good steps’ (very loosely). Let m = |A| be the number of possible atoms, and let r be the size of the current active set |S(t)| = r ≤ m. When doing a drop step γt = αvt , there are two possibilities: either we move all the mass from vt to a new atom st /∈ S(t) i.e. α(t+1)vt = 0 and α (t+1) st = α (t) vt (a swap step); or we move all the mass from vt to an old atom st ∈ S(t) i.e. α(t+1)st = α (t) st + α (t) vt (a ‘full drop step’). When doing a swap step, the set of possible values for the coordinates αv do not change, they are only ‘swapped around’ amongst the m possible slots. The maximum number of possible consecutive swap steps without revisiting an iterate already seen is thus bounded by the number of ways we can assign r numbers in m slots (supposing the r coordinates were all distinct in the worst case), which is m!/(m − r)!. Note that because the algorithm does a line-search in a strict descent direction at each iteration, we always have f(x(t+1)) < f(x(t)) unless x(t) is already optimal. This means that the algorithm cannot revisit the same point unless it has converged. When doing a ‘full drop step’, the set of coordinates changes, but the size of the active set is reduced by one (thus r reduced by one). In the worst case, we will do a maximum number of swap steps, followed by a full drop step, repeated so on all the way until we reach an active set of only one element (in which case there is a maximum number of m swap steps). Starting with an active set of r coordinates, the maximum number of swap steps B without doing any ‘good step’ (which would also change the set of coordinates), is thus upper bounded by:\nB ≤ r∑ l=1 m! (m− l)! ≤ m! ∞∑ l=0 1 l! = m! e ≤ 3m! ,\nas claimed.\nProof of Sublinear Convergence for General Convex Objectives (i.e. when µAf = 0). For the good steps of the MNP algorithm and the pairwise FW algorithm, we have the reduction of suboptimality given by (31) without the factor of 12 in front of gt ≥ ht. This is the standard recurrence that appears in the convergence proof of Frank-Wolfe (see for example Equation (4) in [15, proof of Theorem 1]), yielding the usual convergence:\nht ≤ 2C\nk(t) + 2 for k(t) ≥ 1, (33)\nwhere k(t) is the number of good steps up to iteration t, and C = Cf for MNP and C = CAf for PFW. The number of good steps for MNP is k(t) ≥ t/2, while for PFW, we have the (useless) lower bound k(t) ≥ t/(3|A|! + 1). For FCFW with exact correction, the rate (33) was already proven in [15] with k(t) = t. On the other hand, for FCFW with approximate correction, and for AFW, the factor of 12 in front of the gap gt in the suboptimality bound (31) somewhat complicates the convergence proof. The recurrence we get for the suboptimality is the same as in Equation (20) of [21, proof of Theorem C.1], with ν = 12 and n = 1, giving the following suboptimality bound:\nht ≤ 4C\nk(t) + 4 for k(t) ≥ 0, (34)\nwhere C = 2CAf + h0 for AFW and C = 2Cf + h0 for FCFW with approximate correction. Moreover, the number of good steps is k(t) ≥ t/2 for AFW, and k(t) = t for FCFW. A weaker (logarithmic) dependence on the initial error h0 can also be obtained by following a tighter analysis (see [21, Theorem C.4] or [18, Lemma D.5 and Theorem D.6]), though we only state the simpler result here."
    }, {
      "heading" : "E Empirical Tightness of Linear Rate Constant",
      "text" : "We describe here a simple experiment to test how tight the constant in the linear convergence rate of Theorem 8 is. We test both AFW and PFW on the triangle domain with corners at the locations (−1, 0), (0, 0) and (cos(θ), sin(θ)), for increasingly small θ (see Figure 4).\nThe pyramidal width δ = sin( θ2 ) becomes vanishingly small as θ → 0; the diameter is M = 2 cos( θ2 ). We consider the optimization of the function f(x) := 1 2‖x − x\n∗‖2 with x∗ = (−0.5, 1) on one edge of the domain. Note that the condition number of f is Lµ = 1. The bound on the linear convergence rate ρ according to Theorem 8 (using CAf ≤ LM2 (20) and µAf ≥ µ δ2 (23)) is ρPFW = µAf CAf ≥ µL ( δ M )2 for PFW and ρA = 14ρ PFW for AFW. The theoretical constant here is thus ρPFW = 14 tan 2( θ2 ). We consider θ varying from π/4 to 1e−3, and thus theoretical rates varying on a wide range from 0.04 to 1e−7. We compare the theoretical rate ρ with the empirically observed one by estimating ρ̂ in the relationship ht ≈ h0 exp(−ρt) (using linear regression on the semilogarithmic scale). For each θ, we run both AFW and PFW for 2000 iterations starting from 20 different random starting points15 in the interior of the triangle domain. We disregard the starting points that yield a drop step (as then the algorithm converges in one iteration; these happen for about 10% of the starting points). Note that as there is no drop step in our setup, we do not need to divide by two the effective rate as is done in Theorem 8 (the number of ‘good steps’ is k(t) = t).\n15x0 is obtained by taking a random convex combination of the corners of the domain.\nFigure 5 presents the results. In Figure 5(a), we plot the ratio of the estimated rate over the theoretical rate ρ̂ρ for both PFW and AFW as θ varies. Note that the ratio is very stable for PFW (around 10), despite the rate changing through six orders of magnitude, demonstrating the empirical tightness of the constant for this domain. The ratio for AFW has more fluctuations, but also stays within a stable range. We can also do a finer analysis than the pyramidal width and consider the finite number possibilities for the worst case angles for (〈r̂,dPFW(r)〉)2. This gives the tighter constant ρPFW = sin2( θ2 ) for our triangle domain, gaining a factor of about 4, but still not matching yet the empirical observation for PFW.\nIn Figure 5(b), we compare the empirical rate for PFW vs. the one for AFW. For bigger theoretical rates, PFW appears to converge faster. However, AFW gets a slightly better empirical rate for very small rates (small angles)."
    }, {
      "heading" : "F Non-Strongly Convex Generalization",
      "text" : "Here we will study the generalized setting with objective f(x) := g(Ax) + 〈b,x〉 where g is µg-strongly convex w.r.t. the Euclidean norm over the domain AM with strong convexity constant µg > 0.\nWe first define a few constants: let G := maxx∈M ‖∇g(Ax)‖ be the maximal norm of the gradient of g over AM; M be the diameter ofM and MA be the diameter of AM.\nLet θ be the Hoffman constant (see [4, Lemma 2.2]) associated with the matrix [A; b>;B] = ( A b>\nB\n) ,\nwhere the rows of B are the linear inequality constraints defining the setM. We present here a generalization of Lemma 2.5 from [4]:\nLemma 9. For any x ∈M and x∗ in the solution set X ∗:\nf(x∗)− f(x)− 2〈∇f(x),x∗ − x〉 ≥ 2µ̃ d(x,X ∗)2, (35)\nwhere µ̃ := 1/ ( 2θ2 ( ‖b‖M + 3GMA + 2µg (G 2 + 1) ))\nis the generalized strong convexity constant for f .\nProof. Let x∗ be any element of the solution set X ∗. By the strong convexity of g, we have\nf(x∗)− f(x)− 〈∇f(x),x∗ − x〉 ≥ µg2 ‖Ax ∗ −Ax‖2 . (36)\nMoreover, by the convexity of f , we have:\n− 〈∇f(x),x∗ − x〉 ≥ f(x)− f(x∗). (37)\nWe now use inequality (2.10) in [4] to get the bound:\nf(x)− f(x∗) ≥ 1 B1 (〈b,x〉 − 〈b,x∗〉)2, (38)\nwhere B1 := (‖b‖M + 3GMA + 2µgG 2).\nPlugging (38) into (37) and adding to (36), we get:\nf(x∗)− f(x)− 2〈∇f(x),x∗ − x〉 ≥ 1 B2\n( ‖Ax∗ −Ax‖2 + (〈b,x〉 − 〈b,x∗〉)2 ) ≥ 1 B2θ2 d(x,X ∗)2,\nwhere B2 := (‖b‖M + 3GMA + 2µg (G 2 + 1)). For the last inequality, we used inequality (2.1) in [4] that made use of the Hoffman’s Lemma (see [4, Lemma 2.2]), where θ is the Hoffman constant associated with the matrix [A; b>;B]. In this case, B is the matrix with rows containing the linear inequality constraints definingM.\nWe now define the following generalization of the geometric strong convexity constant (22), that we now call µ̃f :\nµ̃f := inf x∈M\nsup x∗∈X∗\ns.t. 〈∇f(x),x∗−x〉<0\n1 2γA(x,x∗)2 ( f(x∗)− f(x)− 2 〈∇f(x),x∗ − x〉 ) . (39)\nNotice the new inner supremum over the solution setX ∗ compared to the original definition (22), the factor of 2 in front of the gradient, and the different overall scaling to have a similar form as in the previous linear convergence theorem. This new quantity µ̃f is still affine invariant, but unfortunately now depends on the location of the solution setX ∗. We now present the generalization of Theorem 6. Theorem 10. Let f(x) := g(Ax) + 〈b,x〉 where g is µg-strongly convex w.r.t. the Euclidean norm over the domain AM with strong convexity constant µg > 0. Let µ̃ be the corresponding generalized strong convexity constant coming from Lemma 9. Then\nµ̃f ≥ µ̃ · (PWidth(M))2 .\nProof. Let x be fixed and not optimal; let x∗ be its closest point in X ∗ i.e. ‖x− x∗‖ = d(x,X ∗). We have that 〈∇f(x),x∗ − x〉 < 0 as x is not optimal. We use the generalized strong convexity notion µ̃ from Lemma 9 for the particular reference point x∗ in the third line below to get:\nsup x′∈X∗\ns.t. 〈∇f(x),x′−x〉<0\n1 2γA(x,x′)2 ( f(x′)− f(x)− 2 〈∇f(x),x′ − x〉 )\n≥ 1 2γA(x,x∗)2\n( f(x∗)− f(x)− 2 〈∇f(x),x∗ − x〉 ) ≥ 1\n2γA(x,x∗)2 2µ̃ d(x,X ∗)2 = 1 γA(x,x∗)2 µ̃‖x− x∗‖2.\nWe can do this for each non-optimal x. We thus obtain:\nµ̃f ≥ inf x,x∗∈M\ns.t. 〈rx,x∗−x〉>0\nµ̃ ( 〈rx, sf (x)− vf (x)〉 〈rx,x∗ − x〉 ‖x∗ − x‖ )2 . (40)\nAnd we are back to the same situation as in the proof of our earlier Theorem 6, the only change being that we now have equation (25) holding for the general strong convexity constant µ̃ instead of its classical analogue µ.\nHaving this tool at hand, the linear convergence of all Frank-Wolfe algorithm variants now holds with the earlier µAf complexity constant replaced with µ̃f . The factor of 2 in the denominator of (39) is to ensure the same scaling.\nAgain, as we have shown in Theorem 10, we have that our condition µ̃f > 0 leading to linear convergence is slightly weaker than generalized strong convexity in the Hoffman sense (it is implied by it). Theorem 11. Suppose that f has smoothness constant CAf (Cf for FCFW and MNP), as well as generalized geometric strong convexity constant µ̃f as defined in (39).\nThen the suboptimality error ht of the iterates of all the four variants of the FW algorithm (AFW, FCFW, MNP and PFW) decreases geometrically at each step that is not a drop step nor a swap step (i.e. when γt < γmax), with the same constants as in Theorem 8, except that µAf is replaced by µ̃f .\nProof. The proof closely follows the proof of Theorem 8.\nWe start from the above generalization (39) of the original geometric strong convexity constant (22), and first replace the inf over x by considering only the choice x := x(t), giving\nµ̃f ≤ sup x∗∈X∗\ns.t. 〈∇f(x(t)),x∗−x(t)〉<0\n1\n2γA(x(t),x∗) 2\n( f(x∗)−f(x(t))−2 〈 ∇f(x(t)),x∗ − x(t) 〉 ) . (41)\nFrom here, we will now mirror our earlier derivation for an upper bound on the suboptimality as a function of the gap gt, as given in (27). As an optimal reference point x∗ in (27), we will choose a x̃∗ attaining the supremum in (41), given x(t).\nWe again employ the ‘step-size quantity’ γ := γA(x(t), x̃∗) as defined in (21). Using (41), we have 2γ2 µ̃f ≤ f(x∗)− f(x(t)) + 2 〈 −∇f(x(t)), x̃∗ − x(t) 〉 (42)\n= −ht + 2γ 〈 −∇f(x(t)), sf (x(t))− vf (x(t)) 〉 ≤ −ht + 2γ 〈 −∇f(x(t)), st − vt\n〉 = −ht + 2γgt ,\nTherefore ht ≤ − γ̂ 2 2 µ̃f + γ̂gt when writing γ̂ := 2γ, which is always upper bounded 16 by\nht ≤ gt\n2\n2µ̃f . (43)\nwhich is exactly the bound (28) as in the classical case, with the denominator being 2µ̃f instead of 2µAf .\nFrom here, the proof of the main convergence Theorem 8 continues without modification, using µ̃f instead of µAf ."
    }, {
      "heading" : "Supplementary References",
      "text" : "[37] H. Allende, E. Frandi, R. Nanculef, and C. Sartori. A novel Frank-Wolfe algorithm. Analysis and applications to large-scale SVM training. arXiv:1304.1014v2, 2013. [38] D. P. Bertsekas. Nonlinear programming. Athena Scientific, second edition, 1999. [39] D. Chakrabarty, P. Jain, and P. Kothari. Provable submodular minimization using Wolfe’s algorithm. In NIPS. 2014. [40] S. Iwata. A faster scaling algorithm for minimizing submodular functions. In Integer Program-\nming and Combinatorial Optimization, volume 2337 of Lecture Notes in Computer Science, pages 1–8. 2002.\n[41] G. M. Ziegler. Lectures on Polytopes, volume 152 of Graduate Texts in Mathematics. Springer, 1995.\n16Here we have again used the trivial inequality 0 ≤ a2 − 2ab+ b2 for the choice of numbers a := gt µ̃f and b := γ̂."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : null,
    "creator" : "LaTeX with hyperref package"
  }
}