{
  "name" : "1410.7660.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Non-convex Robust PCA",
    "authors" : [ "Praneeth Netrapalli", "U N Niranjan", "Sujay Sanghavi", "Animashree Anandkumar", "Prateek Jain" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "( r2mn ) per iteration,\nand needs O (log(1/ )) iterations to reach an accuracy of . This is close to the running times of simple PCA via the power method, which requires O (rmn) per iteration, and O (log(1/ )) iterations. In contrast, the existing methods for robust PCA, which are based on convex optimization, have O ( m2n ) complexity per iteration, and take O (1/ ) iterations, i.e., exponentially more iterations for the same accuracy. Experiments on both synthetic and real data establishes the improved speed and accuracy of our method over existing convex implementations.\nKeywords: Robust PCA, matrix decomposition, non-convex methods, alternating projections."
    }, {
      "heading" : "1 Introduction",
      "text" : "Principal component analysis (PCA) is a common procedure for preprocessing and denoising, where a low rank approximation to the input matrix (such as the covariance matrix) is carried out. Although PCA is simple to implement via eigen-decomposition, it is sensitive to the presence of outliers, since it attempts to “force fit” the outliers to the low rank approximation. To overcome this, the notion of robust PCA is employed, where the goal is to remove sparse corruptions from an input matrix and obtain a low rank approximation. Robust PCA has been employed in a wide range of applications, including background modeling [LHGT04], 3d reconstruction [MZYM11], robust topic modeling [Shi13], and community detection [CSX12], and so on.\nConcretely, robust PCA refers to the following problem: given an input matrix M = L∗ + S∗, the goal is to decompose it into sparse S∗ and low rank L∗ matrices. The seminal works of [CSPW11, CLMW11] showed that this problem can be provably solved via convex relaxation methods, under some natural conditions on the low rank and sparse components. While the theory is elegant, in practice, convex techniques are expensive to run on a large scale and have poor convergence rates. Concretely, for decomposing an m× n matrix, say with m ≤ n, the best specialized implementations (typically first-order methods) have a per-iteration complexity of O ( m2n ) , and require O(1/ ) number of iterations to achieve an error of . In contrast, the usual PCA, which carries out a rank-r approximation of the input matrix, has O(rmn) complexity per iteration – drastically smaller when r is\n∗Microsoft Research, Cambridge MA. Email: praneeth@microsoft.com. Part of the work done while interning at Microsoft Research, India. †The University of California at Irvine, CA. Email: un.niranjan@uci.edu. Part of the work done while interning at Microsoft Research, India. ‡The University of Texas at Austin, TX. Email: sanghavi@mail.utexas.edu §The University of California at Irvine, CA. Email: a.anandkumar@uci.edu ¶Microsoft Research, Bangalore, India. Email: prajain@microsoft.com\nar X\niv :1\n41 0.\n76 60\nv1 [\ncs .I\nT ]\n2 8\nO ct\n2 01\n4\nmuch smaller than m,n. Moreover, PCA requires exponentially fewer iterations for convergence: an accuracy is achieved with only O (log(1/ )) iterations (assuming constant gap in singular values).\nIn this paper, we design a non-convex algorithm which is “best of both the worlds” and bridges the gap between (the usual) PCA and convex methods for robust PCA. Our method has low computational complexity similar to PCA (i.e. scaling costs and convergence rates), and at the same time, has provable global convergence guarantees, similar to the convex methods. Proving global convergence for non-convex methods is an exciting recent development in machine learning. Non-convex alternating minimization techniques have recently shown success in many settings such as matrix completion [Kes12, JNS13, Har13], phase retrieval [NJS13], dictionary learning [AAJ+13], tensor decompositions for unsupervised learning [AGH+12], and so on. Our current work on the analysis of non-convex methods for robust PCA is an important addition to this growing list."
    }, {
      "heading" : "1.1 Summary of Contributions",
      "text" : "We propose a simple intuitive algorithm for robust PCA with low per-iteration cost and a fast convergence rate. We prove tight guarantees for recovery of sparse and low rank components, which match those for the convex methods. In the process, we derive novel matrix perturbation bounds, when subject to sparse perturbations. Our experiments reveal significant gains in terms of speed-ups over the convex relaxation techniques, especially as we scale the size of the input matrices.\nOur method consists of simple alternating (non-convex) projections onto low-rank and sparse matrices. For an m × n matrix, our method has a running time of O(r2mn log(1/ )), where r is the rank of the low rank component. Thus, our method has a linear convergence rate, i.e. it requires O(log(1/ )) iterations to achieve an error of , where r is the rank of the low rank component L∗. When the rank r is small, this nearly matches the complexity of PCA, (which is O(rmn log(1/ ))).\nWe prove recovery of the sparse and low rank components under a set of requirements which are tight and match those for the convex techniques (up to constant factors). In particular, under the deterministic sparsity model, where each row and each column of the sparse matrix S∗ has at most α fraction of non-zeros, we require that α = O ( 1/(µ2r) ) , where µ is the incoherence factor (see Section 3).\nIn addition to strong theoretical guarantees, in practice, our method enjoys significant advantages over the state-of-art solver for (1), viz., the inexact augmented Lagrange multiplier (IALM) method [CLMW11]. Our method outperforms IALM in all instances, as we vary the sparsity levels, incoherence, and rank, in terms of running time to achieve a fixed level of accuracy. In addition, on a real dataset involving the standard task of foreground-background separation [CLMW11], our method is significantly faster and provides visually better separation.\nOverview of our techniques: Our proof technique involves establishing error contraction with each projection onto the sets of low rank and sparse matrices. We first describe the proof ideas when L∗ is rank one. The first projection step is a hard thresholding procedure on the input matrix M to remove large entries and then we perform rank-1 projection of the residual to obtain L(1). Standard matrix perturbation results (such as Davis-Kahan) provide `2 error bounds between the singular vectors of L\n(1) and L∗. However, these bounds do not suffice for establishing the correctness of our method. Since the next step in our method involves hard thresholding of the residual M −L(1), we require element-wise error bounds on our low rank estimate. Inspired by the approach of Erdős et al. [EKYY13], where they obtain similar element-wise bounds for the eigenvectors of sparse Erdős–Rényi graphs, we derive these bounds by exploiting the fixed point characterization of the eigenvectors1. A Taylor’s series expansion reveals that the perturbation between the estimated and the true eigenvectors consists of bounding the walks in a graph whose adjacency matrix corresponds to (a subgraph of) the sparse component S∗. We then show that if the graph is sparse enough, then this perturbation can be controlled, and thus, the next thresholding step results in further error contraction. We use an induction argument to show that the sparse estimate is always contained in the true support of S∗, and that there is an error contraction in each step. For the case, where L∗ has rank r > 1, our algorithm proceeds in several stages,\n1If the input matrix M is not symmetric, we embed it in a symmetric matrix and consider the eigenvectors of the corresponding matrix.\nwhere we progressively compute higher rank projections which alternate with the hard thresholding steps. In stage k = [1, 2, . . . , r], we compute rank-k projections, and show that after a sufficient number of alternating projections, we reduce the error to the level of (k + 1)th singular value of L∗, using similar arguments as in the rank-1 case. We then proceed to performing rank-(k + 1) projections which alternate with hard thresholding. This stage-wise procedure is needed for ill-conditioned matrices, since we cannot hope to recover lower eigenvectors in the beginning when there are large perturbations. Thus, we establish global convergence guarantees for our proposed non-convex robust PCA method."
    }, {
      "heading" : "1.2 Related Work",
      "text" : "Guaranteed methods for robust PCA have received a lot of attention in the past few years, starting from the seminal works of [CSPW11, CLMW11], where they showed recovery of an incoherent low rank matrix L∗ through the following convex relaxation method:\nConv-RPCA : min L,S ‖L‖∗ + λ‖S‖1, s.t., M = L+ S, (1)\nwhere ‖L‖∗ denotes the nuclear norm of L (nuclear norm is the sum of singular values). A typical solver for this convex program involves projection on to `1 and nuclear norm balls (which are convex sets). Note that the convex method can be viewed as “soft” thresholding in the standard and spectral domains, while our method involves hard thresholding in these domains.\n[CSPW11] and [CLMW11] consider two different models of sparsity for S∗. Chandrasekaran et al. [CSPW11] consider a deterministic sparsity model, where each row and column of the m × n matrix, S, has at most α fraction of non-zero entries. For guaranteed recovery, they require α = O ( 1/(µ2r √ n) ) , where µ is the incoherence level of L∗, and r is its rank. Hsu et al. [HKZ11] improve upon this result to obtain guarantees for an optimal sparsity level of α = O ( 1/(µ2r) ) . This matches the requirements of our non-convex method for exact recovery. Note that when the rank r = O(1), this allows for a constant fraction of corrupted entries. Candès et al. [CLMW11] consider a different model with random sparsity and additional incoherence constraints, viz., they require ‖UV >‖∞ < µ √ r/n. Note that our assumption of incoherence, viz., ‖U (i)‖ < µ √ r/n, only yields ‖UV >‖∞ < µ2r/n. The additional assumption enables [CLMW11] to prove exact recovery with a constant fraction of corrupted entries, even when L∗ is nearly full-rank. We note that removing the ‖UV >‖∞ condition for robust PCA would imply solving the planted clique problem when the clique size is less than √ n [Che13]. Thus, our recovery guarantees are tight upto constants without these additional assumptions.\nA number of works have considered modified models under the robust PCA framework, e.g. [ANW12, XCS12]. For instance, Agarwal et al. [ANW12] relax the incoherence assumption to a weaker “diffusivity” assumption, which bounds the magnitude of the entries in the low rank part, but incurs an additional approximation error. Xu et al.[XCS12] impose special sparsity structure where a column can either be non-zero or fully zero.\nIn terms of state-of-art specialized solvers, [CLMW11] implements the in-exact augmented Lagrangian multipliers (IALM) method and provides guidelines for parameter tuning. Other related methods such as multi-block alternating directions method of multipliers (ADMM) have also been considered for robust PCA, e.g. [WHML13]. Recently, a multi-step multi-block stochastic ADMM method was analyzed for this problem [SAJ14], and this requires 1/ iterations to achieve an error of . In addition, the convergence rate is tight in terms of scaling with respect to problem size (m,n) and sparsity and rank parameters, under random noise models.\nThere is only one other work which considers a non-convex method for robust PCA [KC12]. However, their result holds only for significantly more restrictive settings and does not cover the deterministic sparsity assumption that we study. Moreover, the projection step in their method can have an arbitrarily large rank, so the running time is still O(m2n), which is the same as the convex methods. In contrast, we have an improved running time of O(r2mn)."
    }, {
      "heading" : "2 Algorithm",
      "text" : "In this section, we present our algorithm for the robust PCA problem. The robust PCA problem can be formulated as the following optimization problem: find L, S s.t. ‖M − L− S‖F ≤ 2 and\n1. L lies in the set of low-rank matrices,\n2. S lies in the set of sparse matrices.\nA natural algorithm for the above problem is to iteratively project M − L onto the set of sparse matrices to update S, and then to project M −S onto the set of low-rank matrices to update L. Alternatively, one can view the problem as that of finding a matrix L in the intersection of the following two sets: a) L = { set of rank-r matrices}, b) SM = {M − S, where S is a sparse matrix}. Note that these projections can be done efficiently, even though the sets are non-convex. Hard thresholding (HT) is employed for projections on to sparse matrices, and singular value decomposition (SVD) is used for projections on to low rank matrices. Rank-1 case: We first describe our algorithm for the special case when L∗ is rank 1. Our algorithm performs an initial hard thresholding to remove very large entries from input M . Note that if we performed the projection on to rank-1 matrices without the initial hard thresholding, we would not make any progress since it is subject to large perturbations. We alternate between computing the rank-1 projection of M − S, and performing hard thresholding on M − L to remove entries exceeding a certain threshold. This threshold is gradually decreased as the iterations proceed, and the algorithm is run for a certain number of iterations (which depends on the desired reconstruction error). General rank case: When L∗ has rank r > 1, a naive extension of our algorithm consists of alternating projections on to rank-r matrices and sparse matrices. However, such a method has poor performance on illconditioned matrices. This is because after the initial thresholding of the input matrix M , the sparse corruptions in the residual are of the order of the top singular value (with the choice of threshold as specified in the algorithm). When the lower singular values are much smaller, the corresponding singular vectors are subject to relatively large perturbations and thus, we cannot make progress in improving the reconstruction error. To alleviate the dependence on the condition number, we propose an algorithm that proceeds in stages. In the kth stage, the algorithm alternates between rank-k projections and hard thresholding for a certain number of iterations. We run the algorithm for r stages, where r is the rank of L∗. Intuitively, through this procedure, we recover the lower singular values only after the input matrix is sufficiently denoised, i.e. sparse corruptions at the desired level have been removed. Figure 1 shows a pictorial representation of the alternating projections in different stages.\nParameters: As can be seen, the only real parameter to the algorithm is β, used in thresholding, which represents “spikiness” of L∗. That is if the user expects L∗ to be “spiky” and the sparse part to be heavily diffused, then higher value of β can be provided. In our implementation, we found that selecting β aggressively helped speed up recovery of our algorithm. In particular, we selected β = 1/ √ n.\n2 is the desired reconstruction error\nAlgorithm 1 (L̂, Ŝ) = AltProj(M, , r, β): Non-convex Alternating Projections based Robust PCA\n1: Input: Matrix M ∈ Rm×n, convergence criterion , target rank r, thresholding parameter β. 2: Pk(A) denotes the best rank-k approximation of matrix A. HTζ(A) denotes hard-thresholding, i.e.\n(HTζ(A))ij = Aij if |Aij | ≥ ζ and 0 otherwise. 3: Set initial threshold ζ0 ← βσ1(M). 4: L(0) = 0, S(0) = HTζ0(M − L(0)) 5: for Stage k = 1 to r do 6: for Iteration t = 0 to T = 10 log ( nβ ∥∥M − S(0)∥∥ 2 / ) do 7: Set threshold ζ as\nζ = β ( σk+1(M − S(t)) + ( 1\n2\n)t σk(M − S(t)) ) (2)\n8: L(t+1) = Pk(M − S(t)) 9: S(t+1) = HTζ(M − L(t+1))\n10: end for 11: if βσk+1(L (t+1)) < 2n then 12: Return: L(T ), S(T ) /* Return rank-k estimate if remaining part has small norm */ 13: else 14: S(0) = S(T ) /* Continue to the next stage */ 15: end if 16: end for 17: Return: L(T ), S(T )\nComplexity: The complexity of each iteration within a single stage is O(kmn), since it involves calculating the rank-k approximation3 of an m × n matrix (done e.g. via vanilla PCA). The number of iterations in each stage is O (log (1/ )) and there are at most r stages. Thus the overall complexity of the entire algorithm is then O(r2mn log(1/ )). This is drastically lower than the best known bound of O ( m2n/ ) on the number of iterations required by convex methods, and just a factor r away from the complexity of vanilla PCA."
    }, {
      "heading" : "3 Analysis",
      "text" : "In this section, we present our main result on the correctness of AltProj. We assume the following conditions:\n(L1) Rank of L∗ is at most r. (L2) L∗ is µ-incoherent, i.e., if L∗ = U∗Σ∗(V ∗)> is the SVD of L∗, then ‖(U∗)i‖2 ≤ µ √ r√ m , ∀1 ≤ i ≤ m and\n‖(V ∗)i‖2 ≤ µ √ r√ n , ∀1 ≤ i ≤ n, where (U∗)i and (V ∗)i denote the ith rows of U∗ and V ∗ respectively.\n(S1) Each row and column of S have at most α fraction of non-zero entries such that α ≤ 1512µ2r .\nNote that in general, it is not possible to have a unique recovery of low-rank and sparse components. For example, if the input matrix M is both sparse and low rank, then there is no unique decomposition (e.g. M = e1e > 1 ). The above conditions ensure uniqueness of the matrix decomposition problem.\nAdditionally, we set the parameter β in Algorithm 1 be set as β = 4µ 2r√ mn .\nWe now establish that our proposed algorithm recovers the low rank and sparse components under the above conditions.\n3Note that we only require a rank-k approximation of the matrix rather than the actual singular vectors. Thus, the computational complexity has no dependence on the gap between the singular values.\nTheorem 1 (Noiseless Recovery). Under conditions (L1), (L2) and S∗, and choice of β as above, the outputs"
    }, {
      "heading" : "L̂ and Ŝ of Algorithm 1 satisfy:∥∥∥L̂− L∗∥∥∥",
      "text" : "F ≤ , ∥∥∥Ŝ − S∗∥∥∥ ∞ ≤ √ mn , and Supp ( Ŝ ) ⊆ Supp (S∗) .\nRemark (tight recovery conditions): Our result is tight up to constants, in terms of allowable sparsity level under the deterministic sparsity model. In other words, if we exceed the sparsity limit imposed in S1, it is possible to construct instances where there is no unique decomposition4. Our conditions L1, L2 and S1 also match the conditions required by the convex method for recovery, as established in [HKZ11]. Remark (convergence rate): Our method has a linear rate of convergence, i.e. O(log(1/ )) to achieve an error of , and hence we provide a strongly polynomial method for robust PCA. In contrast, the best known bound for convex methods for robust PCA is O(1/ ) iterations to converge to an -approximate solution.\nTheorem 1 provides recovery guarantees assuming that L∗ is exactly rank-r. However, in several real-world scenarios, L∗ can be nearly rank-r. Our algorithm can handle such situations, where M = L∗ + N∗ + S∗, with N∗ being an additive noise. Theorem 1 is a special case of the following theorem which provides recovery guarantees when N∗ has small `∞ norm. Theorem 2 (Noisy Recovery). Under conditions (L1), (L2) and S∗, and choice of β as in Theorem 1, when the noise ‖N∗‖∞ ≤ σr(L\n∗) 100n ,the outputs L̂, Ŝ of Algorithm 1 satisfy:∥∥∥L̂− L∗∥∥∥ F ≤ + 2µ2r ( 7 ‖N∗‖2 + 8 √ mn√ r ‖N∗‖∞ ) ,∥∥∥Ŝ − S∗∥∥∥\n∞ ≤ √ mn + 2µ2r√ mn ( 7 ‖N∗‖2 + 8 √ mn√ r ‖N∗‖∞ ) , and Supp ( Ŝ ) ⊆ Supp (S∗) ."
    }, {
      "heading" : "3.1 Proof Sketch",
      "text" : "We now present the key steps in the proof of Theorem 1. A detailed proof is provided in the appendix.\nStep I: Reduce to the symmetric case, while maintaining incoherence of L∗ and sparsity of S∗. Using standard symmetrization arguments, we can reduce the problem to the symmetric case, where all the matrices involved are symmetric. See appendix for details on this step.\nStep II: Show decay in ‖L−L∗‖∞ after projection onto the set of rank-k matrices. The t-th iterate L(t+1) of the k-th stage is given by L(t+1) = Pk(L\n∗ + S∗ − S(t)). Hence, L(t+1) is obtained by using the top principal components of a perturbation of L∗ given by L∗+ (S∗−S(t)). The key step in our analysis is to show that when an incoherent and low-rank L∗ is perturbed by a sparse matrix S∗ − S(t), then ‖L(t+1) − L∗‖∞ is small and is much smaller than |S∗ − S(t)|∞. The following lemma formalizes the intuition; see the appendix for a detailed proof. Lemma 1. Let L∗, S∗ be symmetric and satisfy the assumptions of Theorem 1 and let S(t) and L(t) be the tth iterates of the kth stage of Algorithm 1. Let σ∗1 , . . . , σ ∗ n be the eigenvalues of L\n∗, s.t., |σ∗1 | ≥ · · · ≥ |σ∗r |. Then, the following holds:\n∥∥∥L(t+1) − L∗∥∥∥ ∞ ≤ 2µ 2r n (∣∣σ∗k+1∣∣+ (12 )t |σ∗k| ) , ∥∥∥S∗ − S(t+1)∥∥∥ ∞ ≤ 8µ 2r n (∣∣σ∗k+1∣∣+ (12 )t |σ∗k| ) , and Supp ( S(t+1) ) ⊆ Supp (S∗) .\n4For instance, consider the n×n matrix which has r copies of the all ones matrix, each of size n r\n, placed across the diagonal. We see that this matrix has rank r and is incoherent with parameter µ = 1. Note that a fraction of α = O (1/r) sparse perturbations suffice to erase one of these blocks making it impossible to recover the matrix.\nMoreover, the outputs L̂ and Ŝ of Algorithm 1 satisfy:∥∥∥L̂− L∗∥∥∥ F ≤ , ∥∥∥Ŝ − S∗∥∥∥ ∞ ≤ n , and Supp ( Ŝ ) ⊆ Supp (S∗) .\nStep III: Show decay in ‖S − S∗‖∞ after projection onto the set of sparse matrices. We next show that if ‖L(t+1)−L∗‖∞ is much smaller than ‖S(t)−S∗‖∞ then the iterate S(t+1) also has a much smaller error (w.r.t. S∗) than S(t). The above given lemma formally provides the error bound.\nStep IV: Recurse the argument. We have now reduced the `∞ norm of the sparse part by a factor of half, while maintaining its sparsity. We can now go back to steps II and III and repeat the arguments for subsequent iterations."
    }, {
      "heading" : "4 Experiments",
      "text" : "We now present an empirical study of our AltProj method. The goal of this study is two-fold: a) establish that our method indeed recovers the low-rank and sparse part exactly, without significant parameter tuning, b) demonstrate that AltProj is significantly faster than Conv-RPCA (see (1)); we solve Conv-RPCA using the IALM method [CLMW11], a state-of-the-art solver [LCM10]. We implemented our method in Matlab and used a Matlab implementation of the IALM method by [LCM10].\nWe consider both synthetic experiments and experiments on real data involving the problem of foregroundbackground separation in a video. Each of our results for synthetic datasets is averaged over 5 runs.\nParameter Setting: Our pseudo-code (Algorithm 1) prescribes the threshold ζ in Step 4, which depends on the knowledge of the singular values of the low rank component L∗. Instead, in the experiments, we set the threshold at the (t + 1)-th step of k-th stage as ζ = µσk+1(M−S (t))√\nn . For synthetic experiments, we employ the\nµ used for data generation, and for real-world datasets, we tune µ through cross-validation. We found that the above thresholding provides exact recovery while speeding up the computation significantly. We would also like to note that [CLMW11] sets the regularization parameter λ in Conv-RPCA (1) as 1/ √ n (assuming m ≤ n). However, we found that for problems with large incoherence such a parameter setting does not provide exact recovery. Instead, we set λ = µ/ √ n in our experiments.\nSynthetic datasets: Following the experimental setup of [CLMW11], the low-rank part L∗ = UV T is generated using normally distributed U ∈ Rm×r, V ∈ Rn×r. Similarly, supp(S∗) is generated by sampling a uniformly random subset of [m]× [n] with size ‖S∗‖0 and each non-zero S∗ij is drawn i.i.d. from the uniform distribution over [r/(2 √ mn), r/ √ mn]. For increasing incoherence of L∗, we randomly zero-out rows of U, V and then renormalize them.\nThere are three key problem parameters for RPCA with a fixed matrix size: a) sparsity of S∗, b) incoherence of L∗, c) rank of L∗. We investigate performance of both AltProj and IALM by varying each of the three parameters while fixing the others. In our plots (see Figure 2), we report computational time required by each of the two methods for decomposing M into L + S up to a relative error (‖M − L − S‖F /‖M‖F ) of 10−3. Figure 2 shows that AltProj scales significantly better than IALM for increasingly dense S∗. We attribute this observation to the fact that as ‖S∗‖0 increases, the problem is “harder” and the intermediate iterates of\nIALM have ranks significantly larger than r. Our intuition is confirmed by Figure 2 (b), which shows that when density (α) of S∗ is 0.4 then the intermediate iterates of IALM can be of rank over 500 while the rank of L∗ is only 5. We observe a similar trend for the other parameters, i.e., AltProj scales significantly better than IALM with increasing incoherence parameter µ (Figure 2 (c)) and increasing rank (Figure 2 (d)). See Appendix C for additional plots.\nReal-world datasets: Next, we apply our method to the problem of foreground-background (F-B) separation in a video [LHGT04]. The observed matrix M is formed by vectorizing each frame and stacking them columnwise. Intuitively, the background in a video is the static part and hence forms a low-rank component while the foreground is a dynamic but sparse perturbation.\nHere, we used two benchmark datasets named Escalator and Restaurant dataset. The Escalator dataset has 3417 frames at a resolution of 160 × 130. We first applied the standard PCA method for extracting low-rank part. Figure 3 (b) shows the extracted background from the video. There are several artifacts (shadows of people near the escalator) that are not desirable. In contrast, both IALM and AltProj obtain significantly better F-B separation (see Figure 3(c), (d)). Interestingly, AltProj removes the steps of the escalator which are moving and arguably are part of the dynamic foreground, while IALM keeps the steps in the background part. Also, our method is significantly faster, i.e., our method, which takes 63.2s is about 26 times faster than IALM, which takes 1688.9s.\nRestaurant dataset: Figure 4 shows the comparison of AltProj and IALM on a subset of the “Restaurant” dataset where we consider the last 2055 frames at a resolution of 120× 160. AltProj was around 19 times faster than IALM. Moreover, visually, the background extraction seems to be of better quality (for example, notice the blur near top corner counter in the IALM solution). Plot(b) shows the PCA solution and that also suffers from a similar blur at the top corner of the image, while the background frame extracted by AltProj does not have any noticeable artifacts."
    }, {
      "heading" : "5 Conclusion",
      "text" : "In this work, we proposed a non-convex method for robust PCA, which consists of alternating projections on to low rank and sparse matrices. We established global convergence of our method under conditions which match those for convex methods. At the same time, our method has much faster running times, and has superior experimental performance. This work opens up a number of interesting questions for future investigation. While we match the convex methods, under the deterministic sparsity model, studying the random sparsity model is of interest. Our noisy recovery results assume deterministic noise; improving the results under random noise needs to be investigated. There are many decomposition problems beyond the robust PCA setting, e.g. structured sparsity models, robust tensor PCA problem, and so on. It is interesting to see if we can establish global convergence for non-convex methods in these settings."
    }, {
      "heading" : "Acknowledgements",
      "text" : "AA and UN would like to acknowledge NSF grant CCF-1219234, ONR N00014-14-1-0665, and Microsoft faculty fellowship. SS would like to acknowledge NSF grants 1302435, 0954059, 1017525 and DTRA grant HDTRA113-1-0024. PJ would like to acknowledge Nikhil Srivastava and Deeparnab Chakrabarty for several insightful discussions during the course of the project."
    }, {
      "heading" : "A Proof of Theorem 1",
      "text" : "We will start with some preliminary lemmas. The first lemma is the well known Weyl’s inequality in the matrix setting[Bha97]. Lemma 2. Suppose B = A+E be an n×n matrix. Let λ1, · · · , λn and σ1, · · · , σn be the eigenvalues of B and A respectively such that λ1 ≥ · · · ≥ λn and σ1 ≥ · · · ≥ σn. Then we have:\n|λi − σi| ≤ ‖E‖2 ∀ i ∈ [n].\nThe following lemma is the Davis-Kahan theorem[Bha97], specialized for rank-1 matrices. Lemma 3. Suppose B = A+E. Let A = u∗(u∗) >\nbe a rank-1 matrix with unit spectral norm. Suppose further that ‖E‖2 < 1 2 . Then, we have: |λ− 1| < ‖E‖2 , and∣∣∣〈u,u∗〉2 − 1∣∣∣ < 4 ‖E‖2 , where λ and u are the top eigenvalue eigenvector pair of B.\nAs outlined in Section 3.1 (and formalized in the proof of Theorem 1), it is sufficient to prove the correctness of Algorithm 1 for the case of symmetric matrices. So, most of the lemmas we prove in this section assume that the matrices are symmetric. Lemma 4. Let S ∈ Rn×n satisfy assumption (S1). Then, ‖S‖2 ≤ αn ‖S‖∞.\nProof of Lemma 4. Let x, y be unit vectors such that ‖S‖2 = xTSy = ∑ ij xiyjSij . Then, using a·b ≤ (a2+b2)/2, we have:\n‖S‖2 ≤ 1\n2 ∑ ij (x2i + y 2 j )Sij ≤ 1 2 (αn‖S‖∞ + αn‖S‖∞), (3)\nwhere the last inequality follows from the fact that S has at most αn non-zeros per row and per column.\nLemma 5. Let S ∈ Rn×n satisfy assumption (S1). Also, let U ∈ Rn×r be a µ-incoherent orthogonal matrix, i.e., maxi ∥∥ei>U∥∥2 ≤ µ√r√n , where ei stands for the ith standard basis vector. Then, ∀p ≥ 0, the following holds: max i\n∥∥ei>SpU∥∥2 ≤ µ√r√n (α · n · ‖S‖∞)p. Proof of Lemma 5. We prove the lemma using mathematical induction.\nBase Case (p = 0): This is just a restatement of the incoherence of U .\nInduction step: We have:∥∥ei>(S)p+1U∥∥22 = ‖ei>S(SpU)‖22 = ∑ ` (ei >S(SpU)e`) 2 = ∑ ` ( ∑ j Sijej >(SpU)e`) 2\n= ∑ j1j2 Sij1Sij2 ∑ ` (ej1 >(SpU)e`)(e` >(SpU) > ej2)\nζ1 ≤ ∑ j1j2 Sij1Sij2(ej1 >(SpU)(SpU) > ej2) ≤ ∑ j1j2 Sij1Sij2‖eTj1(S pU)‖2‖ej2>(SpU)‖2\nζ2 ≤ µ\n2r n (α · n · ‖S‖∞)2p,\nwhere ζ1 follows by ∑t `=1 e`e`\n> = I, and ζ2 follows from assumption (S1) on S and from the inductive hypothesis on ∥∥ei>SpU∥∥2.\nIn what follows, we prove a number of lemmas concerning the structure of L(t) and E(t) := S∗ − S(t). The following lemma shows that the threshold in (2) is close to that with M − S(t) replaced by L∗. Lemma 6. Let L∗, S∗ be symmetric and satisfy the assumptions of Theorem 1 and let S(t) be the tth iterate of the kth stage of Algorithm 1. Let σ∗1 , . . . , σ ∗ r be the eigenvalues of L\n∗, such that |σ∗1 | ≥ · · · ≥ |σ∗r | and λ1, · · · , λn be the eigenvalues of M − S(t) such that |λ1| ≥ · · · ≥ |λn|. Recall that E(t) := S∗ − S(t). Suppose further that\n1. ∥∥E(t)∥∥∞ ≤ 8µ2rn (|σ∗k+1|+ ( 12)t−1 |σ∗k|), and\n2. Supp ( E(t) ) ⊆ Supp (S∗).\nThen,\n7\n8\n( |σ∗k+1|+ ( 1\n2\n)t |σ∗k| ) ≤ ( |λk+1|+ ( 1\n2\n)t |λk| ) ≤ 9\n8\n( |σ∗k+1|+ ( 1\n2\n)t |σ∗k| ) . (4)\nProof. Note that M − S(t) = L∗ + E(t). Now, using Lemmas 2 and 4, we have:∣∣λk+1 − σ∗k+1∣∣ ≤ ∥∥∥E(t)∥∥∥ 2 ≤ αn ∥∥∥E(t)∥∥∥ ∞ ≤ 8µ2rαγt,\nwhere γt := ( |σ∗k+1|+ ( 1 2 )t−1 |σ∗k|). That is, ∣∣|λk+1| − |σ∗k+1|∣∣ ≤ 8µ2rαγt. Similarly, ||λk| − |σ∗k|| ≤ 8µ2rαγt. So we have: ∣∣∣∣∣ ( |λk+1|+ ( 1 2 )t |λk| ) − ( |σ∗k+1|+ ( 1 2 )t |σ∗k| )∣∣∣∣∣ ≤ 8µ2rαγt ( 1 + ( 1 2\n)t) ≤ 16µ2rαγt\n≤ 1 8\n( |σ∗k+1|+ ( 1\n2\n)t |σ∗k| ) ,\nwhere the last inequality follows from the bound α ≤ 1512µ2r .\nThe following lemma shows that under the same assumptions as in Lemma 6, we can obtain a bound on the `∞ norm of L(t+1) − L∗. This is the most crucial step in our analysis since we bound `∞ norm of errors which are quite hard to obtain. Lemma 7. Assume the notation of Lemma 6. Also, let L(t), S(t) be the tth iterates of kth stage of Algorithm 1 and L(t+1), S(t+1) be the (t + 1)th iterates of the same stage. Also, recall that E(t) := S∗ − S(t) and E(t+1) := S∗ − S(t+1). Suppose further that\n1. ∥∥E(t)∥∥∞ ≤ 8µ2rn (|σ∗k+1|+ ( 12)t−1 |σ∗k|), and\n2. Supp ( E(t) ) ⊆ Supp (S∗).\nThen, we have: ∥∥∥L(t+1) − L∗∥∥∥ ∞ ≤ 2µ 2r n ( |σ∗k+1|+ ( 1 2 )t |σ∗k| ) .\nProof. Let L(t+1) = Pk(M − S(t)) = UΛU> be the eigenvalue decomposition of L(t+1). Also, recall that\nM − S(t) = L∗ + E(t). Then, for every eigenvector ui of L(t+1), we have( L∗ + E(t) ) ui = λiui,(\nI − E (t)\nλi\n) ui = 1\nλi L∗ui,\nui =\n( I − E (t)\nλi )−1 L∗ui λi\n= ( I + E(t)\nλi +\n( E(t)\nλi\n)2 + . . . ) L∗ui λi . (5)\nNote that we used Lemmas 2 and 4 to guarantee the existence of ( I − E (t)\nλi\n)−1 . Hence,\nUΛU> − L∗ = ( L∗UΛ−1U>L∗ − L∗ ) + ∑ p+q≥1 ( E(t) )p L∗UΛ−(p+q+1)U>L∗ ( E(t) )q .\nBy triangle inequality, we have∥∥UΛU> − L∗∥∥∞ ≤ ∥∥L∗UΛ−1U>L∗ − L∗∥∥∞ + ∑ p+q≥1 ∥∥∥(E(t))p L∗UΛ−(p+q+1)U>L∗ (E(t))q∥∥∥ ∞ . (6)\nWe now bound the two terms on the right hand side above.\nWe note that, ∥∥L∗UΛ−1U>L∗ − L∗∥∥∞ = max ij ei > ( U∗Σ∗(U∗) > UΛ−1U>U∗Σ∗(U∗) > − U∗Σ∗(U∗)> ) ej\n= max ij\nei >U∗ ( Σ∗(U∗) > UΛ−1U>U∗Σ∗ − Σ∗ ) (U∗) > ej\n≤ max ij ‖ei>U∗‖ · ‖ej>U∗‖ · ‖U∗Σ∗(U∗)>UΛ−1U>U∗Σ∗(U∗)> − U∗Σ∗(U∗)>‖2 ≤ µ 2r\nn ‖L∗UΛ−1U>L∗ − L∗‖2, (7)\nwhere we denote U∗Σ∗(U∗) > to be the SVD of L∗. Let L∗ + E(t) = UΛU> + Ũ Λ̃Ũ> be the eigenvalue decomposition of L∗+E(t). Note that Ũ>U = 0. Recall that, UΛU> = Pk(M −S(t)) = Pk(L∗+E(t)) = L(t+1). Also note that,\nL∗UΛ−1U>L∗ − L∗ = ( UΛU> + Ũ Λ̃Ũ> − E(t) ) UΛ−1U> ( UΛU> + Ũ Λ̃ŨT − E(t) ) − L∗,\n= ( UU> − ( E(t) ) UΛ−1U> )( UΛU> + Ũ Λ̃ŨT − E(t) ) − L∗,\n= −UU>E(t) − E(t)UU> − E(t)UΛ−1U>E(t) > − Ũ Λ̃Ũ> + E(t). (8)\nHence, using Lemma 8, we have:\n‖L∗UΛ−1U>L∗ − L∗‖2 ≤ 3‖E(t)‖2 + ‖E(t)‖22 |λk| + |λk+1|\n≤ ∣∣σ∗k+1∣∣+ 5 ∥∥∥E(t)∥∥∥\n2 . (9)\nCombining (7) and (9), we have:∥∥L∗UΛ−1U>L∗ − L∗∥∥∞ ≤ µ2rn (∣∣σ∗k+1∣∣+ 5 ∥∥∥E(t)∥∥∥2) (10) Now, we will bound the (p, q)th term of ∑ p+q≥1 ∥∥∥(E(t))p L∗UΛ−(p+q+1)U>L∗ (E(t))q∥∥∥ ∞\n:∥∥∥(E(t))pL∗UΛ−(p+q+1)U>L∗(E(t))q∥∥∥ ∞\n= max ij\nei > ( (E(t))pL∗UΛ−(p+q+1)U>L∗(E(t))q ) ej ,\n≤ max ij ∥∥∥ei>(E(t))pU∗∥∥∥ 2 ∥∥∥ej>(E(t))qU∗∥∥∥ 2 ∥∥∥L∗UΛ−(p+q+1)U>L∗∥∥∥ 2 ,\nζ1 ≤ µ\n2r\nn\n( αn ∥∥∥E(t)∥∥∥\n∞\n)p ( αn ∥∥∥E(t)∥∥∥\n∞ )q ∥∥∥L∗UΛ−(p+q+1)U>L∗∥∥∥ 2 , (11)\nwhere ζ1 follows from Lemma 5 and the incoherence of L ∗. Now, similar to (8), we have:∥∥∥L∗UΛ−(p+q+1)U>L∗∥∥∥\n2 = ∥∥∥UΛ−(p+q−1)U> − E(t)UΛ−(p+q)U> − UΛ−(p+q)U>E(t) + E(t)UΛ−(p+q+1)U>E(t)∥∥∥\n2 ,\n≤ ‖Λ−(p+q−1)‖2 + 2‖E(t)‖2‖Λ−(p+q)‖2 + ‖E(t)‖22‖Λ−(p+q+1)‖2, ≤ |λk|−(p+q−1) (\n1 + 2 ‖E(t)‖2 |λk| + ‖E(t)‖22 λ2k\n) = |λk|−(p+q−1) ( 1 + ‖E(t)‖2 |λk| )2 ,\n≤ |λk|−(p+q−1) ( 1 + ∥∥E(t)∥∥ 2\n|λk|\n)2 ,\nζ1 ≤ |λk|−(p+q−1) ( 1 +\n17µ2rα |σ∗k| (1− 17µ2rα) |σ∗k|\n)2 ≤2 |λk|−(p+q−1) , (12)\nwhere ζ1 follows from Lemma 8.\nUsing (11), (12), we have:∥∥∥(E(t))pL∗UΛ−(p+q+1)U>L∗(E(t))q∥∥∥ ∞ ≤ 2αµ2r ∥∥∥E(t)∥∥∥ ∞ ( αn ∥∥E(t)∥∥∞ |λk| )p+q−1 . (13) Using the above bound, and the assumption on ∥∥E(t)∥∥∞:∥∥∥E(t)∥∥∥\n∞ ≤ 8µ\n2r\nn (∣∣σ∗k+1∣∣+ (12 )t−1 |σ∗k| ) ≤ 17µ 2r n |σ∗k| ,\nwe have: ∑ p+q≥1 ∥∥∥(E(t))p L∗UΛ−(p+q+1)U>L∗ (E(t))q∥∥∥ ∞\n≤ 2µ2rα ∥∥∥E(t)∥∥∥\n∞ ∑ p+q≥1 ( αn ∥∥E(t)∥∥∞ |λk| )p+q−1\n≤ 2µ2rα ∥∥∥E(t)∥∥∥\n∞\n( 1\n1− 17µ2αr1−17µ2α·r\n)2\n≤ 2µ2rα ∥∥∥E(t)∥∥∥\n∞\n( 1\n1− 34µ2rα )2 ≤ 4µ2rα ∥∥∥E(t)∥∥∥ ∞ . (14)\nCombining (6), (10), (14), we have:\n‖UΛU> − L∗‖∞ ≤ µ2r\nn (∣∣σ∗k+1∣∣+ 5 ∥∥∥E(t)∥∥∥ 2 + 4µ2rαn ∥∥∥E(t)∥∥∥ ∞ ) ≤ 2µ 2r\nn (∣∣σ∗k+1∣∣+ (12 )t |σ∗k| ) ,\nwhere we used Lemma 4 and the assumption on ∥∥E(t)∥∥∞.\nWe used the following technical lemma in the proof of Lemma 7. Lemma 8. Assume the notation of Lemma 7. Suppose further that\n1. ∥∥E(t)∥∥∞ ≤ 8µ2rn (|σ∗k+1|+ ( 12)t−1 |σ∗k|), and\n2. Supp ( E(t) ) ⊆ Supp (S∗).\nThen we have:∥∥∥E(t)∥∥∥ 2 ≤ 17µ2rα|σ∗k|, |λk| ≥ |σ∗k| (1− 17µ2rα), and |λk+1| ≤ |σ∗k+1|+ ∥∥∥E(t)∥∥∥ 2 .\nProof. Using Lemmas 4 and 2, we have: |λi − σ∗i | ≤ ‖E(t)‖2 ≤ αn ∥∥∥E(t)∥∥∥\n∞ .\nThe result follows by using the bound on ∥∥E(t)∥∥∞.\nThe following lemma bounds the support of E(t+1) and ∥∥E(t+1)∥∥∞, using an assumption on ∥∥L(t+1) − L∗∥∥∞. Lemma 9. Assume the notation of Lemma 7. Suppose\n∥∥∥L(t+1) − L∗∥∥∥ ∞ ≤ 2µ 2r n ( |σ∗k+1|+ ( 1 2 )t |σ∗k| ) .\nThen, we have: 1. Supp ( E(t+1) ) ⊆ Supp (S∗).\n2. ∥∥E(t+1)∥∥∞ ≤ 7µ2rn (|σ∗k+1|+ ( 12)t |σ∗k|), and\nProof. We first prove the first conclusion. Recall that,\nS(t+1) = Hζ(M − L(t+1)) = Hζ(L∗ − L(t+1) + S∗),\nwhere ζ = 4µ 2r n ( |λk+1|+ ( 1 2 )t |λk|) is as defined in Algorithm 1 and λ1, · · · , λn are the eigenvalues of M −S(t) such that |λ1| ≥ · · · ≥ |λn|.\nIf S∗ij = 0 then E (t+1) ij = 1 {∣∣∣L∗ij−L(t+1)ij ∣∣∣>ζ} · (L∗ij − L(t+1)ij ). The first part of the lemma now follows by using the assumption that\n∥∥L(t+1) − L∗∥∥∞ ≤ 2µ2rn (|σ∗k+1|+ ( 12)t |σ∗k|) (ζ1)≤ 4µ2rn (|λ∗k+1|+ ( 12)t |λ∗k|) = ζ, where (ζ1) follows from Lemma 6.\nWe now prove the second conclusion. We consider the following two cases: 1. ∣∣∣Mij − L(t+1)ij ∣∣∣ > ζ: Here, S(t+1)ij = S∗ij + L∗ij − L(t+1)ij . Hence, |S(t+1)ij − S∗ij | ≤ |L∗ij − L(t+1)ij | ≤ 2µ2r n ( |σ∗k+1|+ ( 1 2 )t |σ∗k|).\n2. ∣∣∣Mij − L(t+1)ij ∣∣∣ ≤ ζ: In this case, S(t+1)ij = 0 and ∣∣∣S∗ij + L∗ij − L(t+1)ij ∣∣∣ ≤ ζ. So we have, ∣∣∣E(t+1)ij ∣∣∣ = ∣∣S∗ij∣∣ ≤ ζ +\n∣∣∣L∗ij − L(t+1)ij ∣∣∣ ≤ 7µ2rn (|σ∗k+1|+ ( 12)t |σ∗k|). The last inequality above follows from Lemma 6. This proves the lemma.\nWe are now ready to prove Lemma 1. In fact, we prove the following stronger version.\nProof of Lemma 1. Recall that in the kth stage, the update L(t+1) is given by: L(t+1) = Pk(M − S(t)) and S(t+1) is given by: S(t+1) = Hζ(M − L(t+1)). Also, recall that E(t) := S∗ − S(t) and E(t+1) := S∗ − S(t+1).\nWe prove the lemma by induction on both k and t. For the base case (k = 1 and t = −1), we first note that the first inequality on ∥∥L(0) − L∗∥∥∞ is trivially satisfied. Due to the thresholding step (step 3 in Algorithm 1) and the incoherence assumption on L∗, we have:∥∥∥E(0)∥∥∥\n∞ ≤ 8µ\n2r\nn (σ∗2 + 2σ ∗ 1) , and Supp ( E(0) ) ⊆ Supp (S∗) .\nSo the base case of induction is satisfied. We first do the inductive step over t (for a fixed k). By inductive hypothesis we assume that: a) ∥∥E(t)∥∥∞ ≤ 8µ2r n ( |σ∗k+1|+ ( 1 2\n)t−1 |σ∗k|), b) Supp (E(t)) ⊆ Supp (S∗). Then by Lemma 7, we have: ∥∥∥L(t+1) − L∗∥∥∥\n∞ ≤ 2µ\n2r\nn\n( |σ∗k+1|+ ( 1\n2\n)t+1 |σ∗k| ) .\nLemma 9 now tells us that 1. ∥∥E(t+1)∥∥∞ ≤ 8µ2rn (|σ∗k+1|+ ( 12)t |σ∗k|), and\n2. Supp ( E(t+1) ) ⊆ Supp (S∗).\nThis finishes the induction over t. Note that we show a stronger bound than necessary on ∥∥E(t+1)∥∥∞.\nWe now do the induction over k. Suppose the hypothesis holds for stage k. Let T denote the number of iterations in each stage. We first obtain a lower bound on T . Since∥∥∥M − S(0)∥∥∥\n2 ≥ ‖L∗‖2 − ∥∥∥E(0)∥∥∥ 2 ≥ |σ∗1 | − αn ∥∥∥E(0)∥∥∥ ∞ ≥ 3 4 |σ∗1 | ,\nwe see that T ≥ 10 log ( 3µ2r |σ∗1 | / ) . So, at the end of stage k, we have:\n1. ∥∥E(T )∥∥∞ ≤ 7µ2rn (|σ∗k+1|+ ( 12)T |σ∗k|) ≤ 7µ2r|σ∗k+1|n + 10n , and\n2. Supp ( E(T ) ) ⊆ Supp (S∗).\nLemmas 4 and 2 tell us that ∣∣σk+1 (M − S(T ))− ∣∣σ∗k+1∣∣∣∣ ≤ ∥∥E(T )∥∥2 ≤ α (7µ2r ∣∣σ∗k+1∣∣+ ). We will now consider two cases:\n1. Algorithm 1 terminates: This means that βσk+1 ( M − S(T ) ) < 2n which then implies that ∣∣σ∗k+1∣∣ <\n6µ2r . So we have: ∥∥∥L̂− L∗∥∥∥ ∞ = ∥∥∥L(T ) − L∗∥∥∥ ∞ ≤ 2µ 2r n ( |σ∗k+1|+ ( 1 2 )T |σ∗k| ) ≤ 5n . This proves the statement about L̂. A similar argument proves the claim on ∥∥∥Ŝ − S∗∥∥∥\n∞ . The claim on Supp ( Ŝ ) follows since Supp ( E(T ) ) ⊆ Supp (S∗).\n2. Algorithm 1 continues to stage (k+ 1): This means that βσk+1 ( L(T ) ) ≥ 2n which then implies that∣∣σ∗k+1∣∣ > 8µ2r . So we have: ∥∥∥E(T )∥∥∥\n∞ ≤ 8µ\n2r\nn\n( |σ∗k+1|+ ( 1\n2\n)T |σ∗k| )\n≤ 8µ 2r\nn\n( |σ∗k+1|+\n10µ2rn ) ≤ 8µ 2r\nn\n( |σ∗k+1|+ 8 ∣∣σ∗k+1∣∣ 10n )\n≤ 8µ 2r\nn\n( |σ∗k+2|+ 2 ∣∣σ∗k+1∣∣) . Similarly for\n∥∥L(T ) − L∗∥∥∞. This finishes the proof.\nProof of Theorem 1. Using Lemma 1, it suffices to show that the general case can be reduced to the case of symmetric matrices. We will now outline this reduction.\nRecall that we are given an m × n matrix M = L∗ + S∗ where L∗ is the true low-rank matrix and S∗ the sparse error matrix. Wlog, let m ≤ n and suppose βm ≤ n < (β + 1)m, for some β ≥ 1. We then consider the symmetric matrices\nM̃ =  0 ... 0 · · · 0 ... 0\nM> · · ·M>︸ ︷︷ ︸ β times\nM ... M 0\n , L̃ = \n0 ... 0 · · · 0 ... 0\n(L∗) > · · · (L∗)>︸ ︷︷ ︸ β times\nL∗\n... L∗\n0\n , (15)\nand S̃ = M̃−L̃. A simple calculation shows that L̃ is incoherent with parameter √\n3µ and S̃ satisfies the sparsity condition (S1) with parameter α√\n2 . Moreover the iterates of AltProj with input M̃ have similar expressions\nas in (15) in terms of the corresponding iterates with input M . This means that it suffices to obtain the same guarantees for Algorithm 1 for the symmetric case. Lemma 1 does precisely this, proving the theorem."
    }, {
      "heading" : "B Proof of Theorem 2",
      "text" : "In this section, we prove Theorem 2. The roadmap of the proofs in this section is essentially the same as that in Appendix A.\nIn what follows, we prove a number of lemmas concerning the structure of L(t) and E(t) := S∗ − S(t). The first lemma is a generalization of Lemma 6 and shows that the threshold in (2) is close to that with M (t) replaced by L∗. Lemma 10. Let L∗, S∗, N∗ be symmetric and satisfy the assumptions of Theorem 2 and let S(t) be the tth iterate of the kth stage of Algorithm 1. Let σ∗1 , . . . , σ ∗ r be the eigenvalues of L\n∗, such that |σ∗1 | ≥ · · · ≥ |σ∗r | and λ1, · · · , λn be the eigenvalues of M − S(t) such that |λ1| ≥ · · · ≥ |λn|. Recall that E(t) := S∗ − S(t). Suppose further that\n1. ∥∥E(t)∥∥∞ ≤ 8µ2rn (|σ∗k+1|+ ( 12)t−1 |σ∗k|+ 7 ‖N∗‖2 + 8n√r ‖N∗‖∞), and\n2. Supp ( S(t) ) ⊆ Supp (S∗).\nThen,\n7\n8\n( |σ∗k+1|+ ( 1\n2\n)t |σ∗k| ) ≤ ( |λk+1|+ ( 1\n2\n)t |λk| ) ≤ 9\n8\n( |σ∗k+1|+ ( 1\n2\n)t |σ∗k| ) . (16)\nProof. Note that M − S(t) = L∗ +N∗ + E(t). Now, using Lemmas 2 and 4, we have:∣∣λk+1 − σ∗k+1∣∣ ≤ ∥∥∥E(t)∥∥∥ 2 ≤ αn ∥∥∥E(t)∥∥∥ ∞ ≤ 8µ2rαγt,\nwhere γt = ( |σ∗k+1|+ ( 1 2 )t−1 |σ∗k|+ 7 ‖N∗‖2 + 8n√r ‖N∗‖∞). That is, ∣∣|λk+1| − |σ∗k+1|∣∣ ≤ 8µ2rαγt. Similarly, ||λk| − |σ∗k|| ≤ 8µ2rαγt. So we have:∣∣∣∣∣ ( |λk+1|+ ( 1 2 )t |λk| ) − ( |σ∗k+1|+ ( 1 2 )t |σ∗k| )∣∣∣∣∣ ≤ 8µ2rαγt ( 1 + ( 1 2\n)t) ≤ 16µ2rαγt\n≤ 1 8\n( |σ∗k+1|+ ( 1\n2\n)t |σ∗k| ) ,\nwhere the last inequality follows from the bound α ≤ 1512µ2r and the assumption on ‖N ∗‖∞.\nThe following lemma shows that under the same assumptions as in Lemma 6, we can obtain a bound on the `∞ norm of L(t+1) − L∗. This is the most crucial step in our analysis since we bound `∞ norm of errors which are quite hard to obtain. Lemma 11. Assume the notation of Lemma 6. Also, let L(t), S(t) be the tth iterates of kth stage of Algorithm 1 and L(t+1), S(t+1) be the (t + 1)th iterates of the same stage. Also, recall that E(t) := S∗ − S(t) and E(t+1) := S∗ − S(t+1). Suppose further that\n1. ∥∥E(t)∥∥∞ ≤ 8µ2rn (|σ∗k+1|+ ( 12)t−1 |σ∗k|+ 7 ‖N∗‖2 + 8n√r ‖N∗‖∞), and\n2. Supp ( E(t) ) ⊆ Supp (S∗).\nThen, we have: ∥∥∥L(t+1) − L∗∥∥∥ ∞ ≤ 2µ 2r n ( |σ∗k+1|+ ( 1 2 )t |σ∗k|+ 7 ‖N∗‖2 + 8n√ r ‖N∗‖∞ ) .\nProof. Let L(t+1) = Pk(M − S(t)) = UΛU> be the eigenvalue decomposition of L(t+1). Also, recall that M − S(t) = L∗ +N∗ + E(t). Then, for every eigenvector ui of L(t+1), we have(\nL∗ +N∗ + E(t) ) ui = λiui,(\nI − E (t)\nλi\n) ui = 1\nλi (L∗ +N∗)ui,\nui =\n( I − E (t)\nλi\n)−1 (L∗ +N∗)ui\nλi\n= ( I + E(t)\nλi +\n( E(t)\nλi\n)2 + . . . ) (L∗ +N∗)ui\nλi .\nNote that we used Lemmas 2 and 4 to guarantee the existence of ( I − E (t)\nλi\n)−1 . Hence,\nUΛU> − L∗ = ((L∗ +N∗)UΛ−1U> (L∗ +N∗)− L∗) + ∑ p+q≥1 (S(t))p (L∗ +N∗)UΛ−(p+q+1)U> (L∗ +N∗) (S(t))q.\nBy triangle inequality, we have∥∥UΛU> − L∗∥∥∞ ≤ ∥∥(L∗ +N∗)UΛ−1U> (L∗ +N∗)− L∗∥∥∞ + ∑ p+q≥1 ∥∥∥(S(t))p (L∗ +N∗)UΛ−(p+q+1)U> (L∗ +N∗) (S(t))q∥∥∥ ∞ . (17)\nWe now bound the two terms on the right hand side above.\nFor the first term, we again use triangle inequality to obtain∥∥(L∗ +N∗)UΛ−1U> (L∗ +N∗)− L∗∥∥∞ ≤ ∥∥L∗UΛ−1U>L∗ − L∗∥∥∞ + ∥∥N∗UΛ−1U>L∗∥∥∞ + ∥∥L∗UΛ−1U>N∗∥∥∞ + ∥∥N∗UΛ−1U>N∗∥∥∞ . (18) We note that, ∥∥L∗UΛ−1U>L∗ − L∗∥∥∞ = max ij ei > ( U∗Σ∗(U∗) > UΛ−1U>U∗Σ∗(U∗) > − U∗Σ∗(U∗)> ) ej\n= max ij\nei >U∗ ( Σ∗(U∗) > UΛ−1U>U∗Σ∗ − Σ∗ ) (U∗) > ej\n≤ max ij ‖ei>U∗‖ · ‖ej>U∗‖ · ‖U∗Σ∗(U∗)>UΛ−1U>U∗Σ∗(U∗)> − U∗Σ∗(U∗)>‖2 ≤ µ 2r\nn ‖L∗UΛ−1U>L∗ − L∗‖2, (19)\nwhere we denote U∗Σ∗(U∗) > to be the SVD of L∗. Let L∗ + N∗ + E(t) = UΛU> + Ũ Λ̃Ũ> be the eigenvalue decomposition of L∗ +N∗ +E(t). Note that Ũ>U = 0. Recall that, UΛU> = Pk(M (t)) = L(t). Also note that,\nL∗UΛ−1U>L∗ − L∗\n= (UΛU> + Ũ Λ̃Ũ> −N∗ − E(t))UΛ−1U>(UΛU> + Ũ Λ̃Ũ> −N∗ − E(t))− L∗, = (UU> − ( N∗ + E(t) ) UΛ−1U>)(UΛU> + Ũ Λ̃Ũ> −N∗ − E(t))− L∗,\n= UΛU> − UU> ( N∗ + E(t) ) − ( N∗ + E(t) ) UU>\n− ( N∗ + E(t) ) UΛ−1U> ( N∗ + E(t) )> − UΛU> − Ũ Λ̃Ũ> +N∗ + E(t). (20)\nHence, using Lemma 12, we have:\n∥∥L∗UΛ−1U>L∗ − L∗∥∥ 2 ≤ 3 ∥∥∥N∗ + E(t)∥∥∥ 2 + ∥∥N∗ + E(t)∥∥2 2 |λk| + |λk+1|\n≤ ∣∣σ∗k+1∣∣+ 4 ∥∥∥N∗ + E(t)∥∥∥\n2 +\n∥∥N∗ + E(t)∥∥2 2\n(1− 17µ2rα) |σ∗k| . (21)\nUsing (19), (21), and Lemma 12:∥∥L∗UΛ−1U>L∗ − L∗∥∥∞ ≤ µ2rn (∣∣σ∗k+1∣∣+ 7 ‖N∗‖2 + 5 ∥∥∥E(t)∥∥∥2) (22) Coming to the second term of (18), we have:∥∥N∗UΛ−1U>L∗∥∥∞\n= max i,j\nei >N∗UΛ−1U>L∗ej\n≤ max i ∥∥ei>N∗U∥∥2 ∥∥Λ−1U>U∗Σ∗∥∥2 ∥∥∥(U∗)>ej∥∥∥2 ≤ √ n ‖N∗‖∞ ∥∥Λ−1U>U∗Σ∗∥∥ 2 µ √ r√ n = µ √ r ‖N∗‖∞ ∥∥∥UΛ−1U>U∗Σ∗(U∗)>∥∥∥ 2 . (23)\nUsing an expansion along the lines of (20), we see that\n∥∥∥UΛ−1U>U∗Σ∗(U∗)>∥∥∥ 2 ≤ 1 + ∥∥N∗ + E(t)∥∥ 2 |λk| ≤ 1 + ‖N∗‖2 + ∥∥E(t)∥∥ 2 (1− 17µ2r · α) |σ∗k|\n≤ 2 + ∥∥E(t)∥∥ 2\n(1− 17µ2rα) |σ∗k| .\nPlugging this in (23) gives us ∥∥N∗UΛ−1U>L∗∥∥∞ ≤ 3µ√r ‖N∗‖∞ . (24) A similar argument as in (23) gives us the following bound on the last term in (18): ∥∥N∗UΛ−1U>N∗∥∥∞ ≤ n ‖N∗‖2∞|λk| ≤ ‖N∗‖∞ . (25) Plugging (22), (24) and (25), we obtain:∥∥(L∗ +N∗)UΛ−1U> (L∗ +N∗)− L∗∥∥∞\n≤ µ 2r\nn (∣∣σ∗k+1∣∣+ 7 ‖N∗‖2 + 7 ∥∥∥E(t)∥∥∥ 2 + 7n√ r ‖N∗‖∞ ) . (26)\nNext, we analyze ∑ p+q≥1 ∥∥(E(t))p(L∗ +N∗)UΛ−(p+q+1)U>(L∗ +N∗)(E(t))q∥∥∞. This can again be bounded by four quantities:∥∥∥(E(t))p(L∗ +N∗)UΛ−(p+q+1)U>(L∗ +N∗)(E(t))q∥∥∥\n∞ ≤ ∥∥∥(E(t))pL∗UΛ−(p+q+1)U>L∗(E(t))q∥∥∥ ∞ + ∥∥∥(E(t))pN∗UΛ−(p+q+1)U>L∗(E(t))q∥∥∥ ∞ (27)\n+ ∥∥∥(E(t))pL∗UΛ−(p+q+1)U>N∗(E(t))q∥∥∥ ∞ + ∥∥∥(E(t))pN∗UΛ−(p+q+1)U>N∗(E(t))q∥∥∥ ∞ . (28)\nWe bound the first term above:∥∥∥(E(t))pL∗UΛ−(p+q+1)U>L∗(E(t))q∥∥∥ ∞\n= max ij\nei > ( (E(t))pL∗UΛ−(p+q+1)U>L∗(E(t))q ) ej ,\n≤ max ij ∥∥∥ei>(E(t))pU∗∥∥∥ 2 ∥∥∥ej>(E(t))qU∗∥∥∥ 2 ∥∥∥L∗UΛ−(p+q+1)U>L∗∥∥∥ 2 ,\n(ζ1) ≤ µ 2r\nn\n( αn ∥∥∥E(t)∥∥∥\n∞\n)p ( αn ∥∥∥E(t)∥∥∥\n∞ )q ∥∥∥L∗UΛ−(p+q+1)U>L∗∥∥∥ 2 , (29)\nwhere (ζ1) follows from Lemma 5 and the incoherence of L ∗. Now, similar to (20), we have:∥∥∥L∗UΛ−(p+q+1)U>L∗∥∥∥\n2 = ∥∥∥UΛ−(p+q−1)U> − (N∗ + E(t))UΛ−(p+q)U> − UΛ−(p+q)U> (N∗ + E(t))\n+ ( N∗ + E(t) ) UΛ−(p+q+1)U> ( N∗ + E(t) )∥∥∥ 2 ,\n≤ ‖Λ−(p+q−1)‖2 + 2‖N∗ + E(t)‖2‖Λ−(p+q)‖2 + ‖N∗ + E(t)‖22‖Λ−(p+q+1)‖2, ≤ |λk|−(p+q−1) ( 1 + 2 ‖N∗ + E(t)‖2\n|λk| + ‖N∗ + E(t)‖22 λ2k\n) ,\n= |λk|−(p+q−1) ( 1 + ‖N∗ + E(t)‖2\n|λk|\n)2 ,\n≤ |λk|−(p+q−1) ( 1 + ‖N∗‖2 + ∥∥E(t)∥∥ 2\n|λk|\n)2 ,\n(ζ1) ≤ |λk|−(p+q−1) ( 1 + ‖N∗‖2 + 17µ2rα |σ∗k|\n(1− 17µ2rα) |σ∗k|\n)2 ≤2 |λk|−(p+q−1) , (30)\nwhere (ζ1) follows from Lemma 12 and the bound on ‖N∗‖∞.\nUsing (29), (30), we have:\n∥∥∥(E(t))pL∗UΛ−(p+q+1)U>L∗(E(t))q∥∥∥ ∞ ≤ 2αµ2r ∥∥∥E(t)∥∥∥ ∞ ( αn ∥∥E(t)∥∥∞ |λk| )p+q−1 . (31)\nComing to the second term of (28), we have∥∥∥(E(t))pN∗UΛ−(p+q+1)U>L∗(E(t))q∥∥∥ ∞\n= max i,j\nei > ( (E(t))pN∗UΛ−(p+q+1)U>L∗(E(t))q ) ej ,\n≤ max ij ∥∥∥ei>(E(t))pN∗U∥∥∥ 2 ∥∥∥ej>(E(t))qU∗∥∥∥ 2 ∥∥∥Λ−(p+q+1)U>L∗∥∥∥ 2\n(ζ1) ≤ µ √ r√ n ‖N∗U‖∞\n( αn ∥∥∥E(t)∥∥∥\n∞\n)p ( αn ∥∥∥E(t)∥∥∥\n∞ )q ∥∥∥UΛ−(p+q+1)U>L∗∥∥∥ 2\n≤ µ √ r ‖N∗‖∞ ( αn ∥∥∥E(t)∥∥∥\n∞ )p+q ∥∥∥UΛ−(p+q+1)U>L∗∥∥∥ 2 , (32)\nwhere (ζ1) follows from Lemma 5 and incoherence of U ∗. Proceeding along the lines of (30), we obtain:\n∥∥∥UΛ−(p+q+1)U>L∗∥∥∥ 2 ≤ |λk|−(p+q) ( 1 + ‖N∗‖2 + ∥∥E(t)∥∥ 2 |λk| ) ≤2 |λk|−(p+q) .\nPlugging the above in (32) gives us\n∥∥∥(E(t))pN∗UΛ−(p+q+1)U>L∗(E(t))q∥∥∥ ∞ ≤ 2µ √ r ( αn ∥∥E(t)∥∥∞ |λk| )p+q ‖N∗‖∞ . (33)\nA similar argument as in (32) gives us\n∥∥∥(E(t))pN∗UΛ−(p+q+1)U>N∗(E(t))q∥∥∥ ∞ ≤ n ‖N∗‖∞ |λk| ( αn ∥∥E(t)∥∥∞ |λk| )p+q ‖N∗‖∞ .\nPlugging the above inequality along with (31) and (33) into (28) gives us:∥∥∥(E(t))p(L∗ +N∗)UΛ−(p+q+1)U>(L∗ +N∗)(E(t))q∥∥∥ ∞\n≤ 2µ2r ( α ∥∥∥E(t)∥∥∥\n∞ + ‖N∗‖∞√ r )( αn ∥∥E(t)∥∥∞ |λk| )p+q−1 .\nUsing the above bound, and the assumption on ∥∥E(t)∥∥∞:∥∥∥E(t)∥∥∥\n∞ ≤ 8µ\n2r\nn (∣∣σ∗k+1∣∣+ (12 )t−1 |σ∗k|+ 7 ‖N∗‖2 + 8n√ r ‖N∗‖∞ ) ≤ 17µ 2r n |σ∗k| ,\nwe have: ∑ p+q≥1 ∥∥∥(E(t))p (L∗ +N∗)UΛ−(p+q+1)U> (L∗ +N∗) (E(t))q∥∥∥ ∞\n(34)\n≤ 2µ2r ( α ∥∥∥E(t)∥∥∥\n∞ + ‖N∗‖∞√ r ) ∑ p+q≥1 ( αn ∥∥E(t)∥∥∞ |λk| )p+q−1\n≤ 2µ2r ( α ∥∥∥E(t)∥∥∥\n∞ + ‖N∗‖∞√ r\n)( 1\n1− 17µ2αr1−17µ2α·r\n)2\n≤ 2µ2r ( α ∥∥∥E(t)∥∥∥\n∞ + ‖N∗‖∞√ r\n)( 1\n1− 34µ2rα )2 ≤ 4µ2r ( α ∥∥∥E(t)∥∥∥\n∞ + ‖N∗‖∞√ r\n) . (35)\nCombining (17), (26), (35), we have:∥∥UΛU> − L∗∥∥∞ (ζ1)≤ µ2rn (∣∣σ∗k+1∣∣+ 7 ‖N∗‖2 + 11nα ∥∥∥E(t)∥∥∥∞ + 11n√r ‖N∗‖∞ ) (ζ2)\n≤ 2µ 2r\nn (∣∣σ∗k+1∣∣+ (12 )t |σ∗k|+ 7 ‖N∗‖2 + 8n√ r ‖N∗‖∞ ) ,\nwhere (ζ1) follows from Lemma 4, and (ζ2) follows from the assumption on ∥∥E(t)∥∥∞.\nWe used the following technical lemma in the proof of Lemma 11. Lemma 12. Assume the notation of Lemma 11. Suppose further that\n1. ∥∥E(t)∥∥∞ ≤ 8µ2rn (|σ∗k+1|+ ( 12)t−1 |σ∗k|+ 7 ‖N∗‖2 + 8n√r ‖N∗‖∞), and\n2. Supp ( E(t) ) ⊆ Supp (S∗).\nThen we have:∥∥∥E(t)∥∥∥ 2 ≤ 17µ2rα|σ∗k|, |λk| ≥ |σ∗k| (1− 17µ2rα), and |λk+1| ≤ |σ∗k+1|+ ∥∥∥E(t)∥∥∥ 2 .\nProof. Using Lemmas 4 and 2, we have: |λi − σ∗i | ≤ ∥∥∥E(t)∥∥∥\n2 ≤ αn ∥∥∥E(t)∥∥∥ ∞ .\nUsing the bound on ∥∥E(t)∥∥∞ and recalling the assumption that\n‖N∗‖∞ ≤ |σ∗r | 100\nfinishes the proof.\nThe following lemma bounds the support of E(t+1) and ∥∥E(t+1)∥∥∞, using an assumption on ∥∥L(t+1) − L∗∥∥∞. Lemma 13. Assume the notation of Lemma 11. Suppose∥∥∥L(t+1) − L∗∥∥∥ ∞ ≤ 2µ 2r n ( |σ∗k+1|+ ( 1 2 )t |σ∗k|+ 7 ‖N∗‖2 + 8n√ r ‖N∗‖∞ ) .\nThen, we have: 1. Supp ( E(t+1) ) ⊆ Supp (S∗).\n2. ∥∥E(t+1)∥∥∞ ≤ 7µ2rn (|σ∗k+1|+ ( 12)t |σ∗k|+ 7 ‖N∗‖2 + 8n√r ‖N∗‖∞), and\nProof. We first prove the first conclusion. Recall that,\nS(t+1) = Hζ(M − L(t+1)) = Hζ(L∗ − L(t+1) +N∗ + S∗),\nwhere ζ = 4µ 2r n ( |λk+1|+ ( 1 2 )t |λk|) is as defined in Algorithm 1 and λ1, · · · , λn are the eigenvalues of M −S(t) such that |λ1| ≥ · · · ≥ |λn|.\nIf S∗ij = 0 then E (t+1) ij = 1 {∣∣∣L∗ij−L(t+1)ij +N∗ij∣∣∣>ζ} · (L∗ij − L(t+1)ij + N∗ij). The first part of the lemma now follows by using the assumption that\n∥∥L(t+1) − L∗∥∥∞ ≤ 2µ2rn (|σ∗k+1|+ ( 12)t |σ∗k|) (ζ1)≤ 9µ2r4n (|λ∗k+1|+ ( 12)t |λ∗k|) = ζ, where (ζ1) follows from Lemma 6, and the bound on ‖N∗‖∞.\nWe now prove the second conclusion. We consider the following two cases: 1. ∣∣∣Mij − L(t+1)ij ∣∣∣ > ζ: Here, S(t+1)ij = S∗ij +L∗ij−L(t+1)ij +N∗ij . Hence, |S(t+1)ij −S∗ij | ≤ |L∗ij−L(t+1)ij |+ ∣∣N∗ij∣∣ ≤ 2µ2r n ( |σ∗k+1|+ ( 1 2\n)t |σ∗k|)+ ‖N∗‖∞. 2. ∣∣∣Mij − L(t+1)ij ∣∣∣ ≤ ζ: In this case, S(t+1)ij = 0 and ∣∣∣S∗ij + L∗ij − L(t+1)ij +N∗ij∣∣∣ ≤ ζ. So we have, ∣∣∣E(t+1)ij ∣∣∣ =∣∣S∗ij∣∣ ≤ ζ + ∣∣∣L∗ij − L(t+1)ij ∣∣∣+ ∣∣N∗ij∣∣ ≤ 7µ2rn (|σ∗k+1|+ ( 12)t |σ∗k|)+ ‖N∗‖∞. The last inequality above follows from Lemma 6.\nThis proves the lemma.\nThe following lemma is a generalization of Lemma 1. Lemma 14. Let L∗, S∗, N∗ be symmetric and satisfy the assumptions of Theorem 2 and let M (t) and L(t) be the tth iterates of the kth stage of Algorithm 1. Let σ∗1 , . . . , σ ∗ n be the eigenvalues of L\n∗, s.t., |σ∗1 | ≥ · · · ≥ |σ∗r |. Then, the following holds:∥∥∥L(t+1) − L∗∥∥∥\n∞ ≤ 2µ\n2r\nn (∣∣σ∗k+1∣∣+ (12 )t |σ∗k|+ 7 ‖N∗‖2 + 8n√ r ‖N∗‖∞ ) ,\n∥∥∥E(t+1)∥∥∥ ∞ = ∥∥∥S∗ − S(t+1)∥∥∥ ∞ ≤ 8µ 2r n (∣∣σ∗k+1∣∣+ (12 )t−1 |σ∗k|+ 7 ‖N∗‖2 + 8n√ r ‖N∗‖∞ ) , and\nSupp ( E(t+1) ) ⊆ Supp (S∗) .\nMoreover, the outputs L̂ and Ŝ of Algorithm 1 satisfy:∥∥∥L̂− L∗∥∥∥ F ≤ + 2µ2r ( 7 ‖N∗‖2 + 8n√ r ‖N∗‖∞ ) ,∥∥∥Ŝ − S∗∥∥∥\n∞ ≤ n\n+ 8µ2r\nn\n( 7 ‖N∗‖2 +\n8n√ r ‖N∗‖∞\n) , and\nSupp ( Ŝ ) ⊆ Supp (S∗) .\nProof. Recall that in the kth stage, the update L(t+1) is given by: L(t+1) = Pk(M − S(t)) and S(t+1) is given by: S(t+1) = Hζ(M − L(t+1)). Also, recall that E(t) := S∗ − S(t) and E(t+1) := S∗ − S(t+1).\nWe prove the lemma by induction on both k and t. For the base case (k = 1 and t = −1), we first note that the first inequality on ∥∥L(0) − L∗∥∥∞ is trivially satisfied. Due to the thresholding step (step 3 in Algorithm 1) and the incoherence assumption on L∗, we have:∥∥∥E(0)∥∥∥\n∞ ≤ 8µ\n2r\nn (σ∗2 + 2σ ∗ 1) , and Supp ( E(0) ) ⊆ Supp (S∗) .\nSo the base case of induction is satisfied. We first do the inductive step over t (for a fixed k). By inductive hypothesis we assume that: a) ∥∥E(t)∥∥∞ ≤ 8µ2r n ( |σ∗k+1|+ ( 1 2\n)t−1 |σ∗k|+ 7 ‖N∗‖2 + 8n√r ‖N∗‖∞), b) Supp (E(t)) ⊆ Supp (S∗). Then by Lemma 11, we have: ∥∥∥L(t+1) − L∗∥∥∥\n∞ ≤ 2µ\n2r\nn\n( |σ∗k+1|+ ( 1\n2\n)t |σ∗k|+ 7 ‖N∗‖2 +\n8n√ r ‖N∗‖∞\n) .\nLemma 13 now tells us that 1. ∥∥E(t+1)∥∥∞ ≤ 7µ2rn (|σ∗k+1|+ ( 12)t |σ∗k|+ 7 ‖N∗‖2 + 8n√r ‖N∗‖∞), and\n2. Supp ( E(t+1) ) ⊆ Supp (S∗).\nThis finishes the induction over t. Note that we show a stronger bound than necessary on ∥∥E(t+1)∥∥∞.\nWe now do the induction over k. Suppose the hypothesis holds for stage k. Let T denote the number of iterations in each stage. We first obtain a lower bound on T . Since∥∥∥M − S(0)∥∥∥\n2 ≥ ‖L∗ +N∗‖2 − ∥∥∥E(0)∥∥∥ 2 ≥ |σ∗1 | − αn ∥∥∥E(0)∥∥∥ ∞ ≥ 3 4 |σ∗1 | ,\nwe see that T ≥ 10 log ( 3µ2r |σ∗1 | / ) . So, at the end of stage k, we have:\n1. ∥∥E(T )∥∥∞ ≤ 7µ2rn (|σ∗k+1|+ ( 12)T |σ∗k|+ 7 ‖N∗‖2 + 8n√r ‖N∗‖∞) ≤ 7µ2r|σ∗k+1|n + 10n , and\n2. Supp ( E(T ) ) ⊆ Supp (S∗).\nLemmas 4 and 2 tell us that ∣∣σk+1 (M − S(T ))− ∣∣σ∗k+1∣∣∣∣ ≤ ∥∥E(T )∥∥2 ≤ α (7µ2r ∣∣σ∗k+1∣∣+ ). We will now consider two cases:\n1. Algorithm 1 terminates: This means that βσk+1 ( M − S(T ) ) < 2n which then implies that ∣∣σ∗k+1∣∣ <\n6µ2r . So we have:∥∥∥L̂− L∗∥∥∥ ∞ = ∥∥∥L(T ) − L∗∥∥∥ ∞ ≤ 2µ 2r n ( |σ∗k+1|+ ( 1 2 )T |σ∗k|+ 7 ‖N∗‖2 + 8n√ r ‖N∗‖∞ )\n≤ 5n\n+ 2µ2r\nn\n( 7 ‖N∗‖2 +\n8n√ r ‖N∗‖∞\n) .\nThis proves the statement about L̂. A similar argument proves the claim on ∥∥∥Ŝ − S∗∥∥∥\n∞ . The claim on Supp ( Ŝ ) follows since Supp ( E(T ) ) ⊆ Supp (S∗).\n2. Algorithm 1 continues to stage (k+ 1): This means that βσk+1 ( L(T ) ) ≥ 2n which then implies that∣∣σ∗k+1∣∣ > 8µ2r . So we have:∥∥∥E(T )∥∥∥\n∞ ≤ 7µ\n2r\nn\n( |σ∗k+1|+ ( 1\n2\n)T |σ∗k|+ 7 ‖N∗‖2 +\n8n√ r ‖N∗‖∞\n)\n≤ 7µ 2r\nn\n( |σ∗k+1|+\n10µ2rn + 7 ‖N∗‖2 + 8n√ r ‖N∗‖∞ ) ≤ 7µ 2r\nn\n( |σ∗k+1|+ 8 ∣∣σ∗k+1∣∣ 10n + 7 ‖N∗‖2 + 8n√ r ‖N∗‖∞ )\n≤ 8µ 2r\nn\n( |σ∗k+2|+ 2 ∣∣σ∗k+1∣∣+ 7 ‖N∗‖2 + 8n√r ‖N∗‖∞ ) .\nSimilarly for ∥∥L(T ) − L∗∥∥∞.\nThis finishes the proof.\nProof of Theorem 2. Using Lemma 14, it suffices to show that the general case can be reduced to the case of symmetric matrices. We will now outline this reduction.\nRecall that we are given an m× n matrix M = L∗ +N∗ + S∗ where L∗ is the true low-rank matrix, N∗ dense corruption matrix and S∗ the sparse error matrix. Wlog, let m ≤ n and suppose βm ≤ n < (β + 1)m, for some β ≥ 1. We then consider the symmetric matrices\nM̃ =  0 ... 0 · · · 0 ... 0\nM> · · ·M>︸ ︷︷ ︸ β times\nM ... M 0\n , L̃ = \n0 ... 0 · · · 0 ... 0\n(L∗) > · · · (L∗)>︸ ︷︷ ︸ β times\nL∗\n... L∗\n0\n ,\nÑ =  0 ... 0 · · · 0 ... 0\n(N∗) > · · · (N∗)>︸ ︷︷ ︸ β times\nL∗\n... L∗\n0\n , (36)\nand S̃ = M̃ − L̃. A simple calculation shows that L̃ is incoherent with parameter √\n3µ, Ñ satisfies the assumption of Theorem 2 and S̃ satisfies the sparsity condition (S1) with parameter α√\n2 . Moreover the iterates\nof AltProj with input M̃ have similar expressions as in (36) in terms of the corresponding iterates with input M . This means that it suffices to obtain the same guarantees for Algorithm 1 for the symmetric case. Lemma 14 does precisely this, proving the theorem."
    }, {
      "heading" : "C Additional experimental results",
      "text" : "Synthetic datasets: Extending Figure 2, the plots in Figure 5 illustrate the point that soft thresholding, i.e., the convex relaxation approach, leads to intermediate solutions with high ranks. Figures 5 (a)-(b) show the variation of the maximum rank of the intermediate low-rank solutions of IALM with rank and incoherence respectively; the results are averaged over 5 runs of the algorithm; we note that as the problem becomes harder, the maximum intermediate rank via soft thresholding (convex approach) increases, and this leads to higher running times. As an example of this phenomenon, Figure 5 (c) shows the rank of the intermediate iterates of IALM for a particular run with n = 2000, r = 10, α = 100/n, µ = 3; here, while the rank of the final output is 10, intermediate iterates have a rank as high as 800. We run our synthetic simulations on a machine with Intel Dual 8-core Xeon (E5-2650) 2.0GHz CPU with 192GB RAM.\nReal-world datasets: We provide some additional results concerning foreground-background separation in videos 5. We compare NcRPCA with IALM, and also with the low-rank solution obtained using vanilla PCA; we report the solutions obtained by NcRPCA and IALM methods for decomposing M into L+S up to a relative error (‖M − L − S‖F /‖M‖F ) of 10−3. We report the rank and the sparsity of the solutions obtained by the two methods along with the computational time. As mentioned before, the observed matrix M is formed by\n5The datasets are available at http://perception.i2r.a-star.edu.sg/bk_model/bk_index.html\nvectorizing each frame and stacking them column-wise. For illustration purposes, we arbitrarily select one of the original frames in the sequence of image frames obtained from the video, i.e., one of the columns of M , and the corresponding columns in L and S obtained using NcRPCA and IALM. We run our real data experiments on a machine with Intel Dual 8-core Xeon (E5-2650) 2.0GHz CPU with 192GB RAM.\nShopping Mall dataset: Figure 6 shows the comparison of NcRPCA and IALM on the “Shopping Mall” dataset which has 1286 frames at a resolution of 256 × 320. NcRPCA achieves a solution of better visual quality (for example, unlike NcRPCA, notice the artifact of the low-rank solution from IALM in the top right corner of the image where the person is walking over the reflection of a light source; also notice the shadows of people in the low-rank part obtained by IALM which are not present in the low-rank solution obtained by NcRPCA), in 292.1s, compared to IALM, which takes 783.4s until convergence. NcRPCA obtains a rank 20 solution for L with ‖S‖0 = 95411896 whereas IALM obtains a rank 286 solution for L with ‖S‖0 = 86253965.\nCurtain dataset: We illustrate our recovery on one of the frames (frame 2773) wherein a person enters a room with a curtain on the background. Figure 7 shows the comparison of NcRPCA and IALM on the “Curtain” dataset which has 2964 frames at a resolution of 160× 128. NcRPCA achieves a solution, in 39.5s, which is of similar visual quality to that of IALM, which takes 989.0s until convergence. NcRPCA obtains a rank 1 solution for L with ‖S‖0 = 53897769 whereas IALM obtains a rank 701 solution for L with ‖S‖0 = 42310582."
    } ],
    "references" : [ {
      "title" : "Learning Sparsely Used Overcomplete Dictionaries via Alternating Minimization",
      "author" : [ "A. Agarwal", "A. Anandkumar", "P. Jain", "P. Netrapalli", "R. Tandon" ],
      "venue" : "Available on arXiv:1310.7991,",
      "citeRegEx" : "Agarwal et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Agarwal et al\\.",
      "year" : 2013
    }, {
      "title" : "Tensor Methods for Learning Latent Variable Models",
      "author" : [ "A. Anandkumar", "R. Ge", "D. Hsu", "S.M. Kakade", "M. Telgarsky" ],
      "venue" : "Available at arXiv:1210.7559,",
      "citeRegEx" : "Anandkumar et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Anandkumar et al\\.",
      "year" : 2012
    }, {
      "title" : "Noisy matrix decomposition via convex relaxation: Optimal rates in high dimensions",
      "author" : [ "A. Agarwal", "S. Negahban", "M. Wainwright" ],
      "venue" : "The Annals of Statistics,",
      "citeRegEx" : "Agarwal et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Agarwal et al\\.",
      "year" : 2012
    }, {
      "title" : "Incoherence-Optimal Matrix Completion",
      "author" : [ "Y. Chen" ],
      "venue" : "ArXiv e-prints,",
      "citeRegEx" : "Chen.,? \\Q2013\\E",
      "shortCiteRegEx" : "Chen.",
      "year" : 2013
    }, {
      "title" : "Robust principal component analysis",
      "author" : [ "Emmanuel J. Candès", "Xiaodong Li", "Yi Ma", "John Wright" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "Candès et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Candès et al\\.",
      "year" : 2011
    }, {
      "title" : "Rank-sparsity incoherence for matrix decomposition",
      "author" : [ "Venkat Chandrasekaran", "Sujay Sanghavi", "Pablo A. Parrilo", "Alan S. Willsky" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "Chandrasekaran et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Chandrasekaran et al\\.",
      "year" : 2011
    }, {
      "title" : "Clustering sparse graphs",
      "author" : [ "Yudong Chen", "Sujay Sanghavi", "Huan Xu" ],
      "venue" : "In Advances in neural information processing systems,",
      "citeRegEx" : "Chen et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2012
    }, {
      "title" : "Spectral statistics of Erdős–Rényi graphs I: Local semicircle law",
      "author" : [ "László Erdős", "Antti Knowles", "Horng-Tzer Yau", "Jun Yin" ],
      "venue" : "The Annals of Probability,",
      "citeRegEx" : "Erdős et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Erdős et al\\.",
      "year" : 2013
    }, {
      "title" : "On the provable convergence of alternating minimization for matrix completion",
      "author" : [ "Moritz Hardt" ],
      "venue" : null,
      "citeRegEx" : "Hardt.,? \\Q2013\\E",
      "shortCiteRegEx" : "Hardt.",
      "year" : 2013
    }, {
      "title" : "Robust matrix decomposition with sparse corruptions",
      "author" : [ "Daniel Hsu", "Sham M Kakade", "Tong Zhang" ],
      "venue" : "ITIT,",
      "citeRegEx" : "Hsu et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Hsu et al\\.",
      "year" : 2011
    }, {
      "title" : "Low-rank matrix completion using alternating minimization",
      "author" : [ "Prateek Jain", "Praneeth Netrapalli", "Sujay Sanghavi" ],
      "venue" : "In STOC,",
      "citeRegEx" : "Jain et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Jain et al\\.",
      "year" : 2013
    }, {
      "title" : "Matrix alps: Accelerated low rank and sparse matrix reconstruction",
      "author" : [ "Anastasios Kyrillidis", "Volkan Cevher" ],
      "venue" : "In SSP Workshop,",
      "citeRegEx" : "Kyrillidis and Cevher.,? \\Q2012\\E",
      "shortCiteRegEx" : "Kyrillidis and Cevher.",
      "year" : 2012
    }, {
      "title" : "Efficient algorithms for collaborative filtering",
      "author" : [ "Raghunandan H. Keshavan" ],
      "venue" : "Phd Thesis, Stanford University,",
      "citeRegEx" : "Keshavan.,? \\Q2012\\E",
      "shortCiteRegEx" : "Keshavan.",
      "year" : 2012
    }, {
      "title" : "The augmented lagrange multiplier method for exact recovery of corrupted low-rank matrices",
      "author" : [ "Zhouchen Lin", "Minming Chen", "Yi Ma" ],
      "venue" : null,
      "citeRegEx" : "Lin et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Lin et al\\.",
      "year" : 2010
    }, {
      "title" : "Statistical modeling of complex backgrounds for foreground object detection",
      "author" : [ "Liyuan Li", "Weimin Huang", "IY-H Gu", "Qi Tian" ],
      "venue" : "ITIP,",
      "citeRegEx" : "Li et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Li et al\\.",
      "year" : 2004
    }, {
      "title" : "Holistic 3d reconstruction of urban structures from low-rank textures",
      "author" : [ "Hossein Mobahi", "Zihan Zhou", "Allen Y. Yang", "Yi Ma" ],
      "venue" : "In ICCV Workshops,",
      "citeRegEx" : "Mobahi et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Mobahi et al\\.",
      "year" : 2011
    }, {
      "title" : "Phase retrieval using alternating minimization",
      "author" : [ "Praneeth Netrapalli", "Prateek Jain", "Sujay Sanghavi" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "Netrapalli et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Netrapalli et al\\.",
      "year" : 2013
    }, {
      "title" : "Guarantees for Stochastic ADMM in High Dimensions",
      "author" : [ "H. Sedghi", "A. Anandkumar", "E. Jonckheere" ],
      "venue" : null,
      "citeRegEx" : "Sedghi et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Sedghi et al\\.",
      "year" : 2014
    }, {
      "title" : "Sparse additive text models with low rank background",
      "author" : [ "Lei Shi" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Shi.,? \\Q2013\\E",
      "shortCiteRegEx" : "Shi.",
      "year" : 2013
    }, {
      "title" : "Solving multiple-block separable convex minimization problems using two-block alternating direction method of multipliers",
      "author" : [ "X. Wang", "M. Hong", "S. Ma", "Z. Luo" ],
      "venue" : null,
      "citeRegEx" : "Wang et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2013
    }, {
      "title" : "Robust pca via outlier pursuit",
      "author" : [ "Huan Xu", "Constantine Caramanis", "Sujay Sanghavi" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "Xu et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Xu et al\\.",
      "year" : 2012
    } ],
    "referenceMentions" : [ ],
    "year" : 2014,
    "abstractText" : "We propose a new method for robust PCA – the task of recovering a low-rank matrix from sparse corruptions that are of unknown value and support. Our method involves alternating between projecting appropriate residuals onto the set of low-rank matrices, and the set of sparse matrices; each projection is non-convex but easy to compute. In spite of this non-convexity, we establish exact recovery of the lowrank matrix, under the same conditions that are required by existing methods (which are based on convex optimization). For anm×n input matrix (m ≤ n), our method has a running time of O ( rmn ) per iteration, and needs O (log(1/ )) iterations to reach an accuracy of . This is close to the running times of simple PCA via the power method, which requires O (rmn) per iteration, and O (log(1/ )) iterations. In contrast, the existing methods for robust PCA, which are based on convex optimization, have O ( mn ) complexity per iteration, and take O (1/ ) iterations, i.e., exponentially more iterations for the same accuracy. Experiments on both synthetic and real data establishes the improved speed and accuracy of our method over existing convex implementations.",
    "creator" : "LaTeX with hyperref package"
  }
}