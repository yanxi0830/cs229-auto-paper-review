{
  "name" : "1410.8750.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Aravindan Vijayaraghavan" ],
    "emails" : [ "pawashti@cs.princeton.edu", "avrim@cs.cmu.edu", "osheffet@seas.harvard.edu", "vijayara@cims.nyu.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n41 0.\n87 50\nv1 [\ncs .L\nG ]\n3 1"
    }, {
      "heading" : "1 Introduction",
      "text" : "Probabilistic modeling of ranking data is an extensively studied problem with a rich body of past work [1, 2, 3, 4, 5, 6, 7, 8, 9]. Ranking using such models has applications in a variety of areas ranging from understanding user preferences in electoral systems and social choice theory, to more modern learning tasks in online web search, crowd-sourcing and recommendation systems. Traditionally, models for generating ranking data consider a homogeneous group of users with a central ranking (permutation) π∗ over a set of n elements or alternatives. (For instance, π∗ might correspond to a “ground-truth ranking” over a set of movies.) Each individual user generates her own ranking as a noisy version of this one central ranking and independently from other users. The most popular ranking model of choice is the Mallows model [1], where in addition to π∗ there is also a scaling parameter φ ∈ (0, 1). Each user picks her ranking π w.p. proportional to φdkt(π,π∗) where dkt(·) denotes the Kendall-Tau distance between permutations (see Section 2).1 We denote such a model as Mn(φ, π∗). The Mallows model and its generalizations have received much attention from the statistics, political science and machine learning communities, relating this probabilistic model to the long-studied work about voting and social choice [10, 11]. From a machine learning perspective, the problem is to find the parameters of the model — the central permutation π∗ and the scaling parameter φ, using independent samples from the distribution. There is a large body of work [4, 6, 5, 7, 12] providing efficient algorithms for learning the parameters of a Mallows model.\n∗This work was supported in part by NSF grants CCF-1101215, CCF-1116892, the Simons Institute, and a Simons Foundation Postdoctoral fellowhsip. Part of this work was performed while the 3rd author was at the Simons Institute for the Theory of Computing at the University of California, Berkeley and the 4th author was at CMU.\n1In fact, it was shown [1] that this model is the result of the following simple (inefficient) algorithm: rank every pair of elements randomly and independently s.t. with probability 1\n1+φ they agree with π∗ and with\nprobability φ 1+φ they don’t; if all ( n 2 ) pairs agree on a single ranking – output this ranking, otherwise resample.\nIn many scenarios, however, the population is heterogeneous with multiple groups of people, each with their own central ranking [2]. For instance, when ranking movies, the population may be divided into two groups corresponding to men and women; with men ranking movies with one underlying central permutation, and women ranking movies with another underlying central permutation. This naturally motivates the problem of learning a mixture of multiple Mallows models for rankings, a problem that has received significant attention [8, 13, 3, 4]. Heuristics like the EM algorithm have been applied to learn the model parameters of a mixture of Mallows models [8]. The problem has also been studied under distributional assumptions over the parameters, e.g. weights derived from a Dirichlet distribution [13]. However, unlike the case of a single Mallows model, algorithms with provable guarantees have remained elusive for this problem.\nIn this work we give the first polynomial time algorithm that provably learns a mixture of two Mallows models. The input to our algorithm consists of i.i.d random rankings (samples), with each ranking drawn with probability w1 from a Mallows model Mn(φ1, π1), and with probability w2(= 1− w1) from a different model Mn(φ2, π2). Informal Theorem. Given sufficiently many i.i.d samples drawn from a mixture of two Mallows models, we can learn the central permutations π1, π2 exactly and parameters φ1, φ2, w1, w2 up to ǫ-accuracy in time poly(n, (min{w1, w2})−1, 1φ1(1−φ1) , 1 φ2(1−φ2) , ǫ −1).\nIt is worth mentioning that, to the best of our knowledge, prior to this work even the question of identifiability was unresolved for a mixture of two Mallows models; given infinitely many i.i.d. samples generated from a mixture of two distinct Mallow models with parameters {w1, φ1, π1, w2, φ2, π2} (with π1 6= π2 or φ1 6= φ2), could there be a different set of parameters {w′1, φ′1, π′1, w′2, φ′2, π′2} which explains the data just as well. Our result shows that this is not the case and the mixture is uniquely identifiable given polynomially many samples.\nIntuition and a Naı̈ve First Attempt. It is evident that having access to sufficiently many random samples allows one to learn a single Mallows model. Let the elements in the permutations be denoted as {e1, e2, . . . , en}. In a single Mallows model, the probability of element ei going to position j (for j ∈ [n]) drops off exponentially as one goes farther from the true position of ei [12]. So by assigning each ei the most frequent position in our sample, we can find the central ranking π∗.\nThe above mentioned intuition suggests the following clustering based approach to learn a mixture of two Mallows models — look at the distribution of the positions where element ei appears. If the distribution has 2 clearly separated “peaks” then they will correspond to the positions of ei in the central permutations. Now, dividing the samples according to ei being ranked in a high or a low position is likely to give us two pure (or almost pure) subsamples, each one coming from a single Mallows model. We can then learn the individual models separately. More generally, this strategy works when the two underlying permutations π1 and π2 are far apart which can be formulated as a separation condition.2 Indeed, the above-mentioned intuition works only under strong separator conditions: otherwise, the observation regarding the distribution of positions of element ei is no longer true 3. For example, if π1 ranks ei in position k and π2 ranks ei in position k + 2, it is likely that the most frequent position of ei is k+1, which differs from ei’s position in either permutations!\nHandling arbitrary permutations. Learning mixture models under no separation requirements is a challenging task. To the best of our knowledge, the only polynomial time algorithm known is for the case of a mixture of a constant number of Gaussians [17, 18]. Other works, like the recent developments that use tensor based methods for learning mixture models without distance-based separation condition [19, 20, 21] still require non-degeneracy conditions and/or work for specific sub cases (e.g. spherical Gaussians).\nThese sophisticated tensor methods form a key component in our algorithm for learning a mixture of two Mallows models. This is non-trivial as learning over rankings poses challenges which are not present in other widely studied problems such as mixture of Gaussians. For the case of Gaussians, spectral techniques have been extremely successful [22, 16, 19, 21]. Such techniques rely on estimating the covariances and higher order moments in terms of the model parameters to detect structure and dependencies. On the other hand, in the mixture of Mallows models problem there is\n2Identifying a permutation π over n elements with a n-dimensional vector (π(i))i, this separation condition can be roughly stated as ‖π1 − π2‖∞ = Ω̃ ( (min{w1, w2})−1 · (min{log(1/φ1), log(1/φ2)}))−1 ) .\n3Much like how other mixture models are solvable under separation conditions, see [14, 15, 16].\nno “natural” notion of a second/third moment. A key contribution of our work is defining analogous notions of moments which can be represented succinctly in terms of the model parameters. As we later show, this allows us to use tensor based techniques to get a good starting solution.\nOverview of Techniques. One key difficulty in arguing about the Mallows model is the lack of closed form expressions for basic propositions like “the probability that the i-th element of π∗ is ranked in position j.” Our first observation is that the distribution of a given element appearing at the top, i.e. the first position, behaves nicely. Given an element e whose rank in the central ranking π∗ is i, the probability that a ranking sampled from a Mallows model ranks e as the first element is ∝ φi−1. A length n vector consisting of these probabilities is what we define as the first moment vector of the Mallows model. Clearly by sorting the coordinate of the first moment vector, one can recover the underlying central permutation and estimate φ. Going a step further, consider any two elements which are in positions i, j respectively in π∗. We show that the probability that a ranking sampled from a Mallows model ranks {i, j} in (any of the 2! possible ordering of) the first two positions is ∝ f(φ)φi+j−2. We call the n × n matrix of these probabilities as the second moment matrix of the model (analogous to the covariance matrix). Similarly, we define the 3rd moment tensor as the probability that any 3 elements appear in positions {1, 2, 3}. We show in the next section that in the case of a mixture of two Mallows models, the 3rd moment tensor defined this way has a rank-2 decomposition, with each rank-1 term corresponds to the first moment vector of each of two Mallows models. This motivates us to use tensor-based techniques to estimate the first moment vectors of the two Mallows models, thus learning the models’ parameters.\nThe above mentioned strategy would work if one had access to infinitely many samples from the mixture model. But notice that the probabilities in the first-moment vectors decay exponentially, so by using polynomially many samples we can only recover a prefix of length ∼ log1/φ n from both rankings. This forms the first part of our algorithm which outputs good estimates of the mixture weights, scaling parameters φ1, φ2 and prefixes of a certain size from both the rankings. Armed with w1, w2 and these two prefixes we next proceed to recover the full permutations π1 and π2. In order to do this, we take two new fresh batches of samples. On the first batch, we estimate the probability that element e appears in position j for all e and j. On the second batch, which is noticeably larger than the first, we estimate the probability that e appears in position j conditioned on a carefully chosen element e∗ appearing as the first element. We show that this conditioning is almost equivalent to sampling from the same mixture model but with rescaled weights w′1 and w ′ 2. The two estimations allow us to set a system of two linear equations in two variables: f (1) (e → j) – the probability of element e appearing in position j in π1, and f (2) (e → j) — the same probability for π2. Solving this linear system we find the position of e in each permutation.\nThe above description contains most of the core ideas involved in the algorithm. We need two additional components. First, notice that the 3rd moment tensor is not well defined for triplets (i, j, k), when i, j, k are not all distinct and hence cannot be estimated from sampled data. To get around this barrier we consider a random partition of our element-set into 3 disjoint subsets. The actual tensor we work with consists only of triplets (i, j, k) where the indices belong to different partitions. Secondly, we have to handle the case where tensor based-technique fails, i.e. when the 3rd moment tensor isn’t full-rank. This is a degenerate case. Typically, tensor based approaches for other problems cannot handle such degenerate cases. However, in the case of the Mallows mixture model, we show that such a degenerate case provides a lot of useful information about the problem. In particular, it must hold that φ1 ≃ φ2, and π1 and π2 are fairly close — one is almost a cyclic shift of the other. To show this we use a characterization of the when the tensor decomposition is unique (for tensors of rank 2), and we handle such degenerate cases separately. Altogether, we find the mixture model’s parameters with no non-degeneracy conditions.\nLower bound under the pairwise access model. Given that a single Mallows model can be learned using only pairwise comparisons, a very restricted access to each sample, it is natural to ask, “Is it possible to learn a mixture of Mallows models from pairwise queries?”. This next example shows that we cannot hope to do this even for a mixture of two Mallows models. Fix some φ and π and assume our sample is taken using mixing weights of w1 = w2 = 12 from the two Mallows modelsMn(φ, π) and Mn(φ, rev(π)), where rev(π) indicates the reverse permutation (the first element of π is the last of rev(π), the second is the next-to-last, etc.) . Consider two elements, e and e′. Using only pairwise comparisons, we have that it is just as likely to rank e > e′ as it is to rank e′ > e and so this case cannot be learned regardless of the sample size.\n3-wise queries. We would also like to stress that our algorithm does not need full access to the sampled rankings and instead will work with access to certain 3-wise queries. Observe that the first part of our algorithm, where we recover the top elements in each of the two central permutations, only uses access to the top 3 elements in each sample. In that sense, we replace the pairwise query “do you prefer e to e′?” with a 3-wise query: “what are your top 3 choices?” Furthermore, the second part of the algorithm (where we solve a set of 2 linear equations) can be altered to support 3-wise queries of the (admittedly, somewhat unnatural) form “if e∗ is your top choice, do you prefer e to e′?” For ease of exposition, we will assume full-access to the sampled rankings.\nFuture Directions. Several interesting directions come out of this work. A natural next step is to generalize our results to learn a mixture of k Mallows models for k > 2. We believe that most of these techniques can be extended to design algorithms that take poly(n, 1/ǫ)k time. It would also be interesting to get algorithms for learning a mixture of k Mallows models which run in time poly(k, n), perhaps in an appropriate smoothed analysis setting [23] or under other non-degeneracy assumptions. Perhaps, more importantly, our result indicates that tensor based methods which have been very popular for learning problems, might also be a powerful tool for tackling ranking-related problems in the fields of machine learning, voting and social choice.\nOrganization. In Section 2 we give the formal definition of the Mallow model and of the problem statement, as well as some useful facts about the Mallow model. Our algorithm and its numerous subroutines are detailed in Section 3. In Section 4 we experimentally compare our algorithm with a popular EM based approach for the problem. The complete details of our algorithms and proofs are included in the supplementary material."
    }, {
      "heading" : "2 Notations and Properties of the Mallows Model",
      "text" : "Let Un = {e1, e2, . . . , en} be a set of n distinct elements. We represent permutations over the elements in Un through their indices [n]. (E.g., π = (n, n − 1, . . . , 1) represents the permutation (en, en−1, . . . , e1).) Let posπ(ei) = π\n−1(i) refer to the position of ei in the permutation π. We omit the subscript π when the permutation π is clear from context. For any two permutations π, π′ we denote dkt(π, π′) as the Kendall-Tau distance [24] between them (number of pairwise inversions between π, π′). Given some φ ∈ (0, 1) we denote Zi(φ) = 1−φ i\n1−φ , and partition function Z[n](φ) =∑ π φ dkt(π,π0) = ∏n i=1 Zi(φ) (see Section 6 in the supplementary material). Definition 2.1. [Mallows model (Mn(φ, π0)).] Given a permutation π0 on [n] and a parameter φ ∈ (0, 1),4, a Mallows model is a permutation generation process that returns permutation π w.p.\nPr (π) = φdkt(π,π0)/Z[n](φ)\nIn Section 6 we show many useful properties of the Mallows model which we use repeatedly throughout this work. We believe that they provide an insight to Mallows model, and we advise the reader to go through them. We proceed with the main definition.\nDefinition 2.2. [Mallows Mixture model w1Mn(φ1, π1) ⊕ w2Mn(φ2, π2).] Given parameters w1, w2 ∈ (0, 1) s.t. w1 + w2 = 1, parameters φ1, φ2 ∈ (0, 1) and two permutations π1, π2, we call a mixture of two Mallows models to be the process that with probability w1 generates a permutation from M (φ1, π1) and with probability w2 generates a permutation from M (φ2, π2).\nOur next definition is crucial for our application of tensor decomposition techniques.\nDefinition 2.3. [Representative vectors.] The representative vector of a Mallows model is a vector where for every i ∈ [n], the ith-coordinate is φposπ(ei)−1/Zn. The expression φposπ(ei)−1/Zn is precisely the probability that a permutation generated by a model Mn(φ, π) ranks element ei at the first position (proof deferred to the supplementary material). Given that our focus is on learning a mixture of two Mallows models Mn(φ1, π1) and Mn(φ2, π2), we denote x as the representative vector of the first model, and y as the representative vector of the latter. Note that retrieving the vectors x and y exactly implies that we can learn the permutations π1 and π2 and the values of φ1, φ2.\n4It is also common to parameterize using β ∈ R+ where φ = e−β . For small β we have (1− φ) ≈ β.\nFinally, let f (i → j) be the probability that element ei goes to position j according to mixture model. Similarly f (1) (i → j) be the corresponding probabilities according to Mallows model M1 and M2 respectively. Hence, f (i → j) = w1f (1) (i → j) + w2f (2) (i → j). Tensors: Given two vectors u ∈ Rn1 , v ∈ Rn2 , we define u⊗v ∈ Rn1×n2 as the matrix uvT . Given also z ∈ Rn3 then u⊗v⊗z denotes the 3-tensor (of rank- 1) whose (i, j, k)-th coordinate is uivjzk. A tensor T ∈ Rn1×n2×n3 has a rank-r decomposition if T can be expressed as ∑ i∈[r] ui ⊗ vi ⊗ zi where ui ∈ Rn1 , vi ∈ Rn2 , zi ∈ Rn3 . Given two vectors u, v ∈ Rn, we use (u; v) to denote the n× 2 matrix that is obtained with u and v as columns. We now define first, second and third order statistics (frequencies) that serve as our proxies for the first, second and third order moments. Definition 2.4. [Moments] Given a Mallows mixture model, we denote for every i, j, k ∈ [n]\n• Pi = Pr (pos (ei) = 1) is the probability that element ei is ranked at the first position • Pij = Pr (pos ({ei, ej}) = {1, 2}), is the probability that ei, ej are ranked at the first two\npositions (in any order)\n• Pijk = Pr (pos ({ei, ej , ek}) = {1, 2, 3}) is the probability that ei, ej , ek are ranked at the first three positions (in any order).\nFor convenience, let P represent the set of quantities (Pi, Pij , Pijk)1≤i<j<k≤n. These can be estimated up to any inverse polynomial accuracy using only polynomial samples. The following simple, yet crucial lemma relates P to the vectors x and y, and demonstrates why these statistics and representative vectors are ideal for tensor decomposition. Lemma 2.5. Given a mixture w1M (φ1, π1)⊕ w2M (φ2, π2) let x, y and P be as defined above.\n1. For any i it holds that Pi = w1xi + w2yi.\n2. Denote c2(φ) = Zn(φ) Zn−1(φ) 1+φ φ . Then for any i 6= j it holds that Pij = w1c2(φ1)xixj +\nw2c2(φ2)yiyj .\n3. Denote c3(φ) = Z2n(φ) Zn−1(φ)Zn−2(φ) 1+2φ+2φ2+φ3\nφ3 . Then for any distinct i, j, k it holds that Pijk = w1c3(φ1)xixjxk + w2c3(φ2)yiyjyk.\nClearly, if i = j then Pij = 0, and if i, j, k are not all distinct then Pijk = 0.\nIn addition, in Lemma 13.2 in the supplementary material we prove the bounds c2(φ) = O(1/φ) and c3(φ) = O(φ−3).\nPartitioning Indices: Given a partition of [n] into Sa, Sb, Sc, let x(a), y(a) be the representative vectors x, y restricted to the indices (rows) in Sa (similarly for Sb, Sc). Then the 3-tensor\nT (abc) ≡ (Pijk)i∈Sa,j∈Sb,k∈Sc = w1c3(φ1)x(a) ⊗ x(b) ⊗ x(c) + w2c3(φ2)y(a) ⊗ y(b) ⊗ y(c). This tensor has a rank-2 decomposition, with one rank-1 term for each Mallows model. Finally for convenience we define the matrix M = (x; y), and similarly define the matrices Ma = (x(a); y(a)), Mb = (x (b); y(b)), Mc = (x(c); y(c)).\nError Dependency and Error Polynomials. Our algorithm gives an estimate of the parameters w, φ that we learn in the first stage, and we use these estimates to figure out the entire central rankings in the second stage. The following lemma essentially allows us to assume instead of estimations, we have access to the true values of w and φ.\nLemma 2.6. For every δ > 0 there exists a function f(n, φ, δ) s.t. for every n, φ and φ̂ satisfying |φ−φ̂| < δf(n,φ,δ) we have that the total-variation distance satisfies ‖M (φ, π)−M ( φ̂, π ) ‖TV ≤ δ.\nFor the ease of presentation, we do not optimize constants or polynomial factors in all parameters. In our analysis, we show how our algorithm is robust (in a polynomial sense) to errors in various statistics, to prove that we can learn with polynomial samples. However, the simplification when there are no errors (infinite samples) still carries many of the main ideas in the algorithm — this in fact shows the identifiability of the model, which was not known previously."
    }, {
      "heading" : "3 Algorithm Overview",
      "text" : "Algorithm 1 LEARN MIXTURES OF TWO MALLOWS MODELS, Input: a set S of N samples from w1M (φ1, π1)⊕ w2M (φ2, π2), Accuracy parameters ǫ, ǫ2.\n1. Let P̂ be the empirical estimate of P on samples in S . 2. Repeat O(log n) times:\n(a) Partition [n] randomly into Sa, Sb and Sc. Let T (abc) = ( P̂ijk ) i∈Sa,j∈Sb,k∈Sc . (b) Run TENSOR-DECOMP from [25, 26, 23] to get a decomposition of T (abc) = u(a) ⊗ u(b) ⊗ u(c) + v(a) ⊗ v(b) ⊗ v(c). (c) If min{σ2(u(a); v(a)), σ2(u(b); v(b)), σ2(u(c); v(c))} > ǫ2 (In the non-degenerate case these matrices are far from being rank-1 matrices in the sense that their least singular value is bounded away from 0.)\ni. Obtain parameter estimates (ŵ1, ŵ2, φ̂1, φ̂2 and prefixes of the central rankings π1′, π2′) from INFER-TOP-K(P̂ , M ′a , M ′ b , M ′ c), with M ′ i = (u\n(i); v(i)) for i ∈ {a, b, c}. ii. Use RECOVER-REST to find the full central rankings π̂1, π̂2.\nReturn SUCCESS and output (ŵ1, ŵ2, φ̂1, φ̂2, π̂1, π̂2).\n3. Run HANDLE DEGENERATE CASES (P̂ ).\nOur algorithm (Algorithm 1) has two main components. First we invoke a decomposition algorithm [25, 26, 23] over the tensor T (abc), and retrieve approximations of the two Mallows models’ representative vectors which in turn allow us to approximate the weight parameters w1, w2, scale parameters φ1, φ2, and the top few elements in each central ranking. We then use the inferred parameters to recover the entire rankings π1 and π2. Should the tensor-decomposition fail, we invoke a special procedure to handle such degenerate cases. Our algorithm has the following guarantee.\nTheorem 3.1. Let w1M (φ1, π1) ⊕ w2M (φ2, π2) be a mixture of two Mallows models and let wmin = min{w1, w2} and φmax = max{φ1, φ2} and similarly φmin = min{φ1, φ2}. Denote ǫ0 =\nw2min(1−φmax)10 16n22φ2max . Then, given any 0 < ǫ < ǫ0, suitably small ǫ2 = poly( 1n , ǫ, φmin, wmin)\nand N = poly ( n, 1min{ǫ,ǫ0} , 1 φ1(1−φ1) , 1 φ2(1−φ2) , 1 w1 , 1w2 ) i.i.d samples from the mixture model, Algorithm 1 recovers, in poly-time and with probability ≥ 1 − n−3, the model’s parameters with w1, w2, φ1, φ2 recovered up to ǫ-accuracy. Next we detail the various subroutines of the algorithm, and give an overview of the analysis for each subroutine. The full analysis is given in the supplementary material.\nThe TENSOR-DECOMP Procedure. This procedure is a straight-forward invocation of the algorithm detailed in [25, 26, 23]. This algorithm uses spectral methods to retrieve the two vectors generating the rank-2 tensor T (abc). This technique works when all factor matrices Ma = (x(a); y(a)),Mb = (x (b); y(b)),Mc = (x (c); y(c)) are well-conditioned. We note that any algorithm that decomposes non-symmetric tensors which have well-conditioned factor matrices, can be used as a black box.\nLemma 3.2 (Full rank case). In the conditions of Theorem 3.1, suppose our algorithm picks some partition Sa, Sb, Sc such that the matrices Ma,Mb,Mc are all well-conditioned — i.e. have σ2(Ma), σ2(Mb), σ2(Mc) ≥ ǫ′2 ≥ poly( 1n , ǫ, ǫ2, w1, w2) then with high probability, Algorithm TENSORDECOMP of [25] finds M ′a = (u (a); v(a)),M ′b = (u (b); v(b)),M ′c = (u (c); v(c)) such that for any τ ∈ {a, b, c}, we have u(τ) = ατx(τ) + z(τ)1 and v(τ) = βτy(τ) + z (τ) 2 ; with ‖z(τ)1 ‖, ‖z (τ) 2 ‖ ≤ poly( 1n , ǫ, ǫ2, wmin) and, σ2(M ′τ ) > ǫ2 for τ ∈ {a, b, c}.\nThe INFER-TOP-K procedure. This procedure uses the output of the tensor-decomposition to retrieve the weights, φ’s and the representative vectors. In order to convert u(a), u(b), u(c) into an approximation of x(a), x(b), x(c) (and similarly with v(a), v(b), v(c) and y(a), y(b), y(c)), we need to find a good approximation of the scalars αa, αb, αc. This is done by solving a certain linear system. This also allows us to estimate ŵ1, ŵ2. Given our approximation of x, it is easy to find φ1 and the top first elements of π1 — we sort the coordinates of x, setting π′1 to be the first elements in the sorted\nvector, and φ1 as the ratio between any two adjacent entries in the sorted vector. We refer the reader to Section 8 in the supplementary material for full details. The RECOVER-REST procedure. The algorithm for recovering the remaining entries of the central permutations (Algorithm 2) is more involved.\nAlgorithm 2 RECOVER-REST, Input: a set S of N samples from w1M (φ1, π1)⊕w2M (φ2, π2), parameters ŵ1, ŵ2, φ̂1, φ̂2 and initial permutations π̂1, π̂2, and accuracy parameter ǫ.\n1. For elements in π̂1 and π̂2, compute representative vectors x̂ and ŷ using estimates φ̂1 and φ̂2. 2. Let |π̂1| = r1, |π̂2| = r2 and wlog r1 ≥ r2.\nIf there exists an element ei such that posπ̂1(ei) > r1 and posπ̂2(ei) < r2/2 (or in the symmetric case), then: Let S1 be the subsample with ei ranked in the first position.\n(a) Learn a single Mallows model on S1 to find π̂1. Given π̂1 use dynamic programming to find π̂2 3. Let ei∗ be the first element in π̂1 having its probabilities of appearing in first place in π1 and π2 differ\nby at least ǫ. Define ŵ′1 = ( 1 + ŵ2\nŵ1\nŷ(ei∗ ) x̂(ei∗ )\n)−1 and ŵ′2 = 1− ŵ′1. Let S1 be the subsample with ei∗\nranked at the first position. 4. For each ei that doesn’t appear in either π̂1 or π̂2 and any possible position j it might belong to\n(a) Use S to estimate f̂i,j = Pr (ei goes to position j), and S1 to estimate f̂ (i → j|ei∗ → 1) = Pr (ei goes to position j|ei∗ 7→ 1).\n(b) Solve the system\nf̂ (i → j) = ŵ1f (1) (i → j) + ŵ2f (2) (i → j) (1) f̂ (i → j|ei∗ → 1) = ŵ′1f (1) (i → j) + ŵ′2f (2) (i → j) (2)\n5. To complete π̂1 assign each ei to position argmaxj{f (1) (i → j)}. Similarly complete π̂2 using f (2) (i → j). Return the two permutations.\nAlgorithm 2 first attempts to find a pivot — an element ei which appears at a fairly high rank in one permutation, yet does not appear in the other prefix π̂2. Let Eei be the event that a permutation ranks ei at the first position. As ei is a pivot, then PrM1 (Eei) is noticeable whereas PrM2 (Eei ) is negligible. Hence, conditioning on ei appearing at the first position leaves us with a subsample in which all sampled rankings are generated from the first model. This subsample allows us to easily retrieve the rest of π1. Given π1, the rest of π2 can be recovered using a dynamic programming procedure. Refer to the supplementary material for details.\nThe more interesting case is when no such pivot exists, i.e., when the two prefixes of π1 and π2 contain almost the same elements. Yet, since we invoke RECOVER-REST after successfully calling TENSOR-DECOMP , it must hold that the distance between the obtained representative vectors x̂ and ŷ is noticeably large. Hence some element ei∗ satisfies |x̂(ei∗) − ŷ(ei∗)| > ǫ, and we proceed by setting up a linear system. To find the complete rankings, we measure appropriate statistics to set up a system of linear equations to calculate f (1) (i → j) and f (2) (i → j) up to inverse polynomial accuracy. The largest of these values { f (1) (i → j) } corresponds to the position of ei in the central ranking of M1. To compute the values { f (r) (i → j)\n} r=1,2\nwe consider f (1) (i → j|ei∗ → 1) – the probability that ei is ranked at the jth position conditioned on the element ei∗ ranking first according to M1 (and resp. for M2). Using w′1 and w′2 as in Algorithm 2, it holds that\nPr (ei → j|ei∗ → 1) = w′1f (1) (i → j|ei∗ → 1) + w′2f (2) (i → j|ei∗ → 1) .\nWe need to relate f (r) (i → j|ei∗ → 1) to f (r) (i → j). Indeed Lemma 10.1 shows that Pr (ei → j|ei∗ → 1) is an almost linear equations in the two unknowns. We show that if ei∗ is ranked above ei in the central permutation, then for some small δ it holds that\nPr (ei → j|ei∗ → 1) = w′1f (1) (i → j) + w′2f (2) (i → j)± δ We refer the reader to Section 10 in the supplementary material for full details.\nThe HANDLE-DEGENERATE-CASES procedure. We call a mixture model w1M (φ1, π1) ⊕ w2M (φ2, π2) degenerate if the parameters of the two Mallows models are equal, and the edit distance between the prefixes of the two central rankings is at most two i.e., by changing the positions of at most two elements in π1 we retrieve π2. We show that unless w1M (φ1, π1)⊕w2M (φ2, π2) is degenerate, a random partition (Sa, Sb, Sc) is likely to satisfy the requirements of Lemma 3.2 (and TENSOR-DECOMP will be successful). Hence, if TENSOR-DECOMP repeatedly fail, we deduce our model is indeed degenerate. To show this, we characterize the uniqueness of decompositions of rank 2, along with some very useful properties of random partitions. In such degenerate cases, we find the two prefixes and then remove the elements in the prefixes from U , and recurse on the remaining elements. We refer the reader to Section 9 in the supplementary material for full details."
    }, {
      "heading" : "4 Experiments",
      "text" : "Goal. The main contribution of our paper is devising an algorithm that provably learns any mixture of two Mallows models. But could it be the case that the previously existing heuristics, even though they are unproven, still perform well in practice? We compare our algorithm to existing techniques, to see if, and under what settings our algorithm outperforms them.\nBaseline. We compare our algorithm to the popular EM based algorithm of [5], seeing as EM based heuristics are the most popular way to learn a mixture of Mallows models. The EM algorithm starts with a random guess for the two central permutations. At iteration t, EM maintains a guess as to the two Mallows models that generated the sample. First (expectation step) the algorithm assigns a weight to each ranking in our sample, where the weight of a ranking reflects the probability that it was generated from the first or the second of the current Mallows models. Then (the maximization step) the algorithm updates its guess of the models’ parameters based on a local search – minimizing the average distance to the weighted rankings in our sample. We comment that we implemented only the version of our algorithm that handles non-degenerate cases (more interesting case). In our experiment the two Mallows models had parameters φ1 6= φ2, so our setting was never degenerate. Setting. We ran both the algorithms on synthetic data comprising of rankings of size n = 10. The weights were sampled u.a.r from [0, 1], and the φ-parameters were sampled by sampling ln(1/φ) u.a.r from [0, 5]. For d ranging from 0 to ( n 2 ) we generated the two central rankings π1 and π2 to be within distance d in the following manner. π1 was always fixed as (1, 2, 3, . . . , 10). To describe π2, observe that it suffices to note the number of inversion between 1 and elements 2, 3, ..., 10; the number of inversions between 2 and 3, 4, ..., 10 and so on. So we picked u.a.r a non-negative integral solution to x1+ . . .+xn = d which yields a feasible permutation and let π2 be the permutation that it details. Using these models’ parameters, we generated N = 5 · 106 random samples. Evaluation Metric and Results. For each value of d, we ran both algorithms 20 times and counted the fraction of times on which they returned the true rankings that generated the sample. The results of the experiment for rankings of size n = 10 are in Table 1. Clearly, the closer the two centrals rankings are to one another, the worst EM performs. On the other hand, our algorithm is able to recover the true rankings even at very close distances. As the rankings get slightly farther, our algorithm recovers the true rankings all the time. We comment that similar performance was observed for other values of n as well. We also comment that our algorithm’s runtime was reasonable (less than 10 minutes on a 8-cores Intel x86 64 computer). Surprisingly, our implementation of the EM algorithm typically took much longer to run — due to the fact that it simply did not converge."
    }, {
      "heading" : "5 Acknowledgements",
      "text" : "We would like to thank Ariel Procaccia for bringing to our attention various references to Mallows model in social choice theory."
    }, {
      "heading" : "6 Properties of the Mallows Model",
      "text" : "In this section, we outline some of the properties of the Mallows model. Some of these properties were already shown before (see [27]), but we add them in this appendix for completion. Our algorithm and its analysis rely heavily on these properties.\nNotation. Given a Mallows model Mn (φ, π0) we denote Zn = 1−φ n\n1−φ , and we denote Z[n] as the\nsum all weights of all permutations: Z[n] = ∑ π φ dkt(π,π0). Given an element e, we abuse notation and denote by π \\e the permutation we get by omitting the element e (projecting π over all elements but e). The notation π = (e, σ) denotes a permutation whose first element is e and elements 2 through n are as given by the permutation over n− 1 elements σ. The first property shows that for any element e, conditioning on e being ranked at the first position results in a reduced Mallows model.\nLemma 6.1. Let M (φ, π) be a Mallows model over [n]. For any i, the conditional distribution (given that i is ranked at position 1) of rankings over [n] \\ {i}, i.e. Pr (π|π(i) = 1) is the same as that of M (φ, π \\ i).\nThe above lemma can be extended to conditioning on prefixes as follows.\nLemma 6.2. Let M (φ, π) be a Mallows model over [n]. For any prefix I of π, the marginal distribution of rankings over [n] \\ I is the same as that of M (φ, π \\ I).\nThe following lemma describe a useful trick that allows us to simulate the addition of another element that is added to the start of the central ranking π, using the knowledge of φ. This will be particularly useful to simplify certain degenerate cases.\nLemma 6.3. Let M (φ, π) be a Mallows model over [n]. Given oracle access to M (φ, π) and a new element e0 /∈ [n] we can efficiently simulate an oracle access to M (φ, (e0, π))."
    }, {
      "heading" : "6.1 Proofs of Lemmas 6.1, 6.2, 6.3",
      "text" : "Observation. All of the properties we state and prove in this appendix are based on the following important observation. Given two permutations π and π′, denote the first element in π as e1. Then we have that\n#pairs (e1, ei)i6=1 that π, π ′ disagree on = (position of e1 in π ′)− 1 = posπ′(e1)− 1 The same holds for the last element, denoted en, only using the distance between posπ′(en) and the nth-position (i.e., n− posπ′(en)). We begin by characterizing Z[n]. Property 6.4. For every n and any π0 ∈ Sn we have that Z[n] = ∑ π φ dkt(π,π0) =\n∏n i=1 Zi =∏\ni (∑i=1 j=0 φ j ) .\nProof. By induction on n. For n = 1 there’s a single permutation over the set {1} and Z1 = 1. For any n > 1, given a permutation over n elements π ∈ Sn, denote its first element as eπ. Based on our observation, we have that\ndkt(π, π0) = #swaps involving eπ + dkt(π \\ eπ, π0 \\ eπ) = (posπ0(eπ)− 1)+ dkt(π \\ eπ, π0 \\ eπ) And so we have\nZ[n] = ∑ π φ dkt(π,π0) =\nn∑\nj=1\n∑\n{π:eπ is the jth elements in π0} φdkt(π,π0)\n= n∑\nj=1\n∑\n{π:eπ is the jth elements in π0} φj−1φdkt(π\\eπ,π0\\eπ)\n=\nn−1∑\nj=0\nφj ∑\nπ∈Sn−1 φdkt(π,π\n−j 0 )\ninduction =\nn−1∑\nj=0\nφj\n( n−1∏\ni=1\nZi\n) = ( n−1∏\ni=1\nZi ) Zn = n∏\ni=1\nZi\nwhere π−j0 denotes the permutation we get by omitting the jth element from π0.\nObserve that the proof essentially shows how to generate a random ranking from a Mallows model. What we in fact showed is that the given a permutation π = (e, π \\ e) we have that\nPr[π] = 1Z[n]φ (posπ0 (e)−1)+dkt(π\\e,π0\\e) =\nφ(posπ0(e)−1)\nZn · φ\ndkt(π\\e,π0\\e)\nZ1:(n−1)\nAnd so, to generate a random permutation using π0: place the jth elements of π0 at the first position w.p. ∝ φj−1, and recourse over the truncated permutation. π0 \\e1 to find the rest of the permutation (positions 1, 2, . . . , j − 1, j + 1, . . . , n). This proves Lemma 6.1. Note the symmetry between π and π0 in defining the weight of π. Therefore, denoting e1 as the element π0 ranks at the first position, we have that\ndkt(π, π0) = #swaps involving e1 + dkt(π \\ e1, π0 \\ e1) = (i− 1) + dkt(π \\ e1, π0 \\ e1)\nand so, the probability of permutation π in which e1 is ranked at position j and the rest of the permutation is as a given permutation σ over n− 1 elements is:\nPr[π] = 1Z[n]φ (j−1)+dkt(π\\e1,π0\\e1) =\nφ(j−1)\nZn · φ\ndkt(π\\e1,π0\\e1)\nZ1:(n−1)\nSo, an alternative way to generate a random permutation using π0 is to rank element e1 at position j w.p. ∝ φj−1 and then to recourse over the truncated permutation π0 \\ e1. Repeating this argument for each element in a given prefix I of π0 proves Lemma 6.2.\nObserve that the algorithms the generate a permutation for a given Mallows model also allow us to simulate a random sample from a Mallows model over n + 1 elements. That is, given π0, we can introduce a new element e0 and denote π′0 = (e0, π0). Now, to sample from a Mallows model centered at π′0 all we need is to pick the position of e0 (moving it to position j w.p. φ\nj−1/Zn+1), then sampling from original Mallows model. This proves Lemma 6.3."
    }, {
      "heading" : "6.2 Total Variation Distance",
      "text" : "In this subsection, our goal is to prove Lemma 2.6. Namely, we aim to show that given φ, for every δ > 0 we can pick any φ̂ sufficiently close to φ, and have that the total variation distance between\nthe two models M (φ, π0) and M ( φ̂, π0 ) is at most δ.\nProof of Lemma 2.6. First, denote φ = e−β and φ̂ = e−β̂ . And so it holds that\n|β − β̂| = | ln(1/φ)− ln(1/φ̂)| = | ln(φ̂/φ)| ≤ | ln(1 + |φ−φ̂|φmin )| ≤ |φ−φ̂| φmin\nassuming some global lower bound φmin on φ, φ̂.\nObserve that for every π we have that\nφdkt(π,π0) = exp(−βdkt(π, π0)) = exp(−β̂dkt(π, π0)) exp(−(β−β̂)dkt(π, π0)) ≤ e 1 2n 2|β−β̂|φ̂dkt(π,π0)\nAlgorithm 3 LEARN MIXTURES OF TWO MALLOWS MODELS, Input: a set S of N samples from w1M (φ1, π1)⊕ w2M (φ2, π2), Accuracy parameters ǫ, ǫ2.\n1. Set threshold ǫ2 = f2(ǫ).\n2. Let P̂ be the empirical estimate of P on samples in S . 3. Run O(log n) times\n(a) Partition [n] randomly into Sa, Sb and Sc. (b) Set T (abc) = ( P̂ijk\n) i∈Sa,j∈Sb,k∈Sc .\n(c) Run TENSOR-DECOMP as in Theorem 4.2 of([25]) to get a decomposition of Tabc = u(a) ⊗ u(b) ⊗ u(c) + v(a) ⊗ v(b) ⊗ v(c). (d) Let M ′a = (u (a); v(a)), M ′b = (u (b); v(b)), M ′c = (u (c); v(c)). (e) If min(σ2(M ′a), σ2(M ′ b), σ2(M ′ c)) ≥ ǫ2,\ni. (ŵ1, ŵ2, φ̂1, φ̂2, π1′, π2′) ← INFER-TOP-K(P̂ , M ′a , M ′b , M ′c). ii. (π̂1, π̂2) ← RECOVER-REST(S,ŵ1, ŵ2, φ̂1, φ̂2, π1′, π2′ , ǫ2/ √ 2n).\nReturn SUCCESS and output (ŵ1, ŵ2, φ̂1, φ̂2, π̂1, π̂2). (f) Else if σ2(M ′a) < ǫ2 and σ2(M ′ b) ≥ ǫ2, and σ2(M ′c) ≥ ǫ2 (or other symmetric cases),\nlet p(a) = ( P̂i )\ni∈Sa .\nφ̂ ← ESTIMATE-PHI(p(a)). (g) Else φ̂ = median ( ESTIMATE-PHI(p(a)), ESTIMATE-PHI(p(b)), ESTIMATE-PHI(p(c)) ) .\n(h) Else, (at least two of the three matrices M ′a,M ′ b,M ′ c are essentially rank-1)\nlet τ ∈ {a, b, c} denote a matrix M ′τ s.t. σ2(M ′τ ) < ǫ2, and let p(τ) = (P̂i)i∈Sτ . φ̂ ← ESTIMATE-PHI(p(τ)).\n4. Run HANDLE-DEGENERATE-CASE(P̂ , φ̂, ǫ).\nSumming over all permutation (and replacing the role of φ and φ̂) we have also that ∑\nπ φ dkt(π,π0) ≥\ne− 1 2n 2|β−β̂| ∑ π φ̂ dkt(π,π0). Let pπ (resp. p̂π) denote the probability of sampling the permutation π\nfrom a Mallows model M (φ, π0) (resp. M ( φ̂, π0 ) ). It follows that for every π we have\npπ = φdkt(π,π0)∑ π′ φ dkt(π′,π0) ≤ en2|β−β̂| φ̂ dkt(π,π0) ∑ π′ φ̂ dkt(π′,π0) = en 2|β−β̂|p̂π\nand similarly, p̂π ≤ en 2|β−β̂|pπ.\nTherefore, assuming that |β − β̂| is sufficiently small, and using the fact that |1 − ex| ≤ 2|x| for x ∈ (− 12 , 12 ), then we have\n‖M (φ, π)−M ( φ̂, π ) ‖TV = 1\n2\n∑\nπ\n|pπ − p̂π|\n= 1\n2\n∑\nπ\npπ ∣∣∣∣1− p̂π pπ ∣∣∣∣ ≤ 1 2 ∑\nπ\n2pπn 2|β − β̂| = n\n2\nφmin |φ− φ̂|\nIt follows that in order to bound the total variation distance by δ we need to have φ and φ̂ close up to a factor of δ · φmin/n2."
    }, {
      "heading" : "7 Algorithm and Subroutines",
      "text" : "We now describe the algorithm and its subroutines in full detail. These will be followed by the analysis of the algorithms and proof of correctness in the following sections. Broadly speaking, our algorithm (Algorithm 1) has two main components.\nRetrieving the Top Elements and Parameters. In the first part we use spectral methods to recover elements which have a good chance of appearing in the first position. The algorithm tries\nAlgorithm 4 INFER-TOP-K, Input: P̂ ,M ′a = (u (a); v(a)),M ′b = (u (b); v(b)),M ′c = (u (c); v(c)).\n1. Let P̂a = P̂ (i ∈ a) 2. Set (αa, βa)T = (M ′a) † P̂a\n(αb, βb) T = (M ′b) † P̂b (αc, βc) T = (M ′c) † P̂c.\n3. Set ŵ1 = ‖αau(a)‖1 + ‖αbu(b)‖1 + ‖αcu(c)‖1, ŵ2 = 1− ŵ1. 4. Let u =\n( αa w1 u(a), αb w1 u(b), αc w1 u(c) ) .\nv = (\nβa w2 v(a), βb w2 v(b), βc w2\nv(c) ) .\n5. Sort the vectors u and v in decreasing order, i.e., U ←SORT(u), V ←SORT(v). 6. φ̂1 = U2U1 and φ̂2 = V2 V1 . 7. Define γ = (1− ˆφmax) 2\n4n ˆφmax . Let r1 = log1/φ̂1\n( n10\nw2minγ 2\n) and r2 = log1/φ̂2 ( n10\nw2minγ 2\n) .\n8. Output π′1 to be the first r1 ordered elements according to U and π ′ 2 to be the first r2 ordered elements\naccording to V .\nO(log n) different random partitions Sa, Sb, Sc, and constructs the tensor T (abc) from the samples as described in step 3(b). We then try to find a rank-2 decomposition of the tensor using a black-box algorithm for decomposing non-symmetric tensors. While we use the algorithm of [25] here, we can use the more practically efficient algorithm of Jennrich [23], or other power-iteration methods that are suitably modified to handle non-symmetric tensors.\nThese algorithms work when the factor matrices Ma,Mb,Mc have polynomially bounded condition number (in other words their second largest singular values σ2(·) is lower bounded by a polynomial in the input parameters) — in such cases the tensor T (abc) has a unique rank-2 decomposition. If this condition holds for any of the random partitions, then one can recover the top few elements of both π1 and π2 correctly. In addition, we can also infer the parameters w’s and φ’s to good accuracy ǫ (corresponding to INFER-TOP-K (Algorithm 4). This is detailed in section 8.\nIf any random partition Sa, Sb, Sc fails to produce a tensor T (abc) with well-conditioned factor matrices, then we are already in a special case. We show that in this case, the scaling parameters φ1 ≈ φ2 with high probability. We exploit the random choice of the partition to make this argument (see Lemma 9.1). However, we still need to find the top few elements of the permutations and the weights. If all these O(log n) random partitions fail, then we show that we are in the Degenerate case that we handle separately; we describe a little later. Otherwise, if at least one of the random partitions succeeds, then we have estimated the scaling parameters, the mixing weights and the top few elements of both permutations.\nRecovering Rest of the Elements. The second part of the algorithm (corresponding to RECOVERREST) takes the inferred parameters and the initial prefixes as input and uses this information to recover the entire rankings π1 and π2. This is done by observing that the probability of an element ei going to position j can be written as a weighted combination of the corresponding probabilities under π1 and π2. In addition, as mentioned in Section 2, the reduced distribution obtained by conditioning on a particular element ej going to position 1 is again a mixture of two Mallows models with the same parameters. Hence, by conditioning on a particular element which appears in the initial learned prefix, we get a system of linear equations which can be used to infer the probability of every other element ei going to position j in both π1 and π2. This will allow us to infer the entire rankings.\nDegenerate Cases. In the case when none of the random partition produces a tensor which has well-conditioned factor matrices (or alternately, a unique rank-2 decomposition), the instance is a very special instance, that we term degenerate. The additional subroutine (HANDLE-DEGENERATECASE) takes care of such degenerate instances. Before we do so, we introduce some notation to describe these degenerate cases.\nNotation. Define Lǫ = {ei : Pi ≥ ǫ}. If ǫ not stated explicitly L refers to L√ǫ where ǫ is the accuracy required in Theorem 3.1.\nNow we have the following definition that helps us formally define the degenerate case.\nDefinition 7.1 (Bucketing by relative positions). For every ℓ ∈ Z, let Bℓ = {ei ∈ L : posπ1(ei)− posπ2(ei) = ℓ}. Further let ℓ∗ be the majority bucket for the elements in L.\nWe call a mixture model w1M (φ1, π1) ⊕ w2M (φ2, π2) as degenerate if except for at most 2 elements, all the elements in L fall into the majority bucket. In other words, |ℓ∗| ≥ |L| − 2. Intuitively, in this case one of the partitions Sa, Sb, Sc constructed by the algorithm will have their corresponding u and v vectors as parallel to each other and hence the tensor method will fail. We show that when this happens, it can be detected and in fact this case provides useful information about the model parameters. More specifically, we show that in a degenerate case, φ1 will be almost equal to φ2 and the two rankings will be aligned in a couple of very special configurations (see Section 9). Procedure HANDLE-DEGENERATE-CASE is designed to recover the rankings in such scenarios."
    }, {
      "heading" : "8 Retrieving the Top elements",
      "text" : "Here we show how the first stage of the algorithm i.e. steps (a)-(e.i) manages to recover the top few elements of both rankings π1 and π2 and also estimate the parameters φ1, φ2, w1, w2 up to accuracy ǫ. We first show that if Ma,Mb,Mc have non-negligible minimum singular values (at least ǫ′2 as in Lemma 8.1), then the decomposition is unique, and hence we can recover the top few elements and parameters from INFER TOP-K. Otherwise, we show that if this procedure did not work for all O(log n) iterations, we are in the degenerate case (Lemma 9.1 and Lemma 9.6), and handle this separately.\nFor the sake of analysis, we denote by γmin the smallest length of the vectors in the partition i.e. γmin = minτ∈{a,b,c}min { ‖x(τ)‖, ‖y(τ)‖ } . Lemma 9.10 shows that with high probability γmin ≥ φC log nmin (1− φ) for some large constant C. The following lemma shows that when Ma,Mb,Mc are well-conditioned, Algorithm TENSORDECOMP finds a decomposition close to the true decomposition up to scaling. This Lemma essentially follows from the guarantees of the Tensor Decomposition algorithm in [25]. It also lets us conclude that σ2(M ′a), σ2(M ′ b), σ2(M ′ c) are all also large enough. Hence, these singular values of the matrices M ′a,M ′ b,M ′ c that we obtain from TENSOR-DECOMP algorithm can be tested to check if this step worked.\nLemma 8.1 (Decomposition guarantees). In the conditions of Theorem 3.1, suppose there exists a partition Sa, Sb, Sc such that the matrices Ma = (x(a); y(a)),Mb = (x(b); y(b)) and Mc = (x(c); y(c)) are well-conditioned i.e. σ2(Ma), σ2(Mb), σ2(Mc) ≥ ǫ′2, then with high probability, Algorithm TENSORDECOMP finds M ′a = (u (a); v(a)),M ′b = (u (b); v(b)),M ′c = (u\n(c); v(c)) such that\n1. For τ ∈ {a, b, c}, we have u(τ) = αax(τ) + z(τ)1 and v(τ) = βay(τ) + z (τ) 2 where\n‖z(τ)1 ‖, ‖z (τ) 2 ‖ ≤ ϑ8.1(n, ǫ, ǫ2, wmin)\n2. σ2(M ′a) ≥ γmin(ǫ′2 − ϑ8.1) (similarly for M ′b,M ′c).\nwhere ϑ8.1 is a polynomial function ϑ8.1 = min {√ ϑtensors(n, 1, κ = 1 ǫ2 , ǫsn3/2), γ4minwmin 4 } and ϑtensors is the error bound attained in Theorem 2.6 of [25].\nProof. Let ǫ′ = ϑ8.1. The entry-wise sampling error is ǫs ≤ 3 logn/ √ N . Hence, the rank-2 decomposition for T (abc) is n3/2ǫs close in Frobenius norm. We use the algorithm given in [25] to find a rank-2 decomposition of T (abc) that is O(ǫs) close in Frobenius norm. Further, the rank1 term u(a) ⊗ u(b) ⊗ u(c) is ǫ′2-close to w1c3(φ1)x(a) ⊗ x(b) ⊗ x(c). Let us renormalize so that ‖u(a)‖ = ‖u(b)‖ = ‖u(c)‖ ≥ w1/3min γmin.\nApplying Lemma 13.1, we see that u(a) = αax(a) + z (a) 1 where ‖z (a) 1 ‖ ≤ ǫ′, and similarly v(a) = βay (a) + z (a) 2 where ‖z2‖ ≤ ǫ′. Further w 1/3 min γminφ1/4 ≤ αa ≤ 1/γmin. Further\nσ2 ( αax (a);βay (a) ) ≥ min {αa, βa} σ2(Ma) ≥ w 1/3 min γminφ1\n4 σ2(Ma).\nHence, σ2(M ′a) ≥ w 1/3 min γminφ1σ2(Ma)/2−2ǫ′, as required. The same proof also works for M ′b,M ′c.\nInstead of using the enumeration algorithm of [25], the simultaneous eigen-decomposition algorithms in [23] and [26] can also be used. The only difference is that the “full-rank conditions” involving the Ma,Mb,Mc are checked in advance, using the empirical second moment. Note that TENSOR-DECOMP only relies on elements that have a non-negligible chance of appearing in the first position L: this can lead to large speedup for constant φ1, φ2 < 1 by restricting to a much smaller tensor.\nLemma 3.2 captures how Algorithm 1 (steps 3 (a - e.i)) performs the first stage using Algorithm 4 and recovers the weights w1, w2 and x, y when the factor matrices Ma,Mb,Mc are well-conditioned.\nIn the proof we show that in this case, for one of the O(log n) random partitions, Lemma 8.1 succeeds and recovers vectors u(a), v(a) which are essentially parallel to x(a) and y(a) respectively (similarly for u(b), u(c), v(b), v(c)). Sorting the entries of u(a) would give the relative ordering among those in Sa of the top few elements of π1. However, to figure out all the top-k elements, we need to figure out the correct scaling of u(a), u(b), u(c) to obtain x(a). This is done by setting up a linear system.\nNow we present the complete proof of the lemmas."
    }, {
      "heading" : "8.1 Proof of Lemma 3.2: the Full Rank Case",
      "text" : "If such a partition S∗a , S ∗ b , S ∗ c exists such that σ2(Ma) ≥ ǫ′2, then there exists a 2-by-2 submatrix of Ma corresponding to elements ei1 , ej1 which has σ2(·) ≥ ǫ′2. Similarly there exists such pairs of elements ei2 , ej2 and ei3 , ej3 in Sb andSc respectively. But with constant probability the random partition Sa, Sb, Sc has ei1 , ej1 ∈ Sa, ei2 , ej2 ∈ Sb, ei3 , ej3 ∈ Sc respectively. Hence in the O(log n) iterations, at least one iteration will produce sets Sa, Sb, Sc such that σ2(Ma), σ2(Mb), σ2(Mc) ≥ ǫ′2 with high probability. Further, Lemma 8.1 also ensures that σ2(M ′a), σ2(M ′ b), σ2(M ′ c) ≥ ǫ2.\nLemma 8.1 recovers vectors u(a), v(a) which are essentially parallel to x(a) and y(a) respectively (similarly for u(b), u(c), v(b), v(c)). While sorting the entries of u(a) would give the relative ordering among those in Sa of the top few elements of π1, we need to figure out the correct scaling of u(a), u(b), u(c) to recover the top few elements of π1.\nFrom Lemma 8.1, we can express\nw1x (a) = α′au (a) + z (a) 1 where z (a) 1 ⊥ u(a)where ‖z (a) 1 ‖ ≤ ϑ8.1(n, ǫs, ǫ′2).\nSimilarly w2y(a) = β′av (a) + z (a) 2 , where ‖z (a) 2 ‖ ≤ ϑ8.1. If ǫs is the sampling error for each entry in p(a), we have\n‖w1x(a) + w2x(b) − p(a)‖ < √ nǫs (3)\n‖α′au(a) + βv(a) − p(a)‖ < √ nǫs + 1\n2 w\n1/3 min φ1γminϑ8.1 (4)\nEq (4) allows us to define a set of linear equations with unknowns α′a, β ′ a, constraint matrix given by M ′a = (u (a); v(a)). Hence, the error in the values of α′a, β ′ a is bounded by the condition number of the system and the error in the values i.e.\nǫα ≤ κ(M ′a).w 1/3 min γminϑ8.1 ≤\n( 1\n4 w\n1/3 min φminγminǫ ′ 2 − ϑ8.1\n)−1 · φmin\n2 w\n1/3 min γminϑ8.1.\nThe same holds for αb, αc, βb, βc.\nAlgorithm 5 REMOVE-COMMON-PREFIX, Input: a set S of N samples from w1M (φ, π1) ⊕ w2M (φ, π2), ǫ.\n1. Initialize I ← ∅, S = [n]. 2. for t = 1 to n,\n(a) For each element x ∈ [n] \\ I , estimate p̂x,1 = Pr(x goes to position t). (b) Let xt = argmaxx∈[n]\\I p̂x,1. (c) If |p̂x,1 − 1Zn−t+1 | > ϑ(ǫ), return I and QUIT. (d) Else I ← I ∪ xt\n3. Output I .\nHowever, we also know that ‖x(a)‖1 + ‖x(b)‖1 + ‖x(c)‖1 = 1. Hence,\n|‖αau(a)‖1 + ‖αbu(b)‖1 + ‖αcu(c)‖1 − w1| ≤ ǫ ≤ 3 √ n(ǫα + ϑ8.1).\nThus, ŵ1, ŵ2 are within ǫ of w1, w2. Hence, we can recover vectors x by concatenating αa w1 u(a), αbw1u (b), αcw1u\n(c) (similarly y). Since we have ϑ8.1 < φ1(1 − φ)/wmin, it is easy to verify that by sorting the entries and taking the ratio of the top two entries, φ̂1 estimates φ1 up to error 2ϑ8.1φ1(1−φ1)\nwmin (similarly φ2). Finally, since we recovered x up to error ǫ′′ = 2ϑ8.1 wmin\n, we recovered the top m elements of π1 where m ≤ logφ1 (2ϑ8.1(1− φ1)/wmin)."
    }, {
      "heading" : "9 Degenerate Case",
      "text" : "While we know that we succeed when Ma,Mb,Mc have non-negligible minimum singular value for one of the the O(log n) random partitions, we will now understand when this does not happen. Recollect that L = L√ǫ = {ei : Pi ≥ √ ǫ}. For every ℓ ∈ Z, let Bℓ ={\nei ∈ L : π−11 (i)− π−12 (i) = ℓ }\n. Further let ℓ∗ be the majority bucket for the elements in L. We call a mixture model w1M (φ1, π1)⊕w2M (φ2, π2) as degenerate if the parameters of the two Mallows models are equal, and except for at most 2 elements, all the elements in L fall into the majority bucket. In other words, |ℓ∗| ≥ |L| − 2. We first show that if the tensor method fails, then the parameters of the two models φ1 and φ2 are essentially the same. Further, we show how the algorithm finds this parameter as well.\nLemma 9.1 (Equal parameters). In the notation of the Algorithm 1, for any ǫ′ > 0, suppose σ2(M ′ a) < ǫ2 ≤ ϑ9.1(n, ǫ′, wmin, φ1, φ2) (or M ′b,M ′c), then with high probability (1 − 1/n3), we have that |φ1 − φ2| ≤ ǫ′ and further Algorithm 9 (ESTIMATE-PHI) finds |φ̂ − φ1| ≤ ǫ′/2. The number of samples needed N > poly(n, 1ǫ′ ).\nThis lemma is proven algorithmically. We first show that Algorithm 9 finds a good estimate φ̂ of φ1. However, by the same argument φ̂ will also be a good estimate of φ2! Since φ̂ will be ǫ′/2-close to both φ1 and φ2, this will imply that |φ1 − φ2| ≤ ǫ′ ! We prove this formally in the next section. But first, we first characterize when the tensor T (abc) does not have a unique decomposition — this characterization of uniqueness of rank-2 tensors will be crucial in establishing that φ1 ≈ φ2.\n9.1 Characterizing the Rank and Uniqueness of tensor T (abc) based on Ma,Mb,Mc\nTo establish Lemma 9.1, we need the following simple lemma, which establishes that the conditioning of the matrices output by the Algorithm TensorDecomp is related to the conditioning of the parameter matrices Ma,Mb,Mc. Lemma 9.2 (Rank-2 components). Suppose we have sets of vectors (gi, hi, g′i, h ′ i)i=1,2,3 with length at most one (‖ · ‖2 ≤ 1) such that T = g1 ⊗ g2 ⊗ g3 + h1 ⊗ h2 ⊗ h3 and ‖T − g′1 ⊗ g′2 ⊗ g′3 + h′1 ⊗ h′2 ⊗ h′3‖ ≤ ǫs\nsuch that matrices have minimum singular value σ2 ( g1;h1 ) , σ2 ( g2;h2 ) ≥ λ and ‖g3‖, ‖h3‖ ≥\nγmin, then we have that for matrices M ′1 = ( g′1;h ′ 1 ) ,M ′2 = ( g′2;h ′ 2 )\nσ2(M ′ 1) ≥ λ2γmin 4n − ǫs and σ2(M ′1) ≥ λ2γmin 4n − ǫs.\nProof. Let matrices M1 = ( g1;h1 ) ,M2 = ( g2;h2 ) . For a unit vector w (of appropriate dimension) let\nMw = T (·, ·, w) = 〈w, g3〉g1 ⊗ g2 + 〈w, h3〉h1 ⊗ h2\n= M1DwM T 2 where Dw =\n( 〈w, g3〉 0\n0 〈w, h3〉\n) .\nBesides, since w is a random gaussian unit vector,Pr|〈w, g3〉| ≥ ‖g3‖/4 √ n with probability> 1/2.\nHence, using there exists a unit vector w such that min{|〈w, g3〉|, |〈w, h3〉|} ≥ γmin/(4 √ n). Hence,\nσ2(Mw) ≥ λ2γmin 4 √ n .\nHowever, ‖Mw −M ′1D′w(M ′2)T ‖F ≤ ǫs where D′w = ( 〈w, g′3〉 0\n0 〈w, h′3〉\n) .\nHence, σ2 ( M ′1D ′ w(M ′ 2) T ) ≥ σ2(Mw)− ǫs.\nCombining this with the fact that σ2 ( M ′1D ′ w(M ′ 2) T )\n≤ σ2(M ′1)σ1(D′w)σ1(M ′2) gives us the claimed bound.\nThis immediately implies the following lemma in the contrapositive.\nLemma 9.3 (Rank-1 components). Suppose σ2(M ′a) < ǫ and σ2(M ′ b) < ǫ, then two of the matrices\nMa,Mb,Mc have σ2(·) < √\n8ǫn γmin , when the number of samples N > poly(n, 1/ǫ)."
    }, {
      "heading" : "9.2 Equal Scaling Parameters",
      "text" : "The following simple properties of our random partition will be crucial for our algorithm.\nLemma 9.4. The random partition of [m] into A,B,C satisfies with high probability (at least 1− exp ( − 1C9.4 ·m ) ):\n1. |A|, |B|, |C| ≥ m/6\n2. There are many consecutive numbers in each of the three sets A,B,C i.e.\n|{i ∈ A and i+ 1 ∈ A}| ≥ m/100.\nProof. The claimed bounds follow by a simple application of Chernoff Bounds, since each element is chosen in A with probability 1/3 independently at random. The second part follows by considering the m/2 disjoint consecutive pairs of elements, and observing that each pair fall entirely into A with probability 1/9.\nLemma 9.5. Consider a set of indices S ⊆ [n] and let pS be the true probability vector p of a single Mallows model M(π, φ) restricted to subset S. Suppose the empirical vector ‖p̂S−pS‖∞ < ǫ1, and there exists consecutive elements of π in S i.e. ∃i such that π(i), π(i + 1) ∈ S, with p(π(i + 1)) ≥√ ǫ1. Then, if we arrange the entries of pS in decreasing order as r1, r2, . . . , r|S| we have that\nφ̂ = max i:ri+1≥ √ ǫ1 ri+1 ri satisfies |φ̂− φ| < 2√ǫ1.\nProof. By the properties of the Mallows model, the ratio of any two probabilities is a power of φ i.e.\npℓ2 pℓ1\n= φπ −1(ℓ2)−π−1(ℓ1). If p(π(i + 1)) ≥ √ǫ1, we have that\np̂(π(i + 1)) p̂(π(i)) ≤ φ · p(π(i)) + ǫ1 p(π(i))− ǫ1\n≤ φ+ φ (p(π(i))− p̂(π(i)) + ǫ1) p̂(φ(i)) ≤ φ+ ǫ1 (1 + φ) p̂(φ(i)) ≤ φ+ 2√ǫ1\nThe same proof holds for the lower bound.\nWe now proceed to showing that the scaling parameters are equal algorithmically.\nProof of Lemma 9.1. We now proceed to prove that φ1 ≈ φ2. We note that ‖T (abc)‖F ≤ 1 since the entries of T (abc) correspond to probabilities, and for any vector z, ‖z‖2 ≤ ‖z‖1. This implies that all the vectors in the decomposition can be assumed to have ℓ2 norm at most 1, without loss of generality. We can first conclude that at least one of the three matrices Ma,Mb,Mc has σ2(·) <√\n8nǫ2 γminwmin . Otherwise, we get a contradiction by applying Lemma 9.2 (contrapositive) to M ′a,M ′ b and M ′a,M ′ c. Now, we will show how the algorithm gives an accurate estimate φ̂ of φ1. However the exact argument applied to φ2 will show that φ̂ is also a good estimate for φ2, implying that φ1 ≈ φ2. We have two cases depending on whether one of σ2(M ′b) and σ2(M ′ c) are non-negligible or not.\nCase 1: σ2(M ′b) ≥ (ǫ 1/4 2 8n γminwmin )3/4) and σ2(M ′c) ≥ (ǫ 1/4 2 8n γminwmin )3/4): Applying Lemma 9.2, we conclude that σ2(Mb) ≥ ǫ1/22 (8n/γminwmin)1/2 and σ2(Mc) ≥ ǫ 1/2 2 ( 8n γminwmin )1/2. However one of the matrices Ma,Mb,Mc has small σ2 value. Hence\nσ2(Ma) < ǫ 1/2 2\n( 8n\nγminwmin\n)1/2 = ǫ′2 (say).\nLet y(a) = αx(a) + y⊥ where y⊥ ⊥ x(a). Then ‖y⊥‖ ≤ ǫ′2 and α ≥ (‖y(a)‖−ǫ′2)\n‖x(a)‖ ≥ γmin/2. Further, p(a) = (w1 + w2α)x(a) + w2y⊥. Hence,\nx(a) = βp(a) − w2βy⊥, where 0 ≤ β < 2\nγmin .\nSince the sampling error is ǫs, we have\nx(a) = βp̂(a) + β(p(a) − p̂(a))− w2βy⊥\n= βp̂(a) + z where ‖z‖∞ ≤ β(ǫs + ǫ′2) ≤ 4ǫ2 γmin = ǫ3\nConsider the first m = C9.4 logn elements F of π1.\n∀i ∈ F, xi ≥ φ C9.4 logn 1\n1− φ1 ≥ n\nC9.4 log(1/φ1)\n1− φ1 ≥ √ǫ3 due to our choice of error parameters\nApplying Lemma 9.4, Ω(logn) consecutive elements of π1 occur in Sa. Hence applying Lemma 9.5, we see that the estimate φ̂ output by the algorithm satisfies |φ̂ − φ1| ≤ 2 √ ǫ3 = 16ǫ 1/4 2 n 1/4\nγ 3/4 min w 1/4 min\n, as\nrequired.\nCase 2: σ2(M ′b) < (ǫ 1/4 2 8n γminwmin )3/4): We also know that σ2(M ′a) < ǫ2. Applying Lemma 9.3, we see that two of the three matrices Ma,Mb,Mc have σ2(·) being negligible i.e.\nσ2(·) < ǫ1/42 ( 8n\nγminwmin\n)7/8 .\nAlgorithm 6 HANDLE-DEGENERATE, Input: a set S of N samples from w1M (φ1, π1) ⊕ w2M (φ2, π2), φ̂.\n1. πpfx ← REMOVE-COMMON-PREFIX(S ). Let πrem1 = π1 \\ πpfx, πrem2 = π2 \\ πpfx. 2. If |πpfx| = n, then output IDENTICAL MALLOWS MODELS and parameters φ̂ and πpfx. 3. Let M′ be the Mallows mixture obtained by adding three artificial elements e∗1, e∗2, e∗3 to the front. 4. Run steps (1-3) of Algorithm 1 on M′. If SUCCESS, output ŵ1, ŵ2, π1, π2, φ̂. 5. If FAIL, let P̂ (i), P̂ (i, j) be the estimates of P (i), P (i, j) when samples according to M′. 6. Divide elements in L√ǫ into R ≤ log(ǫZn(φ̂))2 log(φ̂) disjoint sets\nIr =\n{ i : P̂ (i) ∈ [ φ̂r\nZn(φ̂) − ǫ, φ̂\nr\nZn(φ̂) + ǫ\n]}\n.\n7. If |Ir| = 1 set πrem1 (i) to be the only element in Ir. 8. Let Ibad be the remaining elements in the sets I1 ∪ I2 . . . IR along with L√ǫ \\ ⋃ r Ir . If |Ibad| > 4\nor |Ibad| < 2, output FAIL. 9. Let Sa, Sb is any partition of I1 ∪ I2 ∪ IR \\ Ibad.\nFind i1, j1 ∈ Ibad such that M = ( P̂ij )\ni∈Sa∪{i1},Sb∪{j1} has σ2(M) ≥\n√ ǫn.\n10. For i ∈ Ibad \\ {i1, j1} and i ∈ Ir, set πrem1 (r) = πrem2 (r) = i. Set πrem1 (1) = i1, π rem 2 (1) = j1, and π rem 1 (k) = j1, π rem 2 (k) = i1 where k ≤ R is unfilled\nposition.\n11. Output π1 = πpfx ◦ πrem1 , π2 = πpfx ◦ πpfx2 , φ̂. Output ŵ1, ŵ2 = 1− ŵ1, by solving for ŵ1 from P̂ (i) = ŵ1π−11 (i) + (1− ŵ1)π−12 (i).\nUsing the same argument as in the previous case, we see that the estimates given by two of the three partitions Sa, Sb, Sc is 2 √ ǫ3 close to the φ1. Hence the median value φ̂ of these estimates is also as close. As stated before, applying the same argument for φ2 (and π2) , we see that φ̂ is 2 √ ǫ3 close to φ2 as\nwell. Hence, φ1 is 4 √ ǫ3 close to φ1."
    }, {
      "heading" : "9.3 Establishing Degeneracy",
      "text" : "Next, we establish that if none of the O(log n) rounds were successful, then the two central permutations (restricted to the top O(log1/φmin n) positions) are essentially the same shifted by at most a couple of elements.\nLemma 9.6. Consider the large elements L√ǫ. Suppose |Bℓ∗| ≥ |L√ǫ| − 3, then the one of the O(log n) rounds of the Tensor Algorithm succeeds with high probability.\nProof. We have two cases depending on whether ℓ∗ ≤ log(ǫ)/ log(φ) or not. Suppose |ℓ∗| ≤ log(ǫ(1 − φ))/ log(φ). Let i, j, k be the indices of elements in L√ǫ that are not in Bℓ∗ . With constant probability the random partition Sa, Sb, Sc puts these three elements in different partitions. In that case, by applying Lemma 9.11 we see that σ2(Ma), σ2(Mb), σ2(Mc) ≥ ǫ2(1 − φ)2. Hence, Lemma 3.2 would have succeeded with high probability.\nSuppose |ℓ∗| > log(ǫ(1 − φ))/ log(φ). Assume without loss of generality that ℓ∗ ≥ 0. Consider the first three elements of π2. They can not belong to Bℓ∗ since ℓ∗ > 3. Hence, by pairing each of these elements with some three elements of Bℓ∗, and repeating the previous argument we get that σ2(Ma), σ2(Mb), σ2(Mc) ≥ ǫ2(1 − φ)2 in one of the iterations w.h.p. Hence, Lemma 3.2 would have succeeded with high probability.\nHence we now have two kinds of degenerate cases to deal with. The next two lemmas show how such cases are handled.\nLemma 9.7 (Staggered degenerate case). Suppose φ = φ1 = φ2, and at most two of the top elements L√ǫ are not in bucket Bℓ∗ i.e. Bℓ∗ ≥ L√ǫ − 2 with ℓ∗ 6= 0. Then, for any ǫ > 0, given N > poly(n, φ, ǫ, wmin) samples, step (3-4) of Algorithm HANDLE-DEGENERATE finds finds ŵ1, ŵ2 of w1, w2 up to ǫ accuracy and the top m elements of π1, π2 respectively where m = logZn(ǫ) 2 log φ .\nProof. Since φ1 = φ2, we can use Lemma 6.3, we can sample from a Mallows mixture where we add one new element e∗3 to the front of both permutations π1, π2. Doing this two more times we can sample from a Mallows mixture where we add e∗1, e ∗ 2, e ∗ 3 to the front of both permutations. Let these new concatenated permutations be π∗1 , π ∗ 2 . Since the majority bucket corresponds to ℓ\n∗ 6= 0, we have at least three pairs of elements which satisfy Lemma 9.11, we see that w.h.p. in one of the O(log n) iterations, the partitions Sa, Sb, Sc have σ2(·) ≥ (γminφ6)2(1 − φ)3. Hence, by using the Tensor algorithm with guarantees from Lemma 3.2, and using Algorithm RECOVER-REST, we get the full rankings as required (using Lemma 10.2).\nLemma 9.8 (Aligned Degenerate case). Suppose φ = φ1 = φ2, and at most two of the top elements L√ǫ are not in bucket B0 i.e. |B0| ≥ |L√ǫ|−2. For any ǫ > 0, given N = O( n\n2 logn ǫ8w2min(1−φ)4 ) samples,\nsteps (5-10) of Algorithm 6 (HANDLE-DEGENERATE) finds estimates ŵ1, ŵ2 up to ǫ accuracy and prefixes π′1, π ′ 2 of π1, π2 respectively that contain at least the top m elements where m = logZn(ǫ) 2 logφ .\nProof. The first position differs because of step(1-2) of Algorithm 6. Without loss of generality π1 = π pfx 1 and π2 = π pfx 2 . B0 ≥ m − 2, hence |B0| = m − 2. Let ei1 , ej1 be the other two elements in L√ǫ.\nFor elements ei ∈ B0, π−11 (i) = π−12 (i). The sampling error in the entries of P̂ is at most ǫs = ǫ4wmin(1 − φ)2/n. Hence, they fall into the set Iπ−11 (i). Therefore, there can be at most four sets with at most four elements between them that constitute Ibad.\nConsider M = (P̂ij)i∈Sa∪{i1},j∈Sb∪{j1}. Also let Ma = (x (a); y(a)) and Mb = (x(a); y(a)) applied to M′. By Lemma 9.11, we see that σ2(Ma), σ2(Mb) ≥ ǫ(1− φ). Further,\n‖M −Ma ( w1 0 0 w2 ) MTb ‖F ≤ ǫsn.\nHence, σ2(M) ≥ ǫ2(1− φ)2wmin. If i1, j1 do not belong to the two different partitions Sa, Sb, it is easy to see that σ2(M) ≤ √ ǫs > ǫ\n2wmin(1 − φ)2. Hence, we identify the two irregular elements that are not in bucket B0, and use this to figure out the rest of the permutations.\nFinally, the following lemma shows how the degenerate cases are handled.\nLemma 9.9. For 0 < ǫ, given φ1, φ2 with |φ1 − φ2| ≤ ǫ1 = ϑ9.9(n, φ, ǫ, wmin), such that at most two elements of L√ǫ are not in the bucket Bℓ∗ , then Algorithm HANDLE-DEGENERATE finds w.h.p. estimates ŵ1, ŵ2 of w1, w2 up to ǫ accuracy, and recovers π1, π2.\nProof. We can just consider the case φ̂ = φ̂1 = φ2 using Lemma 2.6 as long as ǫ1 < φ\nn2N(n,φ,ǫ)2 , where N is the number of samples used by Lemma 9.8 and Lemma 9.7 to recover the rest of the permutations and parameters up to error ǫ. This is because the simulation oracle does not fail on any of the samples w.h.p, by a simple union bound.\nIf the two permutations do not differ at all, then by Lemma 10.6, Algorithm 5 returns the whole permutation π1 = π2. Further, any set of weights can be used since both are identical models (φ1 = φ2 = φ).\nLet m = L√ǫ. In the remaining mixture M′, the first position of the two permutations differ: hence, Bℓ∗ < m. Further, we know that Bℓ∗ ≥ m− 2. We have two cases, depending on whether the majority bucket Bℓ∗ corresponds to ℓ∗ = 0 or ℓ∗ 6= 0. In the first case, Lemma 9.7 shows that we find the permutations π1, π2 and parameters up to\naccuracy ǫ. If this FAILS, we are in the case ℓ∗ = 0, and hence Lemma 9.8 shows that we find the permutations π1, π2 and parameters up to accuracy ǫ."
    }, {
      "heading" : "9.4 Auxiliary Lemmas for Degenerate Case",
      "text" : "Lemma 9.10. For any Mallows model with parameters φ1, φ2 has\nγmin = min τ∈{a,b,c}\nmin { ‖x(τ)‖, ‖y(τ)‖ } ≥ min { φ2C logn1 (1− φ1), φ2C logn2 (1 − φ2) } with probability 1−nC\nProof. Consider a partition A, and the top m ≥ 2C logn elements according to π. The probability that none of the them belong to A is at most 1/nC . This easily gives the required conclusion.\nLemma 9.11. When φ1 = φ2 = φ, if two large elements ei, ej ∈ L√ǫ belonging to different buckets Bℓ1 and Bℓ2 respectively with max {|ℓ1|, |ℓ2|} ≤ log(ǫ)log(φ) . Suppose further that these elements are in the partition Sa. Then the corresponding matrix Ma has σ2(Ma) ≥ ǫ2(1− φ) when φ1 = φ2 = φ.\nProof. Consider the submatrix\nM = ( xi yi xj yj ) = xi ( 1 φℓ1 φπ −1 1 (i)−π −1 1 (j) φπ −1 1 (i)−π −1 1 (j) · φℓ2 ) .\nUsing a simple determinant bound, it is easy to see that\nσ1(M)σ2(M) ≥ max {xi, yi}max {xj , yj}·(φ|ℓ1|−φ|ℓ2|) ≥ max {xi, yi}·ǫφmin{|ℓ1|,|ℓ2|}(1−φ).\nSince σ1(M) ≤ 4maxxi, yi, we see that σ2(M) ≥ ǫ 2(1−φ)\n4 ."
    }, {
      "heading" : "10 Recovering the complete rankings",
      "text" : "Let f (1) (i → j) be the probability that element ei goes to position j according to Mallows Model M1 (and similarly f (2) (i → j) for model M2). To find the complete rankings, we measure appropriate statistics to set up a system of linear equations to calculate f (1) (i → j) and f (2) (i → j) up to inverse polynomial accuracy. The largest of these values { f (1) (i → j) } corresponds to the position of ei in the central ranking of M (,1). To compute these values { f (r) (i → j) } r=1,2\nwe consider statistics of the form “what is the probability that ei goes to position j conditioned on ei∗ going to the first position?”. This statistic is related to f (1) (i → j) , f (2) (i → j) for element ei∗ that is much closer than ei to the front of one of the permutations.\nNotation: Let fM (i → j) be the probability that element ei goes to position j according to Mallows Model M, and let f (r) (i → j) be the same probability for the Mallows model Mr (r ∈ {1, 2}). Let f (1) (i → j|ei∗ → 1) be the probability that ei goes to the jth position conditioned on the element ei∗ going to the first position according to M1 (similarly M (,2)). Finally for any Mallows model M (φ, π), and any element ei∗ ∈ pi, let M−i∗ represent the Mallows model on n − 1 elements M (φ, π − i∗). In the notation defined above, we have that for any elements ei∗ , ei and position j, we have\nPr (ei → j|ei∗ → 1) = w′1f (1) (i → j|ei∗ → 1) + w′2f (2) (i → j|ei∗ → 1) where w′1 =\nw1xi∗ w1xi∗ + w2yi∗ , w′2 = 1− w′1\nHowever, these statistics are not in terms of the unknown variables f (1) (i → j) , f (2) (i → j). The following lemma shows that these statistics are almost linear equations in the unknowns f (1) (i → j) , f (2) (i → j) for the i, j pairs that we care about. For threshold δ, let r1 be the smallest number r such that δ > φr−11 /Zn(φ1). Similarly let r2 be the corresponding number for second Mallows models M2.\nAlgorithm 7 RECOVER-REST, Input: a set S of N samples from w1M (φ1, π1)⊕w2M (φ2, π2), ŵ1, ŵ2, φ̂1, φ̂2, π̂1, π̂2, ǫ.\n1. Let |π̂1| = r1, |π̂2| = r2 and let r1 ≥ r2 w.l.o.g. (the other case is the symmetric analog). 2. For any element ei, define f̂ (1) (i → 1) = φ̂1 (π̂1−1(ei)−1)\nZn(φ̂1) , and f̂ (2) (i → 1) = φ̂2( π̂2 −1(ei)−1) Zn(φ̂2) .\nIf ei does not appear in π̂1 set f̂ (1) (i → 1) = 0. Similarly, if ei does not appear in π̂2 set f̂ (2) (i → 1) = 0. Define g(n, φ) = C. n2φ2\n(1−φ)2 log n, where C is an absolute constant.\n3. For each ei ∈ π̂1(1 : r1/2)\n(a) If f̂ (2) (i → 1) < min{ŵ1,ŵ2} 16 f̂(1)(i→1) n2g(n,φ̂1)\ni. π̂1 ← LEARN-SINGLE-MALLOW(Sei7→1). Here Sei 7→1 refers to the samples in S where ei goes to position 1.\nii. π̂2 ← FIND-PI(S , π̂1 , ŵ1, ŵ2 , φ̂1 , φ̂2). Output SUCCESS and return π̂1 and π̂2, ŵ1, ŵ2, φ̂1 and φ̂2.\n4. Do similar check for each ei ∈ π̂2(1 : r2/2). 5. Let ei∗ be the first element in π̂1 such that |f̂ (1) (i∗ → 1) − f̂ (2) (i∗ → 1) | > ǫ. Define ŵ′1 =\n1\n1+ ŵ2 ŵ1\nf̂(2)(i∗→1) f̂(1)(i∗→1)\nand ŵ′2 = 1− ŵ′1.\n6. For each ei /∈ π̂1 and j > r1 (a) Estimate f̂ (i → j) = Pr[ei goes to position j] and f̂ (i → j|ei∗ → 1) =\nPr[ei goes to position j|ei∗ 7→ 1]. (b) Solve the system\nf̂ (i → j) = ŵ1f̂ (1) (i → j) + ŵ2f̂ (2) (i → j) (5) f̂ (i → j|ei∗ → 1) = ŵ′1f̂ (1) (i → j) + ŵ′2f̂ (2) (i → j) (6)\n7. Form the ranking π̂1 = π̂1 ◦ π′1 s.t. for each ei /∈ π̂1, pos(ei) = argmaxj>r1 f̂ (1) (i → j). 8. π̂2 ←FIND-PI(S , π̂1, ŵ1 , ŵ2 , φ̂1, φ̂2, ǫ). Output SUCCESS and return π̂1 and π̂2, ŵ1, ŵ2, φ̂1 and\nφ̂2.\nAlgorithm 8 LEARN-SINGLE-MALLOW, Input: a set S of N samples from M(φ, π).\n1. For each element ei, estimate f̂ (1) (i → j) = Pr[ei goes to position j]. 2. Output a ranking π̂ such that for all ei, pos(ei) = argmaxj f̂ (1) (i → j).\nLemma 10.1. For any j > r1, any elements ei∗ , ei with posπ1(i ∗) > r1, posπ1(i) > posπ1(i ∗), we have in the notation defined above that\nf (1) (i → j|ei∗ → 1) = f (1) (i → j) + δ′ where |δ′| ≤ δn. The corresponding statement also holds for Mallows model M2.\nProof. When samples are generated according to Mallows model M1, we have for these sets of i, i∗, j that the conditional probability f (1) (i → j|ei∗ → 1) = fM(φ1,π1−i∗) (i → j − 1), where the term on the right is a Mallows model over n− 1 elements.\nf (1) (i → j) = n∑\ni′=1\nPr (ei′ → 1) f (1) (i → j|ei∗ → 1) ≤ r1∑\ni′=1\nPr (ei′ → 1) fM(φ1,π1−i′) (i → j − 1) + δ\n= fM(φ1,π1−i∗) (i → j − 1) r1∑\ni′=1\nPr (ei′ → 1) .\nThe last equality is because the probability is independent of i′ (since posπ1(ei) > posπ1(ei∗)). Hence, it follows easily that\nf (1) (i → j|ei∗ → 1) (1− δ) ≤ f (1) (i → j) ≤ f (1) (i → j|ei∗ → 1) + δ.\nAlgorithm 9 ESTIMATE-PHI, Input: P̂ .\n1. Sort P in decreasing order. Return mini{Pi+1Pi }.\nAlgorithm 10 FIND-PI, Input: a set S of N elements from ŵ1M ( φ̂1, π1 ) ⊕ ŵ2M̂ ( φ̂2, π2 ) , π̂1,\nŵ1, ŵ2, φ̂1, φ̂2.\n1. Compute f̂ (1) (i → j) = Pr (ei goes to position j|π̂1) (see Lemma 10.8). 2. For each element ei, estimate f̂ei,j = Pr (ei goes to position j). 3. Solve for f̂ (1) (i → j) using the equation f̂ei,j = ŵ1f̂ (1) (i → j) + ŵ2f̂ (2) (i → j). 4. Output π̂2 such that for each ei, pos(ei) = argmaxj f̂ (2) (i → j).\nHence, by picking an appropriate element ei∗ , we can set up a system of linear equations and solves for the quantities { f (1) (i → j) , f (2) (i → j) } . Suppose there exists an element ei∗ that occurs in the top few positions in both the permutations, then that element would suffice for our purpose. On the other hand, if we condition on an element i∗ which occurs near the top in one permutation but far away in the other permutation, gives us a single Mallows model. The sub-routine RECOVERREST of the main algorithm figures out which of the cases we are in, and succeeds in recovering the entire permutations π1 and π2 in the case that w1M (φ1, π1)⊕w2M (φ2, π2) is non-degenerate (the degenerate cases have been handled separately in the previous section). In such a scenario, from the guarantee of Lemma 3.2 we can assume that we have parameters {ŵ1, ŵ2, φ̂1, φ̂2} which are within ǫ ≤ ǫ0 of the true parameters. For the rest of this section we will assume that RECOVER-REST and every sub-routine it uses has access to samples from ŵ1M ( φ̂1, π1 ) ⊕ ŵ2M̂ ( φ̂2, π2 ) . This is\nw.l.o.g. due to Lemma 2.6.\nThe rankings π̂1 and π̂2 are obtained from INFER-TOP-K. Define γ = (1−φmax)2 4nφmax . By our choice\nof ǫ0, rankings |π̂1| = r1 ≥ log1/φ1 ( n10Zn(φ1) w2minγ 2 ) and |π̂2| = r2 ≥ log1/φ2 ( n10Zn(φ2) w2minγ 2 ) . We note that the values f (1) (i → j) , f (2) (i → j) in the following Lemma are defined with respect to ŵ1M ( φ̂1, π1 ) ⊕ ŵ2M̂ ( φ̂2, π2 ) .\nLemma 10.2. Given access to an oracle for M̂ and rankings π̂1 and π̂2 which agree with π1 and π2 in the first r1 and r2 elements respectively, where r1 ≥ log1/φ1 ( n10Zn(φ1)\nw2minγ 2\n) and r2 ≥\nlog1/φ2\n( n10Zn(φ2)\nw2minγ 2\n) , then procedure RECOVER-REST with ǫ = 110γ, outputs the rankings π1 and\nπ2 with high probability.\nProof. First suppose that the condition in Step 2 of Recover-Rest is true for some ei∗ . This would imply that f (2) (i∗ → 1) < ŵ1ŵ2 f(1)(i∗→1) n2g(n,φ̂1) . Hence, conditioned on ei∗ going to the first position, the new weight w′1 would be 1\n1+ ŵ2 ŵ1\nf(2)(i∗→1) f(1)(i∗→1)\n≥ 1 − 1 ng(n,φ̂1) . Since, g(n, φ̂1) is an upper bound on the\nsample complexity of learning a single Mallows model with parameter φ̂1, with high probability we will only see samples from π1 and from the guarantees of Lemma 10.7 and Lemma 10.8, we will recover both the permutations. A similar analysis is also true for step 4 of RECOVER-REST. If none of the above conditions happen, then step 5 will succeed because of the guarantee from Lemma 3.2.\nNext we will argue about the correctness of the linear equations in step 6. We have set a threshold δ = wminγ 2\nn4 , from Lemma 10.1, we know that the linear equations are correct up to error δ. Once we have obtained good estimates for f (1) (i → j) for all ei and j > r, Lemma 10.3 implies that\nstep 7 of RECOVER-REST will give us the correct ranking π1. This combined with Lemma 10.8 will recover both the rankings with high probability.\nWe now present the Lemmas needed in the proof of the previous Lemma 10.2.\nLemma 10.3. Consider a length n Mallows model with parameter φ. Consider an element ei and let pos(ei) = j. Let f (i → k) = Pr[ei 7→ k]. Then we have\n1. f (i → k) is maximum at k = j.\n2. For all k > j, f (i → k − 1) ≥ f (i → k) (1 + gain(φ)).\n3. For all k < j, f (i → k) ≥ f (i → k − 1) (1 + gain(φ)).\nHere gain(φ) = (1−φ)4φ min( 1 n , 1− φ2).\nProof. The case j = 1 is easy. Let j > 1 and consider the case k > j. Let Sk = {π : posπ(ei) = k}. Similarly let Sk−1 = {π : posπ(ei) = k − 1}. For a set U of rankings, let p(U) = Pr[π ∈ U ]. Notice that f (i → k − 1) = p(Sk−1) and f (i → k) = p(Sk). Let X = {ej : posπ∗(ej) > posπ∗(ei)} and Y = {ej : posπ∗(ej) < posπ∗(ei)}. We will divide Sk into 4 subsets depending on the elements τ1 and τ2 which appear in positions (k − 1) and (k − 2) respectively. In each case we will also present a bijection to the rankings in Sk−1.\n• Sk,1 = {π ∈ Sk : τ1, τ2 ∈ X}. For each such ranking in Sk we form a ranking in Sk−1 by swapping ei and τ1. Call the corresponding subset of Sk−1 as Sk−1,1.\n• Sk,2 = {π ∈ Sk : τ1 ∈ X, τ2 ∈ Y }. For each such ranking in Sk we form a ranking in Sk−1 by swapping ei and τ1. Call the corresponding subset of Sk−1 as Sk−1,2.\n• Sk,3 = {π ∈ Sk : τ1 ∈ Y, τ2 ∈ X}. For each such ranking in Sk we form a ranking in Sk−1 by swapping ei and τ1. Call the corresponding subset of Sk−1 as Sk−1,3.\n• Sk,4 = {π ∈ Sk : τ1, τ2 ∈ Y }. Consider a particular ranking π in Sk,4. Notice that since ei is not in it’s intended position there must exist at least one element x ∈ X such that posπ(x) < posπ(ei) in Sk. Let x∗ be such an element with the largest value of posπ(x). Let y ∈ Y be the element in the position posπ(x∗) + 1. For each such ranking in Sk we form a ranking in Sk−1 by swapping ei and τ1 and x∗ and y. Call the corresponding subset of Sk−1 as Sk−1,4.\nIt is easy to see that the above construction gives a bijection from Sk to Sk−1. We also have the following\n• p(Sk−1,1) = 1φp(Sk,1). This is because the swap is decreasing the number of inversions by exactly 1.\n• p(Sk−1,2) = 1φp(Sk,2). This is because the swap is decreasing the number of inversions by exactly 1. p(Sk−1,3) = φp(Sk,3). This is because the swap is increasing the number of inversions by exactly 1. p(Sk−1,4) = p(Sk,4). This is because the two swaps maintain the number of inversions.\nAlso note that there is a bijection between Sk,2 and Sk,3 such that every ranking in Sk,3 has one more inversion than the corresponding ranking in Sk,2. Hence we have p(Sk,3) = φp(Sk,2).\nNow we have\nf (i → k − 1) = ∑\ni\np(Sk−1,i) (7)\n= 1\nφ p(Sk,1) +\n1 φ p(Sk,2) + φp(Sk,3) + p(Sk,4) (8)\n= f (i → k) + p(Sk,1)( 1\nφ − 1) + p(Sk,2)(\n1 φ − 1)− p(Sk,3)(1 − φ) (9)\n(10)\nIf p(Sk,1) ≥ 14p(Sk) or p(Sk,2) ≥ 14p(Sk), then gain(φ) ≥ (1−φ) 4φ (1 − φ2). If not, then we have p(Sk,4) ≥ 1/4. Divide Sk,4 as ∪jSk,4,j where Sk,4,j = {π ∈ Sk,4 : posπ(x∗) = j}. It is easy to see that p(Sk,4,j) = φ(Sk,4,j−1). Hence we have p(Sk,2) > p(Sk,3) > 1np(Sk,4) ≥ 14n . In this case we will have gain(φ) ≥ (1−φ)4nφ (1 − φ2).\nThe case k < j is symmetric.\nLemma 10.4. Consider a length n Mallows model with parameter φ. Let the target ranking be π∗ = (e1, e2, . . . , en). Let f (1) (i → j) be the probability that the element at position i goes to position j. We have for all i, j\nf (1) (i → j) = f (1) (j → i)\nProof. We will prove the statement by induction on n. For n = 1, 2, the statement is true for all φ. Now assume it is true for all n ≤ l − 1. Consider a length l Mallows model. We have f (1) (i → j) = ∑\nk≤i f (1) (i− 1 → j − 1|ek → 1)Pr(ek 7→ 1) +\n∑\nj≥k>i f (1) (i → j − 1|ek → 1)Pr(ek 7→ 1)\n+ ∑\nk>j\nf (1) (i → j|ek → 1)Pr(ek 7→ 1)\n= ∑\nk≤i f (1) (j − 1 → i− 1|ek → 1)Pr(ek 7→ 1) +\n∑\nj≥k>i f (1) (j − 1 → i|ek → 1)Pr(ek 7→ 1)\n+ ∑\nk>j\nf (1) (j → i|ek → 1)Pr(ek 7→ 1)\n=f (1) (j → i)\nLemma 10.5. Consider a length n Mallows model with parameter φ. Let the target ranking be π∗ = (e1, e2, . . . , en). Consider a position i which has element ei.\n1. f (j → i) is maximum at j = i.\n2. For all k > i, f (k − 1 → i) ≥ f (k → i) (1 + gain(φ)).\n3. For all k < i, f (k → i) ≥ f (k − 1 → i) (1 + gain(φ)).\nHere gain(φ) = (1−φ)4φ min( 1 n , 1− φ2).\nProof. Follows from Lemmas 10.3 and 10.4.\nLemma 10.6. Given access to m = O( 1gain(φ)2 log( n δ )) samples w1M (φ1, π1) ⊕ w2M (φ2, π2), with φ1 = φ2, procedure REMOVE-COMMON-PREFIX with ǫ = 110gain(φ), succeeds with probability 1− δ.\nProof. If the two permutations have the same first element e1, then we have x1 = 1/Zn(φ). Since m is large enough, all our estimates will be correct up to multiplicative error of √ 1 + gain(φ). By induction, assume that the two permutations have the same prefix till t − 1. By the property of\nthe Mallows model, we know that the remaining permutations are also a mixture of two Mallows models with the same weight. Hence, at step t, if we estimate each probability within multiplicative factor of √ 1 + gain(φ), we will succeed with high probability.\nLemma 10.7. Given access to m = O( 1gain(φ)2 log( n δ )) samples from a Mallows model M(φ, π), procedure LEARN-SINGLE-MALLOW with ǫ = 110gain(φ), succeeds with probability 1− δ.\nProof. In order to learn, it is enough to estimate f (i → j) = Pr[ei goes to position j] for every element ei and position j. Having done that we can simply assign pos(ei) = argmaxj f (i → j). From Lemma 10.3 we know that this probability is maximum at the true location of ei and hence is at least 1/n. Hence, it is enough to estimate all f (i → j) which are larger than 1/n up to multiplicative error of √ 1 + gain(φ). By standard Chernoff bounds, it is enough to sample O( 1gain(φ)2 log( n δ )) from the oracle for M(φ, π). Lemma 10.8. Given the parameters of a mixture model w1M (φ1, π1) ⊕ w2M (φ2, π2) and one of the permutations π1, procedure Find-Pi with ǫ = wminγ 10 , succeeds with probability 1 − δ. Here γ = min(gain(φ1), gain(φ2)).\nProof. For any element ei and position j, we have that\nf (i → j) = w1f (1) (i → j) + w2f (2) (i → j) . (11) Here f (1) (i → j) is the probability that element ei goes to position j in M(φ1, π1). Similarly, f (2) (i → j) is the probability that element ei goes to position j in M(φ2, π2). We can compute f (1) (i → j) = f (1)(n,j,i) using dynamic programming via the following relation\nf (1) (n,1,i) = φ i−1 1 /Zn(φ1)\nf (1) (n,l,i) = 1 Zn(φ1)\n    i−1∑\nj=1\nφj−11   f (1)(n−1,l−1,i−1) +   n∑\nj=i+1\nφj−11   f (1)(n−1,l−1,1)  \nHere f (1)(n,l,i) is the probability that the element at the ith position goes to position l in a length n Mallows model. Notice that this probability is independent of the underlying permutation π. Having computed f (1) (i → j) using the above formula, we can solve Equation 11 to get f (2) (i → j) to accuracy √1 + wminγ and figure out π2. The total number of samples required will be O( 1\nγ2w2min log(nδ ))."
    }, {
      "heading" : "11 Wrapping up the Proof",
      "text" : "Proof of Theorem 3.1. Let ǫs be the entry-wise error in P from the estimates. From Lemma 13.3, ǫs < 3 logn/ √ N . We aim to estimate each of the parameters φ1, φ2w1, w2 up to error at most ǫ. Let for convenience, γ = (1−φmax) 2\n4nφmax .\nLet ǫ = min {ǫ, ǫ0}. Let ǫ3 = ϑ9.9(n, φmin, ǫ). Let us also set ǫ2 = ϑ9.1(n, ǫ3, φmin, wmin). Let ǫ′2 be a parameter chosen large enough such that ǫ′2 ≥ ǫ2γmin + ϑ8.1, and ǫ ≤ ϑ3.2(n, ǫ ′ 2, ǫs, wmin, φmin).\nIn the non-degenerate case, suppose there is a partition such that σ2(Ma), σ2(Mb), σ2(Mc) ≥ ǫ′2, Lemma 8.1 guarantees that σ2(M ′a), σ2(M ′ b), σ2(M ′ c) ≥ ǫ2. In this case, Lemma 3.2 ensures that one of the O(log n) rounds of the algorithm succeeds and we get the parameters w1, w2, φ1, φ2 within an error ǫ using Lemma 3.2. Further, Lemma 3.2 will also find the top r, s elements of π1 and π2 respectively where r = log1/φ1 ( n10 γ2wmin ) and s = log1/φ2 ( n10 γ2wmin ) . We will then appeal to Lemma 10.2 (along with Lemma 2.6) to recover the entire rankings π1, π2.\nLemma 2.6 implies that the total variation distance between distributions of w1M (φ1, π1) ⊕ w2M (φ2, π2) and ŵ1M ( φ̂1, π1 ) ⊕ ŵ2M̂ ( φ̂2, π2 ) is at most ǫn 2\nφmin . Since ǫ ≤ ǫ0, this vari-\nation distance is at most φmin 10n3S(wmin/2, √ φmax)\n. Here S(wmin/2, √ φmax) is an upper bound on the\nnumber of samples needed by RECOVER-REST to work given true parameters (and not estimations). This allows to analyze the performance of RECOVER-REST assuming that we get perfect estimates of the parameters (w1, w2, φ1, φ2) since samples used by RECOVER-REST which are drawn from w1M (φ1, π1) ⊕ w2M (φ2, π2) will be indistinguishable from samples from ŵ1M ( φ̂1, π1 ) ⊕ ŵ2M̂ ( φ̂2, π2 ) except with probability 110n3 . This followed by the guarantee of Lemma 10.2 will recover the complete rankings π1 and π2.\nIn the degenerate case, due to our choice of ǫ2, Lemma 9.1 shows that φ̂ is ǫ3 close to both φ1 and φ2. Using Lemma 9.9 we then conclude that step 4 of Algorithm 1 recovers π1, π2 and the parameters w1, w2 within error ǫ."
    }, {
      "heading" : "12 Conclusions and Future Directions",
      "text" : "In this paper we gave the first polynomial time algorithm for learning the parameters of a mixture of two Mallows models. Our algorithm works for an arbitrary mixture and does not need separation among the underlying base rankings. We would like to point out that we can obtain substantial speed-up in the first stage (tensor decompositions) of our algorithm by reducing to an instance with just k ∼ log1/φ n elements. Several interesting directions come out of this work. A natural next step is to generalize our results to learn a mixture of k Mallows models for k > 2. We believe that most of these techniques can be extended to design algorithms that take poly(n, 1/ǫ)k time. It would also be interesting to get algorithms for learning a mixture of k Mallows models which run in time poly(k, n), perhaps in an appropriate smoothed analysis setting [23] or under other non-degeneracy assumptions. Perhaps, more importantly, our result indicates that tensor based methods which have been very popular for problems such as mixture of Gaussians, might be a powerful tool for solving learning problems over rankings as well. We would like to understand the effectiveness of such tools by applying them to other popular ranking models as well."
    }, {
      "heading" : "13 Some Useful Lemmas for Error Analysis",
      "text" : "Lemma 13.1. Let u, u′, v, v′ denote vectors and fix parameters δ, γ > 0. Suppose ‖u ⊗ v − u′ ⊗ v′‖F < δ, and γ ≤ ‖u‖, ‖v‖, ‖u′‖, ‖v′‖ ≤ 1, with δ < γ 2\n2 . Given a decomposition u = α1u ′ + u⊥ and v = α2v′ + v⊥, where u⊥ and v⊥ are\northogonal to u′, v′ respectively, then we have\n‖u⊥‖ < √ δ and ‖v⊥‖ < √ δ.\nProof. We are given that u = α1u′ + u⊥ and v = α2v′ + v⊥. Now, since the tensored vectors are close\n‖u⊗ v − u′ ⊗ v′‖2F < δ2\n‖(1− α1α2)u′ ⊗ v′ + α2u⊥ ⊗ v′ + α1u′ ⊗ v⊥ + u⊥ ⊗ v⊥‖2F < δ2\nγ4(1− α1α2)2 + ‖u⊥‖2α22γ2min + ‖v⊥‖2α21γ2 + ‖u⊥‖2‖v⊥‖2 < δ2 (12) This implies that |1− α1α2| < δ/γ2. Now, let us assume β1 = ‖u⊥‖ > √ δ. This at once implies that β2 = ‖v⊥‖ < √ δ. Hence one of\nthe two (say β2) is smaller than √ δ. Also\nγ2 ≤ ‖v‖2 = α22‖v′‖2 + β22 γ2 − δ ≤ α22\nHence, α2 ≥ γ\n2\nNow, using (12), we see that β1 < √ δ.\nLemma 13.2. Let φ ∈ (0, 1) be a parameter and denote c2(φ) = Zn(φ)Zn−1(φ) 1+φ φ and c3(φ) = Z2n(φ) Zn−1(φ)Zn−2(φ) 1+2φ+2φ2+φ3 φ3 . Then we have that 1 ≤ c2(φ) ≤ 3/φ and 1 ≤ c3(φ) ≤ 50/φ3.\nProof. Since 0 < φ < 1, we have that Zn−1(φ) ≤ 11−φ . Observe that 1 ≤ Zn(φ) Zn−1(φ) ≤ 1+ 1Zn−1(φ) ≤ 2. The bounds now follow immediately.\nLemma 13.3. In the notation of section 2, given N independent samples, the empirical average P̂ satisfied ‖P − P̂‖∞ < √ C log nN with probability 1− n−C/8.\nProof. This follows from a standard application of Bernstein inequality followed by a union bound over the O(n3) events."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2014,
    "abstractText" : "This work concerns learning probabilistic models for ranking data in a heteroge-<lb>neous population. The specific problem we study is learning the parameters of a<lb>Mallows Mixture Model. Despite being widely studied, current heuristics for this<lb>problem do not have theoretical guarantees and can get stuck in bad local optima.<lb>We present the first polynomial time algorithm which provably learns the param-<lb>eters of a mixture of two Mallows models. A key component of our algorithm is<lb>a novel use of tensor decomposition techniques to learn the top-k prefix in both<lb>the rankings. Before this work, even the question of identifiability in the case of a<lb>mixture of two Mallows models was unresolved.",
    "creator" : "LaTeX with hyperref package"
  }
}