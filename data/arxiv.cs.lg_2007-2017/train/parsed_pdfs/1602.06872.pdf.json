{
  "name" : "1602.06872.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Principal Component Projection Without Principal Component Analysis",
    "authors" : [ "Roy Frostig", "Christopher Musco" ],
    "emails" : [ "rf@cs.stanford.edu", "cnmusco@mit.edu", "cpmusco@mit.edu", "asid@microsoft.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 2.\n06 87\n2v 1\n[ cs\n.D S]\nBy avoiding explicit principal component analysis (PCA), our algorithm is the first with no runtime dependence on the number of top principal components. We show that it can be used to give a fast iterative method for the popular principal component regression problem, giving the first major runtime improvement over the naive method of combining PCA with regression.\nTo achieve our results, we first observe that ridge regression can be used to obtain a “smooth projection” onto the top principal components. We then sharpen this approximation to true projection using a low-degree polynomial approximation to the matrix step function. Step function approximation is a topic of long-term interest in scientific computing. We extend prior theory by constructing polynomials with simple iterative structure and rigorously analyzing their behavior under limited precision."
    }, {
      "heading" : "1 Introduction",
      "text" : "In machine learning and statistics, it is common – and often essential – to represent data in a concise form that decreases noise and increases efficiency in downstream tasks. Perhaps the most widespread method for doing so is to project data onto the linear subspace spanned by its directions of highest variance – that is, onto the span of the top components given by principal component analysis (PCA). Computing principal components can be an expensive task, a challenge that prompts a basic algorithmic question:\nCan we project a vector onto the span of a matrix’s top principal components without performing principal component analysis?\nThis paper answers that question in the affirmative, demonstrating that projection is much easier than PCA itself. We show that it can be solved using a simple iterative algorithm based on black-box calls to a ridge regression routine. The algorithm’s runtime does not depend on the number of top principal components chosen for projection, a cost inherent to any algorithm for PCA, or even algorithms that just compute an orthogonal span for the top components."
    }, {
      "heading" : "1.1 Motivation: principal component regression",
      "text" : "To motivate our projection problem, consider one of the most basic downstream applications for PCA: linear regression. Combined, PCA and regression comprise the principal component regression (PCR) problem:\nDefinition 1.1 (Principal component regression (PCR)). Let A ∈ Rn×d be a design matrix whose rows are data points and let b ∈ Rd be a vector of data labels. Let Aλ denote the result of projecting each row of A onto the span of the top principal components of A – in particular the eigenvectors of the covariance matrix 1nA TA whose corresponding variance (eigenvalue) exceeds a threshold λ. The task of PCR is to find a minimizer of the squared loss ‖Aλx− b‖22. In other words, the goal is to compute A†λb, where A † λ is the Moore-Penrose pseudoinverse of Aλ.\nPCR is a key regularization method in statistics, numerical linear algebra, and scientific disciplines including chemometrics [Hot57, Han87, FF93]. It models the assumption that small principal components represent noise rather than data signal. PCR is typically solved by first using PCA to compute Aλ and then applying linear regression. The PCA step dominates the algorithm’s cost, especially if many principal components have variance above the threshold λ.\nWe remedy this issue by showing that our principal component projection algorithm yields a fast algorithm for regression. Specifically, full access to Aλ is unnecessary for PCR: A † λb can be computed efficiently given only an approximate projection of the vector ATb onto A’s top principal components. By solving projection without PCA we obtain the first PCA-free algorithm for PCR."
    }, {
      "heading" : "1.2 A first approximation: ridge regression",
      "text" : "Interestingly, our main approach to efficient principal component projection is based on a common alternative to PCR: ridge regression. This ubiquitous regularization method computes a minimizer of ‖Ax− b‖22+λ‖x‖22 for some regularization parameter λ [Tik63]. The advantage of ridge regression is its formulation as a simple convex optimization problem that can be solved efficiently using many techniques (see Lemma 2.1).\nSolving ridge regression is equivalent to applying the matrix (ATA + λI)−1AT, an operation that can be viewed as a smooth relaxation of PCR. Adding the ℓ2 norm penalty (i.e. λI) effectively “washes out” A’s small principal components in comparison to its large ones and achieves an effect similar to PCR at the extreme ends of A’s spectrum.\nAccordingly, ridge regression gives access to a “smooth projection” operator, (ATA+ λI)−1ATA. This matrix approximates PAλ , the projection matrix onto A’s top principal components. Both have the same singular vectors, but PAλ has a singular value of 1 for each squared singular value σ 2 i ≥ λ in A and a singular value of 0 for each σ2i < λ, whereas (A TA + λI)−1ATA has singular values equal to σ2 i\nσ2 i +λ\n. This function\napproaches 1 when σ2i is much greater than λ and 0 when it is smaller. Figure 1 illustrates the comparison.\nUnfortunately, ridge regression is a very crude approximation to PCR and projection in many settings and may perform significantly worse in certain data analysis applications [DFKU13]. In short, while ridge regression algorithms are valuable tools, it has been unclear how to wield them for tasks like projection or PCR."
    }, {
      "heading" : "1.3 Main result: from ridge regression to projection",
      "text" : "We show that it is possible to sharpen the weak approximation given by ridge regression. Specifically, there exists a low degree polynomial p(·) such that p ( (ATA+ λI)−1ATA )\ny provides a very accurate approximation to PAλy for any vector y. Moreover, the polynomial can be evaluated as a recurrence, which translates into a simple iterative algorithm: we can apply the sharpened approximation to a vector by repeatedly applying any ridge regression routine a small number of times.\nTheorem 1.2 (Principal component projection without PCA). Given A ∈ Rn×d and y ∈ Rd, Algorithm 1 uses Õ(γ−2 log(1/ǫ)) approximate applications of (ATA+ λI)−1 and returns x with ‖x−PAλy‖2 ≤ ǫ‖y‖2.\nLike most iterative PCA algorithms, our running time scales inversely with γ, the spectral gap around λ. Notably, it does not depend on the number of principal components in Aλ, a cost incurred by any method that applies the projection PAλ directly, either by explicitly computing the top principal components of A, or even by just computing an orthogonal span for these components.\nAs mentioned, the above theorem also yields an algorithm for principal component regression that computes A†λb without finding Aλ. We achieve this result by introducing a robust reduction from projection to PCR, that again relies on ridge regression as a computational primitive.\nCorollary 1.3 (Principal component regression without PCA). Given A ∈ Rn×d and b ∈ Rn, Algorithm 2 uses Õ(γ−2 log(1/ǫ)) approximate applications of (ATA+λI)−1 and returns x with ‖x−A†λb‖ATA ≤ ǫ‖b‖2.\nCorollary 1.3 gives the first known algorithm for PCR that avoids the cost of principal component analysis."
    }, {
      "heading" : "1.4 Related work",
      "text" : "A number of papers attempt to alleviate the high cost of principal component analysis when solving PCR. It has been shown that an approximation to Aλ suffices for solving the regression problem [CH90, BMI14]. Unfortunately, even the fastest approximations are much slower than routines for ridge regression and inherently incur a linear dependence on the number of principal components above λ.\nMore closely related to our approach is work on thematrix sign function, an important operation in control theory, quantum chromodynamics, and scientific computing in general. Approximating the sign function often involves matrix polynomials similar to our “sharpening polynomial” that converts ridge regression to principal component projection. Significant effort addresses Krylov methods for applying such operators without computing them explicitly [vdEFL+02, FS08].\nOur work differs from these methods in an important way: since we only assume access to an approximate ridge regression algorithm, it is essential that our sharpening step is robust to noise. Our iterative polynomial construction allows for a complete and rigorous noise analysis that is not available for Krylov methods, while at the same time eliminating space and post-processing costs. Iterative approximations to the matrix sign function have been proposed, but lack rigorous noise analysis [Hig08]."
    }, {
      "heading" : "1.5 Paper layout",
      "text" : "Section 2: Mathematical and algorithmic preliminaries.\nSection 3: Develop a PCA-free algorithm for principal component projection based on a ridge regression subroutine.\nSection 4: Show how our approximate projection algorithm can be used to solve PCR, again without PCA.\nSection 5: Detail our iterative approach to sharpening the smooth ridge regression projection towards true projection via a low degree sharpening polynomial.\nSection 6: Empirical evaluation of our principal component projection and regression algorithms."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "Singular value decomposition. Any matrix A ∈ Rn×d of rank r has a singular value decomposition (SVD) A = UΣVT, where U ∈ Rn×r and V ∈ Rd×r both have orthonormal columns and Σ ∈ Rr×r is a diagonal matrix. The columns of U and V are the left and right singular vectors of A. Moreover, Σ = diag(σ1(A), ..., σr(A)), where σ1(A) ≥ σ2(A) ≥ ... ≥ σr(A) > 0 are the singular values of A in decreasing order.\nThe columns of V are the eigenvectors of the covariance matrix ATA – that is, the principal components of the data – and the eigenvalues of the covariance matrix are the squares of the singular values σ1, . . . , σr.\nFunctions of matrices. If f : R → R is a scalar function and S = diag(s1, . . . , sn) is a diagonal matrix, we define by f(S) def = diag(f(s1), . . . , f(sn)) the entrywise application of f to the diagonal. For a non-diagonal matrix A with SVD A = UΣVT we define f(A) def = Uf(Σ)VT.\nMatrix pseudoinverse. We define the pseudoinverse of A as A† = f(A)T where f(x) = 1/x. The pseudoinverse is essential in the context of regression, as the vector A†b minimizes the squared error ‖Ax− b‖22.\nPrincipal component projection. Given a threshold λ > 0 let k be the largest index with σk(A) 2 ≥ λ and define:\nAλ def = Udiag(σ1, . . . , σk, 0, . . . , 0)V T.\nThe matrix Aλ contains A’s rows projected to the span of all principal components having squared singular value at least λ. We sometimes write Aλ = APAλ where PAλ ∈ Rd×d is the projection onto these top components. Here PAλ = f(A TA) where f(x) is a step function: 0 if x < λ and 1 if x ≥ λ.\nMiscellaneous notation. For any positive semidefinite M,N ∈ Rd×d we use N M to denote that M−N is positive semidefinite. For any x ∈ Rd, ‖x‖M def= √ xTMx.\nRidge regression. Ridge regression is the problem of computing, given a regularization parameter λ > 0:\nxλ def = argmin x∈Rd ‖Ax− b‖22 + λ‖x‖22. (1)\nThe solution to (1) is given by xλ = ( ATA+ λI )−1 ATb. Applying the matrix ( ATA+ λI )−1\nto ATb is equivalent to solving the convex minimization problem:\nxλ def = argmin\nx∈Rd\n1 2 xTATAx− yTx+ λ‖x‖22.\nA vast literature studies solving problems of this form via (accelerated) gradient descent, stochastic variants, and random sketching [Nes83, NN13, SSZ14, LLX14, FGKS15, CLM+15]. We summarize a few, now standard, runtimes achievable by these iterative methods:\nLemma 2.1 (Ridge regression runtimes). Given y ∈ Rd let x∗ = (ATA + λI)−1y. There is an algorithm, ridge(A, λ,y, ǫ) that, for any ǫ > 0, returns x̃ such that\n‖x̃− x∗‖ATA+λI ≤ ǫ‖y‖(ATA+λI)−1 .\nIt runs in time Tridge(A, λ, ǫ) = O ( nnz(A) √ κλ · log(1/ǫ) ) where κλ = σ 2 1(A)/λ is the condition number of the regularized system and nnz(A) is the number of nonzero entries in A. There is a also stochastic algorithm that, for any δ > 0, gives the same guarantee with probability 1− δ in time\nTridge(A, λ, ǫ, δ) = O ((nnz(A) + d sr(A)κλ) · log(1/δǫ)) ,\nwhere sr(A) = ‖A‖2F /‖A‖22 is A’s stable rank. When nnz(A) ≥ d sr(A)κλ the runtime can be improved to\nTridge(A, λ, ǫ, δ) = Õ( √ nnz(A) · d sr(A)κλ · log(1/δǫ)),\nwhere the Õ hides a factor of log (\nd sr(A)κλ nnz(A)\n)\n.\nNote that typically, the regularized condition number κλ will be significantly smaller than the full condition number of ATA."
    }, {
      "heading" : "3 From ridge regression to principal component projection",
      "text" : "We now describe how to approximately apply PAλ using any black-box ridge regression routine. The key idea is to first compute a soft step function of ATA via ridge regression, and then to sharpen this step to approximate PAλ . Let Bx = (A\nTA+ λI)−1(ATA)x be the result of applying ridge regression to (ATA)x. In the language of functions of matrices, we have B = r(ATA), where\nr(x) def =\nx\nx+ λ .\nThe function r(x) is a smooth step about λ (see Figure 1). It primarily serves to map the eigenvalues of ATA to the range [0, 1], mapping those exceeding the threshold λ to a value above 1/2 and the rest to a value below 1/2. To approximate the projection PAλ , it would now suffice to apply a simple symmetric step function:\ns(x) =\n{\n0 if x < 1/2 1 if x ≥ 1/2\nIt is easy to see that s(B) = s(r(ATA)) = PAλ . For x ≥ λ, r(x) ≥ 1/2 and so s(r(x)) = 1. Similarly for x < λ, r(x) < 1/2 and hence s(r(x)) = 0. That is, the symmetric step function exactly converts our smooth ridge regression step to the true projection operator."
    }, {
      "heading" : "3.1 Polynomial approximation to the step function",
      "text" : "While computing s(B) directly is expensive, requiring the SVD of B, we show how to approximate this function with a low-degree polynomial. We also show how to apply this polynomial efficiently and stably using a simple iterative algorithm. Our main result, proven in Section 5, is:\nLemma 3.1 (Step function algorithm). Let S ∈ Rd×d be symmetric with every eigenvalue σ satisfying σ ∈ [0, 1] and |σ − 1/2| ≥ γ. Let A denote a procedure that on x ∈ Rd produces A(x) with ‖A(x) − Sx‖2 = O(ǫ2γ2)‖x‖2. Given y ∈ Rd set s0 := A(y), w0 := s0 − 12y, and for k ≥ 0 set\nwk+1 := 4\n(\n2k + 1\n2k + 2\n)\nA(wk −A(wk))\nand sk+1 := sk +wk+1. If all arithmetic operations are performed with Ω(log(d/ǫγ)) bits of precision then ‖sq − s(S)y‖2 = O(ǫ)‖y‖2 for q = Θ(γ−2 log(1/ǫ)).\nNote that the output sq is an approximation to a 2q degree polynomial of S applied to y. In Algorithm 1, we give pseudocode for combining the procedure with ridge regression to solve principal component projection. Set S = B and let A be an algorithm that approximately applies B to any x by applying approximate ridge regression to ATAx. As long as B has no eigenvalues falling within γ of 1/2, the lemma ensures ‖sq −PAλy‖2 = O(ǫ)‖y‖2. This requires γ on order of the spectral gap: 1− σ2k+1(A)/σ2k(A), where k is the largest index with σ2k(A) ≥ λ.\nAlgorithm 1 (pc-proj) Principal component projection input: A ∈ Rn×d, y ∈ Rd, error ǫ, failure rate δ, threshold λ, gap γ ∈ (0, 1) q := c1γ\n−2 log(1/ǫ) ǫ′ := c−12 ǫ 2γ2/ √ κλ, δ\n′ := δ/(2q) s := ridge(A, λ,ATAy, ǫ′, δ′) w := s− 12y for k = 0, ..., q − 1 do t := w − ridge(A, λ,ATAw, ǫ′, δ′) w := 4 (\n2k+1 2k+2\n)\nridge(A, λ,ATAt, ǫ′, δ′)\ns := s +w end for return s\nTheorem 3.2. If 11−4γσk+1(A) 2 ≤ λ ≤ (1− 4γ)σk(A)2 and c1, c2 are sufficiently large constants, pc-proj (Algorithm 1) returns s such that with probability ≥ 1− δ,\n‖s−PAλy‖2 ≤ ǫ‖y‖2.\nThe algorithm requires O(γ−2 log(1/ǫ)) ridge regression calls, each costing Tridge(A, λ, ǫ ′, δ′). Lemma 2.1 yields total cost (with no failure probability)\nO ( nnz(A) √ κλγ −2 log(1/ǫ) log (κλ/(ǫγ)) )\nor, via stochastic methods,\nÕ ( (nnz(A+ d sr(A)κλ) γ −2 log(1/ǫ) log(κλ/(ǫγδ)) )\nwith acceleration possible when nnz(A) > d sr(A)κλ.\nProof. We instantiate Lemma 3.1. Let S = B = (ATA+ λI)−1ATA. As discussed, B = r(ATA) and hence all its eigenvalues fall in [0, 1]. Specifically, σi(B) = σi(A) 2\nσi(A)2+λ . Now, σk(B) ≥ λ/(1−4γ)λ/(1−4γ)+λ = 12−4γ ≥ 12 + γ\nand similarly σk+1(B) ≤ λ(1−4γ)λ(1−4γ)+λ = 1−4γ 2−4γ ≤ 12 − γ, so all eigenvalues of B are at least γ far from 1/2. By Lemma 2.1, for any x, with probability ≥ 1− δ′:\n‖ridge(A,λ,ATAx, ǫ′, δ′)−Bx‖ATA+λI ≤ ǫ′‖ATAx‖(ATA+λI)−1 ≤ σ1(A)ǫ′‖x‖2.\nSince the minimum eigenvalue of ATA+ λI is λ:\n‖ridge(A, λ,ATAx, ǫ′, δ′)−Bx‖2\n≤ σ1(A)√ λ\nǫ′‖x‖2 ≤ √ κλǫ 2γ2\nc2 √ κλ ‖x‖2 = O(ǫ2γ2)‖x‖2.\nApplying the union bound over all 2q calls of ridge, this bound holds for all calls with probability ≥ 1− δ′ · 2q = 1− δ. So, overall, by Lemma 3.1, with probability at least 1− δ, ‖s− s(B)y‖2 = O(ǫ)‖y‖2. As discussed, s(B) = PAλ . Adjusting constants on ǫ (via c1 and c2) completes the proof.\nNote that the runtime of Theorem 3.2 includes a dependence on √ κλ. In performing principal component projection, pc-proc applies an asymmetric step function to ATA. The optimal polynomial for approximating this step also has a √ κλ dependence [EY11], showing that our reduction from projection to ridge regression is optimal in this regard."
    }, {
      "heading" : "3.2 Choosing λ and γ",
      "text" : "Theorem 3.2 requires σk+1(A) 2\n1−4γ ≤ λ ≤ (1− 4γ)σk(A)2. If λ is chosen approximately equidistant from the two eigenvalues, we need γ = O(1 − σ2k+1(A)/σ2k(A)).\nIn practice, however, it is unnecessary to explicitly specify γ or to choose λ so precisely. With q = O(γ−2 log(1/ǫ)) our projection will be approximately correct on all singular values outside the range [(1 − γ)λ, (1 + γ)λ]. If there are any “intermediate” singular values in this range, as shown in Section 5, the approximate step function applied by Lemma 3.1 will map these values to [0, 1] via a monotonically increasing soft step. That is, Algorithm 1 gives a slightly softened projection – removing any principal directions with value < (1− γ)λ, keeping any with value > (1 + γ)λ and partially projecting away any in between."
    }, {
      "heading" : "4 From principal component projection to principal component",
      "text" : "regression\nA major motivation for an efficient, PCA-free method for projecting a vector onto the span of top principal components is principal component regression (PCR). Recall that PCR solves the following problem:\nA † λb = argmin x∈Rd ‖Aλx− b‖22.\nIn exact arithmetic, A†λb is equal to (A TA)−1PAλA\nTb. This identity suggests a method for computing the solution to ridge regression without finding Aλ explicitly: first apply a principal component projection algorithm to ATb and then solve a linear system to apply (ATA)−1.\nUnfortunately, this approach is disastrously unstable, not only when PAλ is applied approximately, but in any finite precision environment. Accordingly, we present a modified method for obtaining PCA-free regression from projection."
    }, {
      "heading" : "4.1 Stable inversion via ridge regression",
      "text" : "Let y = PAλA Tb and suppose we have some ỹ ≈ y (e.g. obtained from Algorithm 1). The issue with the first approach mentioned is that since (ATA)−1 could have a very large maximum eigenvalue, we cannot guarantee (ATA)−1ỹ ≈ (ATA)−1y. On the other hand, applying the ridge regression operator (ATA+λI)−1 to ỹ is much more stable since it has a maximum eigenvalue of 1/λ, so (ATA + λI)−1ỹ will approximate (ATA+ λI)−1y well.\nIn short, it is more stable to apply (ATA+λI)−1y = f(ATA)y, where f(x) = 1x+λ , but the goal in PCR is to apply (ATA)−1 = h(ATA) where h(x) = 1/x. So, in order to go from one function to the other, we use a correction function g(x) = x1−λx . By simple calculation,\nA † λb = (A TA)−1y = g((ATA+ λI)−1)y.\nAdditionally, we can stably approximate g(x) with an iteratively computed low degree polynomial! Specifically, we use a truncation of the series g(x) =\n∑∞ i=1 λ i−1xi. An exact approximation to g(x) would exactly apply (ATA)−1, which as discussed, is unstable due to very large eigenvalues (corresponding to small eigenvalues of ATA). Our approximation to g(x) is accurate on the large eigenvalues of ATA but inaccurate on the small eigenvalues. This turns out to be the key to the stability of our algorithm. By not “fully inverting” these eigenvalues, our polynomial approximation avoids the instability of applying the true inverse (ATA)−1. We provide a complete error analysis in Appendix B, the upshot of which is the following:\nLemma 4.1 (PCR approximation algorithm). Let A be a procedure that, given x ∈ Rd, produces A(x) with ‖A(x)− (ATA+ λI)−1x‖ATA+λI = O( ǫq2σ1(A) )‖x‖2. Let B be a procedure that, given x ∈ R\nd produces B(x) with ‖B(x)−PAλx‖2 = O( ǫq2√κλ )‖x‖2. Given b ∈ R n set s0 := B(ATb) and s1 := A(s0). For k ≥ 1 set:\nsk+1 := s1 + λ · A(sk).\nIf all arithmetic operations are performed with Ω(log(d/qǫ)) bits of precision then ‖sq−A†λb‖ATA = O(ǫ)‖b‖2 for q = Θ(log(κλ/ǫ)).\nWe instantiate the iterative procedure above in Algorithm 2. pc-proj(A, λ,y, γ, ǫ, δ) denotes a call to Algorithm 1.\nAlgorithm 2 (ridge-pcr) Ridge regression-based PCR input: A ∈ Rn×d, b ∈ Rn, error ǫ, failure rate δ, threshold λ, gap γ ∈ (0, 1) q := c1 log(κλ/ǫ) ǫ′ := c−12 ǫ/(q\n2√κλ), δ′ = δ/2(q + 1) y := pc-proj(A, λ,ATb, γ, ǫ′, δ/2) s0 := ridge(A, λ,y, ǫ\n′, δ′), s := s0 for k = 1, ..., q do s := s0 + λ · ridge(A, λ, s, ǫ′, δ′) end for return s\nTheorem 4.2. If 11−4γσk+1(A) 2 ≤ λ ≤ (1−4γ)σk(A)2 and c1, c2 are sufficiently large constants, ridge-pcr (Algorithm 2) returns s such that with probability ≥ 1− δ,\n‖s−A†λb‖ATA ≤ ǫ‖b‖2.\nThe algorithm makes one call to pc-proj and O(log(κλ/ǫ)) calls to ridge regression, each of which costs Tridge(A, λ, ǫ ′, δ′), so Lemma 2.1 and Theorem 3.2 imply a total runtime of\nÕ(nnz(A) √ κλγ −2 log2 (κλ/(ǫγ))),\nwhere Õ hides log log(1/ǫ), or, with stochastic methods,\nÕ((nnz(A) + d sr(A)κλ)γ −2 log2 (κλ/(ǫγδ))).\nProof. We apply Lemma 4.1; A is given by ridge(A, λ,x, ǫ′, δ′). Since ‖(ATA+ λI)−1‖2 < 1/λ, Lemma 2.1 states that with probability 1− δ′,\n‖A(x)− (ATA+ λI)−1x‖ATA+λI\n≤ ǫ′‖x‖(ATA+λI)−1 ≤ c−12 ǫ\nq2 √ κλλ\n‖x‖2 ≤ c−12 ǫ\nq2σ1(A) ‖x‖2.\nNow, B is given by pc-proj(A, λ,x, γ, ǫ′, δ/2). With probability 1 − δ/2, if 11−4γσk+1(A)2 ≤ λ ≤ (1− 4γ)σk(A)2 then by Theorem 3.2, ‖B(x)−PAλx‖2 ≤ ǫ′‖x‖2 = ǫ/(c2q2 √ κλ). Applying the union bound over q+1 calls to A and a single call to B, these bounds hold on every call with probability ≥ 1−δ. Adjusting constants on ǫ (via c1 and c2) proves the theorem."
    }, {
      "heading" : "5 Approximating the matrix step function",
      "text" : "We now return to proving our underlying result on iterative polynomial approximation of the matrix step function:\nLemma 3.1 (Step function algorithm). Let S ∈ Rd×d be symmetric with every eigenvalue σ satisfying σ ∈ [0, 1] and |σ − 1/2| ≥ γ. Let A denote a procedure that on x ∈ Rd produces A(x) with ‖A(x) − Sx‖ = O(ǫ2γ2)‖x‖2. Given y ∈ Rd set s0 := A(y), w0 := s0 − 12y, and for k ≥ 0 set\nwk+1 := 4\n(\n2k + 1\n2k + 2\n)\nA(wk −A(wk))\nand sk+1 := sk +wk+1. If all arithmetic operations are performed with Ω(log(d/ǫγ)) bits of precision and if q = Θ(γ−2 log(1/ǫ)) then ‖sq − s(S)y‖2 = O(ǫ)‖y‖2.\nThe derivation and proof of Lemma 3.1 is split into 3 parts. In Section 5.1 we derive a simple low degree polynomial approximation to the sign function:\nsgn(x) def =\n\n \n \n1 if x > 0\n0 if x = 0\n−1 if x < 0 In Section 5.2 we show how this polynomial can be computed with a stable iterative procedure. In Section 5.3 we use these pieces and the fact that the step function is simply a shifted and scaled sign function to prove Lemma 3.1. Along the way we give complementary views of Lemma 3.1 and show that there exist more efficient polynomial approximations."
    }, {
      "heading" : "5.1 Polynomial approximation to the sign function",
      "text" : "We show that for sufficiently large k, the following polynomial is uniformly close to sgn(x) on [−1, 1]:\npk(x) def =\nk ∑\ni=0\n x(1 − x2)i i ∏\nj=1\n2j − 1 2j\n\n\nThe polynomial pk(x) can be derived in several ways. One follows from observing that sgn(x) is odd and thereby sgn(x)/x = 1/|x| is even. So, a good polynomial approximation for sgn(x) should be odd and, when divided by x, should be even (i.e. a function of x2). Specifically, given a polynomial approximation q(x) to 1/ √ x on the range (0, 1] we can approximate sgn(x) using xq(x2). Choosing q to be the k-th order Taylor approximation to 1/ √ x at x = 1 yields pk(x). With this insight we show that pk(x) converges to sgn(x).\nLemma 5.1. sgn(x) = limk→∞ pk(x) for all x ∈ [−1, 1]. Proof. Let f(x) = x−1/2. By induction on k it is straightforward to show that the k-th derivative of f at x > 0 is\nf (k)(x) = (−1)k · (x)− 1+2k 2\nk ∏\ni=1\n2i− 1 2 .\nSince (−1)i(x− 1)i = (1 − x)i we see that the degree k Taylor approximation to f(x) at x = 1 is therefore\nqk(x) = k ∑\ni=0\n\n(1− x)i · 1 i!\ni ∏\nj=1\n2j − 1 2\n  = k ∑\ni=0\n (1 − x)i · i ∏\nj=1\n2j − 1 2j\n\n .\nNote that for x, y ∈ [ǫ, 1], the remainder f (k)(x)(1 − y)k/k! has absolute value at most (1 − ǫ)k. Therefore the remainder converges to 0 as k → ∞ and the Taylor approximation converges, i.e. limk→∞ qk(x) = 1/ √ x\nfor x ∈ (0, 1]. Since pk(x) = x · qk(x2) we have limk→∞ pk(x) = x/ √ x2 = sgn(x) for x 6= 0 with x ∈ [−1, 1]. Since pk(0) = 0 = sgn(0), the result follows.\nAlternatively, to derive pk(x) we can consider (1 − x2)k, which is relatively large near 0 and small on the rest of [−1, 1]. Integrating this function from 0 to x and normalizing yields a good step function. In Appendix A we prove that:\nLemma 5.2. For all x ∈ R pk(x) = ∫ x 0 (1− y2)kdy\n∫ 1 0 (1 − y2)kdy .\nNext, we bound the rate of convergence of pk(x) to sgn(x):\nLemma 5.3. For k ≥ 1 if x ∈ (0, 1] then pk(x) > 0 and\nsgn(x)− (x √ k)−1e−kx 2 ≤ pk(x) ≤ sgn(x) . (2)\nIf x ∈ [−1, 0) then pk(x) < 0 and\nsgn(x) ≤ pk(x) ≤ sgn(x) + (x √ k)−1e−kx 2 .\nProof. The claim is trivial when x = 0. Since pk(x) is odd it suffices to consider x ∈ (0, 1]. For such x, it is direct that pk(x) > 0, and pk(x) ≤ sgn(x) follows from the observation that pk(x) increases monotonically with k and limk→∞ pk(x) = sgn(x) by Lemma 5.1. All that remains to show is the left-side inequality of (2). Using Lemma 5.1 again,\nsgn(x)− pk(x) = ∞ ∑\ni=k+1\n x(1 − x2)i i ∏\nj=1\n2i− 1 2i\n\n\n≤ x(1− x2)k ∞ ∑\ni=0\n (1 − x2)i k ∏\nj=1\n2j − 1 2j\n\n .\nNow since 1 + x ≤ ex for all x and ∑ni=1 1i ≥ lnn, we have\nk ∏\nj=1\n2j − 1 2j ≤ exp\n\n\nk ∑\nj=1\n−1 2j\n  ≤ exp (− ln k\n2\n)\n= 1√ k .\nCombining with ∑∞ i=0(1 − x2)i = x−2 and again that 1 + x ≤ ex proves the left hand side of (2).\nThe lemma directly implies that pk(x) is a high quality approximation to sgn(x) for x bounded away from 0.\nCorollary 5.4. If x ∈ [−1, 1], with |x| ≥ α > 0 and k = α−2 ln(1/ǫ), then | sgn(x)− pk(x)| ≤ ǫ.\nWe conclude by noting that this proof in fact implies the existence of a lower-degree polynomial approximation to sgn(x). Since the sum of coefficients in our expansion is small, we can replace each (1−x2)q with Chebyshev polynomials of lower degree. In Appendix A, we prove:\nLemma 5.5. There exists an O(α−1 log(1/αǫ)) degree polynomial q(x) such that | sgn(x)− q(x)| ≤ ǫ for all x ∈ [−1, 1] with |x| ≥ α > 0 .\nLemma 5.5 achieves, up an additive log(1/α)/α, the optimal trade off between degree and approximation of sgn(x) [EY07]. We have preliminary progress toward making this near-optimal polynomial algorithmic, a topic we leave to explore in future work."
    }, {
      "heading" : "5.2 Stable iterative algorithm for the sign function",
      "text" : "We now provide an iterative algorithm for computing pk(x) that works when applied with limited precision. Our formula is obtained by considering each term of pk(x). Let\ntk(x) def = x(1− x2)k\nk ∏\nj=1\n2j − 1 2j .\nClearly tk+1(x) = tk(x)(1 − x2)(2k + 1)/(2k + 2) and therefore we can compute the tk iteratively. Since pk(x) = ∑k i=0 ti(x) we can compute pk(x) iteratively as well. We show this procedure works when applied to matrices, even if all operations are performed with limited precision:\nLemma 5.6. Let B ∈ Rd×d be symmetric with ‖B‖2 ≤ 1. Let C be a procedure that given x ∈ Rd produces C(x) with ‖C(x)−(I−B2)x‖2 ≤ ǫ‖x‖2. Given y ∈ Rd suppose that we have t0 and p0 such that ‖t0−By‖2 ≤ ǫ‖y‖2 and ‖p0 −By‖2 ≤ ǫ‖y‖2. For all k ≥ 1 set\ntk+1 :=\n(\n2k + 1\n2k + 2\n)\nC(tk) and pk+1 := pk + tk+1 .\nThen if arithmetic operations are carried out with Ω(log(d/ǫ)) bits of precision we have for 1 ≤ k ≤ 1/(7ǫ)\n‖tk(B)y − tk‖2 ≤ 7kǫ and ‖pk(B)y − pk‖2 ≤ 7kǫ .\nProof. Let t∗k def = tk(B)y, p ∗ k def = pk(B)y, and C def = I − B2. Since p∗0 = t∗0 = By and ‖B‖2 ≤ 1 we see that even if t0 and p0 are truncated to the given bit precision we still have ‖t0 − t∗0‖2 ≤ ǫ‖y‖2 and ‖p0 − p∗0‖2 ≤ ǫ‖y‖2.\nNow suppose that ‖tk − t∗k‖2 ≤ α‖y‖2 for some α ≤ 1. Since |tk(x)| ≤ |pk(x)| ≤ | sgn(x)| ≤ 1 for x ∈ [−1, 1] and −I B I we know that ‖t∗k‖2 ≤ ‖y‖2 and by reverse triangle inequality ‖tk‖2 ≤ (1 + α)‖y‖2. Using our assumption on C and applying triangle inequality yields\n‖C(tk)−Ct∗k‖2 ≤ ‖C(tk)−Ctk‖2 + ‖C(tk − t∗k)‖2 ≤ ǫ‖tk‖2 + ‖C‖2 · ‖(tk − t∗k)‖2 ≤ (ǫ(1 + α) + α)‖y‖2 ≤ (2ǫ+ α)‖y‖2 .\nIn the last line we used ‖C‖2 ≤ 1 since 0 B2 I. Again, by this fact we know that ‖Ct∗k‖2 ≤ ‖y‖2 and therefore again by reverse triangle inequality ‖C(tk)‖2 ≤ (1+2ǫ+α)‖y‖2. Using C(tk) to compute tk+1 with bounded arithmetic precision will then introduce an additional additive error of ǫ(1+2ǫ+α)‖y‖2 ≤ 4ǫ‖y‖2. Putting all this together we have that ‖t∗k− tk‖2 grows by at most an additive 6ǫ‖y‖2 every time k increases and by the same argument so does ‖pk − p∗k‖2. Including our initial error of ǫ on t0 and p0, we conclude that ‖t∗k − tk‖2 and ‖pk − p∗k‖2 are both bounded by 6kǫ+ ǫ ≤ 7kǫ."
    }, {
      "heading" : "5.3 Approximating the step function",
      "text" : "We finally apply the results of Section 5.1 and Section 5.2 to approximate the step function and prove Lemma 3.1. We simply apply the fact that s(x) = (1/2)(1+ sgn(2x− 1)) and perform further error analysis. We first use Lemma 5.6 to show how to compute (1/2)(1 + pk(2x− 1)). Lemma 5.7. Let S ∈ Rd×d be symmetric with 0 S I. Let A be a procedure that on x ∈ Rd produces A(x) with ‖A(x) − Sx‖2 ≤ ǫ‖x‖2. Given arbitrary y ∈ Rd set s0 := A(y), w0 := s0 − (1/2)y, and for all k ≥ 0 set\nwk+1 := 4\n(\n2k + 1\n2k + 2\n)\nA(wk −A(wk))\nand sk+1 := sk + wk+1. If arithmetic operations are performed with Ω(log(d/ǫ)) bits of precision and k = O(1/ǫ) then ‖1/2(I− pk(2S− I))y − sk‖2 = O(kǫ)‖y‖2.\nProof. Since M def = I − (2S − I)2 = 4S(I − S) we see that wk is the same as (1/2)tk in Lemma 5.6 with B = 2S− I and C(x) = 4A(x−A(x)), and sk = ∑k\ni=0(1/2)ti+(1/2)b. Since multiplying by 1/2 everywhere does not increase error and since ‖2S − I‖2 ≤ 1 we can invoke Lemma 5.6 to yield the result provided we can show ‖4A(x−A(x))−Mx‖2 = O(ǫ)‖x‖2. Computing A(x) and subtracting from x introduces at most additive error 2ǫ‖x‖2 Consequently by the error guarantee of A, ‖4A(A(x) − x) − Mx‖2 = O(ǫ)‖x‖2 as desired.\nUsing Lemma 5.7 and Corollary 5.4 we finally have:\nProof of Lemma 3.1. By assumption, 0 S I and ǫγ2q = O(1). Invoking Lemma 5.7 with error ǫ′ = ǫ2γ2, letting aq def = 1/2(I− pq(2S− I))y we have\n‖aq − sq‖2 = O(γ2ǫ2q)‖y‖2 = O(ǫ)‖y‖2 . (3)\nNow, since s(S) = 1/2(I− sgn(2S − I)) and every eigenvalue of 2S − I is in [γ, 1], by assumption on S we can invoke Corollary 5.4 yielding ‖aq − s(S)y‖2 ≤ 12‖pq(2S − I) − sgn(2S− I)‖2‖y‖2 ≤ 2ǫ‖y‖2. The result follows from combining with (3) via triangle inequality."
    }, {
      "heading" : "6 Empirical evaluation",
      "text" : "We conclude with an empirical evaluation of pc-proc and ridge-pcr (Algorithms 1 and 2). Since PCR has already been justified as a statistical technique, we focus on showing that, with few iterations, the algorithm recovers an accurate approximation to A†λb and PAλy.\nWe begin with synthetic data, which lets us control the spectral gap γ that dominates our iteration bounds (see Theorem 3.2). Data is generated randomly by drawing top singular values uniformly from the range [.5(1 + γ), 1] and tail singular values from [0, .5(1 − γ)]. λ is set to .5 and A is formed via the SVD UΣVT where U and V are random orthonormal matrices and Σ contains our random singular values. To model a typical PCR application, b is generated by adding noise to the response Ax of a random “true” x that correlates with A’s top principal components.\nAs apparent in Figure 2(a), our algorithm performs very well for regression, even for small γ. Error is\nmeasured via the natural ATA-norm and we plot ‖ridge-pcr(A,b, λ)−A†λb‖2ATA/‖A † λb‖2ATA.\nFigure 2(b) shows similar convergence for projection, although we do notice a stronger effect of a small gap γ in this case. Projection error is given with respect to the more natural 2-norm.\nBoth plots confirm the linear convergence predicted by our analysis (Theorems 3.2 and 4.2). To illustrate stability, we include an extended plot for the γ = .1 data which shows arbitrarily high accuracy as iterations increase (Figure 3).\nFinally, we consider a large regression problem constructed from MNIST classification data [LCB15], with the goal of distinguishing handwritten digits {1,2,4,5,7} from the rest. Input is normalized and 1000 random Fourier features are generated according to a unit RBF kernel [RR07]. Our final data set is both of larger scale and condition number than the original.\nThe MNIST principal component regression was run with λ = .01σ21 . Although the gap γ is very small around this cutoff point (just .006), we see fast convergence for PCR. Convergence for projection is slowed more notably by the small gap, but it is still possible to obtain 0.01 relative error with only 20 iterations (i.e. invocations of ridge regression)."
    }, {
      "heading" : "A The matrix step function",
      "text" : "Here we provide proofs omitted from Section 5. We prove Lemma 5.2 showing that pq(x) can be viewed alternatively as a simple integral of (1 − x2)q. We also prove Lemma 5.5 showing the existence of an even lower degree polynomial approximation to sgn(x).\nLemma 5.2. For all x ∈ R pk(x) = ∫ x 0 (1− y2)kdy ∫ 1\n0 (1 − y2)kdy\n.\nProof. Let qk(x) def = ∫ x 0 (1 − x2)q. Our proof follows from simply recursively computing this integral via integration by parts. Integration by parts with u = (1 − x2)k and dv = dx yields\nqk(x) = x(1− x2)k + 2k ∫ x\n0\nx2(1− x2)k−1 .\nSince x2 = 1− (1− x2) we have\nqk(x) = x(1 − x2)k + 2k · qk−1(x)− 2k · qk(x).\nRearranging terms and dividing by 2k + 1 yields\nqk(x) = 1\n2k + 1\n[ x(1− x2)k + 2k · qk−1(x) ] .\nSince q0(1) = 1 this implies that qk(1) = ∏k j=1 2j 2j+1 and\nqk(x) qk(1) =\n1\n2k + 1\nk ∏\nj=1\n(\n2j + 1\n2j\n)\nx(1− x2)k + qk−1(x) qk−1(1) .\nSince 12k+1 ∏k j=1 2j+1 2j = ∏k j=1 2j−1 2j we have that qk(x)/qk(1) = pk(x) as desired.\nWe now prove the existence of a lower degree polynomial for approximating sgn(x).\nLemma 5.5. There exists an O(α−1 log(1/αǫ)) degree polynomial q(x) such that | sgn(x)− q(x)| ≤ ǫ for all x ∈ [−1, 1] with |x| ≥ α > 0 .\nWe first provide a general result on approximating polynomials with lower degree polynomials.\nLemma A.1 (Polynomial Compression). Let p(x) be an O(k) degree polynomial that we can write as\np(x) = k ∑\ni=0\nfi(x) (gi(x)) i\nwhere fi(x) and gi(x) are O(1) degree polynomials satisfying |fi(x)| ≤ ai and |gi(x)| ≤ 1 for all x ∈ [−1, 1]. Then, there exists polynomial q(x) of degree O( √ k log(A/ǫ)) where A = ∑k\ni=0 ai such that |p(x)− q(x)| ≤ ǫ for all x ∈ [−1, 1].\nThis lemma follows from the well known fact in approximation theory that there exist O( √ d) degree polynomials that approximate xd uniformly on the interval [−1, 1]. In particular we make use of the following: Theorem A.2 (Theorem 3.3 from [SV14]). For all s and d there exists a degree d polynomial denoted ps,d(x) such that |ps,d(x) − xs| ≤ 2 exp(−d2/2s) for all x ∈ [−1, 1].\nUsing Theorem A.2 we prove Lemma A.1.\nProof. Let d = √ 2k log(A/ǫ) and let our low degree polynomial be defined as q(x) = ∑k\ni=1 fi(x)pd,i(gi(x)). By Theorem A.2 we know that q(x) has the desired degree and by triangle inequality for all x ∈ [−1, 1]\n|p(x) − q(x)| ≤ k ∑\ni=1\nai|gi(x)i − pd,i(gi(x))|\n≤ k ∑\ni=1\nai exp(−d2/2i) ≤ ǫ,\nwhere the last line used i ≤ k and our choice of d.\nUsing Lemma A.1 we can now complete the proof.\nProof of Lemma 5.5. Note that pk(x) can be written in the form of Lemma A.1 with fi(x) = x ∏i j=1 2j−1 2j and gi(x) = 1 − x2. Clearly |fi(x)| ≤ 1 and |gi(x)| ≤ 1 for x ∈ [−1, 1] and thus we can invoke Lemma A.1 to obtain a degree O( √\nk log(k/ǫ)) polynomial qk(x) with |qk(x)− pk(x)| ≤ 12ǫ for all x ∈ [−1, 1]. By Corollary 5.4 we know that for k = α−2 ln(2/ǫ) we have | sgn(x) − pk(x)| ≤ ǫ/2 and therefore\n| sgn(x) − qk(x)| ≤ ǫ. Since √\nα−2 ln(2/ǫ) ln\n( α−2 ln(2/ǫ)\nǫ\n)\n= O(α−1 ln(1/αǫ)),\nwe have the desired result."
    }, {
      "heading" : "B Principal component regression",
      "text" : "Finally we prove Lemma 4.1, the main result behind our algorithm to convert principal component projection to PCR algorithm. The proof is in two parts. First, letting y = PAλA Tb, we show how to approximate (ATA)−1y = A†λ with a low degree polynomial of the ridge inverse (A TA + λI)−1. Second, we provide an error analysis of our iterative method for computing this polynomial. We start with a very basic polynomial approximation bound:\nLemma B.1. Let g(x) def = x1−λx and pk(x) def = ∑k i=1 λ i−1xi. For x ≤ 12λ we have: g(x)− pk(x) ≤ 12kλ Proof. We can expand g(x) =\n∑∞ i=1 λ i−1xi. So:\ng(x)− pk(x) = ∞ ∑\ni=k+1\nλi−1xi ≤ x 2k−1\n∞ ∑\ni=1\n(λx)i ≤ 1 2kλ .\nWe next extend this lemma to the matrix case:\nLemma B.2. For any A ∈ Rn×d and b ∈ Rd, let y = PAλATb. Let pk(x) = ∑k i=1 λ i−1xi. Then we have:\n‖pk ( (ATA+ λI)−1 ) y −A†λb‖ATA ≤ κλ‖b‖2\n2k .\nProof. For conciseness, in the remainder of this section we denote M def = ATA + λI. Let z = pk ( M−1 ) y. Letting g(x) = x/(1−λx) we have g (\n1 x+λ\n)\n= 1x . So, g(M −1)y = (ATA)−1y = A†λb. Define δk(x) def = g(x)−\npk(x).\n‖A†λb− z‖ATA = ‖δk(M−1)y‖ATA ≤ σ1(A) · ‖δk(M−1)y‖2. (4)\nThe projection y falls entirely in the span of principal components of A with squared singular values ≥ λ. M maps these values to singular values ≤ 1λ+λ = 12λ , and hence by Lemma B.1 we have:\n‖δk(M−1)y‖2 ≤ 1\n2kλ ‖y‖2\n≤ σ1(A) 2kλ ‖b‖2.\nCombining with (4) and recalling that κλ def = σ1(A) 2/λ gives the lemma.\nWith this bound in place, we are ready to give a full error analysis of our iterative method for applying pk((A TA+ λI)−1).\nLemma 4.1 (PCR approximation algorithm). Let A be a procedure that, given x ∈ Rd produces A(x) with ‖A(x)− (ATA+ λI)−1x‖ATA+λI = O( ǫq2σ1(A) )‖x‖2. Let B be a procedure that, given x ∈ R\nd produces B(x) with ‖B(x)−PAλx‖2 = O( ǫq2√κλ )‖x‖2. Given b ∈ R n set s0 := B(ATb) and s1 := A(s0). For k ≥ 1 set:\nsk+1 := s1 + λ · A(sk)\nIf all arithmetic operations are performed with Ω(log(d/qǫ)) bits of precision then ‖sq−A†λb‖ATA = O(ǫ)‖b‖2 for q = Θ(log(κλ/ǫ)).\nProof. Let s∗0 def = PAλA Tb, and for k ≥ 1\ns∗k = k ∑\ni=1\nλi−1M−is∗0\nFor ease of exposition, assume our accuracy bound on B gives ‖s0 − s∗0‖2 ≤ ǫq2√κλ ‖A Tb‖2 ≤\n√ λǫ/q2‖b‖2.\nAdjusting constants, the same proof with give Lemma 4.1 when error is actually O( √ λǫ/q2). By triangle inequality:\n‖s1 − s∗1‖M ≤ ‖s1 −M−1s0‖M + ‖M−1(s∗0 − s0)‖M (5)\n‖M−1(s∗0 − s0)‖M ≤ 1√λ‖s ∗ 0 − s0‖2 ≤ ǫ/q2‖b‖2. And by our accuracy bound on A:\n‖s1 −M−1s0‖M ≤ ǫ\nq2σ1(A) ‖s0‖2.\nApplying triangle inequality and the fact that the projection PAλ can only decrease norm we have:\nǫ\nq2σ1(A) ‖s0‖2 ≤\nǫ\nq2σ1(A) (‖s∗0‖2 + ‖s∗0 − s0‖2)\n≤ ǫ q2σ1(A) (\n‖ATb‖2 + √ λǫ/q2‖b‖2 )\n≤ 2ǫ/q2‖b‖2.\nPlugging back into (5) we finally have: ‖s1 − s∗1‖M ≤ 3ǫ/q2‖b‖2. Suppose we have for any k ≥ 1, ‖sk − s∗k‖M ≤ α‖b‖2.\n‖sk+1 − s∗k+1‖M ≤ ‖s1 − s∗1‖M + λ‖A(sk)−M−1s∗k‖M ≤ 3ǫ/q2‖b‖2 + λ‖A(sk)−M−1s∗k‖M.\nWe have:\nλ‖A(sk)−M−1s∗k‖M\n≤ λǫ q2σ1(A) ‖sk‖2 + λ‖M−1(sk − s∗k)‖M ≤ λǫ q2σ1(A) (‖s∗k‖2 + ‖sk − s∗k‖2) + α‖b‖2 ≤ λǫ q2σ1(A) ‖sk − s∗k‖2 + (α+ kǫ/q2)‖b‖2\nwhere the last step follows from: λǫq2σ1(A)‖s ∗ k‖2 ≤ λǫq2σ1(A) ∑k i=1 λ i−1‖M−is∗0‖2 ≤ kǫq2σ1(A)‖s ∗ 0‖2 ≤ kǫ/q2‖b‖2.\nNow, λǫq2σ1(A)‖sk − s ∗ k‖2 ≤ ǫ\n√ λ\nq2σ1(A) ‖sk − s∗k‖M ≤ ǫα/q2‖b‖2 since\n√ λ ≤ σ1(A).\nSo overall, presuming ‖sk − s∗k‖M ≤ α‖b‖2, we have ‖sk+1 − s∗k+1‖M ≤ [(1 + ǫ/q2)α+ (3 + k)ǫ/q2]‖b‖2. We know that ‖s1 − s∗1‖M ≤ 3ǫ/q2‖b‖2, so by induction we have:\n‖sq − s∗q‖M < (1 + ǫ/q2)q · q2ǫ/q2‖b‖2 < 3ǫ‖b‖2.\nFinally, applying the above bound, triangle inequality, and the polynomial approximation bound from Lemma B.2 we have:\n‖sq −A†λb‖ATA ≤ ‖sq − s∗q‖ATA + ‖s∗q −A † λb‖ATA\n≤ ( 3ǫ+ κλ 2q ) ‖b‖2 ≤ 4ǫ‖b‖2\nsince q = Θ(log(κλ/ǫ))."
    } ],
    "references" : [ {
      "title" : "In Proceedings of the 2014 IEEE International Symposium on Information Theory (ISIT)",
      "author" : [ "Christos Boutsidis", "Malik Magdon-Ismail. Faster SVD-truncated regularized least-squares" ],
      "venue" : "pages 1321–1325,",
      "citeRegEx" : "BMI14",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Computing truncated singular value decomposition least squares solutions by rank revealing qr-factorizations",
      "author" : [ "Tony F. Chan", "Per Christian Hansen" ],
      "venue" : "SIAM Journal on Scientific and Statistical Computing,",
      "citeRegEx" : "Chan and Hansen.,? \\Q1990\\E",
      "shortCiteRegEx" : "Chan and Hansen.",
      "year" : 1990
    }, {
      "title" : "In Proceedings of the 6th Conference on Innovations in Theoretical Computer Science (ITCS)",
      "author" : [ "Michael B. Cohen", "Yin Tat Lee", "Cameron Musco", "Christopher Musco", "Richard Peng", "Aaron Sidford. Uniform sampling for matrix approximation" ],
      "venue" : "pages 181–190,",
      "citeRegEx" : "CLM15",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "The Journal of Machine Learning Research",
      "author" : [ "Paramveer S. Dhillon", "Dean P. Foster", "Sham M. Kakade", "Lyle H. Ungar. A risk comparison of ordinary least squares vs ridge regression" ],
      "venue" : "14(1):1505–1511,",
      "citeRegEx" : "DFKU13",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Uniform approximation of sgn(x) by polynomials and entire functions",
      "author" : [ "Alexandre Eremenko", "Peter Yuditskii" ],
      "venue" : "Journal d’Analyse Mathmatique,",
      "citeRegEx" : "Eremenko and Yuditskii.,? \\Q2007\\E",
      "shortCiteRegEx" : "Eremenko and Yuditskii.",
      "year" : 2007
    }, {
      "title" : "Polynomials of the best uniform approximation to sgn(x) on two intervals",
      "author" : [ "Alexandre Eremenko", "Peter Yuditskii" ],
      "venue" : "Journal d’Analyse Mathématique,",
      "citeRegEx" : "Eremenko and Yuditskii.,? \\Q2011\\E",
      "shortCiteRegEx" : "Eremenko and Yuditskii.",
      "year" : 2011
    }, {
      "title" : "A statistical view of some chemometrics regression",
      "author" : [ "Ildiko E. Frank", "Jerome H. Friedman" ],
      "venue" : "tools. Technometrics,",
      "citeRegEx" : "Frank and Friedman.,? \\Q1993\\E",
      "shortCiteRegEx" : "Frank and Friedman.",
      "year" : 1993
    }, {
      "title" : "Un-regularizing: approximate proximal point and faster stochastic algorithms for empirical risk minimization",
      "author" : [ "Roy Frostig", "Rong Ge", "Sham M. Kakade", "Aaron Sidford" ],
      "venue" : "Proceedings of the 32nd International Conference on Machine Learning (ICML),",
      "citeRegEx" : "FGKS15",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Model Order Reduction: Theory, Research Aspects and Applications, chapter Matrix Functions, pages 275–303",
      "author" : [ "Andreas Frommer", "Valeria Simoncini" ],
      "venue" : null,
      "citeRegEx" : "Frommer and Simoncini.,? \\Q2008\\E",
      "shortCiteRegEx" : "Frommer and Simoncini.",
      "year" : 2008
    }, {
      "title" : "BIT Numerical Mathematics",
      "author" : [ "Per Christian Hansen. The truncated SVD as a method for regularization" ],
      "venue" : "27(4):534–553,",
      "citeRegEx" : "Han87",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "Functions of Matrices: Theory and Computation",
      "author" : [ "Nicholas J. Higham" ],
      "venue" : "Society for Industrial and Applied Mathematics,",
      "citeRegEx" : "Higham.,? \\Q2008\\E",
      "shortCiteRegEx" : "Higham.",
      "year" : 2008
    }, {
      "title" : "The relations of the newer multivariate statistical methods to factor analysis",
      "author" : [ "Harold Hotelling" ],
      "venue" : "British Journal of Statistical Psychology,",
      "citeRegEx" : "Hotelling.,? \\Q1957\\E",
      "shortCiteRegEx" : "Hotelling.",
      "year" : 1957
    }, {
      "title" : "Burges",
      "author" : [ "Yann LeCun", "Corinna Cortes", "Christopher J.C" ],
      "venue" : "MNIST handwritten digit database.",
      "citeRegEx" : "LCB15",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "In Advances in Neural Information Processing Systems 27 (NIPS)",
      "author" : [ "Qihang Lin", "Zhaosong Lu", "Lin Xiao. An accelerated proximal coordinate gradient method" ],
      "venue" : "pages 3059–3067,",
      "citeRegEx" : "LLX14",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "A method for unconstrained convex minimization problem with the rate of convergence o(1/k)",
      "author" : [ "Yurii Nesterov" ],
      "venue" : "In Soviet Mathematics Doklady,",
      "citeRegEx" : "Nesterov.,? \\Q1983\\E",
      "shortCiteRegEx" : "Nesterov.",
      "year" : 1983
    }, {
      "title" : "OSNAP: Faster numerical linear algebra algorithms via sparser subspace embeddings",
      "author" : [ "Jelani Nelson", "Huy L. Nguyên" ],
      "venue" : "In Proceedings of the 54th Annual IEEE Symposium on Foundations of Computer Science (FOCS),",
      "citeRegEx" : "Nelson and Nguyên.,? \\Q2013\\E",
      "shortCiteRegEx" : "Nelson and Nguyên.",
      "year" : 2013
    }, {
      "title" : "Mathematical Programming",
      "author" : [ "Shai Shalev-Shwartz", "Tong Zhang. Accelerated proximal stochastic dual coordinate ascent for regularized loss minimization" ],
      "venue" : "pages 1–41,",
      "citeRegEx" : "SSZ14",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Faster algorithms via approximation theory",
      "author" : [ "Sushant Sachdeva", "Nisheeth K. Vishnoi" ],
      "venue" : "Foundations and Trends in Theoretical Computer Science,",
      "citeRegEx" : "Sachdeva and Vishnoi.,? \\Q2014\\E",
      "shortCiteRegEx" : "Sachdeva and Vishnoi.",
      "year" : 2014
    }, {
      "title" : "Solution of incorrectly formulated problems and the regularization method",
      "author" : [ "Andrey Tikhonov" ],
      "venue" : "In Soviet Mathematics Doklady,",
      "citeRegEx" : "Tikhonov.,? \\Q1963\\E",
      "shortCiteRegEx" : "Tikhonov.",
      "year" : 1963
    }, {
      "title" : "Numerical methods for the QCD overlap operator I: Sign-function and error bounds",
      "author" : [ "Jasper van den Eshof", "Andreas Frommer", "Thomas Lippert", "Klaus Schilling", "Henk A. van der Vorst" ],
      "venue" : "Computer physics communications, 146(2):203–224,",
      "citeRegEx" : "vdEFL02",
      "shortCiteRegEx" : null,
      "year" : 2002
    } ],
    "referenceMentions" : [ {
      "referenceID" : 3,
      "context" : "Unfortunately, ridge regression is a very crude approximation to PCR and projection in many settings and may perform significantly worse in certain data analysis applications [DFKU13].",
      "startOffset" : 175,
      "endOffset" : 183
    }, {
      "referenceID" : 12,
      "context" : "Finally, we consider a large regression problem constructed from MNIST classification data [LCB15], with the goal of distinguishing handwritten digits {1,2,4,5,7} from the rest.",
      "startOffset" : 91,
      "endOffset" : 98
    } ],
    "year" : 2016,
    "abstractText" : "We show how to efficiently project a vector onto the top principal components of a matrix, without explicitly computing these components. Specifically, we introduce an iterative algorithm that provably computes the projection using few calls to any black-box routine for ridge regression. By avoiding explicit principal component analysis (PCA), our algorithm is the first with no runtime dependence on the number of top principal components. We show that it can be used to give a fast iterative method for the popular principal component regression problem, giving the first major runtime improvement over the naive method of combining PCA with regression. To achieve our results, we first observe that ridge regression can be used to obtain a “smooth projection” onto the top principal components. We then sharpen this approximation to true projection using a low-degree polynomial approximation to the matrix step function. Step function approximation is a topic of long-term interest in scientific computing. We extend prior theory by constructing polynomials with simple iterative structure and rigorously analyzing their behavior under limited precision.",
    "creator" : "LaTeX with hyperref package"
  }
}