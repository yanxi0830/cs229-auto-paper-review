{
  "name" : "1306.5362.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Statistical Perspective on Algorithmic Leveraging",
    "authors" : [ "Ping Ma", "Michael W. Mahoney", "Bin Yu" ],
    "emails" : [ "pingma@illinois.edu.", "mmahoney@cs.stanford.edu.", "binyu@stat.berkeley.edu." ],
    "sections" : [ {
      "heading" : null,
      "text" : "In this paper, we provide a simple yet effective framework to evaluate the statistical properties of algorithmic leveraging in the context of estimating parameters in a linear regression model with a fixed number of predictors. In particular, for several versions of leverage-based sampling, we derive results for the bias and variance, both conditional and unconditional on the observed data. We show that from the statistical perspective of bias and variance, neither leverage-based sampling nor uniform sampling dominates the other. This result is particularly striking, given the well-known result that, from the algorithmic perspective of worst-case analysis, leverage-based sampling provides uniformly superior worst-case algorithmic results, when compared with uniform sampling.\nBased on these theoretical results, we propose and analyze two new leveraging algorithms: one constructs a smaller least-squares problem with “shrinked” leverage scores (SLEV), and the other solves a smaller and unweighted (or biased) least-squares problem (LEVUNW). A detailed empirical evaluation of existing leverage-based methods as well as these two new methods is carried out on both synthetic and real data sets. The empirical results indicate that our theory is a good predictor of practical performance of existing and new leverage-based algorithms and that the new algorithms achieve improved performance. For example, with the same computation reduction as in the original algorithmic leveraging approach, our proposed SLEV typically leads to improved biases and variances both unconditionally and conditionally (on the observed data), and our proposed LEVUNW typically yields improved unconditional biases and variances.\n∗Department of Statistics, University of Illinois at Urbana-Champaign, Champaign, IL 61820. Email: pingma@illinois.edu. †Department of Mathematics, Stanford University, Stanford, CA 94305. Email: mmahoney@cs.stanford.edu. ‡Department of Statistics, University of California at Berkeley, Berkeley, CA 94720. Email: binyu@stat.berkeley.edu.\nar X\niv :1\n30 6.\n53 62\nv1 [\nst at\n.M E\n] 2\n3 Ju\nn 20\n13"
    }, {
      "heading" : "1 Introduction",
      "text" : "One popular method for dealing with large-scale data sets is sampling. In this approach, one first chooses a small portion of the full data, and then one uses this sample as a surrogate to carry out computations of interest for the full data. For example, one might randomly sample a small number of rows from an input matrix and use those rows to construct a low-rank approximation to the original matrix, or one might randomly sample a small number of constraints or variables in a regression problem and then perform a regression computation on the subproblem thereby defined. For many problems, it is very easy to construct “worst-case” input for which uniform random sampling will perform very poorly. Motivated by this, there has been a great deal of work on developing algorithms for matrix-based machine learning and data analysis problems that construct the random sample in a nonuniform data-dependent fashion [27].\nOf particular interest here is when that data-dependent sampling process selects rows or columns from the input matrix according to a probability distribution that depends on the empirical statistical leverage scores of that matrix. This recently-developed approach of algorithmic leveraging has been applied to matrix-based problems that are of interest in large-scale data analysis, e.g., least-squares approximation [11, 12], least absolute deviations regression [6, 29], and low-rank matrix approximation [28, 7]. Typically, the leverage scores are computed approximately [10, 6], or otherwise a random projection [1, 6] is used to precondition by approximately uniformizing them [12, 3, 30]. A detailed discussion of this approach can be found in the recent review monograph on randomized algorithms for matrices and matrix-based data problems [27].\nThis algorithmic leveraging paradigm has already yielded impressive algorithmic benefits: by preconditioning with a high-quality numerical implementation of a Hadamard-based random projection, the Blendenpik code of [3] “beats Lapack’s1 direct dense least-squares solver by a large margin on essentially any dense tall matrix;” the LSRN algorithm of [30] preconditions with a high-quality numerical implementation of a normal random projection in order to solve large over-constrained least-squares problems on clusters with high communication cost, e.g., on Amazon Elastic Cloud Compute clusters; the solution to the `1 regression or least absolute deviations problem as well as to quantile regression problems can be approximated for problems with billions of constraints [6, 44]; and CUR-based low-rank matrix approximations [28] have been used for structure extraction in DNA SNP matrices of size thousands of individuals by hundreds of thousands of SNPs [35, 34]. In spite of these impressive algorithmic results, none of this recent work on leveraging or leverage-based sampling addresses statistical aspects of this approach. This is in spite of the central role of statistical leverage, a traditional concept from regression diagnostics [21, 5, 41].\nIn this paper, we bridge that gap by providing the first statistical analysis of the algorithmic leveraging paradigm. We do so in the context of parameter estimation in fitting linear regression models for large-scale data—where, by “large-scale,” we mean that the data define a high-dimensional problem in terms of sample size n, as opposed to the dimension p of the parameter space. Although n p is the classical regime in theoretical statistics, it is a relatively new phenomenon that in practice we routinely see a sample size n in the hundreds of thousands or millions or more. This is a size regime where sampling methods such as algorithmic leveraging are indispensable to meet computational constraints.\nOur main theoretical contribution is to provide an analytic framework for evaluating the statistical properties of algorithmic leveraging. This involves performing a Taylor series analysis around the ordinary least-squares solution to approximate the subsampling estimators as linear combinations of random sampling matrices. Within this framework, we consider biases and\n1Lapack (short for Linear Algebra PACKage) is a high-quality and widely-used software library of numerical routines for solving a wide range of numerical linear algebra problems.\nvariances, both conditioned as well as not conditioned on the data, for several versions of the basic algorithmic leveraging procedure. We show that both leverage-based sampling and uniform sampling are unbiased to leading order; and that while leverage-based sampling improves the “sizescale” of the variance, relative to uniform sampling, the presence of very small leverage scores can inflate the variance considerably. It is well-known that, from the algorithmic perspective of worst-case analysis, leverage-based sampling provides uniformly superior worst-case algorithmic results, when compared with uniform sampling. However, our statistical analysis here reveals that from the statistical perspective of bias and variance, neither leverage-based sampling nor uniform sampling dominates the other.\nBased on these theoretical results, we propose and analyze two new leveraging algorithms designed to improve upon vanilla leveraging and uniform sampling algorithms in terms of bias and variance. The first of these (denoted SLEV below) involves increasing the probability of lowleverage samples, and thus it also has the effect of “shrinking” the effect of large leverage scores. The second of these (denoted LEVUNW below) constructs an unweighted version of the leveragesubsampled problem; and thus for a given data set it involves solving a biased subproblem. In both cases, we obtain the algorithmic benefits of leverage-based sampling, while achieving improved statistical performance.\nOur main empirical contribution is to provide a detailed evaluation of the statistical properties of these algorithmic leveraging estimators on both synthetic and real data sets. These empirical results indicate that our theory is a good predictor of practical performance for both existing algorithms and our two new leveraging algorithms as well as that our two new algorithms lead to improved performance. In addition, we show that using shrinked leverage scores typically leads to improved conditional and unconditional biases and variances; and that solving a biased subproblem typically yields improved unconditional biases and variances. By using a recentlydeveloped algorithm of [10] to compute fast approximations to the statistical leverage scores, we also demonstrate a regime for large data where our shrinked leveraging procedure is better algorithmically, in the sense of computing an answer more quickly than the usual black-box leastsquares solver, as well as statistically, in the sense of having smaller mean squared error than näıve uniform sampling. Depending on whether one is interested in results unconditional on the data (which is more traditional from a statistical perspective) or conditional on the data (which is more natural from an algorithmic perspective), we recommend the use of SLEV or LEVUNW, respectively, in the future.\nThe remainder of this article is organized as follows. We will start in Section 2 with a brief review of linear models, the algorithmic leveraging approach, and related work. Then, in Section 3, we will present our main theoretical results for bias and variance of leveraging estimators. This will be followed in Sections 4 and 5 by a detailed empirical evaluation on a wide range of synthetic and several real data sets. Then, in Section 6, we will conclude with a brief discussion of our results in a broader context. Appendix A will describe our results from the perspective of asymptotic relative efficiency and will consider several toy data sets that illustrate various aspects of algorithmic leveraging; and Appendix B will provide the proofs of our main theoretical results."
    }, {
      "heading" : "2 Background, Notation, and Related Work",
      "text" : "In this section, we will provide a brief review of relevant background, including our notation for linear models, an overview of the algorithmic leveraging approach, and a review of related work in statistics and computer science."
    }, {
      "heading" : "2.1 Least-squares and Linear Models",
      "text" : "We start with relevant background and notation. Given an n×p matrix X and an n-dimensional vector y, the least-squares (LS) problem is to solve\nargminβ∈Rp ||y −Xβ||2, (1)\nwhere || · || represents the Euclidean norm on Rn. Of interest is both a vector exactly or approximately optimizing Problem (1), as well as the value of the objective function at the optimum. Using one of several related methods [18], this LS problem can be solved exactly in O(np2) time (but, as we will discuss in Section 2.2, it can be solved approximately in o(np2) time2). For example, LS can be solved using the singular value decomposition (SVD): the so-called thin SVD of X can be written as X = UΛV T , where U is an n×p orthogonal matrix whose columns contain the left singular vectors of X, V is an p× p orthogonal matrix whose columns contain the right singular vectors of X, and the p×p matrix Λ = Diag {λi}, where λi, i = 1, . . . , p, are the singular values of X. In this case, β̂ols = V Λ\n−1UTy. We consider the use of LS for parameter estimation in a Gaussian linear regression model. Consider the model y = Xβ0 + , (2)\nwhere y is an n× 1 response vector, X is an n× p fixed predictor or design matrix, β0 is a p× 1 coefficient vector, and the noise vector ∼ N(0, σ2I). In this case, the unknown coefficient β0 can be estimated via maximum-likelihood estimation as\nβ̂ols = argminβ||y −Xβ||2 = (XTX)−1XTy, (3)\nin which case the predicted response vector is ŷ = Hy, where H = X(XTX)−1XT is the so-called Hat Matrix, which is of interest in classical regression diagnostics [21, 5, 41]. The ith diagonal element of H, hii = x T i (X TX)−1xi, where x T i is the i th row of X, is the statistical leverage of ith observation or sample. The statistical leverage scores have been used historically to quantify the extent to which an observation is an outlier [21, 5, 41], and they will be important for our main results below. Since H can alternatively be expressed as H = UUT , where U is any orthogonal basis for the column space of X, e.g., the Q matrix from a QR decomposition or the matrix of left singular vectors from the thin SVD, the leverage of the ith observation can also be expressed as\nhii = p∑ j=1 U2ij = ||ui||2, (4)\nwhere uTi is the i th row of U . Using Eqn. (4), the exact computation of hii, for i ∈ [n], requires O(np2) time [18] (but, as we will discuss in Section 2.2, they can be approximated in o(np2) time). For an estimate β̂ of β, the MSE (mean squared error) associated with the prediction error is defined to be\nMSE(β̂) = 1 n E [ (Xβ0 −Xβ̂)T (Xβ0 −Xβ̂) ] (5)\n= 1 n Tr ( Var [ Xβ̂ ]) + 1 n E [ (Xβ̂ −Xβ0)T (Xβ̂ −Xβ0) ] = 1 n Tr ( Var [ Xβ̂ ]) + 1 n [bias(Xβ̂)]T [bias(Xβ̂)]\n2Recall that, formally, f(n) = o(g(n)) as n→∞ means that for every positive constant there exists a constant N such that |f(n)| ≤ |g(n)|, for all n ≥ N . Informally, this means that f(n) grows more slowly than g(n). Thus, if the running time of an algorithm is o(np2) time, then it is asymptotically faster than any (arbitrarily small) constant times np2.\nwhere β0 is the true value of β. The MSE provides a benchmark to compare the different subsampling estimators, and we will be interested in both the bias and variance components."
    }, {
      "heading" : "2.2 Algorithmic Leveraging for Least-squares Approximation",
      "text" : "Here, we will review relevant work on random sampling algorithms for computing approximate solutions to the general overconstrained LS problem [11, 27, 10]. These algorithms choose (in general, nonuniformly) a subsample of the data, e.g., a small number of rows of X and the corresponding elements of y, and then they perform (typically weighted) LS on the subsample. Importantly, these algorithms make no assumptions on the input dataX and y, except that n p.\nA prototypical example of this approach is given by the following meta-algorithm [11, 27, 10], which we call SubsampleLS, and which takes as input an n× p matrix X, where n p, a vector y, and a probability distribution {πi}ni=1, and which returns as output an approximate solution β̃ols, which is an estimate of β̂ols of Eqn. (3).\n• Randomly sample r > p constraints, i.e., rows of X and the corresponding elements of y, using {πi}ni=1 as an importance sampling distribution.\n• Rescale each sampled row/element by 1/(rπi) to form a weighted LS subproblem.\n• Solve the weighted LS subproblem, formally given in Eqn. (6) below, and then return the solution β̃ols.\nIt is convenient to describe SubsampleLS in terms of a random “sampling matrix” STX and a random diagonal “rescaling matrix” (or “reweighting matrix”) D, in the following manner. If we draw r samples (rows or constraints or data points) with replacement, then define an r × n sampling matrix, STX , where each of the r rows of S T X has one non-zero element indicating which row of X (and element of y) is chosen in a given random trial. That is, if the kth data unit (or observation) in the original data set is chosen in the ith random trial, then the ith row of STX equals ek; and thus S T X is a random matrix that describes the process of sampling with replacement. As an example of applying this sampling matrix, when the sample size n = 6 and the subsample size r = 3, then premultiplying by\nSTX =  0 1 0 0 0 00 0 0 1 0 0 0 0 0 1 0 0  represents choosing the second, fourth, and fourth data points or samples. The resulting subsample of r data points can be denoted as (X∗,y∗), where X∗r×p = S T XX and y ∗ r×1 = S T Xy. In this case, an r×r diagonal rescaling matrix D can be defined so that ith diagonal element of D equals 1/ √ rπk if the k th data point is chosen in the ith random trial (meaning, in particular, that every\ndiagonal element of D equals √ n/r for uniform sampling). With this notation, SubsampleLS constructs and solves the weighted LS estimator :\nargminβ∈Rp ||DSTXy −DSTXXβ||2. (6)\nSince SubsampleLS samples constraints and not variables, the dimensionality of the vector β̃ols that solves the (still overconstrained, but smaller) weighted LS subproblem is the same as that of the vector β̂ols that solves the original LS problem. The former may thus be taken as an approximation of the latter, where, of course, the quality of the approximation depends critically on the choice of {πi}ni=1. There are several distributions that have been considered previously [11, 27, 10].\n• Uniform Subsampling. Let πi = 1/n, for all i ∈ [n], i.e., draw the sample uniformly at random.\n• Leverage-based Subsampling. Let πi = hii/ ∑n\ni=1 hii = hii/p be the normalized statistical leverage scores of Eqn. (4), i.e., draw the sample according to an importance sampling distribution that is proportional to the statistical leverage scores of the data matrix X.\nAlthough Uniform Subsampling (with or without replacement) is very simple to implement, it is easy to construct examples where it will perform very poorly (e.g., see below or see [11, 27]). On the other hand, it has been shown that, for a parameter γ ∈ (0, 1] to be tuned, if\nπi ≥ γ hii p , and r = O(p log(p)/(γ )), (7)\nthen the following relative-error bounds hold:\n||y −Xβ̃ols||2 ≤ (1 + )||y −Xβ̂ols||2 and (8) ||β̂ols − β̃ols||2 ≤ √ ( κ(X) √ ξ−2 − 1 ) ||β̂ols||2, (9)\nwhere κ(X) is the condition number of X and where ξ = ||UUTy||2/||y||2 is a parameter defining the amount of the mass of y inside the column space of X [11, 27, 10].\nDue to the crucial role of the statistical leverage scores in Eqn. (7), we refer to algorithms of the form of SubsampleLS as the algorithmic leveraging approach to approximating LS approximation. Several versions of the SubsampleLS algorithm are of particular interest to us in this paper. We start with two versions that have been studied in the past.\n• Uniform Sampling Estimator (UNIF) is the estimator resulting from uniform subsampling and weighted LS estimation, i.e., where Eqn. (6) is solved, where both the sampling and rescaling/reweighting are done with the uniform sampling probabilities. (Note that when the weights are uniform, then the weighted LS estimator of Eqn. (6) leads to the same solution as same as the unweighted LS estimator of Eqn. (11) below.) This version corresponds to vanilla uniform sampling, and it’s solution will be denoted by β̃UNIF .\n• Basic Leveraging Estimator (LEV) is the estimator resulting from exact leverage-based sampling and weighted LS estimation, i.e., where Eqn. (6) is solved, where both the sampling and rescaling/reweighting are done with the leverage-based sampling probabilities given in Eqn. (7). This is the basic algorithmic leveraging algorithm that was originally proposed in [11], where the exact empirical statistical leverage scores of X were first used to construct the subsample and reweight the subproblem, and it’s solution will be denoted by β̃LEV .\nMotivated by our statistical analysis (to come later in the paper), we will introduce two variants of SubsampleLS; since these are new to this paper, we also describe them here.\n• Shrinked Leveraging Estimator (SLEV) is the estimator resulting from a shrinked leverage-based sampling and weighted LS estimation. By shrinked leverage-based sampling, we mean that we will sample according to a distribution that is a convex combination of a leverage score distribution and the uniform distribution, thereby obtaining the benefits of each; and the rescaling/reweighting is done according to the same distribution. That is, if πLev denotes a distribution defined by the normalized leverage scores and πUnif denotes the uniform distribution, then the sampling and reweighting probabilities for SLEV are of the form\nπi = απ Lev i + (1− α)π Unif i , (10)\nwhere α ∈ (0, 1). Thus, with SLEV, Eqn. (6) is solved, where both the sampling and rescaling/reweighting are done with the probabilities given in Eqn. (10). This estimator will be denoted by β̃SLEV , and to our knowledge it has not been explicitly considered previously.\n• Unweighted Leveraging Estimator (LEVUNW) is the estimator resulting from a leverage-based sampling and unweighted LS estimation. That is, after the samples have been selected with leverage-based sampling probabilities, rather than solving the unweighted LS estimator of (6), we will compute the solution of the unweighted LS estimator :\nargminβ∈Rp ||STXy − STXXβ||2. (11)\nWhereas the previous estimators all follow the basic framework of sampling and rescaling/reweighting according to the same distribution (which is used in worst-case analysis to control the properties of both eigenvalues and eigenvectors and provide unbiased estimates of certain quantities within the analysis [11, 27, 10]), with LEVUNW they are essentially done according to two different distributions—the reason being that not rescaling leads to the same solution as rescaling with the uniform distribution. This estimator will be denoted by β̃LEV UNW , and to our knowledge it has not been considered previously.\nThese methods can all be used to estimate the coefficient vector β, and we will analyze—both theoretically and empirically—their statistical properties in terms of bias and variance."
    }, {
      "heading" : "2.3 Running Time Considerations",
      "text" : "Although it is not our main focus, the running time for leverage-based sampling algorithms is of interest. The running times of these algorithms depend on both the time to construct the probability distribution, {πi}ni=1, and the time to solve the subsampled problem. For UNIF, the former is trivial and the latter depends on the size of the subproblem. For estimators that depend on the exact or approximate (recall the flexibility in Eqn. (7) provided by γ) leverage scores, the running time is dominated by the exact or approximate computation of those scores. A näıve algorithm involves using a QR decomposition or the thin SVD of X to obtain the exact leverage scores. Unfortunately, this exact algorithm takes O(np2) time and is thus no faster than solving the original LS problem exactly. Of greater interest is the algorithm of [10] that computes relative-error approximations to all of the leverage scores of X in o(np2) time.\nIn more detail, given as input an arbitrary n×p matrix X, with n p, and an error parameter ∈ (0, 1), the main algorithm of [10] (described also in Section 5.2 below) computes numbers ˜̀ i, for all i = 1, . . . , n, that are relative-error approximations to the leverage scores hii, in the sense that |hii − ˜̀i| ≤ hii, for all i = 1, . . . , n. This algorithm runs in roughly O(np log(p)/ ) time,3 which for appropriate parameter settings is o(np2) time [10]. Given the numbers ˜̀i, for all i = 1, . . . , n, we can let πi = ˜̀i/ ∑n i=1 ˜̀ i, which then yields probabilities of the form of Eqn. (7) with (say) γ = 0.5 or γ = 0.9. Thus, we can use these πi in place of hii in BELV, SLEV, or LEVUNW, thus providing a way to implement these procedures in o(np2) time.\nThe running time of the relative-error approximation algorithm of [10] depends on the time needed to premultiply X by a randomized Hadamard transform (i.e., a “structured” random projection). Recently, high-quality numerical implementations of such random projections have been provided; see, e.g., Blendenpik [3], as well as LSRN [30], which extends these implementations\n3 In more detail, the asymptotic running time of the main algorithm of [10] is O ( np ln ( p −1 ) + np −2 lnn+ p3 −2 (lnn) ( ln ( p −1 ))) . To simplify this expression, suppose that p ≤ n ≤ ep and\ntreat as a constant; then, the asymptotic running time is O ( np lnn+ p3 (lnn) (ln p) ) .\nto large-scale parallel environments. These implementations demonstrate that, for matrices as small as several thousand by several hundred, leverage-based algorithms such as LEV and SLEV can be better in terms of running time than the computation of QR decompositions or the SVD with, e.g., Lapack. See [3, 30] for details, and see [17] for the application of these methods to the fast computation of leverage scores. Below, we will evaluate an implementation of a variant of the main algorithm of [10] in the software environment R."
    }, {
      "heading" : "2.4 Additional Related Work",
      "text" : "Our leverage-based methods for estimating β are related to resampling methods such as the bootstrap [13], and many of these resampling methods enjoy desirable asymptotic properties [40]. Resampling methods in linear models were studied extensively in [43] and are related to the jackknife [31, 32, 22, 14]. They usually produce resamples at a similar size to that of the full data, whereas algorithmic leveraging is primarily interested in constructing subproblems that are much smaller than the full data. In addition, the goal of resampling is traditionally to perform statistical inference and not to improve the running time of an algorithm, except in the very recent work [23]. Additional related work in statistics includes [20, 37, 26, 4, 36]."
    }, {
      "heading" : "3 Bias and Variance Analysis of Subsampling Estimators",
      "text" : "In this section, we develop analytic methods to study the biases and variances of the subsampling estimators described in Section 2.2. Analyzing these subsampling methods is challenging for at least the following two reasons: first, there are two layers of randomness in the estimators, i.e., the randomness inherent in the linear regression model as well as random subsampling of a particular sample from the linear model; and second, the estimators depends on random subsampling through the inverse of random sampling matrix, which is a nonlinear function. To ease the analysis, we will employ a Taylor series analysis to approximate the subsampling estimators as linear combinations of random sampling matrices, and we will consider biases and variances both conditioned as well as not conditioned on the data. Here is a brief outline of the main results of this section.\n• We will start in Section 3.1 with bias and variance results for weighted LS estimators for general sampling/reweighting probabilities. This will involve viewing the solution of the subsampled LS problem as a function of the vector of sampling/reweighting probabilities and performing a Taylor series expansion of the solution to the subsampled LS problem around the expected value (where the expectation is taken with respect to the random choices of the algorithm) of that vector.\n• Then, in Section 3.2, we will specialize these results to leverage-based sampling and uniform sampling, describing their complementary properties. We will see that, in terms of bias and variance, neither LEV nor UNIF is uniformly better than the other. In particular, LEV has variance whose size-scale is better than the size-scale of UNIF; but UNIF does not have leverage scores in the denominator of its variance expressions, as does LEV, and thus the variance of UNIF is not inflated on inputs that have very small leverage scores.\n• Finally, in Section 3.3, we will propose and analyze two new leveraging algorithms that will address deficiencies of LEV and UNIF in two different ways. The first, SLEV, constructs a smaller LS problem with “shrinked” leverage scores that are constructed as a convex combination of leverage score probabilities and uniform probabilities; and the second, LEVUNW,\nuses leverage-based sampling probabilities to construct and solve an unweighted or biased LS problem."
    }, {
      "heading" : "3.1 Traditional Weighted Sampling Estimators",
      "text" : "We start with the bias and variance of the traditional weighted sampling estimator β̃W , given in Eqn. (12) below. Recall that this estimator actually refers to a parameterized family of estimators, parameterized by the sampling/rescaling probabilities. The estimate obtained by solving the weighted LS problem of (6) can be represented as\nβ̃W = (X TSXD 2STXX) −1XTSTXD 2SXy\n= (XTWX)−1XTWy, (12)\nwhere W = SXD 2STX is an r × r diagonal random matrix, i.e., all off-diagonal elements are zeros, and where both SX and D are defined in terms of the sampling/rescaling probabilities. (In particular, W describes the probability distribution with which to draw the sample and with which to reweigh the subsample, where both are done according to the same distribution. Thus, this section does not apply to LEVUNW; see Section 3.3.2 for the extension to LEVUNW.) Although our results hold more generally, we are most interested in UNIF, LEV, and SLEV, as described in Section 2.2.\nClearly, the vector β̃W can be regarded as a function of the random weight vector w = (w1, w2, . . . , wn)\nT , denoted as β̃W (w), where (w1, w2, . . . , wn) are diagonal entries of W . Since we are performing random sampling with replacement, it is easy to see thatw = (w1, w2, . . . , wn) T has a scaled multinomial distribution,\nPr [ w1 =\nk1 rπ1 , w2 = k2 rπ2 , . . . , wn = kn rπn\n] =\nr!\nk1!k2! . . . , kn! πk11 π k2 2 · · ·π kn n ,\nand thus it can easily be shown that E [w] = 1. By setting w0, the vector around which we will perform our Taylor series expansion, to be the all-ones vector, i.e., w0 = 1, then β̃(w) can be expanded around the full sample ordinary LS estimate β̂ols, i.e., β̃W (1) = β̂ols. From this, we can establish the following lemma, the proof of which may be found in Section B.1.\nLemma 1. Let β̃W be the output of the SubsampleLS Algorithm, obtained by solving the weighted LS problem of (6). Then, a Taylor expansion of β̃W around the point w0 = 1 yields\nβ̃W = β̂ols + (X TX)−1XTDiag {ê} (w − 1) +RW , (13)\nwhere ê = y−Xβ̂ols is the LS residual vector, and where RW is the Taylor expansion remainder.\nRemark. The significance of Lemma 1 is that, to leading order, the vector w that encodes information about the sampling process and subproblem construction enters the estimator of β̃W linearly. The additional error, RW depends strongly on the details of the sampling process, and in particular will be very different for UNIF, LEV, and SLEV. Remark. Our approximations hold when the Taylor series expansion is valid, i.e., when RW is “small,” e.g., RW = op(||w −w0||), where op(·) means “little o” with high probability over the randomness in the random vector w. Although we will evaluate the quality of our approximations empirically in Sections 4 and 5, we currently do not have a precise theoretical characterization of when this holds. Here, we simply make two observations. First, this expression will fail to hold if rank is lost in the sampling process. This is because in general there will be a bias due to failing to capture information in the dimensions that are not represented in the sample. (Recall\nthat one may use the Moore-Penrose generalized inverse for inverting rank-deficient matrices.) Second, this expression will tend to hold better as the subsample size r is increased. However, for a fixed value of r, the linear approximation regime will be larger when the sample is constructed using information in the leverage scores—since, among other things, using leverage scores in the sampling process is designed to preserve the rank of the subsampled problem [11, 27, 10]. A detailed discussion of this last point is available in [27]; and these observations will be confirmed empirically in Section 5. Remark. Since, essentially, LEVUNW involves sampling and reweighting according to two different distributions4, the analogous expression for LEVUNW will be somewhat different, as will be discussed in Lemma 5 in Section 3.3.\nGiven Lemma 1, we can establish the following lemma, which provides expressions for the conditional and unconditional expectations and variances for the weighted sampling estimators. The first two expressions in the lemma are conditioned on the data vector y5; and the last two expressions in the lemma provide similar results, except that they are not conditioned on the data vector y. The proof of this lemma appears in Section B.2.\nLemma 2. The conditional expectation and conditional variance for the traditional algorithmic leveraging procedure, i.e., when the subproblem solved is a weighted LS problem of the form (6), are given by:\nEw [ β̃W |y ] = β̂ols + Ew [RW ] ; (14)\nVarw [ β̃W |y ] =(XTX)−1XT [ Diag {ê}Diag { 1\nrπ\n} Diag {ê} ] X(XTX)−1+Varw [RW ] ,(15)\nwhere W specifies the probability distribution used in the sampling and rescaling steps. The unconditional expectation and unconditional variance for the traditional algorithmic leveraging procedure are given by:\nE [ β̃W ] =β0 + E [RW ] ; (16)\nVar [ β̃W ] =σ2(XTX)−1 + σ2\nr (XTX)−1XTDiag\n{ (1− hii)2\nπi\n} X(XTX)−1 + Var [RW ] . (17)\nRemark. Eqn. (14) states that, when the Ew [RW ] term is negligible, i.e., when the linear approximation is valid, then, conditioning on the observed data y, the estimate β̃W is approximately unbiased, relative to the full sample ordinarily LS estimate β̂ols; and Eqn. (16) states that, when the E [RW ] term is negligible, then the estimate β̃W is approximately unbiased, relative to the “true” value β0 of the parameter vector β. That is, given a particular data set (X,y), the conditional expectation result of Eqn. (14) states that the leveraging estimators can approximate well β̂ols; and, as a statistical inference procedure for arbitrary data sets, the unconditional expectation result of Eqn. (16) states that the leveraging estimators can infer well β0. Remark. Both the conditional variance of Eqn. (15) and the (second term of the) unconditional variance of Eqn. (17) are inversely proportional to the subsample size r; and both contain a sandwich-type expression, the middle of which depends on how the leverage scores interact with the sampling probabilities. Moreover, the first term of the unconditional variance, σ2(XTX)−1, equals the variance of the ordinary LS estimator; this implies, e.g., that the unconditional variance of Eqn. (17) is larger than the variance of the ordinary LS estimator, which is consistent with the Gauss-Markov theorem.\n4In this case, the latter distribution is the uniform distribution, where recall that reweighting uniformly leads to the same solution as not reweighting at all.\n5Here and below, the subscript w on Ew and Varw refers to performing expectations and variances with respect to (just) the random weight vector w and not the data."
    }, {
      "heading" : "3.2 Leverage-based Sampling and Uniform Sampling Estimators",
      "text" : "Here, we specialize Lemma 2 by stating two lemmas that provide the conditional and unconditional expectation and variance for LEV and UNIF, and we will discuss the relative merits of each procedure. The proofs of these two lemmas are immediate, given the proof of Lemma 2. Thus, we omit the proofs, and instead discuss properties of the expressions that are of interest in our empirical evaluation.\nOur main conclusion here is that Lemma 3 and Lemma 4 highlight that the statistical properties of the algorithmic leveraging method can be quite different than the algorithmic properties. Prior work has adopted an algorithmic perspective that has focused on providing worst-case running time bounds for arbitrary input matrices. From this algorithmic perspective, leverage-based sampling (i.e., explicitly or implicitly biasing toward high-leverage components, as is done in particular with the LEV procedure) provides uniformly superior worst-case algorithmic results, when compared with UNIF [11, 27, 10]. Our analysis here reveals that, from a statistical perspective where one is interested in the bias and variance properties of the estimators, the situation is considerably more subtle. In particular, a key conclusion from Lemmas 3 and 4 is that, with respect to their variance or MSE, neither LEV nor UNIF is uniformly superior for all input.\nWe start with the bias and variance of the leverage subsampling estimator β̃LEV .\nLemma 3. The conditional expectation and conditional variance for the LEV procedure are given by:\nEw [ β̃LEV |y ] = β̂ols + Ew [RLEV ] ;\nVarw [ β̃LEV |y ] = p\nr (XTX)−1XT\n[ Diag {ê}Diag { 1\nhii\n} Diag {ê} ] X(XTX)−1+Varw [RLEV ] .\nThe unconditional expectation and unconditional variance for the LEV procedure are given by: E [ β̃LEV ] = β0 + E [RLEV ] ;\nVar [ β̃LEV ] = σ2(XTX)−1 + pσ2\nr (XTX)−1XTDiag\n{ (1− hii)2\nhii\n} X(XTX)−1\n+ Var [RLEV ] . (18)\nRemark. Two points are worth making. First, the variance expressions for LEV depend on the size (i.e., the number of columns and rows) of the n×p matrix X and the number of samples r as p/r. This variance size-scale many be made to be very small if p r n. Second, the sandwichtype expression depends on the leverage scores as 1/hii, implying that the variances could be inflated to arbitrarily large values by very small leverage scores. Both of these observations will be confirmed empirically in Section 4.\nWe next turn to the bias and variance of the uniform subsampling estimator β̃UNIF .\nLemma 4. The conditional expectation and conditional variance for the UNIF procedure are given by:\nEw [ β̃UNIF |y ] = β̂ols + Ew [RUNIF ]\nVarw [ β̃UNIF |y ] = n\nr (XTX)−1XT [Diag {ê}Diag {ê}]X(XTX)−1 + Varw [RUNIF ] . (19)\nThe unconditional expectation and unconditional variance for the UNIF procedure are given by: E [ β̃UNIF ] = β0 + E [RUNIF ] ;\nVar [ β̃UNIF ] = σ2(XTX)−1 + n\nr σ2(XTX)−1XTDiag\n{ (1− hii)2 } X(XTX)−1\n+ Var [RUNIF ] . (20)\nRemark. Two points are worth making. First, the variance expressions for UNIF depend on the size (i.e., the number of columns and rows) of the n×p matrix X and the number of samples r as n/r. Since this variance size-scale is very large, e.g., compared to the p/r from LEV, these variance expressions will be large unless r is nearly equal to n. Second, the sandwich-type expression is not inflated by very small leverage scores. Remark. Apart from a factor n/r, the conditional variance for UNIF, as given in Eqn. (19), is the same as Hinkley’s weighted jackknife variance estimator [20]."
    }, {
      "heading" : "3.3 Novel Leveraging Estimators",
      "text" : "In view of Lemmas 3 and 4, we consider several ways to take advantage of the complementary strengths of the LEV and UNIF procedures. Recall that we would like to sample with respect to probabilities that are “near” those defined by the empirical statistical leverage scores. We at least want to identify large leverage scores to preserve rank. This helps ensure that the linear regime of the Taylor expansion is large, and it also helps ensure that the scale of the variance is p/r and not n/r. But we would like to avoid rescaling by 1/hii when certain leverage scores are extremely small, thereby avoiding inflated variance estimates."
    }, {
      "heading" : "3.3.1 The Shrinked Leveraging (SLEV) Estimator",
      "text" : "Consider first the SLEV procedure. As described in Section 2.2, this involves sampling and reweighting with respect to a distribution that is a convex combination of the empirical leverage score distribution and the uniform distribution. That is, let πLev denote a distribution defined by the normalized leverage scores (i.e., πLevi = hii/p, or π\nLev is constructed from the output of the algorithm of [10] that computes relative-error approximations to the leverage scores), and let πUnif denote the uniform distribution (i.e., πUnifi = 1/n, for all i ∈ [n]); then the sampling probabilities for the SLEV procedure are of the form\nπi = απ Lev i + (1− α)π Unif i , (21)\nwhere α ∈ (0, 1). Since SLEV involves solving a weighted LS problem of the form of Eqn. (6), expressions of the form provided by Lemma 2 hold immediately. In particular, SLEV enjoys approximate unbiasedness, in the same sense that the LEV and UNIF procedures do. The particular expressions for the higher order terms can be easily derived, but they are much messier and less transparent than the bounds provided by Lemmas 3 and 4 for LEV and UNIF, respectively. Thus, rather than presenting them, we simply point out several aspects of the SLEV procedure that should be immediate, given our earlier theoretical discussion.\nFirst, note that mini πi ≥ (1 − α)/n, with equality obtained when hii = 0. Thus, assuming that 1−α is not extremely small, e.g., 1−α = 0.1, then none of the SLEV sampling probabilities is too small, and thus the variance of the SLEV estimator does not get inflated too much, as it could with the LEV estimator. Second, assuming that 1−α is not too large, e.g., 1−α = 0.1, then Eqn. (7) is satisfied with γ = 1.1, and thus the amount of oversampling that is required, relative\nto the LEV procedure, is not much, e.g., 10%. In this case, the variance of the SLEV procedure has a scale of p/r, as opposed to n/r scale of UNIF, assuming that r is increased by that 10%. Third, since Eqn. (21) is still required to be a probability distribution, combining the leverage score distribution with the uniform distribution has the effect of not only increasing the very small scores, but it also has the effect of performing shrinkage on the very large scores. Finally, all of these observations also hold if, rather that using the exact leverage score distribution (which recall takes O(np2) time to compute), we instead use approximate leverage scores, as computed with the fast algorithm of [10]. For this reason, this approximate version of the SLEV procedure is the most promising for very large-scale applications."
    }, {
      "heading" : "3.3.2 The Unweighted Leveraging (LEVUNW) Estimator",
      "text" : "Consider next the LEVUNW procedure. As described in Section 2.2, this estimator is different than the previous estimators, in that the sampling and reweighting are done according to different distributions. (Since LEVUNW does not sample and reweight according to the same probability distribution, our previous analysis does not apply.) Thus, we shall examine the bias and variance of the unweighted leveraging estimator β̃LEV UNW . To do so, we first use a Taylor series expansion to get the following lemma, the proof of which may be found in Section B.3.\nLemma 5. Let β̃LEV UNW be the output of the modified SubsampleLS Algorithm, obtained by solving the unweighted LS problem of (11). Then, a Taylor expansion of β̃LEV UNW around the point w0 = rπ yields\nβ̃LEV UNW = β̂wls + (X TW0X) −1XTDiag {êw} (w − rπ) +RLEV UNW , (22)\nwhere β̂wls = (X TW0X) −1XW0y is the full sample weighted LS estimator, êw = y−Xβ̂wls is the LS residual vector, W0 = Diag {rπ} = Diag {rhii/p}, and RLEV UNW is the Taylor expansion remainder.\nRemark. This lemma is analogous to Lemma 1. Since the sampling and reweighting are performed according to different distributions, however, the point about which the Taylor expansion is performed, as well as the prefactors of the linear term, are somewhat different. In particular, here we expand around the point w0 = rπ since E [w] = rπ when no reweighting takes place.\nGiven this Taylor expansion lemma, we can now establish the following lemma for the mean and variance of LEVUNW, both conditioned and unconditioned on the data y. The proof of the following lemma may be found in Section B.4.\nLemma 6. The conditional expectation and conditional variance for the LEVUNW procedure are given by:\nEw [ β̃LEV UNW |y ] = β̂wls + Ew [RLEV UNW ] ;\nVarw [ β̃LEV UNW |y ] = (XTW0X) −1XTDiag {êw}W0Diag {êw}X(XTW0X)−1\n+ Varw [RLEV UNW ] .\nwhere W0 = Diag {rπ}, and where β̂wls = (XTW0X)−1XW0y is the full sample weighted LS estimator. The unconditional expectation and unconditional variance for the LEVUNW procedure\nare given by: E [ β̃LEV UNW ] = β0 + E [RLEV UNW ] ;\nVar [ β̃LEV UNW ] = σ2(XTW0X) −1XTW 20X(X TW0X) −1\n+ σ2(XTW0X) −1XTDiag {I − PX,W0}W0Diag {I − PX,W0}X(XTW0X)−1 + Var [RLEV UNW ] (23)\nwhere PX,W0 = X(X TW0X) −1XTW0.\nRemark. The two expectation results in this lemma state: (i), when Ew [RLEV UNW ] is negligible, then, conditioning on the observed data y, the estimator β̃LEV UNW is approximately unbiased, relative to the full sample weighted LS estimator β̂wls; and (ii), when E [RLEV UNW ] is negligible, then the estimator β̃LEV UNW is approximately unbiased, relative to the “true” value β0 of the parameter vector β. That is, if we apply LEVUNW to a given data set N times, then the average of the N LEVUNW estimates are not centered at the LS estimate, but instead are centered roughly at the weighted least squares estimate; while if we generate many data sets from the true model and apply LEVUNW to these data sets, then the average of these estimates is roughly centered around true value β0. Remark. As expected, when the leverage scores are all the same, the variance in Eqn. (23) is the same as the variance of uniform random sampling. This is expected since, when reweighting with respect to the uniform distribution, one does not change the problem being solved, and thus the solutions to the weighted and unweighted LS problems are identical. More generally, the variance is not inflated by very small leverage scores, as it is with LEV. For example, the conditional variance expression is also a sandwich-type expression, the center of which is W0 = Diag {rhii/n}, which is not inflated by very small leverage scores."
    }, {
      "heading" : "4 Main Empirical Evaluation",
      "text" : "In this section, we describe the main part of our empirical analysis of the behavior of the biases and variances of the subsampling estimators described in Section 2.2. Additional empirical results will be presented in Section 5. In these two sections, we will consider both synthetic data as well as real data that have been chosen to illustrate the extreme properties of the subsampling methods in realistic settings. We will use the MSE as a benchmark to compare the different subsampling estimators; but since we are interested in both the bias and variance properties of our estimates, we will present results for both the bias and variance separately.\nHere is a brief outline of the main results of this section.\n• In Section 4.1, we will describe our synthetic data. These data are drawn from three standard distributions, and they are designed to provide relatively-realistic synthetic examples where leverages scores are fairly uniform, moderately nonuniform, or very nonuniform.\n• Then, in Section 4.2, we will summarize our results for the unconditional bias and variance for LEV and UNIF, when applied to the synthetic data.\n• Then, in Section 4.3, we will summarize our results for the unconditional bias and variance of SLEV and LEVUNW. This will illustrate that both SLEV and LEVUNW can overcome some of the problems associated with LEV and UNIF.\n• Finally, in Section 4.4, we will present our results for the conditional bias and variance of SLEV and LEVUNW (as well as LEV and UNIF). In particular, this will show that LEVUNW can incur substantial bias, relative to the other methods, when conditioning on a given data set."
    }, {
      "heading" : "4.1 Description of Synthetic Data",
      "text" : "We consider synthetic data of 1000 runs generated from y = Xβ + , where ∼ N(0, 9In), where several different values of n and p, leading to both “very rectangular” and “moderately rectangular” matrices X, are considered. The design matrix X is generated from one of three different classes of distributions introduced below. These three distributions were chosen since the first has nearly uniform leverage scores, the second has mildly non-uniform leverage scores, and the third has very non-uniform leverage scores.\n• Nearly uniform leverage scores (GA). We generated an n × p matrix X from multivariate normal N(1p,Σ), where the (i, j)th element of Σij = 2× 0.5|i−j|, and where we set β = (110, 0.11p−20,110) T . (Referred to as GA data.)\n• Moderately nonuniform leverage scores (T3). We generated X from multivariate tdistribution with 3 degree of freedom and covariance matrix Σ as before. (Referred to as T3 data.)\n• Very nonuniform leverage scores (T1). We generatedX from multivariate t-distribution with 1 degree of freedom and covariance matrix Σ as before. (Referred to as T1 data.)\nSee Table 4.1 for a summary of the parameters for the synthetic data we considered and for basic summary statistics for the leverage scores probabilities (i.e., the leverage scores that have been normalized to sum to 1 by dividing by p) of these data matrices. The results reported in Table 4.1 are for leverage score statistics for a single fixed data matrix X generated in the above manner (for each of the 3 procedures and for each value of n and p), but we have confirmed that similar results hold for other matrices X generated in the same manner.\nSeveral observations are worth making about the summaries presented in Table 4.1. First, and as expected, the Gaussian data tend to have the most uniform leverage scores, the T3 data are intermediate, and the T1 data have the most nonuniform leverage scores, as measured by both the standard deviation of the scores as well as the ratio of maximum to minimum leverage score. Second, the standard deviation of the leverage score distribution is substantially less sensitive to nonuniformities in the leverage scores than is the ratio of the maximum to minimum leverage score (or the maximum to the mean/median score, although all four measures exhibit the same qualitative trends). Although we have not pursued it, this suggests that these latter measures will be more informative as to when leverage-based sampling might be necessary in a particular application. Third, in all these cases, the variability trends are caused both by the large (in particular, the maximum) leverage scores increasing as well as the small (in particular, the minimum) leverage score decreasing. Fourth, within a given type of distribution (i.e., GA or T3 or T1), leverage scores are more nonuniform when the matrix X is more rectangular, and this is true both when n is held fixed and when p is held fixed."
    }, {
      "heading" : "4.2 Leveraging Versus Uniform Sampling on Synthetic Data",
      "text" : "Here, we will describe the properties of LEV versus UNIF for synthetic data. See Figures 1, 2, and 3 for the results on data matrices with n = 1000 and p = 10, 50, and 100, respectively. (The results for data matrices for n = 5000 and other values of n are similar.) In each case, we\ngenerated a single matrix from that distribution (which we then fixed to generate the y vectors) and β0 was set to be the all-ones vector; and then we ran the sampling process multiple times, typically ca. 1000 times, in order to obtain reliable estimates for the biases and variances. In each of the Figures 1, 2, and 3, the top panel is the variance, the bottom panel is the squared bias; for both the bias and variance, we have plotted the results in log-scale; and, in each figure, the first column is the GA model, the middle column is the T3 model, and the right column is the T1 model.\nThe simulation results corroborate what we have learned from our theoretical analysis, and there are several things worth noting. First, in general the squared bias is much less than the variance, even for the T1 data, suggesting that the solution is approximately unbiased, at least for the values of r plotted here, in the sense quantified in Lemmas 3 and 4. Second, LEV and UNIF perform very similarly for GA, somewhat less similarly for T3, and quite differently for T1, consistent with the results in Table 4.1 that indicate that the leverage scores are very uniform for GA and very nonuniform for T1. In addition, when they are different, LEV tends to perform better than UNIF, i.e., have a lower MSE for a fixed sampling complexity. Third, as the subsample size increases, the squared bias and variance tend to decrease monotonically. In particular, the variance tends to decrease roughly as 1/r, where r is the size of the subsample, in agreement with Lemmas 3 and 4. Moreover, the decrease for UNIF is much slower, in a manner more consistent with the leading term of n/r in Eqn. (20), than is the decrease for LEV, which by Eqn. (18)\nhas leading term p/r. Fourth, for all three models, both the bias and variance tend to increase when the matrix is less rectangular, e.g., as p increases 10 to 100 for n = 1000. All in all, LEV is comparable to or outperforms UNIF, especially when the leverage scores are nonuniform."
    }, {
      "heading" : "4.3 Improvements from Shrinked Leveraging and Unweighted Leveraging",
      "text" : "Here, we will describe how our proposed SLEV and LEVUNW procedures can both lead to improvements relative to LEV and UNIF. Recall that LEV can lead to large MSE by inflating very small leverage scores. The SLEV procedure deals with this by considering a convex combination of the uniform distribution and the leverage score distribution, thereby providing a lower bound on the leverage scores; and the LEVUNW procedure deals with this by not rescaling the subproblem to be solved.\nConsider Figures 4, 5, and 6, which present the variance and bias for synthetic data matrices (for GA, T3, and T1 data) of size n × p, where n = 1000 and p = 10, 50, and 100, respectively. In each case, LEV, SLEV for three different values of the convex combination parameter α, and LEVUNW were considered. Several observations are worth making. First of all, for GA data (left panel in these figures), all the results tend to be quite similar; but for T3 data (middle panel) and even more so for T1 data (right panel), differences appear. Second, SLEV with α ' 0.1, i.e., when SLEV consists mostly of the uniform distribution, is notably worse in a manner similarly as with UNIF. Moreover, there is a gradual decrease in both bias and variance for our proposed SLEV as α is increased; and when α ' 0.9 SLEV is slightly better than LEV. Finally, our proposed\nLEVUNW often has the smallest bias and variance over a wide range of subsample sizes for both T3 and T1, although the effect is not major. All in all, these observations are consistent with our main theoretical results.\nConsider next Figure 7. This figure examines the optimal convex combination choice for α in SLEV, and α is the x-axis in all the plots. Different column panels in Figure 7 correspond to different subsample sizes r. Recall that there are two conflicting goals for SLEV: adding (1−α)/n to the small leverage scores will avoid substantially inflating the variance of the resulting estimate by samples with extremely small leverage scores; and doing so will lead to larger sample size r in order to obtain bounds of the form Eqns. (8) and (9). Figure 7 plots the variance and bias for T1 data for a range of parameter values and for a range of subsample sizes. In general, one sees that using SLEV to increase the probability of choosing small leverage components with α around 0.8− 0.9 (and relatedly shrinking the effect of large leverage components) has a beneficial effect on bias as well as variance. This is particularly true in two cases: first, when the matrix is very rectangular, e.g., when the p = 10, which is consistent with the leverage score statistics from\nTable 4.1; and second, when the subsample size r is larger, as the results for r = 3p are much choppier (and for r = 2p, they are still choppier). As a rule of thumb, these plots suggest that choosing α = 0.9, and thus using πi = απ Lev\ni +(1−α)/n as the importance sampling probabilities,\nstrikes a balance between needing more samples and avoiding variance inflation. One can also see in Figure 7 the grey lines, dots, and dashes, which correspond to LEVUNW for the corresponding values of p, that LEVUNW consistently has smaller variances than SLEV for all values of α. We should emphasize, though, that these are unconditional biases and variances. Since LEVUNW is approximately unbiased relative to the full sample weighted LS estimate β̂wls, however, there is a large bias away from the full sample unweighted LS estimate β̂ols. This suggests that LEVUNW may be used when the primary goal is to infer the true β0; but that\nwhen the primary goal is rather to approximate the full sample unweighted LS estimate, or when conditional biases and variances are of interest, then SLEV may be more appropriate. We will discuss this in greater detail in Section 4.4 next."
    }, {
      "heading" : "4.4 Conditional Bias and Variance",
      "text" : "Here, we will describe the properties of the conditional bias and variance under various subsampling estimators. These will provide a more direct comparison with Eqns. (14) and (15) from Lemma 2 and the corresponding bounds from Lemma 6. These will also provide a more direct comparison with previous work that has adopted an algorithmic perspective on algorithmic leveraging [11, 27, 10].\nConsider Figure 8, which presents our main empirical results for conditional biases and variances. As before, matrices were generated from GA, T3 and T1; and we calculated the empirical bias and variance of UNIF, LEV, SLEV with α = 0.9, and LEVUNW—in all cases, conditional on the empirical data y. Several observations are worth making. First, for GA the variances are all very similar the same; and the biases are also, with the exception of LEVUNW. This is expected, since by the conditional expectation bounds from Lemma 6, LEVUNW is approximately unbiased, relative to the full sample weighted LS estimate β̂wls—and thus there should be a large bias away from the full sample unweighted LS estimate. Second, for T3 and even more prominently for T1, the variance of LEVUNW is less than that for the other estimators. Third, when the leverage scores are very nonuniform, as with T1, the relative merits of UNIF versus LEVUNW depend on the subsample size r. In particular, the bias of LEVUNW is larger than that of even UNIF for very aggressive downsampling; but it is substantially less than UNIF for moderate to large sample sizes.\nBased on these and our other results, our default recommendation is to use SLEV (with either exact or approximate leverage scores) with α ≈ 0.9: it is no more than slightly worse than LEVUNW when considering unconditional biases and variances, and it can be much better than LEVUNW when considering conditional biases and variances."
    }, {
      "heading" : "5 Additional Empirical Evaluation",
      "text" : "In this section, we provide additional empirical results (of a more specialized nature than those presented in Section 4). Here is a brief outline of the main results of this section.\n• In Section 5.1, we will consider the synthetic data, and we will describe what happens when the subsampled problem looses rank. This can happen if one is extremely aggressive in downsampling with SLEV; but it is much more common with UNIF, even if one samples many constraints. In both cases, the behavior of bias and variance is very different than when rank is preserved.\n• Then, in Section 5.2, we will summarize our results on synthetic data when the leverage scores are computed approximately with the fast approximation algorithm of [10]. Among other things, we will describe the running time of this algorithm, illustrating that it can solve larger problems than can be solved with traditional deterministic methods; and we will evaluate the unconditional bias and variance of SLEV when this algorithm is used to approximate the leverage scores.\n• Finally, in Section 5.3, we will consider real data, and we will present our results for the conditional bias and variance for two data sets that are drawn from our previous work in two genetics applications. One of these has very uniform leverage scores, and the other has moderately nonuniform leverage scores; and our results from the synthetic data hold also in these realistic applications."
    }, {
      "heading" : "5.1 Leveraging and Uniform Estimates for Singular Subproblems",
      "text" : "Here, we will describe the properties of LEV versus UNIF for situations in which rank is lost in the construction of the subproblem. That is, in some cases, the subsampled matrix, X∗, may have column rank that is smaller than the rank of the original matrix X, and this leads to a singular X∗TX∗ = XTWX. Of course, the LS solution of the subproblem can still be solved, but there will be a “bias” due to the dimensions that are not represented in the subsample. (We use the Moore-Penrose generalized inverse to compute the estimators when rank is lost in the construction of the subproblem.) Before describing these results, recall that algorithmic leveraging (in particular, LEV, but it holds for SLEV as well) guarantees that this will not happen in the following sense: if roughly O(p log p) rows of X are sampled using an importance sampling distribution that approximates the leverage scores in the sense of Eqn. (7), then with very high probability the matrix X∗ does not loose rank [11, 27, 10]. Indeed, this observation is crucial from the algorithmic perspective, i.e., in order to obtain relative-error bounds of the form of Eqns. (8) and (9), and thus it was central to the development of algorithmic leveraging. On the other hand, if one downsamples more aggressively, e.g., if one samples only, say, p+ 100 or p+ 10 rows, or if one uses uniform sampling when the leverage scores are very nonuniform, then it is possible to loose rank. Here, we examine the statistical consequences of this.\nWe have observed this phenomenon with the synthetic data for both UNIF as well as for leverage-based sampling procedures; but the properties are somewhat different depending on the sampling procedure. To illustrate both of these with a single synthetic example, we first generated a 1000 × 10 matrix from multivariate t-distribution with 3 (or 2 or 1, denoted T3, T2, and T1, respectively) degrees of freedom and covariance matrix Σij = 2 × 0.5|i−j|; we then calculated the leverage scores of all rows; and finally we formed the matrix X was by keeping the 50 rows with highest leverage scores and replicating 950 times the row with the smallest leverage score. (This is a somewhat more realistic version of the toy Worst-case Matrix that is described in Section A.2.) We then applied LEV and UNIF to the data sets with different subsample sizes, as we did for the results summarized in Section 4.2. Our results are summarized in Figure 9 and 10.\nThe top row of Figure 9 plots the fraction of singular XTWX, out of 500 trials, for both LEV and UNIF; from left to right, results for T3, T2, and T1 are shown. Several points are worth emphasizing. First, both LEV and UNIF loose rank if the downsampling is sufficiently aggressive. Second, for LEV, as long as one chooses more than roughly 20 (or less for T2 and T1), i.e., the ratio r/p is at least roughly 2, then rank is not lost; but for uniform sampling, one must sample a much larger fraction of the data. In particular, when fewer than r = 100 samples are drawn then nearly all of the subproblems constructed with the UNIF procedure are singular, and it is not until more than r = 300 that nearly all of the subproblems are not singular. Although these particular numbers depend on the particular data, needing to draw many more samples with UNIF than with LEV in order to preserve rank is a very general phenomenon. The middle row of Figure 9 shows the boxplots of rank for the subproblem for LEV for those 500 tries; and the bottom row shows the boxplots of the rank of the subproblem for UNIF for those 500 tries. Note the unusual scale on the X-axis designed to highlight the lost rank data for both LEV as well as UNIF. These boxplots illustrate the sigmoidal distribution of ranks that obtained by UNIF as a\nfunction of the number of samples and the less severe beginning of the sigmoid for LEV; and they also show that when subproblems are singular, then often many dimensions fail to be captured. All in all, LEV outperforms UNIF, especially when the leverage scores are nonuniform.\nFigure 10 illustrates the variance and bias of the corresponding estimators. In particular, the upper panels plot the logarithm of variances; the middle panels plot the same quantities, except that it is zoomed-in on the X-axis; and the lower panels plot the logarithm of squared bias. As before, the left/middle/right panels present results for the T3/T2/T1 data, respectively. The behavior here is very different that that shown in Figures 1, 2, and 3; and several observations are worth making. First, for all three models and for both LEV and UNIF, when the downsampling is very aggressive, e.g, r = p+ 5 or r = p+ 10, then the bias is comparable to the variance. That is, since the sampling process has lost dimensions, the linear approximation implicit in our Taylor expansion is violated. Second, both bias and variance are worse for T1 than for T2 than for T3, which is consistent with Table 4.1, but the effect is minor; and the bias and variance are generally much worse for UNIF than for LEV. Third, as r increases, the variance for UNIF increases, hits a maximum and then decreases; and at the same time the bias for UNIF gradually decreases. Upon examining the original data, the reason that there is very little variance initially is that most of the subsamples have rank 1 or 2; then the variance increases as the dimensionality of the subsamples increases; and then the variance decreases due to the 1/r scaling, as we saw in the plots in Section 4.2. Fourth, as r increases, both the variance and bias of LEV decrease, as we saw in Section 4.2; but in the aggressive downsampling regime, i.e., when r is very small, the\nvariance of LEV is particularly “choppy,” and is actually worse than that of UNIF, perhaps also due to rank deficiency issues."
    }, {
      "heading" : "5.2 Approximate Leveraging via the Fast Leveraging Algorithm",
      "text" : "Here, we will describe using the fast randomized algorithm from [10] to compute approximations to the leverage scores of X, to be used in place of the exact leverage scores in LEV, SLEV, and LEVUNW. To start, we provide a brief description of the algorithm of [10], which takes as input an arbitrary n× p matrix X.\n• Generate an r1 × n random matrix Π1 and a p× r2 random matrix Π2.\n• Let R be the R matrix from a QR decomposition of Π1X.\n• Compute and return the leverage scores of the matrix XR−1Π2.\nFor appropriate choices of r1 and r2, if one chooses Π1 to be a Hadamard-based random projection matrix, then this algorithm runs in o(np2) time, and it returns 1 ± approximations to all the leverage scores of X [10]. In addition, with a high-quality implementation of the Hadamard-based random projection, this algorithm runs faster than traditional deterministic algorithms based on Lapack for matrices as small as several thousand by several hundred [3, 17].\nWe have implemented in the software environment R two variants of this fast algorithm of [10], and we have compared it with QR-based deterministic algorithms also supported in R for\ncomputing the leverage scores exactly. In particular, the following results were obtained on a PC with Intel Core i7 Processor and 6 Gbytes RAM running Windows 7, on which we used the software package R, version 2.15.2. In the following, we refer to the above algorithm as BFast (the Binary Fast algorithm) when (up to normalization) each element of Π1 and Π2 is generated i.i.d. from {−1, 1} with equal sampling probabilities; and we refer to the above algorithm as GFast (the Gaussian Fast algorithm) when each element of Π1 is generated i.i.d. from a Gaussian distribution with mean zero and variance 1/n and each element of Π2 is generated i.i.d. from a Gaussian distribution with mean zero and variance 1/p. (In particular, note that here we do not consider Hadamard-based projections for Π1 or more sophisticated parallel and distributed implementations of these algorithms [3, 30, 17, 44].)\nTo illustrate the behavior of this algorithm as a function of its parameters, we considered synthetic data where the 20, 000× 1, 000 design matrix X is generated from T1 distribution. All the other parameters are set to be the same as before, except Σij = 0.1, for i 6= j, and Σii = 2.\nWe then applied BFast and GFast with varying r1 and r2 to the data. In particular, we set r1 = p, 1.5p, 2p, 3p, 5p, where p = 1, 000, and we set r2 = κ log(n), for κ = 1, 2, 3, 4, 5, 10, 20, where n = 20, 000. See Figure 11, which presents both a summary of the correlation between the approximate and exact leverage scores as well as a summary of the running time for computing the approximate leverage scores, as r1 and r2 are varied for both BFast and GFast. We can see that the correlations between approximated and exact leverage scores are not very sensitive to varying r1, whereas the running time increases roughly linearly for increasing r1. In contrast, the correlations between approximated and exact leverage scores increases rapidly for increasing r2, whereas the running time does not increase much when r2 increases. These observations suggest that we may use a combination of small r1 and large r2 to achieve high-quality approximation and short running time.\nNext, we examine the running time of the approximation algorithms for computing the leverage scores. Our results for running times are summarized in Figure 12. In that figure, we plot the\nrunning time as sample size n and predictor size p are varied for BFast and GFast. We can see that when the sample size is very small, the computation time of the fast algorithms is slightly worse than that of the exact algorithm. (This phenomenon is primarily since the fast algorithm requires additional projection and matrix multiplication steps, which dominate the running time for very small matrices.) On the other hand, when the sample size is larger than ca. 20, 000, the computation time of the fast approximation algorithms becomes slightly less expensive than that of exact algorithm. Much more significantly, when the sample size is larger than roughly 35, 000, the exact algorithm requires more memory than our standard R environment can provide, and thus it fails to run at all. In contrast, the fast algorithms can work with sample size up to roughly 60, 000.\nThat is, the use of this randomized algorithm to approximate the leverage scores permits us to work with data that are roughly 1.5 times larger in n or p, even when a simple vanilla implementation is provided in the R environment. (If one is interested in much larger inputs, e.g., with n = 106 or more, then one should probably not work within R and instead use Hadamardbased random projections for Π1 and/or the use of more sophisticated methods, such as those described in [3, 30, 17, 44]; here we simply evaluate an implementation of these methods in R.) The reason that BFast and GFast can run for much larger input is likely that the computational bottleneck for the exact algorithm is a QR decomposition, while the computational bottleneck for the fast randomized algorithms is the matrix-matrix multiplication step.\nFinally, we evaluate the bias and variance of LEV, SLEV and LEVUNW estimates where the leverage scores are calculated using exact algorithm, BFast, and GFast. In Figure 13, we plot the variance and squared bias for T3 data sets. (We have observed similar but slightly smoother\nresults for the Gaussian data sets and similar but slightly choppier results for the T1 data sets.) Observe that the variances of LEV estimates where the leverage scores are calculated using exact algorithm, BFast, and GFast are almost identical; and this observation is also true for SLEV and LEVUNW estimates. All in all, using the fast approximation algorithm of [10] to compute approximations to the leverage scores for use in LEV, SLEV, and LEVUNW leads to improved algorithmic performance, while achieving nearly identical statistical results as LEV, SLEV, and LEVUNW when the exact leverage scores are used."
    }, {
      "heading" : "5.3 Illustration of the Method on Real Data",
      "text" : "Here, we provide an illustration of our methods on two real data sets drawn from two problems in genetics with which we have prior experience [9, 28]. The first data set has relatively uniform leverage scores, while the second data set has somewhat more nonuniform leverage scores. These two examples simply illustrate that observations we made on the synthetic data also hold for more realistic data that we have studied previously. For more information on the application of these ideas in genetics, see previous work on PCA-correlated SNPs [35, 34]."
    }, {
      "heading" : "5.3.1 Linear model for bias correction in RNA-Seq data",
      "text" : "In order to illustrate how our methods perform on a real data set with nearly uniform leverage scores, we consider an RNA-Seq data set containing n = 51, 751 read counts from embryonic mouse stem cells [15]. Recall that RNA-Seq is becoming the major tool for transcriptome analysis; it produces digital signals by obtaining tens of millions of short reads; and after being mapped to the genome, RNA-Seq data can be summarized by a sequence of short-read counts. Recent work found that short-read counts have significant sequence bias [25]. Here, we consider a simplified linear model of [9] for correcting sequence bias in RNA-Seq. Let nij denote the counts of reads that are mapped to the genome starting at the jth nucleotide of the ith gene, where i = 1, 2, . . . , 100 and j = 1, . . . , Li. We assume that the log transformed count of reads, yij = log(nij + 0.5), depends on 40 nucleotides in the neighborhood, denoted as bij,−20, bij,−19, . . . , bij,18, bij,19 through the following linear model: yij = α + ∑19 k=−20 ∑ h∈H βkhI(bij,k = h) + ij , where H = {A,C,G}, where T is used as the baseline level, α is the grand mean, I(bij,k = h) equals to 1 if the kth nucleotide of the surrounding sequence is h, and 0 otherwise, βkh is the coefficient of the effect of nucleotide h occurring in the kth position, and ij ∼ N(0, σ2). This linear model uses p = 121 parameters to model the sequence bias of read counts. For n = 51, 751, model-fitting via LS is time-consuming.\nCoefficient estimates were obtained using three subsampling algorithms for seven different subsample sizes: 2p, 3p, 4p, 5p, 10p, 20p, 50p. We compare the estimates using the sample bias and variances; and, for each subsample size, we repeat our sampling 100 times to get 100 estimates.\n(At each subsample size, we take one hundred subsamples and calculate all the estimates; we then calculate the bias of the estimates with respect to the full sample least squares estimate and their variance.) See Figure 14 for a summary of our results. In the left panel of Figure 14, we plot the histogram of the leverage score sampling probabilities. Observe that the distribution is quite uniform, suggesting that leverage-based sampling methods will perform similarly to uniform sampling. To demonstrate this, the middle and right panels of Figure 14 present the (conditional) empirical variances and biases of each of the four estimates, for seven different subsample sizes. Observe that LEV, LEVUNW, SLEV, and UNIF all have comparable sample variances. When the subsample size is very small, all four methods have comparable sample bias; but when the subsample size is larger, then LEVUNW has a slightly larger bias than the other three estimates."
    }, {
      "heading" : "5.3.2 Linear model for predicting gene expressions of cancer patient",
      "text" : "In order to illustrate how our methods perform on real data with moderately nonuniform leverage scores, we consider a microarray data set that was presented in [33] (and also considered in [28]) for 46 cancer patients with respect to n = 5, 520 genes. Here, we randomly select one patient’s gene expression as the response y and use the remaining patients’ gene expressions as the predictors (so p = 45); and we predict the selected patient’s gene expression using other patients gene expressions through a linear model. We fit the linear model using subsampling algorithms with nine different subsample sizes. See Figure 15 for a summary of our results. In the left panel of Figure 15, we plot the histogram of the leverage score sampling probabilities. Observe that the distribution is highly skewed and quite a number of probabilities are significantly larger than the average probability. Thus, one might expect that leveraging estimates will have an advantage over the uniform sampling estimate. To demonstrate this, the middle and right panels of Figure 15 present the (conditional) empirical variances and biases of each of the four estimates, for nine different subsample sizes. Observe that SLEV and LEV have smaller sample variance than LEVUNW and that UNIF consistently has the largest variance. Interestingly, since LEVUNW is approximately unbiased to the weighted least squares estimate, here we observe that LEVUNW has by far the largest bias and that the bias does not decrease as the subsample size increases. In addition, when the subsample size is less than 2000, the biases of LEV, SLEV and UNIF are comparable; but when the subsample size is greater than 2000, LEV and SLEV have slightly smaller bias\nthan UNIF."
    }, {
      "heading" : "6 Discussion and Conclusion",
      "text" : "Algorithmic leveraging—a recently-popular framework for solving large least-squares regression and other related matrix problems via sampling based on the empirical statistical leverage scores of the data—has been shown to have many desirable algorithmic properties. In this paper, we have adopted a statistical perspective on algorithmic leveraging, and we have demonstrated how this leads to improved performance of this paradigm on real and synthetic data. In particular, from the algorithmic perspective of worst-case analysis, leverage-based sampling provides uniformly superior worst-case algorithmic results, when compared with uniform sampling. Our statistical analysis, however, reveals that, from the statistical perspective of bias and variance, neither leverage-based sampling nor uniform sampling dominates the other. Based on this, we have developed new statistically-inspired leveraging algorithms that achieve improved statistical performance, while maintaining the algorithmic benefits of the usual leverage-based method. Our empirical evaluation demonstrates that our theory is a good predictor of the practical performance of both existing as well as our newly-proposed leverage-based algorithms. In addition, our empirical evaluation demonstrates that, by using a recently-developed algorithm to approximate the leverage scores, we can compute improved approximate solutions for much larger least-squares problems than we can compute the exact solutions with traditional deterministic algorithms.\nFinally, we should note that, while our results are straightforward and intuitive, obtaining them was not easy, in large part due to seemingly-minor differences between problem formulations in statistics, computer science, machine learning, and numerical linear algebra. Now that we have “bridged the gap” by providing a statistical perspective on a recently-popular algorithmic framework, we expect that one can ask even more refined statistical questions of this and other related algorithmic frameworks for large-scale computation."
    }, {
      "heading" : "A Asymptotic Analysis and Toy Data",
      "text" : "In this section, we will relate our analytic methods to the notion of asymptotic relative efficiency, and we will consider several toy data sets that illustrate various aspects of algorithmic leveraging. Although the results of this section are not used elsewhere, and thus some readers may prefer skip this section, we include it in order to relate our approach to ideas that may be more familiar to certain readers.\nA.1 Asymptotic Relative Efficiency Analysis\nHere, we present an asymptotic analysis comparing UNIF with LEV, SLEV, and LEVUNW in terms of their relative efficiency. Recall that one natural way to compare two procedures is to compare the sample sizes at which the two procedures meet a given standard of performance. One such standard is efficiency, which addresses how “spread out” about β0 is the estimator. In this case, the smaller the variance, the more “efficient” is the estimator [38]. Since β0 is a p-dimensional vector, to determine the relative efficiency of two estimators, we consider the linear combination of β0, i.e., c\nTβ0, where c is the linear combination coefficient. In somewhat more detail, when β̂ and β̃ are two one-dimensional estimates, their relative efficiency can be defined as\ne(β̂, β̃) = Var(β̃)\nVar(β̂) ,\nand when β̂ and β̃ are two p-dimensional estimates, we can take their linear combinations cT β̂ and cT β̃, where c is the linear combination coefficient vector, and define their relative efficiency as\ne(cT β̂, cT β̃) = Var(cT β̃)\nVar(cT β̂) .\nIn order to discuss asymptotic relative efficiency, we start with the following seeminglytechnical observation.\nDefinition 1. A k × k matrix A is said to be A = O(αn) if and only if every element of A satisfies Aij = O(αn) for i, j = 1, . . . , k.\nAssumption 1. XTX = ∑n\ni=1 xix T i is positive definite and (X TX)−1 = O(α−1n ).\nRemark. Assuming XTX is nonsingular, for a LS estimator β̂ols to converge to true value β0 in probability, it is sufficient and necessary that (XTX)−1 → 0 as n→∞ [2, 24]. Remark. Although we have stated this as an assumption, one typically assumes an n-dependence for αn [2]. Since the form of the n-dependence is unspecified, we can alternatively view Assumption 1 as a definition of αn. The usual assumption that is made (typically for analytical convenience) is that αn = n [16]. We will provide examples of toy data for which αn = n, as well as examples for which αn 6= n. In light of our empirical results in Section 4 and the empirical observation that leverage scores are often very nonuniform [28, 17], it is an interesting question to ask whether the common assumption that αn = n is too restrictive, e.g., whether it excludes interesting matrices X with very heterogeneous leveraging scores.\nUnder Assumption 1, i.e., that (XTX)−1 is asymptotically parameterized as (XTX)−1 = O(α−1n ), we have the following three results to compare the leveraging estimators and the uniform sampling estimator. The expressions in these three lemmas are complicated; and, since they are expressed in terms of αn, they are not easy to evaluate on real or synthetic data. (It is partly for this reason that our empirical evaluation is in terms of the bias and variance of the subsampling estimators.) We start by stating a lemma characterizing the relative efficiency of LEV and UNIF; the proof of this lemma may be found in Appendix B.5.\nLemma 7. To leading order, the asymptotic relative efficiency of cT β̃LEV and c T β̃UNIF is\ne(cT β̃LEV , c T β̃UNIF ) ' O(\n1 αn + 1r √∑ i(1− hii)4 max(hii)\n1 αn + 1αnr √∑ i (1−hii)4 h2ii max(hii) ), (24)\nwhere the residual variance is ignored.\nNext, we state a lemma characterizing the relative efficiency of SLEV and UNIF; the proof of this lemma is similar to that of Lemma 7 and is thus omitted.\nLemma 8. To leading order, the asymptotic relative efficiency of cT β̃SLEV and c T β̃UNIF is\ne(cT β̃SLEV , c T β̃UNIF ) ' O(\n1 αn + 1r √∑ i(1− hii)4 max(hii)\n1 αn + 1αnr √∑ i (1−hii)4 π2i max(hii) ),\nwhere the residual variance is ignored.\nFinally, we state a lemma characterizing the relative efficiency of LEVUNW and UNIF; the proof of this lemma may be found in Appendix B.6.\nLemma 9. To leading order, the asymptotic relative efficiency of cT β̃LEV UNW and c T β̃UNIF is\ne(cT β̃LEV UNW , c T β̃UNIF ) ' O(\n1 αn + 1r √∑\ni(1− hii)4 max(hii) max(hii) αn min(hii) + 1αn min(hii)r √∑ i(1− gii)4 max(gii) ),\nwhere the residual variance is ignored and gii = hiix T i (X TDiag {hii}X)−1xi.\nOf course, in an analogous manner, one could derive expressions for the asymptotic relative efficiencies e(cT β̃SLEV , c T β̃LEV ), e(c T β̃LEV UNW , c T β̃LEV ), and e(c T β̃LEV UNW , c T β̃SLEV ).\nA.2 Illustration of the Method on Toy Data\nHere, we will consider several toy data sets that illustrate various aspects of algorithmic leveraging, including various extreme cases of the method. While some of these toy data may seem artificial or contrived, they will highlight properties that manifest themselves in less extreme forms in the more realistic data in Section 4. Since the leverage score structure of the matrix X is crucial for the behavior of the method, we will focus primarily on that structure. To do so, consider the two extreme cases. At one extreme, when the leverage scores are all equal, i.e., hii = p/n, for all i ∈ [n], the first two variance terms in Eqn. (20) are equal to the first two variance terms in Eqn. (18). In this case, LEV simply reduces to UNIF. At the other extreme, the leverage scores can be very nonuniform—e.g., there can be a small number of leverage scores that are much larger than the rest and/or there can be some leverage scores that are much smaller than the mean score. Dealing with these two cases properly is crucial for the method of algorithmic leveraging, but these two cases highlight important differences between the more common algorithmic perspective and our more novel statistical perspective.\nThe former problem (of a small number of very large leverage scores) is of particular importance from an algorithmic perspective. The reason is that in that case one wants to compare the output of the sampling algorithm with the optimum based on the empirical data (as opposed to the “ground truth” solution). Thus, dealing with large leverage scores was a main issue in the\ndevelopment of the leveraging paradigm [11, 27, 10]. On the other hand, the latter problem (of some very small leverage scores) is also an important concern if we are interested in statistical properties of algorithmic leveraging. To see why, consider, e.g., the extreme case that a few data points have very very small leverage scores, e.g. hii = 1/n\n4 for some i. In this case, e.g., the second variance term in Eqn. (18) will be much larger than the second variance term in Eqn. (20).\nIn light of this discussion, here are several toy examples to consider. We will start with several examples where p = 1 that illustrate things in the simplest setting.\n• Example 1A: Sample Mean. Let n be arbitrary, p = 1, and let the n× p matrix X be such that Xi = 1, for all i ∈ [n], i.e., let X be the all-ones vector. In this case, XTX = n and hii = 1/n, for all i ∈ [n], i.e., the leverage scores are uniform, and thus algorithmic leveraging reduces to uniform sampling. Also, in this case, αn = n in Assumption 1. All three asymptotic efficiencies are equal to O(1).\n• Example 1B: Simple Linear Combination. Let n be arbitrary, p = 1, and let the n×p matrix X be such that Xi = ±1, for all i ∈ [n], either uniformly at random, or such that Xi = +1 if i is odd and Xi = −1 if i is even. In this case, XTX = n and hii = 1/n, for all i ∈ [n], i.e., the leverage scores are uniform; and, in addition, αn = n in Assumption 1. For all four estimators, all four unconditional variances are equal to σ2{ 1n + (1−1/n)2 r }. In\naddition, for all four estimators, all three relative efficiencies are equal to O(1).\n• Example 2: “Inflated” Regression Line Through Origin. Let n be arbitrary, p = 1, and let the n × p matrix X be such that Xi = i, i.e., they are evenly spaced and increase without limit with increasing i. (We thus refer the X as “inflated.”) In this case,\nXTX = n(n+ 1)(2n+ 1)/6,\nand the leverage scores equal\nhii = 6i2\nn(n+ 1)(2n+ 1) ,\ni.e., the leverage scores hii are very nonuniform. This is illustrated in the left panel of Figure 16. Also, in this case, αn = n\n3 in Assumption 1. It is easy to see that the first variance components of UNIF, LEV, SLEV are the same, i.e., they equal\n(XTX)−1 = 6\nn(n+ 1)(2n+ 1) .\nIt is also easy to see that variances of LEV, SLEV and UNIF are dominated by their second variance component. The leading terms of the second variance component of LEV and UNIF are the same, and we expect to see the similar performance based on their variance. The leading term of the second variance component of SLEV is smaller than that of LEV and UNIF; and thus SLEV has smaller variance than LEV and UNIF. Simple calculation shows that LEVUNW has a smaller leading term for the second variance component than those of LEV, UNIF and SLEV.\n• Example 3: “In-fill” Regression Line Through Origin. Let n be arbitrary, p = 1, and let the n× p matrix X be such that Xi = 1/i. This is different than the evenly spaced data points in the “inflated” toy example since the unevenly spaced data points this this example get denser in the interval (0, 1]. The asymptotic properties of such design matrix are so-called “in-fill” asymptotics [8]. In this case,\nXTX = π2/6− ψ(1)(n+ 1),\nwhere ψ(k) is the kth derivative of digamma function, and the leverage scores equal\nhii = 1\ni2(π2/6− ψ(1)(n+ 1)) ,\ni.e., the leverage scores hii are very nonuniform. This is illustrated in the middle panel of Figure 16. Also, in this case, αn = 1 in Assumption 1.\nTo obtain an improved understanding of these examples, consider the first two panels of Figures 16 and 17. Figure 16 shows the sampling probabilities for the Inflated Regression Line and the Infill Regression Line. Both the Inflated Regression Line and the In-fill Regression Line have very nonuniform leverage scores, and by construction there is a natural ordering such that the leverage scores increase or decrease respectively. For the Inflated Regression Line, the minimum, mean, and maximum leverage scores are 6/(n(n + 1)(2n + 1)), 1/n, and 6n/(n + 1)(2n + 1), respectively; and for the In-fill Regression Line, the minimum, mean, and maximum leverage scores are 1/(n2(π2/6−ψ(1)(n+1))), 1/n, and 1/(π2/6−ψ(1)(n+1)), respectively. For reference, note that for the Sample Mean (as well as for the Simple Linear Combination) all of the the leverage scores are equal to 1/n, which equals 0.1 for the value of n = 10 used in Figure 16.\nFigure 17 illustrates the theoretical variances for the same examples for particular values of σ2 and r. In particular, observe that for the Inflated Regression Line, all three sampling methods tend to have smaller variance as n is increased for a fixed value of p. This is intuitive, and it is a common phenomenon that we observe in most of the synthetic and real data sets. The property of the In-fill Regression Line where the variances are roughly flat (actually, they increase slightly) is more uncommon, but it illustrates that other possibilities exist. The reason is that leverage scores of most data points are relatively homogeneous (as long as i is greater than √ 6n/π2, the leverage score of ith observation is less than mean 1/n but greater than 1/n2(π2/6)). When subsample size r is reasonably large, we have high probabilities to sample these data points, whose sample probabilities inflate the variance. These curves also illustrate that LEV and UNIF can be better or worse with respect to each other, depending on the problem parameters; and that SLEV and LEVUNW can be better than either, for certain parameter values.\nFrom these examples, we can see that the variance for the leveraging estimate can be inflated by very small leverage scores. That is, since the variances involve terms that depend on the\ninverse of hii, they can be large if hii is very small. Here, we note that the common practice of adding an intercept, i.e., a sample mean or all-ones vector tends to uniformize the leverage scores. That is, in statistical model building applications, we usually have intercept—which is an all-ones vector, called the Sample Mean above—in the model, i.e., the first column of X is 1 vector; and, in this case, the hiis are bounded below by 1/n and above by 1/wi [42]. This is also illustrated in Figure 16, which shows the the leverage scores for when an intercept is included. Interestingly, for the Inflated Regression Line, the scores for elements that originally had very small score actually increase to be on par with the largest scores. In our experience, it is much more common for the small leverage scores to simply be increased a bit, as is illustrated with the modified scores for the In-fill Regression Line.\nWe continue the toy examples with an example for p = 2; this is the simplest case that allows us to look at what is behind Assumption 1.\n• Example 4: Regression Surface Through Origin. Let p = 2 and n = 2k be even. Let the elements of X be defined as x2j−1,n = ( √ n 3j 0 ) , and x2j,n = ( 0 √ n 3j ) . In this\ncase,\nXTX = (n n∑ j=1 1 3j )I2 = k 3k − 1 3k I2 = O(n),\nand the leverage scores equal\nh2j−1,2j−1 = h2j,2j = 2× 3k\n3j(3k − 1) .\nHere, αn = n in Assumption 1, and the largest leverage score does not converge to zero.\nTo see the leverage scores and the (theoretically-determined) variance for the Regression Surface of Example 4, see the third panel of Figures 16 and 17. In particular, the third panel of Figure 16 demonstrates what we saw with the p = 1 examples, i.e., that adding an intercept tends to increase the small leverage scores; and Figure 17 illustrates that the variances of all four estimates are getting close as sample size n becomes larger. Remark. It is worth noting that [32] showed αn = n in Assumption 1 implies that maxhii → 0. In his proof, Miller essentially assumed that xi, i = 1, . . . , n is a single sequence. Example\n4 shows that Miller’s theorem does not hold for triangular array (with one pattern for even numbered observations and the other pattern for odd numbered observations) [39].\nFinally, we consider several toy data sets with larger values of p. In this case, there starts to be a nontrivial interaction between the singular value structure and the singular vector structure of the matrix X.\n• Example 5: Truncated Hadamard Matrix. An n × p matrix consisting of p columns from a Hadamard Matrix (which is an orthogonal matrix) has uniform leverage scores—all are equal. Similarly, for an n × p matrix with entries i.i.d. from Gaussian distribution— that is, unless the aspect ratio of the matrix is extremely rectangular, e.g., p = 1, the leverage scores of a random Gaussian matrix are very close to uniform. (In particular, as our empirical results demonstrate, using nonuniform sampling probabilities is not necessary for data generated from Gaussian random matrices.)\n• Example 6: Truncated Identity Matrix. An n × p matrix consisting of the first p columns from an Identity Matrix (which is an orthogonal matrix) has very nonuniform leverage scores—the first p are large, and the remainder are zero. (Since one could presumably remove the all-zeros rows, this example might seem trivial, but it is useful as a worst-case thought experiment.)\n• Example 7: Worst-case Matrix. An n× p matrix consisting of n− 1 rows all pointing in the same direction and 1 row pointing in some other direction. This has one leverage score—the one corresponding to the row pointing in the other direction—that is large, and the rest are mediumly-small. (This is an even better worst-case matrix than Example 6; and in the main text we have an even less trivial example of this.)\nExample 5 is “nice” from an algorithmic perspective and, as seen in Section 4, from a statistical perspective as well. Since they have nonuniform leverage scores; Example 6 and Example 7 are worse from an algorithmic perspective. As our empirical results will demonstrate, they are also problematic from a statistical perspective, but for slightly different reasons."
    }, {
      "heading" : "B Appendix: Proofs of our main results",
      "text" : "In this section, we will provide proofs of several of our main results.\nB.1 Proof of Lemma 1\nRecall that the matrix W = SXD 2STX encodes information about the sampling/rescaling process; in particular, this includes UNIF, LEV, and SLEV, although our results hold more generally. By performing a Taylor expansion of β̃W (w) around the point w0 = 1, we have\nβ̃W (w) = β̃W (w0) + ∂β̃W (w)\n∂wT |w=w0(w −w0) +RW ,\nwhere the second order remainder RW = op(||w−w0||) when w is close to w0. By setting w0 as the all-one vector, i.e., w0 = 1, β̃W (w0) is expanded around the full sample ordinary LS estimate β̂ols, i.e., β̃W (1) = β̂ols. That is,\nβ̃W (w) = β̂ols + ∂(XTDiag {w}X)−1XTDiag {w}y\n∂wT |w=1(w − 1) +RW .\nBy differentiation by parts, we obtain\n∂(XTDiag {w}X)−1XTDiag {w}y ∂wT = ∂Vec[(XTDiag {w}X)−1XTDiag {w}y] ∂wT\n= (1⊗ (XTDiag {w}X)−1)∂Vec[X TDiag {w}y] ∂wT (25) + (yTDiag {w}X ⊗ Ip) ∂Vec[(XTDiag {w}X)−1]\n∂wT (26)\nwhere Vec is Vec operator, which stacks the columns of a matrix into a vector, and ⊗ is the Kronecker product. The Kronecker product is defined as follows: suppose A = {aij} is an m× n matrix and B = {bij} is a p× q matrix; then, A⊗B is a mp×nq matrix, comprising m rows and n columns of p× q blocks, the ijth of which is aijB.\nTo simplify (25), note that is easy to show that (25) can be seen as\n(1⊗ (XTDiag {w}X)−1)(yT ⊗XT )∂Vec[Diag {w}] ∂wT . (27)\nTo simplify (26), we need the following two results of matrix differentiation,\n∂Vec[X−1] ∂(VecX)T = −(X−1)T ⊗X−1, and\n∂Vec[AWB] ∂wT = (BT ⊗A)∂Vec[W ] ∂wT , (28)\nwhere the details on these two results can be found on page 366-367 of [19]. By combining the two results in (28), by the chain rule, we have\n∂Vec[(XTDiag {w}X)−1] ∂wT\n= ∂Vec[(XTDiag {w}X)−1] ∂Vec[(XTDiag {w}X)]T ∂Vec[(XTDiag {w}X)] ∂wT = −(XTDiag {w}X)−1 ⊗ (XTDiag {w}X)−1(XT ⊗XT )∂Vec[Diag {w}] ∂wT\nBy simple but tedious algebra, (25) and (26) give rise to\n{(yT − yTDiag {w}X(XTDiag {w}X)−1XT )⊗ (XTDiag {w}X)−1XT }∂Vec[Diag {w}] ∂wT\n= {(y −Xβ̃W (w))T ⊗ (XTDiag {w}X)−1XT } ∂Vec[Diag {w}]\n∂wT (29)\nBy combining these results, we thus have,\nβ̃W = β̂ols + {(y −Xβ̂ols)T ⊗ (XTX)−1XT } ∂Vec(Diag {w})\n∂wT (w − 1) +RW\n= β̂ols + {êT ⊗ (XTX)−1XT }  e1e T 1 e2e T 2\nene T n  (w − 1) +RW = β̂ols + (X TX)−1XTDiag {ê} (w − 1) +RW\nwhere ê = y −Xβ̂ols is the LS residual vector, ei is a length n vector with ith element equal to one and all other elements equal to zero, from which the lemma follows.\nB.2 Proof of Lemma 2\nRecall that we will use W to refer to the sampling process. We start by establishing the conditional result. Since E [w] = 1, it is straightforward to calculate conditional expectation of β̃W . Then, it is easy to see that\nE [(wi − 1)(wj − 1)] = 1 rπi − 1 r for i = j\n= −1 r for i 6= j.\nWe rewrite it in matrix form,\nVar [w] = E [ (w − 1)(w − 1)T ] = Diag\n{ 1\nrπ } − 1 r Jn,\nwhere π = (π1, π2, . . . , πn) T and Jn is a n×n matrix of ones. Some additional algebra yields that the variance of β̃W is\nVarw [ β̃W − β̂|y ] = Var [ (XTX)−1XTDiag {ê} (w − 1)|y ] + Varw [RW ]\n= (XTX)−1XTDiag {ê} (Diag { 1\nrπ } − 1 r Jn)Diag {ê}X(XTX)−1 + Varw [RW ]\n= (XTX)−1XT [Diag {ê}Diag { 1\nrπ\n} Diag {ê}]X(XTX)−1 + Var [RW ]\n= (XTX)−1XTDiag\n{ 1 rπ ê2 } X(XTX)−1 + Varw [RW ] .\nSetting πi = hii/p in above equations, we thus prove the conditional result. We next establish the unconditional result as follows. If we take one more expectation of the expectation result in Lemma 3 with respect to the response, then we have the expectation result. By rule of double expectations, we have the variance of β̃W result, from which the lemma follows.\nB.3 Proof of Lemma 5\nFirst note that the unweighted leveraging estimate β̃LEV UNW can be written as\nβ̃LEV UNW = (X TSXS T XX) −1XTSXS T Xy = (X TWLEV UNWX) −1XTWLEV UNWy,\nwhere WLEV UNW = SXS T X = Diag {wLEV UNW }, and where wLEV UNW has a multinomial distribution Multi(r,π). The proof of this lemma is analogous to the proof of Lemma 1; and so here we provide only some details on the differences. By employing a Taylor expansion, we have\nβ̃LEV UNW (wLEV UNW ) = β̃LEV UNW (w0)+ ∂β̃LEV UNW (w)\n∂wT |w=w0(wLEV UNW−w0)+RLEV UNW ,\nwhere RLEV UNW = op(||wLEV UNW − w0||). Following the proof of the previous lemma, we have that β̃LEV UNW = β̂wls + {(y −Xβ̂wls)T ⊗ (XTW0X)−1XT } ∂vec(Diag {wLEV UNW })\n∂wTLEV UNW (wLEV UNW −w0)\n+RLEV UNW\n= β̂wls + {êTw ⊗ (XTW0X)−1XT }  e1e T 1 e2e T 2\nene T n  (wLEV UNW −w0) +RLEV UNW = β̂wls + (X TW0X) −1XTDiag {êw0} (wLEV UNW −w0) +RLEV UNW ,\nwhere W0 = Diag {w0} = Diag {rπ}, β̂wls = (XTW0X)−1XTW0y, êw = y − Xβ̂wls is the weighted LS residual vector, ei is a length n vector with i\nth element equal to one and all other elements equal to zero. From this the lemma follows.\nB.4 Proof of Lemma 6\nBy taking the conditional expectation of Taylor expansion of the LEVUNW estimate β̃LEV UNW in Lemma 5, we have that\nEw [ β̃LEV UNW |y ] = β̂wls + (X TW0X) −1XTDiag {êw}Ew [w − rπ] + Ew [RLEV UNW ] .\nSince Ew [wLEV UNW ] = rπ, the conditional expectation is thus obtained. Since wLEV UNW is multinomial distributed, we have\nVar [wLEV UNW ] = E [ (wLEV UNW − rπ)(wLEV UNW − rπ)T ] = Diag {rπ} − rππT .\nSome algebra yields that the conditional variance of β̃LEV UNW is\nVarw [ β̃LEV UNW − β̂wls|y ] = Varw [ (XTW0X) −1XTDiag {êw} (wLEV UNW − rπ)|y ] + Varw [RLEV UNW ]\n= (XTW0X) −1XTDiag {êw}W0Diag {êw}X(XTW0X)−1 + Varw [RLEV UNW ] .\nFinally, note that E [ β̂wls ] = (XTW0X) −1XW0E [y] = (X TW0X) −1XW0Xβ0 = β0.\nFrom this the lemma follows.\nB.5 Proof of Lemma 7\nSince Var(cT β̃LEV ) = c TVar(β̃LEV )c, we shall the derive the asymptotic order of Var(β̃LEV ). The second variance component of β̃LEV in (18) is seen to be\npσ2\nr (XTX)−1XTDiag\n{ (1− hii)2\nhii\n} X(XTX)−1\n= pσ2\nr ∑ i (1− hii)2 hii (XTX)−1xix T i (X TX)−1\n≤ pσ 2\nr √∑ i (1− hii)4 h2ii ∑ i ((XTX)−1xixTi (X TX)−1)2,\nwhere Cauchy-Schwartz inequality has been used. Next, we show that∑ i ((XTX)−1xix T i (X TX)−1)2 = O(max(hii)α −2 n ).\nTo see this, observe that∑ i ((XTX)−1xix T i (X TX)−1)2 ≤ max((XTX)−1xixTi ) ∑ i (XTX)−2xix T i (X TX)−1\n≤ max(xTi (XTX)−1xi) ∑ i (XTX)−2xix T i (X TX)−1 = max(xTi (X TX)−1xi)(X TX)−2 = O(max(hii)α −2 n )\nThus, the second variance component of β̃LEV in (18) is of the order of\nO( 1\nαnr √∑ i (1− hii)4 h2ii max(hii)).\nAnalogously, the second variance component of β̃UNIF in (20) is of the order of\nO( 1\nr √∑ i (1− hii)4 max(hii)).\nThe lemma then follows immediately.\nB.6 Proof of Lemma 9\nIt is easy to see that (XTDiag {hii}X)−1 = O(1/(min(hii)αn)). The second variance component of β̃LEV UNW in (23) is seen to be\npσ2\nr (XTDiag {hii}X)−1XTDiag\n{ (1− gii)2hii } X(XTDiag {hii}X)−1\n= pσ2\nr ∑ i (1− gii)2hii(XTDiag {hii}X)−1xixTi (XTDiag {hii}X)−1\n≤ pσ 2\nr √∑ i (1− gii)4 ∑ i (hii(XTDiag {hii}X)−1xixTi (XTDiag {hii}X)−1)2,\nwhere Cauchy-Schwartz inequality has used. Next, we show that∑ i (hii(X TDiag {hii}X)−1xixTi (XTDiag {hii}X)−1)2 = O(max(gii)(min(hii)αn)−2).\nTo see this, observe that∑ i (hii(X TDiag {hii}X)−1xixTi (XTDiag {hii}X)−1)2\n≤ max(hii(XTDiag {hii}X)−1xixTi ) ∑ i hii(X TDiag {hii}X)−2xixTi (XTDiag {hii}X)−1\n≤ max(hiixTi (XTDiag {hii}X)−1xi) ∑ i hii(X TDiag {hii}X)−2xixTi (XTDiag {hii}X)−1 = max(hiix T i (X TDiag {hii}X)−1xi)(XTDiag {hii}X)−2 = O(max(gii)(min(hii)αn)−2).\nThus, the second variance component of β̃LEV UNW in (23) is of the order of\nO( 1\nαn min(hii)r √∑ i (1− gii)4 max(gii)).\nThe lemma then follows immediately.\nAcknowledgments. This research was partially supported by a grant from the U.S. National Science Foundation."
    } ],
    "references" : [ {
      "title" : "Faster dimension reduction",
      "author" : [ "N. Ailon", "B. Chazelle" ],
      "venue" : "Communications of the ACM, 53(2):97–104",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Strong consistency of least squares estimates in normal linear regression",
      "author" : [ "T.W. Anderson", "J.B. Taylor" ],
      "venue" : "Annals of Statistics, 4(4):788–790",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1976
    }, {
      "title" : "Blendenpik: Supercharging LAPACK’s leastsquares solver",
      "author" : [ "H. Avron", "P. Maymounkov", "S. Toledo" ],
      "venue" : "SIAM Journal on Scientific Computing, 32:1217–1236",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "and W",
      "author" : [ "P.J. Bickel", "F. Gotze" ],
      "venue" : "R. van Zwet. Resampling fewer than n observations: gains, losses, and remedies for losses. Statistica Sinica, 7:1–31",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Influential observations",
      "author" : [ "S. Chatterjee", "A.S. Hadi" ],
      "venue" : "high leverage points, and outliers in linear regression. Statistical Science, 1(3):379–393",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "The Fast Cauchy Transform and faster robust linear regression",
      "author" : [ "K.L. Clarkson", "P. Drineas", "M. Magdon-Ismail", "M.W. Mahoney", "X. Meng", "D.P. Woodruff" ],
      "venue" : "Technical report. Preprint: arXiv:1207.4684 ",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Low rank approximation and regression in input sparsity time",
      "author" : [ "K.L. Clarkson", "D.P. Woodruff" ],
      "venue" : "Technical report. Preprint: arXiv:1207.6365 ",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Statistics for Spatial Data",
      "author" : [ "N. Cressie" ],
      "venue" : "Wiley, New York",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Bias correction in RNA-Seq short-read counts using penalized regression",
      "author" : [ "D. Dalpiaz", "X. He", "P. Ma" ],
      "venue" : "Statistics in Biosciences, 5(1):88–99",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Fast approximation of matrix coherence and statistical leverage",
      "author" : [ "P. Drineas", "M. Magdon-Ismail", "M.W. Mahoney", "D.P. Woodruff" ],
      "venue" : "Journal of Machine Learning Research, 13:3475– 3506",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Sampling algorithms for `2 regression and applications",
      "author" : [ "P. Drineas", "M.W. Mahoney", "S. Muthukrishnan" ],
      "venue" : "Proceedings of the 17th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 1127–1136",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Faster least squares approximation",
      "author" : [ "P. Drineas", "M.W. Mahoney", "S. Muthukrishnan", "T. Sarlós" ],
      "venue" : "Numerische Mathematik, 117(2):219–249",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Bootstrap methods: another look at the jackknife",
      "author" : [ "B. Efron" ],
      "venue" : "The Annals of Statistics, 7(1):1–26",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "A leisurely look at the bootstrap",
      "author" : [ "B. Efron", "G. Gong" ],
      "venue" : "the jackknife, and cross-validation. The American Statistician, 37(1):36–48",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1983
    }, {
      "title" : "Stem cell transcriptome profiling via massive-scale mRNA sequencing",
      "author" : [ "N. Cloonan" ],
      "venue" : "Nature Methods,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2008
    }, {
      "title" : "Asymptotics for lasso-type estimators",
      "author" : [ "W. Fu", "K. Knight" ],
      "venue" : "Annals of Statistics, 28:1356– 1378",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Revisiting the Nyström method for improved large-scale machine learning",
      "author" : [ "A. Gittens", "M.W. Mahoney" ],
      "venue" : "Technical report. Preprint: arXiv:1303.1849 ",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Matrix Computations",
      "author" : [ "G.H. Golub", "C.F. Van Loan" ],
      "venue" : "Johns Hopkins University Press, Baltimore",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Matrix Algebra from A Statistician’s perspective",
      "author" : [ "D.A. Harville" ],
      "venue" : "Springer-Verlag, New York",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Jackknifing in unbalanced situations",
      "author" : [ "D.V. Hinkley" ],
      "venue" : "Technometrics, 19(3):285–292",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 1977
    }, {
      "title" : "The hat matrix in regression and ANOVA",
      "author" : [ "D.C. Hoaglin", "R.E. Welsch" ],
      "venue" : "The American Statistician, 32(1):17–22",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 1978
    }, {
      "title" : "The infinitesimal jackknife",
      "author" : [ "L. Jaeckel" ],
      "venue" : "Bell Laboratories Memorandum, MM:72–1215–11",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 1972
    }, {
      "title" : "The big data bootstrap",
      "author" : [ "A. Kleiner", "A. Talwalkar", "P. Sarkar", "M. Jordan" ],
      "venue" : "Proceedings of the 29th International Conference on Machine Learning",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Strong consistency of least squares estimates in multiple regression",
      "author" : [ "T.L. Lai", "H. Robbins", "C.Z. Wei" ],
      "venue" : "Proceedings of National Academy of Sciences, 75(7):3034–3036",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 1978
    }, {
      "title" : "Modeling non-uniformity in short-read rates in RNA-seq data",
      "author" : [ "J. Li", "H. Jiang", "W.H. Wong" ],
      "venue" : "Genome Biology, 11:R50",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Rejection control and sequential importance sampling",
      "author" : [ "J.S. Liu", "R. Chen", "W.H. Wong" ],
      "venue" : "Journal of the American Statistical Association, 93(443):1022–1031",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Randomized algorithms for matrices and data",
      "author" : [ "M.W. Mahoney" ],
      "venue" : "Foundations and Trends in Machine Learning. NOW Publishers, Boston",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "CUR matrix decompositions for improved data analysis",
      "author" : [ "M.W. Mahoney", "P. Drineas" ],
      "venue" : "Proceedings of National Academy of Sciences, 106:697–702",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Low-distortion subspace embeddings in input-sparsity time and applications to robust linear regression",
      "author" : [ "X. Meng", "M.W. Mahoney" ],
      "venue" : "Technical report. Preprint: arXiv:1210.3135 ",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "LSRN: A parallel iterative solver for strongly over- or under-determined systems",
      "author" : [ "X. Meng", "M.A. Saunders", "M.W. Mahoney" ],
      "venue" : "Technical report. Preprint: arXiv:1109.5981 ",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "The jackknife–a review",
      "author" : [ "R.G. Miller" ],
      "venue" : "Biometrika, 61(1):1–15",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 1974
    }, {
      "title" : "An unbalanced jackknife",
      "author" : [ "R.G. Miller" ],
      "venue" : "The Annals of Statistics, 2(5):880–891",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 1974
    }, {
      "title" : "J",
      "author" : [ "T. Nielsen", "R.B. West", "S.C. Linn", "O. Alter", "M.A. Knowling" ],
      "venue" : "O’Connell, S. Zhu, M. Fero, G. Sherlock, J. R. Pollack, P. O. Brown, D. Botstein, and M. van de Rijn. Molecular characterisation of soft tissue tumours: a gene expression study. Lancet, 359(9314):1301– 1307",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Ancestry informative markers for finescale individual assignment to worldwide populations",
      "author" : [ "P. Paschou", "J. Lewis", "A. Javed", "P. Drineas" ],
      "venue" : "Journal of Medical Genetics, page doi:10.1136/jmg.2010.078212",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "PCA-correlated SNPs for structure identification in worldwide human populations",
      "author" : [ "P. Paschou", "E. Ziv", "E.G. Burchard", "S. Choudhry", "W. Rodriguez-Cintron", "M.W. Mahoney", "P. Drineas" ],
      "venue" : "PLoS Genetics, 3:1672–1686",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Subsampling",
      "author" : [ "D.N. Politis", "J.P. Romano", "M. Wolf" ],
      "venue" : "Springer-Verlag, New York",
      "citeRegEx" : "36",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "The Bayesian bootstrap",
      "author" : [ "D.B. Rubin" ],
      "venue" : "The Annals of Statistics, 9(1):130–134",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 1981
    }, {
      "title" : "Asymptotic relative efficiency in estimation",
      "author" : [ "R. Serfling" ],
      "venue" : "Miodrag Lovric, editor, International Encyclopedia of Statistical Sciences, pages 68–72. Springer",
      "citeRegEx" : "38",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "On resampling methods for variance estimation and related topics",
      "author" : [ "J. Shao" ],
      "venue" : "PhD thesis, University of Wisconsin at Madison",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "The Jackknife and Bootstrap",
      "author" : [ "J. Shao", "D. Tu" ],
      "venue" : "Springer-Verlag, New York",
      "citeRegEx" : "40",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Efficient computing of regression diagnostics",
      "author" : [ "P.F. Velleman", "R.E. Welsch" ],
      "venue" : "The American Statistician, 35(4):234–242",
      "citeRegEx" : "41",
      "shortCiteRegEx" : null,
      "year" : 1981
    }, {
      "title" : "Applied Linear Regression",
      "author" : [ "S. Weisberg" ],
      "venue" : "Wiley, New York",
      "citeRegEx" : "42",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Jackknife",
      "author" : [ "C.F.J. Wu" ],
      "venue" : "bootstrap and other resampling methods in regression analysis. The Annals of Statistics, 14(4):1261–1295",
      "citeRegEx" : "43",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "Quantile regression for large-scale applications",
      "author" : [ "J. Yang", "X. Meng", "M.W. Mahoney" ],
      "venue" : "Technical report. Preprint: arXiv:1305.0087 ",
      "citeRegEx" : "44",
      "shortCiteRegEx" : null,
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 26,
      "context" : "Motivated by this, there has been a great deal of work on developing algorithms for matrix-based machine learning and data analysis problems that construct the random sample in a nonuniform data-dependent fashion [27].",
      "startOffset" : 213,
      "endOffset" : 217
    }, {
      "referenceID" : 10,
      "context" : ", least-squares approximation [11, 12], least absolute deviations regression [6, 29], and low-rank matrix approximation [28, 7].",
      "startOffset" : 30,
      "endOffset" : 38
    }, {
      "referenceID" : 11,
      "context" : ", least-squares approximation [11, 12], least absolute deviations regression [6, 29], and low-rank matrix approximation [28, 7].",
      "startOffset" : 30,
      "endOffset" : 38
    }, {
      "referenceID" : 5,
      "context" : ", least-squares approximation [11, 12], least absolute deviations regression [6, 29], and low-rank matrix approximation [28, 7].",
      "startOffset" : 77,
      "endOffset" : 84
    }, {
      "referenceID" : 28,
      "context" : ", least-squares approximation [11, 12], least absolute deviations regression [6, 29], and low-rank matrix approximation [28, 7].",
      "startOffset" : 77,
      "endOffset" : 84
    }, {
      "referenceID" : 27,
      "context" : ", least-squares approximation [11, 12], least absolute deviations regression [6, 29], and low-rank matrix approximation [28, 7].",
      "startOffset" : 120,
      "endOffset" : 127
    }, {
      "referenceID" : 6,
      "context" : ", least-squares approximation [11, 12], least absolute deviations regression [6, 29], and low-rank matrix approximation [28, 7].",
      "startOffset" : 120,
      "endOffset" : 127
    }, {
      "referenceID" : 9,
      "context" : "Typically, the leverage scores are computed approximately [10, 6], or otherwise a random projection [1, 6] is used to precondition by approximately uniformizing them [12, 3, 30].",
      "startOffset" : 58,
      "endOffset" : 65
    }, {
      "referenceID" : 5,
      "context" : "Typically, the leverage scores are computed approximately [10, 6], or otherwise a random projection [1, 6] is used to precondition by approximately uniformizing them [12, 3, 30].",
      "startOffset" : 58,
      "endOffset" : 65
    }, {
      "referenceID" : 0,
      "context" : "Typically, the leverage scores are computed approximately [10, 6], or otherwise a random projection [1, 6] is used to precondition by approximately uniformizing them [12, 3, 30].",
      "startOffset" : 100,
      "endOffset" : 106
    }, {
      "referenceID" : 5,
      "context" : "Typically, the leverage scores are computed approximately [10, 6], or otherwise a random projection [1, 6] is used to precondition by approximately uniformizing them [12, 3, 30].",
      "startOffset" : 100,
      "endOffset" : 106
    }, {
      "referenceID" : 11,
      "context" : "Typically, the leverage scores are computed approximately [10, 6], or otherwise a random projection [1, 6] is used to precondition by approximately uniformizing them [12, 3, 30].",
      "startOffset" : 166,
      "endOffset" : 177
    }, {
      "referenceID" : 2,
      "context" : "Typically, the leverage scores are computed approximately [10, 6], or otherwise a random projection [1, 6] is used to precondition by approximately uniformizing them [12, 3, 30].",
      "startOffset" : 166,
      "endOffset" : 177
    }, {
      "referenceID" : 29,
      "context" : "Typically, the leverage scores are computed approximately [10, 6], or otherwise a random projection [1, 6] is used to precondition by approximately uniformizing them [12, 3, 30].",
      "startOffset" : 166,
      "endOffset" : 177
    }, {
      "referenceID" : 26,
      "context" : "A detailed discussion of this approach can be found in the recent review monograph on randomized algorithms for matrices and matrix-based data problems [27].",
      "startOffset" : 152,
      "endOffset" : 156
    }, {
      "referenceID" : 2,
      "context" : "This algorithmic leveraging paradigm has already yielded impressive algorithmic benefits: by preconditioning with a high-quality numerical implementation of a Hadamard-based random projection, the Blendenpik code of [3] “beats Lapack’s1 direct dense least-squares solver by a large margin on essentially any dense tall matrix;” the LSRN algorithm of [30] preconditions with a high-quality numerical implementation of a normal random projection in order to solve large over-constrained least-squares problems on clusters with high communication cost, e.",
      "startOffset" : 216,
      "endOffset" : 219
    }, {
      "referenceID" : 29,
      "context" : "This algorithmic leveraging paradigm has already yielded impressive algorithmic benefits: by preconditioning with a high-quality numerical implementation of a Hadamard-based random projection, the Blendenpik code of [3] “beats Lapack’s1 direct dense least-squares solver by a large margin on essentially any dense tall matrix;” the LSRN algorithm of [30] preconditions with a high-quality numerical implementation of a normal random projection in order to solve large over-constrained least-squares problems on clusters with high communication cost, e.",
      "startOffset" : 350,
      "endOffset" : 354
    }, {
      "referenceID" : 5,
      "context" : ", on Amazon Elastic Cloud Compute clusters; the solution to the `1 regression or least absolute deviations problem as well as to quantile regression problems can be approximated for problems with billions of constraints [6, 44]; and CUR-based low-rank matrix approximations [28] have been used for structure extraction in DNA SNP matrices of size thousands of individuals by hundreds of thousands of SNPs [35, 34].",
      "startOffset" : 220,
      "endOffset" : 227
    }, {
      "referenceID" : 43,
      "context" : ", on Amazon Elastic Cloud Compute clusters; the solution to the `1 regression or least absolute deviations problem as well as to quantile regression problems can be approximated for problems with billions of constraints [6, 44]; and CUR-based low-rank matrix approximations [28] have been used for structure extraction in DNA SNP matrices of size thousands of individuals by hundreds of thousands of SNPs [35, 34].",
      "startOffset" : 220,
      "endOffset" : 227
    }, {
      "referenceID" : 27,
      "context" : ", on Amazon Elastic Cloud Compute clusters; the solution to the `1 regression or least absolute deviations problem as well as to quantile regression problems can be approximated for problems with billions of constraints [6, 44]; and CUR-based low-rank matrix approximations [28] have been used for structure extraction in DNA SNP matrices of size thousands of individuals by hundreds of thousands of SNPs [35, 34].",
      "startOffset" : 274,
      "endOffset" : 278
    }, {
      "referenceID" : 34,
      "context" : ", on Amazon Elastic Cloud Compute clusters; the solution to the `1 regression or least absolute deviations problem as well as to quantile regression problems can be approximated for problems with billions of constraints [6, 44]; and CUR-based low-rank matrix approximations [28] have been used for structure extraction in DNA SNP matrices of size thousands of individuals by hundreds of thousands of SNPs [35, 34].",
      "startOffset" : 405,
      "endOffset" : 413
    }, {
      "referenceID" : 33,
      "context" : ", on Amazon Elastic Cloud Compute clusters; the solution to the `1 regression or least absolute deviations problem as well as to quantile regression problems can be approximated for problems with billions of constraints [6, 44]; and CUR-based low-rank matrix approximations [28] have been used for structure extraction in DNA SNP matrices of size thousands of individuals by hundreds of thousands of SNPs [35, 34].",
      "startOffset" : 405,
      "endOffset" : 413
    }, {
      "referenceID" : 20,
      "context" : "This is in spite of the central role of statistical leverage, a traditional concept from regression diagnostics [21, 5, 41].",
      "startOffset" : 112,
      "endOffset" : 123
    }, {
      "referenceID" : 4,
      "context" : "This is in spite of the central role of statistical leverage, a traditional concept from regression diagnostics [21, 5, 41].",
      "startOffset" : 112,
      "endOffset" : 123
    }, {
      "referenceID" : 40,
      "context" : "This is in spite of the central role of statistical leverage, a traditional concept from regression diagnostics [21, 5, 41].",
      "startOffset" : 112,
      "endOffset" : 123
    }, {
      "referenceID" : 9,
      "context" : "By using a recentlydeveloped algorithm of [10] to compute fast approximations to the statistical leverage scores, we also demonstrate a regime for large data where our shrinked leveraging procedure is better algorithmically, in the sense of computing an answer more quickly than the usual black-box leastsquares solver, as well as statistically, in the sense of having smaller mean squared error than näıve uniform sampling.",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 17,
      "context" : "Using one of several related methods [18], this LS problem can be solved exactly in O(np2) time (but, as we will discuss in Section 2.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 20,
      "context" : "In this case, the unknown coefficient β0 can be estimated via maximum-likelihood estimation as β̂ols = argminβ||y −Xβ|| = (XTX)−1XTy, (3) in which case the predicted response vector is ŷ = Hy, where H = X(XTX)−1XT is the so-called Hat Matrix, which is of interest in classical regression diagnostics [21, 5, 41].",
      "startOffset" : 300,
      "endOffset" : 311
    }, {
      "referenceID" : 4,
      "context" : "In this case, the unknown coefficient β0 can be estimated via maximum-likelihood estimation as β̂ols = argminβ||y −Xβ|| = (XTX)−1XTy, (3) in which case the predicted response vector is ŷ = Hy, where H = X(XTX)−1XT is the so-called Hat Matrix, which is of interest in classical regression diagnostics [21, 5, 41].",
      "startOffset" : 300,
      "endOffset" : 311
    }, {
      "referenceID" : 40,
      "context" : "In this case, the unknown coefficient β0 can be estimated via maximum-likelihood estimation as β̂ols = argminβ||y −Xβ|| = (XTX)−1XTy, (3) in which case the predicted response vector is ŷ = Hy, where H = X(XTX)−1XT is the so-called Hat Matrix, which is of interest in classical regression diagnostics [21, 5, 41].",
      "startOffset" : 300,
      "endOffset" : 311
    }, {
      "referenceID" : 20,
      "context" : "The statistical leverage scores have been used historically to quantify the extent to which an observation is an outlier [21, 5, 41], and they will be important for our main results below.",
      "startOffset" : 121,
      "endOffset" : 132
    }, {
      "referenceID" : 4,
      "context" : "The statistical leverage scores have been used historically to quantify the extent to which an observation is an outlier [21, 5, 41], and they will be important for our main results below.",
      "startOffset" : 121,
      "endOffset" : 132
    }, {
      "referenceID" : 40,
      "context" : "The statistical leverage scores have been used historically to quantify the extent to which an observation is an outlier [21, 5, 41], and they will be important for our main results below.",
      "startOffset" : 121,
      "endOffset" : 132
    }, {
      "referenceID" : 17,
      "context" : "(4), the exact computation of hii, for i ∈ [n], requires O(np2) time [18] (but, as we will discuss in Section 2.",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 10,
      "context" : "2 Algorithmic Leveraging for Least-squares Approximation Here, we will review relevant work on random sampling algorithms for computing approximate solutions to the general overconstrained LS problem [11, 27, 10].",
      "startOffset" : 200,
      "endOffset" : 212
    }, {
      "referenceID" : 26,
      "context" : "2 Algorithmic Leveraging for Least-squares Approximation Here, we will review relevant work on random sampling algorithms for computing approximate solutions to the general overconstrained LS problem [11, 27, 10].",
      "startOffset" : 200,
      "endOffset" : 212
    }, {
      "referenceID" : 9,
      "context" : "2 Algorithmic Leveraging for Least-squares Approximation Here, we will review relevant work on random sampling algorithms for computing approximate solutions to the general overconstrained LS problem [11, 27, 10].",
      "startOffset" : 200,
      "endOffset" : 212
    }, {
      "referenceID" : 10,
      "context" : "A prototypical example of this approach is given by the following meta-algorithm [11, 27, 10], which we call SubsampleLS, and which takes as input an n× p matrix X, where n p, a vector y, and a probability distribution {πi}i=1, and which returns as output an approximate solution β̃ols, which is an estimate of β̂ols of Eqn.",
      "startOffset" : 81,
      "endOffset" : 93
    }, {
      "referenceID" : 26,
      "context" : "A prototypical example of this approach is given by the following meta-algorithm [11, 27, 10], which we call SubsampleLS, and which takes as input an n× p matrix X, where n p, a vector y, and a probability distribution {πi}i=1, and which returns as output an approximate solution β̃ols, which is an estimate of β̂ols of Eqn.",
      "startOffset" : 81,
      "endOffset" : 93
    }, {
      "referenceID" : 9,
      "context" : "A prototypical example of this approach is given by the following meta-algorithm [11, 27, 10], which we call SubsampleLS, and which takes as input an n× p matrix X, where n p, a vector y, and a probability distribution {πi}i=1, and which returns as output an approximate solution β̃ols, which is an estimate of β̂ols of Eqn.",
      "startOffset" : 81,
      "endOffset" : 93
    }, {
      "referenceID" : 10,
      "context" : "There are several distributions that have been considered previously [11, 27, 10].",
      "startOffset" : 69,
      "endOffset" : 81
    }, {
      "referenceID" : 26,
      "context" : "There are several distributions that have been considered previously [11, 27, 10].",
      "startOffset" : 69,
      "endOffset" : 81
    }, {
      "referenceID" : 9,
      "context" : "There are several distributions that have been considered previously [11, 27, 10].",
      "startOffset" : 69,
      "endOffset" : 81
    }, {
      "referenceID" : 10,
      "context" : ", see below or see [11, 27]).",
      "startOffset" : 19,
      "endOffset" : 27
    }, {
      "referenceID" : 26,
      "context" : ", see below or see [11, 27]).",
      "startOffset" : 19,
      "endOffset" : 27
    }, {
      "referenceID" : 10,
      "context" : "On the other hand, it has been shown that, for a parameter γ ∈ (0, 1] to be tuned, if πi ≥ γ hii p , and r = O(p log(p)/(γ )), (7) then the following relative-error bounds hold: ||y −Xβ̃ols||2 ≤ (1 + )||y −Xβ̂ols||2 and (8) ||β̂ols − β̃ols||2 ≤ √ ( κ(X) √ ξ−2 − 1 ) ||β̂ols||2, (9) where κ(X) is the condition number of X and where ξ = ||UUy||2/||y||2 is a parameter defining the amount of the mass of y inside the column space of X [11, 27, 10].",
      "startOffset" : 433,
      "endOffset" : 445
    }, {
      "referenceID" : 26,
      "context" : "On the other hand, it has been shown that, for a parameter γ ∈ (0, 1] to be tuned, if πi ≥ γ hii p , and r = O(p log(p)/(γ )), (7) then the following relative-error bounds hold: ||y −Xβ̃ols||2 ≤ (1 + )||y −Xβ̂ols||2 and (8) ||β̂ols − β̃ols||2 ≤ √ ( κ(X) √ ξ−2 − 1 ) ||β̂ols||2, (9) where κ(X) is the condition number of X and where ξ = ||UUy||2/||y||2 is a parameter defining the amount of the mass of y inside the column space of X [11, 27, 10].",
      "startOffset" : 433,
      "endOffset" : 445
    }, {
      "referenceID" : 9,
      "context" : "On the other hand, it has been shown that, for a parameter γ ∈ (0, 1] to be tuned, if πi ≥ γ hii p , and r = O(p log(p)/(γ )), (7) then the following relative-error bounds hold: ||y −Xβ̃ols||2 ≤ (1 + )||y −Xβ̂ols||2 and (8) ||β̂ols − β̃ols||2 ≤ √ ( κ(X) √ ξ−2 − 1 ) ||β̂ols||2, (9) where κ(X) is the condition number of X and where ξ = ||UUy||2/||y||2 is a parameter defining the amount of the mass of y inside the column space of X [11, 27, 10].",
      "startOffset" : 433,
      "endOffset" : 445
    }, {
      "referenceID" : 10,
      "context" : "This is the basic algorithmic leveraging algorithm that was originally proposed in [11], where the exact empirical statistical leverage scores of X were first used to construct the subsample and reweight the subproblem, and it’s solution will be denoted by β̃LEV .",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 10,
      "context" : "(11) Whereas the previous estimators all follow the basic framework of sampling and rescaling/reweighting according to the same distribution (which is used in worst-case analysis to control the properties of both eigenvalues and eigenvectors and provide unbiased estimates of certain quantities within the analysis [11, 27, 10]), with LEVUNW they are essentially done according to two different distributions—the reason being that not rescaling leads to the same solution as rescaling with the uniform distribution.",
      "startOffset" : 315,
      "endOffset" : 327
    }, {
      "referenceID" : 26,
      "context" : "(11) Whereas the previous estimators all follow the basic framework of sampling and rescaling/reweighting according to the same distribution (which is used in worst-case analysis to control the properties of both eigenvalues and eigenvectors and provide unbiased estimates of certain quantities within the analysis [11, 27, 10]), with LEVUNW they are essentially done according to two different distributions—the reason being that not rescaling leads to the same solution as rescaling with the uniform distribution.",
      "startOffset" : 315,
      "endOffset" : 327
    }, {
      "referenceID" : 9,
      "context" : "(11) Whereas the previous estimators all follow the basic framework of sampling and rescaling/reweighting according to the same distribution (which is used in worst-case analysis to control the properties of both eigenvalues and eigenvectors and provide unbiased estimates of certain quantities within the analysis [11, 27, 10]), with LEVUNW they are essentially done according to two different distributions—the reason being that not rescaling leads to the same solution as rescaling with the uniform distribution.",
      "startOffset" : 315,
      "endOffset" : 327
    }, {
      "referenceID" : 9,
      "context" : "Of greater interest is the algorithm of [10] that computes relative-error approximations to all of the leverage scores of X in o(np2) time.",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 9,
      "context" : "In more detail, given as input an arbitrary n×p matrix X, with n p, and an error parameter ∈ (0, 1), the main algorithm of [10] (described also in Section 5.",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 9,
      "context" : "This algorithm runs in roughly O(np log(p)/ ) time,3 which for appropriate parameter settings is o(np2) time [10].",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 9,
      "context" : "The running time of the relative-error approximation algorithm of [10] depends on the time needed to premultiply X by a randomized Hadamard transform (i.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 2,
      "context" : ", Blendenpik [3], as well as LSRN [30], which extends these implementations 3 In more detail, the asymptotic running time of the main algorithm of [10] is O ( np ln ( p −1 ) + np −2 lnn+ p −2 (lnn) ( ln ( p −1 ))) .",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 29,
      "context" : ", Blendenpik [3], as well as LSRN [30], which extends these implementations 3 In more detail, the asymptotic running time of the main algorithm of [10] is O ( np ln ( p −1 ) + np −2 lnn+ p −2 (lnn) ( ln ( p −1 ))) .",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 9,
      "context" : ", Blendenpik [3], as well as LSRN [30], which extends these implementations 3 In more detail, the asymptotic running time of the main algorithm of [10] is O ( np ln ( p −1 ) + np −2 lnn+ p −2 (lnn) ( ln ( p −1 ))) .",
      "startOffset" : 147,
      "endOffset" : 151
    }, {
      "referenceID" : 2,
      "context" : "See [3, 30] for details, and see [17] for the application of these methods to the fast computation of leverage scores.",
      "startOffset" : 4,
      "endOffset" : 11
    }, {
      "referenceID" : 29,
      "context" : "See [3, 30] for details, and see [17] for the application of these methods to the fast computation of leverage scores.",
      "startOffset" : 4,
      "endOffset" : 11
    }, {
      "referenceID" : 16,
      "context" : "See [3, 30] for details, and see [17] for the application of these methods to the fast computation of leverage scores.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 9,
      "context" : "Below, we will evaluate an implementation of a variant of the main algorithm of [10] in the software environment R.",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 12,
      "context" : "4 Additional Related Work Our leverage-based methods for estimating β are related to resampling methods such as the bootstrap [13], and many of these resampling methods enjoy desirable asymptotic properties [40].",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 39,
      "context" : "4 Additional Related Work Our leverage-based methods for estimating β are related to resampling methods such as the bootstrap [13], and many of these resampling methods enjoy desirable asymptotic properties [40].",
      "startOffset" : 207,
      "endOffset" : 211
    }, {
      "referenceID" : 42,
      "context" : "Resampling methods in linear models were studied extensively in [43] and are related to the jackknife [31, 32, 22, 14].",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 30,
      "context" : "Resampling methods in linear models were studied extensively in [43] and are related to the jackknife [31, 32, 22, 14].",
      "startOffset" : 102,
      "endOffset" : 118
    }, {
      "referenceID" : 31,
      "context" : "Resampling methods in linear models were studied extensively in [43] and are related to the jackknife [31, 32, 22, 14].",
      "startOffset" : 102,
      "endOffset" : 118
    }, {
      "referenceID" : 21,
      "context" : "Resampling methods in linear models were studied extensively in [43] and are related to the jackknife [31, 32, 22, 14].",
      "startOffset" : 102,
      "endOffset" : 118
    }, {
      "referenceID" : 13,
      "context" : "Resampling methods in linear models were studied extensively in [43] and are related to the jackknife [31, 32, 22, 14].",
      "startOffset" : 102,
      "endOffset" : 118
    }, {
      "referenceID" : 22,
      "context" : "In addition, the goal of resampling is traditionally to perform statistical inference and not to improve the running time of an algorithm, except in the very recent work [23].",
      "startOffset" : 170,
      "endOffset" : 174
    }, {
      "referenceID" : 19,
      "context" : "Additional related work in statistics includes [20, 37, 26, 4, 36].",
      "startOffset" : 47,
      "endOffset" : 66
    }, {
      "referenceID" : 36,
      "context" : "Additional related work in statistics includes [20, 37, 26, 4, 36].",
      "startOffset" : 47,
      "endOffset" : 66
    }, {
      "referenceID" : 25,
      "context" : "Additional related work in statistics includes [20, 37, 26, 4, 36].",
      "startOffset" : 47,
      "endOffset" : 66
    }, {
      "referenceID" : 3,
      "context" : "Additional related work in statistics includes [20, 37, 26, 4, 36].",
      "startOffset" : 47,
      "endOffset" : 66
    }, {
      "referenceID" : 35,
      "context" : "Additional related work in statistics includes [20, 37, 26, 4, 36].",
      "startOffset" : 47,
      "endOffset" : 66
    }, {
      "referenceID" : 10,
      "context" : "However, for a fixed value of r, the linear approximation regime will be larger when the sample is constructed using information in the leverage scores—since, among other things, using leverage scores in the sampling process is designed to preserve the rank of the subsampled problem [11, 27, 10].",
      "startOffset" : 284,
      "endOffset" : 296
    }, {
      "referenceID" : 26,
      "context" : "However, for a fixed value of r, the linear approximation regime will be larger when the sample is constructed using information in the leverage scores—since, among other things, using leverage scores in the sampling process is designed to preserve the rank of the subsampled problem [11, 27, 10].",
      "startOffset" : 284,
      "endOffset" : 296
    }, {
      "referenceID" : 9,
      "context" : "However, for a fixed value of r, the linear approximation regime will be larger when the sample is constructed using information in the leverage scores—since, among other things, using leverage scores in the sampling process is designed to preserve the rank of the subsampled problem [11, 27, 10].",
      "startOffset" : 284,
      "endOffset" : 296
    }, {
      "referenceID" : 26,
      "context" : "A detailed discussion of this last point is available in [27]; and these observations will be confirmed empirically in Section 5.",
      "startOffset" : 57,
      "endOffset" : 61
    }, {
      "referenceID" : 10,
      "context" : ", explicitly or implicitly biasing toward high-leverage components, as is done in particular with the LEV procedure) provides uniformly superior worst-case algorithmic results, when compared with UNIF [11, 27, 10].",
      "startOffset" : 201,
      "endOffset" : 213
    }, {
      "referenceID" : 26,
      "context" : ", explicitly or implicitly biasing toward high-leverage components, as is done in particular with the LEV procedure) provides uniformly superior worst-case algorithmic results, when compared with UNIF [11, 27, 10].",
      "startOffset" : 201,
      "endOffset" : 213
    }, {
      "referenceID" : 9,
      "context" : ", explicitly or implicitly biasing toward high-leverage components, as is done in particular with the LEV procedure) provides uniformly superior worst-case algorithmic results, when compared with UNIF [11, 27, 10].",
      "startOffset" : 201,
      "endOffset" : 213
    }, {
      "referenceID" : 19,
      "context" : "(19), is the same as Hinkley’s weighted jackknife variance estimator [20].",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 9,
      "context" : ", πLev i = hii/p, or π Lev is constructed from the output of the algorithm of [10] that computes relative-error approximations to the leverage scores), and let πUnif denote the uniform distribution (i.",
      "startOffset" : 78,
      "endOffset" : 82
    }, {
      "referenceID" : 9,
      "context" : "Finally, all of these observations also hold if, rather that using the exact leverage score distribution (which recall takes O(np2) time to compute), we instead use approximate leverage scores, as computed with the fast algorithm of [10].",
      "startOffset" : 233,
      "endOffset" : 237
    }, {
      "referenceID" : 10,
      "context" : "These will also provide a more direct comparison with previous work that has adopted an algorithmic perspective on algorithmic leveraging [11, 27, 10].",
      "startOffset" : 138,
      "endOffset" : 150
    }, {
      "referenceID" : 26,
      "context" : "These will also provide a more direct comparison with previous work that has adopted an algorithmic perspective on algorithmic leveraging [11, 27, 10].",
      "startOffset" : 138,
      "endOffset" : 150
    }, {
      "referenceID" : 9,
      "context" : "These will also provide a more direct comparison with previous work that has adopted an algorithmic perspective on algorithmic leveraging [11, 27, 10].",
      "startOffset" : 138,
      "endOffset" : 150
    }, {
      "referenceID" : 9,
      "context" : "2, we will summarize our results on synthetic data when the leverage scores are computed approximately with the fast approximation algorithm of [10].",
      "startOffset" : 144,
      "endOffset" : 148
    }, {
      "referenceID" : 10,
      "context" : "(7), then with very high probability the matrix X∗ does not loose rank [11, 27, 10].",
      "startOffset" : 71,
      "endOffset" : 83
    }, {
      "referenceID" : 26,
      "context" : "(7), then with very high probability the matrix X∗ does not loose rank [11, 27, 10].",
      "startOffset" : 71,
      "endOffset" : 83
    }, {
      "referenceID" : 9,
      "context" : "(7), then with very high probability the matrix X∗ does not loose rank [11, 27, 10].",
      "startOffset" : 71,
      "endOffset" : 83
    }, {
      "referenceID" : 9,
      "context" : "2 Approximate Leveraging via the Fast Leveraging Algorithm Here, we will describe using the fast randomized algorithm from [10] to compute approximations to the leverage scores of X, to be used in place of the exact leverage scores in LEV, SLEV, and LEVUNW.",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 9,
      "context" : "To start, we provide a brief description of the algorithm of [10], which takes as input an arbitrary n× p matrix X.",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 9,
      "context" : "For appropriate choices of r1 and r2, if one chooses Π1 to be a Hadamard-based random projection matrix, then this algorithm runs in o(np2) time, and it returns 1 ± approximations to all the leverage scores of X [10].",
      "startOffset" : 212,
      "endOffset" : 216
    }, {
      "referenceID" : 2,
      "context" : "In addition, with a high-quality implementation of the Hadamard-based random projection, this algorithm runs faster than traditional deterministic algorithms based on Lapack for matrices as small as several thousand by several hundred [3, 17].",
      "startOffset" : 235,
      "endOffset" : 242
    }, {
      "referenceID" : 16,
      "context" : "In addition, with a high-quality implementation of the Hadamard-based random projection, this algorithm runs faster than traditional deterministic algorithms based on Lapack for matrices as small as several thousand by several hundred [3, 17].",
      "startOffset" : 235,
      "endOffset" : 242
    }, {
      "referenceID" : 9,
      "context" : "We have implemented in the software environment R two variants of this fast algorithm of [10], and we have compared it with QR-based deterministic algorithms also supported in R for",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 2,
      "context" : "(In particular, note that here we do not consider Hadamard-based projections for Π1 or more sophisticated parallel and distributed implementations of these algorithms [3, 30, 17, 44].",
      "startOffset" : 167,
      "endOffset" : 182
    }, {
      "referenceID" : 29,
      "context" : "(In particular, note that here we do not consider Hadamard-based projections for Π1 or more sophisticated parallel and distributed implementations of these algorithms [3, 30, 17, 44].",
      "startOffset" : 167,
      "endOffset" : 182
    }, {
      "referenceID" : 16,
      "context" : "(In particular, note that here we do not consider Hadamard-based projections for Π1 or more sophisticated parallel and distributed implementations of these algorithms [3, 30, 17, 44].",
      "startOffset" : 167,
      "endOffset" : 182
    }, {
      "referenceID" : 43,
      "context" : "(In particular, note that here we do not consider Hadamard-based projections for Π1 or more sophisticated parallel and distributed implementations of these algorithms [3, 30, 17, 44].",
      "startOffset" : 167,
      "endOffset" : 182
    }, {
      "referenceID" : 2,
      "context" : ", with n = 106 or more, then one should probably not work within R and instead use Hadamardbased random projections for Π1 and/or the use of more sophisticated methods, such as those described in [3, 30, 17, 44]; here we simply evaluate an implementation of these methods in R.",
      "startOffset" : 196,
      "endOffset" : 211
    }, {
      "referenceID" : 29,
      "context" : ", with n = 106 or more, then one should probably not work within R and instead use Hadamardbased random projections for Π1 and/or the use of more sophisticated methods, such as those described in [3, 30, 17, 44]; here we simply evaluate an implementation of these methods in R.",
      "startOffset" : 196,
      "endOffset" : 211
    }, {
      "referenceID" : 16,
      "context" : ", with n = 106 or more, then one should probably not work within R and instead use Hadamardbased random projections for Π1 and/or the use of more sophisticated methods, such as those described in [3, 30, 17, 44]; here we simply evaluate an implementation of these methods in R.",
      "startOffset" : 196,
      "endOffset" : 211
    }, {
      "referenceID" : 43,
      "context" : ", with n = 106 or more, then one should probably not work within R and instead use Hadamardbased random projections for Π1 and/or the use of more sophisticated methods, such as those described in [3, 30, 17, 44]; here we simply evaluate an implementation of these methods in R.",
      "startOffset" : 196,
      "endOffset" : 211
    }, {
      "referenceID" : 9,
      "context" : ") CPU time for calculating exact leverage scores and approximate leverage scores using the BFast and GFast versions of the fast algorithm of [10].",
      "startOffset" : 141,
      "endOffset" : 145
    }, {
      "referenceID" : 9,
      "context" : "All in all, using the fast approximation algorithm of [10] to compute approximations to the leverage scores for use in LEV, SLEV, and LEVUNW leads to improved algorithmic performance, while achieving nearly identical statistical results as LEV, SLEV, and LEVUNW when the exact leverage scores are used.",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 8,
      "context" : "3 Illustration of the Method on Real Data Here, we provide an illustration of our methods on two real data sets drawn from two problems in genetics with which we have prior experience [9, 28].",
      "startOffset" : 184,
      "endOffset" : 191
    }, {
      "referenceID" : 27,
      "context" : "3 Illustration of the Method on Real Data Here, we provide an illustration of our methods on two real data sets drawn from two problems in genetics with which we have prior experience [9, 28].",
      "startOffset" : 184,
      "endOffset" : 191
    }, {
      "referenceID" : 34,
      "context" : "For more information on the application of these ideas in genetics, see previous work on PCA-correlated SNPs [35, 34].",
      "startOffset" : 109,
      "endOffset" : 117
    }, {
      "referenceID" : 33,
      "context" : "For more information on the application of these ideas in genetics, see previous work on PCA-correlated SNPs [35, 34].",
      "startOffset" : 109,
      "endOffset" : 117
    }, {
      "referenceID" : 9,
      "context" : ") Comparison of variances and squared biases of the LEV, SLEV, and LEVUNW estimators in T3 data sets for n = 20000 and p = 5000 using BFast and GFast versions of the fast algorithm of [10].",
      "startOffset" : 184,
      "endOffset" : 188
    }, {
      "referenceID" : 14,
      "context" : "1 Linear model for bias correction in RNA-Seq data In order to illustrate how our methods perform on a real data set with nearly uniform leverage scores, we consider an RNA-Seq data set containing n = 51, 751 read counts from embryonic mouse stem cells [15].",
      "startOffset" : 253,
      "endOffset" : 257
    }, {
      "referenceID" : 24,
      "context" : "Recent work found that short-read counts have significant sequence bias [25].",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 8,
      "context" : "Here, we consider a simplified linear model of [9] for correcting sequence bias in RNA-Seq.",
      "startOffset" : 47,
      "endOffset" : 50
    }, {
      "referenceID" : 32,
      "context" : "2 Linear model for predicting gene expressions of cancer patient In order to illustrate how our methods perform on real data with moderately nonuniform leverage scores, we consider a microarray data set that was presented in [33] (and also considered in [28]) for 46 cancer patients with respect to n = 5, 520 genes.",
      "startOffset" : 225,
      "endOffset" : 229
    }, {
      "referenceID" : 27,
      "context" : "2 Linear model for predicting gene expressions of cancer patient In order to illustrate how our methods perform on real data with moderately nonuniform leverage scores, we consider a microarray data set that was presented in [33] (and also considered in [28]) for 46 cancer patients with respect to n = 5, 520 genes.",
      "startOffset" : 254,
      "endOffset" : 258
    }, {
      "referenceID" : 37,
      "context" : "In this case, the smaller the variance, the more “efficient” is the estimator [38].",
      "startOffset" : 78,
      "endOffset" : 82
    }, {
      "referenceID" : 1,
      "context" : "Assuming XTX is nonsingular, for a LS estimator β̂ols to converge to true value β0 in probability, it is sufficient and necessary that (XTX)−1 → 0 as n→∞ [2, 24].",
      "startOffset" : 154,
      "endOffset" : 161
    }, {
      "referenceID" : 23,
      "context" : "Assuming XTX is nonsingular, for a LS estimator β̂ols to converge to true value β0 in probability, it is sufficient and necessary that (XTX)−1 → 0 as n→∞ [2, 24].",
      "startOffset" : 154,
      "endOffset" : 161
    }, {
      "referenceID" : 1,
      "context" : "Although we have stated this as an assumption, one typically assumes an n-dependence for αn [2].",
      "startOffset" : 92,
      "endOffset" : 95
    }, {
      "referenceID" : 15,
      "context" : "The usual assumption that is made (typically for analytical convenience) is that αn = n [16].",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 27,
      "context" : "In light of our empirical results in Section 4 and the empirical observation that leverage scores are often very nonuniform [28, 17], it is an interesting question to ask whether the common assumption that αn = n is too restrictive, e.",
      "startOffset" : 124,
      "endOffset" : 132
    }, {
      "referenceID" : 16,
      "context" : "In light of our empirical results in Section 4 and the empirical observation that leverage scores are often very nonuniform [28, 17], it is an interesting question to ask whether the common assumption that αn = n is too restrictive, e.",
      "startOffset" : 124,
      "endOffset" : 132
    }, {
      "referenceID" : 10,
      "context" : "development of the leveraging paradigm [11, 27, 10].",
      "startOffset" : 39,
      "endOffset" : 51
    }, {
      "referenceID" : 26,
      "context" : "development of the leveraging paradigm [11, 27, 10].",
      "startOffset" : 39,
      "endOffset" : 51
    }, {
      "referenceID" : 9,
      "context" : "development of the leveraging paradigm [11, 27, 10].",
      "startOffset" : 39,
      "endOffset" : 51
    }, {
      "referenceID" : 7,
      "context" : "The asymptotic properties of such design matrix are so-called “in-fill” asymptotics [8].",
      "startOffset" : 84,
      "endOffset" : 87
    }, {
      "referenceID" : 41,
      "context" : ", the first column of X is 1 vector; and, in this case, the hiis are bounded below by 1/n and above by 1/wi [42].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 31,
      "context" : "It is worth noting that [32] showed αn = n in Assumption 1 implies that maxhii → 0.",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 38,
      "context" : "4 shows that Miller’s theorem does not hold for triangular array (with one pattern for even numbered observations and the other pattern for odd numbered observations) [39].",
      "startOffset" : 167,
      "endOffset" : 171
    }, {
      "referenceID" : 18,
      "context" : "(27) To simplify (26), we need the following two results of matrix differentiation, ∂Vec[X−1] ∂(VecX)T = −(X−1)T ⊗X−1, and ∂Vec[AWB] ∂wT = (B ⊗A) ] ∂wT , (28) where the details on these two results can be found on page 366-367 of [19].",
      "startOffset" : 230,
      "endOffset" : 234
    } ],
    "year" : 2013,
    "abstractText" : "One popular method for dealing with large-scale data sets is sampling. For example, by using the empirical statistical leverage scores as an importance sampling distribution, the method of algorithmic leveraging samples and rescales rows/columns of data matrices to reduce the data size before performing computations on the subproblem. This method has been successful in improving computational efficiency of algorithms for matrix problems such as least-squares approximation, least absolute deviations approximation, and low-rank matrix approximation. Existing work has focused on algorithmic issues such as worst-case running times and numerical issues associated with providing high-quality implementations, but none of it addresses statistical aspects of this method. In this paper, we provide a simple yet effective framework to evaluate the statistical properties of algorithmic leveraging in the context of estimating parameters in a linear regression model with a fixed number of predictors. In particular, for several versions of leverage-based sampling, we derive results for the bias and variance, both conditional and unconditional on the observed data. We show that from the statistical perspective of bias and variance, neither leverage-based sampling nor uniform sampling dominates the other. This result is particularly striking, given the well-known result that, from the algorithmic perspective of worst-case analysis, leverage-based sampling provides uniformly superior worst-case algorithmic results, when compared with uniform sampling. Based on these theoretical results, we propose and analyze two new leveraging algorithms: one constructs a smaller least-squares problem with “shrinked” leverage scores (SLEV), and the other solves a smaller and unweighted (or biased) least-squares problem (LEVUNW). A detailed empirical evaluation of existing leverage-based methods as well as these two new methods is carried out on both synthetic and real data sets. The empirical results indicate that our theory is a good predictor of practical performance of existing and new leverage-based algorithms and that the new algorithms achieve improved performance. For example, with the same computation reduction as in the original algorithmic leveraging approach, our proposed SLEV typically leads to improved biases and variances both unconditionally and conditionally (on the observed data), and our proposed LEVUNW typically yields improved unconditional biases and variances. ∗Department of Statistics, University of Illinois at Urbana-Champaign, Champaign, IL 61820. Email: pingma@illinois.edu. †Department of Mathematics, Stanford University, Stanford, CA 94305. Email: mmahoney@cs.stanford.edu. ‡Department of Statistics, University of California at Berkeley, Berkeley, CA 94720. Email: binyu@stat.berkeley.edu. 1 ar X iv :1 30 6. 53 62 v1 [ st at .M E ] 2 3 Ju n 20 13",
    "creator" : "LaTeX with hyperref package"
  }
}