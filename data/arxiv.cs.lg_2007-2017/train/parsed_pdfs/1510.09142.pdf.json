{
  "name" : "1510.09142.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Learning Continuous Control Policies by Stochastic Value Gradients",
    "authors" : [ "Nicolas Heess", "Greg Wayne", "David Silver", "Timothy Lillicrap", "Yuval Tassa", "Tom Erez" ],
    "emails" : [ "etom}@google.com" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Policy gradient algorithms maximize the expectation of cumulative reward by following the gradient of this expectation with respect to the policy parameters. Most existing algorithms estimate this gradient in a model-free manner by sampling returns from the real environment and rely on a likelihood ratio estimator [32, 26]. Such estimates tend to have high variance and require large numbers of samples or, conversely, low-dimensional policy parameterizations.\nA second approach to estimate a policy gradient relies on backpropagation instead of likelihood ratio methods. If a differentiable environment model is available, one can link together the policy, model, and reward function to compute an analytic policy gradient by backpropagation of reward along a trajectory [18, 11, 6, 9]. Instead of using entire trajectories, one can estimate future rewards using a learned value function (a critic) and compute policy gradients from subsequences of trajectories. It is also possible to backpropagate analytic action derivatives from a Q-function to compute the policy gradient without a model [31, 21, 23]. Following Fairbank [8], we refer to methods that compute the policy gradient through backpropagation as value gradient methods.\nIn this paper, we address two limitations of prior value gradient algorithms. The first is that, in contrast to likelihood ratio methods, value gradient algorithms are only suitable for training deterministic policies. Stochastic policies have several advantages: for example, they can be beneficial for partially observed problems [24]; they permit on-policy exploration; and because stochastic policies can assign probability mass to off-policy trajectories, we can train a stochastic policy on samples from an experience database in a principled manner. When an environment model is used, value gradient algorithms have also been critically limited to operation in deterministic environments. By exploiting a mathematical tool known as “re-parameterization” that has found recent use for generative models [20, 12], we extend the scope of value gradient algorithms to include the optimization of stochastic policies in stochastic environments. We thus describe our framework as Stochastic Value Gradient (SVG) methods. Secondly, we show that an environment dynamics model, value function, and policy can be learned jointly with neural networks based only on environment interaction. Learned dynamics models are often inaccurate, which we mitigate by computing value gradients along real system trajectories instead of planned ones, a feature shared by model-free\nar X\niv :1\n51 0.\n09 14\n2v 1\n[ cs\n.L G\n] 3\n0 O\nct 2\nmethods [32, 26]. This substantially reduces the impact of model error because we only use models to compute policy gradients, not for prediction, combining advantages of model-based and modelfree methods with fewer of their drawbacks.\nWe present several algorithms that range from model-based to model-free methods, flexibly combining models of environment dynamics with value functions to optimize policies in stochastic or deterministic environments. Experimentally, we demonstrate that SVG methods can be applied using generic neural networks with tens of thousands of parameters while making minimal assumptions about plants or environments. By examining a simple stochastic control problem, we show that SVG algorithms can optimize policies where model-based planning and likelihood ratio methods cannot. We provide evidence that value function approximation can compensate for degraded models, demonstrating the increased robustness of SVG methods over model-based planning. Finally, we use SVG algorithms to solve a variety of challenging, under-actuated, physical control problems, including swimming of snakes, reaching, tracking, and grabbing with a robot arm, fall-recovery for a monoped, and locomotion for a planar cheetah and biped."
    }, {
      "heading" : "2 Background",
      "text" : "We consider discrete-time Markov Decision Processes (MDPs) with continuous states and actions and denote the state and action at time step t by st ∈ RNS and at ∈ RNA , respectively. The MDP has an initial state distribution s0 ∼ p0(·), a transition distribution st+1 ∼ p(·|st,at), and a (potentially time-varying) reward function rt = r(st,at, t).1 We consider time-invariant stochastic policies a ∼ p(·|s; θ), parameterized by θ. The goal of policy optimization is to find policy parameters θ that maximize the expected sum of future rewards. We optimize either finite-horizon or infinite-horizon sums, i.e., J(θ) = E [∑T t=0 γ trt ∣∣θ] or J(θ) = E [∑∞t=0 γtrt∣∣θ] where γ ∈ [0, 1] is a discount factor.2 When possible, we represent a variable at the next time step using the “tick” notation, e.g., s′ , st+1.\nIn what follows, we make extensive use of the state-action-value Q-function and state-value Vfunction.\nQt(s,a) = E [∑ τ=t γτ−trτ ∣∣st = s,at = a, θ] ;V t(s) = E[∑ τ=t γτ−trτ ∣∣st = s, θ] . (1)\nFor finite-horizon problems, the value functions are time-dependent, e.g., V ′ , V t+1(s′), and for infinite-horizon problems the value functions are stationary, V ′ , V (s′). The relevant meaning should be clear from the context. The state-value function can be expressed recursively using the stochastic Bellman equation\nV t(s) = ∫ [ rt + γ ∫ V t+1(s′)p(s′|s,a)ds′ ] p(a|s; θ)da. (2)\nWe abbreviate partial differentiation using subscripts, gx , ∂g(x, y)/∂x."
    }, {
      "heading" : "3 Deterministic value gradients",
      "text" : "The deterministic Bellman equation takes the form V (s) = r(s,a)+γV ′(f(s,a)) for a deterministic model s′ = f(s,a) and deterministic policy a = π(s; θ). Differentiating the equation with respect to the state and policy yields an expression for the value gradient\nVs = rs + raπs + γV ′ s′(fs + faπs), (3) Vθ = raπθ + γV ′ s′faπθ + γV ′ θ . (4)\nIn eq. 4, the term γV ′θ arises because the total derivative includes policy gradient contributions from subsequent time steps (full derivation in Appendix A). For a purely model-based formalism, these equations are used as a pair of coupled recursions that, starting from the termination of a trajectory, proceed backward in time to compute the gradient of the value function with respect to the state and policy parameters. V 0θ returns the total policy gradient. When a state-value function is used\n1We make use of a time-varying reward function only in one problem to encode a terminal reward. 2γ < 1 for the infinite-horizon case.\nafter one step in the recursion, raπθ + γV ′s′faπθ directly expresses the contribution of the current time step to the policy gradient. Summing these gradients over the trajectory gives the total policy gradient. When a Q-function is used, the per-time step contribution to the policy gradient takes the form Qaπθ."
    }, {
      "heading" : "4 Stochastic value gradients",
      "text" : "One limitation of the gradient computation in eqs. 3 and 4 is that the model and policy must be deterministic. Additionally, the accuracy of the policy gradient Vθ is highly sensitive to modeling errors. We introduce two critical changes: First, in section 4.1, we transform the stochastic Bellman equation (eq. 2) to permit backpropagating value information in a stochastic setting. This also enables us to compute gradients along real trajectories, not ones sampled from a model, making the approach robust to model error, leading to our first algorithm “SVG(∞),” described in section 4.2. Second, in section 4.3, we show how value function critics can be integrated into this framework, leading to the algorithms “SVG(1)” and “SVG(0)”, which expand the Bellman recursion for 1 and 0 steps, respectively. Value functions further increase robustness to model error and extend our framework to infinite-horizon control."
    }, {
      "heading" : "4.1 Differentiating the stochastic Bellman equation",
      "text" : "Re-parameterization of distributions Our goal is to backpropagate through the stochastic Bellman equation. To do so, we make use of a concept called “re-parameterization”, which permits us to compute derivatives of deterministic and stochastic models in the same way. A very simple example of re-parameterization is to write a conditional Gaussian density p(y|x) = N (y|µ(x), σ2(x)) as the function y = µ(x) + σ(x)ξ, where ξ ∼ N (0, 1). From this point of view, one produces samples procedurally by first sampling ξ, then deterministically constructing y. Here, we consider conditional densities whose samples are generated by a deterministic function of an input noise variable and other conditioning variables: y = f(x, ξ), where ξ ∼ ρ(·), a fixed noise distribution. Rich density models can be expressed in this form [20, 12]. Expectations of a function g(y) become Ep(y|x)g(y) = ∫ g(f(x, ξ))ρ(ξ)dξ.\nThe advantage of working with re-parameterized distributions is that we can now obtain a simple Monte-Carlo estimator of the derivative of an expectation with respect to x:\n∇xEp(y|x)g(y) = Eρ(ξ)gyfx ≈ 1\nM M∑ i=1 gyfx ∣∣ ξ=ξi . (5)\nIn contrast to likelihood ratio-based Monte Carlo estimators,∇x log p(y|x)g(y), this formula makes direct use of the Jacobian of g.\nRe-parameterization of the Bellman equation We now re-parameterize the Bellman equation. When re-parameterized, the stochastic policy takes the form a = π(s, η; θ), and the stochastic environment the form s′ = f(s,a, ξ) for noise variables η ∼ ρ(η) and ξ ∼ ρ(ξ), respectively. Inserting these functions into eq. (2) yields\nV (s) = Eρ(η) [ r(s, π(s, η; θ)) + γEρ(ξ) [ V ′(f(s, π(s, η; θ), ξ)) ]] . (6)\nDifferentiating eq. 6 with respect to the current state s and policy parameters θ gives Vs = Eρ(η) [ rs + raπs + γEρ(ξ)V ′s′(fs + faπs) ] , (7)\nVθ = Eρ(η) [ raπθ + γEρ(ξ) [ V ′s′faπθ + V ′ θ ]] . (8)\nWe are interested in controlling systems with a priori unknown dynamics. Consequently, in the following, we replace instances of f or its derivatives with a learned model f̂ .\nGradient evaluation by planning A planning method to compute a gradient estimate is to compute a trajectory by running the policy in loop with a model while sampling the associated noise variables, yielding a trajectory τ = (s1, η1,a1, ξ1, s2, η2,a2, ξ2, . . . ). On this sampled trajectory, a Monte-Carlo estimate of the policy gradient can be computed by the backward recursions:\nvs = [rs + raπs + γv ′ s′(f̂s + f̂aπs)] ∣∣ η,ξ , (9)\nvθ = [raπθ + γ(v ′ s′ f̂aπθ + v ′ θ)] ∣∣ η,ξ , (10)\nwhere have written lower-case v to emphasize that the quantities are one-sample estimates3, and “ ∣∣ x ” means “evaluated at x”. Gradient evaluation on real trajectories An important advantage of stochastic over deterministic models is that they can assign probability mass to observations produced by the real environment. In a deterministic formulation, there is no principled way to account for mismatch between model predictions and observed trajectories. In this case, the policy and environment noise (η, ξ) that produced the observed trajectory are considered unknown. By an application of Bayes’ rule, which we explain in Appendix B, we can rewrite the expectations in equations 7 and 8 given the observations (s,a, s′) as\nVs = Ep(a|s)Ep(s′|s,a)Ep(η,ξ|s,a,s′) [ rs + raπ+γV ′ s′(f̂s + f̂aπs) ] , (11)\nVθ = Ep(a|s)Ep(s′|s,a)Ep(η,ξ|s,a,s′) [ raπθ + γ(V ′ s′ f̂aπθ + V ′ θ ) ] , (12)\nwhere we can now replace the two outer expectations with samples derived from interaction with the real environment. In the special case of additive noise, s′ = f̂(s,a) + ξ, it is possible to use a deterministic model to compute the derivatives (f̂s, f̂a). The noise’s influence is restricted to the gradient of the value of the next state, V ′s′ , and does not affect the model Jacobian. If we consider it desirable to capture more complicated environment noise, we can use a re-parameterized generative model and infer the missing noise variables, possibly by sampling from p(η, ξ|s,a, s′)."
    }, {
      "heading" : "4.2 SVG(∞)",
      "text" : "SVG(∞) computes value gradients by backward recursions on finite-horizon trajectories. After every episode, we train the model, f̂ , followed by the policy, π. We provide pseudocode for this in Algorithm 1 but discuss further implementation details in section 5 and in the experiments.\nAlgorithm 1 SVG(∞) 1: Given empty experience database D 2: for trajectory = 0 to∞ do 3: for t = 0 to T do 4: Apply control a = π(s, η; θ), η ∼ ρ(η) 5: Insert (s,a, r, s′) into D 6: end for 7: Train generative model f̂ using D 8: v′s = 0 (finite-horizon) 9: v′θ = 0 (finite-horizon) 10: for t = T down to 0 do 11: Infer ξ|(s,a, s′) and η|(s,a) 12: vθ = [raπθ + γ(v′s′ f̂aπθ + v ′ θ)] ∣∣ η,ξ\n13: vs = [rs + raπs + γv′s′(f̂s + f̂aπs)] ∣∣ η,ξ 14: end for 15: Apply gradient-based update using v0θ 16: end for\nAlgorithm 2 SVG(1) with Replay 1: Given empty experience database D 2: for t = 0 to∞ do 3: Apply control π(s, η; θ), η ∼ ρ(η) 4: Observe r, s′\n5: Insert (s,a, r, s′) into D 6: // Model and critic updates 7: Train generative model f̂ using D 8: Train value function V̂ using D (Alg. 4) 9: // Policy update\n10: Sample (sk,ak, rk, sk+1) from D (k ≤ t) 11: w = p(a\nk|sk;θt) p(ak|sk;θk)\n12: Infer ξk|(sk,ak, sk+1) and ηk|(sk,ak) 13: vθ = w(ra + γV̂ ′s′ f̂a)πθ ∣∣ ηk,ξk 14: Apply gradient-based update using vθ 15: end for"
    }, {
      "heading" : "4.3 SVG(1) and SVG(0)",
      "text" : "In our framework, we may learn a parametric estimate of the expected value V̂ (s; ν) (critic) with parameters ν. The derivative of the critic value with respect to the state, V̂s, can be used in place of the sample gradient estimate given in eq. (9). The critic can reduce the variance of the gradient estimates because V̂ approximates the expectation of future rewards while eq. (9) provides only a\n3In the finite-horizon formulation, the gradient calculation starts at the end of the trajectory for which the only terms remaining in eq. (9) are vTs ≈ rTs + rTa πTs . After the recursion, the total derivative of the value function with respect to the policy parameters is given by v0θ , which is a one-sample estimate of∇θJ .\nsingle-trajectory estimate. Additionally, the value function can be used at the end of an episode to approximate the infinite-horizon policy gradient. Finally, eq. (9) involves the repeated multiplication of Jacobians of the approximate model f̂s, f̂a. Just as model error can compound in forward planning, model gradient error can compound during backpropagation. Furthermore, SVG(∞) is on-policy. That is, after each episode, a single gradient-based update is made to the policy, and the policy optimization does not revisit those trajectory data again. To increase data-efficiency, we construct an off-policy, experience replay [15, 29] algorithm that uses models and value functions, SVG(1) with Experience Replay (SVG(1)-ER). This algorithm also has the advantage that it can perform an infinite-horizon computation.\nTo construct an off-policy estimator, we perform importance-weighting of the current policy distribution with respect to a proposal distribution, q(s,a):\nV̂θ = Eq(s,a)Ep(s′|s,a)Ep(η,ξ|s,a,s′) p(a|s; θ) q(a|s)\n[ raπθ + γV̂ ′ s f̂aπθ ] . (13)\nSpecifically, we maintain a database with tuples of past state transitions (sk,ak, rk, sk+1). Each proposal drawn from q is a sample of a tuple from the database. At time t, the importance-weight w , p/q = p(a\nk|sk;θt) p(ak|sk,θk) , where θ\nk comprise the policy parameters in use at the historical time step k. We do not importance-weight the marginal distribution over states q(s) generated by a policy; this is widely considered to be intractable.\nSimilarly, we use experience replay for value function learning. Details can be found in Appendix C. Pseudocode for the SVG(1) algorithm with Experience Replay is in Algorithm 2.\nWe also provide a model-free stochastic value gradient algorithm, SVG(0) (Algorithm 3 in the Appendix). This algorithm is very similar to SVG(1) and is the stochastic analogue of the recently introduced Deterministic Policy Gradient algorithm (DPG) [23, 14, 4]. Unlike DPG, instead of assuming a deterministic policy, SVG(0) estimates the derivative around the policy noise Ep(η) [ Qaπθ\n∣∣η].4 This, for example, permits learning policy noise variance. The relative merit of SVG(1) versus SVG(0) depends on whether the model or value function is easier to learn and is task-dependent. We expect that model-based algorithms such as SVG(1) will show the strongest advantages in multitask settings where the system dynamics are fixed, but the reward function is variable. SVG(1) performed well across all experiments, including ones introducing capacity constraints on the value function and model. SVG(1)-ER demonstrated a significant advantage over all other tested algorithms."
    }, {
      "heading" : "5 Model and value learning",
      "text" : "We can use almost any kind of differentiable, generative model. In our work, we have parameterized the models as neural networks. Our framework supports nonlinear state- and action-dependent noise, notable properties of biological actuators. For example, this can be described by the parametric form f̂(s,a, ξ) = µ̂(s,a) + σ̂(s,a)ξ. Model learning amounts to a purely supervised problem based on observed state transitions. Our model and policy training occur jointly. There is no “motorbabbling” period used to identify the model. As new transitions are observed, the model is trained first, followed by the value function (for SVG(1)), followed by the policy. To ensure that the model does not forget information about state transitions, we maintain an experience database and cull batches of examples from the database for every model update. Additionally, we model the statechange by s′ = f̂(s,a, ξ) + s and have found that constructing models as separate sub-networks per predicted state dimension improved model quality significantly.\nOur framework also permits a variety of means to learn the value function models. We can use temporal difference learning [25] or regression to empirical episode returns. Since SVG(1) is modelbased, we can also use Bellman residual minimization [3]. In practice, we used a version of “fitted” policy evaluation. Pseudocode is available in Appendix C, Algorithm 4."
    }, {
      "heading" : "6 Experiments",
      "text" : "We tested the SVG algorithms in two sets of experiments. In the first set of experiments (section 6.1), we test whether evaluating gradients on real environment trajectories and value function ap-\n4Note that π is a function of the state and noise variable.\nproximation can reduce the impact of model error. In our second set (section 6.2), we show that SVG(1) can be applied to several complicated, multidimensional physics environments involving contact dynamics (Figure 1) in the MuJoCo simulator [28]. Below we only briefly summarize the main properties of each environment: further details of the simulations can be found in Appendix D and supplement. In all cases, we use generic, 2 hidden-layer neural networks with tanh activation functions to represent models, value functions, and policies. A video montage is available at https://youtu.be/PYdL7bcn_cM."
    }, {
      "heading" : "6.1 Analyzing SVG",
      "text" : "Gradient evaluation on real trajectories vs. planning To demonstrate the difficulty of planning with a stochastic model, we first present a very simple control problem for which SVG(∞) easily learns a control policy but for which an otherwise identical planner fails entirely. Our example is based on a problem due to [16]. The policy directly controls the velocity of a point-mass “hand” on a 2D plane. By means of a spring-coupling, the hand exerts a force on a ball mass; the ball additionally experiences a gravitational force and random forces (Gaussian noise). The goal is to bring hand and ball into one of two randomly chosen target configurations with a relevant reward being provided only at the final time step.\nWith simulation time step 0.01s, this demands controlling and backpropagating the distal reward along a trajectory of 1, 000 steps. Because this experiment has a non-stationary, time-dependent value function, this problem also favors model-based value gradients over methods using value functions. SVG(∞) easily learns this task, but the planner, which uses trajectories from the model, shows little improvement. The planner simulates trajectories using the learned stochastic model and backpropagates along those simulated trajectories (eqs. 9 and 10) [18]. The extremely long time-horizon lets prediction error accumulate and thus renders roll-outs highly inaccurate, leading to much worse final performance (c.f. Fig. 2, left).5\nRobustness to degraded models and value functions We investigated the sensitivity of SVG(∞) and SVG(1) to the quality of the learned model on Swimmer. Swimmer is a chain body with multiple links immersed in a fluid environment with drag forces that allow the body to propel itself [5, 27]. We build chains of 3, 5, or 7 links, corresponding to 10, 14, or 18-dimensional state spaces with 2, 4, or 6-dimensional action spaces. The body is initialized in random configurations with respect to a central goal location. Thus, to solve the task, the body must turn to re-orient and then produce an undulation to move to the goal.\nTo assess the impact of model quality, we learned to control a link-3 swimmer with SVG(∞) and SVG(1) while varying the capacity of the network used to model the environment (5, 10, or 20 hidden units for each state dimension subnetwork (Appendix D); i.e., in this task we intentionally shrink the neural network model to investigate the sensitivity of our methods to model inaccuracy. While with a high capacity model (20 hidden units per state dimension), both SVG(∞) and SVG(1) successfully learn to solve the task, the performance of SVG(∞) drops significantly as model capacity is reduced (c.f. Fig. 3, middle). SVG(1) still works well for models with only 5 hidden units, and it also scales up to 5 and 7-link versions of the swimmer (Figs. 3, right and 4, left). To compare SVG(1) to conventional model-free approaches, we also tested a state-of-the-art actor-critic algorithm that learns a V -function and updates the policy using the TD-error δ = r + γV ′ − V as an estimate of the advantage, yielding the policy gradient vθ = δ∇θ log π [30]. (SVG(1) and the AC algorithm used the same code for learning V .) SVG(1) outperformed the model-free approach in the 3-, 5-, and 7-link swimmer tasks (c.f. Fig. 3, left, right; Fig. 4, top left). In figure panels 2, middle, 3, right, and 4, left column, we show that experience replay for the policy can improve the data efficiency and performance of SVG(1).\n5We also tested REINFORCE on this problem but achieved very poor results due to the long horizon.\nSimilarly, we tested the impact of varying the capacity of the value function approximator (Fig. 2, right) on a cart-pole. The V-function-based SVG(1) degrades less severely than the Q-functionbased DPG presumably because it computes the policy gradient with the aid of the dynamics model."
    }, {
      "heading" : "6.2 SVG in complex environments",
      "text" : "In a second set of experiments we demonstrated that SVG(1)-ER can be applied to several challenging physical control problems with stochastic, non-linear, and discontinuous dynamics due to contacts. Reacher is an arm stationed within a walled box with 6 state dimensions and 3 action dimensions and the (x, y) coordinates of a target site, giving 8 state dimensions in total. In 4-Target Reacher, the site was randomly placed at one of the four corners of the box, and the arm in a random configuration at the beginning of each trial. In Moving-Target Reacher, the site moved at a randomized speed and heading in the box with reflections at the walls. Solving this latter problem implies that the policy has generalized over the entire work space. Gripper augments the reacher arm with a manipulator that can grab a ball in a randomized position and return it to a specified site. Monoped has 14 state dimensions, 4 action dimensions, and ground contact dynamics. The monoped begins falling from a height and must remain standing. Additionally, we apply Gaussian random noise to the torques controlling the joints with a standard deviation of 5% of the total possible actuator strength at all points in time, reducing the stability of upright postures. Half-Cheetah is a planar cat robot designed to run based on [29] with 18 state dimensions and 6 action dimensions. Half-Cheetah has a version with springs to aid balanced standing and a version without them. Walker is a planar biped, based on the environment from [22]. Results Figure 4 shows learning curves for several repeats for each of the tasks. We found that in all cases SVG(1) solved the problem well; we provide videos of the learned policies in the supplemental material. The 4-target reacher reliably finished at the target site, and in the tracking task followed the moving target successfully. SVG(1)-ER has a clear advantage on this task as also borne out in the cart-pole and swimmer experiments. The cheetah gaits varied slightly from experiment to experiment but in all cases made good forward progress. For the monoped, the policies were able to balance well beyond the 200 time steps of training episodes and were able to resist significantly\nhigher adversarial noise levels than used during training (up to 25% noise). We were able to learn gripping and walking behavior, although walking policies that achieved similar reward levels did not always exhibit equally good walking phenotypes."
    }, {
      "heading" : "7 Related work",
      "text" : "Writing the noise variables as exogenous inputs to the system to allow direct differentiation with respect to the system state (equation 7) is a known device in control theory [10, 7] where the model is given analytically. The idea of using a model to optimize a parametric policy around real trajectories is presented heuristically in [17] and [1] for deterministic policies and models. Also in the limit of deterministic policies and models, the recursions we have derived in Algorithm 1 reduce to those of [2]. Werbos defines an actor-critic algorithm called Heuristic Dynamic Programming that uses a deterministic model to roll-forward one step to produce a state prediction that is evaluated by a value function [31]. Deisenroth et al. have used Gaussian process models to compute policy gradients that are sensitive to model-uncertainty [6], and Levine et al. have optimized impressive policies with the aid of a non-parametric trajectory optimizer and locally-linear models [13]. Our work in contrast has focused on using global, neural network models conjoined to value function approximators."
    }, {
      "heading" : "8 Discussion",
      "text" : "We have shown that two potential problems with value gradient methods, their reliance on planning and restriction to deterministic models, can be exorcised, broadening their relevance to reinforcement learning. We have shown experimentally that the SVG framework can train neural network policies in a robust manner to solve interesting continuous control problems. The framework includes algorithm variants beyond the ones tested in this paper, for example, ones that combine a value function with k steps of back-propagation through a model (SVG(k)). Augmenting SVG(1) with experience replay led to the best results, and a similar extension could be applied to any SVG(k). Furthermore, we did not harness sophisticated generative models of stochastic dynamics, but one could readily do so, presenting great room for growth.\nAcknowledgements We thank Arthur Guez, Danilo Rezende, Hado van Hasselt, John Schulman, Jonathan Hunt, Nando de Freitas, Martin Riedmiller, Remi Munos, Shakir Mohamed, and Theophane Weber for helpful discussions and John Schulman for sharing his walker model."
    }, {
      "heading" : "A Derivation of recursive gradient of the deterministic value function",
      "text" : "The use of derivatives in equation 4 is subtle, so we expand on the logic here. We first note that a change to the policy parameters affects the immediate action as well as each future state and action. Thus, the total derivative d dθ can be expanded to\nd\ndθ = [∑ t≥0 dat dθ ∂ ∂at + ∑ t>0 dst dθ ∂ ∂st ]\n=\n( da0\ndθ\n∂ ∂a0 + ds1 dθ ∂ ∂s1\n) + [∑ t≥1 dat dθ ∂ ∂at + ∑ t>1 dst dθ ∂ ∂st ] .\nLet us define the operator ∇tθ , [∑ t′≥t dat ′ dθ ∂ ∂at ′ + ∑ t′>t dst ′ dθ ∂ ∂st ′ ] . The operator obeys the recursive\nformula\n∇tθ = ( dat\ndθ\n∂ ∂at + dst+1 dθ ∂ ∂st+1\n) +∇t+1θ .\nWe can transform this to\n∇tθ = dat\ndθ\n( ∂\n∂at + dst+1 dat ∂ ∂st+1\n) +∇t+1θ .\nThe value function depends on the policy parameters V t(st; θ). The deterministic Bellman equation can be specified as V t(st; θ) = r(st,at) + γV t+1(st+1; θ). Now, we can apply the operator∇tθ:\n∇tθV t(st; θ) = ∇tθ [ r(st,at) + γV t+1(st+1; θ) ] = [ dat\ndθ\n( ∂\n∂at + dst+1 dat ∂ ∂st+1\n) +∇t+1θ ][ r(st,at) + γV t+1(st+1; θ) ] = dat\ndθ\n∂\n∂at r(st,at) +\ndat\ndθ\ndst+1\ndat ∂ ∂st+1 γV t+1(st+1; θ) +∇t+1θ γV t+1(st+1; θ).\nIn the “tick” notation of the main text, this is equation 4."
    }, {
      "heading" : "B Gradient calculation for noise models",
      "text" : "Evaluating the Jacobian terms in equations in equations 9 and 10) may require knowledge of the noise variables η and ξ. This poses no difficulty when we obtain trajectory samples by forward-sampling η, ξ and computing (a, s′) using the policy and learned system model.\nHowever, the same is not true when we sample trajectories from the real environment. Here, the noise variables are unobserved and may need to be “filled in” to evaluate the Jacobians around the right arguments.\nEquations 11 and 12 arise from an application of Bayes’ rule. We formally invert the forward sampling process that generates samples from the joint distribution p(a, s′, η, ξ|s). Instead of sampling η, ξ ∼ ρ and then a ∼ p(a|s, η), s′ ∼ p(·|s,a, ξ), we first sample a ∼ p(a|s) and s′ ∼ p(s′|s,a) using our policy and the real environment. Given these data and a function g of them, we sample η, ξ ∼ p(η, ξ|s,a, s′) to produce\nEρ(ξ,η)Ep(a,s′|s,ξ,η)g(s,a, s′, ξ, η) = Ep(ξ,η,a,s′|s)g(s,a, s′, ξ, η) = Ep(a,s′|s)Ep(ξ,η|s,a,s′)g(s,a, s′, ξ, η). (14)\nFor example, in eq. 11, we plug in g(s,a, s′, ξ, η) = rs + raπs + γV ′s′(f̂s + f̂aπs)."
    }, {
      "heading" : "C Model and value learning",
      "text" : "We found that the models exhibited the lowest per-step prediction error when the µ̂ and σ̂ vector components were computed by parallel subnetworks, producing one (µ̂, σ̂) pair for each state dimension, i.e., [(µ̂1, σ̂1); (µ̂2, σ̂2); . . . ]. (This was due to varied scaling of the dynamic range of the state dimensions.) In the experiments in this paper, the σ̂ components were parametrized as constant biases per dimension. (As remarked in the main text, this implies that they do not contribute to the gradient calculation. However, in the Hand environment, the planner agent forward-samples based on the learned standard deviations.)\nAlgorithm 3 SVG(0) with Replay 1: Given empty experience database D 2: for t = 0 to∞ do 3: Apply control π(s, η; θ), η ∼ ρ(η) 4: Observe r, s′ 5: Insert (s,a, r, s′) into D 6: // Critic updates 7: Train value function Q̂ using D 8: // Policy update 9: Sample (sk,ak, rk, sk+1,ak+1) fromD\n(k < t) 10: Infer ηk|(sk,ak) 11: vθ = Q̂aπθ ∣∣ ηk 12: Apply gradient-based update using vθ 13: end for\nAlgorithm 4 Fitted Policy Evaluation 1: Given experience database D 2: Given value function V̂ (·, ν), outer loop\ntime t 3: νnew = ν 4: for m = 0 to M do 5: Sample (sk,ak, rk, sk+1) from D (k < t) 6: ym = rk + γV̂ (sk+1; ν) 7: w = p(a k|sk;θt)\np(ak|sk;θk)\n8: ∆ = ∇νnew w2 (y m − V̂ (sk; νnew))2 9: Apply gradient-based update to νnew using ∆ 10: Every C updates, set ν = νnew (C = 50) 11: end for"
    }, {
      "heading" : "D Experimental details",
      "text" : "For a direct comparison we ran SVG(0), SVG(1), SVG(∞), and DPG without experience replay for the policy updates since replay is not possible for SVG(∞). (All algorithms use replay for the value function updates.) We further implemented SVG(1)-ER such that policy updates are performed at the end of each episode, following the update of the value function, rather than following each step of interaction with the environment. For K steps of replay for the policy we perform K gradient steps according to lines 10-14 in Algorithm 2, drawing new data from the databaseD in each step. In some cases we found it helpful to apply an additional regularizer that penalized Es [DKL[πθk−1 ||πθ]] during each step of replay, where πθ denotes the policy at the beginning of the update and πθk−1 the policy after k − 1 steps of replay. The expectation with respect to s is taken over the empirical distribution of states in D. Following [30] we truncated importance weights (using a maximum value of 5 for all experiments except for the 4-target reacher and gripper where we used 20).\nComputing the policy gradient with SVG(∞) involves backpropagation through what is effectively a recurrent network. (Each time-step involves a concatenation of two multi-layer networks for policy and dynamics model. The full model is a chain of these pairs.) In line with findings for training standard recurrent networks, we found that “clipping” the policy gradient improved stability. Following [19] we chose to limit the norm of the policy gradient; i.e., we performed backpropagation for an episode as described above and then renormalized\nv0θ if its norm exceeded a set threshold V max θ : ṽ 0 θ = v0θ ‖v0 θ ‖ min(V max θ , ‖v0θ‖). We used this approach for all algorithms although it was primarily necessary for SVG(∞).\nWe optimized hyper-parameters separately for each algorithm by first identifying a reasonable range for the relevant hyper-parameters and then performing a more systematic grid search. The main parameters optimized were: learning rates for policy, value function, and model (as applicable); the number of updates per episode for policy, value function, and model (as applicable); regularization as described above for SVG(1)-ER; V maxθ ; the standard deviation of the Gaussian policy noise.\nHand\nrt(s,a) = { α1||a||2 t < 10s, α2[d(hand, 0) + d(ball, target)] t = 10s,\n(15)\nfor Euclidean distance d(·, ·).\nSwimmer r(s,a) = α1r̂goal · vc.o.m + α2||a||2, where r̂goal is a unit vector pointing from the nose to the goal.\nFor the MuJoCo environment problems, we provide .xml task descriptions.\nDiscount factors Hand: 1.0; Swimmer: 0.995; Reacher: 0.98; Gripper: 0.98; Hopper: 0.95; Cheetah: 0.98; Walker: 0.98"
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : "We present a unified framework for learning continuous control policies using<lb>backpropagation. It supports stochastic control by treating stochasticity in the<lb>Bellman equation as a deterministic function of exogenous noise. The product<lb>is a spectrum of general policy gradient algorithms that range from model-free<lb>methods with value functions to model-based methods without value functions.<lb>We use learned models but only require observations from the environment in-<lb>stead of observations from model-predicted trajectories, minimizing the impact<lb>of compounded model errors. We apply these algorithms first to a toy stochastic<lb>control problem and then to several physics-based control problems in simulation.<lb>One of these variants, SVG(1), shows the effectiveness of learning models, value<lb>functions, and policies simultaneously in continuous domains.",
    "creator" : "LaTeX with hyperref package"
  }
}