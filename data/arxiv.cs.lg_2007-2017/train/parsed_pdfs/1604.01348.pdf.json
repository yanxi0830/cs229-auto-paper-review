{
  "name" : "1604.01348.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Bayesian Optimization with Exponential Convergence",
    "authors" : [ "Kenji Kawaguchi", "Leslie Pack Kaelbling" ],
    "emails" : [ "kawaguch@mit.edu", "lpk@csail.mit.edu", "tlp@csail.mit.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "This paper presents a Bayesian optimization method with exponential convergence without the need of auxiliary optimization and without the δ-cover sampling. Most Bayesian optimization methods require auxiliary optimization: an additional non-convex global optimization problem, which can be time-consuming and hard to implement in practice. Also, the existing Bayesian optimization method with exponential convergence [1] requires access to the δ-cover sampling, which was considered to be impractical [1, 2]. Our approach eliminates both requirements and achieves an exponential convergence rate."
    }, {
      "heading" : "1 Introduction",
      "text" : "We consider a general global optimization problem: maximize f(x) subject to x ∈ Ω ⊂ RD where f : Ω → R is a non-convex black-box deterministic function. Such a problem arises in many realworld applications, such as parameter tuning in machine learning [3], engineering design problems [4], and model parameter fitting in biology [5]. For this problem, one performance measure of an algorithm is the simple regret, rn, which is given by rn = supx∈Ω f(x) − f(x+) where x+ is the best input vector found by the algorithm. For brevity, we use the term “regret” to mean simple regret.\nThe general global optimization problem is known to be intractable if we make no further assumptions [6]. The simplest additional assumption to restore tractability is to assume the existence of a bound on the slope of f . A well-known variant of this assumption is Lipschitz continuity with a known Lipschitz constant, and many algorithms have been proposed in this setting [7, 8, 9]. These algorithms successfully guaranteed certain bounds on the regret. However appealing from a theoretical point of view, a practical concern was soon raised regarding the assumption that a tight Lipschitz constant is known. Some researchers relaxed this somewhat strong assumption by proposing procedures to estimate a Lipschitz constant during the optimization process [10, 11, 12].\nBayesian optimization is an efficient way to relax this assumption of complete knowledge of the Lipschitz constant, and has become a well-recognized method for solving global optimization problems with non-convex black-box functions. In the machine learning community, Bayesian optimization— especially by means of a Gaussian process (GP)—is an active research area [13, 14, 15]. With the requirement of the access to the δ-cover sampling procedure (it samples the function uniformly such that the density of samples doubles in the feasible regions at each iteration), de Freitas et al. [1] recently proposed a theoretical procedure that maintains an exponential convergence rate (exponential regret). However, as pointed out by Wang et al. [2], one remaining problem is to derive a GP-based optimization method with an exponential convergence rate without the δ-cover sampling procedure, which is computationally too demanding in many cases.\nIn this paper, we propose a novel GP-based global optimization algorithm, which maintains an exponential convergence rate and converges rapidly without the δ-cover sampling procedure.\nar X\niv :1\n60 4.\n01 34\n8v 1\n[ st\nat .M\nL ]\n5 A\npr 2"
    }, {
      "heading" : "2 Gaussian Process Optimization",
      "text" : "In Gaussian process optimization, we estimate the distribution over function f and use this information to decide which point of f should be evaluated next. In a parametric approach, we consider a parameterized function f(x; θ), with θ being distributed according to some prior. In contrast, the nonparametric GP approach directly puts the GP prior over f as f(·) ∼ GP (m(·), κ(·, ·)) wherem(·) is the mean function and κ(·, ·) is the covariance function or the kernel. That is, m(x) = E[f(x)] and κ(x, x′) = E[(f(x)−m(x))(f(x′)−m(x′))T ]. For a finite set of points, the GP model is simply a joint Gaussian: f(x1:N ) ∼ N (m(x1:N ),K), where Ki,j = κ(xi, xj) and N is the number of data points. To predict the value of f at a new data point, we first consider the joint distribution over f of the old data points and the new data point:\n( f(x1:N ) f(xN+1) ) ∼ N ( m(x1:N ) m(xN+1) , [ K k kT κ(xN+1, xN+1) ]) where k = κ(x1:N ,xN+1) ∈ RN×1. Then, after factorizing the joint distribution using the Schur complement for the joint Gaussian, we obtain the conditional distribution, conditioned on observed entities DN := {x1:N , f(x1:N )} and xN+1, as:\nf(xN+1)|DN , xN+1 ∼ N (µ(xN+1|DN ), σ2(xN+1|DN )) where µ(xN+1|DN ) = m(xN+1) + kTK−1(f(x1:N ) − m(x1:N )) and σ2(xN+1|DN ) = κ(xN+1,xN+1)− kTK−1k. One advantage of GP is that this closed-form solution simplifies both its analysis and implementation.\nTo use a GP, we must specify the mean function and the covariance function. The mean function is usually set to be zero. With this zero mean function, the conditional mean µ(xN+1|DN ) can still be flexibly specified by the covariance function, as shown in the above equation for µ. For the covariance function, there are several common choices, including the Matern kernel and the Gaussian kernel. For example, the Gaussian kernel is defined as κ(x, x′) = exp ( − 12 (x− x ′) T Σ−1(x− x′) ) where Σ−1 is the kernel parameter matrix. The kernel parameters or hyperparameters can be estimated by empirical Bayesian methods [16]; see [17] for more information about GP.\nThe flexibility and simplicity of the GP prior make it a common choice for continuous objective functions in the Bayesian optimization literature. Bayesian optimization with GP selects the next query point that optimizes the acquisition function generated by GP. Commonly used acquisition functions include the upper confidence bound (UCB) and expected improvement (EI). For brevity, we consider Bayesian optimization with UCB, which works as follows. At each iteration, the UCB function U is maintained as U(x|DN ) = µ(x|DN ) + ςσ(x|DN ) where ς ∈ R is a parameter of the algorithm. To find the next query xn+1 for the objective function f , GP-UCB solves an additional non-convex optimization problem with U as xN+1 = arg maxx U(x|DN ). This is often carried out by other global optimization methods such as DIRECT and CMA-ES. The justification for introducing a new optimization problem lies in the assumption that the cost of evaluating the objective function f dominates that of solving additional optimization problem.\nFor deterministic function, de Freitas et al. [1] recently presented a theoretical procedure that maintains exponential convergence rate. However, their own paper and the follow-up research [1, 2] point out that this result relies on an impractical sampling procedure, the δ-cover sampling. To overcome this issue, Wang et al. [2] combined GP-UCB with a hierarchical partitioning optimization method, the SOO algorithm [18], providing a regret bound with polynomial dependence on the number of function evaluations. They concluded that creating a GP-based algorithm with an exponential convergence rate without the impractical sampling procedure remained an open problem."
    }, {
      "heading" : "3 Infinite-Metric GP Optimization",
      "text" : ""
    }, {
      "heading" : "3.1 Overview",
      "text" : "The GP-UCB algorithm can be seen as a member of the class of bound-based search methods, which includes Lipschitz optimization, A* search, and PAC-MDP algorithms with optimism in the\nface of uncertainty. Bound-based search methods have a common property: the tightness of the bound determines its effectiveness. The tighter the bound is, the better the performance becomes. However, it is often difficult to obtain a tight bound while maintaining correctness. For example, in A* search, admissible heuristics maintain the correctness of the bound, but the estimated bound with admissibility is often too loose in practice, resulting in a long period of global search.\nThe GP-UCB algorithm has the same problem. The bound in GP-UCB is represented by UCB, which has the following property: f(x) ≤ U(x|D) with some probability. We formalize this property in the analysis of our algorithm. The problem is essentially due to the difficulty of obtaining a tight bound U(x|D) such that f(x) ≤ U(x|D) and f(x) ≈ U(x|D) (with some probability). Our solution strategy is to first admit that the bound encoded in GP prior may not be tight enough to be useful by itself. Instead of relying on a single bound given by the GP, we leverage the existence of an unknown bound encoded in the continuity at a global optimizer.\nAssumption 1. (Unknown Bound) There exists a global optimizer x∗ and an unknown semi-metric ` such that for all x ∈ Ω, f(x∗) ≤ f(x) + ` (x, x∗) and ` (x, x∗) <∞.\nIn other words, we do not expect the known upper bound due to GP to be tight, but instead expect that there exists some unknown bound that might be tighter. Notice that in the case where the bound by GP is as tight as the unknown bound by semi-metric ` in Assumption 1, our method still maintains an exponential convergence rate and an advantage over GP-UCB (no need for auxiliary optimization). Our method is expected to become relatively much better when the known bound due to GP is less tight compared to the unknown bound by `.\nAs the semi-metric ` is unknown, there are infinitely many possible candidates that we can think of for `. Accordingly, we simultaneously conduct global and local searches based on all the candidates of the bounds. The bound estimated by GP is used to reduce the number of candidates. Since the bound estimated by GP is known, we can ignore the candidates of the bounds that are looser than the bound estimated by GP. The source code of the proposed algorithm is publicly available at http://lis.csail.mit.edu/code/imgpo.html."
    }, {
      "heading" : "3.2 Description of Algorithm",
      "text" : "Figure 1 illustrates how the algorithm works with a simple 1-dimensional objective function. We employ hierarchical partitioning to maintain hyperintervals, as illustrated by the line segments in the figure. We consider a hyperrectangle as our hyperinterval, with its center being the evaluation point of f (blue points in each line segment in Figure 1). For each iteration t, the algorithm performs the following procedure for each interval size:\n(i) Select the interval with the maximum center value among the intervals of the same size.\n(ii) Keep the interval selected by (i) if it has a center value greater than that of any larger interval.\n(iii) Keep the interval accepted by (ii) if it contains a UCB greater than the center value of any smaller interval.\n(iv) If an interval is accepted by (iii), divide it along with the longest coordinate into three new intervals.\n(v) For each new interval, if the UCB of the evaluation point is less than the best function value found so far, skip the evaluation and use the UCB value as the center value until the interval is accepted in step (ii) on some future iteration; otherwise, evaluate the center value.\n(vi) Repeat steps (i)–(v) until every size of intervals are considered\nThen, at the end of each iteration, the algorithm updates the GP hyperparameters. Here, the purpose of steps (i)–(iii) is to select an interval that might contain the global optimizer. Steps (i) and (ii) select the possible intervals based on the unknown bound by `, while Step (iii) does so based on the bound by GP.\nWe now explain the procedure using the example in Figure 1. Let n be the number of divisions of intervals and let N be the number of function evaluations. t is the number of iterations. Initially, there is only one interval (the center of the input region Ω ⊂ R) and thus this interval is divided,\nresulting in the first diagram of Figure 1. At the beginning of iteration t = 2 , step (i) selects the third interval from the left side in the first diagram (t = 1, n = 2), as its center value is the maximum. Because there are no intervals of different size at this point, steps (ii) and (iii) are skipped. Step (iv) divides the third interval, and then the GP hyperparameters are updated, resulting in the second diagram (t = 2, n = 3). At the beginning of iteration t = 3, it starts conducting steps (i)–(v) for the largest intervals. Step (i) selects the second interval from the left side and step (ii) is skipped. Step (iii) accepts the second interval, because the UCB within this interval is no less than the center value of the smaller intervals, resulting in the third diagram (t = 3, n = 4). Iteration t = 3 continues by conducting steps (i)–(v) for the smaller intervals. Step (i) selects the second interval from the left side, step (ii) accepts it, and step (iii) is skipped, resulting in the forth diagram (t = 3, n = 4). The effect of the step (v) can be seen in the diagrams for iteration t = 9. At n = 16, the far right interval is divided, but no function evaluation occurs. Instead, UCB values given by GP are placed in the new intervals indicated by the red asterisks. One of the temporary dummy values is resolved at n = 17 when the interval is queried for division, as shown by the green asterisk. The effect of step (iii) for the rejection case is illustrated in the last diagram for iteration t = 10. At n = 18, t is increased to 10 from 9, meaning that the largest intervals are first considered for division. However, the three largest intervals are all rejected in step (iii), resulting in the division of a very small interval near the global optimum at n = 18."
    }, {
      "heading" : "3.3 Technical Detail of Algorithm",
      "text" : "We define h to be the depth of the hierarchical partitioning tree, and ch,i to be the center point of the ith hyperrectangle at depth h. Ngp is the number of the GP evaluations. Define depth(T ) to be the largest integer h such that the set Th is not empty. To compute UCB U , we use ςM =√\n2 log(π2M2/12η) whereM is the number of the calls made so far for U (i.e., each time we use U , we increment M by one). This particular form of ςM is to maintain the property of f(x) ≤ U(x|D) during an execution of our algorithm with probability at least 1 − η. Here, η is the parameter of IMGPO. Ξmax is another parameter, but it is only used to limit the possibly long computation of step (iii) (in the worst case, step (iii) computes UCBs 3Ξmax times although it would rarely happen).\nThe pseudocode is shown in Algorithm 1. Lines 8 to 23 correspond to steps (i)-(iii). These lines compute the index i∗h of the candidate of the rectangle that may contain a global optimizer for each depth h. For each depth h, non-null index i∗h at Line 24 indicates the remaining candidate of a rectangle that we want to divide. Lines 24 to 33 correspond to steps (iv)-(v) where the remaining candidates of the rectangles for all h are divided. To provide a simple executable division scheme (line 29), we assume Ω to be a hyperrectangle (see the last paragraph of section 4 for a general case).\nLines 8 to 17 correspond to steps (i)-(ii). Specifically, line 10 implements step (i) where a single candidate is selected for each depth, and lines 11 to 12 conduct step (ii) where some candidates are screened out. Lines 13 to 17 resolve the the temporary dummy values computed by GP. Lines 18\nAlgorithm 1 Infinite-Metric GP Optimization (IMGPO)\nInput: an objective function f , the search domain Ω, the GP kernel κ, Ξmax ∈ N+ and η ∈ (0, 1) 1: Initialize the set Th = {∅} ∀h ≥ 0 2: Set c0,0 to be the center point of Ω and T0 ← {c0,0} 3: Evaluate f at c0,0: g(c0,0)← f(c0,0) 4: f+ ← g(c0,0),D ← {(c0,0, g(c0,0))} 5: n,N ← 1, Ngp ← 0,Ξ← 1 6: for t = 1, 2, 3, ... do 7: υmax ← −∞ 8: for h = 0 to depth(T ) do # for-loop for steps (i)-(ii) 9: while true do 10: i∗h ← arg maxi:ch,i∈Th g(ch,i) 11: if g(ch,i∗h) < υmax then 12: i∗h ← ∅, break 13: else if g(ch,i∗h) is not labeled as GP-based then 14: υmax ← g(ch,i∗h), break 15: else 16: g(ch,i∗h)← f(ch,i∗h) and remove the GP-based label from g(ch,i∗h) 17: N ← N + 1, Ngp ← Ngp − 1 18: D ← {D, (ch,i∗h , g(ch,i∗h))} 19: for h = 0 to depth(T ) do # for-loop for step (iii) 20: if i∗h 6= ∅ then 21: ξ ← the smallest positive integer s.t. i∗h+ξ 6= ∅ and ξ ≤ min(Ξ,Ξmax) if exists, and 0 otherwise 22: z(h, i∗h) = maxk:ch+ξ,k∈T ′h+ξ(ch,i∗h )\nU(ch+ξ,k|D) 23: if ξ 6= 0 and z(h, i∗h) < g(ch+ξ,i∗h+ξ ) then 24: i∗h ← ∅, break 25: υmax ← −∞ 26: for h = 0 to depth(T ) do # for-loop for steps (iv)-(v) 27: if i∗h 6= ∅ and g(ch,i∗h) ≥ υmax then 28: n← n+ 1. 29: Divide the hyperrectangle centered at ch,i∗\nh along with the longest coordinate into three new hy-\nperrectangles with the following centers: S = {ch+1,i(left), ch+1,i(center), ch+1,i(right)}\n30: Th+1 ← {Th+1,S} 31: Th ← Th \\ ch,i∗h , g(ch+1,i(center))← g(ch,i∗h) 32: for inew = {i(left), i(right)} do 33: if U(ch+1,inew |D) ≥ f\n+ then 34: g(ch+1,inew )← f(ch+1,inew ) 35: D ← {D, (ch+1,inew , g(ch+1,inew ))} N ← N + 1, f+ ← max(f+, g(ch+1,inew )), υmax = max(υmax, g(ch+1,inew )) 36: else 37: g(ch+1,inew )← U(ch+1,inew |D) and label g(ch+1,inew ) as GP-based. Ngp ← Ngp + 1 38: Update Ξ: if f+ was updated, Ξ← Ξ + 22 , and otherwise, Ξ← max(Ξ− 2−1, 1) 39: Update GP hyperparameters by an empirical Bayesian method\nto 23 correspond to step (iii) where the candidates are further screened out. At line 21, T ′h+ξ(ch,i∗h) indicates the set of all center points of a fully expanded tree until depth h + ξ within the region covered by the hyperrectangle centered at ch,i∗h . In other words, T ′ h+ξ(ch,i∗h) contains the nodes of the fully expanded tree rooted at ch,i∗h with depth ξ and can be computed by dividing the current rectangle at ch,i∗h and recursively divide all the resulting new rectangles until depth ξ (i.e., depth ξ from ch,i∗h , which is depth h+ ξ in the whole tree)."
    }, {
      "heading" : "3.4 Relationship to Previous Algorithms",
      "text" : "The most closely related algorithm is the BaMSOO algorithm [2], which combines SOO with GPUCB. However, it only achieves a polynomial regret bound while IMGPO achieves a exponential\nregret bound. IMGPO can achieve exponential regret because it utilizes the information encoded in the GP prior/posterior to reduce the degree of the unknownness of the semi-metric `.\nThe idea of considering a set of infinitely many bounds was first proposed by Jones et al. [19]. Their DIRECT algorithm has been successfully applied to real-world problems [4, 5], but it only maintains the consistency property (i.e., convergence in the limit) from a theoretical viewpoint. DIRECT takes an input parameter to balance the global and local search efforts. This idea was generalized to the case of an unknown semi-metric and strengthened with a theoretical support (finite regret bound) by Munos [18] in the SOO algorithm. By limiting the depth of the search tree with a parameter hmax, the SOO algorithm achieves a finite regret bound that depends on the near-optimality dimension."
    }, {
      "heading" : "4 Analysis",
      "text" : "In this section, we prove an exponential convergence rate of IMGPO and theoretically discuss the reason why the novel idea underling IMGPO is beneficial. The proofs are provided in the supplementary material. To examine the effect of considering infinitely many possible candidates of the bounds, we introduce the following term. Definition 1. (Infinite-metric exploration loss). The infinite-metric exploration loss ρt is the number of intervals to be divided during iteration t. The infinite-metric exploration loss ρτ can be computed as ρt = ∑depth(T ) h=1 1(i ∗ h 6= ∅) at line 25. It is the cost (in terms of the number of function evaluations) incurred by not committing to any particular upper bound. If we were to rely on a specific bound, ρτ would be minimized to 1. For example, the DOO algorithm [18] has ρt = 1 ∀t ≥ 1. Even if we know a particular upper bound, relying on this knowledge and thus minimizing ρτ is not a good option unless the known bound is tight enough compared to the unknown bound leveraged in our algorithm. This will be clarified in our analysis. Let ρ̄t be the maximum of the averages of ρ1:t′ for t′ = 1, 2, ..., t (i.e., ρ̄t ≡ max({ 1t′ ∑t′ τ=1 ρτ ; t\n′ = 1, 2, . . . , t}). Assumption 2. For some pair of a global optimizer x∗ and an unknown semi-metric ` that satisfies Assumption 1, both of the following, (i) shape on ` and (ii) lower bound constant, conditions hold:\n(i) there exist L > 0, α > 0 and p ≥ 1 in R such that for all x, x′ ∈ Ω, `(x′, x) ≤ L||x′−x||αp .\n(ii) there exists θ ∈ (0, 1) such that for all x ∈ Ω, f(x∗) ≥ f(x) + θ` (x, x∗).\nIn Theorem 1, we show that the exponential convergence rate O ( λN+Ngp ) with λ < 1 is achieved. We define Ξn ≤ Ξmax to be the largest ξ used so far with n total node expansions. For simplicity, we assume that Ω is a square, which we satisfied in our experiments by scaling original Ω.\nTheorem 1. Assume Assumptions 1 and 2. Let β = supx,x′∈Ω 12‖x−x ′‖∞. Let λ = 3− α 2CDρ̄t < 1. Then, with probability at least 1− η, the regret of IMGPO is bounded as\nrN ≤ L(3βD1/p)α exp ( −α [ N +Ngp 2CDρ̄t − Ξn − 2 ] ln 3 ) = O ( λN+Ngp ) .\nImportantly, our bound holds for the best values of the unknown L,α and p even though these values are not given. The closest result in previous work is that of BaMSOO [2], which obtained Õ(n− 2α D(4−α) ) with probability 1 − η for α = {1, 2}. As can be seen, we have improved the regret bound. Additionally, in our analysis, we can see how L, p, and α affect the bound, allowing us to view the inherent difficulty of an objective function in a theoretical perspective. Here, C is a constant in N and is used in previous work [18, 2]. For example, if we conduct 2D or 3D − 1 function evaluations per node-expansion and if p =∞, we have that C = 1. We note that λ can get close to one as input dimension D increases, which suggests that there is a remaining challenge in scalability for higher dimensionality. One strategy for addressing this problem would be to leverage additional assumptions such as those in [14, 20]. Remark 1. (The effect of the tightness of UCB by GP) If UCB computed by GP is “useful” such thatN/ρ̄t = Ω(N), then our regret bound becomesO ( exp ( −N+Ngp2CD α ln 3 )) . If the bound due to\nUCB by GP is too loose (and thus useless), ρ̄t can increase up to O(N/t) (due to ρ̄t ≤ ∑t i=1 i/t ≤\nO(N/t)), resulting in the regret bound of O ( exp ( − t(1+Ngp/N)2CD α ln 3 )) , which can be bounded\nby O ( exp ( −N+Ngp2CD max( 1√ N , tN )α ln 3 )) 1. This is still better than the known results.\nRemark 2. (The effect of GP) Without the use of GP, our regret bound would be as follows: rN ≤ L(3βD1/p)α exp(−α[ N2CD 1 ρ̃t −2] ln 3), where ρ̄t ≤ ρ̃t is the infinite-metric exploration loss without GP. Therefore, the use of GP reduces the regret bound by increasingNgp and decreasing ρ̄t, but may potentially increase the bound by increasing Ξn ≤ Ξ. Remark 3. (The effect of infinite-metric optimization) To understand the effect of considering all the possible upper bounds, we consider the case without GP. If we consider all the possible bounds, we have the regret bound L(3βD1/p)α exp(−α[ N\n2CD 1 ρ̃t − 2] ln 3) for the best unknown L, α and p.\nFor standard optimization with a estimated bound, we have L′(3βD1/p ′ )α ′ exp(−α′[ N\n2C′D − 2] ln 3) for an estimated L′, α′, and p′. By algebraic manipulation, considering all the possible bounds has\na better regret when ρ̃−1t ≥ 2CDN ln 3α (( N 2C′D − 2) ln 3 α′ + 2 ln 3α− ln L\n′(3βD1/p ′ )α ′ L(3βD1/p)α ). For an intuitive\ninsight, we can simplify the above by assuming α′ = α and C ′ = C as ρ̃−1t ≥ 1− Cc2DN ln L′Dα/p\n′\nLDα/p .\nBecause L and p are the ones that achieve the lowest bound, the logarithm on the right-hand side is always non-negative. Hence, ρ̃t = 1 always satisfies the condition. When L′ and p′ are not tight enough, the logarithmic term increases in magnitude, allowing ρ̃t to increase. For example, if the second term on the right-hand side has a magnitude of greater than 0.5, then ρ̃t = 2 satisfies the inequality. Therefore, even if we know the upper bound of the function, we can see that it may be better not to rely on this, but rather take the infinite many possibilities into account.\nOne may improve the algorithm with different division procedures than one presented in Algorithm 1 as discussed in the supplementary material.\n1This can be done by limiting the depth of search tree as depth(T ) = O( √ N). Our proof works with this additional mechanism, but results in the regret bound with N being replaced by √ N . Thus, if we assume to have at least “not useless” UCBs such that N/ρ̄t = Ω( √ N), this additional mechanism can be disadvantageous. Accordingly, we do not adopt it in our experiments."
    }, {
      "heading" : "5 Experiments",
      "text" : "In this section, we compare the IMGPO algorithm with the SOO, BaMSOO, GP-PI and GP-EI algorithms [18, 2, 3]. In previous work, BaMSOO and GP-UCB were tested with a pair of a handpicked good kernel and hyperparameters for each function [2]. In our experiments, we assume that the knowledge of good kernel and hyperparameters is unavailable, which is usually the case in practice. Thus, for IMGPO, BaMSOO, GP-PI and GP-EI, we simply used one of the most popular kernels, the isotropic Matern kernel with ν = 5/2. This is given by κ(x, x′) = g( √ 5||x− x′||2/l), where g(z) = σ2(1 + z + z2/3) exp(−z). Then, we blindly initialized the hyperparameters to σ = 1 and l = 0.25 for all the experiments; these values were updated with an empirical Bayesian method after each iteration. To compute the UCB by GP, we used η = 0.05 for IMGPO and BaMSOO. For IMGPO, Ξmax was fixed to be 22 (the effect of selecting different values is discussed later). For BaMSOO and SOO, the parameter hmax was set to √ n, according to Corollary 4.3 in [18]. For GP-PI and GP-EI, we used the SOO algorithm and a local optimization method using gradients to solve the auxiliary optimization. For SOO, BaMSOO and IMGPO, we used the corresponding deterministic division procedure (given Ω, the initial point is fixed and no randomness exists). For GP-PI and GP-EI, we randomly initialized the first evaluation point and report the mean and one standard deviation for 50 runs.\nThe experimental results for eight different objective functions are shown in Figure 2. The vertical axis is log10(f(x∗) − f(x+)), where f(x∗) is the global optima and f(x+) is the best value found by the algorithm. Hence, the lower the plotted value on the vertical axis, the better the algorithm’s performance. The last five functions are standard benchmarks for global optimization [21]. The first two were used in [18] to test SOO, and can be written as fsin1(x) = (sin(13x) sin +1)/2 for Sin1 and fsin2(x) = fsin1(x1)fsin1(x2) for Sin2. The form of the third function is given in Equation (16) and Figure 2 in [22]. The last function is Sin2 embedded in 1000 dimension in the same manner described in Section 4.1 in [14], which is used here to illustrate a possibility of using IMGPO as a main subroutine to scale up to higher dimensions with additional assumptions. For this function, we used REMBO [14] with IMGPO and BaMSOO as its Bayesian optimization subroutine. All of these functions are multimodal, except for Rosenbrock2, with dimensionality from 1 to 1000.\nAs we can see from Figure 2, IMGPO outperformed the other algorithms in general. SOO produced the competitive results for Rosenbrock2 because our GP prior was misleading (i.e., it did not model the objective function well and thus the property f(x) ≤ U(x|D) did not hold many times). As can be seen in Table 1, IMGPO is much faster than traditional GP optimization methods although it is slower than SOO. For Sin 1, Sin2, Branin and Hartmann3, increasing Ξmax does not affect IMGPO because Ξn did not reach Ξmax = 22 (Figure 2). For the rest of the test functions, we would be able to improve the performance of IMGPO by increasing Ξmax at the cost of extra CPU time."
    }, {
      "heading" : "6 Conclusion",
      "text" : "We have presented the first GP-based optimization method with an exponential convergence rate O ( λN+Ngp ) (λ < 1) without the need of auxiliary optimization and the δ-cover sampling. Perhaps more importantly in the viewpoint of a broader global optimization community, we have provided a practically oriented analysis framework, enabling us to see why not relying on a particular bound is advantageous, and how a non-tight bound can still be useful (in Remarks 1, 2 and 3). Following the advent of the DIRECT algorithm, the literature diverged along two paths, one with a particular bound and one without. GP-UCB can be categorized into the former. Our approach illustrates the benefits of combining these two paths.\nAs stated in Section 3.1, our solution idea was to use a bound-based method but rely less on the estimated bound by considering all the possible bounds. It would be interesting to see if a similar principle can be applicable to other types of bound-based methods such as planning algorithms (e.g., A* search and the UCT or FSSS algorithm [23]) and learning algorithms (e.g., PAC-MDP algorithms [24])."
    }, {
      "heading" : "Acknowledgments",
      "text" : "The authors would like to thank Dr. Remi Munos for his thoughtful comments and suggestions. We gratefully acknowledge support from NSF grant 1420927, from ONR grant N00014-14-1-0486, and from ARO grant W911NF1410433. Kenji Kawaguchi was supported in part by the Funai Overseas Scholarship. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of our sponsors.\nBayesian Optimization with Exponential Convergence: Supplementary Material\nIn this supplementary material, we provide the proofs of the theoretical results. Along the way, we also prove regret bounds for a general class of algorithms, the result of which may be used to design a new algorithm.\nWe first provide a known property of the upper confidence bound of GP.\nLemma 1. (Bound Estimated by GP) According to the belief encoded in the GP prior/posterior2, for any x, f(x) ≤ U(x|D) holds during the execution of Algorithm 1 with probability at least 1− η.\nProof. It follows the proof of lemma 5.1 of [15]. From the property of the standard gaussian distribution, Pr(f(x) > U(x|D)) < 12e\n−ς2M/2. Taking union bound on the entire execution of Algorithm 1, Pr(f(x) > U(x|D) ∀M ≥ 1) < 12 ∑∞ M=1 e −ς2M/2. Substituting ςM = √\n2 log(π2M2/12η), we obtain the statement.\nOur algorithm has a concrete division procedure in line 27 of Algorithm 1. However, one may improve the algorithm with different division procedures. Accordingly, we first derive abstract version of regret bound for the IMGPO (Algorithm 1) under a family of division procedures that satisfy Assumptions 3 and 4. After that, we provide a proof for the main results in the paper."
    }, {
      "heading" : "A With Family of Division Procedure",
      "text" : "In this section, we modify the result obtained by [18]. Let xh,i to be any point in the region covered by the ith hyperinterval at depth h, and x∗h,i be the global optimizer that may exist in the i\nth hyperinterval at depth h. The previous work provided the regret bound of the SOO algorithm with a family of division procedure that satisfies the following two assumptions.\nAssumption 3. (Decreasing diameter) There exists a diameter function δ(h) > 0 such that, for any hyperinterval ωh,i ⊂ Ω and its center ch,i ∈ ωh,i and any xh,i ∈ ωh,i, we have δ(h) ≥ supxh,i`(xh,i, ch,i) and δ(h− 1) ≥ δ(h) for all h ≥1. Assumption 4. (Well-shaped cell) There exists ν > 0 such that any hyperinterval ωh,i contains at least an `-ball of radius νδ(h) centered in ωh,i.\nThus, in this section, hyperinterval is not restricted to hyperrectangle. We now revisit the definitions of several terms and variables used in [18]. Let the -optimal space X be defined as X := {x ∈ Ω : f(x) + ≥ f(x∗)}. That is, the -optimal space is the set of input vectors whose function value is at least -close to the global optima. To bound the number of hyperintervals relevant to this -optimal space, we define a near-optimality dimension as follows.\nDefinition 3. (Near-optimality dimension) The near-optimality dimension is the smallest d > 0 such that, there exists C > 0, for all > 0, the maximum number of disjoint `-balls of radius ν with center in the -optimal space X is less than C −d.\nFinally, we define the set of δ-optimal hyperintervals Iδ(h) as Iδ(h) := {c ∈ Ω : f(c) + δ(h) ≥ f(x∗), c is the center point of the interval, ωh,i, for some (h, i)}. The δ-optimal hyperinterval Iδ(h) is used to relate the hyperintervals to the -optimal space. Indeed, the δ-optimal hyperinterval Iδ(h) is almost identical to the δ(h)-optimal space Xδ(h), except that Iδ(h) is focused on the center points\n2Thus, the probability in this analysis should be seen as that of the subjective view. If we assume that f is indeed a sample from the GP, we have the same result with the objective view of probability.\nwhereas Xδ(h) considers the whole input vector space. In the following, we use |Iδ(h)| to denote the number of Iδ(h) and derive its upper bound.\nLemma 2. (Lemma 3.1 in [18]) Let d be the near-optimality dimension and C denote the corresponding constant in Definition 1. Then, the number of δ-optimal hyperintervals is bounded by |Iδ(h)|≤ Cδ(h)−d.\nWe are now ready to present the main result in this section. In the following, we use the term optimal hyperinterval to indicate a hyperinterval that contains a global optimizer x∗. We say a hyperinterval is dominated by other intervals when it is rejected or not selected in step (i)-(iii). In Lemma 3, we bound the maximum size of the optimal hyperinterval. From Assumption 1, this can be translated to the regret bound, as we shall see in Theorem 2.\nLemma 3. Let Ξn ≤ min(Ξ,Ξmax) be the largest ξ used so far with n total node expansions. Let h∗n be the depth of the deepest expanded node that contains a global optimizer x\n∗ after n total node expansions (i.e., h∗n ≤ n determines the size of the optimal hyperinterval). Then, with probability at least 1− η, h∗n is bounded below by some h′ that satisfies\nn ≥ ∑h′+Ξ l=0 |Il|∑ τ =1 ρτ .\nProof. Let Th denote the time at which the optimal hyperinterval is further divided. We prove the statement by showing that the time difference Th+1 − Th is bounded by the number of δ-optimal hyperintervals. To do so, we first note that there are three types of hyperinterval that can dominate an optimal hyperinterval ch+1,∗ during the time [Th, Th+1 − 1], all of which belong to δ-optimal hyperintervals Iδ . The first type has the same size (i.e., same depth h), ch+1,i. In this case,\nf(ch+1,i) ≥ f(ch+1,∗) ≥ f(x∗h+1,∗)− δ(h+ 1),\nwhere the first inequality is due to line 10 (step (i)) and the second follows Assumptions 1 and 2. Thus, it must be ch+1,i ∈ Ih+1. The second case is where the optimal hyperinterval may be dominated by a hyperinterval of larger size (depth l < h+ 1), cl,i. In this case, similarly,\nf(cl,i) ≥ f(ch+1,∗) ≥ f(x∗h+1,∗)− δ(l),\nwhere the first inequality is due to lines 11 to 12 (step (ii)) and thus cl,i ∈ Il. In the final scenario, the optimal hyperinterval is dominated by a hyperinterval of smaller size (depth h+1+ξ), ch+1+ξ,i. In this case,\nf(ch+1+ξ,i) ≥ z(h+ 1, ∗) ≥ f(x∗h+1,∗)− δ(h+ 1 + ξ)\nwith probability at least 1− η where z(·, ·) is defined in line 21 of Algorithm 1. The first inequality is due to lines 19 to 23 (step (iii)) and the second inequality follows Lemma 1 and Assumptions 1 and 3. Hence, we can see that ch+1+ξ,i ∈ Ih+1+ξ. For all of the above arguments, the temporarily assigned U under GP has no effect. This is because the algorithm still covers the above three types of δ-optimal hyperintervals Iδ , as U ≥ f with probability at least 1− η (Lemma 1). However, these are only expanded based on f because of the temporary nature of U . Putting these results together,\nTh+1 − Th ≤\n∑h+1+Ξn l=1 |Iδ(l)|∑\nτ=1\nρτ .\nSince if one of the Iδ is divided during [Th, Th+1 − 1], it cannot be divided again during another time period,\nh∗n∑ h=0 Th+1 − Th ≤ ∑h∗n+1+Ξn l=1 |Il|∑ τ=1 ρτ ,\nwhere on the right-hand side, we could combine the summation ∑h∗n h=0 and ∑∑h+1+Ξn l=1 |Iδ(l)|\nτ=1 into the one, because each h in the summation refers to the same δ-optimal interval Iδ(l) with l ≤ h∗n+1+Ξn,\nand should not be double-counted. As ∑h∗n h=0 Th+1 − Th = Th∗n+1 − T0, T0 = 1 and |Iδ(0)|= 1,\nTh∗n+1 ≤ 1 + ∑h∗n+1+Ξn l=1 |Il|∑ τ=1 ρτ ≤ ∑h∗n+1+Ξn l=0 |Il|∑ τ=1 ρτ .\nAs Th∗n+1 > n by definition, for any h ′ such that\n∑∑h′+Ξn l=0 |Il| τ=1 ρτ ≤ n < ∑∑h∗n+1+Ξn l=0 |Il| τ=1 ρτ , we\nhave h∗n > h ′.\nWith Lemmas 2 and 3, we are ready to present a finite regret bound with the family of division procedures.\nTheorem 2. Assume Assumptions 1, 3, and 4. Let h(n) be the smallest integer h such that\nn ≤ C\n∑h+Ξn l=0 δ(l)\n−d∑ τ=1 ρτ .\nThen, with probability at least 1 − η, the regret of the IMGPO with any general division procedure is bounded as\nrn ≤ δ(h(n)− 1).\nProof. Let c(n) and ch∗n,∗ be the center point expanded at the nth expansion and the optimal hyperinterval containing a global optimizer x∗, respectively. Then, from Assumptions 1, 3, and 4, f(c(n)) ≥ f(ch∗n,∗) ≥ f\n∗ − δ(h∗n), where f∗ is the global optima. Hence, the regret bound is rh ≤ δ(h∗n). To find a lower bound for the quantity h∗n, we first relate h(n) to Lemma 3 by\nn >\nC ∑h(n)+Ξn−1 l=0 δ(l)\n−d∑ τ=1 ρτ ≥ ∑h(n)+Ξn−1 l=0 |Il|∑ τ=1 ρτ ,\nwhere the first inequality comes from the definition of h(n), and the second follows from Lemma 2. Then, from Lemma 3, we have h∗n ≥ h(n)− 1. Therefore, rn ≤ δ(h∗n) ≤ δ(h(n)− 1).\nAssumption 5. (Decreasing diameter revisit) The decreasing diameter defined in Assumption 3 can be written as δ(h) = c1γh/D for some c1 > 0 and γ < 1 with a division procedure that requires c2 function evaluations per node expansion.\nCorollary 1. Assume Assumptions 1, 3, 4, and 5. Then, if d = 0, with probability at least 1− η, rN ≤ O ( exp ( −N +Ngp c2CDρ̄t )) .\nIf d > 0, with probability at least 1− η,\nrN ≤ O\n(( 1\nN +Ngp\n)1/d( − c2Cρ̄t\n1− γd/D\n)1/d γ− 1 D ) .\nProof. For the case d = 0, we have n ≤ ∑C∑h(n)+Ξnl=0 δ(l)−d τ=1 ρτ ≤ ∑C(h(n)+Ξn+1) τ=1 ρ̄t, where the first inequality follows from the definition of h(n), and the second comes from the definition of ρ̄t and the assumption d = 0. The second inequality holds for ρ̄t that only considers ρτ with τ ≤ t. This is computable, because τ ≤ t by construction. Indeed, the condition of Lemma 3 implies t ≥ ∑h′+Ξn l=0 |Il|. Therefore, the two inequalities hold, and we can deduce that h(n) ≥ n Cρ̄t −Ξn−1 by algebraic manipulation. By Assumption 5, n = (N +Ngp)/c2. With this, substituting the lower bound of h(n) into the statement of Theorem 2 with Assumption 5,\nrN ≤ c1 exp ( − [ N +Ngp c2D 1 Cρ̄t − Ξn − 2 ] ln 1 γ ) .\nSimilarly, for the case d > 0,\nn ≤ C\n∑h(n)+Ξn l=0 δ(l)\n−d∑ τ=1 ρτ ≤ c−dC γ −(h(n)+Ξn+1)d/D−1 γ−d/D−1∑ τ=1 ρ̄t,\nand hence cγ h(n)+Ξn D ≤ ( n(1−γd/D)\nCρ̄t\n)−1/d by algebraic manipulation. Substituting this into the\nresult of Theorem 2, we arrive at the desired result."
    }, {
      "heading" : "B With a Concrete Division Procedure",
      "text" : "In this section, we prove the main result in the paper. In Theorem 1, we show that the exponential convergence rate bound O ( λN+Ngp ) with λ < 1 is achieved without Assumptions 3, 4 and 5 and without the assumption that d = 0.\nTheorem 1. Assume Assumptions 1 and 2. Let β = supx,x′∈Ω 12‖x−x ′‖∞. Let λ = 3− α 2Cρ̄tD < 1. Then, without Assumptions 3, 4 and 5 and without the assumption on d, with probability at least 1− η, the regret of IMGPO with the division procedure in Algorithm 1 is bounded as\nrN ≤ L(3βD1/p)α exp ( −α [ N +Ngp 2Cρ̄tD − Ξn − 2 ] ln 3 ) = O ( λN+Ngp ) .\nProof. To prove the statement, we show that Assumptions 3, 4, and 5 can all be satisfied while maintaining d = 0. From Assumption 2 (i), and based on the division procedure that the algorithm uses,\nsup x∈ωh,i `(x, ch,i) ≤ sup x∈ωh,i\nL||x− ch,i||αp≤ L ( 3−bh/DcβD1/p )α .\nThis upper bound corresponds to the diagonal length of each hyperrectangle with respect to pnorm, where 3−bh/Dcβ corresponds to the length of the longest side. We fix the form of δ as δ(h) = L3αDα/p3−hα/Dβα ≥ L(3−bh/DcβD1/p)α, which satisfies Assumption 3.\nThis form of δ(h) also satisfies Assumption 5 with γ = 3−α and c1 = L3αDα/pβα.\nEvery hyperrectangle contains at least one `-ball with a radius corresponding to the length of the shortest side of the hyperrectangle. Thus, we have at least one `-ball of radius νδ(h) = L3−αdh/De ≥ L3−α3−αh/D for every hyperrectangle with ν ≥ 3−2αD−α/p. This satisfies Assumption 4.\nFinally, we show that d = 0. The set of δ-optimal hyperintervals Iδ(h) is contained by the δ(h)optimal space Xδ(h) as\nIδ(h) = {c ∈ Ω : f(x∗)− f(c) ≤ δ(h), c is the center point of the interval, ωh,i, for some (h, i)} ⊆ {x ∈ Ω : f(x∗)− f(x) ≤ δ(h)} = Xδ(h)\nLet θ be a value that satisfies Assumption 2 (ii) (which is nonzero). Consider an `-ball of radius δ(h) θ at x\n∗, which is a set {x ∈ Ω | θ`(x, x∗) ≤ δ(h)}. Since θ`(x, x∗) ≤ f(x∗) − f(x) by Assumption 2 (ii), the δ(h)-optimal space Xδ(h) is covered by an `-ball of radius δ(h) θ . Therefore, Iδ(h) ⊆ Xδ(h) ⊆ (an `-ball of radius δ(h)\nθ at x∗). By Assumption 2 (i), the volume V of an `-ball of\nradius νδ(h) is proportional to (νδ(h))D as V pD(νδ(h)) = (2νδ(h)Γ(1+1/p)) D/Γ(1+D/p). Thus, the number of disjoint `-balls of radius νδ(h) that fit in Xδ(h) is at most d( δ(h)θνδ(h) ) De = d(θν)−De. Therefore, the number of `-balls does not depend on δ(h) in this case, which means d = 0.\nNow that we have satisfied Assumptions 3, 4, and 5 with d = 0, γ = 3−α, and c1 = L3αDα/pβα, we follow the proof of Corollary 1 and deduce the desired statement."
    } ],
    "references" : [ {
      "title" : "Exponential regret bounds for Gaussian process bandits with deterministic observations",
      "author" : [ "N. De Freitas", "A.J. Smola", "M. Zoghi" ],
      "venue" : "In Proceedings of the 29th International Conference on Machine Learning (ICML),",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2012
    }, {
      "title" : "Bayesian Multi-Scale Optimistic Optimization",
      "author" : [ "Z. Wang", "B. Shakibi", "L. Jin", "N. de Freitas" ],
      "venue" : "In Proceedings of the 17th International Conference on Artificial Intelligence and Statistics (AISTAT),",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2014
    }, {
      "title" : "Practical Bayesian optimization of machine learning algorithms",
      "author" : [ "J. Snoek", "H. Larochelle", "R.P. Adams" ],
      "venue" : "In Proceedings of Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2012
    }, {
      "title" : "Algorithms for noisy problems in gas transmission pipeline optimization",
      "author" : [ "R.G. Carter", "J.M. Gablonsky", "A. Patrick", "C.T. Kelley", "O.J. Eslinger" ],
      "venue" : "Optimization and engineering,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2001
    }, {
      "title" : "Globally optimised parameters for a model of mitotic control in frog egg extracts",
      "author" : [ "J.W. Zwolak", "J.J. Tyson", "L.T. Watson" ],
      "venue" : "IEEE Proceedings-Systems Biology,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2005
    }, {
      "title" : "Global optima without convexity",
      "author" : [ "L.C.W. Dixon" ],
      "venue" : "Numerical Optimisation Centre, Hatfield Polytechnic,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1977
    }, {
      "title" : "A sequential method seeking the global maximum of a function",
      "author" : [ "B.O. Shubert" ],
      "venue" : "SIAM Journal on Numerical Analysis,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1972
    }, {
      "title" : "Outer approximation algorithm for nondifferentiable optimization problems",
      "author" : [ "D.Q. Mayne", "E. Polak" ],
      "venue" : "Journal of Optimization Theory and Applications,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1984
    }, {
      "title" : "An algorithm for finding the global maximum of a multimodal, multivariate function",
      "author" : [ "R.H. Mladineo" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1986
    }, {
      "title" : "Convergence of an algorithm for finding a global extremum",
      "author" : [ "R.G. Strongin" ],
      "venue" : "Engineering Cybernetics,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1973
    }, {
      "title" : "Local tuning and partition strategies for diagonal GO methods",
      "author" : [ "D.E. Kvasov", "C. Pizzuti", "Y.D. Sergeyev" ],
      "venue" : "Numerische Mathematik,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2003
    }, {
      "title" : "Lipschitz bandits without the Lipschitz constant",
      "author" : [ "S. Bubeck", "G. Stoltz", "J.Y. Yu" ],
      "venue" : "In Algorithmic Learning Theory,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2011
    }, {
      "title" : "Bayesian Optimization with Inequality Constraints",
      "author" : [ "J. Gardner", "M. Kusner", "K. Weinberger", "J. Cunningham" ],
      "venue" : "In Proceedings of The 31st International Conference on Machine Learning (ICML),",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2014
    }, {
      "title" : "Bayesian optimization in high dimensions via random embeddings",
      "author" : [ "Z. Wang", "M. Zoghi", "F. Hutter", "D. Matheson", "N. De Freitas" ],
      "venue" : "In Proceedings of the Twenty-Third international joint conference on Artificial Intelligence,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2013
    }, {
      "title" : "Gaussian Process Optimization in the Bandit Setting: No Regret and Experimental Design",
      "author" : [ "N. Srinivas", "A. Krause", "M. Seeger", "S.M. Kakade" ],
      "venue" : "In Proceedings of the 27th International Conference on Machine Learning (ICML),",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2010
    }, {
      "title" : "Machine learning: a probabilistic perspective",
      "author" : [ "K.P. Murphy" ],
      "venue" : "MIT press,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2012
    }, {
      "title" : "Gaussian Processes for Machine Learning",
      "author" : [ "C.E. Rasmussen", "C. Williams" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2006
    }, {
      "title" : "Optimistic optimization of deterministic functions without the knowledge of its smoothness",
      "author" : [ "R. Munos" ],
      "venue" : "In Proceedings of Advances in neural information processing systems (NIPS),",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2011
    }, {
      "title" : "Lipschitzian optimization without the Lipschitz constant",
      "author" : [ "D.R. Jones", "C.D. Perttunen", "B.E. Stuckman" ],
      "venue" : "Journal of Optimization Theory and Applications,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1993
    }, {
      "title" : "High dimensional Bayesian optimisation and bandits via additive models",
      "author" : [ "K. Kandasamy", "J. Schneider", "B. Poczos" ],
      "venue" : "arXiv preprint arXiv:1503.01673,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2015
    }, {
      "title" : "Virtual library of simulation experiments: Test functions and datasets",
      "author" : [ "S. Surjanovic", "D. Bingham" ],
      "venue" : "Retrieved November",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2014
    }, {
      "title" : "Global and local optimization using radial basis function response surface models",
      "author" : [ "D.B. McDonald", "W.J. Grantham", "W.L. Tabor", "M.J. Murphy" ],
      "venue" : "Applied Mathematical Modelling,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2007
    }, {
      "title" : "Integrating Sample-Based Planning and Model- Based Reinforcement Learning",
      "author" : [ "T.J. Walsh", "S. Goschin", "M.L. Littman" ],
      "venue" : "In Proceedings of the 24th AAAI conference on Artificial Intelligence (AAAI),",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2010
    }, {
      "title" : "Reinforcement learning in finite MDPs: PAC analysis",
      "author" : [ "A.L. Strehl", "L. Li", "M.L. Littman" ],
      "venue" : "The Journal of Machine Learning Research (JMLR),",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Also, the existing Bayesian optimization method with exponential convergence [1] requires access to the δ-cover sampling, which was considered to be impractical [1, 2].",
      "startOffset" : 77,
      "endOffset" : 80
    }, {
      "referenceID" : 0,
      "context" : "Also, the existing Bayesian optimization method with exponential convergence [1] requires access to the δ-cover sampling, which was considered to be impractical [1, 2].",
      "startOffset" : 161,
      "endOffset" : 167
    }, {
      "referenceID" : 1,
      "context" : "Also, the existing Bayesian optimization method with exponential convergence [1] requires access to the δ-cover sampling, which was considered to be impractical [1, 2].",
      "startOffset" : 161,
      "endOffset" : 167
    }, {
      "referenceID" : 2,
      "context" : "Such a problem arises in many realworld applications, such as parameter tuning in machine learning [3], engineering design problems [4], and model parameter fitting in biology [5].",
      "startOffset" : 99,
      "endOffset" : 102
    }, {
      "referenceID" : 3,
      "context" : "Such a problem arises in many realworld applications, such as parameter tuning in machine learning [3], engineering design problems [4], and model parameter fitting in biology [5].",
      "startOffset" : 132,
      "endOffset" : 135
    }, {
      "referenceID" : 4,
      "context" : "Such a problem arises in many realworld applications, such as parameter tuning in machine learning [3], engineering design problems [4], and model parameter fitting in biology [5].",
      "startOffset" : 176,
      "endOffset" : 179
    }, {
      "referenceID" : 5,
      "context" : "The general global optimization problem is known to be intractable if we make no further assumptions [6].",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 6,
      "context" : "A well-known variant of this assumption is Lipschitz continuity with a known Lipschitz constant, and many algorithms have been proposed in this setting [7, 8, 9].",
      "startOffset" : 152,
      "endOffset" : 161
    }, {
      "referenceID" : 7,
      "context" : "A well-known variant of this assumption is Lipschitz continuity with a known Lipschitz constant, and many algorithms have been proposed in this setting [7, 8, 9].",
      "startOffset" : 152,
      "endOffset" : 161
    }, {
      "referenceID" : 8,
      "context" : "A well-known variant of this assumption is Lipschitz continuity with a known Lipschitz constant, and many algorithms have been proposed in this setting [7, 8, 9].",
      "startOffset" : 152,
      "endOffset" : 161
    }, {
      "referenceID" : 9,
      "context" : "Some researchers relaxed this somewhat strong assumption by proposing procedures to estimate a Lipschitz constant during the optimization process [10, 11, 12].",
      "startOffset" : 146,
      "endOffset" : 158
    }, {
      "referenceID" : 10,
      "context" : "Some researchers relaxed this somewhat strong assumption by proposing procedures to estimate a Lipschitz constant during the optimization process [10, 11, 12].",
      "startOffset" : 146,
      "endOffset" : 158
    }, {
      "referenceID" : 11,
      "context" : "Some researchers relaxed this somewhat strong assumption by proposing procedures to estimate a Lipschitz constant during the optimization process [10, 11, 12].",
      "startOffset" : 146,
      "endOffset" : 158
    }, {
      "referenceID" : 12,
      "context" : "In the machine learning community, Bayesian optimization— especially by means of a Gaussian process (GP)—is an active research area [13, 14, 15].",
      "startOffset" : 132,
      "endOffset" : 144
    }, {
      "referenceID" : 13,
      "context" : "In the machine learning community, Bayesian optimization— especially by means of a Gaussian process (GP)—is an active research area [13, 14, 15].",
      "startOffset" : 132,
      "endOffset" : 144
    }, {
      "referenceID" : 14,
      "context" : "In the machine learning community, Bayesian optimization— especially by means of a Gaussian process (GP)—is an active research area [13, 14, 15].",
      "startOffset" : 132,
      "endOffset" : 144
    }, {
      "referenceID" : 0,
      "context" : "[1] recently proposed a theoretical procedure that maintains an exponential convergence rate (exponential regret).",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "[2], one remaining problem is to derive a GP-based optimization method with an exponential convergence rate without the δ-cover sampling procedure, which is computationally too demanding in many cases.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 15,
      "context" : "The kernel parameters or hyperparameters can be estimated by empirical Bayesian methods [16]; see [17] for more information about GP.",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 16,
      "context" : "The kernel parameters or hyperparameters can be estimated by empirical Bayesian methods [16]; see [17] for more information about GP.",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 0,
      "context" : "[1] recently presented a theoretical procedure that maintains exponential convergence rate.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "However, their own paper and the follow-up research [1, 2] point out that this result relies on an impractical sampling procedure, the δ-cover sampling.",
      "startOffset" : 52,
      "endOffset" : 58
    }, {
      "referenceID" : 1,
      "context" : "However, their own paper and the follow-up research [1, 2] point out that this result relies on an impractical sampling procedure, the δ-cover sampling.",
      "startOffset" : 52,
      "endOffset" : 58
    }, {
      "referenceID" : 1,
      "context" : "[2] combined GP-UCB with a hierarchical partitioning optimization method, the SOO algorithm [18], providing a regret bound with polynomial dependence on the number of function evaluations.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 17,
      "context" : "[2] combined GP-UCB with a hierarchical partitioning optimization method, the SOO algorithm [18], providing a regret bound with polynomial dependence on the number of function evaluations.",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 1,
      "context" : "The most closely related algorithm is the BaMSOO algorithm [2], which combines SOO with GPUCB.",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 18,
      "context" : "[19].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 3,
      "context" : "Their DIRECT algorithm has been successfully applied to real-world problems [4, 5], but it only maintains the consistency property (i.",
      "startOffset" : 76,
      "endOffset" : 82
    }, {
      "referenceID" : 4,
      "context" : "Their DIRECT algorithm has been successfully applied to real-world problems [4, 5], but it only maintains the consistency property (i.",
      "startOffset" : 76,
      "endOffset" : 82
    }, {
      "referenceID" : 17,
      "context" : "This idea was generalized to the case of an unknown semi-metric and strengthened with a theoretical support (finite regret bound) by Munos [18] in the SOO algorithm.",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 17,
      "context" : "For example, the DOO algorithm [18] has ρt = 1 ∀t ≥ 1.",
      "startOffset" : 31,
      "endOffset" : 35
    }, {
      "referenceID" : 1,
      "context" : "The closest result in previous work is that of BaMSOO [2], which obtained Õ(n 2α D(4−α) ) with probability 1 − η for α = {1, 2}.",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 17,
      "context" : "Here, C is a constant in N and is used in previous work [18, 2].",
      "startOffset" : 56,
      "endOffset" : 63
    }, {
      "referenceID" : 1,
      "context" : "Here, C is a constant in N and is used in previous work [18, 2].",
      "startOffset" : 56,
      "endOffset" : 63
    }, {
      "referenceID" : 13,
      "context" : "One strategy for addressing this problem would be to leverage additional assumptions such as those in [14, 20].",
      "startOffset" : 102,
      "endOffset" : 110
    }, {
      "referenceID" : 19,
      "context" : "One strategy for addressing this problem would be to leverage additional assumptions such as those in [14, 20].",
      "startOffset" : 102,
      "endOffset" : 110
    }, {
      "referenceID" : 17,
      "context" : "In this section, we compare the IMGPO algorithm with the SOO, BaMSOO, GP-PI and GP-EI algorithms [18, 2, 3].",
      "startOffset" : 97,
      "endOffset" : 107
    }, {
      "referenceID" : 1,
      "context" : "In this section, we compare the IMGPO algorithm with the SOO, BaMSOO, GP-PI and GP-EI algorithms [18, 2, 3].",
      "startOffset" : 97,
      "endOffset" : 107
    }, {
      "referenceID" : 2,
      "context" : "In this section, we compare the IMGPO algorithm with the SOO, BaMSOO, GP-PI and GP-EI algorithms [18, 2, 3].",
      "startOffset" : 97,
      "endOffset" : 107
    }, {
      "referenceID" : 1,
      "context" : "In previous work, BaMSOO and GP-UCB were tested with a pair of a handpicked good kernel and hyperparameters for each function [2].",
      "startOffset" : 126,
      "endOffset" : 129
    }, {
      "referenceID" : 17,
      "context" : "3 in [18].",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 20,
      "context" : "The last five functions are standard benchmarks for global optimization [21].",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 17,
      "context" : "The first two were used in [18] to test SOO, and can be written as fsin1(x) = (sin(13x) sin +1)/2 for Sin1 and fsin2(x) = fsin1(x1)fsin1(x2) for Sin2.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 21,
      "context" : "The form of the third function is given in Equation (16) and Figure 2 in [22].",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 13,
      "context" : "1 in [14], which is used here to illustrate a possibility of using IMGPO as a main subroutine to scale up to higher dimensions with additional assumptions.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 13,
      "context" : "For this function, we used REMBO [14] with IMGPO and BaMSOO as its Bayesian optimization subroutine.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 22,
      "context" : ", A* search and the UCT or FSSS algorithm [23]) and learning algorithms (e.",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 23,
      "context" : ", PAC-MDP algorithms [24]).",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 14,
      "context" : "1 of [15].",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 17,
      "context" : "In this section, we modify the result obtained by [18].",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 17,
      "context" : "We now revisit the definitions of several terms and variables used in [18].",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 17,
      "context" : "1 in [18]) Let d be the near-optimality dimension and C denote the corresponding constant in Definition 1.",
      "startOffset" : 5,
      "endOffset" : 9
    } ],
    "year" : 2016,
    "abstractText" : "This paper presents a Bayesian optimization method with exponential convergence without the need of auxiliary optimization and without the δ-cover sampling. Most Bayesian optimization methods require auxiliary optimization: an additional non-convex global optimization problem, which can be time-consuming and hard to implement in practice. Also, the existing Bayesian optimization method with exponential convergence [1] requires access to the δ-cover sampling, which was considered to be impractical [1, 2]. Our approach eliminates both requirements and achieves an exponential convergence rate.",
    "creator" : "LaTeX with hyperref package"
  }
}