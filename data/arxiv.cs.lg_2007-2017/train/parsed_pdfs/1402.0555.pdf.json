{
  "name" : "1402.0555.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Taming the Monster: A Fast and Simple Algorithm for Contextual Bandits",
    "authors" : [ "Alekh Agarwal", "Daniel Hsu", "Satyen Kale", "John Langford", "Lihong Li", "Robert E. Schapire" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 2.\n05 55\nv1 [\ncs .L\nG ]\n√\nT ) oracle calls across all T rounds. By doing so, we obtain the most practical contextual bandit learning algorithm amongst approaches that work for general policy classes. We further conduct a proof-of-concept experiment which demonstrates the excellent computational and prediction performance of (an online variant of) our algorithm relative to several baselines."
    }, {
      "heading" : "1 Introduction",
      "text" : "In the contextual bandit problem, an agent collects rewards for actions taken over a sequence of rounds; in each round, the agent chooses an action to take on the basis of (i) context (or features) for the current round, as well as (ii) feedback, in the form of rewards, obtained in previous rounds. The feedback is incomplete: in any given round, the agent observes the reward only for the chosen action; the agent does not observe the reward for other actions. Contextual bandit problems are found in many important applications such as online recommendation and clinical trials, and represent a natural half-way point between supervised learning and reinforcement learning. The use of features to encode context is inherited from supervised machine learning, while exploration is necessary for good performance as in reinforcement learning.\nThe choice of exploration distribution on actions is important. The strongest known results (Auer et al., 2002; McMahan and Streeter, 2009; Beygelzimer et al., 2011) provide an algorithm that carefully controls the exploration distribution to achieve an optimal regret after T rounds of\nO (√ KT log |Π| )\nrelative to a set of policies Π ⊆ XA mapping contexts x ∈ X to actions a ∈ A (where K is the number of actions). The regret is the difference between the cumulative reward of the best policy in Π and the cumulative reward collected by the algorithm. Because the bound has a mild logarithmic dependence on |Π|, the algorithm can compete with very large policy classes that are likely to yield high rewards, in which case the algorithm also earns high rewards. However, the computational complexity of the algorithm is linear in |Π|, making it tractable for only simple policy classes.\nA sub-linear in |Π| running time is possible for policy classes that can be efficiently searched. In this work, we use the abstraction of an optimization oracle to capture this property: given a set of context/reward vector pairs, the oracle returns a policy in Π with maximum total reward. Using such an oracle in an i.i.d. setting (formally defined in Section 2.1), it is possible to create ǫ-greedy (Sutton and Barto, 1998) or epoch-greedy (Langford and Zhang, 2007) algorithms that run in time O(log |Π|) with only a single call to the oracle per round. However, these algorithms have suboptimal regret bounds of O((K log |Π|)1/3T 2/3) because the algorithms randomize uniformly over actions when they choose to explore.\nThe RandomizedUCB algorithm of Dud́ık et al. (2011a) achieves the optimal regret bound (up to logarithmic factors) in the i.i.d. setting, and runs in time poly(T, log |Π|) with poly(T ) calls to the optimization oracle. This is a fascinating result because it shows that the oracle can provide an exponential speed-up over previous algorithms with optimal regret bounds. However, the algorithm is not practical because the degree of the running time polynomial is high.\nIn this work, we prove the following1:\nTheorem 1. There is an algorithm for the i.i.d. contextual bandit problem with an optimal regret bound requiring Õ( √ KT ) calls to the optimization oracle over T rounds.\nConcretely, we make Õ( √ KT ) calls to the oracle with a net running time of Õ(T 1.5K1/2 log |Π|), vastly improving over the complexity of RandomizedUCB. The major components of the new algorithm are (i) a new coordinate descent procedure for computing a very sparse distribution over policies which can be efficiently sampled from, and (ii) a new epoch structure which allows the distribution over policies to be updated very infrequently. We consider variants of the epoch structure that make different computational trade-offs; on one extreme we concentrate the entire computational burden on O(log T ) rounds with Õ( √ KT ) oracle calls each time, while on the other we spread our computation over √ T rounds with Õ(K) oracle calls for each of these rounds. We stress that in either case, the total number of calls to the oracle is only sublinear. Finally, we develop a more efficient online variant, and conduct a proof-ofconcept experiment showing low computational complexity and high reward relative to several natural baselines.\nMotivation and related work. The EXP4-family of algorithms (Auer et al., 2002; McMahan and Streeter, 2009; Beygelzimer et al., 2011) solve the contextual bandit problem with optimal regret by updating weights (multiplicatively) over all policies in every round. Except for a few special cases (Helmbold and Schapire, 1997; Beygelzimer et al., 2011), the running time of such measure-based algorithms is generally linear in the number of policies.\nIn contrast, the RandomizedUCB algorithm of Dud́ık et al. (2011a) is based on a natural abstraction from supervised learning—the ability to efficiently find a function in a rich function class that minimizes the loss on a training set. This abstraction is encapsulated in the notion of an optimization oracle, which is also useful for ǫ-greedy (Sutton and Barto, 1998) and epoch-greedy (Langford and Zhang, 2007). However, these algorithms have only suboptimal regret bounds.\nAnother class of approaches based on Bayesian updating is Thompson sampling (Thompson, 1933; Li, 2013), which often enjoys strong theoretical guarantees in expectation over the prior and good empirical performance (Chapelle and Li, 2011). Such algorithms, as well as the closely related upper-confidence bound algorithms (Auer, 2002; Chu et al., 2011), are computationally tractable in cases where the posterior distribution over policies can be efficiently maintained or approximated. In our experiments, we compare to a strong baseline algorithm that uses this approach (Chu et al., 2011).\nTo circumvent the Ω(|Π|) running time barrier, we restrict attention to algorithms that only access the policy class via the optimization oracle. Specifically, we use a cost-sensitive classification oracle, and a key challenge is to design good supervised learning problems for querying this oracle. The RandomizedUCB algorithm of Dud́ık et al. (2011a) uses a similar oracle to construct a distribution over policies that solves a certain convex program. However, the number of oracle calls in their work is prohibitively large, and the statistical analysis is also rather complex.2\n1Throughout this paper, we use the Õ notation to suppress dependence on logarithmic factors. 2The paper of Dud́ık et al. (2011a) is colloquially referred to, by its authors, as the “monster paper” (Langford, 2014).\nMain contributions. In this work, we present a new and simple algorithm for solving a similar convex program as that used by RandomizedUCB. The new algorithm is based on coordinate descent: in each iteration, the algorithm calls the optimization oracle to obtain a policy; the output is a sparse distribution over these policies. The number of iterations required to compute the distribution is small—at most Õ( √ Kt) in any round t. In fact, we present a more general scheme based on epochs and warm start\nin which the total number of calls to the oracle is, with high probability, just Õ( √ KT ) over all T rounds ; we prove that this is nearly optimal for a certain class of optimization-based algorithms. The algorithm is natural and simple to implement, and we provide an arguably simpler analysis than that for RandomizedUCB. Finally, we report proof-of-concept experimental results using a variant algorithm showing strong empirical performance."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "In this section, we recall the i.i.d. contextual bandit setting and some basic techniques used in previous works (Auer et al., 2002; Beygelzimer et al., 2011; Dud́ık et al., 2011a)."
    }, {
      "heading" : "2.1 Learning Setting",
      "text" : "Let A be a finite set of K actions, X be a space of possible contexts (e.g., a feature space), and Π ⊆ AX be a finite set of policies that map contexts x ∈ X to actions a ∈ A.3 Let ∆Π := {Q ∈ RΠ : Q(π) ≥ 0 ∀π ∈ Π, ∑π∈Π Q(π) ≤ 1} be the set of non-negative weights over policies with total weight at most one, and let RA+ := {r ∈ RA : r(a) ≥ 0 ∀a ∈ A} be the set of non-negative reward vectors.\nLet D be a probability distribution over X× [0, 1]A, the joint space of contexts and reward vectors; we assume actions’ rewards from D are always in the interval [0, 1]. Let DX denote the marginal distribution of D over X .\nIn the i.i.d. contextual bandit setting, the context/reward vector pairs (xt, rt) ∈ X × [0, 1]A over all rounds t = 1, 2, . . . are randomly drawn independently from D. In round t, the agent first observes the context xt, then (randomly) chooses an action at ∈ A, and finally receives the reward rt(at) ∈ [0, 1] for the chosen action. The (observable) record of interaction resulting from round t is the quadruple (xt, at, rt(at), pt(at)) ∈ X × A× [0, 1]× [0, 1]; here, pt(at) ∈ [0, 1] is the probability that the agent chose action at ∈ A. We let Ht ⊆ X × A × [0, 1]× [0, 1] denote the history (set) of interaction records in the first t rounds. We use the shorthand notation Êx∼Ht [·] to denote expectation when a context x is chosen from the t contexts in Ht uniformly at random.\nLet R(π) := E(x,r)∼D[r(π(x))] denote the expected (instantaneous) reward of a policy π ∈ Π, and let π⋆ := argmaxπ∈ΠR(π) be a policy that maximizes the expected reward (the optimal policy). Let Reg(π) := R(π⋆) − R(π) denote the expected (instantaneous) regret of a policy π ∈ Π relative to the optimal policy. Finally, the (empirical cumulative) regret of the agent after T rounds4 is defined as\nT∑\nt=1\n( rt(π⋆(xt))− rt(at) ) ."
    }, {
      "heading" : "2.2 Inverse Propensity Scoring",
      "text" : "An unbiased estimate of a policy’s reward may be obtained from a history of interaction records Ht using inverse propensity scoring (IPS; also called inverse probability weighting): the expected reward of policy π ∈ Π is estimated as\nR̂t(π) := 1\nt\nt∑\ni=1\nri(ai) · 1{π(xi) = ai} pi(ai) . (1)\n3Extension to VC classes is simple using standard arguments. 4We have defined empirical cumulative regret as being relative to π⋆, rather than to the empirical reward maximizer\nargmaxπ∈Π ∑ T t=1 rt(π(xt)). However, in the i.i.d. setting, the two do not differ by more than O(\n√\nT ln(N/δ)) with probability at least 1− δ.\nThis technique can be viewed as mapping Ht 7→ IPS(Ht) of interaction records (x, a, r(a), p(a)) to context/reward vector pairs (x, r̂), where r̂ ∈ RA+ is a fictitious reward vector that assigns to the chosen action a a scaled reward r(a)/p(a) (possibly greater than one), and assigns to all other actions zero rewards. This transformation IPS(Ht) is detailed in Algorithm 3 (in Appendix A); we may equivalently define R̂t by R̂t(π) := t−1 ∑\n(x,r̂)∈IPS(Ht) r̂(π(x)). It is easy to verify that E[r̂(π(x))|(x, r)] = r(π(x)), as\np(a) is indeed the agent’s probability (conditioned on (x, r)) of picking action a. This implies R̂t(π) is an unbiased estimator for any history Ht.\nLet πt := argmaxπ∈Π R̂t(π) denote a policy that maximizes the expected reward estimate based on inverse propensity scoring with history Ht (π0 can be arbitrary), and let R̂egt(π) := R̂t(πt)− R̂t(π) denote estimated regret relative to πt. Note that R̂egt(π) is generally not an unbiased estimate of Reg(π), because πt is not always π⋆."
    }, {
      "heading" : "2.3 Optimization Oracle",
      "text" : "One natural mode for accessing the set of policies Π is enumeration, but this is impractical in general. In this work, we instead only acceess Π via an optimization oracle which corresponds to a cost-sensitive learner. Following (Dud́ık et al., 2011a), we call this oracle AMO5.\nDefinition 1. For a set of policies Π, the argmax oracle (AMO) is an algorithm, which for any sequence of context and reward vectors, (x1, r1), (x2, r2), . . . , (xt, rt) ∈ X × RA+, returns\nargmax π∈Π\nt∑\nτ=1\nrτ (π(xτ ))."
    }, {
      "heading" : "2.4 Projections and Smoothing",
      "text" : "In each round, our algorithm chooses an action by randomly drawing a policy π from a distribution over Π, and then picking the action π(x) recommended by π on the current context x. This is equivalent to drawing an action according to Q(a|x) := ∑π∈Π:π(x)=aQ(π), ∀a ∈ A . For keeping the variance of reward estimates from IPS in check, it is desirable to prevent the probability of any action from being too small. Thus, as in previous work, we also use a smoothed projection Qµ(·|x) for µ ∈ [0, 1/K], Qµ(a|x) := (1 − Kµ)∑π∈Π:π(x)=aQ(π) + µ, ∀a ∈ A. Every action has probability at least µ under Qµ(·|x).\nFor technical reasons, our algorithm maintains non-negative weights Q ∈ ∆Π over policies that sum to at most one, but not necessarily equal to one; hence, we put any remaining mass on a default policy π̄ ∈ Π to obtain a legitimate probability distribution over policies Q̃ = Q + ( 1−∑π∈Π Q(π) ) 1π̄. We then pick an action from the smoothed projection Q̃µ(·|x) of Q̃ as above. This sampling procedure Sample(x,Q, π̄, µ) is detailed in Algorithm 4 (in Appendix A)."
    }, {
      "heading" : "3 Algorithm and Main Results",
      "text" : "Our algorithm (ILOVETOCONBANDITS) is an epoch-based variant of the RandomizedUCB algorithm of Dud́ık et al. (2011a) and is given in Algorithm 1. Like RandomizedUCB, ILOVETOCONBANDITS also solves an optimization problem (OP) to obtain a distribution over policies to sample from (Step 7), but does so on an epoch schedule, i.e., only on certain pre-specified rounds τ1, τ2, . . .. The only requirement of the epoch schedule is that the length of epoch m is bounded as τm+1 − τm = O(τm). For simplicity, we assume τm+1 ≤ 2τm for m ≥ 1, and τ1 = O(1).\nThe crucial step here is solving (OP). This problem is very similar to the one in (Dud́ık et al., 2011a), and our coordinate descent algorithm in Section 3.1 gives a constructive proof that the problem is feasible. As in (Dud́ık et al., 2011a), we have the following regret bound:\n5Cost-sensitive learners often need a cost instead of reward, in which case we use ct = 1− rt.\nTheorem 2. Suppose it is possible to solve the optimization problem (OP). With probability at least 1− δ, the regret of ILOVETOCONBANDITS after T rounds is\nO (√ KT ln(T |Π|/δ) +K ln(T |Π|/δ) ) .\nAlgorithm 1 Importance-weighted LOw-Variance Epoch-Timed Oracleized CONtextual BANDITS algorithm (ILOVETOCONBANDITS) input Epoch schedule 0 = τ0 < τ1 < τ2 < · · · , allowed failure probability δ ∈ (0, 1). 1: Initial weights Q0 := 0 ∈ ∆Π, initial epoch m := 1.\nDefine µm := min{1/2K, √ ln(16τ2m|Π|/δ)/(Kτm)} for all m ≥ 0.\n2: for round t = 1, 2, . . . do 3: Observe context xt ∈ X . 4: (at, pt(at)) := Sample(xt, Qm−1, πτm−1, µm−1). 5: Select action at and observe reward rt(at) ∈ [0, 1]. 6: if t = τm then 7: Let Qm be the solution to (OP) with history Ht and minimum probability µm. 8: m := m+ 1. 9: end if\n10: end for\nOptimization Problem (OP)\nGiven a historyHt and minimum probability µm, define bπ := R̂egt(π) ψµm for ψ := 100, and find Q ∈ ∆Π such that\n∑\nπ∈Π\nQ(π)bπ ≤ 2K (2)\n∀π ∈ Π : Êx∼Ht [\n1\nQµm(π(x)|x)\n] ≤ 2K + bπ. (3)"
    }, {
      "heading" : "3.1 Solving (OP) via Coordinate Descent",
      "text" : "We now present a coordinate descent algorithm to solve (OP). The pseudocode is given in Algorithm 2. Our analysis, as well as the algorithm itself, are based on a potential function which we use to measure progress. The algorithm can be viewed as a form of coordinate descent applied to this same potential function. The main idea of our analysis is to show that this function decreases substantially on every iteration of this algorithm; since the function is nonnegative, this gives an upper bound on the total number of iterations as expressed in the following theorem.\nTheorem 3. Algorithm 2 (with Qinit := 0) halts in ≤ 4 ln(1/(Kµ))µ iterations, and outputs a solution Q to (OP)."
    }, {
      "heading" : "3.2 Using an Optimization Oracle",
      "text" : "We now show how to implement Algorithm 2 via AMO (c.f. Section 2.3).\nLemma 1. Algorithm 2 can be implemented using one call to AMO before the loop is started, and one call for each iteration of the loop thereafter.\nAlgorithm 2 Coordinate Descent Algorithm Require: History Ht, minimum probability µ, initial weights Qinit ∈ ∆Π. 1: Set Q := Qinit. 2: loop\n3: Define, for all π ∈ Π,\nVπ(Q) = Êx∼Ht [1/Q µ(π(x)|x)] Sπ(Q) = Êx∼Ht [ 1/(Qµ(π(x)|x))2 ]\nDπ(Q) = Vπ(Q)− (2K + bπ).\n4: if ∑\nπ Q(π)(2K + bπ) > 2K then 5: Replace Q by cQ, where\nc := 2K∑\nπ Q(π)(2K + bπ) < 1. (4)\n6: end if 7: if there is a policy π for which Dπ(Q) > 0 then 8: Add the (positive) quantity\nαπ(Q) = Vπ(Q) +Dπ(Q)\n2(1−Kµ)Sπ(Q) to Q(π) and leave all other weights unchanged.\n9: else\n10: Halt and output the current set of weights Q. 11: end if 12: end loop\nProof. At the very beginning, before the loop is started, we compute the best empirical policy so far, πt, by calling AMO on the sequence of historical contexts and estimated reward vectors; i.e., on (xτ , r̂τ ), for τ = 1, 2, . . . , t.\nNext, we show that each iteration in the loop of Algorithm 2 can be implemented via one call to AMO. Going over the pseudocode, first note that operations involving Q in step Step 4 can be performed efficiently since Q has sparse support. Note that the definitions in step Step 3 don’t actually need to be computed for all policies π ∈ Π, as long as we can identify a policy π for which Dπ(Q) > 0. We can identify such a policy using one call to AMO as follows.\nFirst, note that for any policy π, we have\nVπ(Q) = Êx∼Ht\n[ 1\nQµ(π(x)|x)\n] = 1\nt\nt∑\nτ=1\n1\nQµ(π(xτ )|xτ ) ,\nand\nbπ = R̂egt(π)\nψµ = R̂t(πt) ψµ − 1 ψµt\nt∑\nτ=1\nr̂τ (π(xτ )).\nNow consider the sequence of historical contexts and reward vectors, (xτ , r̃τ ) for τ = 1, 2, . . . , t, where for any action a we define\nr̃τ (a) := 1\nt\n( ψµ\nQµ(a|xτ ) + r̂t(a)\n) . (5)\nIt is easy to check that\nDπ(Q) = 1\nψµ\nt∑\nτ=1\nr̃τ (π(xτ ))− ( 2K +\nR̂t(πt) ψµ\n) .\nSince 2K + R̂t(πt)ψµ is a constant independent of π, we have\nargmax π∈Π Dπ(Q) = argmax π∈Π\nt∑\nτ=1\nr̃τ (π(xτ )),\nand hence, calling AMO once on the sequence (xτ , r̃τ ) for τ = 1, 2, . . . , t, we obtain a policy that maximizes Dπ(Q) and thereby identify a policy for which Dπ(Q) > 0, if one exists."
    }, {
      "heading" : "3.3 Epoch Schedule",
      "text" : "Theorem 3 shows that Algorithm 2 solves (OP) with Õ( √ t) calls to AMO in round t. Thus, if we use the epoch schedule τm = m (i.e., run Algorithm 2 in every round), then we get a total of Õ(T 3/2) calls to AMO over all T rounds. This number can be dramatically reduced using a more carefully chosen epoch schedule.\nLemma 2. For the epoch schedule τm := 2 m−1, the total number of calls to AMO is Õ( √ KT ).\nProof. The epoch schedule satisfies the requirement τm+1 ≤ 2τm. With this epoch schedule, Algorithm 2 is run only O(log T ) times over T rounds, leading to Õ( √ KT ) total calls to AMO over the entire period."
    }, {
      "heading" : "3.4 Warm Start",
      "text" : "We now present a different technique to reduce the number of calls to AMO. This is based on the observation that practically speaking, it seems terribly wasteful, at the start of a new epoch, to throw out the results of all of the preceding computations and to begin yet again from nothing. Instead, intuitively, we expect computations to be more moderate if we begin again where we left off last, i.e., a “warm-start” approach. Here, when Algorithm 2 is called at the end of epoch m, we use Qinit := Qm−1 (the previously computed weights) rather than 0.\nWe can combine warm-start with a different epoch schedule to guarantee Õ( √ KT ) total calls to AMO,\nspread across O( √ T ) calls to Algorithm 2.\nLemma 3. Define the epoch schedule (τ1, τ2) := (3, 5) and τm := m 2 for m ≥ 3 (this satisfies τm+1 ≤\n2τm). With high probability, the warm-start variant of Algorithm 1 makes Õ( √ KT ) calls to AMO over\nT rounds and O( √ T ) calls to Algorithm 2."
    }, {
      "heading" : "3.5 A Lower Bound on the Support Size",
      "text" : "So far we have seen various ways to solve the optimization problem (OP), with corresponding bounds on the number of calls to AMO. An attractive feature of the coordinate descent algorithm, Algorithm 2, is that the number of oracle calls is directly related to the number of policies in the support of Qm. Specifically, for the doubling schedule of Section 3.3, Theorem 3 implies that we never have non-zero weights for more than 4 ln(1/(Kµm))µm policies in epoch m. Similarly, the total number of oracle calls for the warm-start approach in Section 3.4 bounds the total number of policies which ever have non-zero weight over all T rounds. The support size of the distributions Qm in Algorithm 1 is crucial to the computational complexity of sampling an action (Step 4 of Algorithm 1).\nIn this section, we demonstrate a lower bound showing that it is not possible to construct substantially sparser distributions that also satisfy the low-variance constraint (3) in the optimization problem (OP). To formally define the lower bound, fix an epoch schedule 0 = τ0 < τ1 < τ2 < · · · and consider the following set of non-negative vectors over policies:\nQm :={Q ∈ ∆Π : Q satisfies Eq. (3) in round τm}. (The distribution Qm computed by Algorithm 1 is in Qm.) Let us also define supp(Q) to be the set of policies where Q puts non-zero entries, with |supp(Q)| denoting the cardinality of this set. Then we have the following lower bound.\nTheorem 4. For any epoch schedule 0 = τ0 < τ1 < τ2 < · · · and any M ∈ N sufficiently large, there exists a distribution D over X × [0, 1]A and a policy class Π such that, with probability at least 1− δ,\ninf m∈N:\nτm≥τM/2\ninf Q∈Qm\n|supp(Q)| = Ω (√\nKτM ln(|Π|τM/δ)\n) .\nThe proof of the theorem is deferred to Appendix E. In the context of our problem, this lower bound shows that the bounds in Lemmas 2 and 3 are unimprovable, since the number of calls to AMO is at least the size of the support, given our mode of access to Π."
    }, {
      "heading" : "4 Regret Analysis",
      "text" : "In this section, we outline the regret analysis for our algorithm ILOVETOCONBANDITS, with details deferred to Appendix B and Appendix C.\nThe deviations of the policy reward estimates R̂t(π) are controlled by (a bound on) the variance of each term in Eq. (1): essentially the left-hand side of Eq. (3) from (OP), except with Êx∼Ht [·] replaced by Ex∼DX [·]. Resolving this discrepancy is handled using deviation bounds, so Eq. (3) holds with Ex∼DX [·], with worse right-hand side constants.\nThe rest of the analysis, which deviates from that of RandomizedUCB, compares the expected regret Reg(π) of any policy π with the estimated regret R̂egt(π) using the variance constraints Eq. (3):\nLemma 4 (Informally). With high probability, for each m such that τm ≥ Õ(K log |Π|), each round t in epoch m, and each π ∈ Π, Reg(π) ≤ 2R̂egt(π) +O(Kµm).\nThis lemma can easily be combined with the constraint Eq. (2) from (OP): since the weights Qm−1 used in any round t in epoch m satisfy ∑ π∈Π Qm−1R̂egτm−1(π) ≤ 2Kµτm−1, we obtain a bound on the (conditionally) expected regret in round t using the above lemma: with high probability,\n∑\nπ∈Π\nQ̃m−1 Reg(π) ≤ O(Kµm−1).\nSumming these terms up over all T rounds and applying martingale concentration gives the final regret bound in Theorem 2."
    }, {
      "heading" : "5 Analysis of the Optimization Algorithm",
      "text" : "In this section, we give a sketch of the analysis of our main optimization algorithm for computing weights Qm on each epoch as in Algorithm 2. As mentioned in Section 3.1, this analysis is based on a potential function.\nSince our attention for now is on a single epoch m, here and in what follows, when clear from context, we drop m from our notation and write simply τ = τm, µ = µm, etc. Let UA be the uniform distribution over the action set A. We define the following potential function for use on epoch m:\nΦm(Q) = τµ\n( Êx[RE (UA‖Qµ(· | x))] 1−Kµ + ∑ π∈ΠQ(π)bπ 2K ) . (6)\nThe function in Eq. (6) is defined for all vectors Q ∈ ∆Π. Also, RE (p‖q) denotes the unnormalized relative entropy between two nonnegative vectors p and q over the action space (or any set) A:\nRE (p‖q) = ∑\na∈A\n(pa ln(pa/qa) + qa − pa).\nThis number is always nonnegative. Here, Qµ(·|x) denotes the “distribution” (which might not sum to 1) over A induced by Qµ for context x as given in Section 2.4. Thus, ignoring constants, this potential function is a combination of two terms: The first measures how far from uniform are the distributions induced by Qµ, and the second is an estimate of expected regret under Q since bπ is proportional to the empirical regret of π. Making Φm small thus encourages Q to choose actions as uniformly as possible while also incurring low regret — exactly the aims of our algorithm. The constants that appear in this definition are for later mathematical convenience.\nFor further intuition, note that, by straightforward calculus, the partial derivative ∂Φm/∂Q(π) is roughly proportional to the variance constraint for π given in Eq. (3) (up to a slight mismatch of constants). This shows that if this constraint is not satisfied, then ∂Φm/∂Q(π) is likely to be negative, meaning that Φm can be decreased by increasing Q(π). Thus, the weight vector Q that minimizes Φm satisfies the variance constraint for every policy π. It turns out that this minimizing Q also satisfies the low regret constraint in Eq. (2), and also must sum to at most 1; in other words, it provides a complete solution to our optimization problem. Algorithm 2 does not fully minimize Φm, but it is based roughly on coordinate descent. This is because in each iteration one of the weights (coordinate directions) Q(π) is increased. This weight is one whose corresponding partial derivative is large and negative.\nTo analyze the algorithm, we first argue that it is correct in the sense of satisfying the required constraints, provided that it halts.\nLemma 5. If Algorithm 2 halts and outputs a weight vector Q, then the constraints Eq. (3) and Eq. (2) must hold, and furthermore the sum of the weights Q(π) is at most 1.\nThe proof is rather straightforward: Following step 4, Eq. (2) must hold, and also the weights must sum to 1. And if the algorithm halts, then Dπ(Q) ≤ 0 for all π, which is equivalent to Eq. (3).\nWhat remains is the more challenging task of bounding the number of iterations until the algorithm does halt. We do this by showing that significant progress is made in reducing Φm on every iteration. To begin, we show that scaling Q as in step 4 cannot cause Φm to increase. Lemma 6. Let Q be a weight vector such that ∑\nπ Q(π)(2K+ bπ) > 2K, and let c be as in Eq. (4). Then Φm(cQ) ≤ Φm(Q).\nProof sketch. We consider Φm(cQ) as a function of c, and argue that its derivative (with respect to c) at the value of c given in the lemma statement is always nonnegative. Therefore, by convexity, it is nondecreasing for all values exceeding c. Since c < 1, this proves the lemma.\nNext, we show that substantial progress will be made in reducing Φm each time that step 8 is executed.\nLemma 7. Let Q denote a set of weights and suppose, for some policy π, that Dπ(Q) > 0. Let Q ′ be a new set of weights which is an exact copy of Q except that Q′(π) = Q(π) + α where α = απ(Q) > 0. Then\nΦm(Q)− Φm(Q′) ≥ τµ2\n4(1−Kµ) . (7)\nProof sketch. We first compute exactly the change in potential for general α. Next, we apply a secondorder Taylor approximation, which is maximized by the α used in the algorithm. The Taylor approximation, for this α, yields a lower bound which can be further simplified using the fact that Qµ(a|x) ≥ µ always, and our assumption that Dπ(Q) > 0. This gives the bound stated in the lemma.\nSo step 4 does not cause Φm to increase, and step 8 causes Φm to decrease by at least the amount given in Lemma 7. This immediately implies Theorem 3: for Qinit = 0, the initial potential is bounded by τµ ln(1/(Kµ))/(1−Kµ), and it is never negative, so the number of times step 8 is executed is bounded by 4 ln(1/(Kµ))/µ as required."
    }, {
      "heading" : "5.1 Epoching and Warm Start",
      "text" : "As shown in Section 2.3, the bound on the number of iterations of the algorithm from Theorem 3 also gives a bound on the number of times the oracle is called. To reduce the number of oracle calls, one\napproach is the “doubling trick” of Section 3.3, which enables us to bound the total combined number of iterations of Algorithm 2 in the first T rounds is only Õ( √ KT ). This means that the average number of\ncalls to the arg-max oracle is only Õ( √\nK/T ) per round, meaning that the oracle is called far less than once per round, and in fact, at a vanishingly low rate.\nWe now turn to warm-start approach of Section 3.4, where in each epoch m + 1 we initialize the coordinate descent algorithm with Qinit = Qm, i.e. the weights computed in the previous epoch m. To analyze this, we bound how much the potential changes from Φm(Qm) at the end of epoch m to Φm+1(Qm) at the very start of epoch m + 1. This, combined with our earlier results regarding how quickly Algorithm 2 drives down the potential, we are able to get an overall bound on the total number of updates across T rounds.\nLemma 8. Let M be the largest integer for which τM+1 ≤ T . With probability at least 1 − 2δ, for all (not too small) T , the total epoch-to-epoch increase in potential is\nM∑\nm=1\n(Φm+1(Qm)− Φm(Qm)) ≤ Õ (√ T\nK\n) ,\nwhere M is the largest integer for which τM+1 ≤ T .\nProof sketch. The potential function, as written in Eq. (6), naturally breaks into two pieces whose epoch-to-epoch changes can be bounded separately. Changes affecting the relative entropy term on the left can be bounded, regardless of Qm, by taking advantage of the manner in which these distributions are smoothed. For the other term on the right, it turns out that these epoch-to-epoch changes are related to statistical quantities which can be bounded with high probability. Specifically, the total change in this term is related first to how the estimated reward of the empirically best policy compares to the expected reward of the optimal policy; and second, to how the reward received by our algorithm compares to that of the optimal reward. From our regret analysis, we are able to show that both of these quantities will be small with high probability.\nThus, the total amount that the potential increases across T rounds is at most Õ( √ T/K). On the other hand, Lemma 7 shows that each time Q is updated by Algorithm 2 the potential decreases by at least Ω̃(1/K). Therefore, the total number of updates of the algorithm totaled over all T rounds is at most Õ( √ KT ). For instance, if we use (τ1, τ2) := (3, 5) and τm := m\n2 for m ≥ 3, then the weight vector Q is only updated about √ T times in T rounds, and on each of those rounds, Algorithm 2 requires\nÕ( √ K) iterations, on average. This proves Lemma 3."
    }, {
      "heading" : "6 Experimental Evaluation",
      "text" : "In this section we evaluate a variant of Algorithm 1 against several baselines. While Algorithm 1 is significantly more efficient than many previous approaches, the overall computational complexity is still at least Õ(T 1.5) excluding the running time of the oracle, since each invocation of the oracle at round t of Algorithm 1 needs O(t) time in order to create t cost-sensitive classification (henceforth CSC) examples through the transformation (5). After further accounting for the running time of the oracle itself, this seems markedly larger than the complexity of an ordinary supervised learning problem where it is typically\npossible to perform an O(1) complexity update upon receiving a fresh example using online learning algorithms.\nA natural solution is to use an “online” oracle which is stateful and accepts examples one by one. An online CSC oracle takes as input a weighted example and returns a predicted class (corresponding to one of K actions in our setting). Since the oracle is stateful, it remembers and uses examples from all previous calls in answering questions, thereby reducing the complexity of each oracle invocation to O(1) as in supervised learning. Using several of these oracles, we can efficiently track a distribution over good policies and sample from it. The detailed pseduo-code describing this high-level idea (which we call Online Cover) is provided in Algorithm 5 in Appendix F. The algorithm maintains a uniform distribution over a fixed number n of policies where n is a parameter of the algorithm. Upon receiving a fresh example, it updates all n policies with the suitable CSC examples (5). The specific CSC algorithm we use is a reduction to squared regression described in Algorithms 4 and 5 of Beygelzimer and Langford (2009), which is amenable to online updates. Our implementation is public and will be referenced in the final draft.\nDue to lack of public datasets for contextual bandit problems, we use a simple supervised-to-contextualbandit transformation (Dud́ık et al., 2011b) on the CCAT document classification problem in RCV1 (Lewis et al., 2004). This is a dataset of 781, 265 examples, with a total of d = 47, 152 TF-IDF features. In the data transformation, we treated the class labels as actions, and one minus 0/1-loss as the reward. Using this dataset, we provide a proof-of-concept that this approach can be empirically very effective. Our evaluation criteria is progressive validation (Blum et al., 1999) on 0/1 loss. We compare ourselves to several plausible baselines, whose results are summarized in Table 1. All baselines and our online algorithm take advantage of linear representations which are known to work well on this dataset. For each algorithm we report the result for the best parameter settings which are mentioned in Table 1.\n1. ǫ-greedy (Sutton and Barto, 1998) explores randomly with probability ǫ and otherwise exploits.\n2. Explore-first is a common variant where you explore uniformly over actions before switching to an exploit-only phase.\n3. A less common but powerful baseline is based on bagging. In essence, multiple algorithms can be trained with examples sampled with replacement. The different predictions of these different learned predictors yield a distribution over actions from which we can sample effectively.\n4. Another reasonable baseline is based on Thompson sampling (Chapelle and Li, 2011; Li, 2013) or linear UCB (Auer, 2002; Li et al., 2010), the latter being quite effective in past evaluations (Li et al., 2010; Chapelle and Li, 2011). It is impractical to run vanilla LinUCB on this problem due to the high-dimensionality which makes matrix inversions impractical. We report results for the algorihm run after doing a dimesionality reduction via random projections to 1000 dimensions. Even then the algorithm required 59 hours6, and simpler variants such as using diagonal matrix approximations or infrequent updating performed substantially worse.\n5. Finally, our algorithm achieves the best loss of 0.0530. Somewhat surprisingly, the minimum occurs for us with a cover set of size 1—apparently for this problem the small decaying amount of uniform random sampling imposed is adequate exploration. Prediction performance is similar with a larger covering set.\nAll baselines except for LinUCB are implemented as a simple modification of Vowpal Wabbit, an open source online learning system. All reported results use default parameters where not otherwise specified. The contextual bandit learning algorithms all operate in a doubly robust mode similar to the reward estimates formed by our algorithm.\nBecause this is actually a fully supervised dataset, we can apply a fully supervised online multiclass algorithm to solve it. We use a simple one-against-all implementation to reduce this to binary classification, yielding an error rate of 0.051 which is competitive with the best previously reported results. This result is effectively a lower bound on the quality of the solution we can hope to achieve with algorithms\n6The linear algebra routines are based on Intel MKL package.\nusing only partial information. Our algorithm nearly achieves this lower bound with a running time only a factor of 2.5 slower. Hence on this dataset, very little further algorithmic improvement is possible."
    }, {
      "heading" : "7 Conclusions",
      "text" : "In this paper we have presented the first practical algorithm to our knowledge that attains the statistically optimal regret guarantee and is computationally efficient in the setting of general policy classes. A remarkable feature of the algorithm is that the total number of oracle calls over all T rounds is sublinear— a remarkable improvement over previous works in this setting. We believe that the online variant of the approach which we implemented in our experiments has the right practical flavor for a scalable solution to the contextual bandit problem. In future work, it would be interesting to directly analyze the Online Cover algorithm."
    }, {
      "heading" : "A Omitted Algorithm Details",
      "text" : "Algorithm 3 and Algorithm 4 give the details of the inverse propensity scoring transformation IPS and the action sampling procedure Sample."
    }, {
      "heading" : "B Deviation Inequalities",
      "text" : "B.1 Freedman’s Inequality\nThe following form of Freedman’s inequality for martingales is from Beygelzimer et al. (2011).\nLemma 9. Let X1, X2, . . . , XT be a sequence of real-valued random variables. Assume for all t ∈ {1, 2, . . . , T }, Xt ≤ R and E[Xt|X1, . . . , Xt−1] = 0. Define S := ∑T t=1 Xt and V := ∑T t=1 E[X 2 t |X1, . . . , Xt−1]. For any δ ∈ (0, 1) and λ ∈ [0, 1/R], with probability at least 1− δ,\nS ≤ (e− 2)λV + ln(1/δ) λ .\nB.2 Variance Bounds\nFix the epoch schedule 0 = τ0 < τ1 < τ2 < · · · . Define the following for any probability distribution P over Π, π ∈ Π, and µ ∈ [0, 1/K]:\nV (P, π, µ) := Ex∼DX\n[ 1\nPµ(π(x)|x)\n] , (8)\nV̂m(P, π, µ) := Êx∼Hτm\n[ 1\nPµ(π(x)|x)\n] . (9)\nThe proof of the following lemma is essentially the same as that of Theorem 6 from Dud́ık et al. (2011a).\nLemma 10. Fix any µm ∈ [0, 1/K] for m ∈ N. For any δ ∈ (0, 1), with probability at least 1− δ,\nV (P, π, µm) ≤ 6.4V̂m(P, π, µm) + 75(1−Kµm) ln |Π|\nµ2mτm + 6.3 ln(2|Π|2m2/δ) µmτm\nfor all probability distributions P over Π, all π ∈ Π, and all m ∈ N. In particular, if\nµm ≥ √\nln(2|Π|m2/δ) Kτm , τm ≥ 4K ln(2|Π|m2/δ),\nthen V (P, π, µm) ≤ 6.4V̂m(P, π, µm) + 81.3K.\nProof sketch. By Bernstein’s (or Freedman’s) inequality and union bounds, for any choice of Nm ∈ N and λm ∈ [0, µm] for m ∈ N, the following holds with probability at least 1− δ:\nV (P, π, µm)− V̂m(P, π, µm) ≤ (e − 2)λmV (P, π, µm)\nµm + ln(|Π|Nm+12m2/δ) λmτm\nall Nm-point distributions P over Π, all π ∈ Π, and all m ∈ N. Here, an N -point distribution over Π is a distribution of the form 1N ∑N i=1 1πi for π1, π2, . . . , πN ∈ Π. We henceforth condition on this ≥ 1 − δ probability event (for choices of Nm and λm to be determined). Using the probabilistic method, it can be shown that for any probability distribution P over Π, any π ∈ Π, any µm ∈ [0, 1/K], and any cm > 0, there exists an Nm-point distribution P̃ over Π such that ( V (P, π, µm)− V (P̃ , π, µm) ) + cm ( V̂m(P̃ , π, µm)− V̂m(P, π, µm) )\n≤ γNm,µm ( V (P, π, µm) + cmV̂m(P, π, µm) )\nwhere γN,µ := √ (1 −Kµ)/(Nµ) + 3(1−Kµ)/(Nµ).\nCombining the displayed inequalities (using cm := 1/(1− (e− 2)λm/µm)) and rearranging gives\nV (P, π, µm) ≤ 1 + γNm,µm 1− γNm,µm · V̂m(P, π, µm) 1− (e− 2)λmµm + 1 1− γNm,µm · 1 1− (e− 2)λmµm · ln(|Π| Nm+12m2/δ) λmτm .\nUsing Nm := ⌈12(1−Kµm)/µm⌉ and λm := 0.66µm for all m ∈ N gives the claimed inequalities. If µm ≥ √ ln(2|Π|m2/δ)/(Kτm) and τm ≥ 4K ln(2|Π|m2/δ), then µ2mτm ≥ ln(|Π|)/K and µmτm ≥ ln(2|Π|2m2/δ), and hence\n75(1−Kµm) ln |Π| µ2mτm + 6.3 ln(2|Π|2m2/δ) µmτm ≤ (75 + 6.3)K = 81.3K.\nB.3 Reward Estimates\nAgain, fix the epoch schedule 0 = τ0 < τ1 < τ2 < · · · . Recall that for any epoch m ∈ N and round t in epoch m,\n• Qm−1 ∈ ∆Π are the non-negative weights computed at the end of epoch m− 1;\n• Q̃m−1 is the probability distribution over Π obtained from Qm−1 and the policy πm−1 with the highest reward estimate through epoch m− 1;\n• Q̃µm−1m−1 (·|xt) is the probability distribution used to choose at. Let\nm(t) := min{m ∈ N : t ≤ τm} (10) be the index of the epoch containing round t ∈ N, and define\nVt(π) := max 0≤m≤m(t)−1 {V (Q̃m, π, µm)} (11)\nfor all t ∈ N and π ∈ Π. Lemma 11. For any δ ∈ (0, 1) and any choices of λm−1 ∈ [0, µm−1] for m ∈ N, with probability at least 1− δ,\n|R̂t(π)−R(π)| ≤ Vt(π)λm−1 + ln(4t2|Π|/δ)\ntλm−1\nfor all policies π ∈ Π, all epochs m ∈ N, and all rounds t in epoch m. Proof. Fix any policy π ∈ Π, epoch m ∈ N, and round t in epoch m. Then\nR̂t(π)−R(π) = 1\nt\nt∑\ni=1\nZi\nwhere Zi := r̂i(π(xi))− ri(π(xi)). Round i is in epoch m(i) ≤ m, so\n|Zi| ≤ 1\nQ̃ µm(i)−1 m(i)−1 (π(xi)|xi)\n≤ 1 µm(i)−1\nby the definition of the fictitious rewards. Because the sequences µ1 ≥ µ2 ≥ · · · and m(1) ≤ m(2) ≤ · · · are monotone, it follows that Zi ≤ 1/µm−1 for all 1 ≤ i ≤ t. Furthermore, E[Zi|Hi−1] = 0 and\nE[Z2i |Hi−1] ≤ E[r̂i(π(xi))2|Hi−1] ≤ V (Q̃m(i)−1, π, µm(i)−1) ≤ Vt(π)\nfor all 1 ≤ i ≤ t. The first inequality follows because for var(X) ≤ E(X2) for any random variable X ; and the other inequalities follow from the definitions of the fictitious rewards, V (·, ·, ·) in Eq. (8), and Vt(·) in Eq. (11). Applying Freedman’s inequality and a union bound to the sums (1/t) ∑t i=1 Zi and\n(1/t) ∑t\ni=1(−Zi) implies the following: for all λm−1 ∈ [0, µm−1], with probability at least 1−2·δ/(4t2|Π|), ∣∣∣∣∣ 1 t t∑\ni=1\nZi ∣∣∣∣∣ ≤ (e − 2)Vt(π)λm−1 + ln(4t2|Π|/δ) tλm−1 .\nThe lemma now follows by applying a union bound for all choices of π ∈ Π and t ∈ N, since ∑\nπ∈Π\n∑\nt∈N\nδ\n2t2|Π| ≤ δ."
    }, {
      "heading" : "C Regret Analysis",
      "text" : "Throughout this section, we fix the allowed probability of failure δ ∈ (0, 1) provided as input to the algorithm, as well as the epoch schedule 0 = τ0 < τ1 < τ2 < · · · .\nC.1 Definitions\nDefine, for all t ∈ N,\ndt := ln(16t 2|Π|/δ), (12)\nand recall that,\nµm = min\n{ 1\n2K , √ dτm Kτm } .\nObserve that dt/t is non-increasing with t ∈ N, and µm is non-increasing with m ∈ N. Let\nm0 := min\n{ m ∈ N : dτm\nτm ≤ 1 4K\n} .\nObserve that τm0 ≥ 2. Define\nρ := sup m≥m0\n{√ τm\nτm−1\n} .\nRecall that we assume τm+1 ≤ 2τm; thus ρ ≤ √ 2.\nC.2 Deviation Control and Optimization Constraints\nLet E be the event in which the following statements hold:\nV (P, π, µm) ≤ 6.4V̂m(P, π, µm) + 81.3K (13)\nfor all probability distributions P over Π, all π ∈ Π, and all m ∈ N such that µm ≥ √ dτm/(Kτm) and τm ≥ 4Kdτm ; and |R̂t(π)−R(π)| ≤ Vt(π)λt +\ndt tλt\n(14)\nwhere\nλt :=\n{√ dt 2Kt if m ≤ m0,\nµm−1 if m > m0.\nfor all all policies π ∈ Π, all epochs m ∈ N, and all rounds t in epoch m. By Lemma 10, Lemma 11, and a union bound, Pr(E) ≥ 1− δ/2.\nFor every epoch m ∈ N, the weights Qm computed at the end of the epoch (in round τm) as the solution to (OP) satisfy the constraints Eq. (2) and Eq. (3): they are, respectively:\n∑\nπ∈Π\nQm(π)R̂egτm(π) ≤ ψ · 2Kµm (15)\nand, for all π ∈ Π,\nV̂m(Qm, π, µm) ≤ 2K + R̂egτm(π)\nψ · µm . (16)\nRecall that ψ = 100 (as defined in (OP), assuming ρ ≤ √ 2). Define θ1 := 94.1 and θ2 := ψ/6.4 (which come from Lemma 12); the proof of Lemma 13 requires that θ2 ≥ 8ρ, and hence ψ ≥ 6.4 · 8ρ; this is true with our setting of ψ since ρ ≤ √ 2.\nC.3 Proof of Theorem 2\nWe now give the proof of Theorem 2, following the outline in Section 4. The following lemma shows that if Vt(π) is large—specifically, much larger thanK—then the estimated regret of π was large in some previous round.\nLemma 12. Assume event E holds. Pick any round t ∈ N and any policy π ∈ Π, and let m ∈ N be the epoch achieving the max in the definition of Vt(π). Then\nVt(π) ≤    2K if µm = 1/(2K), θ1K + R̂egτm(π)\nθ2µm if µm < 1/(2K).\nProof. Fix a round t ∈ N and policy π ∈ Π. Let m ≤ m(t) − 1 be the epoch achieving the max in the definition of Vt(π) from Eq. (11), so Vt(π) = V (Q̃m, π, µm). If µm = 1/(2K), then V (Q̃m, π, µm) ≤ 2K. So assume instead that 1/(2K) > µm = √ dτm/(Kτm). This implies that τm > 4Kdτm . By Eq. (13), which holds in event E , V (Q̃m, π, µm) ≤ 6.4V̂m(Q̃m, π, µm) + 81.3K.\nThe probability distribution Q̃m satisfies the inequalities\nV̂m(Q̃m, π, µm) ≤ V̂m(Qm, π, µm) ≤ 2K + R̂egτm(π)\nψµm .\nAbove, the first inequality follows because the value of V̂m(Qm, π, µm) decreases as the value of Qm(πτm) increases, as it does when going from Qm to Q̃m; the second inequality is the constraint Eq. (16) satisfied by Qm. Combining the displayed inequalities from above proves the claim.\nIn the next lemma, we compare Reg(π) and R̂egt(π) for any policy π by using the deviation bounds for estimated rewards together with the variance bounds from Lemma 12. Define t0 := min{t ∈ N : dt/t ≤ 1/(4K)}. Lemma 13. Assume event E holds. Let c0 := 4ρ(1 + θ1). For all epochs m ≥ m0, all rounds t ≥ t0 in epoch m, and all policies π ∈ Π,\nReg(π) ≤ 2R̂egt(π) + c0Kµm; R̂egt(π) ≤ 2Reg(π) + c0Kµm.\nProof. The proof is by induction on m. As the base case, consider m = m0 and t ≥ t0 in epoch m. By definition of m0, µm = 1/(2K) for all m < m0, so Vt(π) ≤ 2K for all π ∈ Π by Lemma 12. By Eq. (14), which holds in event E , for all π ∈ Π,\n|R̂t(π)−R(π)| ≤ 2Kλ+ dt tλ\nfor all π ∈ Π, where λ = √ dt/(2Kt). This implies\n|R̂t(π) −R(π)| ≤ 2 √\n2Kdt t\nand therefore |R̂egt(π) − Reg(π)| ≤ 4 √ 2Kdt/t by the triangle inequality and optimality of πt and π⋆.\nSince t > τm0−1 and c0 ≥ 4 √ 2ρ, it follows that |R̂egt(π)− Reg(π)| ≤ 4 √ 2ρKµm0 ≤ c0Kµm0 .\nFor the inductive step, fix some epoch m > m0. We assume as the inductive hypothesis that for all epochs m′ < m, all rounds t′ in epoch m′, and all π ∈ Π,\nReg(π) ≤ 2R̂egt′(π) + c0Kµm′ ; R̂egt′(π) ≤ 2Reg(π) + c0Kµm′ .\nWe first show that Reg(π) ≤ 2R̂egt(π) + c0Kµm (17) for all rounds t in epoch m and all π ∈ Π. So fix such a round t and policy π; by Eq. (14) (which holds in event E),\nReg(π) − R̂egt(π) = ( R(π⋆)−R(π) ) − ( R̂t(πt)− R̂t(π) )\n≤ ( R(π⋆)−R(π) ) − ( R̂t(π⋆)− R̂t(π) ) ≤ ( Vt(π) + Vt(π⋆) ) µm−1 +\n2dt tµm−1 . (18)\nAbove, the first inequality follows from the optimality of πt. By Lemma 12, there exist epochs i, j < m such that\nVt(π) ≤ θ1K + R̂egτi(π)\nθ2µi · 1{µi < 1/(2K)},\nVt(π⋆) ≤ θ1K + R̂egτj (π⋆)\nθ2µj · 1{µj < 1/(2K)}.\nSuppose µi < 1/(2K), so m0 ≤ i < m: in this case, the inductive hypothesis implies\nR̂egτi(π) θ2µi ≤ 2Reg(π) + c0Kµi θ2µi ≤ c0K θ2 + 2Reg(π) θ2µm−1\nwhere the second inequality uses the fact that i ≤ m− 1. Therefore,\nVt(π)µm−1 ≤ ( θ1 +\nc0 θ2\n) Kµm−1 + 2\nθ2 Reg(π). (19)\nNow suppose µj < 1/(2K), so m0 ≤ j < m: as above, the inductive hypothesis implies\nR̂egτj (π⋆) θ2µj ≤ 2Reg(π⋆) + c0Kµj θ2µj = c0 θ2 K\nsince Reg(π⋆) = 0. Therefore,\nVt(π⋆)µm−1 ≤ ( θ1 +\nc0 θ2\n) Kµm−1. (20)\nCombining Eq. (18), Eq. (19), and Eq. (20), and rearranging gives\nReg(π) ≤ 1 1− 2θ2\n( R̂egt(π) + 2 ( θ1 +\nc0 θ2\n) Kµm−1 +\n2dt tµm−1\n) .\nSincem ≥ m0+1, it follows that µm−1 ≤ ρµm by definition of ρ. Moreover, since t > τm−1, (dt/t)/µm−1 ≤ Kµ2m−1/µm−1 ≤ ρKµm Applying these inequalities to the above display, and simplifying, yields Eq. (17) because c0 ≥ 4ρ(1 + θ1) and θ2 ≥ 8ρ.\nWe now show that R̂egt(π) ≤ 2Reg(π) + c0Kµm (21)\nfor all π ∈ Π. Again, fix an arbitrary π ∈ Π, and by Eq. (14),\nR̂egt(π)− Reg(π) = ( R̂t(πt)− R̂t(π) ) − ( R(π⋆)−R(π) )\n≤ ( R̂t(πt)− R̂t(π) ) − ( R(πt)−R(π) ) ≤ ( Vt(π) + Vt(πt) ) µm−1 +\n2dt tµm−1\n(22)\nwhere the first inequality follows from the optimality of π⋆. By Lemma 12, there exists an epoch j < m such\nVt(πt) ≤ θ1K + R̂egτj (πt)\nθ2µj · 1{µj < 1/(2K)}.\nSuppose µj < 1/(2K), so m0 ≤ j < m: in this case the inductive hypothesis and Eq. (17) imply\nR̂egτj (πt) θ2µj ≤ 2Reg(πt) + c0Kµj θ2µj ≤\n2 ( 2R̂egt(πt) + c0Kµm ) + c0Kµj\nθ2µj = 3c0 θ2 K\n(the last equality follows because R̂egt(πt) = 0). Thus\nVt(πt)µτ(t)−1 ≤ ( θ1 +\n3c0 θ2\n) Kµm−1. (23)\nCombining Eq. (22), Eq. (23), and Eq. (19) gives\nR̂egt(π) ≤ ( 1 + 2\nθ2\n) Reg(π) + ( 2θ1 +\n4c0 θ2\n) Kµm−1 +\n2dt tµm−1 .\nAgain, applying the inequalities µm−1 ≤ ρµm and (dt/t)/µm−1 ≤ Kµm to the above display, and simplifying, yields Eq. (21) because c0 ≥ 4ρ(1 + θ1) and θ2 ≥ 8ρ. This completes the inductive step, and thus proves the overall claim.\nThe next lemma shows that the “low estimated regret guarantee” of Qt−1 (optimization constraint Eq. (15)) also implies a “low regret guarantee”, via the comparison of R̂egt(·) to Reg(·) from Lemma 13. Lemma 14. Assume event E holds. For every epoch m ∈ N,\n∑\nπ∈Π\nQ̃m−1(π)Reg(π) ≤ (4ψ + c0)Kµm−1\nwhere c0 is defined in Lemma 13.\nProof. Fix any epoch m ∈ N. If m ≤ m0, then µm−1 = 1/(2K), in which case the claim is trivial. Therefore assume m ≥ m0 + 1. Then\n∑\nπ∈Π\nQ̃m−1(π)Reg(π) ≤ ∑\nπ∈Π\nQ̃m−1(π) ( 2R̂egτm−1(π) + c0Kµm−1 )\n= ( 2 ∑\nπ∈Π\nQm−1(π)R̂egτm−1(π)\n) + c0Kµm−1\n≤ ψ · 4Kµm−1 + c0Kµm−1.\nThe first step follows from Lemma 13, as all rounds in an epoch m ≥ m0 + 1 satisfy t ≥ t0; the second step follows from the fact that Q̃m−1 is a probability distribution, that Q̃m−1 = Qm−1 + α1πτm−1 for some α ≥ 0, and that R̂egτm−1(πτm−1) = 0; and the last step follows from the constraint Eq. (15) satisfied by Qm−1.\nFinally, we straightforwardly translate the “low regret guarantee” from Lemma 14 to a bound on the cumulative regret of the algorithm. This involves summing the bound in Lemma 14 over all rounds t (Lemma 15 and Lemma 16) and applying a martingale concentration argument (Lemma 17).\nLemma 15. For any T ∈ N, T∑\nt=1\nµm(t) ≤ 2 √ dτm(T )τm(T )\nK .\nProof. We break the sum over rounds into the epochs, and bound the sum within each epoch:\nT∑\nt=1\nµm(t) ≤ m(T )∑\nm=1\nτm∑\nt=τm−1+1\nµm\n≤ m(T )∑\nm=1\nτm∑\nt=τm−1+1\n√ dτm Kτm\n≤ √\ndτm(T ) K\nm(T )∑\nm=1\nτm − τm−1√ τm\n≤ √\ndτm(T ) K\nm(T )∑\nm=1\n∫ τm τm−1 dx√ x = √ dτm(T ) K ∫ τm(T ) τ0 dx√ x = 2 √ dτm(T ) K √ τm(T ).\nAbove, the first step uses the fact that m(1) = 1 and τm(t)−1 + 1 ≤ t ≤ τm(t). The second step uses the definition of µm. The third step simplifies the sum over t and uses the bound dτm−1 ≤ dτm(T ) . The remaining steps use an integral bound which is then directly evaluated (recalling that τ0 = 0).\nLemma 16. For any T ∈ N, T∑\nt=1\nµm(t)−1 ≤ τm0 2K +\n√ 8dτm(T)τm(T )\nK .\nProof. Under the epoch schedule condition τm+1 ≤ 2τm, we have µm(t)−1 ≤ √ 2µm(t) whenever m(t) > m0; also, µm(t)−1 ≤ 1/(2K) whenever m(t) ≤ m0. The conclusion follows by applying Lemma 15.\nLemma 17. For any T ∈ N, with probability at least 1− δ, the regret after T rounds is at most\nC0 ( 4Kdτm0−1 + √ 8Kdτm(T)τm(T ) ) + √ 8 log(2/δ)\nwhere C0 := (4ψ + c0) and c0 is defined in Lemma 13. Proof. Fix T ∈ N. For each round t ∈ N, let Zt := rt(π⋆(xt))− rt(at)− ∑ π∈Π Q̃m(t)−1Reg(π). Since\nE[rt(π⋆(xt))− rt(at)|Ht−1] = R(π⋆)− ∑\nπ∈Π\nQ̃m(t)−1(π)R(π) = ∑\nπ∈Π\nQ̃m(t)−1Reg(π),\nit follows that E[Zt|Ht−1] = 0. Since |Zt| ≤ 2, it follows by Azuma’s inequality that T∑\nt=1\nZt ≤ 2 √ 2T ln(2/δ)\nwith probability at least 1− δ/2. By Lemma 10, Lemma 11, and a union bound, the event E holds with probability at least 1 − δ/2. Hence, by another union bound, with probability at least 1 − δ, event E holds and the regret of the algorithm is bounded by\nT∑\nt=1\n∑\nπ∈Π\nQ̃m(t)−1(π)Reg(π) + 2 √ 2 ln(2/δ).\nThe double summation above is bounded by Lemma 14 and Lemma 16:\nT∑\nt=1\n∑\nπ∈Π\nQ̃m(t)−1(π)Reg(π) ≤ (4ψ + c0)K T∑\nt=1\nµm(t)−1 ≤ (4ψ + c0) ( τm0 2 + √ 8Kdτm(T)τm(T ) ) .\nBy the definition of m0, τm0−1 ≤ 4Kdτm0−1 . Since τm0 ≤ 2τm0−1 by assumption, it follows that τm0 ≤ 8Kdτm0−1 .\nTheorem 2 follows from Lemma 17 and the fact that τm(T ) ≤ 2(T − 1) whenever τm(T )−1 ≥ 1. There is one last result implied by Lemma 12 and Lemma 13 that is used elsewhere.\nLemma 18. Assume event E holds, and t is such that dτm(t)−1/τm(t)−1 ≤ 1/(4K). Then\nR̂t(πt) ≤ R(π⋆) + ( θ1 +\nc0 θ2 + c0 + 1\n) Kµm(t)−1.\nProof. Let m′ < m(t) achieve the max in the definition of Vt(π⋆). If µm′ < 1/(2K), then m′ ≥ m0, and\nVt(π⋆) ≤ θ1K + R̂egτm′ (π⋆)\nθ2µm′\n≤ θ1K + 2Reg(π⋆) + c0Kµm′\nθ2µm′ = cK\nfor c := θ1 + c0/θ2. Above, the second inequality follows by Lemma 13. If µm′ = 1/(2K), then the same bound also holds. Using this bound, we obtain from Eq. (14),\nR̂t(π⋆)−R(π⋆) ≤ cKµm(t)−1 + dt\ntµm(t)−1 .\nTo conclude,\nR̂t(πτm) = R(π⋆) + ( R̂t(π⋆)−R(π⋆) ) + R̂egt(π⋆)\n≤ R(π⋆) + cKµm(t)−1 + dt\ntµm(t)−1 + R̂egt(π⋆)\n≤ R(π⋆) + cKµm(t)−1 + dt\ntµm(t)−1 + c0Kµm(t)\nwhere the last inequality follows from Lemma 13. The claim follows because dt/t ≤ dτm(t)−1/τm(t)−1 and µm(t) ≤ µm(t)−1."
    }, {
      "heading" : "D Details of Optimization Analysis",
      "text" : "D.1 Proof of Lemma 5\nFollowing the execution of step 4, we must have\n∑\nπ\nQ(π)(2K + bπ) ≤ 2K. (24)\nThis is because, if the condition in step 7 does not hold, then Eq. (24) is already true. Otherwise, Q is replaced by Q′ = cQ, and for this set of weights, Eq. (24) in fact holds with equality. Note that, since all quantities are nonnegative, Eq. (24) immediately implies both Eq. (2), and that ∑ π Q(π) ≤ 1.\nFurthermore, at the point where the algorithm halts at step 10, it must be that for all policies π, Dπ(Q) ≤ 0. However, unraveling definitions, we can see that this is exactly equivalent to Eq. (3).\nD.2 Proof of Lemma 6\nConsider the function g(c) = B0Φm(cQ),\nwhere, in this proof, B0 = 2K/(τµ). Let Q µ c (a|x) = (1 −Kµ)cQ(a|x) + µ. By the chain rule, the first derivative of g is:\ng′(c) = B0 ∑\nπ\nQ(π) ∂G(cQ)\n∂Q(π)\n= ∑\nπ\nQ(π) ( (2K + bπ)− 2Êx∼Ht [ 1\nQµc (π(x)|x)\n]) (25)\nTo handle the second term, note that\n∑\nπ\nQ(π)Êx∼Ht\n[ 1\nQµc (π(x)|x)\n] = ∑\nπ\nQ(π)Êx∼Ht\n[∑\na∈A\n1{π(x) = a} Qµc (a|x)\n]\n= Êx∼Ht\n[∑\na∈A\n∑\nπ\nQ(π)1{π(x) = a} Qµc (a|x)\n]\n= Êx∼Ht\n[∑\na∈A\nQ(a|x) Qµc (a|x)\n]\n= 1\nc Êx∼Ht\n[∑\na∈A\ncQ(a|x) (1−Kµ)cQ(a|x) + µ\n] ≤ K\nc . (26)\nTo see the inequality in Eq. (26), let us fix x and define qa = cQ(a|x). Then ∑ a qa = c ∑\nπ Q(π) ≤ 1 by Eq. (4). Further, the expression inside the expectation in Eq. (26) is equal to\n∑\na\nqa (1−Kµ)qa + µ = K · 1 K\n∑\na\n1\n(1−Kµ) + µ/qa\n≤ K · 1 (1−Kµ) +Kµ/∑a qa\n(27)\n≤ K · 1 (1−Kµ) +Kµ = K. (28)\nEq. (27) uses Jensen’s inequality, combined with the fact that the function 1/(1−Kµ+ µ/x) is concave (as a function of x). Eq. (28) uses the fact that the function 1/(1−Kµ+Kµ/x) is nondecreasing (in x), and that the qa’s sum to at most 1.\nThus, plugging Eq. (26) into Eq. (25) yields\ng′(c) ≥ ∑\nπ\nQ(π)(2K + bπ)− 2K\nc = 0\nby our definition of c. Since g is convex, this means that g is nondecreasing for all values exceeding c. In particular, since c < 1, this gives\nB0Φm(Q) = g(1) ≥ g(c) = B0Φm(cQ),\nimplying the lemma since B0 > 0.\nD.3 Proof of Lemma 7\nWe first compute the change in potential for general α. Note that Q′µ(a|x) = Qµ(a|x) if a 6= π(x), and otherwise\nQ′ µ (π(x)|x) = Qµ(π(x)|x) + (1−Kµ)α.\nThus, most of the terms defining Φm(Q) are left unchanged by the update. In particular, by a direct calculation:\n2K τµ (Φm(Q)− Φm(Q′)) =\n2 1−Kµ Êx∼Ht [ ln ( 1 + α(1−Kµ) Qµ(π(x)|x) )] − α(2K + bπ)\n≥ 2 1−Kµ Êx∼Ht [ α(1 −Kµ) Qµ(π(x)|x) − 1 2 ( α(1−Kµ) Qµ(π(x)|x) )2]\n−α(2K + bπ) (29) = 2αVπ(Q)− (1−Kµ)α2Sπ(Q)− α(2K + bπ) = α(Vπ(Q) +Dπ(Q))− (1−Kµ)α2Sπ(Q) (30)\n= (Vπ(Q) +Dπ(Q))\n2\n4(1−Kµ)Sπ(Q) . (31)\nEq. (29) uses the bound ln(1+x) ≥ x−x2/2 which holds for x ≥ 0 (by Taylor’s theorem). Eq. (31) holds by our choice of α = απ(Q), which was chosen to maximize Eq. (30). By assumption, Dπ(Q) > 0, which implies Vπ(Q) > 2K. Further, since Q µ(a|x) ≥ µ always, we have\nSπ(Q) = Êx∼Ht\n[ 1 Qµ(π(x) | x)2 ]\n≤ 1 µ · Êx∼Ht\n[ 1\nQµ(π(x) | x)\n] = Vπ(Q)\nµ .\nThus,\n(Vπ(Q) +Dπ(Q)) 2\nSπ(Q) ≥ Vπ(Q)\n2\nSπ(Q) = Vπ(Q) ·\nVπ(Q) Sπ(Q) ≥ 2Kµ.\nPlugging into Eq. (31) completes the lemma.\nD.4 Proof of Lemma 8\nWe break the potential of Eq. (6) into pieces and bound the total change in each separately. Specifically, by straightforward algebra, we can write\nΦm(Q) = φ a m(Q) + φ b m + φ c m(Q) + φ d m(Q)\nwhere\nφam(Q) = τmµm\nK(1−Kµm) Êx∼Ht\n[ − ∑\na\nlnQµ(a|x) ]\nφbm = τmµm lnK\n1−Kµm\nφcm(Q) = τmµm\n(∑\nπ\nQ(π)− 1 )\nφdm(Q) = τmµm 2K\n∑\nπ\nQ(π)bπ.\nWe assume throughout that ∑\nπ Q(π) ≤ 1 as will always be the case for the vectors produced by Algorithm 2. For such a vector Q,\nφcm+1(Q)− φcm(Q) = (τm+1µm+1 − τmµm) (∑\nπ\nQ(π)− 1 ) ≤ 0\nsince τmµm is nondecreasing. This means we can essentially disregard the change in this term. Also, note that φbm does not depend on Q. Therefore, for this term, we get a telescoping sum:\nM∑\nm=1\n(φbm+1 − φbm) = φbM+1 − φb1 ≤ φbM+1 ≤ 2 √\nTdT K lnK\nsince KµM+1 ≤ 1/2, and where dT , used in the definition of µm, is defined in Eq. (12). Next, we tackle φam:\nLemma 19. M∑\nm=1\n(φam+1(Qm)− φam(Qm)) ≤ 6 √\nTdT K ln(1/µM+1).\nProof. For the purposes of this proof, let\nCm = µm\n1−Kµm .\nThen we can write\nφam(Q) = − Cm K\nτm∑\nt=1\n∑\na\nlnQµm(a|xt).\nNote that Cm ≥ Cm+1 since µm ≥ µm+1. Thus,\nφam+1(Q)− φam(Q) ≤ Cm+1 K\n[ τm∑\nt=1\n∑\na\nlnQµm(a|xt)\n− τm+1∑\nt=1\n∑\na\nlnQµm+1(a|xt) ]\n= Cm+1 K\n[ τm∑\nt=1\n∑\na\nln ( Qµm(a|xt) Qµm+1(a|xt) )\n− τm+1∑\nt=τm+1\n∑\na\nlnQµm+1(a|xt). ]\n≤ Cm+1[τm ln(µm/µm+1)− (τm+1 − τm) lnµm+1]. (32)\nEq. (32) uses Qµm+1(a|x) ≥ µm+1, and also Qµm(a|x) Qµm+1(a|x) = (1 −Kµm)Q(a|x) + µm (1 −Kµm+1)Q(a|x) + µm+1 ≤ µm µm+1 .\nA sum over the two terms appearing in Eq. (32) can now be bounded separately. Starting with the one on the left, since τm < τm+1 ≤ T and Kµm ≤ 1/2, we have\nCm+1τm ≤ 2τmµm+1 ≤ 2τm+1µm+1 ≤ 2 √\nTdT K .\nThus,\nM∑\nm=1\nCm+1τm ln(µm/µm+1) ≤ 2 √\nTdT K\nM∑\nm=1\nln(µm/µm+1)\n= 2 √ TdT K ln(µ1/µM+1)) ≤ 2 √\nTdT K (− ln(µM+1)). (33)\nFor the second term in Eq. (32), using µm+1 ≥ µM+1 for m ≤ M , and definition of Cm, we have M∑\nm=1\n−Cm+1(τm+1 − τm) lnµm+1 ≤ −2(lnµM+1) M∑\nm=1\n(τm+1 − τm)µm+1\n≤ −2(lnµM+1) T∑\nt=1\nµm(t)\n≤ −4 √\nTdT K (lnµM+1) (34)\nby Lemma 15. Combining Eqs. (32), (33) and (34) gives the statement of the lemma. Finally, we come to φdm(Q), which, by definition of bπ, can be rewritten as\nφdm(Q) = B1τm ∑\nπ\nQ(π)R̂egτm(π)\nwhereB1 = 1/(2Kψ) and ψ is the same as appears in optimization problem (OP). Note that, conveniently,\nτmR̂egτm(π) = Ŝm(πm)− Ŝm(π),\nwhere Ŝm(π) is the cumulative empirical importance-weighted reward through round τm:\nŜm(π) = τm∑\nt=1\nr̂t(π(xt)) = τmR̂τm(π).\nFrom the definition of Q̃, we have that\nφdm(Q̃) = φ d m(Q)\n+B1\n( 1− ∑\nπ\nQ(π) ) τmR̂egτm(πm)\n= φdm(Q)\nsince R̂egτm(πm) = 0. And by a similar computation, φ d m+1(Q̃) ≥ φdm+1(Q) since R̂egτm+1(π) is always nonnegative. Therefore,\nφdm+1(Qm)− φdm(Qm) ≤ φdm+1(Q̃m)− φdm(Q̃m)\n= B1 ∑\nπ\nQ̃m(π) [( Ŝm+1(πm+1)− Ŝm+1(π) ) − ( Ŝm(πm)− Ŝm(π) )]\n= B1 ( Ŝm+1(πm+1)− Ŝm(πm) )\n−B1 ( τm+1∑\nt=τm+1\n∑\nπ\nQ̃m(π)r̂t(π(xt))\n) . (35)\nWe separately bound the two parenthesized expressions in Eq. (35) when summed over all epochs. Beginning with the first one, we have\nM∑\nm=1\n( Ŝm+1(πm+1)− Ŝm(πm) ) = ŜM+1(πM+1)− Ŝ1(π1) ≤ ŜM+1(πM+1).\nBut by Lemma 18 (and under the same assumptions),\nŜM+1(πM+1) = τM+1R̂τM+1(πM+1) ≤ τM+1(R(π⋆) +D0KµM ) ≤ τM+1R(π⋆) +D0 √ KTdT ,\nwhere D0 is the constant appearing in Lemma 18. For the second parenthesized expression of Eq. (35), let us define random variables\nZt = ∑\nπ\nQ̃τ(t)(π)r̂t(π(xt)).\nNote that Zt is nonnegative, and if m = τ(t), then\nZt = ∑\nπ\nQ̃m(π)r̂t(π(xt))\n= ∑\na\nQ̃m(a|xt)r̂t(a)\n= ∑\na\nQ̃m(a|xt) rt(a)1{a = at} Q̃µm(a|xt)\n≤ rt(at) 1−Kµm ≤ 2\nsince Q̃µm(a|x) ≥ (1 − Kµm)Q̃m(a|x), and since rt(at) ≤ 1 and Kµm ≤ 1/2. Therefore, by Azuma’s inequality, with probability at least 1− δ,\nτM+1∑\nt=1\nZt ≥ τM+1∑\nt=1\nE[Zt|Ht−1]− √ 2τM+1 ln(1/δ).\nThe expectation that appears here can be computed to be\nE[Zt|Ht−1] = ∑\nπ\nQ̃m(π)R(π)\nso\nR(π⋆)− E[Zt|Ht−1] = ∑\nπ\nQ̃m(π)(R(π⋆)−R(π))\n= ∑\nπ\nQ̃m(π)Reg(π)\n≤ (4ψ + c0)Kµm by Lemma 14 (under the same assumptions, and using the same constants). Thus, with high probability,\nτM+1∑\nt=1\n(R(π⋆)− Zt) ≤ (4ψ + c0)K τM+1∑\nt=1\nµm(t) + √ 2τM+1 ln(1/δ)\n≤ (4ψ + c0) √ 8KTdT + √ 2T ln(1/δ)\nby Lemma 16. Putting these together, and applying the union bound, we find that with probability at least 1− 2δ, for all T (and corresponding M),\nM∑\nm=1\n(φdm(Qm)− φdm+1(Qm)) ≤ O (√ T\nK ln(T/δ)\n) .\nCombining the bounds on the separate pieces, we get the bound stated in the lemma."
    }, {
      "heading" : "E Proof of Theorem 4",
      "text" : "Recall the earlier definition of the low-variance distribution set\nQm = {Q ∈ ∆Π : Q satisfies Eq. (3) in round τm}.\nFix δ ∈ (0, 1) and the epoch sequence, and assume M is large enough so µm = √ ln(16τ2m|Π|/δ)/τm for all m ∈ N with τm ≥ τM/2. The low-variance constraint Eq. (3) gives, in round t = τm,\nÊx∼Ht\n[ 1\nQµm(π(x)|x)\n] ≤ 2K + R̂egτm(π)\nψµm , ∀π ∈ Π.\nBelow, we use a policy class Π where every policy π ∈ Π has no regret (Reg(π) = 0), in which case Lemma 13 implies\nÊx∼Ht\n[ 1\nQµm(π(x)|x)\n] ≤ 2K + c0Kµm\nψµm = K\n( 2 +\nc0 ψ\n) , ∀π ∈ Π.\nApplying Lemma 10 (and using our choice of µm) gives the following constraints: with probability at least 1− δ, for all m ∈ N with τm ≥ τM/2, for all π ∈ Π,\nEx∼DX\n[ 1\nQ̃µm(π(x)|x)\n] ≤ 81.3K + 6.4K ( 2 +\nc0 ψ\n) =: cK (36)\n(to make Q into a probability distribution Q̃, the leftover mass can be put on any policy, say, already in the support of Q). That is, with high probability, for every relevant epoch m, every Q ∈ Qm satisfies Eq. (36) for all π ∈ Π.\nNext, we construct an instance with the property that these inequalities cannot be satisfied by a very sparse Q. An instance is drawn uniformly at random from N different contexts denoted as {1, 2, . . . , N} (where we set, with foresight, N := 1/(2 √ 2cKµM )). The reward structure in the problem will be extremely simple, with action K always obtaining a reward of 1, while all the other actions obtain a reward of 0, independent of the context. The distribution D will be uniform over the contexts (with these deterministic rewards). Our policy set Π will consist of (K−1)N separate policies, indexed by 1 ≤ i ≤ N and 1 ≤ j ≤ K − 1. Policy πij has the property that\nπij(x) =\n{ j if x = i,\nK otherwise.\nIn words, policy πij takes action j on context i, and action K on all other contexts. Given the uniform distribution over contexts and our reward structure, each policy obtains an identical reward\nR(π) = ( 1− 1\nN\n) · 1 + 1\nN · 0 = 1− 1 N .\nIn particular, each policy has a zero expected regret as required. Finally, observe that on context i, πij is the unique policy taking action j. Hence we have that Q̃(j|i) = Q̃(πij) and Q̃µm(j|i) = (1−Kµm)Q̃(πij) +µm. Now, let us consider the constraint Eq. (36) for the policy πij . The left-hand side of this constraint can be simplified as\nEx∼DX\n[ 1\nQ̃µm(π(x)|x)\n] = 1\nN\nN∑\nx=1\n1\nQ̃µm(πij(x)|x)\n= 1\nN\n∑\nx 6=i\n1\nQ̃µm(πij(x)|x) +\n1 N · 1 Q̃µm(j|i)\n≥ 1 N · 1 Q̃µm(j|i) .\nIf the distribution Q̃ does not put any support on the policy πij , then Q̃ µm(j|i) = µm, and thus\nEx∼DX\n[ 1\nQ̃µm(π(x)|x)\n] ≥ 1\nN · 1 Q̃µm(j|i) = 1 Nµm ≥ 1√ 2NµM > cK\n(since N < 1/( √ 2cKµM )). Such a distribution Q̃ violates Eq. (36), which means that every Q ∈ Qm must have Q̃(πij) > 0. Since this is true for each policy πij , we see that every Q ∈ Qm has\n|supp(Q)| ≥ (K − 1)N = K − 1 2 √ 2cKµM = Ω\n(√ KτM\nln(τM |Π|/δ)\n)\nwhich completes the proof."
    }, {
      "heading" : "F Online Cover algorithm",
      "text" : "This section describes the pseudocode of the precise algorithm use in our experiments. The minimum exploration probability µ was set as 0.05 min(1/K, 1/ √ tK) for our evaluation.\nAlgorithm 5 Online Cover\ninput Cover size n, minimum sampling probability µ. 1: Initialize online cost-sensitive minimization oracles O1, O2, . . . , On, each of which controls a policy\nπ(1), π(2), . . . , π(n); U := uniform probability distribution over these policies. 2: for round t = 1, 2, . . . do 3: Observe context xt ∈ X . 4: (at, pt(at)) := Sample(xt, U, ∅, µ). 5: Select action at and observe reward rt(at) ∈ [0, 1]. 6: for each i = 1, 2, . . . , n do 7: Qi := (i − 1)−1 ∑ j<i 1π(j) . 8: pi(a) := Q µ(a|xt). 9: Create cost-sensitive example (xt, c) where c(a) = 1− rt(at)pt(at)1{a = at} − µ pi(a) .\n10: Update π(i) = Oi(x, c) 11: end for 12: end for\nTwo additional details are important in step 9:\n1. We pass a cost vector rather than a reward vector to the oracle since we have a loss minimization rather than a reward maximization oracle.\n2. We actually used a doubly robust estimate Dud́ık et al. (2011b) with a linear reward function that was trained in an online fashion."
    } ],
    "references" : [ {
      "title" : "The nonstochastic multiarmed",
      "author" : [ "Research", "2002. Peter Auer", "Nicolò Cesa-Bianchi", "Yoav Freund", "Robert E. Schapire" ],
      "venue" : null,
      "citeRegEx" : "Research et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Research et al\\.",
      "year" : 2002
    }, {
      "title" : "An empirical evaluation of Thompson sampling",
      "author" : [ "cross-validation. In COLT", "1999. Olivier Chapelle", "Lihong Li" ],
      "venue" : null,
      "citeRegEx" : "COLT et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "COLT et al\\.",
      "year" : 2011
    }, {
      "title" : "Predicting nearly as well as the best pruning of a decision",
      "author" : [ "2011b. David P. Helmbold", "Robert E. Schapire" ],
      "venue" : null,
      "citeRegEx" : "Helmbold and Schapire.,? \\Q2011\\E",
      "shortCiteRegEx" : "Helmbold and Schapire.",
      "year" : 2011
    }, {
      "title" : "The epoch-greedy algorithm for contextual multi-armed bandits",
      "author" : [ "Tong Zhang" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "Langford and Zhang.,? \\Q2007\\E",
      "shortCiteRegEx" : "Langford and Zhang.",
      "year" : 2007
    }, {
      "title" : "Rcv1: A new benchmark collection for text categorization research",
      "author" : [ "David D Lewis", "Yiming Yang", "Tony G Rose", "Fan Li" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "Lewis et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Lewis et al\\.",
      "year" : 2004
    }, {
      "title" : "Generalized Thompson sampling for contextual bandits",
      "author" : [ "Lihong Li" ],
      "venue" : "CoRR, abs/1310.7163,",
      "citeRegEx" : "Li.,? \\Q2013\\E",
      "shortCiteRegEx" : "Li.",
      "year" : 2013
    }, {
      "title" : "A contextual-bandit approach to personalized news article recommendation",
      "author" : [ "Lihong Li", "Wei Chu", "John Langford", "Robert E. Schapire" ],
      "venue" : "In WWW,",
      "citeRegEx" : "Li et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Li et al\\.",
      "year" : 2010
    }, {
      "title" : "Tighter bounds for multi-armed bandits with expert advice",
      "author" : [ "H. Brendan McMahan", "Matthew Streeter" ],
      "venue" : "In COLT,",
      "citeRegEx" : "McMahan and Streeter.,? \\Q2009\\E",
      "shortCiteRegEx" : "McMahan and Streeter.",
      "year" : 2009
    }, {
      "title" : "Reinforcement learning, an introduction",
      "author" : [ "Richard S. Sutton", "Andrew G. Barto" ],
      "venue" : null,
      "citeRegEx" : "Sutton and Barto.,? \\Q1998\\E",
      "shortCiteRegEx" : "Sutton and Barto.",
      "year" : 1998
    }, {
      "title" : "On the likelihood that one unknown probability exceeds another in view of the evidence of two samples",
      "author" : [ "William R. Thompson" ],
      "venue" : null,
      "citeRegEx" : "Thompson.,? \\Q1933\\E",
      "shortCiteRegEx" : "Thompson.",
      "year" : 1933
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "The strongest known results (Auer et al., 2002; McMahan and Streeter, 2009; Beygelzimer et al., 2011) provide an algorithm that carefully controls the exploration distribution to achieve an optimal regret after T rounds of",
      "startOffset" : 28,
      "endOffset" : 101
    }, {
      "referenceID" : 8,
      "context" : "1), it is possible to create ǫ-greedy (Sutton and Barto, 1998) or epoch-greedy (Langford and Zhang, 2007) algorithms that run in time O(log |Π|) with only a single call to the oracle per round.",
      "startOffset" : 38,
      "endOffset" : 62
    }, {
      "referenceID" : 3,
      "context" : "1), it is possible to create ǫ-greedy (Sutton and Barto, 1998) or epoch-greedy (Langford and Zhang, 2007) algorithms that run in time O(log |Π|) with only a single call to the oracle per round.",
      "startOffset" : 79,
      "endOffset" : 105
    }, {
      "referenceID" : 3,
      "context" : "1), it is possible to create ǫ-greedy (Sutton and Barto, 1998) or epoch-greedy (Langford and Zhang, 2007) algorithms that run in time O(log |Π|) with only a single call to the oracle per round. However, these algorithms have suboptimal regret bounds of O((K log |Π|)1/3T ) because the algorithms randomize uniformly over actions when they choose to explore. The RandomizedUCB algorithm of Dud́ık et al. (2011a) achieves the optimal regret bound (up to logarithmic factors) in the i.",
      "startOffset" : 80,
      "endOffset" : 411
    }, {
      "referenceID" : 7,
      "context" : "The EXP4-family of algorithms (Auer et al., 2002; McMahan and Streeter, 2009; Beygelzimer et al., 2011) solve the contextual bandit problem with optimal regret by updating weights (multiplicatively) over all policies in every round.",
      "startOffset" : 30,
      "endOffset" : 103
    }, {
      "referenceID" : 8,
      "context" : "This abstraction is encapsulated in the notion of an optimization oracle, which is also useful for ǫ-greedy (Sutton and Barto, 1998) and epoch-greedy (Langford and Zhang, 2007).",
      "startOffset" : 108,
      "endOffset" : 132
    }, {
      "referenceID" : 3,
      "context" : "This abstraction is encapsulated in the notion of an optimization oracle, which is also useful for ǫ-greedy (Sutton and Barto, 1998) and epoch-greedy (Langford and Zhang, 2007).",
      "startOffset" : 150,
      "endOffset" : 176
    }, {
      "referenceID" : 9,
      "context" : "Another class of approaches based on Bayesian updating is Thompson sampling (Thompson, 1933; Li, 2013), which often enjoys strong theoretical guarantees in expectation over the prior and good empirical performance (Chapelle and Li, 2011).",
      "startOffset" : 76,
      "endOffset" : 102
    }, {
      "referenceID" : 5,
      "context" : "Another class of approaches based on Bayesian updating is Thompson sampling (Thompson, 1933; Li, 2013), which often enjoys strong theoretical guarantees in expectation over the prior and good empirical performance (Chapelle and Li, 2011).",
      "startOffset" : 76,
      "endOffset" : 102
    }, {
      "referenceID" : 2,
      "context" : "Except for a few special cases (Helmbold and Schapire, 1997; Beygelzimer et al., 2011), the running time of such measure-based algorithms is generally linear in the number of policies. In contrast, the RandomizedUCB algorithm of Dud́ık et al. (2011a) is based on a natural abstraction from supervised learning—the ability to efficiently find a function in a rich function class that minimizes the loss on a training set.",
      "startOffset" : 32,
      "endOffset" : 251
    }, {
      "referenceID" : 2,
      "context" : "Except for a few special cases (Helmbold and Schapire, 1997; Beygelzimer et al., 2011), the running time of such measure-based algorithms is generally linear in the number of policies. In contrast, the RandomizedUCB algorithm of Dud́ık et al. (2011a) is based on a natural abstraction from supervised learning—the ability to efficiently find a function in a rich function class that minimizes the loss on a training set. This abstraction is encapsulated in the notion of an optimization oracle, which is also useful for ǫ-greedy (Sutton and Barto, 1998) and epoch-greedy (Langford and Zhang, 2007). However, these algorithms have only suboptimal regret bounds. Another class of approaches based on Bayesian updating is Thompson sampling (Thompson, 1933; Li, 2013), which often enjoys strong theoretical guarantees in expectation over the prior and good empirical performance (Chapelle and Li, 2011). Such algorithms, as well as the closely related upper-confidence bound algorithms (Auer, 2002; Chu et al., 2011), are computationally tractable in cases where the posterior distribution over policies can be efficiently maintained or approximated. In our experiments, we compare to a strong baseline algorithm that uses this approach (Chu et al., 2011). To circumvent the Ω(|Π|) running time barrier, we restrict attention to algorithms that only access the policy class via the optimization oracle. Specifically, we use a cost-sensitive classification oracle, and a key challenge is to design good supervised learning problems for querying this oracle. The RandomizedUCB algorithm of Dud́ık et al. (2011a) uses a similar oracle to construct a distribution over policies that solves a certain convex program.",
      "startOffset" : 32,
      "endOffset" : 1606
    }, {
      "referenceID" : 2,
      "context" : "Except for a few special cases (Helmbold and Schapire, 1997; Beygelzimer et al., 2011), the running time of such measure-based algorithms is generally linear in the number of policies. In contrast, the RandomizedUCB algorithm of Dud́ık et al. (2011a) is based on a natural abstraction from supervised learning—the ability to efficiently find a function in a rich function class that minimizes the loss on a training set. This abstraction is encapsulated in the notion of an optimization oracle, which is also useful for ǫ-greedy (Sutton and Barto, 1998) and epoch-greedy (Langford and Zhang, 2007). However, these algorithms have only suboptimal regret bounds. Another class of approaches based on Bayesian updating is Thompson sampling (Thompson, 1933; Li, 2013), which often enjoys strong theoretical guarantees in expectation over the prior and good empirical performance (Chapelle and Li, 2011). Such algorithms, as well as the closely related upper-confidence bound algorithms (Auer, 2002; Chu et al., 2011), are computationally tractable in cases where the posterior distribution over policies can be efficiently maintained or approximated. In our experiments, we compare to a strong baseline algorithm that uses this approach (Chu et al., 2011). To circumvent the Ω(|Π|) running time barrier, we restrict attention to algorithms that only access the policy class via the optimization oracle. Specifically, we use a cost-sensitive classification oracle, and a key challenge is to design good supervised learning problems for querying this oracle. The RandomizedUCB algorithm of Dud́ık et al. (2011a) uses a similar oracle to construct a distribution over policies that solves a certain convex program. However, the number of oracle calls in their work is prohibitively large, and the statistical analysis is also rather complex. Throughout this paper, we use the Õ notation to suppress dependence on logarithmic factors. The paper of Dud́ık et al. (2011a) is colloquially referred to, by its authors, as the “monster paper” (Langford, 2014).",
      "startOffset" : 32,
      "endOffset" : 1962
    }, {
      "referenceID" : 4,
      "context" : ", 2011b) on the CCAT document classification problem in RCV1 (Lewis et al., 2004).",
      "startOffset" : 61,
      "endOffset" : 81
    }, {
      "referenceID" : 8,
      "context" : "ǫ-greedy (Sutton and Barto, 1998) explores randomly with probability ǫ and otherwise exploits.",
      "startOffset" : 9,
      "endOffset" : 33
    }, {
      "referenceID" : 5,
      "context" : "Another reasonable baseline is based on Thompson sampling (Chapelle and Li, 2011; Li, 2013) or linear UCB (Auer, 2002; Li et al.",
      "startOffset" : 58,
      "endOffset" : 91
    }, {
      "referenceID" : 6,
      "context" : "Another reasonable baseline is based on Thompson sampling (Chapelle and Li, 2011; Li, 2013) or linear UCB (Auer, 2002; Li et al., 2010), the latter being quite effective in past evaluations (Li et al.",
      "startOffset" : 106,
      "endOffset" : 135
    }, {
      "referenceID" : 6,
      "context" : ", 2010), the latter being quite effective in past evaluations (Li et al., 2010; Chapelle and Li, 2011).",
      "startOffset" : 62,
      "endOffset" : 102
    } ],
    "year" : 2014,
    "abstractText" : "We present a new algorithm for the contextual bandit learning problem, where the learner repeatedly takes an action in response to the observed context, observing the reward only for that action. Our method assumes access to an oracle for solving cost-sensitive classification problems and achieves the statistically optimal regret guarantee with only Õ( √ T ) oracle calls across all T rounds. By doing so, we obtain the most practical contextual bandit learning algorithm amongst approaches that work for general policy classes. We further conduct a proof-of-concept experiment which demonstrates the excellent computational and prediction performance of (an online variant of) our algorithm relative to several baselines.",
    "creator" : "LaTeX with hyperref package"
  }
}