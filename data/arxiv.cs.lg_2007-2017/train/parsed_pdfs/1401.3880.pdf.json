{
  "name" : "1401.3880.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Regression Conformal Prediction with Nearest Neighbours",
    "authors" : [ "Harris Papadopoulos", "Vladimir Vovk", "Alex Gammerman" ],
    "emails" : [ "h.papadopoulos@frederick.ac.cy", "vovk@cs.rhul.ac.uk", "alex@cs.rhul.ac.uk" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "A drawback of traditional machine learning algorithms is that they do not associate their predictions with confidence information, instead they only output simple predictions. However, some kind of confidence information about predictions is of paramount importance in many risk-sensitive applications such as those used for medical diagnosis (Holst, Ohlsson, Peterson, & Edenbrandt, 1998).\nOf course some machine learning theories that produce confidence information do exist. One can apply the theory of Probably Approximately Correct learning (PAC theory, Valiant, 1984) to an algorithm in order to obtain upper bounds on the probability of its error with respect to some confidence level. The bounds produced by PAC theory though, will be very weak unless the data set to which the algorithm is being applied is particularly clean, which is rarely the case. Nouretdinov, Vovk, Vyugin, and Gammerman (2001b) demonstrated the crudeness of PAC bounds by applying one of the best bounds, by Littlestone and Warmuth (Cristianini & Shawe-Taylor, 2000, Thm. 4.25, 6.8), to the USPS data set.\nc©2011 AI Access Foundation. All rights reserved.\nAnother way of obtaining confidence information is by using the Bayesian framework for producing algorithms that complement individual predictions with probabilistic measures of their quality. In order to apply the Bayesian framework however, one is required to have some prior knowledge about the distribution generating the data. When the correct prior is known, Bayesian methods provide optimal decisions. For real world data sets though, as the required knowledge is not available, one has to assume the existence of an arbitrarily chosen prior. In this case, since the assumed prior may be incorrect, the resulting confidence levels may also be “incorrect”; for example the predictive regions output for the 95% confidence level may contain the true label in much less than 95% of the cases. This signifies a major failure as we would expect confidence levels to bound the percentage of expected errors. An experimental demonstration of this negative aspect of Bayesian methods in the case of regression is given in Section 8, while a detailed experimental examination for both classification and regression was performed by Melluish, Saunders, Nouretdinov, and Vovk (2001).\nA different approach to confidence prediction was suggested by Gammerman, Vapnik, and Vovk (1998) (and later greatly improved by Saunders, Gammerman, & Vovk, 1999), who proposed what we call in this paper “Conformal Prediction” (CP). A thorough analysis of CP was given by Vovk, Gammerman, and Shafer (2005), while an overview was presented by Gammerman and Vovk (2007). Conformal Predictors are built on top of traditional machine learning algorithms and accompany each of their predictions with valid measures of confidence. Unlike Bayesian methods, CPs do not require any further assumptions about the distribution of the data, other than that the data are independently and identically distributed (i.i.d.); although this is still a strong assumption, it is almost universally accepted in machine learning. Even if the traditional algorithm on which a CP is based makes some extra assumptions that are not true for a particular data set, the validity of the predictive regions produced by the CP will not be affected. The resulting predictive regions might be uninteresting, but they will still be valid, as opposed to the misleading regions produced by Bayesian methods. Furthermore, in contrast to PAC methods, the confidence measures they produce are useful in practice. Different variants of CPs have been developed based on Support Vector Machines (Saunders et al., 1999; Saunders, Gammerman, & Vovk, 2000), Ridge Regression (Nouretdinov, Melluish, & Vovk, 2001a; Papadopoulos, Proedrou, Vovk, & Gammerman, 2002a), k-Nearest Neighbours for classification (Proedrou, Nouretdinov, Vovk, & Gammerman, 2002; Papadopoulos, Vovk, & Gammerman, 2002b) and Neural Networks (Papadopoulos, Vovk, & Gammerman, 2007), all of which have been shown to give reliable and high quality confidence measures. Moreover, CP has been applied successfully to many problems such as the early detection of ovarian cancer (Gammerman et al., 2009), the classification of leukaemia subtypes (Bellotti, Luo, Gammerman, Delft, & Saha, 2005), the diagnosis of acute abdominal pain (Papadopoulos, Gammerman, & Vovk, 2009a), the prediction of plant promoters (Shahmuradov, Solovyev, & Gammerman, 2005), the recognition of hypoxia electroencephalograms (EEGs) (Zhang, Li, Hu, Li, & Luo, 2008), the prediction of network traffic demand (Dashevskiy & Luo, 2008) and the estimation of effort for software projects (Papadopoulos, Papatheocharous, & Andreou, 2009b).\nThe only drawback of the original CP approach is its relative computational inefficiency. This is due to the transductive nature of the approach, which entails that all computations have to start from scratch for every test example. This renders it unsuitable for application\nto large data sets. For this reason a modification of the original CP approach, called Inductive Conformal Prediction (ICP), was proposed by Papadopoulos et al. (2002a) for regression and by Papadopoulos et al. (2002b) for classification. As suggested by its name, ICP replaces the transductive inference followed in the original approach with inductive inference. Consequently, ICPs are almost as computationally efficient as their underlying algorithms. This is achieved at the cost of some loss in the quality of the produced confidence measures, but this loss is negligible, especially when the data set in question is large, whereas the improvement in computational efficiency is significant. A computational complexity comparison between the original CP and ICP approaches was performed by Papadopoulos (2008). From now on, in order to differentiate clearly between the original CP and ICP approaches the former will be called Transductive Conformal Prediction (TCP).\nIn order to apply CP (either TCP or ICP) to a traditional algorithm one has to develop a nonconformity measure based on that algorithm. This measure evaluates the difference of a new example from a set (actually a multiset or bag) of old examples. Nonconformity measures are constructed using as basis the traditional algorithm to which CP is being applied, called the underlying algorithm of the resulting Conformal Predictor. In effect nonconformity measures assess the degree to which the new example disagrees with the attribute-label relationship of the old examples, according to the underlying algorithm of the CP. It is worth to note that many different nonconformity measures can be constructed for each traditional algorithm and each of those measures defines a different CP. This difference, as we will show in the next section, does not affect the validity of the results produced by the CPs, it only affects their efficiency.\nIn this paper we are only interested in the problem of regression and we focus on k - Nearest Neighbours Regression (k-NNR) as underlying algorithm, which is one of the most popular machine learning techniques. The first regression CPs were proposed by Nouretdinov et al. (2001a) following the TCP approach and by Papadopoulos et al. (2002a) following the ICP approach, both based on the Ridge Regression algorithm. As opposed to the conventional point predictions, the output of regression CPs is a predictive region that satisfies a given confidence level.\nThe typical nonconformity measure used so far in the case of regression is the absolute difference |yi− ŷi|, between the actual label yi of the example i and the predicted label ŷi of the underlying algorithm for that example, given the old examples as training set. Here we propose six extensions to this nonconformity measure for k -Nearest Neighbours Regression and develop the corresponding Inductive and Transductive CPs; unfortunately although all six new measures can be used with the ICP approach, only two of them can be used with TCP. Our definitions normalize the standard measure based on the expected accuracy of the underlying algorithm for each example, which makes the width of the resulting predictive regions vary accordingly. As a result, the predictive regions produced by our measures are in general much tighter than those produced by the standard regression measure. This paper extends our previous work (Papadopoulos, Gammerman, & Vovk, 2008) where the k -Nearest Neighbours Regression TCP was developed using two normalized nonconformity measures. It is also worth mentioning that one other such nonconformity measure definition was presented by Papadopoulos et al. (2002a) for the Ridge Regression ICP.\nThe rest of this paper is structured as follows. In the next section we discuss the general idea on which CPs are based. Then in Sections 3 and 4 we describe the k -Nearest Neigh-\nbours Regression TCP and ICP respectively using the typical regression nonconformity measure. In Section 5 we give our new nonconformity measure definitions and explain the rationale behind them. Section 6 analyses further one of our new nonconformity measures and demonstrates that under specific assumptions it gives asymptotically optimal predictive regions. Section 7 details our experimental results with the 3 TCPs and 7 ICPs developed based on the different measures, while Section 8 compares our methods with Gaussian Process Regression (Rasmussen & Williams, 2006), which is one of the most popular Bayesian approaches. Finally, Section 9 gives our conclusions and discusses some possible future directions of this work."
    }, {
      "heading" : "2. Conformal Prediction",
      "text" : "In this section we briefly describe the idea behind Conformal Prediction; for a more detailed description the interested reader is referred to the book by Vovk et al. (2005). We are given a training set {z1, . . . , zl} of examples, where each zi ∈ Z is a pair (xi, yi); xi ∈ Rd is the vector of attributes for example i and yi ∈ R is the label of that example. We are also given a new unlabeled example xl+1 and our task is to state something about our confidence in different values ỹ for the label yl+1 of this example. As mentioned in Section 1 our only assumption is that all (xi, yi), i = 1, 2, . . . , are generated independently from the same probability distribution.\nFirst let us define the concept of a nonconformity measure. Formally, a nonconformity measure is a family of functions An : Z\n(n−1)×Z → R, n = 1, 2, . . . (where Z(n−1) is the set of all multisets of size n− 1), which assign a numerical score\nαi = An({z1, . . . , zi−1, zi+1, . . . , zn}, zi) (1)\nto each example zi, indicating how different it is from the examples in the multiset\n{z1, . . . , zi−1, zi+1, . . . , zn}.\nAs mentioned in Section 1 each nonconformity measure is based on some traditional machine learning method, which is called the underlying algorithm of the corresponding CP. Given a training set of examples {z1, . . . , zl+1}, each such method creates a prediction rule\nD{z1,...,zl+1},\nwhich maps any unlabeled example x to a label ŷ. As this prediction rule is based on the examples in the training set, the nonconformity score of an example zi ∈ {z1, . . . , zl+1} is measured as the disagreement between the predicted label\nŷi = D{z1,...,zl+1}(xi) (2)\nand the actual label yi of zi. Alternatively, we can create the prediction rule\nD{z1,...,zi−1,zi+1,...,zl+1}\nusing all the examples in the set except zi, and measure the disagreement between\nŷi = D{z1,...,zi−1,zi+1,...,zl+1}(xi) (3)\nand yi.\nNow suppose we are interested in some particular guess ỹ for the label of xl+1. Adding this new example (xl+1, ỹ) to our known data set {(x1, y1), . . . , (xl, yl)} gives the extended set {z1, . . . , zl+1} = {(x1, y1), . . . , (xl+1, ỹ)}; (4) notice that the only unknown component of this set is the label ỹ. We can now use a nonconformity measure Al+1 to compute the nonconformity score\nαi = Al+1({z1, . . . , zi−1, zi+1, . . . , zl+1}, zi)\nof each example zi, i = 1, . . . , l + 1 in (4). The nonconformity score αl+1 on its own does not really give us any information, it is just a numeric value. However, we can find out how unusual zl+1 is according to Al+1 by comparing αl+1 with all other nonconformity scores. This comparison can be performed with the function\np(ỹ) = #{i = 1, . . . , l + 1 : αi ≥ αl+1}\nl + 1 (5)\n(we leave the dependence of the left-hand side on z1, . . . , zl, xl+1 implicit, but it should be always kept in mind). We call the output of this function, which lies between 1l+1 and 1, the p-value of ỹ, as that is the only part of (4) we were not given. An important property of (5) is that ∀δ ∈ [0, 1] and for all probability distributions P on Z,\nP{{z1, . . . , zl+1} : p(yl+1) ≤ δ} ≤ δ; (6)\na proof was given by Nouretdinov et al. (2001b). As a result, if the p-value of a given label is below some very low threshold, say 0.05, this would mean that this label is highly unlikely as such sets will only be generated at most 5% of the time by any i.i.d. process.\nAssuming we could calculate the p-value of every possible label ỹ, as described above, we would be able to exclude all labels that have a p-value under some very low threshold (or significance level) δ and have at most δ chance of being wrong. Consequently, given a confidence level 1− δ a regression conformal predictor outputs the set\n{ỹ : p(ỹ) > δ}, (7)\ni.e. the set of all labels that have a p-value greater than δ. Of course it would be impossible to explicitly calculate the p-value of every possible label ỹ ∈ R. In the next section we describe how one can compute the predictive region (7) efficiently for k -Nearest Neighbours Regression.\nIt should be noted that the p-values computed by any CP will always be valid in the sense of satisfying (6) regardless of the particular algorithm or nonconformity measure definition it uses. The choice of algorithm, nonconformity measure definition and any parameters only affects the tightness of the predictive regions output by the CP, and consequently their usefulness. To demonstrate the influence of an inadequate nonconformity measure definition on the results of a CP, let us consider the case of a trivial definition that always returns the same value αi for any given example (xi, yi). This will make all p-values equal to 1 and will result in the predictive region R regardless of the required confidence level. Although this region is useless since it does not provide us with any information, it is still valid as it will always contain the true label of the example. Therefore even in the worst case of using some totally wrong nonconformity measure definition or algorithm, the regions produced by the corresponding CP will be useless, but they will never be misleading.\n3. k-Nearest Neighbours Regression TCP\nThe k -Nearest Neighbours algorithms base their predictions on the k training examples that are nearest to the unlabeled example in question according to some distance measure, such as the Euclidean distance. More specifically, for an input vector xl+1 the k -Nearest Neighbours Regression (k -NNR) algorithm finds the k nearest training examples to xl+1 and outputs the average (in some cases the median is also used) of their labels as its prediction. A refined form of the method assigns a weight to each one of the k examples depending on their distance from xl+1, these weights determine the contribution of each label to the calculation of its prediction; in other words it predicts the weighted average of their labels. It is also worth to mention that the performance of the Nearest Neighbours method can be enhanced by the use of a suitable distance measure or kernel for a specific data set.\nHere we will consider the version of the k -NNR method which predicts the weighted average of the k nearest examples. In our experiments we used the Euclidean distance, which is the most commonly used distance measure. It will be easy to see that the use of a kernel function or of a different distance measure will not require any changes to our method.\nAs mentioned in Section 1 in order to create any CP we need to define a nonconformity measure based on the underlying algorithm in question. First let us consider the nonconformity measure\nαi = |yi − ŷi|, (8)\nwhere ŷi is the prediction of k -NNR for xi based on the examples\n{(x1, y1), . . . , (xi−1, yi−1), (xi+1, yi+1), . . . , (xl+1, ỹ)};\nrecall from Section 2 that ỹ is the assumed label for the new example xl+1. Following Nouretdinov et al. (2001a) and Vovk et al. (2005) we express the nonconformity score αi of each example i = 1, . . . , l + 1 as a piecewise-linear function of ỹ\nαi = αi(ỹ) = |ai + biỹ|.\nTo do this we define ai and bi as follows:\n• al+1 is minus the weighted average of the labels of the k nearest neighbours of xl+1 and bl+1 = 1;\n• if i ≤ l and xl+1 is one of the k nearest neighbours of xi, ai is yi minus the labels of the k− 1 nearest neighbours of xi from {x1, . . . , xi−1, xi+1, . . . , xl} multiplied by their corresponding weights, and bi is minus the weight of xl+1;\n• if i ≤ l and xl+1 is not one of the k nearest neighbours of xi, ai is yi minus the weighted average of the labels of the k nearest neighbours of xi, and bi = 0.\nAs a result the p-value p(ỹ) (defined by (5)) corresponding to ỹ can only change at the points where αi(ỹ)−αl+1(ỹ) changes sign for some i = 1, . . . , l. This means that instead of having to calculate the p-value of every possible ỹ, we can calculate the set of points ỹ on the real line that have a p-value p(ỹ) greater than the given significance level δ, leading to a feasible prediction algorithm.\nAlgorithm 1: k-NNR TCP\nInput: training set {(x1, y1), . . . , (xl, yl)}, new example xl+1, number of nearest neighbours k and significance level δ. P := {}; for i = 1 to l + 1 do\nCalculate ai and bi for example zi = (xi, yi); if bi < 0 then ai := −ai and bi := −bi; if bi 6= bl+1 then add (10) to P ; if bi = bl+1 6= 0 and ai 6= al+1 then add (11) to P ;\nend Sort P in ascending order obtaining y(1), . . . , y(u); Add y(0) := −∞ and y(u+1) :=∞ to P ; N(j) := 0, j = 0, . . . , u; M(j) := 0, j = 1, . . . , u; for i = 1 to l + 1 do\nif Si = {} (see (9)) then Do nothing; else if Si contains only one point, Si = {y(j)} then\nM(j) := M(j) + 1; else if Si is an interval [y(j1), y(j2)], j1 < j2 then\nM(z) := M(z) + 1, z = j1, . . . , j2; N(z) := N(z) + 1, z = j1, . . . , j2 − 1;\nelse if Si is a ray (−∞, y(j)] then M(z) := M(z) + 1, z = 1, . . . , j; N(z) := N(z) + 1, z = 0, . . . , j − 1; else if Si is a ray [y(j),∞) then M(z) := M(z) + 1, z = j, . . . , u; N(z) := N(z) + 1, z = j, . . . , u; else if Si is the union (−∞, y(j1)] ∪ [y(j2),∞) of two rays, j1 < j2 then M(z) := M(z) + 1, z = 1, . . . , j1, j2, . . . , u; N(z) := N(z) + 1, z = 0, . . . , j1 − 1, j2, . . . , u; else if Si is the real line (−∞,∞) then M(z) := M(z) + 1, z = 1, . . . , u; N(z) := N(z) + 1, z = 0, . . . , u;\nend Output: the predictive region(\n∪ j:\nN(j) l+1\n>δ (y(j), y(j+1))\n) ∪ {y(j) : M(j) l+1 > δ}.\nFor each i = 1, . . . , l + 1, let\nSi = {ỹ : αi(ỹ) ≥ αl+1(ỹ)} = {ỹ : |ai + biỹ| ≥ |al+1 + bl+1ỹ|}. (9)\nEach set Si (always closed) will either be an interval, a ray, the union of two rays, the real line, or empty; it can also be a point, which is a special case of an interval. As we are interested in |ai + biỹ| we can assume that bi ≥ 0 for i = 1, . . . , l + 1 (if not we multiply both ai and bi by −1). If bi 6= bl+1, then αi(ỹ) and αl+1(ỹ) are equal at two points (which may coincide):\n−ai − al+1 bi − bl+1\nand − ai + al+1 bi + bl+1 ; (10)\nin this case Si is an interval (maybe a point) or the union of two rays. If bi = bl+1 6= 0, then αi(ỹ) = αl+1(ỹ) at just one point:\n−ai + al+1 2bi , (11)\nand Si is a ray, unless ai = al+1 in which case Si is the real line. If bi = bl+1 = 0, then Si is either empty or the real line.\nTo calculate the p-value p(ỹ) for any potential label ỹ of the new example xl+1, we count how many Si include ỹ and divide by l + 1,\np(ỹ) = #{i = 1, . . . , l + 1 : ỹ ∈ Si}\nl + 1 . (12)\nAs ỹ increases p(ỹ) can only change at the points (10) and (11), so for any significance level δ we can find the set of ỹ for which p(ỹ) > δ as the union of finitely many intervals and rays. Algorithm 1 implements a slightly modified version of this idea. It creates a list of the points (10) and (11), sorts it in ascending order obtaining y(1), . . . , y(u), adds y(0) = −∞ to the beginning and y(u+1) =∞ to the end of this list, and then computes N(j), the number of Si which contain the interval (y(j), y(j+1)), for j = 0, . . . , u, and M(j) the number of Si which contain the point y(j), for j = 1, . . . , u.\n4. k-Nearest Neighbours Regression ICP\nAs the TCP technique follows a transductive approach, most of its computations are repeated for every test example. The reason for this is that the test example is included in the training set of the underlying algorithm of the TCP in order to calculate the required nonconformity measures. This means that the underlying algorithm is retrained for every test example, which renders TCP quite computationally inefficient for application to large data sets.\nInductive Conformal Predictors (ICP) are based on the same general idea described in Section 2, but follow an inductive approach, which allows them to train their underlying algorithm just once. This is achieved by splitting the training set (of size l) into two smaller sets, the calibration set with q < l examples and the proper training set with m := l − q examples. The proper training set is used for creating the prediction ruleD{z1,...,zm} and only\nAlgorithm 2: k-NNR ICP\nInput: training set {(x1, y1), . . . , (xl, yl)}, test set {xl+1, . . . , xl+r}, number of nearest neighbours k, number of calibration examples q, and significance level δ. m := l − q; P := {}; for i = 1 to q do\nCalculate ŷm+i using {(x1, y1), . . . , (xm, ym)} as training set; Calculate αm+i for the pair zm+i = (xm+i, ym+i); Add αm+i to P ;\nend Sort P in descending order obtaining α(m+1), . . . , α(m+q); s := bδ(q + 1)c; for g = 1 to r do\nCalculate ŷl+g using {(x1, y1), . . . , (xm, ym)} as training set; Output: the predictive region (ŷl+g − α(m+s), ŷl+g + α(m+s)).\nend\nthe examples in the calibration set are used for calculating the p-value of each possible label of the new test example. More specifically, the non-conformity score αm+i of each example zm+i in the calibration set {zm+1, . . . , zm+q} is calculated as the degree of disagreement between the prediction\nŷm+i = D{z1,...,zm}(xm+i) (13)\nand the true label ym+i. In the same way, the non-conformity score αl+g(ỹ) for the assumed label ỹ of the new test example xl+g is calculated as the degree of disagreement between\nŷl+g = D{z1,...,zm}(xl+g) (14)\nand ỹ. Notice that the nonconformity scores of the examples in the calibration set only need to be computed once. Using these non-conformity scores the p-value of each possible label ỹ of xl+g can be calculated as\np(ỹ) = #{i = m+ 1, . . . ,m+ q, l + g : αi ≥ αl+g}\nq + 1 . (15)\nAs with the original CP approach it is impossible to explicitly consider every possible label ỹ ∈ R of a new example xl+g and calculate its p-value. However, now both the nonconformity scores of the calibration set examples αm+1, . . . , αm+q and the k-NNR prediction ŷl+g remain fixed for each test example xl+g, and the only thing that changes for different values of the assumed label ỹ is the nonconformity score αl+g. Therefore p(ỹ) changes only at the points where αl+g(ỹ) = αi for some i = m+1, . . . ,m+q. As a result, for a confidence level 1− δ we only need to find the biggest αi such that when αl+g(ỹ) = αi then p(ỹ) > δ, which will give us the maximum and minimum ỹ that have a p-value bigger than δ and consequently the beginning and end of the corresponding predictive region. More specifically,\nwe sort the nonconformity scores of the calibration examples in descending order obtaining the sequence\nα(m+1), . . . , α(m+q), (16)\nand output the predictive region\n(ŷl+g − α(m+s), ŷl+g + α(m+s)), (17)\nwhere\ns = bδ(q + 1)c. (18)\nThe whole process is detailed in Algorithm 2. Notice that as opposed to Algorithm 1 where all computations have to be repeated for every test example, here only the part inside the second for loop is repeated.\nThe parameter q given as input to Algorithm 2 determines the number of training examples that will be allocated to the calibration set and the nonconformity scores of which will be used by the ICP to generate its predictive regions. These examples should only take up a small portion of the training set, so that their removal will not dramatically reduce the predictive ability of the underlying algorithm. As we are mainly interested in the confidence levels of 99% and 95%, the calibration sizes we use are of the form q = 100n − 1, where n is a positive integer (see (18))."
    }, {
      "heading" : "5. Normalized Nonconformity Measures",
      "text" : "The main aim of this work was to improve the typical regression nonconformity measure (8) by normalizing it with the expected accuracy of the underlying method. The intuition behind this is that if two examples have the same nonconformity score as defined by (8) and the prediction ŷ for one of them was expected to be more accurate than the other, then the former is actually stranger than the latter. This leads to predictive regions that are larger for the examples which are more difficult to predict and smaller for the examples which are easier to predict.\nThe first measure of expected accuracy we use is based on the distance of the example from its k nearest neighbours. Since the k nearest training examples are the ones actually used to derive the prediction of our underlying method for an example, the nearer these are to the example, the more accurate we expect this prediction to be.\nFor each example zi, let us denote by Ti the training set used for generating the prediction ŷi. This will be the set\nTi = {z1, . . . , zi−1, zi+1, . . . , zl+1} (19)\nin the case of the TCP and the set\nTi = {z1, . . . , zm} (20)\nin the case of the ICP. Furthermore, we denote the k nearest neighbours of xi in Ti as\n(xi1 , yi1), . . . , (xik , yik). (21)\nand the sum of the distances between xi and its k nearest neighbours as\ndki = k∑ j=1 distance(xi, xij ). (22)\nWe could use dki as a measure of accuracy, in fact it was used successfully in our previous work (Papadopoulos et al., 2008). However, here in order to make this measure more consistent across different data sets we use\nλki = dki\nmedian({dkj : zj ∈ Ti}) , (23)\nwhich compares the distance of the example from its k nearest neighbours with the median of the distances of all training examples from their k nearest neighbours. Using λki we defined the nonconformity measures:\nαi = ∣∣∣∣yi − ŷiγ + λki ∣∣∣∣ , (24)\nand\nαi = ∣∣∣∣ yi − ŷiexp(γλki ) ∣∣∣∣ , (25)\nwhere the parameter γ ≥ 0 controls the sensitivity of each measure to changes of λki ; in the first case increasing γ results in a less sensitive nonconformity measure, while in the second increasing γ results in a more sensitive measure. The exponential function in definition (25) was chosen because it has a minimum value of 1, since λki will always be positive, and grows quickly as λki increases. As a result, this measure is more sensitive to changes when λ k i is big, which indicates that an example is unusually far from the training examples. The second measure of accuracy we use is based on how different the labels of the example’s k nearest neighbours are, which is measured as their standard deviation. The more these labels agree with each other, the more accurate we expect the prediction of the k-nearest neighbours algorithm to be. For an example xi, we measure the standard deviation of the labels of its k neighbours as\nski = √√√√1 k k∑ j=1 (yij − yi1,...,k)2, (26)\nwhere\nyi1,...,k = 1\nk k∑ j=1 yij . (27)\nAgain to make this measure consistent across data sets we divide it with the median standard deviation of the k nearest neighbour labels of all training examples\nξki = ski\nmedian({skj : zj ∈ Ti}) . (28)\nIn the same fashion as (24) and (25) we defined the nonconformity measures:\nαi = ∣∣∣∣yi − ŷiγ + ξki ∣∣∣∣ , (29)\nand\nαi = ∣∣∣∣ yi − ŷiexp(γξki ) ∣∣∣∣ , (30)\nwhere again the parameter γ controls the sensitivity of each measure to changes of ξki . Finally by combining λki and ξ k i we defined the nonconformity measures:\nαi = ∣∣∣∣ yi − ŷiγ + λki + ξki ∣∣∣∣ , (31)\nand\nαi = ∣∣∣∣ yi − ŷiexp(γλki ) + exp(ρξki ) ∣∣∣∣ , (32)\nwhere in (31) the parameter γ controls the sensitivity of the measure to changes of both λki and ξki , whereas in (32) there are two parameters γ and ρ, which control the sensitivity to changes of λki and ξ k i respectively.\nIn order to use these nonconformity measures with the k-Nearest Neighbours Regression TCP we need to calculate their nonconformity scores as αi = |ai+biỹ|. We can easily do this for (24) and (25) by computing ai and bi as defined in Section 3 and then dividing both by (γ + λki ) for nonconformity measure (24) and by exp(γλ k i ) for nonconformity measure (25). Unfortunately however, the same cannot be applied for all other nonconformity measures we defined since ξki depends on the labels of the k nearest examples, which change for the k nearest neighbours of xl+1 as we change ỹ. For this reason TCP is limited to using only nonconformity measures (24) and (25).\nIn the case of the ICP we calculate the nonconformity scores αm+1, . . . , αm+q of the calibration examples using (24), (25), (29), (30), (31) or (32) and instead of the predictive region (17) we output\n(ŷl+g − α(m+s)(γ + λki ), ŷl+g + α(m+s)(γ + λki )), (33)\nfor (24), (ŷl+g − α(m+s) exp(γλki ), ŷl+g + α(m+s) exp(γλki )), (34)\nfor (25), (ŷl+g − α(m+s)(γ + ξki ), ŷl+g + α(m+s)(γ + ξki )), (35)\nfor (29), (ŷl+g − α(m+s) exp(γξki ), ŷl+g + α(m+s) exp(γξki )), (36)\nfor (30), (ŷl+g − α(m+s)(γ + λki + ξki ), ŷl+g + α(m+s)(γ + λki + ξki )), (37)\nfor (31) and\n(ŷl+g − α(m+s)(exp(γλki ) + exp(ρξki )), ŷl+g + α(m+s)(exp(γλki ) + exp(ρξki ))), (38)\nfor (32)."
    }, {
      "heading" : "6. Theoretical Analysis of Nonconformity Measure (29)",
      "text" : "In this section we examine k-NNR ICP with nonconformity measure (29) under some specific assumptions and show that, under these assumptions, the predictive regions produced are asymptotically optimal; it is important to note that these assumptions are not required for the validity of the resulting predictive regions. We chose not to formalize all the conditions needed for our conclusions, as this would have made our statement far too complicated.\nAssume that each label yi is generated by a normal distribution N (µxi , σ2xi), where µx and σx are smooth functions of x, that each xi is generated by a probability distribution that is concentrated on a compact set and whose density is always greater than some constant > 0, and that k 1, m k and q k. In this case nonconformity measure (29) with γ = 0 will be\nαi = ∣∣∣∣yi − ŷiski ∣∣∣∣ ≈ ∣∣∣∣yi − µxiσxi ∣∣∣∣ , (39) where the division of ski by median({skj : zj ∈ Ti}) is ignored since the latter does not change within the same data set. The values\nym+1 − µxm+1 σxm+1 , . . . , ym+q − µxm+q σxm+q\nwill follow an approximately standard normal distribution, and for a new example xl+g with probability close to 1− δ we have\nyl+g − µxl+g σxl+g ∈ [−α(m+bδqc), α(m+bδqc)],\nwhere α(m+1), . . . , α(m+q) are the nonconformity scores αm+1, . . . , αm+q sorted in descending order. As a result we obtain the region\nyl+g ∈ [µxl+g − α(m+bδqc)σxl+g , µxl+g + α(m+bδqc)σxl+g ],\nwhich, on one hand, is close to the standard (and optimal in various senses) prediction interval for the normal model and, on the other hand, is almost identical to the region (35) of k-NNR ICP (recall that we set γ = 0 and ξki = s k i )."
    }, {
      "heading" : "7. Experimental Results",
      "text" : "Our methods were tested on six benchmark data sets from the UCI (Frank & Asuncion, 2010) and DELVE (Rasmussen et al., 1996) repositories:\n• Boston Housing, which lists the median house prices for 506 different areas of Boston MA in $1000s. Each area is described by 13 attributes such as pollution and crime rate.\n• Abalone, which concerns the prediction of the age of abalone from physical measurements. The data set consists of 4177 examples described by 8 attributes such as diameter, height and shell weight.\n• Computer Activity, which is a collection of a computer systems activity measures from a Sun SPARCstation 20/712 with 128 Mbytes of memory running in a multiuser university department. It consists of 8192 examples of 12 measured values, such as the number of system buffer reads per second and the number of system call writes per second, at random points in time. The task is to predict the portion of time that the cpus run in user mode, ranging from 0 to 100. We used the small variant of the data set which contains only 12 of the 21 attributes.\n• Kin, which was generated from a realistic simulation of the forward dynamics of an 8 link all-revolute robot arm. The task is to predict the distance of the end-effector from a target. The data set consists of 8192 examples described by attributes like joint positions and twist angles. We used the 8nm variant of the data set which contains 8 of the 32 attributes, and is highly non-linear with moderate noise.\n• Bank, which was generated from simplistic simulator of the queues in a series of banks. The task is to predict the rate of rejections, i.e. the fraction of customers that are turned away from the bank because all the open tellers have full queues. The data set consists of 8192 examples described by 8 attributes like area population size and maximum possible length of queues. The 8nm variant of the data set was used with the same characteristics given in the description of the Kin data set.\n• Pumadyn, which was generated from a realistic simulation of the dynamics of a Unimation Puma 560 robot arm. It consists of 8192 examples and the task is to predict the angular acceleration of one of the robot arm’s links. Each example is described by 8 attributes, which include angular positions, velocities and torques of the robot arm. The 8nm variant of the data set was used with the same characteristics given in the description of the Kin data set.\nBefore conducting our experiments the attributes of all data sets were normalized to a minimum value of 0 and a maximum value of 1. Our experiments consisted of 10 random runs of a fold cross-validation process. Based on their sizes the Boston Housing and Abalone data sets were split into 10 and 4 folds respectively, while the other four were splint into 2 folds. For determining the number k of nearest neighbours that was used for each data set, one third of the training set of its first fold was held-out as a validation set and the base algorithm was tested on that set with different k, using the other two thirds for training. The number of neighbours k that gave the smallest mean absolute error was selected. Note that, as explained in Section 2, the choice of k and any other parameter does not affect the validity of the results produced by the corresponding CP, it only affects their efficiency. The calibration set sizes were set to q = 100n − 1 (see Section 4), where n was chosen so that q was approximately 1/10th of each data set’s training size; in the case of the Boston Housing data set the smallest value n = 1 was used. Table 1 gives the number of folds, number of nearest neighbours k, and calibration set size q used in our experiments for each data set, together with the number of examples and attributes it consists of and the width of its range of labels.\nThe parameters γ and ρ of our nonconformity measures were set in all cases to 0.5, which seems to give very good results with all data sets and measures. It is worth to note however, that somewhat tighter predictive regions can be obtained by adjusting the corresponding\nparameter(s) of each measure for each data set. We chose to fix these parameters to 0.5 here, so as to show that the remarkable improvement in the predictive region widths resulting from the use of the new nonconformity measures does not depend on fine tuning these parameters.\nSince our methods output predictive regions instead of point predictions, the main aim of our experiments was to check the tightness of these regions. The first two parts of Tables 2-7 report the median and interdecile mean widths of the regions produced for every data set by each nonconformity measure of the k-NNR TCP and ICP for the 99%, 95% and 90% confidence levels. We chose to report the median and interdecile mean values instead of the mean so as to avoid the strong impact of a few extremely large or extremely small regions.\nIn the third and last parts of Tables 2-7 we check the reliability of the obtained predictive regions for each data set. This is done by reporting the percentage of examples for which the true label is not inside the region output by the corresponding method. In effect this checks empirically the validity of the predictive regions. The percentages reported here are very close to the required significance levels and do not change by much for the different nonconformity measures.\nFigures 1-6 complement the information detailed in Tables 2-7 by displaying boxplots which show the median, upper and lower quartiles, and upper and lower deciles of the predictive region widths produced for each data set. Each chart is divided into three parts, separating the three confidence levels we consider, and each part contains 10 boxplots of which the first three are for the k-NNR TCP with the nonconformity measures (8), (24) and (25), and the remaining seven are for the k-NNR ICP with all nonconformity measures.\nA transformation of the width values reported in Tables 2-7 to the percentage of the range of possible labels they represent shows that in general the predictive regions produced by all our methods are relatively tight. The median width percentages of all nonconformity measures and all data sets are between 17% and 86% for the 99% confidence level and between 11% and 47% for the 95% confidence level. If we now consider the best performing nonconformity measure for each data set, the worst median width percentage for the 99% confidence level is 61% and for the 95% confidence level it is 43% (both for the pumadyn data set).\nBy comparing the predictive region tightness of the different nonconformity measures for each method both in Tables 2-7 and in Figures 1-6, one can see the relatively big improvement that our new nonconformity measures achieve as compared to the standard\nregression measure (8). In almost all cases the new measures give smaller median and interdecile mean widths, while in the majority of cases the difference is quite significant. The degree of improvement is more evident in Figures 1-6 where we see that in many cases the median widths of the predictive regions obtained with the new measures are even below the smallest widths obtained with measure (8).\nA comparison between the nonconformity measures that are based on the distances of the k nearest neighbours, (24) and (25), and those that are based on the standard deviation of their labels, (29) and (30), reveals that the regions produced by the latter cover a much bigger range of widths. Furthermore, the widths of (24) and (25) seem to be in most cases tighter on average than those of (29) and (30) for the highest confidence level 99%, whereas the opposite is true for the 90% and 95% confidence levels. It is also worth mentioning that measures (29) and (30) are the only ones that produced predictive regions with bigger median and interdecile mean widths than those of measure (8) in some cases.\nThe last two measures (31) and (32), which combine the others, seem to give the tightest predictive region widths of ICP overall. In 11 out of 18 cases one of the two has the smallest median predictive region width and in all but 1 cases one of the two has the smallest interdecile mean width. Their superiority is also evident in the figures and especially in Figures 1, 5 and 6.\nOne other important comparison is between the widths of the regions produced by the TCP and ICP approaches. For the standard regression nonconformity measure (8) the regions of the TCP are in all cases tighter than those of the ICP. This is due to the much richer set of examples that TCP uses for calculating its predictive regions; TCP uses the whole training set as opposed to just the calibration examples used by ICP. The difference in predictive region tightness is much bigger in the results of the Boston housing data set, since the calibration set in this case consisted of only 99 examples. It is also worth to note that the widths of the regions produced by ICP with (8) vary much more than the corresponding widths of the TCP, this is natural since the composition of the calibration set changes to a much bigger degree from one run to another than the composition of the whole training set. If we now compare the region widths of the two approaches with nonconformity measures (24) and (25) we see that, with the exception of the Boston housing set, they are very similar in terms of distribution. This shows that the new measures are not so dependant on the composition of the examples used for producing the predictive regions. Furthermore, if we compare the region widths of the TCP with nonconformity measures (24) and (25) with those of the ICP with nonconformity measures (31) and (32), we see that in many cases the regions of the ICP are somewhat tighter, despite the much smaller set of examples it uses to compute them. This is due to the superiority of the measures (31) and (32).\nFinally, in Table 8 we report the processing times of the two approaches. We use two rows for reporting the times of the ICP, one for measure (8) and one for all new measures, since the new measures require some extra computations; i.e. finding the distances of all training examples from their k nearest neighbours and/or the standard deviation of their k nearest neighbour labels. We also group the times of the Computer Activity, Kin, Bank and Pumadyn data sets, which were almost identical as they consist of the same number of examples, into one column. This table demonstrates the huge computational efficiency improvement of ICP over TCP. It also shows that there is some computational overhead involved in using the new nonconformity measures with ICP, but it is not so important, especially baring in mind the degree of improvement they bring in terms of predictive region tightness."
    }, {
      "heading" : "8. Comparison with Gaussian Process Regression",
      "text" : "In this section we compare the predictive regions produced by our methods with those produced by Gaussian Processes (GPs, Rasmussen & Williams, 2006), which is one of the most popular Bayesian machine learning approaches. We first compare Gaussian Process Regression (GPR) and the k-NNR CPs on artificially generated data that satisfy the GP prior and then check the results of GPR on three of the data sets described in Section 7, namely Boston Housing, Abalone and Computer Activity. Our implementation of GPR was based on the Matlab code that accompanies the work of Rasmussen and Williams.\nFor our first set of experiments we generated 100 artificial data sets consisting of 1000 training and 1000 test examples with inputs drawn from a uniform distribution over [−10, 10]5. The labels of each data set were generated from a Gaussian Process with a covariance function defined as the sum of a squared exponential (SE) covariance and independent noise and hyperparameters (l, σf , σn) = (1, 1, 0.1); i.e. a unit length scale, a unit signal magnitude and a noise standard deviation of 0.1. We then applied GPR on these data sets using exactly the same covariance function and hyperparameters and compared the results with those of the k-NNR CPs (which do not take into account any information about how the data were generated). Table 9 reports the results over all 100 data sets obtained by GPR and our methods in the same manner as Tables 2-7. In this case, since the data meets the GPR prior, the percentage of labels outside the predictive regions produced by GPR are more or less equal to the required significance level as we would expect. The same is true for the regions produced by all our methods. Also, although the predictive regions produced by GPR are tighter than those produced by our methods, the difference between the two is very small.\nOur experiments on the three benchmark data sets were performed following exactly the same setting with our experiments on the two CPs, including the use of the same seed for each fold-cross validation run. In terms of data preprocessing, we normalised the attributes of each data set setting the mean of each attribute to 0 and its standard deviation to 1, while we also centred the labels of each data set so as to have a zero mean; these preprocessing steps are advisable for GPR. We tried out a SE covariance and a Matern covariance with smoothness set to v = 3/2 and v = 5/2. In the case of the SE covariance, we used the automatic relevance determination version of the function, which allows for a separate length-scale for each attribute determined by a corresponding hyperparameter. In all cases\nthe actual covariance function was defined as the sum of the corresponding covariance and independent noise. All hyperparameters were adapted by maximizing marginal likelihood on each training set as suggested by Rasmussen and Williams (2006); the adaptation of hyperparameters using leave-one-out cross-validation produces more or less the same results.\nTables 10-12 report the results obtained by GRP on the three data sets with each covariance function. By comparing the values reported in the first two parts of this tables with those in Tables 2-4 one can see that the regions produced by GPR are tighter in almost all cases. However, the percentage of predictive regions that do not include the true label of the example is much higher than the required for the 95% and 99% confidence levels. This shows that the predictive regions produced by GPR are not valid and therefore they are misleading if the correct prior is not known. On the contrary, as demonstrated in Section 2, CPs produce valid predictive regions even if the parameters or underlying algorithm used are totally wrong."
    }, {
      "heading" : "9. Conclusions",
      "text" : "We presented the Transductive and Inductive Conformal Predictors based on the k-Nearest Neighbours Regression algorithm. In addition to the typical regression nonconformity measure, we developed six novel definitions which take into account the expected accuracy of the k-NNR algorithm on the example in question. Our definitions assess the expected accuracy of k-NNR on the example based on its distances from its k nearest examples (24) and (25), on the standard deviation of their labels (29) and (30), or on a combination of the two (31) and (32).\nThe experimental results obtained by applying our methods to various data sets show that in all cases they produce reliable predictive intervals that are tight enough to be useful in practice. Additionally, they illustrate the great extent to which our new nonconformity measure definitions improve the performance of both the transductive and inductive method in terms of predictive region tightness. In the case of the ICP, with which all new measures were evaluated, definitions (31) and (32) appear to be superior to all other measures, giving the overall tightest predictive regions. Moreover, a comparison between the TCP and ICP methods suggests that, when dealing with relatively large data sets the use of nonconformity measures (31) and (32) makes ICP perform equally well with TCP in terms of predictive region tightness, whereas it has a vast advantage when it comes to computational efficiency. Finally, a comparison with Gaussian Process Regression (GPR) demonstrated that our\nmethods produce almost as tight predictive regions as those of GPR when the correct prior is known, while GPR may produce misleading regions on real world data on which the required prior knowledge is not available.\nThe main future direction of this work is the development of normalized nonconformity measures like the ones presented in this paper based on other popular regression techniques, such as Ridge Regression and Support Vector Regression. Although in the case of Ridge Regression one such measure was already defined for ICP (Papadopoulos et al., 2002a), it unfortunately cannot be used with the TCP approach; thus there is potentially a considerable performance gain to be achieved from a definition of this kind for TCP. Moreover, an equally important future aim is the application of our methods to medical or other problems where the provision of predictive regions is desirable, and the evaluation of their results by experts in the corresponding field."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We would like to thank Savvas Pericleous and Haris Haralambous for useful discussions. We would also like to thank the anonymous reviewers for their insightful and constructive comments. This work was supported in part by the Cyprus Research Promotion Foundation through research contract PLHRO/0506/22 (“Development of New Conformal Prediction Methods with Applications in Medical Diagnosis”)."
    } ],
    "references" : [ {
      "title" : "Qualified predictions for microarray and proteomics pattern diagnostics with confidence machines",
      "author" : [ "T. Bellotti", "Z. Luo", "A. Gammerman", "F.W.V. Delft", "V. Saha" ],
      "venue" : "International Journal of Neural Systems,",
      "citeRegEx" : "Bellotti et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Bellotti et al\\.",
      "year" : 2005
    }, {
      "title" : "An Introduction to Support Vector Machines and Other Kernel-based Methods",
      "author" : [ "N. Cristianini", "J. Shawe-Taylor" ],
      "venue" : null,
      "citeRegEx" : "Cristianini and Shawe.Taylor,? \\Q2000\\E",
      "shortCiteRegEx" : "Cristianini and Shawe.Taylor",
      "year" : 2000
    }, {
      "title" : "Network traffic demand prediction with confidence",
      "author" : [ "M. Dashevskiy", "Z. Luo" ],
      "venue" : "In Proceedings of the IEEE Global Telecommunications Conference 2008 (GLOBECOM",
      "citeRegEx" : "Dashevskiy and Luo,? \\Q2008\\E",
      "shortCiteRegEx" : "Dashevskiy and Luo",
      "year" : 2008
    }, {
      "title" : "Learning by transduction",
      "author" : [ "A. Gammerman", "V. Vapnik", "V. Vovk" ],
      "venue" : "In Proceedings of the Fourteenth Conference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Gammerman et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Gammerman et al\\.",
      "year" : 1998
    }, {
      "title" : "Serum proteomic abnormality predating screen detection of ovarian cancer",
      "author" : [ "A. Gammerman", "V. Vovk", "B. Burford", "I. Nouretdinov", "Z. Luo", "A. Chervonenkis", "M. Waterfield", "R. Cramer", "P. Tempst", "J. Villanueva", "M. Kabir", "S. Camuzeaux", "J. Timms", "U. Menon", "I. Jacobs" ],
      "venue" : "The Computer Journal,",
      "citeRegEx" : "Gammerman et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Gammerman et al\\.",
      "year" : 2009
    }, {
      "title" : "Hedging predictions in machine learning: The second computer journal lecture",
      "author" : [ "A. Gammerman", "V. Vovk" ],
      "venue" : "The Computer Journal,",
      "citeRegEx" : "Gammerman and Vovk,? \\Q2007\\E",
      "shortCiteRegEx" : "Gammerman and Vovk",
      "year" : 2007
    }, {
      "title" : "Intelligent computer reporting ‘lack of experience’: a confidence measure for decision support systems",
      "author" : [ "H. Holst", "M. Ohlsson", "C. Peterson", "L. Edenbrandt" ],
      "venue" : "Clinical Physiology,",
      "citeRegEx" : "Holst et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Holst et al\\.",
      "year" : 1998
    }, {
      "title" : "Comparing the Bayes and Typicalness frameworks",
      "author" : [ "T. Melluish", "C. Saunders", "I. Nouretdinov", "V. Vovk" ],
      "venue" : "In Proceedings of the 12th European Conference on Machine Learning (ECML’01),",
      "citeRegEx" : "Melluish et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Melluish et al\\.",
      "year" : 2001
    }, {
      "title" : "Ridge regression confidence machine",
      "author" : [ "I. Nouretdinov", "T. Melluish", "V. Vovk" ],
      "venue" : "In Proceedings of the 18th International Conference on Machine Learning",
      "citeRegEx" : "Nouretdinov et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Nouretdinov et al\\.",
      "year" : 2001
    }, {
      "title" : "Pattern recognition and density estimation under the general i.i.d. assumption",
      "author" : [ "I. Nouretdinov", "V. Vovk", "M.V. Vyugin", "A. Gammerman" ],
      "venue" : "In Proceedings of the 14th Annual Conference on Computational Learning Theory and 5th European Conference on Computational Learning Theory, Vol. 2111 of Lecture Notes in Computer Science,",
      "citeRegEx" : "Nouretdinov et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Nouretdinov et al\\.",
      "year" : 2001
    }, {
      "title" : "Inductive Conformal Prediction: Theory and application to neural networks",
      "author" : [ "H. Papadopoulos" ],
      "venue" : "Tools in Artificial Intelligence,",
      "citeRegEx" : "Papadopoulos,? \\Q2008\\E",
      "shortCiteRegEx" : "Papadopoulos",
      "year" : 2008
    }, {
      "title" : "Normalized nonconformity measures for regression conformal prediction",
      "author" : [ "H. Papadopoulos", "A. Gammerman", "V. Vovk" ],
      "venue" : "In Proceedings of the IASTED International Conference on Artificial Intelligence and Applications (AIA",
      "citeRegEx" : "Papadopoulos et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Papadopoulos et al\\.",
      "year" : 2008
    }, {
      "title" : "Confidence predictions for the diagnosis of acute abdominal pain",
      "author" : [ "H. Papadopoulos", "A. Gammerman", "V. Vovk" ],
      "venue" : "Artificial Intelligence Applications & Innovations III,",
      "citeRegEx" : "Papadopoulos et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Papadopoulos et al\\.",
      "year" : 2009
    }, {
      "title" : "Reliable confidence intervals for software effort estimation",
      "author" : [ "H. Papadopoulos", "E. Papatheocharous", "A.S. Andreou" ],
      "venue" : "In Proceedings of the 2nd Workshop on Artificial Intelligence Techniques in Software Engineering (AISEW 2009),",
      "citeRegEx" : "Papadopoulos et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Papadopoulos et al\\.",
      "year" : 2009
    }, {
      "title" : "Inductive confidence machines for regression",
      "author" : [ "H. Papadopoulos", "K. Proedrou", "V. Vovk", "A. Gammerman" ],
      "venue" : "In Proceedings of the 13th European Conference on Machine Learning (ECML’02),",
      "citeRegEx" : "Papadopoulos et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Papadopoulos et al\\.",
      "year" : 2002
    }, {
      "title" : "Qualified predictions for large data sets in the case of pattern recognition",
      "author" : [ "H. Papadopoulos", "V. Vovk", "A. Gammerman" ],
      "venue" : "In Proceedings of the 2002 International Conference on Machine Learning and Applications (ICMLA’02),",
      "citeRegEx" : "Papadopoulos et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Papadopoulos et al\\.",
      "year" : 2002
    }, {
      "title" : "Conformal prediction with neural networks",
      "author" : [ "H. Papadopoulos", "V. Vovk", "A. Gammerman" ],
      "venue" : "In Proceedings of the 19th IEEE International Conference on Tools with Artificial Intelligence (ICTAI’07),",
      "citeRegEx" : "Papadopoulos et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Papadopoulos et al\\.",
      "year" : 2007
    }, {
      "title" : "Transductive confidence machines for pattern recognition",
      "author" : [ "K. Proedrou", "I. Nouretdinov", "V. Vovk", "A. Gammerman" ],
      "venue" : "In Proceedings of the 13th European Conference on Machine Learning (ECML’02),",
      "citeRegEx" : "Proedrou et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Proedrou et al\\.",
      "year" : 2002
    }, {
      "title" : "DELVE: Data for evaluating learning in valid experiments. URL http://www.cs.toronto.edu/∼delve",
      "author" : [ "C.E. Rasmussen", "R.M. Neal", "G.E. Hinton", "D. Van Camp", "M. Revow", "Z. Ghahramani", "R. Kustra", "R. Tibshirani" ],
      "venue" : null,
      "citeRegEx" : "Rasmussen et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Rasmussen et al\\.",
      "year" : 1996
    }, {
      "title" : "Gaussian Processes for Machine Learning",
      "author" : [ "C.E. Rasmussen", "C.K.I. Williams" ],
      "venue" : null,
      "citeRegEx" : "Rasmussen and Williams,? \\Q2006\\E",
      "shortCiteRegEx" : "Rasmussen and Williams",
      "year" : 2006
    }, {
      "title" : "Transduction with confidence and credibility",
      "author" : [ "C. Saunders", "A. Gammerman", "V. Vovk" ],
      "venue" : "In Proceedings of the 16th International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Saunders et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Saunders et al\\.",
      "year" : 1999
    }, {
      "title" : "Computationally efficient transductive machines",
      "author" : [ "C. Saunders", "A. Gammerman", "V. Vovk" ],
      "venue" : "In Proceedings of the Eleventh International Conference on Algorithmic Learning Theory (ALT’00), Vol. 1968 of Lecture Notes in Artificial Intelligence,",
      "citeRegEx" : "Saunders et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Saunders et al\\.",
      "year" : 2000
    }, {
      "title" : "Plant promoter prediction with confidence estimation",
      "author" : [ "I.A. Shahmuradov", "V.V. Solovyev", "A.J. Gammerman" ],
      "venue" : "Nucleic Acids Research,",
      "citeRegEx" : "Shahmuradov et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Shahmuradov et al\\.",
      "year" : 2005
    }, {
      "title" : "A theory of the learnable",
      "author" : [ "L.G. Valiant" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "Valiant,? \\Q1984\\E",
      "shortCiteRegEx" : "Valiant",
      "year" : 1984
    }, {
      "title" : "Algorithmic Learning in a Random World",
      "author" : [ "V. Vovk", "A. Gammerman", "G. Shafer" ],
      "venue" : null,
      "citeRegEx" : "Vovk et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Vovk et al\\.",
      "year" : 2005
    }, {
      "title" : "Recognition of hypoxia EEG with a preset confidence level based on EEG analysis",
      "author" : [ "J. Zhang", "G. Li", "M. Hu", "J. Li", "Z. Luo" ],
      "venue" : "In Proceedings of the International Joint Conference on Neural Networks (IJCNN 2008), part of the IEEE World Congress on Computational Intelligence (WCCI",
      "citeRegEx" : "Zhang et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 23,
      "context" : "One can apply the theory of Probably Approximately Correct learning (PAC theory, Valiant, 1984) to an algorithm in order to obtain upper bounds on the probability of its error with respect to some confidence level. The bounds produced by PAC theory though, will be very weak unless the data set to which the algorithm is being applied is particularly clean, which is rarely the case. Nouretdinov, Vovk, Vyugin, and Gammerman (2001b) demonstrated the crudeness of PAC bounds by applying one of the best bounds, by Littlestone and Warmuth (Cristianini & Shawe-Taylor, 2000, Thm.",
      "startOffset" : 81,
      "endOffset" : 433
    }, {
      "referenceID" : 20,
      "context" : "Different variants of CPs have been developed based on Support Vector Machines (Saunders et al., 1999; Saunders, Gammerman, & Vovk, 2000), Ridge Regression (Nouretdinov, Melluish, & Vovk, 2001a; Papadopoulos, Proedrou, Vovk, & Gammerman, 2002a), k-Nearest Neighbours for classification (Proedrou, Nouretdinov, Vovk, & Gammerman, 2002; Papadopoulos, Vovk, & Gammerman, 2002b) and Neural Networks (Papadopoulos, Vovk, & Gammerman, 2007), all of which have been shown to give reliable and high quality confidence measures.",
      "startOffset" : 79,
      "endOffset" : 137
    }, {
      "referenceID" : 4,
      "context" : "Moreover, CP has been applied successfully to many problems such as the early detection of ovarian cancer (Gammerman et al., 2009), the classification of leukaemia subtypes (Bellotti, Luo, Gammerman, Delft, & Saha, 2005), the diagnosis of acute abdominal pain (Papadopoulos, Gammerman, & Vovk, 2009a), the prediction of plant promoters (Shahmuradov, Solovyev, & Gammerman, 2005), the recognition of hypoxia electroencephalograms (EEGs) (Zhang, Li, Hu, Li, & Luo, 2008), the prediction of network traffic demand (Dashevskiy & Luo, 2008) and the estimation of effort for software projects (Papadopoulos, Papatheocharous, & Andreou, 2009b).",
      "startOffset" : 106,
      "endOffset" : 130
    }, {
      "referenceID" : 3,
      "context" : "A thorough analysis of CP was given by Vovk, Gammerman, and Shafer (2005), while an overview was presented by Gammerman and Vovk (2007). Conformal Predictors are built on top of traditional machine learning algorithms and accompany each of their predictions with valid measures of confidence.",
      "startOffset" : 110,
      "endOffset" : 136
    }, {
      "referenceID" : 8,
      "context" : "For this reason a modification of the original CP approach, called Inductive Conformal Prediction (ICP), was proposed by Papadopoulos et al. (2002a) for regression and by Papadopoulos et al.",
      "startOffset" : 121,
      "endOffset" : 149
    }, {
      "referenceID" : 8,
      "context" : "For this reason a modification of the original CP approach, called Inductive Conformal Prediction (ICP), was proposed by Papadopoulos et al. (2002a) for regression and by Papadopoulos et al. (2002b) for classification.",
      "startOffset" : 121,
      "endOffset" : 199
    }, {
      "referenceID" : 8,
      "context" : "For this reason a modification of the original CP approach, called Inductive Conformal Prediction (ICP), was proposed by Papadopoulos et al. (2002a) for regression and by Papadopoulos et al. (2002b) for classification. As suggested by its name, ICP replaces the transductive inference followed in the original approach with inductive inference. Consequently, ICPs are almost as computationally efficient as their underlying algorithms. This is achieved at the cost of some loss in the quality of the produced confidence measures, but this loss is negligible, especially when the data set in question is large, whereas the improvement in computational efficiency is significant. A computational complexity comparison between the original CP and ICP approaches was performed by Papadopoulos (2008). From now on, in order to differentiate clearly between the original CP and ICP approaches the former will be called Transductive Conformal Prediction (TCP).",
      "startOffset" : 121,
      "endOffset" : 796
    }, {
      "referenceID" : 8,
      "context" : "The first regression CPs were proposed by Nouretdinov et al. (2001a) following the TCP approach and by Papadopoulos et al.",
      "startOffset" : 42,
      "endOffset" : 69
    }, {
      "referenceID" : 8,
      "context" : "The first regression CPs were proposed by Nouretdinov et al. (2001a) following the TCP approach and by Papadopoulos et al. (2002a) following the ICP approach, both based on the Ridge Regression algorithm.",
      "startOffset" : 42,
      "endOffset" : 131
    }, {
      "referenceID" : 8,
      "context" : "The first regression CPs were proposed by Nouretdinov et al. (2001a) following the TCP approach and by Papadopoulos et al. (2002a) following the ICP approach, both based on the Ridge Regression algorithm. As opposed to the conventional point predictions, the output of regression CPs is a predictive region that satisfies a given confidence level. The typical nonconformity measure used so far in the case of regression is the absolute difference |yi− ŷi|, between the actual label yi of the example i and the predicted label ŷi of the underlying algorithm for that example, given the old examples as training set. Here we propose six extensions to this nonconformity measure for k -Nearest Neighbours Regression and develop the corresponding Inductive and Transductive CPs; unfortunately although all six new measures can be used with the ICP approach, only two of them can be used with TCP. Our definitions normalize the standard measure based on the expected accuracy of the underlying algorithm for each example, which makes the width of the resulting predictive regions vary accordingly. As a result, the predictive regions produced by our measures are in general much tighter than those produced by the standard regression measure. This paper extends our previous work (Papadopoulos, Gammerman, & Vovk, 2008) where the k -Nearest Neighbours Regression TCP was developed using two normalized nonconformity measures. It is also worth mentioning that one other such nonconformity measure definition was presented by Papadopoulos et al. (2002a) for the Ridge Regression ICP.",
      "startOffset" : 42,
      "endOffset" : 1547
    }, {
      "referenceID" : 24,
      "context" : "In this section we briefly describe the idea behind Conformal Prediction; for a more detailed description the interested reader is referred to the book by Vovk et al. (2005). We are given a training set {z1, .",
      "startOffset" : 155,
      "endOffset" : 174
    }, {
      "referenceID" : 8,
      "context" : "a proof was given by Nouretdinov et al. (2001b). As a result, if the p-value of a given label is below some very low threshold, say 0.",
      "startOffset" : 21,
      "endOffset" : 48
    }, {
      "referenceID" : 8,
      "context" : "Following Nouretdinov et al. (2001a) and Vovk et al.",
      "startOffset" : 10,
      "endOffset" : 37
    }, {
      "referenceID" : 8,
      "context" : "Following Nouretdinov et al. (2001a) and Vovk et al. (2005) we express the nonconformity score αi of each example i = 1, .",
      "startOffset" : 10,
      "endOffset" : 60
    }, {
      "referenceID" : 11,
      "context" : "We could use di as a measure of accuracy, in fact it was used successfully in our previous work (Papadopoulos et al., 2008).",
      "startOffset" : 96,
      "endOffset" : 123
    }, {
      "referenceID" : 18,
      "context" : "Our methods were tested on six benchmark data sets from the UCI (Frank & Asuncion, 2010) and DELVE (Rasmussen et al., 1996) repositories:",
      "startOffset" : 99,
      "endOffset" : 123
    }, {
      "referenceID" : 19,
      "context" : "All hyperparameters were adapted by maximizing marginal likelihood on each training set as suggested by Rasmussen and Williams (2006); the adaptation of hyperparameters using leave-one-out cross-validation produces more or less the same results.",
      "startOffset" : 104,
      "endOffset" : 134
    } ],
    "year" : 2011,
    "abstractText" : "In this paper we apply Conformal Prediction (CP) to the k -Nearest Neighbours Regression (k -NNR) algorithm and propose ways of extending the typical nonconformity measure used for regression so far. Unlike traditional regression methods which produce point predictions, Conformal Predictors output predictive regions that satisfy a given confidence level. The regions produced by any Conformal Predictor are automatically valid, however their tightness and therefore usefulness depends on the nonconformity measure used by each CP. In effect a nonconformity measure evaluates how strange a given example is compared to a set of other examples based on some traditional machine learning algorithm. We define six novel nonconformity measures based on the k -Nearest Neighbours Regression algorithm and develop the corresponding CPs following both the original (transductive) and the inductive CP approaches. A comparison of the predictive regions produced by our measures with those of the typical regression measure suggests that a major improvement in terms of predictive region tightness is achieved by the new measures.",
    "creator" : "TeX"
  }
}