{
  "name" : "1207.4747.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Block-Coordinate Frank-Wolfe Optimization for Structural SVMs",
    "authors" : [ "Simon Lacoste-Julien", "Martin Jaggi", "Mark Schmidt" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Binary SVMs are amongst the most popular classification methods, and this has motivated substantial interest in optimization solvers that are tailored to their specific problem structure. However, despite their wider applicability, there has been much less work on solving the optimization problem associated with structural SVMs, which are the generalization of SVMs to structured outputs like graphs and other combinatorial objects (Taskar et al., 2003; Tsochantaridis et al., 2005). This seems to be due to the difficulty of dealing with the exponential number of constraints in the primal problem, or the exponential number of variables in the dual problem. Indeed, because they achieve an Õ(1/ε) convergence rate while only requiring a single\nProceedings of the 30 th International Conference on Machine Learning, Atlanta, Georgia, USA, 2013. JMLR: W&CP volume 28. Copyright 2013 by the author(s).\ncall to the so-called maximization oracle on each iteration, basic stochastic subgradient methods are still widely used for training structural SVMs (Ratliff et al., 2007; Shalev-Shwartz et al., 2010a). However, these methods are often frustrating to use for practitioners, because their performance is very sensitive to the sequence of step sizes, and because it is difficult to decide when to terminate the iterations.\nTo solve the dual structural SVM problem, in this paper we consider the Frank-Wolfe (1956) algorithm, which has seen a recent surge of interest in machine learning and signal processing (Mangasarian, 1995; Clarkson, 2010; Jaggi, 2011; 2013; Bach et al., 2012), including in the context of binary SVMs (Gärtner & Jaggi, 2009; Ouyang & Gray, 2010). A key advantage of this algorithm is that the iterates are sparse, and we show that this allows us to efficiently apply it to the dual structural SVM objective even though there are an exponential number of variables. A second key advantage of this algorithm is that the iterations only require optimizing linear functions over the constrained domain, and we show that this is equivalent to the maximization oracle used by subgradient and cutting-plane methods (Joachims et al., 2009; Teo et al., 2010). Thus, the Frank-Wolfe algorithm has the same wide applicability as subgradient methods, and can be applied to problems such as low-treewidth graphical models (Taskar et al., 2003), graph matchings (Caetano et al., 2009), and associative Markov networks (Taskar, 2004). In contrast, other approaches must use more expensive (and potentially intractable) oracles such as computing marginals over labels (Collins et al., 2008; Zhang et al., 2011) or doing a Bregman projection onto the space of structures (Taskar et al., 2006). Interestingly, for structural SVMs we also show that existing batch subgradient and cutting-plane methods are special cases of Frank-Wolfe algorithms, and this leads to stronger and simpler O(1/ε) convergence rate guarantees for these existing algorithms. ar X iv :1 20 7. 47 47 v4 [ cs .L\nG ]\n1 4\nJa n\n20 13\nAs in other batch structural SVM solvers like cuttingplane methods (Joachims et al., 2009; Teo et al., 2010) and the excessive gap technique (Zhang et al., 2011) (see Table 1 at the end for an overview), each FrankWolfe iteration unfortunately requires calling the appropriate oracle once for all training examples, unlike the single oracle call needed by stochastic subgradient methods. This can be prohibitive for data sets with a large number of training examples. To reduce this cost, we propose a novel randomized block-coordinate version of the Frank-Wolfe algorithm for problems with block-separable constraints. We show that this algorithm still achieves the O(1/ε) convergence rate of the full Frank-Wolfe algorithm, and in the context of structural SVMs, it only requires a single call to the maximization oracle. Although the stochastic subgradient and the novel block-coordinate Frank-Wolfe algorithms have a similar iteration cost and theoretical convergence rate for solving the structural SVM problem, the new algorithm has several important advantages for practitioners:\n• The optimal step-size can be efficiently computed in closed-form, hence no step-size needs to be selected. • The algorithm yields a duality gap guarantee, and (at the cost of computing the primal objective) we can compute the duality gap as a proper stopping criterion. • The convergence rate holds even when using approximate maximization oracles.\nFurther, our experimental results show that the optimal step-size leads to a significant advantage during the first few passes through the data, and a systematic (but smaller) advantage in later passes."
    }, {
      "heading" : "2. Structural Support Vector Machines",
      "text" : "We first briefly review the standard convex optimization setup for structural SVMs (Taskar et al., 2003; Tsochantaridis et al., 2005). In structured prediction, the goal is to predict a structured object y ∈ Y(x) (such as a sequence of tags) for a given input x ∈ X . In the standard approach, a structured feature map φ : X × Y → Rd encodes the relevant information for input/output pairs, and a linear classifier with parameter w is defined by hw(x) = argmaxy∈Y(x)〈w,φ(x,y)〉. Given a labeled training set D = {(xi,yi)}ni=1, w is estimated by solving\nmin w, ξ\nλ 2 ‖w‖2 + 1 n\nn∑\ni=1\nξi (1)\ns.t. 〈w,ψi(y)〉 ≥ L(yi,y)− ξi ∀i, ∀y ∈ =:Yi︷ ︸︸ ︷ Y(xi),\nwhere ψi(y) := φ(xi,yi) − φ(xi,y), and Li(y) := L(yi,y) denotes the task-dependent structured error of predicting output y instead of the observed output yi (typically a Hamming distance between the two labels). The slack variable ξi measures the surrogate loss for the i-th datapoint and λ is the regularization parameter. The convex problem (1) is what Joachims et al. (2009, Optimization Problem 2) call the n-slack structural SVM with margin-rescaling. A variant with slack-rescaling was proposed by Tsochantaridis et al. (2005), which is equivalent to our setting if we replace all vectors ψi(y) by Li(y)ψi(y).\nLoss-Augmented Decoding. Unfortunately, the above problem can have an exponential number of constraints due to the combinatorial nature of Y. We can replace the ∑ i |Yi| linear constraints with n piecewiselinear ones by defining the structured hinge-loss:\n‘max oracle’ H̃i(w) := max y∈Yi Li(y)− 〈w,ψi(y)〉︸ ︷︷ ︸ =:Hi(y;w) . (2)\nThe constraints in (1) can thus be replaced with the non-linear ones ξi ≥ H̃i(w). The computation of the structured hinge-loss for each i amounts to finding the most ‘violating’ output y for a given input xi, a task which can be carried out efficiently in many structured prediction settings (see the introduction). This problem is called the loss-augmented decoding subproblem. In this paper, we only assume access to an efficient solver for this subproblem, and we call such a solver a maximization oracle. The equivalent non-smooth unconstrained formulation of (1) is:\nmin w\nλ 2 ‖w‖2 + 1 n\nn∑\ni=1\nH̃i(w). (3)\nHaving a maximization oracle allows us to apply subgradient methods to this problem (Ratliff et al., 2007), as a subgradient of H̃i(w) with respect to w is −ψi(y∗i ), where y∗i is any maximizer of the lossaugmented decoding subproblem (2).\nThe Dual. The Lagrange dual of the above n-slackformulation (1) has m := ∑ i |Yi| variables or potential ‘support vectors’. Writing αi(y) for the dual variable associated with the training example i and potential output y ∈ Yi, the dual problem is given by\nmin α∈Rm α≥0\nf(α) := λ\n2\n∥∥Aα ∥∥2 − bTα (4)\ns.t. ∑ y∈Yi αi(y) = 1 ∀i ∈ [n] ,\nwhere the matrix A ∈ Rd×m consists of the m columns A := { 1 λnψi(y) ∈ Rd ∣∣ i ∈ [n],y ∈ Yi } , and the vector\nb ∈ Rm is given by b := (\n1 nLi(y) ) i∈[n],y∈Yi . Given a\ndual variable vector α, we can use the Karush-KuhnTucker optimality conditions to obtain the corresponding primal variables w = Aα = ∑ i,y∈Yi αi(y) ψi(y) λn , see Appendix E. The gradient of f then takes the simple form ∇f(α) = λATAα − b = λATw − b; its (i,y)-th component is − 1nHi(y;w), cf. (2). Finally, note that the domain M ⊂ Rm of (4) is the product of n probability simplices, M := ∆|Y1| × . . .×∆|Yn|."
    }, {
      "heading" : "3. The Frank-Wolfe Algorithm",
      "text" : "We consider the convex optimization problem minα∈M f(α), where the convex feasible set M is compact and the convex objective f is continuously differentiable. The Frank-Wolfe algorithm (1956) (shown in Algorithm 1) is an iterative optimization algorithm for such problems that only requires optimizing linear functions over M, and thus has wider applicability than projected gradient algorithms, which require optimizing a quadratic function overM. At every iteration, a feasible search corner s is first found by minimizing over M the linearization of f at the current iterate α (see picture in inset).\n↵\nf(↵)\nM\nf\ns\ng(↵) f(↵\n) + ⌦ s 0 ↵,\nrf(↵ ) ↵ The next iterate is then obtained as a convex combination of s and the previous iterate, with step-size γ. These simple updates yield two interesting properties. First, every iterate α(k) can be written as a convex combination of the starting point α(0) and the search corners s found previously. The parameter α(k) thus has a sparse representation, which makes the algorithm suitable even for cases where the dimensionality of α is exponential. Second, since f is convex, the minimum of the linearization of f over M immediately gives a lower bound on the value of the yet unknown optimal solution f(α∗). Every step of the algorithm thus computes for free the following ‘linearization duality gap’ defined for any feasible point α ∈ M (which is in fact a special case of the Fenchel duality gap as\nAlgorithm 1 Frank-Wolfe on a Compact Domain\nLet α(0) ∈M for k = 0 . . .K do\nCompute s := argmin s′∈M\n〈 s′,∇f(α(k)) 〉\nLet γ := 2k+2 , or optimize γ by line-search Update α(k+1) := (1− γ)α(k) + γs\nexplained in Appendix D):\ng(α) := max s′∈M\n〈α− s′,∇f(α)〉 = 〈α− s,∇f(α)〉. (5)\nAs g(α) ≥ f(α) − f(α∗) by the above argument, s thus readily gives at each iteration the current duality gap as a certificate for the current approximation quality (Jaggi, 2011; 2013), allowing us to monitor the convergence, and more importantly to choose the theoretically sound stopping criterion g(α(k)) ≤ ε. In terms of convergence, it is known that after O(1/ε) iterations, Algorithm 1 obtains an ε-approximate solution (Frank & Wolfe, 1956; Dunn & Harshbarger, 1978) as well as a guaranteed ε-small duality gap (Clarkson, 2010; Jaggi, 2013), along with a certificate to (5). For the convergence results to hold, the internal linear subproblem does not need to be solved exactly, but only to some error. We review and generalize the convergence proof in Appendix C. The constant hidden in the O(1/ε) notation is the curvature constant Cf , an affine invariant quantity measuring the maximum deviation of f from its linear approximation over M (it yields a weaker form of Lipschitz assumption on the gradient, see e.g. Appendix A for a formal definition)."
    }, {
      "heading" : "4. Frank-Wolfe for Structural SVMs",
      "text" : "Note that classical algorithms like the projected gradient method cannot be tractably applied to the dual of the structural SVM problem (4), due to the large number of dual variables. In this section, we explain how the Frank-Wolfe method (Algorithm 1) can be efficiently applied to this dual problem, and discuss its relationship to other algorithms. The main insight here is to notice that the linear subproblem employed by Frank-Wolfe is actually directly equivalent to the loss-augmented decoding subproblem (2) for each datapoint, which can be solved efficiently (see Appendix B.1 for details). Recall that the optimization domain for the dual variables α is the product\nAlgorithm 2 Batch Primal-Dual Frank-Wolfe Algorithm for the Structural SVM\nLet w(0) := 0, `(0) := 0 for k = 0 . . .K do\nfor i = 1 . . . n do Solve y∗i := argmax\ny∈Yi Hi(y;w\n(k)) cf. (2)\nLet ws :=\nn∑\ni=1\n1 λnψi(y ∗ i ) and `s := 1 n n∑ i=1 Li(y ∗ i )\nLet γ := λ(w (k)−ws)Tw(k)−`(k)+`s\nλ‖w(k)−ws‖2 and clip to [0, 1]\nUpdate w(k+1) := (1− γ)w(k) + γws and `(k+1) := (1− γ)`(k) + γ `s\nof n simplices, M = ∆|Y1| × . . . × ∆|Yn|. Since each simplex consists of a potentially exponential number |Yi| of dual variables, we cannot maintain a dense vector α during the algorithm. However, as mentioned in Section 3, each iterate α(k) of the Frank-Wolfe algorithm is a sparse convex combination of the previously visited corners s and the starting point α(0), and so we only need to maintain the list of previously seen solutions to the loss-augmented decoding subproblems to keep track of the non-zero coordinates of α, avoiding the problem of its exponential size. Alternately, if we do not use kernels, we can avoid the quadratic explosion of the number of operations needed in the dual by not explicitly maintaining α(k), but instead maintaining the corresponding primal variable w(k)."
    }, {
      "heading" : "A Primal-Dual Frank-Wolfe Algorithm for the",
      "text" : "Structural SVM Dual. Applying Algorithm 1 with line search to the dual of the structural SVM (4), but only maintaining the corresponding primal primal iterates w(k) := Aα(k), we obtain Algorithm 2. Note that the Frank-Wolfe search corner s = (ey ∗ 1 , . . . , ey ∗ n), which is obtained by solving the loss-augmented subproblems, yields the update ws = As. We use the natural starting point α(0) := (ey1 , . . . , eyn) which yields w(0) = 0 as ψi(yi) = 0 ∀i.\nThe Duality Gap. The duality gap (5) for our structural SVM dual formulation (4) is given by\ng(α) := max s′∈M 〈α− s′,∇f(α)〉 = (α− s)T (λATAα− b) = λ(w −As)Tw − bTα+ bTs ,\nwhere s is an exact minimizer of the linearized problem given at the point α. This (Fenchel) duality gap turns out to be the same as the Lagrangian duality gap here (see Appendix B.2), and gives a direct handle on the suboptimality of w(k) for the primal problem (3). Using ws := As and `s := b\nTs, we observe that the gap is efficient to compute given the primal variables w := Aα and ` := bTα, which are maintained during the run of Algorithm 2. Therefore, we can use the duality gap g(α(k)) ≤ ε as a proper stopping criterion.\nImplementing the Line-Search. Because the objective of the structural SVM dual (4) is simply a quadratic function in α, the optimal stepsize for any given candidate search point s ∈ M can be obtained analytically. Namely, γLS := argminγ∈[0,1] f ( α+ γ ( s−α )) is obtained by setting the derivative of this univariate quadratic function in γ to zero, which here (before restricting to [0, 1]) gives γopt := 〈α−s,∇f(α)〉 λ‖A(α−s)‖2 = g(α) λ‖w−ws‖2 (used in Algorithms 2 and 4).\nConvergence Proof and Running Time. In the following, we write R for the maximal length of a difference feature vector, i.e. R :=maxi∈[n],y∈Yi‖ψi(y)‖2, and we write the maximum error as Lmax := maxi,y Li(y). By bounding the curvature constant Cf for the dual SVM objective (4), we can now directly apply the known convergence results for the standard Frank-Wolfe algorithm to obtain the following primaldual rate (proof in Appendix B.3):\nTheorem 1. Algorithm 2 obtains an ε-approximate solution to the structural SVM dual problem (4) and duality gap g(α(k)) ≤ ε after at most O ( R2\nλε\n) itera-\ntions, where each iteration costs n oracle calls.\nSince we have proved that the duality gap is smaller than ε, this implies that the original SVM primal objective (3) is actually solved to accuracy ε as well."
    }, {
      "heading" : "Relationship with the Batch Subgradient",
      "text" : "Method in the Primal. Surprisingly, the batch Frank-Wolfe method (Algorithm 2) is equivalent to the batch subgradient method in the primal, though Frank-Wolfe allows a more clever choice of step-size, since line-search can be used in the dual. To see the equivalence, notice that a subgradient of (3) is given by dsub = λw − 1n ∑ iψi(y ∗ i ) = λ(w − ws), where y∗i and ws are as defined in Algorithm 2. Hence, for a step-size of β, the subgradient method update becomes w(k+1) := w(k) − βdsub = w(k) − βλ(w(k) − ws) = (1 − βλ)w(k) + βλws. Comparing this with Algorithm 2, we see that each Frank-Wolfe step on the dual problem (4) with step-size γ is equivalent to a batch subgradient step in the primal with a step-size of β = γ/λ, and thus our convergence results also apply to it. This seems to generalize the equivalence between Frank-Wolfe and the subgradient method for a quadratic objective with identity Hessian as observed by Bach et al. (2012, Section 4.1)."
    }, {
      "heading" : "Relationship with Cutting Plane Algorithms.",
      "text" : "In each iteration, the cutting plane algorithm of Joachims et al. (2009) and the Frank-Wolfe method (Algorithm 2) solve the loss-augmented decoding problem for each datapoint, selecting the same new ‘active’ coordinates to add to the dual problem. The only difference is that instead of just moving towards the corner s, as in classical Frank-Wolfe, the cutting plane algorithm re-optimizes over all the previously added ‘active’ dual variables (this task is a quadratic program). This shows that the method is exactly equivalent to the ‘fully corrective’ variant of Frank-Wolfe, which in each iteration re-optimizes over all previously visited corners (Clarkson, 2010; Shalev-Shwartz et al., 2010b). Note that the convergence results for the ‘fully correc-\nAlgorithm 3 Block-Coordinate Frank-Wolfe Algorithm on Product Domain\nLet α(0) ∈M =M(1) × . . .×M(n) for k = 0 . . .K do\nPick i at random in {1, . . . , n} Find s(i) := argmin\ns′ (i) ∈M(i)\n〈 s′(i),∇(i)f(α(k)) 〉\nLet γ := 2nk+2n , or optimize γ by line-search Update α (k+1) (i) := α (k) (i) + γ ( s(i) −α(k)(i) )\ntive’ variant directly follow from the ones for FrankWolfe (by inclusion), thus our convergence results apply to the cutting plane algorithm of Joachims et al. (2009), significantly simplifying its analysis."
    }, {
      "heading" : "5. Faster Block-Coordinate Frank-Wolfe",
      "text" : "A major disadvantage of the standard Frank-Wolfe algorithm when applied to the structural SVM problem is that each iteration requires a full pass through the data, resulting in n calls to the maximization oracle. In this section, we present the main new contribution of the paper: a block-coordinate generalization of the Frank-Wolfe algorithm that maintains all appealing properties of Frank-Wolfe, but yields much cheaper iterations, requiring only one call to the maximization oracle in the context of structural SVMs. The new method is given in Algorithm 3, and applies to any constrained convex optimization problem of the form\nmin α∈M(1)×...×M(n) f(α) , (6)\nwhere the domain has the structure of a Cartesian product M = M(1) × . . . ×M(n) ⊆ Rm over n ≥ 1 blocks. The main idea of the method is to perform cheaper update steps that only affect a single variable block M(i), and not all of them simultaneously. This is motivated by coordinate descent methods, which have a very successful history when applied to large scale optimization. Here we assume that each factor M(i) ⊆ Rmi is convex and compact, with m = ∑n i=1mi. We will write α(i) ∈ Rmi for the i-th block of coordinates of a vector α ∈ Rm. In each step, Algorithm 3 picks one of the n blocks uniformly at random, and leaves all other blocks unchanged. If there is only one block (n = 1), then Algorithm 3 becomes the standard Frank-Wolfe Algorithm 1. The algorithm can be interpreted as a simplification of Nesterov’s ‘hugescale’ uniform coordinate descent method (Nesterov, 2012, Section 4). Here, instead of computing a projection operator on a block (which is intractable for structural SVMs), we only need to solve one linear subproblem in each iteration, which for structural SVMs is equivalent to a call to the maximization oracle.\nAlgorithm 4 Block-Coordinate Primal-Dual FrankWolfe Algorithm for the Structural SVM\nLet w(0) := wi (0) := w̄(0) := 0, `(0) := `i (0) := 0 for k = 0 . . .K do\nPick i at random in {1, . . . , n} Solve y∗i := argmax\ny∈Yi Hi(y;w\n(k)) cf. (2)\nLet ws := 1 λnψi(y ∗ i ) and `s := 1 n Li(y ∗ i ) Let γ := λ(w (k) i −ws)\nTw(k)−`(k)i +`s λ‖w(k)i −ws‖2 and clip to [0, 1]\nUpdate wi (k+1) := (1− γ)wi(k) + γws\nand `i (k+1) := (1− γ)`i(k) + γ `s\nUpdate w(k+1) := w(k) +wi (k+1) −wi(k)\nand `(k+1) := `(k) + `i (k+1) − `i(k)\n(Optionally: Update w̄(k+1) := k k+2 w̄(k) + 2 k+2 w(k+1))\nConvergence Results. The following main theorem shows that after O(1/ε) many iterations, Algorithm 3 obtains an ε-approximate solution to (6), and guaranteed ε-small duality gap (proof in Appendix C). Here the constant C⊗f := ∑n i=1 C (i) f is the sum of the (partial) curvature constants of f with respect to the individual domain block M(i). We discuss this Lipschitz assumption on the gradient in more details in Appendix A, where we compute the constant precisely for the structural SVM and obtain C⊗f = Cf/n, where Cf is the classical Frank-Wolfe curvature. Theorem 2. For each k ≥ 0, the iterate α(k) of Algorithm 3 (either using the predefined step-sizes, or using line-search) satisfies E [ f(α(k)) ] − f(α∗) ≤\n2n k+2n ( C⊗f + h0 ) , where α∗ ∈M is a solution to problem (6), h0 := f(α (0)) − f(α∗) is the initial error at the starting point of the algorithm, and the expectation is over the random choice of the block i in the steps of the algorithm.\nFurthermore, if Algorithm 3 is run for K ≥ 0 iterations, then it has an iterate α(k̂), 0 ≤ k̂ ≤ K, with duality gap bounded by E [ g(α(k̂)) ] ≤ 6nK+1 ( C⊗f + h0) .\nApplication to the Structural SVM. Algorithm 4 applies the block-coordinate Frank-Wolfe algorithm with line-search to the structural SVM dual problem (4), maintaining only the primal variables w. We see that Algorithm 4 is equivalent to Algorithm 3, by observing that the corresponding primal updates become ws = As[i] and `s = b Ts[i]. Here s[i] is the zero-padding of s(i) := e y∗i ∈ M(i) so that s[i] ∈ M. Note that Algorithm 4 has a primal parameter vector wi (= Aα[i]) for each datapoint i, but that this does not significantly increase the storage cost of the algorithm since each wi has a sparsity pattern that is the union of the corresponding ψi(y ∗ i ) vectors. If the feature vectors are not sparse, it might be more efficient\nto work directly in the dual instead (see the kernelized version below). The line-search is analogous to the batch Frank-Wolfe case discussed above, and formalized in Appendix B.4.\nBy applying Theorem 2 to the SVM case where C⊗f = Cf/n = 4R 2/λn (in the worst case), we get that the number of iterations needed for our new block-wise Algorithm 4 to obtain a specific accuracy ε is the same as for the batch version in Algorithm 2 (under the assumption that the initial error h0 is smaller than 4R2/λn), even though each iteration takes n times fewer oracle calls. If h0 > 4R\n2/λn, we can use the fact that Algorithm 4 is using line-search to get a weaker dependence on h0 in the rate (Theorem C.4). We summarize the overall rate as follows (proof in Appendix B.3): Theorem 3. If Lmax ≤ 4R 2 λn (so h0 ≤ 4R 2\nλn ), then Algorithm 4 obtains an ε-approximate solution to the structural SVM dual problem (4) and expected duality gap E[g(α(k))] ≤ ε after at most O ( R2\nλε\n) iterations, where\neach iteration costs a single oracle call.\nIf Lmax > 4R2\nλn , then it requires at most an additional\n(constant in ε) number of O ( n log ( λnLmax R2 )) steps to get the same error and duality gap guarantees.\nIn terms of ε, the O(1/ε) convergence rate above is similar to existing stochastic subgradient and cuttingplane methods. However, unlike stochastic subgradient methods, the block-coordinate Frank-Wolfe method allows us to compute the optimal step-size at each iteration (while for an additional pass through the data we can evaluate the duality gap (5) to allow us to decide when to terminate the algorithm in practice). Further, unlike cutting-plane methods which require n oracle calls per iteration, this rate is achieved ‘online’, using only a single oracle call per iteration.\nApproximate Subproblems and Decoding. Interestingly, we can show that all the convergence results presented in this paper also hold if only approximate minimizers of the linear subproblems are used instead of exact minimizers. If we are using an approximate oracle giving candidate directions s(i) in Algorithm 3 (or s in Algorithm 1) with a multiplicative accuracy ν ∈ (0, 1] (with respect to the the duality gap (5) on the current block), then the above convergence bounds from Theorem 2 still apply. The only change is that the convergence is slowed by a factor of 1/ν2. We prove this generalization in the Theorems of Appendix C. For structural SVMs, this significantly improves the applicability to large-scale problems, where exact decoding is often too costly but approximate loss-augmented decoding may be possible.\nKernelized Algorithms. Both Algorithms 2 and 4 can directly be used with kernels by maintaining the sparse dual variables α(k) instead of the primal variables w(k). In this case, the classifier is only given implicitly as a sparse combination of the corresponding kernel functions, i.e. w = Aα. Using our Algorithm 4, we obtain the currently best known bound on the number of support vectors, i.e. a guaranteed ε-approximation with only O(R 2\nλε ) support vectors. In comparison, the standard cutting plane method (Joachims et al., 2009) adds n support vectors ψi(y ∗ i ) at each iteration. More details on the kernelized variant of Algorithm 4 are discussed in Appendix B.5."
    }, {
      "heading" : "6. Experiments",
      "text" : "We compare our novel Frank-Wolfe approach to existing algorithms for training structural SVMs on the OCR dataset (n = 6251, d = 4028) from Taskar et al. (2003) and the CoNLL dataset (n = 8936, d = 1643026) from Sang & Buchholz (2000). Both datasets are sequence labeling tasks, where the loss-augmented decoding problem can be solved exactly by the Viterbi algorithm. Our third application is a word alignment problem between sentences in different languages in the setting of Taskar et al. (2006) (n = 5000, d = 82). Here, the structured labels are bipartite matchings, for which computing marginals over labels as required by the methods of Collins et al. (2008); Zhang et al. (2011) is intractable, but loss-augmented decoding can be done efficiently by solving a min-cost flow problem.\nWe compare Algorithms 2 and 4, the batch FrankWolfe method (FW )1 and our novel block-coordinate Frank-Wolfe method (BCFW ), to the cutting plane algorithm implemented in SVMstruct (Joachims et al., 2009) with its default options, the online exponentiated gradient (online-EG) method of Collins et al. (2008), and the stochastic subgradient method (SSG) with step-size chosen as in the ‘Pegasos’ version of Shalev-Shwartz et al. (2010a). We also include the weighted average w̄(k) := 2k(k+1) ∑k t=1 tw (t) of the iterates from SSG (called SSG-wavg) which was recently shown to converge at the faster rate of O(1/k) instead of O ((log k)/k) (Lacoste-Julien et al., 2012; Shamir & Zhang, 2013). Analogously, we average the iterates from BCFW the same way to obtain the BCFW-wavg method (implemented efficiently with the optional line in Algorithm 4), which also has a provable O(1/k) convergence rate (Theorem C.3). The performance of the different algorithms according to several criteria is visualized in Figure 1. The results are discussed\n1This is equivalent to the batch subgradient method with an adaptive step-size, as mentioned in Section 4.\nin the caption, while additional experiments can be found in Appendix F. In most of the experiments, the BCFW-wavg method dominates all competitors. The superiority is especially striking for the first few iterations, and when using a small regularization strength λ, which is often needed in practice. In term of test error, a peculiar observation is that the weighted average of the iterates seems to help both methods significantly: SSG-wavg sometimes slightly outperforms BCFW-wavg despite having the worst objective value amongst all methods. This phenomenon is worth further investigation."
    }, {
      "heading" : "7. Related Work",
      "text" : "There has been substantial work on dual coordinate descent for SVMs, including the original sequential minimal optimization (SMO) algorithm. The SMO algorithm was generalized to structural SVMs (Taskar, 2004, Chapter 6), but its convergence rate scales badly with the size of the output space: it was estimated as O (n|Y|/λε) in Zhang et al. (2011). Further, this method requires an expectation oracle to work with\nits factored dual parameterization. As in our algorithm, Rousu et al. (2006) propose updating one training example at a time, but using multiple Frank-Wolfe updates to optimize along the subspace. However, they do not obtain any rate guarantees and their algorithm is less general because it again requires an expectation oracle. In the degenerate binary SVM case, our block-coordinate Frank-Wolfe algorithm is actually equivalent to the method of Hsieh et al. (2008), where because each datapoint has a unique dual variable, exact coordinate optimization can be accomplished by the line-search step of our algorithm. Hsieh et al. (2008) show a local linear convergence rate in the dual, and our results complement theirs by providing a global primal convergence guarantee for their algorithm of O (1/ε). After our paper had appeared on arXiv, Shalev-Shwartz & Zhang (2012) have proposed a generalization of dual coordinate descent applicable to several regularized losses, including the structural SVM objective. Despite being motivated from a different perspective, a version of their algorithm (Option II of Figure 1) gives the exact same step-size and update direction as BCFW with line-search, and their Corol-\nlary 3 gives a similar convergence rate as our Theorem 3. Balamurugan et al. (2011) propose to approximately solve a quadratic problem on each example using SMO, but they do not provide any rate guarantees. The online-EG method implements a variant of dual coordinate descent, but it requires an expectation oracle and Collins et al. (2008) estimate its primal convergence at only O ( 1/ε2 ) .\nBesides coordinate descent methods, a variety of other algorithms have been proposed for structural SVMs. We summarize a few of the most popular in Table 1, with their convergence rates quoted in number of oracle calls to reach an accuracy of ε. However, we note that almost no guarantees are given for the optimization of structural SVMs with approximate oracles. A regret analysis in the context of online optimization was considered by Ratliff et al. (2007), but they do not analyze the effect of this on solving the optimization problem. The cutting plane algorithm of Tsochantaridis et al. (2005) was considered with approximate maximization by Finley & Joachims (2008), though the dependence of the running time on the the approximation error was left unclear. In contrast, we provide guarantees for batch subgradient, cutting plane, and block-coordinate Frank-Wolfe, for achieving an εapproximate solution as long as the error of the oracle is appropriately bounded."
    }, {
      "heading" : "8. Discussion",
      "text" : "This work proposes a novel randomized blockcoordinate generalization of the classic Frank-Wolfe algorithm for optimization with block-separable constraints. Despite its potentially much lower iteration cost, the new algorithm achieves a similar convergence\nrate in the duality gap as the full Frank-Wolfe method. For the dual structural SVM optimization problem, it leads to a simple online algorithm that yields a solution to an issue that is notoriously difficult to address for stochastic algorithms: no step-size sequence needs to be tuned since the optimal step-size can be efficiently computed in closed-form. Further, at the cost of an additional pass through the data (which could be done alongside a full Frank-Wolfe iteration), it allows us to compute a duality gap guarantee that can be used to decide when to terminate the algorithm. Our experiments indicate that empirically it converges faster than other stochastic algorithms for the structural SVM problem, especially in the realistic setting where only a few passes through the data are possible.\nAlthough our structural SVM experiments use an exact maximization oracle, the duality gap guarantees, the optimal step-size, and a computable bound on the duality gap are all still available when only an appropriate approximate maximization oracle is used. Finally, although the structural SVM problem is what motivated this work, we expect that the blockcoordinate Frank-Wolfe algorithm may be useful for other problems in machine learning where a complex objective with block-separable constraints arises.\nAcknowledgements. We thank Francis Bach, Bernd Gärtner and Ronny Luss for helpful discussions, and Robert Carnecky for the 3D illustration. MJ is supported by the ERC Project SIPA, and by the Swiss National Science Foundation. SLJ and MS are partly supported by the ERC (SIERRA-ERC-239993). SLJ is supported by a Research in Paris fellowship. MS is supported by a NSERC postdoctoral fellowship."
    }, {
      "heading" : "Bach, F., Lacoste-Julien, S., and Obozinski, G. On the",
      "text" : "equivalence between herding and conditional gradient algorithms. In ICML, 2012."
    }, {
      "heading" : "Balamurugan, P., Shevade, S., Sundararajan, S., and",
      "text" : "Keerthi, S. A sequential dual method for structural SVMs. In SDM, 2011."
    }, {
      "heading" : "Caetano, T.S., McAuley, J.J., Cheng, Li, Le, Q.V., and",
      "text" : "Smola, A.J. Learning graph matching. IEEE PAMI, 31 (6):1048–1058, 2009.\nClarkson, K. Coresets, sparse greedy approximation, and the Frank-Wolfe algorithm. ACM Transactions on Algorithms, 6(4):1–30, 2010."
    }, {
      "heading" : "Collins, M., Globerson, A., Koo, T., Carreras, X., and",
      "text" : "Bartlett, P. L. Exponentiated gradient algorithms for conditional random fields and max-margin Markov networks. JMLR, 9:1775–1822, 2008.\nDunn, J.C. and Harshbarger, S. Conditional gradient algorithms with open loop step size rules. Journal of Mathematical Analysis and Applications, 62(2):432–444, 1978."
    }, {
      "heading" : "Finley, T. and Joachims, T. Training structural SVMs",
      "text" : "when exact inference is intractable. In ICML, 2008.\nFrank, M. and Wolfe, P. An algorithm for quadratic programming. Naval Research Logistics Quarterly, 3:95– 110, 1956.\nGärtner, B. and Jaggi, M. Coresets for polytope distance. ACM Symposium on Computational Geometry, 2009.\nHsieh, C., Chang, K., Lin, C., Keerthi, S., and Sundararajan, S. A dual coordinate descent method for large-scale linear SVM. In ICML, pp. 408–415, 2008.\nJaggi, M. Sparse convex optimization methods for machine learning. PhD thesis, ETH Zürich, 2011."
    }, {
      "heading" : "Jaggi, M. Revisiting Frank-Wolfe: Projection-free sparse",
      "text" : "convex optimization. In ICML, 2013."
    }, {
      "heading" : "Joachims, T., Finley, T., and Yu, C. Cutting-plane training",
      "text" : "of structural SVMs. Machine Learn., 77(1):27–59, 2009."
    }, {
      "heading" : "Lacoste-Julien, S., Schmidt, M., and Bach, F. A simpler",
      "text" : "approach to obtaining an O(1/t) convergence rate for the projected stochastic subgradient method. Technical Report 1212.2002v2 [cs.LG], arXiv, December 2012.\nMangasarian, O.L. Machine learning via polyhedral concave minimization. Technical Report 95-20, University of Wisconsin, 1995.\nNesterov, Yurii. Efficiency of coordinate descent methods on huge-scale optimization problems. SIAM Journal on Optimization, 22(2):341–362, 2012.\nOuyang, H. and Gray, A. Fast stochastic Frank-Wolfe algorithms for nonlinear SVMs. SDM, 2010.\nRakhlin, A., Shamir, O., and Sridharan, K. Making gradient descent optimal for strongly convex stochastic optimization. In ICML, 2012."
    }, {
      "heading" : "Ratliff, N., Bagnell, J. A., and Zinkevich, M. (Online)",
      "text" : "subgradient methods for structured prediction. In AISTATS, 2007."
    }, {
      "heading" : "Rousu, J., Saunders, C., Szedmak, S., and Shawe-Taylor,",
      "text" : "J. Kernel-based learning of hierarchical multilabel classification models. JMLR, 2006."
    }, {
      "heading" : "Sang, E.F.T.K. and Buchholz, S. Introduction to the",
      "text" : "CoNLL-2000 shared task: Chunking, 2000."
    }, {
      "heading" : "Shalev-Shwartz, S. and Zhang, T. Proximal stochastic",
      "text" : "dual coordinate ascent. Technical Report 1211.2717v1 [stat.ML], arXiv, November 2012."
    }, {
      "heading" : "Shalev-Shwartz, S., Singer, Y., Srebro, N., and Cotter, A.",
      "text" : "Pegasos: primal estimated sub-gradient solver for SVM. Mathematical Programming, 127(1), 2010a.\nShalev-Shwartz, S., Srebro, N., and Zhang, T. Trading accuracy for sparsity in optimization problems with sparsity constraints. SIAM Journal on Optimization, 20: 2807–2832, 2010b.\nShamir, O. and Zhang, T. Stochastic gradient descent for non-smooth optimization: Convergence results and optimal averaging schemes. In ICML, 2013.\nTaskar, B. Learning structured prediction models: A large margin approach. PhD thesis, Stanford, 2004."
    }, {
      "heading" : "Taskar, B., Guestrin, C., and Koller, D. Max-margin",
      "text" : "Markov networks. In NIPS, 2003.\nTaskar, B., Lacoste-Julien, S., and Jordan, M. I. Structured prediction, dual extragradient and Bregman projections. JMLR, 7:1627–1653, 2006."
    }, {
      "heading" : "Teo, C.H., Vishwanathan, S.V.N., Smola, A.J., and Le,",
      "text" : "Q.V. Bundle methods for regularized risk minimization. JMLR, 11:311–365, 2010.\nTsochantaridis, I., Joachims, T., Hofmann, T., and Altun, Y. Large margin methods for structured and interdependent output variables. JMLR, 6:1453–1484, 2005.\nZhang, X., Saha, A., and Vishwanathan, S. V. N. Accelerated training of max-margin Markov networks with kernels. In ALT, pp. 292–307. Springer, 2011.\nSupplementary Material Block-Coordinate Frank-Wolfe Optimization for Structural SVMs\nOutline. In Appendix A, we discuss the curvature constants and compute them for the structural SVM problem. In Appendix B, we give additional details on applying the Frank-Wolfe algorithms to the structural SVM and provide proofs for Theorems 1 and 3. In the main Appendix C, we give a self-contained presentation and analysis of the new block-coordinate Frank-Wolfe method (Algorithm 3), and prove the main convergence Theorem 2. In Appendix D, the ‘linearization’-duality gap is interpreted in terms of Fenchel duality. For completeness, we include a short derivation of the dual problem to the structural SVM in Appendix E. Finally, we present in Appendix F additional experimental results as well as more detailed information about the implementation.\nA. The Curvature Constants Cf and C ⊗ f\nThe Curvature Constant Cf . The curvature constant Cf is given by the maximum relative deviation of the objective function f from its linear approximations, over the domainM (Clarkson, 2010; Jaggi, 2013). Formally,\nCf := sup x,s∈M, γ∈[0,1],\ny=x+γ(s−x)\n2\nγ2 (f(y)− f(x)− 〈y − x,∇f(x)〉) . (7)\nThe assumption of bounded Cf corresponds to a slightly weaker, affine invariant form of a smoothness assumption on f . It is known that Cf is upper bounded by the Lipschitz constant of the gradient ∇f times the squared diameter of M, for any arbitrary choice of a norm (Jaggi, 2013, Lemma 8); but it can also be much smaller (in particular, when the dimension of the affine hull of M is smaller than the ambient space), so it is a more fundamental quantity in the analysis of the Frank-Wolfe algorithm than the Lipschitz constant of the gradient. As pointed out by Jaggi (2013, Section 2.4), Cf is invariant under affine transformations, as is the Frank-Wolfe algorithm.\nThe Product Curvature Constant C⊗f . The curvature concept can be generalized to our setting of product domains M :=M(1) × . . .×M(n) as follows: over each individual coordinate block, the curvature is given by\nC (i) f := sup\nx∈M, s(i)∈M(i), γ∈[0,1], y=x+γ(s[i]−x[i])\n2 γ2 ( f(y)− f(x)− 〈y(i) − x(i),∇(i)f(x)〉 ) , (8)\nwhere the notation x[i] refers to the zero-padding of x(i) so that x[i] ∈M. By considering the Taylor expansion of f , it is not hard to see that also the ‘partial’ curvature C\n(i) f is upper bounded by the Lipschitz constant of the\npartial gradient ∇(i)f times the squared diameter of just one domain block M(i). See also the proof of Lemma A.2 below.\nWe define the global product curvature constant as the sum of these curvatures for each block, i.e.\nC⊗f :=\nn∑\ni=1\nC (i) f (9)\nObserve that for the classical Frank-Wolfe case when n = 1, we recover the original curvature constant."
    }, {
      "heading" : "Computing the Curvature Constant Cf in the SVM Case.",
      "text" : "Lemma A.1. For the dual structural SVM objective function (4) over the domain M := ∆|Y1| × . . . × ∆|Yn|, the curvature constant Cf , as defined in (7), is upper bounded by\nCf ≤ 4R2\nλ ,\nwhere R is the maximal length of a difference feature vector, i.e. R := max i∈[n],y∈Yi\n‖ψi(y)‖2 .\nProof of Lemma A.1. If the objective function is twice differentiable, we can plug-in the second degree Taylor expansion of f into the above definition (7) of the curvature, see e.g. (Jaggi, 2011, Inequality (2.12)) or (Clarkson, 2010, Section 4.1). In our case, the gradient at α is given by λATAα − b, so that the Hessian is λATA, being a constant matrix independent of α. This gives the following upper bound2 on Cf , which we can separate into two identical matrix-vector products with our matrix A:\nCf ≤ sup x,y∈M,\nz∈[x,y]⊆M\n(y − x)T∇2f(z)(y − x)\n= λ · sup x,y∈M (A(y − x))TA(y − x)\n= λ · sup v,w∈AM ‖v −w‖22 ≤ λ · sup v∈AM ‖2v‖22\nBy definition of our compact domain M, we have that each vector v ∈ AM is precisely the sum of n vectors, each of these being a convex combination of the feature vectors for the possible labelings for datapoint i.\nTherefore, the norm ‖v‖2 is upper bounded by n times the longest column of the matrix A, or more formally ‖v‖2 ≤ n 1λnR with R being the longest3 feature vector, i.e.\nR := max i∈[n],y∈Yi\n‖ψi(y)‖2 .\nAltogether, we have obtained that the curvature Cf is upper bounded by 4R2\nλ .\nWe also note that in the worst case, this bound is tight. For example, we can make Cf = 4R2\nλ by having for each datapoint i, two labelings which give opposite difference feature vectors ψi of the same maximal norm R."
    }, {
      "heading" : "Computing the Product Curvature Constant C⊗f in the SVM Case.",
      "text" : "Lemma A.2. For the dual structural SVM objective function (4) over the domain M := ∆|Y1| × . . . × ∆|Yn|, the total curvature constant C⊗f on the product domain M, as defined in (9), is upper bounded by\nC⊗f ≤ 4R2\nλn\nwhere R is the maximal length of a difference feature vector, i.e. R := max i∈[n],y∈Yi\n‖ψi(y)‖2 .\nProof. We follow the same lines as in the above proof of Lemma A.1, but now applying the same bound to the block-wise definition (8) of the curvature on the i-th block. Here, the change from x to y is now restricted to only affect the coordinates in the i-th block M(i). To simplify the notation, let M[i] be M(i) augmented with the zero domain for all the other blocks – i.e. the analog of x(i) ∈ M(i) is x[i] ∈ M[i]. x(i) is the i-th block of x whereas x[i] ∈ M is x(i) padded with zeros for all the other blocks. We thus require that y − x ∈ M[i] for a\n2Because our function is a quadratic function, this is actually an equality. 3This choice of the radius R then gives 1\nλn R = maxi∈[n],y∈Yi ∥∥ 1 λn ψi(y) ∥∥ 2 = maxi∈[n],y∈Yi ∥∥A(i,y)∥∥.\nvalid change from x to y. Again by the degree-two Taylor expansion, we obtain\nC (i) f ≤ sup\nx,y∈M, (y−x)∈M[i] z∈[x,y]⊆M\n(y − x)T∇2f(z)(y − x)\n= λ · sup x,y∈M\n(y−x)∈M[i]\n(A(y − x))TA(y − x)\n= λ · sup v,w∈AM(i) ‖v −w‖22 ≤ λ · sup v∈AM(i) ‖2v‖22\nIn other words, by definition of our compact domain M(i) = ∆|Yi|, we have that each vector v ∈ AM(i) is a convex combination of the feature vectors corresponding to the possible labelings for datapoint i. Therefore, the norm ‖v‖2 is again upper bounded by the longest column of the matrix A, which means ‖v‖2 ≤ 1λnR with R := maxi∈[n],y∈Yi ‖ψi(y)‖2. Summing up over the n blocks M(i), we obtain that the product curvature C⊗f is upper bounded by 4R 2\nλn .\nFor the same argument as at the end of the proof for Lemma A.1, this bound is actually tight in the worst case."
    }, {
      "heading" : "B. More Details on the Algorithms for Structural SVMs",
      "text" : ""
    }, {
      "heading" : "B.1. Equivalence of an Exact Frank-Wolfe Step and Loss-Augmented Decoding",
      "text" : "To see that the proposed Algorithm 2 indeed exactly corresponds to the standard Frank-Wolfe Algorithm 1 applied to the SVM dual problem (4), we verify that the search direction s giving the update ws = As is in fact an exact Frank-Wolfe step, which can be seen as follows:\nLemma B.1. The sparse vector s ∈ Rn constructed in the inner for-loop of Algorithm 2 is an exact solution to s = argmins′∈M 〈 s′,∇f(α(k)) 〉 for optimization problem (4).\nProof. Over the product domainM = ∆|Y1|× . . .×∆|Yn|, the minimization mins′∈M〈s′,∇f(α)〉 decomposes as∑ i minsi∈∆|Yi|〈si,∇if(α)〉. The minimization of a linear function over the simplex reduces to a search over its corners – in this case, it amounts for each i to find the minimal component of −Hi(y;w) over y ∈ Yi, i.e. solving the loss-augmented decoding problem as used in Algorithm 2 to construct the domain vertex s. To see this, note that for our choice of primal variables w = Aα, the gradient of the dual objective, ∇f(α) = λATAα− b, writes as λATw− b. This vector is precisely the loss-augmented decoding function − 1nHi(y;w), for i ∈ [n], y ∈ Yi, as defined in (2)."
    }, {
      "heading" : "B.2. Relation between the Lagrange Duality Gap and the ‘Linearization’ Gap for the Structural SVM",
      "text" : "We show here that the simple ‘linearization’ gap (5), evaluated on the structural SVM dual problem (4) is actually equivalent to the standard Lagrangian duality gap for the structural SVM primal objective (1) (these two duality gaps are not the same in general4). This is important for the duality gap convergence rate results of our Frank-Wolfe algorithms to be transferable as primal convergence rates on the original structural SVM objective (3), which is the one with statistical meaning (for example with generalization error bounds as given in Taskar et al. (2003)).\nProof. So consider the difference of our objective at w := Aα in the primal problem (3), and the dual objective\n4For example, the two gaps are different when evaluated on the dual of the conditional random field objective (see, for example, Collins et al. (2008) for the formulation), which does not have a Lipschitz continuous gradient.\nat α in problem (4) (in the maximization version). This difference is\ngLagrange(w,α) = λ\n2 wTw +\n1\nn\nn∑\ni=1\nH̃i(w)− ( bTα− λ\n2 wTw\n)\n= λwTw − bTα+ 1 n\nn∑\ni=1\nmax y∈Yi Hi(y;w) .\nNow recall that by the definition of A and b, we have that 1nHi(y;w) = (b− λATw)(i,y) = (−∇f(α))(i,y). By summing up over all points and re-using a similar argument as in Lemma B.1 above, we get that\n1\nn\nn∑\ni=1\nmax y∈Yi Hi(y;w) =\nn∑\ni=1\nmax y∈Yi (−∇f(α))(i,y) = max s′∈M 〈s′,−∇f(α)〉 ,\ngLagrange(w,α) = (λw TA− bT )α+ 1\nn\nn∑\ni=1\nmax y∈Yi Hi(y;w)\n= 〈∇f(α),α〉+ max s′∈M 〈−s′,∇f(α)〉 = 〈α− s,∇f(α)〉 = g(α) ,\nas defined in (5)."
    }, {
      "heading" : "B.3. Convergence Analysis",
      "text" : ""
    }, {
      "heading" : "B.3.1. Convergence of the Batch Frank-Wolfe Algorithm 2 on the Structural SVM Dual",
      "text" : "Theorem’ 1. Algorithm 2 obtains an ε-approximate solution to the structural SVM dual problem (4) and duality gap g(α(k)) ≤ ε after at most O ( R2\nλε\n) iterations, where each iteration costs n oracle calls.\nProof. We apply the known convergence results for the standard Frank-Wolfe Algorithm 1, as given e.g. in (Frank & Wolfe, 1956; Dunn & Harshbarger, 1978; Jaggi, 2013), or as given in the paragraph just after the proof of Theorem C.1: For each k ≥ 1, the iterate α(k) of Algorithm 1 (either using the predefined step-sizes, or using line-search) satisfies E[f(α(k))]− f(α∗) ≤ 2Cfk+2 , where α∗ ∈M is an optimal solution to problem (4).\nFurthermore, if Algorithm 1 is run for K ≥ 1 iterations, then it has an iterate α(k̂), 1 ≤ k̂ ≤ K, with duality gap bounded by E[g(α(k̂))] ≤ 6CfK+1 . This was shown e.g. in (Jaggi, 2013) with slightly different constants, or also in our analysis presented below (see the paragraph after the generalized analysis provided in Theorem C.3, when the number of blocks n is set to one).\nNow for the SVM problem and the equivalent Algorithm 2, the claim follows from the curvature bound Cf ≤ 4R 2 λ for the dual structural SVM objective function (4) over the domain M := ∆|Y1| × . . . ×∆|Yn|, as given in the above Lemma A.1."
    }, {
      "heading" : "B.3.2. Convergence of the Block-Coordinate Frank-Wolfe Algorithm 4 on the Structural SVM Dual",
      "text" : "Theorem’ 3. If Lmax ≤ 4R 2 λn (so h0 ≤ 4R 2 λn ), then Algorithm 4 obtains an ε-approximate solution to the structural\nSVM dual problem (4) and expected duality gap E[g(α(k))] ≤ ε after at most O ( R2\nλε\n) iterations, where each\niteration costs a single oracle call.\nIf Lmax > 4R2 λn , then it requires at most an additional (constant in ε) number of O ( n log ( λnLmax R2 )) steps to get the same error and duality gap guarantees, whereas the predefined step-size variant will require an additional O ( nLmax ε ) steps.\nProof. Writing h0 = f(α (0))− f(α∗) for the error at the starting point used by the algorithm, the convergence Theorem 2 states that if k ≥ 0 and k ≥ 2nε (C⊗f + h0), then the expected error is E[f(α(k))] − f(α∗) ≤ ε and\nanalogously for the expected duality gap. The result then follows by plugging in the curvature bound C⊗f ≤ 4R 2 λn for the dual structural SVM objective function (4) over the domain M := ∆|Y1| × . . . × ∆|Yn|, as detailed in Lemma A.2 (notice that it is n times smaller than the curvature Cf needed for the batch algorithm) and then bounding h0. To bound h0, we observe that by the choice of the starting point α (0) using only the observed labels, the initial error is bounded as h0 ≤ g(α(0)) = bTs = 1n ∑n i=1 maxy∈Yi Li(y) ≤ Lmax. Thus, if Lmax ≤ 4R 2 λn , then we have C⊗f + h0 ≤ 8R 2 λn , which proves the first part of the theorem.\nIn the case Lmax > 4R2 λn , then the predefined step-size variant will require an additional 2nh0 ε ≤ 2nLmaxε steps as we couldn’t use the fact that h0 ≤ C⊗f . For the line-search variant, on the other hand, we can use the improved convergence Theorem C.4, which shows that the algorithm require at most k0 ≤ n log(h0/C⊗f ) steps to reach the condition h0 ≤ C⊗f ; once this condition is satisfied, we can simply re-use Theorem 2 with k redefined as k−k0 to get the final convergence rates. We also point out that the statement of Theorem C.4 stays valid by replacing C⊗f with any C⊗f ′ ≥ C⊗f in it. So plugging in C⊗f ′ = R 2\nλn and the bound h0 ≤ Lmax in the k0 quantity gives back the number of additional steps mentioned in the second part of the theorem statement an ε-approximate solution. A similar argument can be made for the expected duality gap by using the improved convergence Theorem C.5, which simply adds the requirement K ≥ 5k0.\nWe note that the condition Lmax ≤ 4R 2\nλn is not necessarily too restrictive in the case of the structural SVM setup. In particular, the typical range of λ which is needed for a problem is around O(1/n) – and so the condition becomes Lmax ≤ 4R2 which is typically satisfied when the loss function is normalized.\nB.4. Implementation\nWe comment on three practical implementation aspects of Algorithm 4 on large structural SVM problems:\nMemory. For each datapoint i, our Algorithm 4 stores an additional vector wi ∈ Rd holding the contribution of its corresponding dual variables α(i) to the primal vector w = Aα, i.e. wi = Aα[i], where α[i] is α(i) padded with zeros so that α[i] ∈ Rm and α = ∑ iα[i]. This means the algorithm needs more memory than the direct (or batch) Frank-Wolfe structural SVM Algorithm 2, but the additional memory can sometimes be bounded by a constant times the size of the input data itself. In particular, in the case that the feature vectors ψi(y) are sparse, we can sometimes get the same improvement in memory requirements for wi, since for fixed i, all vectors ψi(y) usually have the same sparsity pattern. On the other hand, if the feature vectors are not sparse, it might be more efficient to only work with the dual variables instead of the primal variables (see the kernelized version in Appendix B.5 for more details).\nDuality Gap as a Stopping Criterion. Analogous as in the ‘classical Frank-Wolfe’ structural SVM Algorithm 2 explained in Section 4, we would again like to use the duality gap g(α(k)) ≤ ε as the stopping criterion for the faster Algorithm 4. Unfortunately, since now in every step we only update a single one of the many blocks, such a single direction s(i) will only determine the partial gap g (i)(α(k)) in the i-th block, but not the full information needed to know the total gap g(α(k)). Instead, to compute the total gap, a single complete (batch) pass through all datapoints as in Algorithm 2 is necessary, to obtain a full linear minimizer s ∈M. For efficiency reason, we could therefore compute the duality gap every say Nn iterations for some constant N > 1. Then stopping as soon as g(α(k)) = g(w(k), `(k),ws, `s) ≤ ε will not affect our convergence results.\nLine-Search. To compute the line-search step-size for Frank-Wolfe on the structural SVM, we recall that the analytic formula was given by γopt := 〈α−s,∇f(α)〉 λ‖A(α−s)‖2 , and finally taking γLS := max {0,min {1, γopt}}. This is valid for any s ∈ M. For the block-coordinate Frank-Wolfe Algorithm 4, s is equal to α for all blocks, except for the i-th block – this means that α − s = α[i] − s[i], i.e. is zero everywhere except on the i-th block. By recalling that wi = Aα[i] is the individual contribution to w from α(i) which is stored during the algorithm, we see that the denominator thus becomes λ ‖A(α− s)‖2 = λ ‖wi − ws‖2. The numerator is 〈α− s,∇f(α)〉 = (α− s)T (λATAα− b) = λ(wi − ws)Tw − `i + `s, where as before `i = bTα[i] is maintained during Algorithm 4 and so the line-search step-size can be computed efficiently. We mention in passing that when s(i) is the exact minimizer of the linear subproblem on M(i), then the numerator is actually a duality\ngap component g(i)(α) as defined in (16) – the total duality gap then is g(α) = ∑ i g\n(i)(α) which can only be computed if we do a batch pass over all the datapoints, as explained in the previous paragraph."
    }, {
      "heading" : "B.5. More details on the Kernelized Algorithm",
      "text" : "Both Algorithms 2 and 4 can be used with kernels by explicitly maintaining the sparse dual variables α(k) instead of the primal variables w(k). In this case, the classifier is only given implicitly as a sparse combination of the corresponding kernel functions, i.e. w = Aα, where ψi(y) = k(xi,yi; ·, ·) − k(xi,y; ·, ·) for a structured kernel k : (X × Y)× (X × Y)→ R. Note that the number of non-zero dual variables is upper-bounded by the number of iterations, and so the time to take dot products grows quadratically in the number of iterations.\nAlgorithm B.1 Kernelized Dual Block-Coordinate Frank-Wolfe for Structural SVM\nLet α(0) := (ey1 , . . . , eyn) ∈M = ∆|Y1| × . . .×∆|Yn| and ᾱ(0) = α(0) for k = 0 . . .K do\nPick i uniformly at random in {1, . . . , n} Solve y∗i := argmax\ny∈Yi Hi(y;Aα\n(k)) (solve the loss-augmented decoding problem (2))\ns(i) := e y∗i ∈M(i) (having only a single non-zero entry) Let γ := 2nk+2n , or optimize γ by line-search Update α (k+1) (i) := (1− γ)α (k) (i) + γs(i) (Optionally: Update ᾱ(k+1) := k k+2 ᾱ(k) + 2 k+2 α(k+1)) (maintain a weighted average of the iterates)\nTo compute the line-search step-size, we simply re-use the same formula as in Algorithm 4, but reconstructing (implicitly) on the fly the missing quantities such as `i = b Tα[i], wi = Aα[i] and w (k) = Aα(k), and reinterpreting dot products such as wTi w (k) as the suitable sum of kernel evaluations (which has O(k2/n) terms, where k is the number of iterations since the beginning)."
    }, {
      "heading" : "C. Analysis of the Block-Coordinate Frank-Wolfe Algorithm 3",
      "text" : "This section gives a self-contained presentation and analysis of the new block-coordinate Frank-Wolfe optimization Algorithm 3. The main goal is to prove the convergence Theorem 2, which here is split into two parts, the primal convergence rate in Theorem C.1, and the primal-dual convergence rate in Theorem C.3. Finally, we will present a faster convergence result for the line-search variant in Theorem C.4 and Theorem C.5, which we have used in the convergence for the structural SVM case as presented above in Theorem 3.\nCoordinate Descent Methods. Despite their simplicity and very early appearance in the literature, surprisingly few results were known on the convergence (and convergence rates in particular) of coordinate descent type methods. Recently, the interest in these methods has grown again due to their good scalability to very large scale problems as e.g. in machine learning, and also sparked new theoretical results such as (Nesterov, 2012).\nConstrained Convex Optimization over Product Domains. We consider the general constrained convex optimization problem\nmin x∈M f(x) (10)\nover a Cartesian product domain M =M(1) × . . .×M(n) ⊆ Rm, where each factor M(i) ⊆ Rmi is convex and compact, and ∑n i=1mi = m. We will write x(i) ∈ Rmi for the i-th block of coordinates of a vector x ∈ Rm, and x[i] for the padding of x(i) with zeros so that x[i] ∈ Rm.\nNesterov’s ‘Huge Scale’ Coordinate Descent. If the objective function f is strongly smooth (i.e. has Lipschitz continuous partial gradients ∇(i)f(x) ∈ Rmi), then the following algorithm converges5 at a rate of 1k ,\n5 By additionally assuming strong convexity of f w.r.t. the `1-norm (global onM, not only on the individual factors), one can even get linear convergence rates, see again (Nesterov, 2012) and the follow-up paper (Richtárik & Takáč, 2011).\nor more precisely nk+n , as shown in (Nesterov, 2012, Section 4):\nAlgorithm C.1 Uniform Coordinate Descent Method, (Nesterov, 2012, Section 4)\nLet x(0) ∈M for k = 0 . . .∞ do\nPick i uniformly at random in {1, . . . , n} Compute s(i) := argmin\ns(i)∈M(i)\n〈 s(i),∇(i)f(x(k)) 〉 + Li2 ∥∥s(i) − x(i) ∥∥2\nUpdate x (k+1) (i) := x (k) (i) + ( s(i) − x(k)(i) ) (only affecting the i-th coordinate block)\nUsing Simpler Update Steps: Frank-Wolfe / Conditional Gradient Methods. In some large-scale applications, the above computation of the update direction s(i) can be problematic, e.g. if the Lipschitz constants Li are unknown, or —more importantly— if the domainsM(i) are such that the quadratic term makes the subproblem for s(i) hard to solve.\nThe structural SVM is a nice example where this makes a big difference. Here, each domain block M(i) is a simplex of exponentially many variables, but nevertheless the linear subproblem over one such factor (also known as loss-augmented decoding) is often relatively easy to solve.\nWe would therefore like to replace the above computation of s(i) by a simpler one, as proposed in the following algorithm variant:\nAlgorithm C.2 Cheaper Coordinate Descent: Block-Coordinate Frank-Wolfe Algorithm\nLet x(0) ∈M and x̄(0)w = x(0) for k = 0 . . .∞ do\nPick i uniformly at random in {1, . . . , n} Compute s(i) := argmin\ns(i)∈M(i)\n〈 s(i),∇(i)f(x(k)) 〉\n(or alternatively, find s(i) that solves this linear problem approximately,\neither up to an additive error (11) or up to a multiplicative error (12))\nLet γ := 2nk+2n , or perform line-search for the step-size: γ := argmin γ∈[0,1]\nf ( x(k) + γ ( s[i] − x(k)[i] )) Update x\n(k+1) (i) := x (k) (i) + γ ( s(i) − x(k)(i) ) (only affecting the i-th coordinate block)\n(Optionally: Update x̄ (k+1) w := k k+2 x̄ (k) w + 2 k+2 x(k+1)) (maintain a weighted average of the iterates)\nThis natural coordinate descent type optimization method picks a single one of the n blocks uniformly at random, and in each step leaves all other blocks unchanged.\nIf there is only one factor (n = 1), then Algorithm C.2 becomes the standard Frank-Wolfe (or conditional gradient) algorithm, which is known to converge at a rate of O(1/k) (Frank & Wolfe, 1956; Dunn & Harshbarger, 1978; Clarkson, 2010; Jaggi, 2013).\nUsing Approximate Linear Minimizers. If approximate linear minimizers are used internally in Algorithm C.2, then the necessary approximation quality for the candidate directions s(i) is determined as follows (in either additive or multiplicative quality):\nIn the additive case, we choose a fixed additive error parameter δ ≥ 0 such that the candidate direction s(i) satisfies 〈\ns(i),∇(i)f(x) 〉 ≤ min\ns′ (i) ∈M(i)\n〈 s′(i),∇(i)f(x) 〉 + 12δ γ̃k C (i) f , (11)\nwhere γ̃k := 2n k+2n comes from the default step-size and is used for the convergence results to come. Note that if line-search is used to determine a different step-size, the candidate direction is still defined with respect to the default γ̃k.\nIn the multiplicative case, we choose a fixed multiplicative error parameter 0 < ν ≤ 1 such that the candidate directions s(i) attain the current ‘duality gap’ on the i-th factor up to a multiplicative approximation error of ν, i.e. 〈\nx− s(i),∇(i)f(x) 〉 ≥ ν · max\ns′ (i) ∈M(i)\n〈 x− s′(i),∇(i)f(x) 〉 . (12)\nIf a multiplicative approximate internal oracle is used together with the predefined step-size instead of doing line-search, then the step-size in Algorithm C.2 needs to be increased to γk := 2n νk+2n instead of the original 2n k+2n .\nBoth types of errors can be combined together with the following property for the candidate direction s(i):\n〈 x− s(i),∇(i)f(x) 〉 ≥ ν · max\ns′ (i) ∈M(i)\n〈 x− s′(i),∇(i)f(x) 〉 − 12δ γ̃k C (i) f , (13)\nwhere γ̃k := 2n\nνk+2n .\nAveraging the Iterates. In the above Algorithm C.2 we have also added an optional last line which maintains the following weighted average x̄ (k) w which is defined for k ≥ 1 as\nx̄(k)w := 2\nk(k + 1)\nk∑\nt=1\ntx(t) , (14)\nand by convention we also define x̄ (0) w := x(0). As our convergence analysis will show, the weighted average of the iterates can yield more robust duality gap convergence guarantees when the duality gap function g is convex in x (see Theorem C.3) – this is for example the case for quadratic functions such as in the structural SVM objective (4). We will also consider in our proofs a scheme which averages the last (1−µ)-fraction of the iterates for some fixed 0 < µ < 1:\nx̄(k)µ := 1 k − dµke+ 1 k∑\nt=dµke\nx(t) . (15)\nThis is what Rakhlin et al. (2012) calls (1 − µ)-suffix averaging and it appeared in the context of getting a stochastic subgradient method with O(1/k) convergence rate for strongly convex functions instead of the standard O((log k)/k) rate that one can prove for the individual iterates x(k). The problem with (1− µ)-suffix averaging is that to implement it for a fixed µ (say µ = 0.5) without storing a fraction of all the iterates, one needs to know when they will stop the algorithm. An alternative mentioned in Rakhlin et al. (2012) is to maintain a uniform average over rounds of exponentially increasing size (the so-called ‘doubling trick’). This can give very good performance towards the end of the rounds as we will see in our additional experiments in Appendix F, but the performance varies widely towards the beginning of the rounds. This motivates the simpler and more robust weighted averaging scheme (14), which in the case of the stochastic subgradient method, was also recently proven to have O(1/k) convergence rate by Lacoste-Julien et al. (2012)6 and independently by Shamir & Zhang (2013), who called such schemes ‘polynomial-decay averaging’.\nRelated Work. In contrast to the randomized choice of coordinate which we use here, the analysis of cyclic coordinate descent algorithms (going through the blocks sequentially) seems to be notoriously difficult, such that until today, no analysis proving a global convergence rate has been obtained as far as we know. Luo & Tseng (1992) has proven a local linear convergence rate for the strongly convex case.\nFor product domains, such a cyclic analogue of our Algorithm C.2 has already been proposed in Patriksson (1998), using a generalization of Frank-Wolfe iterations under the name ‘cost approximation’. The analysis of Patriksson (1998) shows asymptotic convergence, but since the method goes through the blocks sequentially, no convergence rates could be proven so far.\n6In this paper, they considered a (k + 1)-weight instead of our k-weight, but similar rates can be proven for shifted versions. We motivate skipping the first iterate x(0) in our weighted averaging scheme as sometimes bounds can be proven on the quality of x(1) irrespective of x(0) for Frank-Wolfe (see the paragraph after the proof of Theorem C.1 for example, looking at the n = 1 case)."
    }, {
      "heading" : "C.1. Setup for Convergence Analysis",
      "text" : "We review below the important concepts needed for analyzing the convergence of the block-coordinate FrankWolfe Algorithm C.2.\nDecomposition of the Duality Gap. The product structure of our domain has a crucial effect on the duality gap, namely that it decomposes into a sum over the n components of the domain. The ‘linearization’ duality gap as defined in (5) (see also Jaggi (2013)) for any constrained convex problem of the above form (10), for a fixed feasible point x ∈M, is given by\ng(x) := max s∈M\n〈x− s,∇f(x)〉\n=\nn∑\ni=1\nmax s(i)∈M(i)\n〈 x(i) − s(i),∇(i)f(x) 〉\n=:\nn∑\ni=1\ng(i)(x) .\n(16)\nCurvature. Also, the curvature can now be defined on the individual factors,\nC (i) f := sup\nx∈M, s(i)∈M(i), γ∈[0,1], y=x+γ(s[i]−x[i])\n2 γ2 ( f(y)− f(x)− 〈y(i) − x(i),∇(i)f(x)〉 ) . (17)\nWe recall that the notation x[i] and x(i) is defined just below (10). We define the global product curvature as the sum of these curvatures for each block, i.e.\nC⊗f :=\nn∑\ni=1\nC (i) f . (18)"
    }, {
      "heading" : "C.2. Primal Convergence on Product Domains",
      "text" : "The following main theorem shows that after O (\n1 ε\n) many iterations, Algorithm C.2 obtains an ε-approximate\nsolution.\nTheorem C.1 (Primal Convergence). For each k ≥ 0, the iterate x(k) of the exact variant of Algorithm C.2 satisfies\nE[f(x(k))]− f(x∗) ≤ 2n k + 2n\n( C⊗f + f(x (0))− f(x∗) ) ,\nFor the approximate variant of Algorithm C.2 with additive approximation quality (11) for δ ≥ 0, it holds that\nE[f(x(k))]− f(x∗) ≤ 2n k + 2n\n( C⊗f (1 + δ) + f(x (0))− f(x∗) ) .\nFor the approximate variant of Algorithm C.2, with multiplicative approximation quality (12) for 0 < ν ≤ 1, it holds that\nE[f(x(k))]− f(x∗) ≤ 2n νk + 2n (1 ν C⊗f + f(x (0))− f(x∗) ) .\nAll convergence bounds hold both if the predefined step-sizes, or line-search is used in the algorithm. Here x∗ ∈M is an optimal solution to problem (10), and the expectation is with respect to the random choice of blocks during the algorithm. (In other words all three algorithm variants deliver a solution of (expected) primal error at most ε after O( 1ε ) many iterations.)\nThe proof of the above theorem on the convergence rate of the primal error crucially depends on the following Lemma C.2 on the improvement in each iteration.\nLemma C.2. Let γ ∈ [0, 1] be an arbitrary fixed step-size. Moving only within the i-th block of the domain, we consider two variants of steps towards a direction s(i) ∈ M(i): Let x(k+1)γ := x(γ) be the point obtained by moving towards s(i) using step-size γ, and let x (k+1) LS := x(γLS) be the corresponding point obtained by line-search, i.e. γLS := argmin γ̄∈[0,1] f (x(γ̄)). Here for convenience we have used the notation x(γ̄) := x(k) + γ̄ ( s[i] − x(k)[i] ) for γ̄ ∈ [0, 1]. If for each i the candidate direction s(i) satisfies the additive approximation quality (11) for δ ≥ 0 and some fixed γ̃k, then in expectation over the random choice of the block i and conditioned on x (k), it holds that\nE [ f(x\n(k+1) LS ) |x(k)\n] ≤ E [ f(x(k+1)γ ) |x(k) ] ≤ f(x(k))− γ\nn g(x(k)) +\n1\n2n (γ2 + δγ̃kγ)C ⊗ f .\nOn the other hand, if s(i) attains the duality gap g (i)(x) on the i-th block up to a multiplicative approximation quality (12) for 0 < ν ≤ 1, then\nE [ f(x\n(k+1) LS ) |x(k)\n] ≤ E [ f(x(k+1)γ ) |x(k) ] ≤ f(x(k))− γ\nn ν g(x(k)) +\nγ2 2n C⊗f .\nAll expectations are taken over the random choice of the block i and conditioned on x(k).\nProof. We write x := x(k), y := x (k+1) γ = x + γ(s[i] − x[i]), with x[i] and s[i] being zero everywhere except in their i-th block. We also write dx := ∇(i)f(x) to simplify the notation. From the definition (17) of the curvature constant C\n(i) f of our convex function f over the factor M(i), we have\nf(y) = f(x+ γ(s[i] − x[i])) ≤ f(x) + γ〈s(i) − x(i), dx〉+ γ 2 2 C (i) f .\nNow we use that by (11), the choice of s(i) with 〈 s(i),∇(i)f(x) 〉 ≤ min s′ (i) ∈M(i) 〈 s′(i),∇(i)f(x) 〉 + 12δγ̃kC (i) f is a good descent direction for the linear approximation to f at x, on the i-th factor M(i), giving\n〈s(i) − x(i), dx〉 ≤ −g(i)(x) + δγ̃k2 C (i) f , (19)\nby the definition (16) of the duality gap. Altogether, we have obtained\nf(y) ≤ f(x) + γ(−g(i)(x) + δγ̃k2 C (i) f ) +\nγ2\n2 C (i) f\n= f(x)− γg(i)(x) + 12 (γ2 + δγ̃kγ)C (i) f .\nUsing that the line-search by definition must lead to an objective value at least as good as the one at the fixed γ, we therefore have shown the inequality\nf(x (k+1) LS ) ≤ f(x (k+1) γ ) ≤ f(x(k))− γg(i)(x(k)) + 12 (γ2 + δγ̃kγ)C (i) f .\nFinally the claimed bound on the expected improvement directly follows by taking the expectation: With respect to the (uniformly) random choice of the block i, the expected value of the gap g(i)(x(k)) corresponding to the picked i is exactly 1ng(x (k)). Also, the expected curvature of the i-th factor is 1nC ⊗ f . The proof for the case of multiplicative approximation follows completely analogously, using 〈s(i) − x(i), dx〉 ≤ −ν g(i)(x), which then gives a step improvement of f(y) ≤ f(x)− γνg(i)(x) + γ22 C (i) f .\nHaving Lemma C.2 at hand, we will now prove our above primal convergence Theorem C.1 using similar ideas as for general domains, such as in Jaggi (2013).\nProof of Theorem C.1. We first prove the theorem for the approximate variant of Algorithm C.2 with multiplicative approximation quality (12) of 0 < ν ≤ 1 – the exact variant of the algorithm is simply the special case\nν = 1. From the above Lemma C.2, we know that for every inner step of Algorithm C.2 and conditioned on x(k), we have that E[f(x (k+1) γ ) |x(k)] ≤ f(x(k))− γνn g(x(k)) + γ2 2nC ⊗ f , where the expectation is over the random choice of the block i (this bound holds independently whether line-search is used or not). Writing h(x) := f(x)−f(x∗) for the (unknown) primal error at any point x, this reads as\nE[h(x (k+1) γ ) |x(k)] ≤ h(x(k))− γνn g(x(k)) +\nγ2 2nC ⊗ f\n≤ h(x(k))− γνn h(x(k)) + γ2 2nC ⊗ f = (1− γνn )h(x(k)) + γ2 2nC ⊗ f ,\n(20)\nwhere in the second line, we have used weak duality h(x) ≤ g(x) (which follows directly from the definition of the duality gap, together with convexity of f). The inequality (20) is conditioned on x(k), which is a random quantity given the previous random choices of blocks to update. We get a deterministic inequality by taking the expectation of both sides with respect to the random choice of previous blocks, yielding:\nE[h(x (k+1) γ )] ≤ (1− γνn ) E[h(x(k))] +\nγ2 2nC ⊗ f . (21)\nWe observe that the resulting inequality (21) with ν = 1 is of the same form as the one appearing in the standard Frank-Wolfe primal convergence proof such as in Jaggi (2013), though with a crucial difference of the 1/n factor (and that we are now working with the expected values E[h(x(k))] instead of the original h(x(k))). We will thus follow a similar induction argument over k, but we will see that the 1/n factor will yield a slightly different induction base case (which for n = 1 can be analyzed separately to obtain a better bound). To simplify the notation, let hk := E[h(x (k))].\nBy induction, we are now going to prove that\nhk ≤ 2nC\nνk + 2n for k ≥ 0 .\nfor the choice of constant C := 1νC ⊗ f + h0. The base-case k = 0 follows immediately from the definition of C, given that C ≥ h0. Now we consider the induction step for k ≥ 0. Here the bound (21) for the particular choice of step-size γk := 2n νk+2n ∈ [0, 1] given by Algorithm C.2 gives us (the same bound also holds for the line-search variant, given that the corresponding objective value f(x (k+1) Line-Search) ≤ f(x(k+1)γ ) only improves):\nhk+1 ≤ (1− γkνn )hk + (γk)2Cν2n = (1− 2ννk+2n )hk + ( 2nνk+2n )2Cν2n ≤ (1− 2ννk+2n ) 2nCνk+2n + ( 1νk+2n )22nCν ,\nwhere in the first line we have used that C⊗f ≤ Cν, and in the last inequality we have plugged in the induction hypothesis for hk. Simply rearranging the terms gives\nhk+1 ≤ 2nCνk+2n ( 1− 2ννk+2n + ννk+2n )\n= 2nCνk+2n νk+2n−ν νk+2n ≤ 2nCνk+2n νk+2nνk+2n+ν = 2nCν(k+1)+2n ,\nwhich is our claimed bound for k ≥ 0. The analogous claim for Algorithm C.2 using the approximate linear primitive with additive approximation quality (11) with γ̃k = 2n νk+2n follows from exactly the same argument, by replacing every occurrence of C ⊗ f in the proof here by C⊗f (1 + δ) instead (compare to Lemma C.2 also – note that γ = γ̃k here). Note moreover that one can combine easily both a multiplicative approximation with an additive one as in (13), and modify the convergence statement accordingly.\nDomains Without Product Structure: n = 1. Our above convergence result also holds for the case of the standard Frank-Wolfe algorithm, when no product structure on the domain is assumed, i.e. for the case n = 1. In this case, the constant in the convergence can even be improved for the variant of the algorithm without a multiplicative approximation (ν = 1), since the additive term given by h0, i.e. the error at the starting point, can be removed. This is because already after the first step, we obtain a bound for h1 which is independent of h0. More precisely, plugging γ0 := 1 and ν = 1 in the bound (21) when n = 1 gives h1 ≤ 0 + C⊗f (1 + δ) ≤ C. Using k = 1 as the base case for the same induction proof as above, we obtain that for n = 1:\nhk ≤ 2\nk + 2 C⊗f (1 + δ) for all k ≥ 1 ,\nwhich matches the convergence rate given in Jaggi (2013). Note that in the traditional Frank-Wolfe setting, i.e. n = 1, our defined curvature constant becomes C⊗f = Cf .\nDependence on h0. We note that the only use of including h0 in the constant C = ν −1C⊗f +h0 was to satisfy the base case in the induction proof, at k = 0. If from the structure of the problem we can get a guarantee that h0 ≤ ν−1C⊗f , then the smaller constant C ′ = ν−1C⊗f will satisfy the base case and the whole proof will go through with it, without needing the extra h0 factor. See also Theorem C.4 for a better convergence result with a weaker dependence on h0 in the case where the line-search is used."
    }, {
      "heading" : "C.3. Obtaining Small Duality Gap",
      "text" : "The following theorem shows that after O (\n1 ε\n) many iterations, Algorithm C.2 will have visited a solution with\nε-small duality gap in expectation. Because the block-coordinate Frank-Wolfe algorithm is only looking at one block at a time, it doesn’t know what is its current true duality gap without doing a full (batch) pass over all blocks. Without monitoring this quantity, the algorithm could miss which iterate had a low duality gap. This is why, if one is interested in having a good duality gap (such as in the structural SVM application), then the averaging schemes considered in (14) and (15) become interesting: the following theorem also says that the bound hold for each of the averaged iterates, if the duality gap function g is convex, which is the case for example when f is a quadratic function.7 Theorem C.3 (Primal-Dual Convergence). For each K ≥ 0, the variants of Algorithm C.2 (either using the predefined step-sizes, or using line-search) will yield at least one iterate x(k̂) with k̂ ≤ K with expected duality gap bounded by\nE [ g(x(k̂)) ] ≤ β 2n\nν(K + 1) C ,\nwhere β = 3 and C = ν−1C⊗f (1 + δ) + f(x (0)) − f(x∗). δ ≥ 0 and 0 < ν ≤ 1 are the approximation quality parameters as defined in (13) – use δ = 0 and ν = 1 for the exact variant. Moreover, if the duality gap g is a convex function of x, then the above bound also holds both for E [ g(x̄ (K) w ) ] and E [ g(x̄\n(K) 0.5 ) ] for each K ≥ 0, where x̄(K)w is the weighted average of the iterates as defined in (14) and x̄(K)0.5\nis the 0.5-suffix average of the iterates as defined in (15) with µ = 0.5.\nProof. To simplify notation, we will again denote the expected primal error and expected duality gap for any iteration k ≥ 0 in the algorithm by hk := E[h(x(k))] := E[f(x(k))− f(x∗)] and gk := E[g(x(k))] respectively. The proof starts again by using the crucial improvement Lemma C.2 with γ = γk := 2n νk+2n to cover both variants of Algorithm C.2 at the same time. As in the beginning of the proof of Theorem C.1, we take the expectation with respect to x(k) in Lemma C.2 and subtract f(x∗) to get that for each k ≥ 0 (for the general approximate variant of the algorithm):\nhk+1 ≤ hk − 1nγkν gk + 12n (γk2 + δγ̃kγk)C⊗f = hk − 1nγkν gk + 12nγk2C⊗f (1 + δ) ,\n7To see that g is convex when f is quadratic, we refer to the equivalence between the gap g(x) and the Fenchel duality p(x)−d(∇f(x))) as shown in Appendix D. The dual function d(·) is concave, so if ∇f(x)) is an affine function of x (which is the case for a quadratic function), then d will be a concave function of x, implying that g(x) = p(x) − d(∇f(x))) is convex in x, since the primal function p is convex.\nsince γ̃k ≤ γk. By isolating gk and using the fact that C ≥ ν−1C⊗f (1 + δ), we get the crucial inequality for the expected duality gap:\ngk ≤ n\nνγk (hk − hk+1) + γk\nC 2 . (22)\nThe general proof idea to get an handle on gk is to take a convex combination over multiple k’s of the inequality (22), to obtain a new upper bound. Because a convex combination of numbers is upper bounded by its\nmaximum, we know that the new bound has to upper bound at least one of the gk’s (this gives the existence k̂ part of the theorem). Moreover, if g is convex, we can also obtain an upper bound for the expected duality gap of the same convex combination of the iterates. So let {wk}Kk=0 be a set of non-negative weights, and let ρk := wk/SK , where SK := ∑K k=0 wk. Taking the convex combination of inequality (22) with coefficient ρk, we get\nK∑\nk=0\nρkgk ≤ n\nν\nK∑\nk=0\nρk ( hk γk − hk+1 γk ) + K∑\nk=0\nρkγk C\n2\n= n\nν ( h0 ρ0 γ0 − hK+1 ρK γK ) + n ν K−1∑\nk=0\nhk+1 ( ρk+1 γk+1 − ρk γk ) + K∑\nk=0\nρkγk C\n2\n≤ n ν h0 ρ0 γ0 + n ν\nK−1∑\nk=0\nhk+1 ( ρk+1 γk+1 − ρk γk ) + K∑\nk=0\nρkγk C\n2 , (23)\nusing hK+1 ≥ 0. Inequality (23) can be seen as a master inequality to derive various bounds on gk. In particular, if we define x̄ := ∑K k=0 ρkx (k) and we suppose that g is convex (which is the case for example when f is a\nquadratic function), then we have E[g(x̄)] ≤∑Kk=0 ρkgk by convexity and linearity of the expectation.\nWeighted-averaging case. We first consider the weights wk = k which appear in the definition of the weighted average of the iterates x̄ (K) w in (14) and suppose K ≥ 1. In this case, we have ρk = k/SK where SK = K(K+1)/2. With the predefined step-size γk = 2n/(νk + 2n), we then have\nρk+1 γk+1 − ρk γk = 1 2nSK ((k + 1)(ν(k + 1) + 2n)− k(νk + 2n))\n= ν(2k + 1) + 2n\n2nSK .\nPlugging this in the master inequality (23) as well as using the convergence rate hk ≤ 2nCνk+2n from Theorem C.1, we obtain\nK∑\nk=0\nρkgk ≤ n\nνSK\n[ 0 + K−1∑\nk=0\n2nC\nν(k + 1) + 2n\nν(2k + 1) + 2n\n2n\n] + K∑\nk=0\n2nk\nνk + 2n\nC\n2SK\n≤ nC νSK\n[ 2 K−1∑\nk=0\n1 +\nK∑\nk=1\n1\n]\n= 2nC\nν(K + 1) · 3.\nHence we have proven the bound with β = 3 for K ≥ 1. For K = 0, the master inequality (23) becomes\ng0 ≤ n\nν h0 +\n1 2 C ≤ nC ν\n( 1 + 1\n2n\n)\nsince h0 ≤ C and ν ≤ 1. Given that n ≥ 1, we see that the bound also holds for K = 0.\nSuffix-averaging case. For the proof of convergence of the 0.5-suffix averaging of the iterates x̄ (K) 0.5 , we refer the reader to the proof of Theorem C.5 which can be re-used for this case (see the last paragraph of the proof to explain how).\nDomains Without Product Structure: n = 1. As we mentioned after the proof of the primal convergence Theorem C.1, we note that if n = 1, then we can replace C in the statement of Theorem C.3 by C⊗f (1 + δ) for K ≥ 1 when ν = 1, as then we can ensure that h1 ≤ C which is all what was needed for the primal convergence induction. Again, C⊗f = Cf when n = 1."
    }, {
      "heading" : "C.4. An Improved Convergence Analysis for the Line-Search Case",
      "text" : "C.4.1. Improved Primal Convergence for Line-Search\nIf line-search is used, we can improve the convergence results of Theorem C.1 by showing a weaker dependence on the starting condition h0 thanks to faster progress in the starting phase of the first few iterations: Theorem C.4 (Improved Primal Convergence for Line-Search). For each k ≥ k0, the iterate x(k) of the linesearch variant of Algorithm C.2 (where the linear subproblem is solved with a multiplicative approximation quality (12) of 0 < ν ≤ 1) satisfies\nE [ f(x(k)) ] − f(x∗) ≤ 1\nν 2nC⊗f ν(k − k0) + 2n\n(24)\nwhere k0 := max { 0, ⌈ log ( 2νh(x(0))\nC⊗f\n)/ (− log ξn) ⌉} is the number of steps required to guarantee that\nE [ f(x(k)) ] − f(x∗) ≤ ν−1C⊗f , with x∗ ∈ M being an optimal solution to problem (10), and h(x(0)) := f(x(0)) − f(x∗) is the primal error at the starting point, and ξn := 1 − νn < 1 is the geometric decrease rate of the primal error in the first phase while k < k0 — i.e. E [ f(x(k)) ] − f(x∗) ≤ (ξn)k h(x(0)) +C⊗f /2ν for k < k0."
    }, {
      "heading" : "If the linear subproblem is solved with an additive approximation quality (11) of δ ≥ 0 instead, then replace all",
      "text" : "appearances of C⊗f above with C ⊗ f (1 + δ).\nProof. For the line-search case, the expected improvement guaranteed by Lemma C.2 for the multiplicative approximation variant of Algorithm C.2, in expectation as in (21), is valid for any choice of γ ∈ [0, 1]:\nE [ h(x\n(k+1) LS ) ] ≤ (1− νγn ) E [ h(x(k)) ] + γ 2 2nC ⊗ f . (25)\nBecause the bound (25) holds for any γ, we are free to choose the one which minimizes it subject to γ ∈ [0, 1], that is γ∗ := min { 1, νhk\nC⊗f\n} , where we have again used the identification hk := E [ h(x (k) LS) ] . Now we distinguish\ntwo cases:\nIf γ∗ = 1, then νhk ≥ C⊗f . By unrolling the inequality (25) recursively to the beginning and using γ = 1 at each step, we get:\nhk+1 ≤ ( 1− νn ) hk + 1 2nC ⊗ f\n≤ ( 1− νn )k+1 h0 + 1 2nC ⊗ f ∑k t=0 ( 1− νn )t ≤ ( 1− νn )k+1 h0 + 1 2nC ⊗ f ∑∞ t=0 ( 1− νn )t = ( 1− νn )k+1 h0 + 1 2nC ⊗ f ( 1 1−(1−ν/n) ) = ( 1− νn )k+1 h0 + 1 2νC ⊗ f .\nWe thus have a geometric decrease with rate ξn := 1 − νn in this phase. We then get hk ≤ ν−1C⊗f as soon as (ξn)\nkh0 ≤ C⊗f /2ν, i.e. when k ≥ log1/ξn(2νh0/C⊗f ) = log(2νh0/C⊗f )/ − log(1 − νn ). We thus have obtained a logarithmic bound on the number of steps that fall into the first regime case here, i.e. where hk is still ‘large’. Here it is crucial to note that the primal error hk is always decreasing in each step, due to the line-search, so once we leave this regime of hk ≥ ν−1C⊗f , then we will never enter it again in subsequent steps.\nOn the other hand, as soon as we reach a step k (e.g. when k = k0) such that γ ∗ < 1 or equivalently hk < ν −1C⊗f , then we are always in the second phase where γ∗ = νhk C⊗f . Plugging this value of γ∗ in (25) yields the recurrence bound:\nhk+1 ≤ hk − 1\nζ h2k ∀k ≥ k0 (26)\nwhere ζ := 2nC⊗f ν2 , with the initial condition hk0 ≤ C⊗f ν = νζ 2n . This is a standard recurrence inequality which appeared for example in Joachims et al. (2009, Theorem 5, see their Equation (23)) or in the appendix of Teo et al. (2007). We can solve the recurrence (26) by following the argument of Teo et al. (2007), where it was pointed out that since hk is monotonically decreasing, we can upper bound hk by the solution to the corresponding differential equations h′(t) = −h2(t)/ζ, with initial condition h(k0) = hk0 . Integrating both sides, we get the solution h(t) = ζt−k0+ζ/hk0 . Plugging in the value for hk0 and since hk ≤ h(k), we thus get the bound:\nhk ≤ 1\nν 2nC⊗f ν(k − k0) + 2n ∀k ≥ k0, (27)\nwhich completes the proof for the multiplicative approximation variant.\nFor the additive approximation variant, the inequality (25) with γ = 1 in Lemma C.2 becomes:\nhk+1 ≤ ( 1− νn ) hk + 1 2n (1 + δγ̃k)C ⊗ f\n≤ ( 1− νn ) hk + 1 2n (1 + δ)C ⊗ f ,\nsince γ̃k ≤ 1. By unrolling this inequality as before, we get the geometric rate of decrease in the initial phase by using γ = 1 until k = k0 where we can ensure that hk0 ≤ C⊗f (1 + δ)/ν. We then finish the proof by reusing the induction proof from Theorem C.1, but with Equation (24) as the induction hypothesis, replacing C⊗f with C⊗f (1 + δ). The base case at k = k0 is satisfied by the definition of k0. For the induction step, we use γk = 2n\nν(k−k0)+2n (note that because we use line-search, we are free to use any γ we want in the inequality from\nLemma C.2), and use the crucial fact that γ̃k = 2n νk+2n ≤ γk to get a similar argument as in Theorem C.1.\nNumber of Iterations. We now make some observations in the case of δ = 0 (for simplicity). Note that since for n > 0.5 and − log ( 1− νn ) > νn for the natural logarithm, we get that k0 ≤ ⌈ n ν log ( 2νh(x(0))\nC⊗f\n)⌉ and so\nunless the structure of our problem can guarantee that h(x(0)) ≤ C⊗f /ν, we get a linear number of steps in n required to reach the second phase, but the dependence is logarithmic in h(x(0)) – instead of linear in h(x(0)) as given by our previous convergence Theorem C.1 for the fixed step-size variant (in the fixed step-size variant,\nwe would need k0 =\n⌈ 2nh(x (0))\nC⊗f\n⌉ steps to guarantee hk0 ≤ C⊗f /ν). Therefore, for the line-search variant of our\nAlgorithm C.2, we have obtained guaranteed ε-small error after ⌈ n\nν log\n( 2νh(x(0))\nC⊗f\n)⌉ + ⌈ 2nC⊗f ν2 ε ⌉\niterations.\nEffect of Line-Search. It is also interesting to point out that even though we were using the optimal stepsize in the second phase of the above proof (which yielded the recurrence (26)), the second phase bound is not better than what we could have obtained by using a fixed step-size schedule of 2nν(k−k0)+2n and following the same induction proof line as in the previous Theorem C.1 (using the base case hk0 ≤ C⊗f /ν and so we could let C := ν−1C⊗f ). This thus means that the advantage of the line-search over the fixed step-size schedule only appears in knowing when to switch from a step-size of 1 (in the first phase, when hk ≥ ν−1C⊗f ) to a step-size of 2nν(k−k0)+2n (in the second phase), which unless we know the value of f(x ∗), we cannot know in general. In the standard Frank-Wolfe case where n = 1 and ν = 1, there is no difference in the rates for line-search or fixed step-size schedule as in this case we know h1 ≤ C⊗f as explained at the end of the proof of Theorem C.1. This also suggests that if k0 > n, it might be more worthwhile in theory to first do one batch Frank-Wolfe step to ensure that h1 ≤ C⊗f , and then proceed with the block-coordinate Frank-Wolfe algorithm afterwards.\nC.4.2. Improved Primal-Dual Convergence for Line-Search\nUsing the improved primal convergence theorem for line-search, we can also get a better rate for the expected duality gap (getting rid of the dependence of h0 in the constant C):\nTheorem C.5 (Improved Primal-Dual Convergence for Line-Search). Let k0 be defined as in Theorem C.4. For each K ≥ 5k0, the line-search variant of Algorithm C.2 will yield at least one iterate x(k̂) with k̂ ≤ K with expected duality gap bounded by\nE [ g(x(k̂)) ] ≤ β 2n\nν(K + 2) C ,\nwhere β = 3 and C = ν−1C⊗f (1 + δ). δ ≥ 0 and 0 < ν ≤ 1 are the approximation parameters as defined in (13) – use δ = 0 and ν = 1 for the exact variant. Moreover, if the duality gap g is a convex function of x, then the above bound also holds for E [ g(x̄\n(K) 0.5 )\n] for each\nK ≥ 5k0, where x̄(K)0.5 is the 0.5-suffix average of the iterates as defined in (15) with µ = 0.5.\nProof. We follow a similar argument as in the proof of Theorem C.3, but making use of the better primal convergence Theorem C.4 as well as using the 0.5-suffix average for the master inequality (23). Let K ≥ 5k0 be given. Let γk :=\n2n ν(k−k0)+2n for k ≥ k0. Note then that γ̃k = 2n νk+2n ≤ γk and so the gap inequality (22)\nappearing in the proof of Theorem C.3 is valid for this γk (because we are considering the line-search variant of Algorithm C.2, we are free to choose any γ ∈ [0, 1] in Lemma C.2). This means that the master inequality (23) is also valid here with C = ν−1C⊗f (1 + δ).\nWe consider the weights which appear in the definition of the 0.5-suffix average of iterates x̄ (K) 0.5 given in (15), i.e. the average of the iterates x(k) from k = Ks := d0.5Ke to k = K. We thus have ρk = 1/SK for Ks ≤ k ≤ K and ρk = 0 otherwise, where SK = K − d0.5Ke+ 1. Notice that Ks ≥ k0 by assumption. With these choices of ρk and γk, the master inequality (23) becomes\nK∑\nk=0\nρkgk ≤ n\nνSK [ hKs γKs + K−1∑\nk=Ks\nhk+1\n( 1\nγk+1 − 1 γk\n)] + K∑\nk=Ks\nγk C\n2SK\n≤ n νSK\n[ C + K−1∑\nk=Ks\n2nC ν(k + 1− k0) + 2n ( ν 2n )\n] + K∑\nk=Ks\n2n ν(k − k0) + 2n C 2SK\n= nC\nνSK\n[ 1 + K−1∑\nk=Ks\n1\nk + 1− k0 + 2n/ν +\nK∑\nk=Ks\n1\nk − k0 + 2n/ν\n]\n≤ nC νSK\n[ 1 + 2 K∑\nk=Ks\n1\nk − k0 + 2n/ν\n]\n≤ 2nC ν(K + 2)\n[ 1 + 2 K∑\nk=Ks\n1\nk − k0 + 2n/ν\n] , (28)\nwhere in the second line we used the faster convergence rate hk ≤ 2nCν(k−k0)+2n from Theorem C.4, given that Ks ≥ k0. In the last line, we used SK ≤ 0.5K + 1. The rest of the proof simply amounts to get an upper bound of β = 3 on the term between brackets in (28), thus concluding that ∑K k=0 ρkgk ≤ β 2nCν(K+2) . Then following a similar argument as in Theorem C.3, this will imply that there exists some gk̂ similarly upper bounded (the\nexistence part of the theorem); and that if g is convex, we have that E [ g(x̄\n(K) 0.5 )\n] is also similarly upper bounded.\nWe can upper bound the summand term in (28) by using the fact that for any non-negative decreasing integrable function f , we have ∑K k=Ks f(k) ≤ ∫K Ks−1 f(t)dt. Let an := k0 − 2n/ν. Using f(k) := 1 k−an , we have that\nK∑\nk=Ks\n1 k − an ≤ ∫ K\nKs−1\n1\nt− an dt =\n[ log(t− an) ]t=K t=Ks−1\n= log K − an Ks − 1− an ≤ log K − an 0.5K − 1− an =: b(K),\nwhere we used Ks ≥ 0.5K. We want to show that b(K) ≤ 1 for K ≥ 5k0 to conclude that β = 3 works as a bound in (28) and thus completing the proof. By looking at the sign of the derivative of b(K), we can see that it is an increasing function of K if an ≤ −2 i.e. if 2n/ν ≥ k0 + 2 (which is always the case if k0 = 0 as n ≥ 1), and a strictly decreasing function of K otherwise. In the case where b(K) is increasing, we have b(K) ≤ limK 7→∞ b(K) = log(2) < 1. In the case where b(K) is decreasing, we upper bound it by letting K take its minimal value from the theorem, namely K ≥ 5k0. From the definition of an, we then get that b(5k0) = log\n4k0+2n/ν 1.5k0−1+2n/ν , which is an increasing function of k0 as long as 2n/ν ≥ 2 (which is indeed always the\ncase). So letting k0 →∞, we get that b(5k0) ≤ log(4/1.5) ≈ 0.98 < 1, thus completing the proof. We finally note that statement for E [ g(x̄\n(K) 0.5 )\n] in Theorem C.3 can be proven using the same argument as\nabove, but with k0 = 0 and C = ν −1C⊗f (1 + δ) + h0 and using the original primal convergence bound on hk in Theorem C.1 instead. This will work for both predefined step-size or the line search variants — the only place where we used the line-search in the above proof was to use the different primal convergence result as well as shifted-by-k0 step-sizes γk (which reduce to the standard step-sizes when k0 = 0).\nWe note that we cannot fully get rid of the dependence on h0 for the convergence rate of the expected duality gap of the weighted averaged scheme because we average over k < k0, a regime where the primal error depends on h0. With a more refined analysis for the weighted average with line-search scheme though, we note that one can replace the h0 n K dependence in the bound with a h0( n K )\n2 one, i.e. a quadratic speed-up to forget the initial conditions when line-search is used. We also note that a bound of O(1/K) can be derived similarly for E [ g(x̄ (K) µ ) ] for 0 < µ < 1 — namely using the C as in Theorem C.3 and β = βµ := (1− µ)−1(0.5− logµ) (notice that βµ =∞ if µ = 0 or µ = 1). This result is similar as the one for the stochastic subgradient method and where the O(1/K) rate was derived by Rakhlin et al. (2012) for the (1− µ)-suffix averaging scheme — this provided a motivation for the scheme as the authors proved that the full averaging scheme has Ω((logK)/K) rate in the worst case. If we use µ = 0 (i.e. we average from the beginning), then the sum in (28) becomes O(logK), yielding O((logK)/K) for the expected gap."
    }, {
      "heading" : "D. Equivalence of the ‘Linearization’-Duality Gap to a Special Case of Fenchel Duality",
      "text" : "For our used constrained optimization framework, the notion of the simple duality gap was crucial. Consider a general constrained optimization problem\nmin x∈M f(x) , (29)\nwhere the domain (or feasible set) M ⊆ X is an arbitrary compact subset of a Euclidean space X . We assume that the objective function f is convex, but not necessarily differentiable.\nIn this case, the general ‘linearization’ duality gap (5) as proposed by (Jaggi, 2013) is given by\ng(x; dx) = I ∗ M(−dx) + 〈x, dx〉 . (30)\nHere dx is an arbitrary subgradient to f at the candidate position x, and I ∗ M(y) := sups∈M 〈s,y〉 is the support function of the set M. Convexity of f implies that the linearization f(x) + 〈 s−x, dx 〉 always lies below the graph of the function f , as illustrated by the figure in Section 3. This immediately gives the crucial property of the duality gap (30), as being a certificate for the current approximation quality, i.e. upper-bounding the (unknown) error g(x) ≥ f(x)−f(x∗), where x∗ is some optimal solution.\nNote that for differentiable functions f , the gradient is the unique subgradient at x, therefore the duality gap equals g(x) := g(x;∇f(x)) as we defined in (5).\nFenchel Duality. Here we will additionally explain how the duality gap (30) can also be interpreted as a special case of standard Fenchel convex duality.\nWe consider the equivalent formulation of our constrained problem (29), given by\nmin x∈X f(x) + IM(x) .\nHere the set indicator function IM of a subset M⊆ X is defined as IM(x) := 0 for x ∈ M and IM(x) := +∞ for x /∈M. The Fenchel conjugate function f∗ of a function f is given by f∗(y) := supx∈X 〈x,y〉 − f(x). For example, observe that the Fenchel conjugate of a set indicator function IM(.) is given by its support function I∗M(.). From the above definition of the conjugate, the Fenchel-Young inequality f(x)+f∗(y) ≥ 〈x,y〉 ∀x,y ∈ X follows directly.\nNow we consider the Fenchel dual problem of minimizing p(x) := f(x) + IM(x), which is defined as to maximize d(y) := −f∗(y)− I∗M(−y). By the Fenchel-Young inequality, and assuming that x ∈M, we have that ∀y ∈ X ,\np(x)− d(y) = f(x)− (−f∗(y)− I∗M(−y)) ≥ 〈x,y〉+ I∗M(−y) = g(x;y) .\nFurthermore, this inequality becomes an equality if and only if y is chosen as a subgradient to f at x, that is if y := −dx. The last fact follows from the known equivalent characterization of the subdifferential in terms of the Fenchel conjugate: ∂f(x) := {y ∈ X | f(x) + f∗(y) = 〈x,y〉}. For a more detailed explanation of Fenchel duality, we refer the reader to the standard literature, e.g. (Borwein & Lewis, 2006, Theorem 3.3.5).\nTo summarize, we have obtained that the simpler ‘linearization’ duality gap g(x; dx) as given in (30) is indeed the difference of the current objective to the Fenchel dual problem, when being restricted to the particular choice of the dual variable y being a subgradient at the current position x."
    }, {
      "heading" : "E. Derivation of the n-Slack Structural SVM Dual",
      "text" : "Proof of the dual of the n-Slack-Formulation. See also Collins et al. (2008). For a self-contained explanation of Lagrange duality we refer the reader to Boyd & Vandenberghe (2004, Section 5). The Lagrangian of (1) is\nL(w, ξ,α) = λ 2 〈w,w〉+ 1 n\nn∑\ni=1\nξi + ∑\ni∈[n],y∈Yi\n1 n αi(y) (−ξi + 〈w,−ψi(y)〉+ Li(y)) ,\nwhere α = (α1, . . . ,αn) ∈ R|Y1| × · · · × R|Yn| = Rm are the corresponding (non-negative) Lagrange multipliers. Here we have re-scaled the multipliers (dual variables) by a constant of 1n , corresponding to multiplying the corresponding original primal constraint by 1n on both sides, which does not change the optimization problem.\nSince the objective as well as the constraints are continuously differentiable with respect to (w, ξ), the Lagrangian L will attain its finite minimum over α when ∇(w,ξ)L(w, ξ,α) = 0. Making this saddle-point condition explicit results in a simplified Lagrange dual problem, which is also known as the Wolfe dual. In our case, this condition from differentiating w.r.t. w is\nλw = ∑\ni∈[n],y∈Yi\n1 n αi(y)ψi(y) . (31)\nAnd differentiating with respect to ξi and setting the derivatives to zero gives 8\n∑\ny∈Yi\nαi(y) = 1 ∀i ∈ [n] .\n8Note that because the Lagrangian is linear in ξi, if this condition is not satisfied, the minimization of the Lagrangian in ξi yield −∞ and so these points can be excluded.\nPlugging this condition and the expression (31) for w back into the Lagrangian, we obtain the Lagrange dual problem\nmax α − λ 2 ∥∥∥∥∥∥ ∑\ni∈[n],y∈Yi\nαi(y) ψi(y)\nλn ∥∥∥∥∥∥ 2 + ∑\ni∈[n],y∈Yi\nαi(y) Li(y)\nn\ns.t. ∑\ny∈Y αi(y) = 1 ∀i ∈ [n], and αi(y) ≥ 0 ∀i ∈ [n], ∀y ∈ Yi ,\nwhich is exactly the negative of the quadratic program claimed in (4)."
    }, {
      "heading" : "F. Additional Experiments",
      "text" : "Complementing the results presented in Figure 1 in Section 6 of the main paper, here we provide additional experimental results as well as give more information about the experimental setup used.\nFor the Frank-Wolfe methods, Figure 2 presents results on OCR comparing setting the step-size by line-search against the simpler predefined step-size scheme of γk = 2n/(k + 2n). There, BCFW with predefined stepsizes does similarly as SSG, indicating that most of the improvement of BCFW with line-search over SSG is coming from the optimal step-size choice (and not from the Frank-Wolfe formulation on the dual). We also see that BCFW with predefined step-sizes can even do worse than batch Frank-Wolfe with line-search in the early iterations for small values of λ.\nFigure 3 and Figure 4 show additional results of the stochastic solvers for several values of λ on the OCR and CoNLL datasets. Here we also include the (uniformly) averaged stochastic subgradient method (SSG-avg), which starts averaging at the beginning; as well as the 0.5-suffix averaging versions of both SSG and BCFW (SSG-tavg and BCFW-tavg respectively), implemented using the ‘doubling trick’ as described just after Equation (15) in Appendix C. The ‘doubling trick’ uniformly averages all iterates since the last iteration which was a power of 2, and was described by Rakhlin et al. (2012), with experiments for SSG in Lacoste-Julien et al. (2012). In our experiments, BCFW-tavg sometimes slightly outperforms the weighted average scheme BCFW-wavg, but its performance fluctuates more widely, which is why we recommend the BCFW-wavg, as mentioned in the main text. In our experiments, the objective value of SSG-avg is always worse than the other stochastic methods (apart online-EG), which is why it was excluded from the main text. Online-EG performed substantially worse than the other stochastic solvers for the OCR dataset, and is therefore not included in the comparison for the other datasets.9\nFinally, Figure 5 presents additional results for the matching application from Taskar et al. (2006).\n9The worse performance of the online exponentiated gradient method could be explained by the fact that it uses a log-parameterization of the dual variables and so its iterates are forced to be in the interior of the probability simplex, whereas we know that the optimal solution for the structural SVM objective lies at the boundary of the domain and thus these parameters need to go to infinity.\nk+2n\nin the block-coordinate case respectively). See also the original optimization Algorithms 1 and 3.\nMore Information about Implementation. We note that since the value of the true optimum is unknown, the primal suboptimality for each experiment was measured as the difference to the highest dual objective seen for the corresponding regularization parameter (amongst all methods). Moreover, the lower envelope of the obtained primal objective values was drawn in Figure 1 for the batch methods (cutting plane and Frank-Wolfe), given that these methods can efficiently keep track of the best parameter seen so far.\nThe online-EG method used the same adaptive step-size scheme as described in Collins et al. (2008) and with the parameters from their code egstra-0.2 available online.10 Each datapoint has their own step-size, initialized at 0.5. Backtracking line-search is used, where the step-size is halved until the objective is decreased (or a maximum number of halvings has been reached: 2 for the first pass through the data; 5 otherwise). After each line-search, the step-size is multiplied by 1.05. We note that each evaluation of the objective requires a new call to the (expectation) oracle, and we count these extra calls in the computation of the effective number of passes appearing on the x-axis of the plots. Unlike all the other methods which initialize w(0) = 0, online-EG initially sets the dual variables α (0) (i) to a uniform distribution, which yields a problem-dependent initialization w (0).\nFor SSG, we used the same step-size as in the ‘Pegasos’ version of Shalev-Shwartz et al. (2010a): γk := 1\nλ(k+1) .\nFor the cutting plane method, we use the version 1.1 of the svm-struct-matlab MATLAB wrapper code from Vedaldi (2011) with its default options.\nThe test error for the OCR and CoNLL tasks is the normalized Hamming distance on the sequences.\nFor the matching prediction task, we use the same setting from Taskar et al. (2006), with 5, 000 training examples and 347 Gold test examples. During training, an asymmetric Hamming loss is used where the precision error cost is 1 while the recall error cost is 3. For testing, error is the ‘alignment error rate’, as defined in Taskar et al. (2006)."
    }, {
      "heading" : "Supplementary References",
      "text" : "Borwein, J. and Lewis, A. Convex analysis and nonlinear optimization: theory and examples. 2006.\nBoyd, S. and Vandenberghe, L. Convex optimization. 2004.\nLuo, Z Q and Tseng, P. On the convergence of the coordinate descent method for convex differentiable minimization. Journal of Optimization Theory and Applications, 72(1):7–35, 1992.\nPatriksson, M. Decomposition methods for differentiable optimization problems over cartesian product sets. Computational Optimization and Applications, 9(1):5–42, 1998.\nRichtárik, P. and Takáč, M. Iteration complexity of randomized block-coordinate descent methods for minimizing a composite function. Technical Report 1107.2848v1 [math.OC], arXiv, 2011.\nTeo, C.H., Smola, A.J., Vishwanathan, SVN, and Le, Q.V. A scalable modular convex solver for regularized risk minimization. ACM SIGKDD, pp. 727–736, 2007.\nVedaldi, A. A MATLAB wrapper of SVMstruct. http://www.vlfeat.org/~vedaldi/code/ svm-struct-matlab.html, 2011.\n10http://groups.csail.mit.edu/nlp/egstra/"
    } ],
    "references" : [ {
      "title" : "Convex analysis and nonlinear optimization: theory and examples",
      "author" : [ "A. Lewis" ],
      "venue" : null,
      "citeRegEx" : "Borwein and Lewis,? \\Q2006\\E",
      "shortCiteRegEx" : "Borwein and Lewis",
      "year" : 2006
    }, {
      "title" : "On the convergence of the coordinate descent method for convex differentiable minimization",
      "author" : [ "Z Q Luo", "P. Tseng" ],
      "venue" : "Journal of Optimization Theory and Applications,",
      "citeRegEx" : "Luo and Tseng,? \\Q1992\\E",
      "shortCiteRegEx" : "Luo and Tseng",
      "year" : 1992
    }, {
      "title" : "Decomposition methods for differentiable optimization problems over cartesian product sets",
      "author" : [ "M. Patriksson" ],
      "venue" : "Computational Optimization and Applications,",
      "citeRegEx" : "Patriksson,? \\Q1998\\E",
      "shortCiteRegEx" : "Patriksson",
      "year" : 1998
    }, {
      "title" : "Iteration complexity of randomized block-coordinate descent methods for minimizing a composite function",
      "author" : [ "P. Richtárik", "M. Takáč" ],
      "venue" : "Technical Report 1107.2848v1 [math.OC],",
      "citeRegEx" : "Richtárik and Takáč,? \\Q2011\\E",
      "shortCiteRegEx" : "Richtárik and Takáč",
      "year" : 2011
    }, {
      "title" : "A scalable modular convex solver for regularized risk minimization",
      "author" : [ "C.H. Teo", "A.J. Smola", "SVN Vishwanathan", "Q.V. Le" ],
      "venue" : "ACM SIGKDD, pp. 727–736,",
      "citeRegEx" : "Teo et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Teo et al\\.",
      "year" : 2007
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "2 has already been proposed in Patriksson (1998), using a generalization of Frank-Wolfe iterations under the name ‘cost approximation’.",
      "startOffset" : 31,
      "endOffset" : 49
    }, {
      "referenceID" : 2,
      "context" : "2 has already been proposed in Patriksson (1998), using a generalization of Frank-Wolfe iterations under the name ‘cost approximation’. The analysis of Patriksson (1998) shows asymptotic convergence, but since the method goes through the blocks sequentially, no convergence rates could be proven so far.",
      "startOffset" : 31,
      "endOffset" : 170
    }, {
      "referenceID" : 4,
      "context" : "(2009, Theorem 5, see their Equation (23)) or in the appendix of Teo et al. (2007). We can solve the recurrence (26) by following the argument of Teo et al.",
      "startOffset" : 65,
      "endOffset" : 83
    }, {
      "referenceID" : 4,
      "context" : "(2009, Theorem 5, see their Equation (23)) or in the appendix of Teo et al. (2007). We can solve the recurrence (26) by following the argument of Teo et al. (2007), where it was pointed out that since hk is monotonically decreasing, we can upper bound hk by the solution to the corresponding differential equations h′(t) = −h2(t)/ζ, with initial condition h(k0) = hk0 .",
      "startOffset" : 65,
      "endOffset" : 164
    } ],
    "year" : 2013,
    "abstractText" : "We propose a randomized block-coordinate variant of the classic Frank-Wolfe algorithm for convex optimization with block-separable constraints. Despite its lower iteration cost, we show that it achieves a similar convergence rate in duality gap as the full FrankWolfe algorithm. We also show that, when applied to the dual structural support vector machine (SVM) objective, this yields an online algorithm that has the same low iteration complexity as primal stochastic subgradient methods. However, unlike stochastic subgradient methods, the block-coordinate FrankWolfe algorithm allows us to compute the optimal step-size and yields a computable duality gap guarantee. Our experiments indicate that this simple algorithm outperforms competing structural SVM solvers.",
    "creator" : "LaTeX with hyperref package"
  }
}