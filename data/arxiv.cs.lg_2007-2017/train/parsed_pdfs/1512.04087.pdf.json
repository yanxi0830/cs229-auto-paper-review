{
  "name" : "1512.04087.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "True Online Temporal-Difference Learning",
    "authors" : [ "Harm van Seijen", "A. Rupam Mahmood", "Patrick M. Pilarski", "Marlos C. Machado", "Richard S. Sutton", "Rupam Mahmood" ],
    "emails" : [ "harm.vanseijen@maluuba.com", "ashique@ualberta.ca", "patrick.pilarski@ualberta.ca", "machado@ualberta.ca", "sutton@cs.ualberta.ca" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Keywords: temporal-difference learning, eligibility traces, forward-view equivalence\nc©2016 Harm van Seijen, A. Rupam Mahmood, Patrick M. Pilarski, Marlos C. Machado and Richard S. Sutton.\nar X\niv :1\n51 2.\n04 08\n7v 2"
    }, {
      "heading" : "1. Introduction",
      "text" : "Temporal-difference (TD) learning is a core learning technique in modern reinforcement learning (Sutton, 1988; Kaelbling et al., 1996; Sutton & Barto, 1998; Szepesvári, 2010). One of the main challenges in reinforcement learning is to make predictions, in an initially unknown environment, about the (discounted) sum of future rewards, the return, based on currently observed feature values and a certain behaviour policy. With TD learning it is possible to learn good estimates of the expected return quickly by bootstrapping from other expected-return estimates. TD(λ) (Sutton, 1988) is a popular TD algorithm that combines basic TD learning with eligibility traces to further speed learning. The popularity of TD(λ) can be explained by its simple implementation, its low-computational complexity and its conceptually straightforward interpretation, given by its forward view. The forward view of TD(λ) states that the estimate at each time step is moved towards an update target known as the λ-return, with λ determining the fundamental trade-off between bias and variance of the update target. This trade-off has a large influence on the speed of learning and its optimal setting varies from domain to domain. The ability to improve this trade-off by adjusting the value of λ is what underlies the performance advantage of eligibility traces.\nAlthough the forward view provides a clear intuition, TD(λ) closely approximates the forward view only for appropriately small step-sizes. Until recently, this was considered an unfortunate, but unavoidable part of the theory behind TD(λ). This changed with the introduction of true online TD(λ) (van Seijen & Sutton, 2014), which computes exactly the same weight vectors as the forward view at any step-size. This gives true online TD(λ) full control over the bias-variance trade-off. In particular, true online TD(1) can achieve fully unbiased updates. Moreover, true online TD(λ) only requires small modifications to the TD(λ) update equations, and the extra computational cost is negligible in most cases.\nWe hypothesize that true online TD(λ), and its control version true online Sarsa(λ), not only have better theoretical properties than their regular counterparts, but also dominate them empirically. We test this hypothesis by performing an extensive empirical comparison between true online TD(λ), regular TD(λ) (which is based on accumulating traces), and the common variation based on replacing traces. In addition, we perform comparisons between true online Sarsa(λ) and Sarsa(λ) (with accumulating and replacing traces). The domains we use include random Markov reward processes, a real-world myoelectric prosthetic arm, and a domain from the Arcade Learning Environment (Bellemare et al., 2013). The representations we consider range from tabular values to linear function approximation with binary and non-binary features.\nBesides the empirical study, we provide an in-depth discussion on the theory behind true online TD(λ). This theory is based on a new online forward view. The traditional forward view, based on the λ-return, is inherently an offline forward view meaning that updates only occur at the end of an episode, because the λ-return requires data up to the end of an episode. We extend this forward view to the online case, where updates occur at every time step, by using a bounded version of the λ-return that grows over time. Whereas TD(λ) approximates the traditional forward view only at the end of an episode, we show that TD(λ) approximates this new online forward view at all time steps. True online TD(λ) is equivalent to this new online forward view at all time steps. We prove this by deriving the true online TD(λ) update equations directly from the online forward\nview update equations. This derivation forms a blueprint for the derivation of other true online methods. By making variations to the online forward view and following the same derivation as for true online TD(λ), we derive several other true online methods.\nThis article is organized as follows. We start by presenting the required background in Section 2. Then, we present the new online forward view in Section 3, followed by the presentation of true online TD(λ) in Section 4. Section 5 presents the empirical study. Furthermore, in Section 6, we present several other true online methods. In Section 7, we discuss in detail related papers. Finally, Section 8 concludes."
    }, {
      "heading" : "2. Background",
      "text" : "Here, we present the main learning framework. As a convention, we indicate scalar-valued random variables by capital letters (e.g., St, Rt), vectors by bold lowercase letters (e.g., θ, φ), functions by non-bold lowercase letters (e.g., v), and sets by calligraphic font (e.g., S, A).1"
    }, {
      "heading" : "2.1 Markov Decision Processes",
      "text" : "Reinforcement learning (RL) problems are often formalized as Markov decision processes (MDPs), which can be described as 5-tuples of the form 〈S,A, p, r, γ〉, where S indicates the set of all states; A indicates the set of all actions; p(s′|s, a) indicates the probability of a transition to state s′ ∈ S, when action a ∈ A is taken in state s ∈ S; r(s, a, s′) indicates the expected reward for a transition from state s to state s′ under action a; the discount factor γ specifies how future rewards are weighted with respect to the immediate reward.\nActions are taken at discrete time steps t = 0, 1, 2, ... according to a policy π : S ×A → [0, 1], which defines for each action the selection probability conditioned on the state. The return at time t is defined as the discounted sum of rewards, observed after t:\nGt := Rt+1 + γ Rt+2 + γ 2Rt+3 + ... = ∞∑ i=1 γi−1Rt+i ,\nwhere Rt+1 is the reward received after taking action At in state St. Some MDPs contain special states called terminal states. After reaching a terminal state, no further reward is obtained and no further state transitions occur. Hence, a terminal state can be interpreted as a state where each action returns to itself with a reward of 0. An interaction sequence from the initial state to a terminal state is called an episode.\nEach policy π has a corresponding state-value function vπ, which maps any state s ∈ S to the expected value of the return from that state, when following policy π:\nvπ(s) := E{Gt |St = s, π} .\nIn addition, the action-value function qπ gives the expected return for policy π, given that action a ∈ A is taken in state s ∈ S:\nqπ(s, a) := E{Gt |St = s,At,= a, π} .\n1. An exception to this convention is the TD error, a scalar-valued random variable that we indicate by δt.\nBecause no further rewards can be obtained from a terminal state, the state-value and action-values for a terminal state are always 0.\nThere are two tasks that are typically associated with an MDP. First, there is the task of determining (an estimate of) the value function vπ for some given policy π. The second, more challenging task is that of determining (an estimate of) the optimal policy π∗, which is defined as the policy whose corresponding value function has the highest value in each state:\nvπ∗(s) := maxπ vπ(s) , for each s ∈ S .\nIn RL, these two tasks are considered under the condition that the reward function r and the transition-probability function p are unknown. Hence, the tasks have to be solved using samples obtained from interacting with the environment."
    }, {
      "heading" : "2.2 Temporal-Difference Learning",
      "text" : "Let’s consider the task of learning an estimate V of the value function vπ from samples, where vπ is being estimated using linear function approximation. That is, V is the inner product between a feature vector φ(s) ∈ Rn of s, and a weight vector θ ∈ Rn:\nV (s,θ) = θ>φ(s) .\nIf s is a terminal state, then by definition φ(s) := 0, and hence V (s,θ) = 0. We can formulate the problem of estimating vπ as an error-minimization problem, where the error is a weighted average of the squared difference between the value of a state and its estimate:\nE(θ) := 1\n2 ∑ i dπ(si) ( vπ(si)− θ>φ(si) )2 ,\nwith dπ the stationary distribution induced by π. The above error function can be minimized by using stochastic gradient descent while sampling from the stationary distribution, resulting in the following update rule:\nθt+1 = θt − α 1 2 ∇θ ( vπ(St)− θ>φt )2 ,\nusing φt as a shorthand for φ(St). The parameter α is called the step-size. Using the chain rule, we can rewrite this update as:\nθt+1 = θt + α ( vπ(St)− θ>φt ) ∇θ(θ>φt) ,\n= θt + α ( vπ(St)− θ>φt ) φt .\nBecause vπ is in general unknown, an estimate Ut of vπ(St) is used, which we call the update target, resulting in the following general update rule:\nθt+1 = θt + α ( Ut − θ>φt ) φt . (1)\nThere are many different update targets possible. For an unbiased estimator the full return can be used, that is, Ut = Gt. However, the full return has the disadvantage that its\nvariance is typically very high. Hence, learning with the full return can be slow. Temporaldifference (TD) learning addresses this issue by using update targets based on other value estimates. While the update target is no longer unbiased in this case, the variance is typically much smaller, and learning much faster. TD learning uses the Bellman equations as its mathematical foundation for constructing update targets. These equations relate the value of a state to the values of its successor states:\nvπ(s) = ∑ a π(s, a) ∑ s′ p(s′|s, a) ( r(s, a, s′) + γ vπ(s ′) ) .\nWriting this equation in terms of an expectation yields:\nvπ(s) = E{Rt+1 + γvπ(St+1)|St = s}π,p,r .\nSampling from this expectation, while using linear function approximation to approximate vπ, results in the update target:\nUt = Rt+1 + γ θ >φt+1 .\nThis update target is called a one-step update target, because it is based on information from only one time step ahead. Applying the Bellman equation multiple times results in update targets based on information further ahead. Such update targets are called multistep update targets."
    }, {
      "heading" : "2.3 TD(λ)",
      "text" : "The TD(λ) algorithm implements the following update equations:\nδt = Rt+1 + γθ > t φt+1 − θ>t φt , (2) et = γλet−1 + φt , (3)\nθt+1 = θt + αδt et , (4)\nfor t ≥ 0, and with e−1 = 0. The scalar δt is called the TD error, and the vector et is called the eligibility-trace vector. The update of et shown above is referred to as the accumulatingtrace update. As a shorthand, we will refer to this version of TD(λ) as ‘accumulate TD(λ)’, to distinguish it from a slightly different version that is discussed below. While these updates appear to deviate from the general, gradient-descent-based update rule given in (1), there is a close connection to this update rule. This connection is formalized through the forward view of TD(λ), which we discuss in detail in the next section. Algorithm 1 shows the pseudocode for accumulate TD(λ).\nAccumulate TD(λ) can be very sensitive with respect to the α and λ parameters. Especially, a large value of λ combined with a large value of α can easily cause divergence, even on simple tasks with bounded rewards. For this reason, a variant of TD(λ) is sometimes used that is more robust with respect to these parameters. This variant, which assumes binary features, uses a different trace-update equation:\net[i] =\n{ γλet−1[i] , if φt[i] = 0;\n1 , if φt[i] = 1 , for all features i .\nAlgorithm 1 accumulate TD(λ)\nINPUT: α, λ, γ,θinit θ ← θinit Loop (over episodes):\nobtain initial φ e← 0 While terminal state has not been reached, do:\nobtain next feature vector φ′ and reward R δ ← R+ γ θ>φ′ − θ>φ e← γλe+ φ θ ← θ + αδe φ← φ′\nwhere x[i] indicates the i-th component of vector x. This update is referred to as the replacing-trace update. As a shorthand, we will refer to the version of TD(λ) using the replacing-trace update as ‘replace TD(λ)’."
    }, {
      "heading" : "3. The Online Forward View",
      "text" : "The traditional forward view relates the TD(λ) update equations to the general update rule shown in Equation (1). Specifically, for small step-sizes the weight vector at the end of an episode computed by accumulate TD(λ) is approximately the same as the weight vector resulting from a sequence of Equation (1) updates (one for each visited state) using a particular multi-step update target, called the λ-return (Sutton & Barto, 1998; Bertsekas & Tsitsiklis, 1996). The λ-return for state St is defined as:\nGλt := (1− λ) T−t−1∑ n=1 λn−1G (n) t + λ T−t−1Gt , (5)\nwhere T is the time step the terminal state is reached, and G (n) t is the n-step return, defined as:\nG (n) t := n∑ k=1 γk−1Rt+k + γ n V (St+n|θt+n−1).\nWe call a method that updates the value of each visited state at the end of the episode an offline method; we call a method that updates the value of each visited state immediately after the visit (i.e., at the time step after the visit) an online method. TD(λ) is an online method. The update sequence of the traditional forward view, however, corresponds with an offline method, because the λ-return requires data up to the end of an episode. This leaves open the question of how to interpret the weights of TD(λ) during an episode. In this section, we provide an answer to this long-standing open question. We introduce a bounded version of the λ-return that only uses information up to a certain horizon and we use this to construct an online forward view. This online forward view approximates the weight vectors of accumulate TD(λ) at all time steps, instead of only at the end of an episode."
    }, {
      "heading" : "3.1 The Online λ-Return Algorithm",
      "text" : "The concept of an online forward view contains a paradox. On the one hand, multi-step update targets require data from time steps far beyond the time a state is visited; on the other hand, the online aspect requires that the value of a visited state is updated immediately. The solution to this paradox is to assign a sequence of update targets to each visited state. The first update target in this sequence contains data from only the next time step, the second contains data from the next two time steps, the third from the next three time steps, and so on. Now, given an initial weight vector and a sequence of visited states, a new weight vector can be constructed by updating each visited state with an update target that contains data up to the current time step. Below, we formalize this idea.\nWe define the interim λ-return for state Sk with horizon h ∈ N+, h > k as follows:\nG λ|h k := (1− λ) h−k−1∑ n=1 λn−1G (n) k + λ h−k−1G (h−k) k . (6)\nNote that this update target does not use data beyond the horizon h. G λ|h k implicitly defines a sequence of update targets for Sk: {G λ|k+1 k , G λ|k+2 k , G λ|k+3 k , . . . }. As time increases, update targets based on data further away become available for state Sk. At a particular time step t, a new weight vector is computed by performing an Equation (1) update for each visited state using the interim λ-return with horizon t, starting from the initial weight vector θinit. Hence, at time step t, a sequence of t updates occurs. To describe this sequence mathematically, we use weight vectors with two indices: θ tk. The superscript indicates the time step at which the updates are performed (this value corresponds with the horizon of the interim λ-returns that are used in the updates). The subscript is the iteration index of the sequence (it corresponds with the number of updates that have been performed at a particular time step). As an example, the update sequences for the first three time steps are:\nt = 1 : θ11 = θ 1 0 + α ( G λ|1 0 − (θ 1 0) >φ0 ) φ0 ,\nt = 2 : θ21 = θ 2 0 + α ( G λ|2 0 − (θ 2 0) >φ0 ) φ0 ,\nθ22 = θ 2 1 + α ( G λ|2 1 − (θ 2 1) >φ1 ) φ1 ,\nt = 3 : θ31 = θ 3 0 + α ( G λ|3 0 − (θ 3 0) >φ0 ) φ0 ,\nθ32 = θ 3 1 + α ( G λ|3 1 − (θ 3 1) >φ1 ) φ1 , θ33 = θ 3 2 + α ( G λ|3 2 − (θ 3 2) >φ2 ) φ2 ,\nwith θt0 := θinit for all t. More generally, the update sequence at time step t is:\nθtk+1 := θ t k + α ( G λ|t k − (θ t k) >φk ) φk , for 0 ≤ k < t . (7)\nWe define θt (without superscript) as the final weight vector of the update sequence at time t, that is, θt := θ t t. We call the algorithm implementing Equation (7) the online λ-return\nalgorithm. By contrast, we call the algorithm that implements the traditional forward view the offline λ-return algorithm.\nThe update sequence performed by the online λ-return algorithm at time step T (the time step that a terminal state is reached) is very similar to the update sequence performed by the offline λ-return algorithm. In particular, note that G λ|T t and G λ t are the same, under the assumption that the weights used for the value estimates are the same. Because these weights are in practise not exactly the same, there will typically be a small difference.2\nFigure 1 illustrates the difference between the online and offline λ-return algorithm, as well as accumulate TD(λ), by showing the RMS error on a random walk task. The task consists of 10 states laid out in a row plus a terminal state on the left. Each state transitions with 70% probability to its left neighbour and with 30% probability to its right neighbour (or to itself in case of the right-most state). All rewards are 1 and γ = 1. Furthermore, λ = 1 and α = 0.2. The right-most state is the initial state. Whereas the offline λ-return algorithm only makes updates at the end of an episode, the online λ-return algorithm, as well as accumulate TD(λ), make updates at every time step.\nThe comparison on the random walk task shows that accumulate TD(λ) behaves similar to the online λ-return algorithm. In fact, the smaller the step-size, the smaller the difference between accumulate TD(λ) and the online λ-return algorithm. This is formalized by Theorem 1. The proof of the theorem can be found in Appendix A. The theorem uses the term ∆ti, which is defined as:\n∆ti := ( Ḡ λ|t i − θ > 0 φi ) φi ,\nwith Ḡ λ|t i the interim λ-return for state Si with horizon t that uses θ0 for all value evaluations. Note that ∆ti is independent of the step-size.\nTheorem 1 Let θ0 be the initial weight vector, θ td t be the weight vector at time t computed by accumulate TD(λ), and θλt be the weight vector at time t computed by the online λ-return\n2. If λ = 1 there is never a difference because there is no bootstrapping.\nalgorithm. Furthermore, assume that ∑t−1\ni=0 ∆ t i 6= 0. Then, for all time steps t:\n||θtdt − θλt || ||θtdt − θ0|| → 0 , as α→ 0.\nTheorem 1 generalizes the traditional result to arbitrary time steps. The traditional result states that the difference between the weight vector at the end of an episode computed by the offline λ-return algorithm and the weight vector at the end of an episode computed by accumulate TD(λ) goes to 0, if the step-size goes to 0 (Bertsekas & Tsitsiklis, 1996)."
    }, {
      "heading" : "3.2 Comparison to Accumulate TD(λ)",
      "text" : "While accumulate TD(λ) behaves like the online λ-return algorithm for small step-sizes, small step-sizes often result in slow learning. Hence, higher step-sizes are desirable. For higher step-sizes, however, the behaviour of accumulate TD(λ) can be very different from that of the online λ-return algorithm. And as we show in the empirical section of this article (Section 5), when there is a difference, it is almost exclusively in favour of the online λ-return algorithm. In this section, we analyze why the online λ-return algorithm can outperform accumulate TD(λ), using the one-state example shown in the left of Figure 2.\nThe right of Figure 2 shows the RMS error over the first 10 episodes of the one-state example for different step-sizes and λ = 1. While for small step-sizes accumulate TD(λ) behaves indeed like the online λ-return algorithm—as predicted by Theorem 1—, for larger step-sizes the difference becomes huge. To understand the reason for this, we derive an analytical expression for the value at the end of an episode.\nFirst, we consider accumulate TD(λ). Because there is only one state involved, we indicate the value of this state simply by V. The update at the end of an episode is VT = VT−1 + αeT−1δT−1. In our example, δt = 0 for all time steps t, except for t = T − 1, where δT−1 = 1−VT−1. Because δt is 0 for all time steps except the last, VT−1 = V0. Furthermore,\nφt = 1 for all time steps t, resulting in eT−1 = T . Substituting all this in the expression for VT yields:\nVT = V0 + Tα(1− V0) , for accumulate TD(λ). (8)\nSo for accumulate TD(λ), the total value difference is simply a summation of the value difference corresponding to a single update.\nNow, consider the online λ-return algorithm. The value at the end of an episode, VT , is equal to V TT , resulting from the update sequence:\nV Tk+1 = V T k + α(G λ|T k − V T k ) , for 0 ≤ k < T .\nBy incremental substitution, we can directly express VT in terms of the initial value, V0, and the update targets:\nVT = (1− α)TV0 + α(1− α)T−1Gλ|T0 + α(1− α) T−2G λ|T 1 + · · ·+ αG λ|T T−1 .\nBecause G λ|T k = 1 for all k in our example, the weights of all update targets can be added together and the expression can be rewritten as a single pseudo-update, yielding:\nVT = V0 + ( 1− (1− α)T ) · (1− V0) , for the online λ-return algorithm. (9)\nThe term 1− (1− α)T in (9) acts like a pseudo step-size. For larger α or T this pseudo step-size increases in value, but as long as α ≤ 1 the value will never exceed 1. By contrast, for accumulate TD(λ) the pseudo step-size is Tα, which can grow much larger than 1 even for α < 1, causing divergence of values. This is the reason that accumulate TD(λ) can be very sensitive to the step-size and it explains why the optimal step-size for accumulate TD(λ) is much smaller than the optimal step-size for the online λ-return algorithm in Figure 2 (α ≈ 0.15 versus α = 1, respectively). Moreover, because the variance on the pseudo step-size is higher for accumulate TD(λ) the performance at the optimal step-size for accumulate TD(λ) is worse than the performance at the optimal step-size for the online λ-return algorithm."
    }, {
      "heading" : "3.3 Comparison to Replace TD(λ)",
      "text" : "The sensitivity of accumulate TD(λ) to divergence, demonstrated in the previous subsection, has been known for long. In fact, replace TD(λ) was designed to deal with this. But while replace TD(λ) is much more robust with respect to divergence, it also has its limitations. One obvious limitation is that it only applies to binary features, so it is not generally applicable. But even in domains where replace TD(λ) can be applied, it can perform poorly. The reason is that replacing previous trace values, rather than adding to it, reduces the multi-step characteristics of TD(λ).\nTo illustrate this, consider the two-state example shown in the left of Figure 3. It is easy to see that the value of the left-most state is 2 and of the other state is 0. The state representation consists of only a single, binary feature that is 1 in both states and 0 in the terminal state. Because there is only a single feature, the state values cannot be represented exactly. The weight that minimizes the mean squared error assigns a value of 1 to both states, resulting in an RMS error of 1. Now consider the graph shown in the right of Figure\n3, which shows the asymptotic RMS error for different values of λ. The error for accumulate TD(λ) converges to the least mean squares (LMS) error for λ = 1, as predicted by the theory (Dayan, 1992). The online λ-return algorithm has the same convergence behaviour (due to Theorem 1). By contrast, replace TD(λ) converges to the same value as TD(0) for any value of λ. The reason for this behaviour is that because the single feature is active at all time steps, the multi-step behaviour of TD(λ) is fully removed, no matter the value of λ. Hence, replace TD(λ) behaves exactly the same as TD(0) for any value of λ at all time steps. As a result, it also behaves like TD(0) asymptotically.\nThe two-state example very clearly demonstrates that there is a price payed by replace TD(λ) to achieve robustness with respect to divergence: a reduction in multi-step behaviour. By contrast, the online λ-return algorithm, which is also robust to divergence, does not have this disadvantage. Of course, the two-state example, as well as the one-state example from the previous section, are extreme examples, merely meant to illustrate what can go wrong. But in practise, a domain will often have some characteristics of the one-state example and some of the two-state example, which negatively impacts the performance of both accumulate and replace TD(λ)."
    }, {
      "heading" : "4. True Online TD(λ)",
      "text" : "The online λ-return algorithm is impractical on many domains: the memory it uses, as well as the computation required per time step increases linearly with time. Fortunately, it is possible to rewrite the update equations of the online λ-return algorithm to a different set of update equations that can be implemented with a computational complexity that is independent of time. In fact, this alternative set of update equations differs from the update equations of accumulate TD(λ) only by two extra terms, each of which can be computed efficiently. The algorithm implementing these equations is called true online TD(λ) and is discussed below.\nAlgorithm 2 true online TD(λ)\nINPUT: α, λ, γ,θinit θ ← θinit Loop (over episodes):\nobtain initial φ e← 0 ; Vold ← 0 While terminal state has not been reached, do:\nobtain next feature vector φ′ and reward R V ← θ>φ V ′ ← θ>φ′ δ ← R+ γ V ′ − V e← γλe+ φ− αγλ(e>φ)φ θ ← θ + α(δ + V − Vold)e− α(V − Vold)φ Vold ← V ′ φ← φ′"
    }, {
      "heading" : "4.1 The Algorithm",
      "text" : "For the online λ-return algorithm, at each time step a sequence of updates is performed. The length of this sequence, and hence the computation per time step, increases over time. However, it is possible to compute the weight vector resulting from the sequence at time step t+ 1 directly from the weight vector resulting from the sequence at time step t. This results in the following update equations (see Appendix B for the derivation):\nδt = Rt+1 + γθ > t φt+1 − θ>t φt , (10)\net = γλet−1 + φt − αγλ(e>t−1φt)φt , (11) θt+1 = θt + αδt et + α(θ > t φt − θ>t−1φt)(et − φt) , (12)\nfor t ≥ 0, and with e−1 = 0. Compared to accumulate TD(λ), both the trace update and the weight update have an additional term. We call a trace updated in this way a dutch trace; we call the term α(θ>t φt − θ>t−1φt)(et − φt) the TD-error time-step correction, or simply the δ-correction. Algorithm 2 shows pseudocode that implements these equations.3\nIn terms of computation time, true online TD(λ) has a (slightly) higher cost due to the two extra terms that have to be accounted for. While the computation-time complexity of true online TD(λ) is the same as that of accumulate/replace TD(λ)—O(n) per time step with n being the number of features—, the actual computation time can be close to twice as much in some cases. In other cases (for example if sparse feature vectors are used), the computation time of true online TD(λ) is only a fraction more than that of accumulate/replace TD(λ). In terms of memory, true online TD(λ) has the same cost as accumulate/replace TD(λ).\n3. When using a time-dependent step-size (e.g., when annealing the step-size) use the pseudocode from Section 6.1. For reasons explained in that section this requires a modified trace update. That pseudocode is the same as the pseudocode from van Seijen & Sutton (2014)."
    }, {
      "heading" : "4.2 When Can a Performance Difference be Expected?",
      "text" : "In Section 3, a number of examples were shown where the online λ-return algorithm outperforms accumulate/replace TD(λ). Because true online TD(λ) is simply an efficient implementation of the online λ-return algorithm, true online TD(λ) will outperform accumulate/replace TD(λ) on these examples as well. But not in all cases will there be a performance difference. For example, it follows from Theorem 1 that when appropriately small step-sizes are used, the difference between the online λ-return algorithm/true online TD(λ) and accumulate TD(λ) is negligible. In this section, we identify two other factors that affect whether or not there will be a performance difference. While the focus of this section is on performance difference rather than performance advantage, our experiments will show that true online TD(λ) performs always at least as well as accumulate TD(λ) and replace TD(λ). In other words, our experiments suggest that whenever there is a performance difference, it is in favour of true online TD(λ).\nThe first factor is the λ parameter and follows straightforwardly from the true online TD(λ) update equations.\nProposition 1 For λ = 0, accumulate TD(λ), replace TD(λ) and the online λ-return algorithm / true online TD(λ) behave the same.\nProof For λ = 0, the accumulating-trace update, the replacing-trace update and the dutch-trace update all reduce to et = φt. In addition, because et = φt, the δ-correction of true online TD(λ) is 0.\nBecause the behaviour of TD(λ) for small λ is close to the behaviour of TD(0), it follows that significant performance differences will only be observed when λ is large.\nThe second factor is related to how often a feature has a non-zero value. We start again with a proposition that highlights a condition under which the different TD(λ) versions behave the same. The proposition makes use of an accumulating trace at time step t − 1, eacct−1, whose non-recursive form is:\neacct−1 = t−1∑ k=0 (γλ)t−1−kφk . (13)\nFurthermore, the proposition uses x[i] to denote the i-th element of vector x.\nProposition 2 If for all features i and at all time steps t\neacct−1[i] · φt[i] = 0 , (14)\nthen accumulate TD(λ), replace TD(λ) and the online λ-return algorithm / true online TD(λ) behave the same (for any λ).\nProof Condition (14) implies that if φt[i] 6= 0, then eacct−1[i] = 0. From this it follows that for binary features the accumulating-trace update can be written as a replacing-trace update at every time step:\neacct [i] := γλe acc t−1[i] + φt[i] ,\n=\n{ γλeacct−1[i] , if φt[i] = 0;\n1 , if φt[i] = 1 .\nHence, accumulate TD(λ) and replace TD(λ) perform exactly the same updates. Furthermore, condition (14) implies that (eacct−1)\n>φt = 0. Hence, the accumulating-trace update can also be written as a dutch trace update at every time step:\neacct := γλe acc t−1 + φt ,\n= γλeacct−1 + φt − αγλ((eacct−1)>φt)φt .\nIn addition, note that the δ-correction is proportional to θ>t φt−θ>t−1φt, which can be written as ( θt − θt−1 )> φt. The value ( θt − θt−1 )> φt is proportional to (e acc t−1)\n>φt for accumulate TD(λ). Because (eacct−1)\n>φt = 0, accumulate TD(λ) can add a δ-correction at every time step without any consequence. This shows that accumulate TD(λ) makes the same updates as true online TD(λ).\nAn example of a domain where the condition of Proposition 2 holds is a domain with tabular features (each state is represented with a unique standard-basis vector), where a state is never revisited within the same episode.\nThe condition of Proposition 2 holds approximately when the value ∣∣eacct−1[i] · φt[i]∣∣ is close to 0 for all features at all time steps. In this case, the different TD(λ) versions will perform very similarly. It follows from Equation (13) that this is the case when there is a long time delay between the time steps that a feature has a non-zero value. Specifically, if there is always at least n time steps between two subsequent times that a feature i has a non-zero value with γλn being very small, then\n∣∣eacct−1[i] · φt[i]∣∣ will always be close to 0. Therefore, in order to see a large performance difference, the same features should have a non-zero value often and within a small time frame (relative to γλ).\nSummarizing the analysis so far: in order to see a performance difference α and λ should be sufficiently large, and the same features should have a non-zero value often and within a small time frame. Based on this summary, we can address a related question: on what type of domains will there be a performance difference between true online TD(λ) with optimized parameters and accumulate/replace TD(λ) with optimized parameters. The first two conditions suggest that the domain should result in a relatively large optimal α and optimal λ. This is typically the case for domains with a relatively low variance on the return. The last condition can be satisfied in multiple ways. It is for example satisfied by domains that have non-sparse feature vectors (that is, domains for which at any particular time step most features have a non-zero value)."
    }, {
      "heading" : "4.3 True Online Sarsa(λ)",
      "text" : "TD(λ) and true online TD(λ) are policy evaluation methods. However, they can be turned into control methods in a straightforward way. From a learning perspective, the main difference is that the prediction of the expected return should be conditioned on the state and action, rather than only on the state. This means that an estimate of the action-value function qπ is being learned, rather than of the state-value function vπ.\nAnother difference is that instead of having a fixed policy that generates the behaviour, the policy depends on the action-value estimates. Because these estimates typically improve over time, so does the policy. The (on-policy) control counterpart of TD(λ) is the popular Sarsa(λ) algorithm. The control counterpart of true online TD(λ) is ‘true online Sarsa(λ)’. Algorithm 3 shows pseudocode for true online Sarsa(λ).\nAlgorithm 3 true online Sarsa(λ)\nINPUT: α, λ, γ,θinit θ ← θinit Loop (over episodes):\nobtain initial state S select action A based on state S (for example -greedy) ψ ← features corresponding to S,A e← 0 ; Qold ← 0 While terminal state has not been reached, do:\ntake action A, observe next state S′ and reward R select action A′ based on state S′ ψ′ ← features corresponding to S′, A′ (if S′ is terminal state, ψ′ ← 0) Q← θ>ψ Q′ ← θ>ψ′ δ ← R+ γ Q′ −Q e← γλe+ψ − αγλ(e>ψ)ψ θ ← θ + α(δ +Q−Qold) e− α(Q−Qold)ψ Qold ← Q′ ψ ← ψ′ ; A← A′\nTo ensure accurate estimates for all state-action values are obtained, typically some exploration strategy has to be used. A simple, but often sufficient strategy is to use an -greedy behaviour policy. That is, given current state St, with probability a random action is selected, and with probability 1− the greedy action is selected:\nAgreedyt = arg maxa θ>t ψ(St, a) ,\nwith ψ(s, a) an action-feature vector, and θ>t ψ(s, a) a (linear) estimate of qπ(s, a) at time step t. A common way to derive an action-feature vector ψ(s, a) from a state-feature vector φ(s) involves an action-feature vector of size n|A|, where n is the number of state features and |A| is the number of actions. Each action corresponds with a block of n features in this action-feature vector. The features in ψ(s, a) that correspond to action a take on the values of the state features; the features corresponding to other actions have a value of 0."
    }, {
      "heading" : "5. Empirical Study",
      "text" : "This section contains our main empirical study, comparing TD(λ), as well as Sarsa(λ), with their true online counterparts. For each method and each domain, a scan over the step-size α and the trace-decay parameter λ is performed such that the optimal performance can be compared. In Section 5.4, we discuss the results."
    }, {
      "heading" : "5.1 Random MRPs",
      "text" : "For our first series of experiments we used randomly constructed Markov reward processes (MRPs).4 An MRP can be interpreted as an MDP with only a single action per state. Consequently, there is only one policy possible. We represent a random MRP as a 3-tuple (k, b, σ), consisting of k, the number of states; b, the branching factor (that is, the number of next states with a non-zero transition probability); and σ, the standard deviation of the reward. An MRP is constructed as follows. The b potential next states for a particular state are drawn from the total set of states at random, and without replacement. The transition probabilities to those states are randomized as well (by partitioning the unit interval at b− 1 random cut points). The expected value of the reward for a transition is drawn from a normal distribution with zero mean and unit variance. The actual reward is drawn from a normal distribution with a mean equal to this expected reward and standard deviation σ. There are no terminal states.\nWe compared the performance of TD(λ) on three different MRPs: one with a small number of states, (10, 3, 0.1), one with a larger number of states, (100, 10, 0.1), and one with a larger number of states but a low branching factor and no stochasticity for the reward, (100, 3, 0). The discount factor γ is 0.99 for all three MRPs. Each MRP is evaluated using three different representations. The first representation consists of tabular features, that is, each state is represented with a unique standard-basis vector of k dimensions. The second representation is based on binary features. This binary representation is constructed by first assigning indices, from 1 to k, to all states. Then, the binary encoding of the state index is used as a feature vector to represent that state. The length of a feature vector is determined by the total number of states: for k = 10, the length is 4; for k = 100, the length is 7. As an example, for k = 10 the binary feature vectors of states 1, 2 and 3 are (0, 0, 0, 1),(0, 0, 1, 0) and (0, 0, 1, 1), respectively. Finally, the third representation uses non-binary features. For this representation each state is mapped to a 5-dimensional feature vector, with the value of each feature drawn from a normal distribution with zero mean and unit variance. After all the feature values for a state are drawn, they are normalized such that the feature vector has unit length. Once generated, the feature vectors are kept fixed for each state. Note that replace TD(λ) cannot be used with this representation, because replacing traces are only defined for binary features (tabular features are a special case of this).\nIn each experiment, we performed a scan over α and λ. Specifically, between 0 and 0.1, α is varied according to 10i with i varying from -3 to -1 with steps of 0.2, and from 0.1 to 2.0 (linearly) with steps of 0.1. In addition, λ is varied from 0 to 0.9 with steps of 0.1 and from 0.9 to 1.0 with steps of 0.01. The initial weight vector is the zero vector in all domains. As performance metric we used the mean-squared error (MSE) with respect to the LMS solution during early learning (for k = 10, we averaged over the first 100 time steps; for k = 100, we averaged over the first 1000 time steps). We normalized this error by dividing it by the MSE under the initial weight estimate.\nFigure 4 shows the results for different λ at the best value of α. In Appendix C, the results for all α values are shown. The optimal performance of true online TD(λ) is at\n4. The code for the MRP experiments is published online at: https://github.com/armahmood/ totd-rndmdp-experiments. The process we used to construct the MRPs is based on the process used by Bhatnagar, Sutton, Ghavamzadeh and Lee (2009).\nleast as good as the optimal performance of accumulate TD(λ) and replace TD(λ), on all domains and for all representations. A more in-depth discussion of these results is provided in Section 5.4."
    }, {
      "heading" : "5.2 Predicting Signals From a Myoelectric Prosthetic Arm",
      "text" : "In this experiment, we compared the performance of true online TD(λ) and TD(λ) on a real-world data-set consisting of sensorimotor signals measured during the human control of an electromechanical robot arm. The source of the data is a series of manipulation tasks performed by a participant with an amputation, as presented by Pilarski et al. (2013). In this study, an amputee participant used signals recorded from the muscles of their residual limb to control a robot arm with multiple degrees-of-freedom (Figure 5). Interactions of this kind are known as myoelectric control (see, for example, Parker et al., 2006).\nFor consistency and comparison of results, we used the same source data and prediction learning architecture as published in Pilarski et al. (2013). In total, two signals are predicted: grip force and motor angle signals from the robot’s hand. Specifically, the target for the prediction is a discounted sum of each signal over time, similar to return predictions (see\nFigure 5: Source of the input data stream and predicted signals used in this experiment: a participant with an amputation performing a simple grasping task using a myoelectrically controlled robot arm, as described in Pilarski et al. (2013). More detail on the subject and experimental setting can be found in Hebert et al. (2014).\ngeneral value functions and nexting; Sutton et al., 2011; Modayil et al., 2014). Where possible, we used the same implementation and code base as Pilarski et al. (2013). Data for this experiment consisted of 58,000 time steps of recorded sensorimotor information, sampled at 40 Hz (i.e., approximately 25 minutes of experimental data). The state space consisted of a tile-coded representation of the robot gripper’s position, velocity, recorded gripping force, and two muscle contraction signals from the human user. A standard implementation of tile-coding was used, with ten bins per signal, eight overlapping tilings, and a single active bias unit. This results in a state space with 800,001 features, 9 of which were active at any given time. Hashing was used to reduce this space down to a vector of 200,000 features that are then presented to the learning system. All signals were normalized between 0 and 1 before being provided to the function approximation routine. The discount factor for predictions of both force and angle was γ = 0.97, as in the results presented by Pilarski et al. (2013). Parameter sweeps over λ and α are conducted for all three methods. The performance metric is the mean absolute return error over all 58,000 time steps of learning, normalized by dividing by the error for λ = 0.\nFigure 6 shows the performance for the angle as well as the force predictions at the best α value for different values of λ. In Appendix D, the results for all α values are shown. The relative performance of replace TD(λ) and accumulate TD(λ) depends on the predictive question being asked. For predicting the robot’s grip force signal—a signal with small magnitude and rapid changes—replace TD(λ) is better than accumulate TD(λ) at all λ values larger than 0. However, for predicting the robot’s hand actuator position, a smoothly changing signal that varies between a range of ∼300–500, accumulate TD(λ) dominates replace TD(λ). On both prediction tasks, true online TD(λ) dominates accumulate TD(λ) and replace TD(λ).\nTrue Online Temporal-Difference Learning van Seijen, Sutton\nRTraces\nATraces\nFigure 5: Analysis of TOTD with respect to accumulating and replacing traces on prosthetic data from the single amputee subject described in Pilarski et al. (2013), for the prediction of servo motor angle (left column) and grip force (right column) as recorded from the amputee’s myoelectrically controlled robot arm during a grasping task."
    }, {
      "heading" : "5.3 Control in the ALE Domain Asterix",
      "text" : "In this final experiment, we compared the performance of true online Sarsa(λ) with that of accumulate Sarsa(λ) and replace Sarsa(λ), on a domain from the Arcade Learning Environment (ALE) (Bellemare et al., 2013; Defazio & Graepel, 2014; Mnih et al., 2015), called Asterix. The ALE is a general testbed that provides an interface to hundreds of Atari 2600 games.5\nIn the Asterix domain, the agent controls a yellow avatar, which has to collect ‘potion’ objects, while avoiding ‘harp’ objects (see Figure 7 for a screenshot). Both potions and harps move across the screen horizontally. Every time the agent collects a potion it receives a reward of 50 points, and every time it touches a harp it looses a life (it has three lives in total). The agent can use the actions up, right, down, and left, combinations of two directions, and a no-op action, resulting in 9 actions in total. The game ends after the agent has lost three lives, or after 5 minutes, whichever comes first.\nWe use linear function approximation using features derived from the screen pixels. Specifically, w use what Bellemare et al. (2013) call th Basic feature set, which “encodes\n5. We used ALE version 0.4.4 for our experiments. The code for the Asterix experiments is published online at: https://github.com/mcmachado/TrueOnlineSarsa.\n19\nthe presence of colours on the Atari 2600 screen.” It is obtained by first subtracting the game screen background (see Bellemare et al., 2013, sec. 3.1.1) and then dividing the remaining screen in to 16 × 14 tiles of size 10 × 15 pixels. Finally, for each tile, one binary feature is generated for each of the 128 available colours, encoding whether a colour is active or not in that tile. This generates 28,672 features (plus a bias term).\nBecause episode lengths can vary hugely (from about 10 seconds all the way up to 5 minutes), constructing a fair performance metric is non-trivial. For example, comparing the average return on the first N episodes of two methods is only fair if they have seen roughly the same amount of samples in those episodes, which is not guaranteed for this domain. On the other hand, looking at the total reward collected for the first X samples is also not a good metric, because there is no negative reward associated to dying. To resolve this, we look at the return per episode, averaged over the first X samples. More specifically, our metric consists of the average score per episode while learning for 20 hours (4,320,000 frames). In addition, we averaged the resulting number over 400 independent runs.\nAs with the evaluation experiments, we performed a scan over the step-size α and the trace-decay parameter λ. Specifically, we looked at all combinations of α ∈ {0.20, 0.50, 0.80, 1.10, 1.40, 1.70, 2.00} and λ ∈ {0.00, 0.50, 0.80, 0.90, 0.95, 0.99} (these values were determined during a preliminary parameter sweep). We used a discount factor γ = 0.999 and -greedy exploration with = 0.01. The weight vector was initialized to the zero vector. Also, as Bellemare et al. (2013), we take an action at each 5 frames. This decreases the algorithms running time and avoids “super-human” reflexes. The results are shown in Figure 8. On this domain, the optimal performance of all three versions of Sarsa(λ) is similar.\nNote that the way we evaluate a domain is computationally very expensive: we perform scans over λ and α, and use a large number of independent runs to get a low standard error. In the case of Asterix, this results in a total of 7 · 6 · 400 = 16, 800 runs per method. This\nrigorous evaluation prohibits us unfortunately to run experiments on the full suite of ALE domains."
    }, {
      "heading" : "5.4 Discussion",
      "text" : "Figure 9 summarizes the performance of the different TD(λ) versions on all evaluation domains. Specifically, it shows the error for each method at its best settings of α and λ. The error is normalized by dividing it by the error at λ = 0 (remember that all versions of TD(λ) behave the same for λ = 0). Because λ = 0 lies in the parameter range that is being optimized over, the normalized error can never be higher than 1. If for a method/domain the normalized error is equal to 1, this means that setting λ higher than 0 either has no effect, or that the error gets worse. In either case, eligibility traces are not effective for that method/domain.\nOverall, true online TD(λ) is clearly better than accumulate TD(λ) and replace TD(λ) in terms of optimal performance. Specifically, for each considered domain/representation, the error for true online TD(λ) is either smaller or equal to the error of accumulate/replace TD(λ). This is especially impressive, given the wide variety of domains, and the fact that the computational overhead for true online TD(λ) is small (see Section 4.1 for details).\nThe observed performance differences correspond well with the analysis from Section 4.2. In particular, note that MRP (10, 3, 0.1) has less states than the other two MRPs, and hence the chance that the same feature has a non-zero value within a small time frame is larger. The analysis correctly predicts that this results in larger performance differences. Furthermore, MRP (100, 3, 0) is less stochastic than MRP (100, 10, 0.1), and hence it has a smaller variance on the return. Also here, the experiments correspond with the analysis, which predicts that this results in a larger performance difference.\nOn the Asterix domain, the performance of the three Sarsa(λ) versions is similar. This is in accordance with the evaluation results, which showed that the size of the performance difference is domain dependent. In the worst case, the performance of the true online method is similar to that of the regular method.\nThe optimal performance is not the only factor that determines how good a method is; what also matters is how easy it is to find this performance. The detailed plots in appendices C and D reveal that the parameter sensitivity of accumulate TD(λ) is much higher than that of true online TD(λ) or replace TD(λ). This is clearly visible for MRP (10, 3, 0.1) (Figure 10), as well as the experiments with the myoelectric prosthetic arm (Figure 13).\nThere is one more thing to take away from the experiments. In MRP (10, 3, 0.1) with non-binary features, replace TD(λ) is not applicable and accumulate TD(λ) is ineffective. However, true online TD(λ) was still able to obtain a considerable performance advantage with respect to TD(0). This demonstrates that true online TD(λ) expands the set of domains/representations where eligibility traces are effective. This could potentially have far-reaching consequences. Specifically, using non-binary features becomes a lot more interesting. Replacing traces are not applicable to such representations, while accumulating traces can easily result in divergence of values. For true online TD(λ), however, non-binary features are not necessarily more challenging than binary features. Exploring new, nonbinary representations could potentially further improve the performance for true online TD(λ) on domains such as the myoelectic prosthetic arm or the Asterix domain."
    }, {
      "heading" : "6. Other True Online Methods",
      "text" : "In Appendix B, it is shown that the true online TD(λ) equations can be derived directly from the online forward view equations. By using different online forward views, new true online methods can be derived. Sometimes, small changes in the forward view, like using a time-dependent step-size, can result in surprising changes in the true online equations. In this section, we look at a number of such variations."
    }, {
      "heading" : "6.1 True Online TD(λ) with Time-Dependent Step-Size",
      "text" : "When using a time-dependent step-size in the base equation of the forward view (Equation 7) and deriving the update equations following the procedure from Appendix B, it turns out that a slightly different trace definition appears. We indicate this new trace using a ‘+’ superscript: e+. For fixed step-size, this new trace definition is equal to:\ne+t = αet , for all t.\nOf course, using e+t instead of et also changes the weight vector update slightly. Below, the full set of update equations is shown:\nδt = Rt+1 + γθ > t φt+1 − θ>t φt ,\ne+t = γλe + t−1 + αtφt − αtγλ ( (e+t−1) >φt ) φt ,\nθt+1 = θt + δt e + t + ( θ>t φt − θ>t−1φt )( e+t − αtφt ) .\nIn addition, e+−1 := 0. We can simplify the weight update equation slightly, by using\nδ′t = δt + θ > t φt − θ>t−1φt ,\nAlgorithm 4 true online TD(λ) with time-dependent step-size\nINPUT: λ,θinit, αt for t ≥ 0 θ ← θinit ; t← 0 Loop (over episodes):\nobtain initial φ e+ ← 0 ; Vold ← 0 While terminal state is not reached, do:\nobtain next feature vector φ′ and reward R V ← θ>φ V ′ ← θ>φ′ δ′ ← R+ γ V ′ − Vold e+ ← γλe+ + αtφ− αtγλ((e+)>φ)φ θ ← θ + δ′e+ − αt(V − Vold)φ Vold ← V ′ φ← φ′ t← t+ 1\nwhich changes the update equations to:6\nδ′t = Rt+1 + γθ > t φt+1 − θ>t−1φt , (15)\ne+t = γλe + t−1 + αtφt − αtγλ ( (e+t−1) >φt ) φt , (16)\nθt+1 = θt + δ ′ t e + t − αt ( θ>t φt − θ>t−1φt ) φt . (17)\nAlgorithm 2 shows the corresponding pseudocode. Of course, this pseudocode can also be used for constant step-size."
    }, {
      "heading" : "6.2 True Online Version of Watkins’s Q(λ)",
      "text" : "So far, we just considered on-policy methods, that is, methods that evaluate a policy that is the same as the policy that generates the samples. However, the true online principle can also be applied to off-policy methods, for which the evaluation policy is different from the behaviour policy. As a simple example, consider Watkins’s Q(λ) (Watkins, 1989). This is an off-policy method that evaluates the greedy policy given an arbitrary behaviour policy. It does this by combining accumulating traces with a TD error that uses the maximum state-action value of the successor state:\nδt = Rt+1 + max a\nQ(St, a)−Q(St, At) .\nIn addition, traces are reset to 0 whenever a non-greedy action is taken.\nFrom an online forward-view perspective, the strategy of Watkins’s Q(λ) method can be interpreted as a growing update target that stops growing once a non-greedy action is taken. Specifically, let τ be the first time step after time step t that a non-greedy action is\n6. These equations are the same as in the original true online paper (van Seijen & Sutton, 2014).\nAlgorithm 5 true online version of Watkins’s Q(λ)\nINPUT: α, λ, γ,θinit,Ψ θ ← θinit Loop (over episodes):\nobtain initial state S select action A based on state S (for example -greedy) ψ ← features corresponding to S,A e← 0 ; Qold ← 0 While terminal state has not been reached, do:\ntake action A, observe next state S′ and reward R select action A′ based on state S′ A∗ ← arg maxa θ>ψ(S′, a) (if A′ ties for the max, then A∗ ← A′) ψ′ ← features corresponding to S′, A∗ (if S′ is terminal state, ψ′ ← 0) Q← θ>ψ Q′ ← θ>ψ′ δ ← R+ γ Q′ −Q e← γλe+ψ − αγλ ( e>ψ ) ψ θ ← θ + α(δ +Q−Qold) e− α(Q−Qold)ψ if A′ 6= A∗ : e← 0 Qold ← Q′ ψ ← ψ′ ; A← A′\ntaken, then the interim update target for time step t can be defined as:\nUht := (1− λ) z−t−1∑ n=1 λn−1G̃ (n) t + λ z−t−1G̃ (z−t) t , z = min{h, τ} ,\nwith\nG̃ (n) t = n∑ k=1 γk−1Rt+k + γ n max a θ>t+n−1ψ(St+n, a) .\nAlgorithm 5 shows the pseudocode for the true online method that corresponds with this update target definition. A problem with Watkins’s Q(λ) is that if the behaviour policy is very different from the greedy policy traces are reset very often, reducing the overall effect of the traces. In Section 7, we discuss more advanced off-policy methods."
    }, {
      "heading" : "6.3 Tabular True Online TD(λ)",
      "text" : "Tabular features are a special case of linear function approximation. Hence, the update equations for true online TD(λ) that are presented so far also apply to the tabular case. However, we discuss it here separately, because the simplicity of this special case can provide extra insight.\nAlgorithm 6 tabular true online TD(λ)\ninitialize v(s) for all s Loop (over episodes):\ninitialize S e(s)← 0 for all s Vold ← 0 While S is not terminal, do:\nobtain next state S′ and reward R ∆V ← V (S)− Vold Vold ← V (S′) δ ← R+ γ V (S′)− V (S) e(S)← (1− α)e(S) + 1 For all s:\nV (s)← V (s) + α(δ + ∆V )e(s) e(s)← γλe(s)\nV (S)← V (S)− α∆V S ← S′\nRewriting the true online update equations (equations 10 – 12) for the special case of tabular features results in:\nδt = Rt+1 + γVt(St+1)− Vt(St) ,\net(s) = { γλet−1(s) , if s 6= St ; (1− α)γλet−1(s) + 1 , if s = St ,\nVt+1(s) =\n{ Vt(s) + α ( δt + Vt(St)− Vt−1(St) ) et(s) , if s 6= St ;\nVt(s) + α ( δt + Vt(St)− Vt−1(St) ) et(s)− α ( Vt(St)− Vt−1(St) ) , if s = St .\nWhat is interesting about the tabular case is that the dutch-trace update reduces to a particularly simple form. In fact, for the tabular case, a dutch-trace update is equal to the weighted average between an accumulating-trace update and a replacing-trace update, with the weight of the former (1 − α) and the latter α. Algorithm 6 shows the corresponding pseudocode."
    }, {
      "heading" : "7. Related Work",
      "text" : "Since the first publication on true online TD(λ) (van Seijen & Sutton, 2014), several related papers have been published, extending the underlying concepts and improving the presentation. In sections 7.1, 7.2 and 7.3, we review those papers. In Section 7.4, we discuss other variations of TD(λ)."
    }, {
      "heading" : "7.1 True Online Learning and Dutch Traces",
      "text" : "As mentioned before, the traditional forward view, which is based on the λ-return, is inherently an offline forward view, because the λ-return is constructed from data up to the end\nof an episode. As a consequence, the work regarding equivalence between a forward view and a backward view traditionally focused on the final weight vector θT . This changed in 2014, when two papers introduced an online forward view with a corresponding backward view that has an exact equivalence at each moment in time (van Seijen & Sutton, 2014; Sutton et al., 2014). While both papers introduced an online forward view, the two forward views presented are very different from each other. One difference is that the forward view introduced by van Seijen & Sutton is an on-policy forward view, whereas the forward view by Sutton et al. is an off-policy forward view. However, there is an even more fundamental difference related to how the forward views are constructed. In particular, the forward view by van Seijen & Sutton is constructed in such a way that at each moment in time the weight vector can be interpreted as the result of a sequence of updates of the form:\nθk+1 = θk + α ( Uk − θ>k φk ) φk , for 0 ≤ k < t . (18)\nBy contrast, the forward view by Sutton et al. gives the following interpretation:\nθt = θ0 + α t−1∑ k=0 δkφk, (19)\nwith δk some multi-step TD error. Of course, the different forward views also result in different backward views. Whereas the backward view of Sutton et al. uses a generalized version of an accumulating trace, the backward view of van Seijen & Sutton introduced a completely new type of trace.\nThe advantage of a forward view based on (18) instead of (19) is that it results in much more stable updates. In particular, the sensitivity to divergence of accumulate TD(λ) is a general side-effect of (19), whereas (18) is much more robust with respect to divergence. As a result, true online TD(λ) not only has the property that it has an exact equivalence with an online forward view at all times, it consistently dominates TD(λ) empirically.\nThe strong performance of true online TD(λ) motivated van Hasselt et al. (2014) to construct an off-policy version of the forward view of true online TD(λ). The corresponding backward view resulted in the algorithm true online GTD(λ), which empirically outperforms GTD(λ). They also introduced the term ‘dutch traces’ for the new eligiblity trace.\nVan Hasselt & Sutton (2015) showed that dutch traces are not only useful for TD learning. In an offline setting with no bootstrapping using dutch traces can result in certain computational advantages. To understand why, consider the Monte Carlo algorithm (MC), which updates state values at the end of an episode using (18), with the full return as update target. MC requires storing all the feature vectors and rewards during an episode, so the memory complexity is linear in the length of the episode. Moreover, the required computation time is distributed very unevenly: during an episode almost no computation is required, but at the end of an episode there is a huge peak in computation time due to all the updates that need to be performed. With dutch traces an alternative implementation can be made that results in the same final weight vector but that does not require storing all the feature vectors and where the required computation time is spread out evenly over all the time steps. Van Hasselt & Sutton refer to this appealing property as span-independence:\nthe memory and computation time required per time step is constant and independent of the span of the prediction.7"
    }, {
      "heading" : "7.2 Backward View Derivation",
      "text" : "The task of finding an efficient backward view that corresponds exactly with a particular online forward view is not easy. Moreover, there is no guarantee that there exists an efficient implementation of a particular online forward view. Often, minor changes in the forward view determine whether or not an efficient backward view can be constructed. This created the desire to somehow automate the process of constructing an efficient backward view.\nVan Seijen & Sutton (2014) did not provide a direct derivation of the backward view update equations; they simply proved that the forward view and the backward view equations result in the same weight vectors. Sutton et al. (2014) were the first to attempt to come up with a general strategy for deriving a backward view (although for forward views based on Equation 19). Van Hasselt et al. (2014) took the approach of providing a theorem that proves equivalence between a general forward view and a corresponding general backward view. They showed that the forward/backward view of true online TD(λ) is a special case of this general forward/backward view. They showed the same for the off-policy method that they introduced—true online GTD(λ). Recently, Mahmood & Sutton (2015) extended this theorem further by proving equivalence between an even more general forward view and backward view.\nFurthermore, van Hasselt & Sutton (2015) derived backward views for a series of increasingly complex forward views. The derivation of the true online TD(λ) equations in Appendix B is similar to those derivations."
    }, {
      "heading" : "7.3 Extension to Non-Linear Function Approximation",
      "text" : "The linear update equations of the online forward view presented in Section 3.1 can be easily extended to the case of non-linear function approximation. Unfortunately, it appears to be impossible to construct an efficient backward view with exact equivalence in the case of non-linear function approximation. The reason is that the derivation in Appendix B makes use of the fact that the gradient with respect to the value function is independent of the weight vector; this does not hold for non-linear function approximation.\nFortunately, van Seijen (2016) shows that many of the benefits of true online learning can also be achieved in the case of non-linear function approximation by using an alternative forward view (but still based on Equation 18). While this alternative forward view is not fully online (there is a delay in the updates), it can be implemented efficiently."
    }, {
      "heading" : "7.4 Other Variations on TD(λ)",
      "text" : "Several variations on TD(λ) other than those treated in this article have been suggested in the literature. Schapire & Warmuth (1996) introduced a variation of TD(λ) for which upper and lower bounds on performance can be derived and proven. Konidaris et al. (2011) introduced TDγ , a parameter-free alternative to TD(λ) based on a multi-step update target\n7. The span of the prediction refers to the time difference between the first prediction and the moment its target is known (e.g., for episodic tasks it corresponds to the length of an episode).\ncalled the γ-return. TDγ is an offline algorithm with a computational cost proportional to the episode-length. Furthermore, Thomas et al. (2015) proposed a method based on a multi-step update target, which they call the Ω-return. The Ω-return can account for the correlation of different length returns, something that both the λ-return and the γ-return cannot. However, it is expensive to compute and it is open question whether efficient approximations exist."
    }, {
      "heading" : "8. Conclusions",
      "text" : "We tested the hypothesis that true online TD(λ) (and true online Sarsa(λ)) dominates TD(λ) (and Sarsa(λ)) with accumulating as well as with replacing traces by performing experiments over a wide range of domains. Our extensive results support this hypothesis. In terms of learning speed, true online TD(λ) was often better, but never worse than TD(λ) with either accumulating or replacing traces, across all domains/representations that we tried. Our analysis showed that especially on domains with non-sparse features and a relatively low variance on the return a large difference in learning speed can be expected. More generally, true online TD(λ) has the advantage over TD(λ) with replacing traces that it can be used with non-binary features, and it has the advantage over TD(λ) with accumulating traces that it is less sensitive with respect to its parameters. In terms of computation time, TD(λ) has a slight advantage. In the worst case, true online TD(λ) is twice as expensive. In the typical case of sparse features, it is only fractionally more expensive than TD(λ). Memory requirements are the same. Finally, we outlined an approach for deriving new true online methods, based on rewriting the equations of an online forward view. This may lead to new, interesting methods in the future."
    }, {
      "heading" : "Acknowledgments",
      "text" : "The authors thank Hado van Hasselt for extensive discussions leading to the refinement of these ideas. Furthermore, the authors thank the anonymous reviewers for their valuable suggestions, resulting in a substantially improved presentation. This work was supported by grants from Alberta Innovates – Technology Futures and the National Science and Engineering Research Council of Canada. Computing resources were provided by Compute Canada through WestGrid."
    }, {
      "heading" : "Appendix A. Proof of Theorem 1",
      "text" : "Theorem 1 Let θ0 be the initial weight vector, θ td t be the weight vector at time t computed by accumulate TD(λ), and θλt be the weight vector at time t computed by the online λ-return algorithm. Furthermore, assume that ∑t−1 i=0 ∆ t i 6= 0. Then, for all time steps t:\n||θtdt − θλt || ||θtdt − θ0|| → 0 , as α→ 0.\nProof We prove the theorem by showing that ||θtdt −θλt ||/||θtdt −θ0|| can be approximated by O(α)/ ( C + O(α) ) as α → 0, with C > 0. For readability, we will not use the ‘td’ and ‘λ’ superscripts; instead, we always use weights with double indices for the online λ-return algorithm and weights with single indices for accumulate TD(λ).\nThe update equations for accumulate TD(λ) are:\nδt = Rt+1 + γ θ > t φt+1 − θ>t φt , et = γλet−1 + φt ,\nθt+1 = θt + αδt et .\nBy incremental substitution, we can write θt directly in terms of θ0:\nθt = θ0 + α t−1∑ j=0 δjej ,\n= θ0 + α t−1∑ j=0 δj j∑ i=0 (γλ)j−iφi ,\n= θ0 + α t−1∑ j=0 j∑ i=0 (γλ)j−iδj φi .\nUsing the summation rule ∑n\nj=k ∑j i=k ai,j = ∑n i=k ∑n j=i ai,j we can rewrite this as:\nθt = θ0 + α t−1∑ i=0 t−1∑ j=i (γλ)j−iδj φi . (20)\nAs part of the derivation shown in Appendix B, we prove the following (see Equation 26):\nG λ|h+1 i = G λ|h i + (λγ) h−iδ′h ,\nwith δ′h := Rh+1 + γ θ > h φh+1 − θ>h−1φh .\nBy applying this sequentially for i+ 1 ≤ h < t, we can derive:\nG λ|t i = G λ|i+1 i + t−1∑ j=i+1 (γλ)j−iδ′j . (21)\nFurthermore, G λ|i+1 i can be written as:\nG λ|i+1 i = Ri+1 + γθ > i φi+1 ,\n= Ri+1 + γθ > i φi+1 − θ>i−1φi + θ>i−1φi , = δ′i + θ > i−1φi .\nSubstituting this in (21) yields:\nG λ|t i = θ > i−1φi + t−1∑ j=i (γλ)j−iδ′j .\nUsing that δ′j = δj + θ > j φj − θ>j−1φj , it follows that\nt−1∑ j=i (γλ)j−iδj = G λ|t i − θ > i−1φi − t−1∑ j=i (γλ)j−i(θj − θj−1)>φj .\nAs α→ 0, we can approximate this as: t−1∑ j=i (γλ)j−iδj = G λ|t i − θ > i−1φi +O(α) ,\n= Ḡ λ|t i − θ > 0 φi +O(α) ,\nwith Ḡ λ|t i the interim λ-return that uses θ0 for all value evaluations. Substituting this in (20) yields:\nθt = θ0 + α t−1∑ i=0 ( Ḡ λ|t i − θ > 0 φi +O(α) ) φi . (22)\nFor the online λ-return algorithm, we can derive the following by sequential substitution of Equation (7):\nθtt = θ0 + α t−1∑ i=0 ( G λ|t i − (θ t i) >φi ) φi .\nAs α→ 0, we can approximate this as:\nθtt = θ0 + α t−1∑ i=0 ( Ḡ λ|t i − θ > 0 φi +O(α) ) φi . (23)\nCombining (22) and (23), it follows that as α→ 0:\n||θt − θtt|| ||θt − θ0|| = ||(θt − θtt)/α|| ||(θt − θ0)/α|| = O(α) C +O(α) ,\nwith\nC = ∣∣∣∣∣ ∣∣∣∣∣ t−1∑ i=0 ( Ḡ λ|t i − θ > 0 φi ) φi ∣∣∣∣∣ ∣∣∣∣∣ = ∣∣∣∣∣ ∣∣∣∣∣ t−1∑ i=0 ∆ti ∣∣∣∣∣ ∣∣∣∣∣ .\nFrom the condition ∑t−1\ni=0 ∆ t i 6= 0 it follows that C > 0."
    }, {
      "heading" : "Appendix B. Derivation Update Equations",
      "text" : "In this subsection, we derive the update equations of true online TD(λ) directly from the online forward view, defined by equations (6) and (7) (and θt0 := θinit). The derivation is based on expressing θt+1t+1 in terms of θ t t.\nWe start by writing θtt directly in terms of the initial weight vector and the interim λ-returns. First, we rewrite (7) as:\nθtk+1 = (I− αφkφ>k )θtk + αφkG λ|t k ,\nwith I the identity matrix. Now, consider θtk for k = 1 and k = 2:\nθt1 = (I− αφ0φ>0 )θinit + αφ0G λ|t 0 , θt2 = (I− αφ1φ>1 )θt1 + αφ1G λ|t 1 ,\n= (I− αφ1φ>1 )(I− αφ0φ>0 )θinit + α(I− αφ1φ>1 )φ0G λ|t 0 + αφ1G λ|t 1 .\nFor general k ≤ t, we can write:\nθtk = A k−1 0 θinit + α k−1∑ i=0 Ak−1i+1 φiG λ|t i ,\nwhere Aji is defined as:\nAji := (I− αφjφ > j )(I− αφj−1φ>j−1) . . . (I− αφiφ>i ), for j ≥ i ,\nand Ajj+1 := I. We are now able to express θ t t as:\nθtt = A t−1 0 θinit + α t−1∑ i=0 At−1i+1 φiG λ|t i , (24)\nBecause for the derivation of true online TD(λ), we only need (24) and the definition of G λ|t i , we can drop the double indices for the weight vectors and use θt := θ t t.\nWe now derive a compact expression for the difference G λ|t+1 i −G λ|t i :\nG λ|t+1 i −G λ|t i = (1− λ) t−i∑ n=1 λn−1G (n) i + λ t−iG (t+1−i) i ,\n− (1− λ) t−i−1∑ n=1 λn−1G (n) i − λ t−i−1G (t−i) i ,\n= (1− λ)λt−i−1G(t−i)i + λ t−iG (t+1−i) i − λ t−i−1G (t−i) i , = λt−iG (t+1−i) i − λ t−iG (t−i) i ,\n= λt−i ( G\n(t+1−i) i −G (t−i) i\n) ,\n= λt−i ( t+1−i∑\nk=1\nγk−1Ri+k + γ t+1−iθ>t φt+1 − t−i∑ k=1 γk−1Ri+k − γt−iθ>t−1φt ) ,\n= λt−i ( γt−iRt+1 + γ t+1−iθ>t φt+1 − γt−iθ>t−1φt ) ,\n= (λγ)t−i ( Rt+1 + γ θ > t φt+1 − θ>t−1φt ) .\nNote that the difference G λ|t+1 i −G λ|t i is naturally expressed using a term that looks like a TD error but with a modified time step. We call this the modified TD error, δ′t:\nδ′t := Rt+1 + γ θ > t φt+1 − θ>t−1φt.\nThe modified TD error relates to the regular TD error, δt, as follows:\nδ′t = Rt+1 + γ θ > t φt+1 − θ>t−1φt ,\n= Rt+1 + γ θ > t φt+1 − θ>t φt + θ>t φt − θ>t−1φt , = δt + θ > t φt − θ>t−1φt . (25)\nUsing δ′t, the difference G λ|t+1 i −G λ|t i can be compactly written as:\nG λ|t+1 i −G λ|t i = (λγ) t−iδ′t . (26)\nTo get the update rule, θt+1 has to be expressed in terms of θt. This is done below, using (24), (25) and (26):\nθt+1 = A t 0 θ0 + α t∑ i=0 Ati+1φiG λ|t+1 i ,\n= At0θ0 + α t−1∑ i=0 Ati+1φiG λ|t+1 i + αφtG λ|t+1 t ,\n= At0θ0 + α t−1∑ i=0 Ati+1φiG λ|t i + α t−1∑ i=0 Ati+1φi ( G λ|t+1 i −G λ|t i ) + αφtG λ|t+1 t ,\n= (I− αφtφ>t ) ( At−10 θ0 + α t−1∑ i=0 At−1i+1 φiG λ|t i ) +α\nt−1∑ i=0 Ati+1φi ( G λ|t+1 i −G λ|t i ) + αφtG λ|t+1 t ,\n= (I− αφtφ>t )θt + α t−1∑ i=0 Ati+1φi ( G λ|t+1 i −G λ|t i ) + αφtG λ|t+1 t ,\n= (I− αφtφ>t )θt + α t−1∑ i=0 Ati+1φi(γλ) t−iδ′t + αφt ( Rt+1 + γθt >φt+1 ) ,\n= θt + α t−1∑ i=0 Ati+1φi(γλ) t−iδ′t + αφt ( Rt+1 + γθt >φt+1 − θ>t φt ) ,\n= θt + α t−1∑ i=0 Ati+1φi(γλ) t−iδ′t\n+αφt ( Rt+1 + γθt >φt+1 − θ>t−1φt + θ>t−1φt − θ>t φt ) ,\n= θt + α t−1∑ i=0 Ati+1φi(γλ) t−iδ′t + αφtδ ′ t − α ( θ>t φt − θ>t−1φt ) φt ,\n= θt + α t∑ i=0 Ati+1φi(γλ) t−iδ′t − α ( θ>t φt − θ>t−1φt ) φt ,\n= θt + αetδ ′ t − α ( θ>t φt − θ>t−1φt ) φt , with et := t∑ i=0 Ati+1φi(γλ) t−i ,\n= θt + αet ( δt + θ > t φt − θ>t−1φt ) − α ( θ>t φt − θ>t−1φt ) φt ,\n= θt + αetδt + α ( θ>t φt − θ>t−1φt )( et − φt ) . (27)\nWe now have the update rule for θt, in addition to an explicit definition of et. Next, using this explicit definition, we derive an update rule to compute et from et−1:\net = t∑ i=0 Ati+1φi(γλ) t−i ,\n= t−1∑ i=0 Ati+1φi(γλ) t−i + φt ,\n= (I− αφtφ>t )γλ t−1∑ i=0 At−1i+1 φi(γλ) t−i−1 + φt , = (I− αφtφ>t )γλet−1 + φt , = γλet−1 + φt − αγλ(e>t−1φt)φt . (28)\nEquations (27) and (28), together with the definition of δt, form the true online TD(λ) update equations."
    }, {
      "heading" : "Appendix C. Detailed Results Random MRPs",
      "text" : "van Seijen, Mahmood, Pilarski, Machado and Sutton\nAppendix D. Detailed Results for Myoelectric Prosthetic Arm\nvan Seijen, Sutton\nANGLE PREDICTION FORCE PREDICTION\nBEST\nTOTD\nRTraces\nATraces\nFigure 5: Analysis of TOTD with respect to accumulating and replacing traces on prosthetic data from the single amputee subject described in Pilarski et al. (2013), for the prediction of servo motor angle (left column) and grip force (right column) as recorded from the amputee’s myoelectrically controlled robot arm during a grasping task.\n16\nvan Seijen, Sutton ANGLE PREDICTION FORCE PREDICTION BEST\nTOTD\nRTraces\nATraces\nFigure 5: Analysis of TOTD with respect to accumulating and replacing traces on prosthetic data from the single amputee subject described in Pilarski et al. (2013), for the prediction of servo motor angle (left column) and grip force (right column) as recorded from the amputee’s myoelectrically controlled robot arm during a grasping task.\n16\nvan Seijen, Sutton\nANGLE PREDICTION FORCE PREDICTION\nBEST\nTOTD\nraces\nr ces\ni : l sis of ith respect to a cumulating and replacing traces on prosthetic fr t e si gle a putee subject described in Pilarski et al. (2013), for the prediction of\nt r gle (left colu n) and grip force (right column) as recorded from the amput e’s l tric ll contro led robot ar during a grasping task.\n16\nvan Seijen, Sutton\nANGLE PREDICTION FORCE PREDICTION\nBEST\nTOTD\nRTraces\nATraces\nFigure 5: Analysis of TOTD with respect to accumulating and replacing traces on prosthetic data from the single amputee subject described in Pilarski et al. (2013), for the prediction of servo motor angle (left column) and grip force (right column) as recorded from the amputee’s myoelectrically controlled robot arm during a grasping task.\nangle prediction force prediction\nangle prediction, accumulate TD(λ) force prediction, accumulate TD(λ)\nangle prediction, replace TD(λ) force prediction, replace TD(λ)\nangle prediction, true online TD(λ) force prediction, true online TD(λ)\nreplace TD(λ) replace TD(λ)\ntrue online TD(λ) true online TD(λ)\naccumulate TD(λ)\naccumulate TD(λ)\nigure 13: Results on prosthetic data from the single amputee subject described in Pilarski et al. (2013), for the prediction of servo motor angle (left column) and grip force (right column) as recorded from the amputee’s myoelectrically controlled robot arm during a grasping task.\n38"
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "The temporal-difference methods TD(λ) and Sarsa(λ) form a core part of modern reinforcement learning. Their appeal comes from their good performance, low computational cost, and their simple interpretation, given by their forward view. Recently, new versions of these methods were introduced, called true online TD(λ) and true online Sarsa(λ), respectively (van Seijen & Sutton, 2014). Algorithmically, these true online methods only make two small changes to the update rules of the regular methods, and the extra computational cost is negligible in most cases. However, they follow the ideas underlying the forward view much more closely. In particular, they maintain an exact equivalence with the forward view at all times, whereas the traditional versions only approximate it for small step-sizes. We hypothesize that these true online methods not only have better theoretical properties, but also dominate the regular methods empirically. In this article, we put this hypothesis to the test by performing an extensive empirical comparison. Specifically, we compare the performance of true online TD(λ)/Sarsa(λ) with regular TD(λ)/Sarsa(λ) on random MRPs, a real-world myoelectric prosthetic arm, and a domain from the Arcade Learning Environment. We use linear function approximation with tabular, binary, and non-binary features. Our results suggest that the true online methods indeed dominate the regular methods. Across all domains/representations the learning speed of the true online methods are often better, but never worse than that of the regular methods. An additional advantage is that no choice between traces has to be made for the true online methods. Besides the empirical results, we provide an in-depth analysis of the theory behind true online temporal-difference learning. In addition, we show that new true online temporaldifference methods can be derived by making changes to the online forward view and then rewriting the update equations.",
    "creator" : "LaTeX with hyperref package"
  }
}