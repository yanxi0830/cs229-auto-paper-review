{
  "name" : "1107.1283.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Spectral Methods for Learning Multivariate Latent Tree Structure",
    "authors" : [ "Animashree Anandkumar", "Kamalika Chaudhuri", "Daniel Hsu", "Sham M. Kakade", "Le Song", "Tong Zhang" ],
    "emails" : [ "a.anandkumar@uci.edu,", "kamalika@cs.ucsd.edu,", "dahsu@microsoft.com,", "skakade@microsoft.com,", "lesong@cs.cmu.edu,", "tzhang@stat.rutgers.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Graphical models are a central tool in modern machine learning applications, as they provide a natural methodology for succinctly representing high-dimensional distributions. As such, they have enjoyed much success in various AI and machine learning applications such as natural language processing, speech recognition, robotics, computer vision, and bioinformatics.\nThe main statistical challenges associated with graphical models include estimation and inference. While the body of techniques for probabilistic inference in graphical models is rather rich [29], current methods for tackling the more challenging problems of parameter and structure estimation are less developed and understood, especially in the presence of latent (hidden) variables. The problem of parameter estimation involves determining the model parameters from samples of certain observed variables. Here, the predominant approach is the expectation maximization (EM) algorithm, and only rather recently is the understanding of this algorithm improving [10, 5]. The problem of structure learning is to estimate the underlying graph\nE-mail: a.anandkumar@uci.edu, kamalika@cs.ucsd.edu, dahsu@microsoft.com, skakade@microsoft.com, lesong@cs.cmu.edu, tzhang@stat.rutgers.edu\nar X\niv :1\n10 7.\n12 83\nv2 [\ncs .L\nG ]\nof the graphical model. In general, structure learning is NP-hard and becomes even more challenging when some variables are unobserved [6]. The main approaches for structure estimation are either greedy or local search approaches [9, 15] or, more recently, based on convex relaxation [25].\nThis work focuses on learning the structure of multivariate latent tree graphical models. Here, the underlying graph is a directed tree (e.g., hidden Markov model, binary evolutionary tree), and only samples from a set of (multivariate) observed variables (the leaves of the tree) are available for learning the structure. Latent tree graphical models are relevant in many applications, ranging from computer vision, where one may learn object/scene structure from the co-occurrences of objects to aid image understanding [7]; to phylogenetics, where the central task is to reconstruct the tree of life from the genetic material of surviving species [12].\nGenerally speaking, methods for learning latent tree structure exploit structural properties afforded by the tree that are revealed through certain statistical tests over every choice of four variables in the tree. These quartet tests, which have origins in structural equation modeling [30, 3], are hypothesis tests of the relative configuration of four (possibly non-adjacent) nodes/variables in the tree (see Figure 1); they are also related to the four point condition associated with a corresponding additive tree metric induced by the distribution [4]. Some early methods for learning tree structure are based on the use of exact correlation statistics or distance measurements (e.g., [24, 26]). Unfortunately, these methods ignore the crucial aspect of estimation error, which ultimately governs their sample complexity. Indeed, this (lack of) robustness to estimation error has been quantified for various algorithms (notably, for the popular Neighbor Joining algorithm [14, 19]), and therefore serves as a basis for comparing different methods. Subsequent work in the area of mathematical phylogenetics has focused on the sample complexity of evolutionary tree reconstruction [13, 14, 20, 11]. The basic model there corresponds to a directed tree over discrete random variables, and much of the recent effort deals exclusively in the regime for a certain model parameter (the Kesten-Stigum regime [18]) that allows for a sample complexity that is polylogarithmic in the number of leaves, as opposed to polynomial [20, 11]. Finally, recent work in machine learning has developed structure learning methods for latent tree graphical models that extend beyond the discrete distributions of evolutionary trees [8], thereby widening their applicability to other problem domains.\nThis work extends beyond previous studies, which have focused on latent tree models with either discrete or scalar Gaussian variables, by directly addressing the multivariate setting where hidden and observed nodes may be random vectors rather than scalars. The generality of our techniques allows us to handle a much wider class of distributions than before, both in terms of the conditional independence properties imposed by the models (i.e., the random vector associated with a node need not follow a distribution that corresponds to a tree model), as well as other characteristics of the node distributions (e.g., some nodes in the tree could have discrete state spaces and others continuous, as in a Gaussian mixture model).\nWe propose the Spectral Recursive Grouping algorithm for learning multivariate latent tree structure. The algorithm has at its core a multivariate spectral quartet test, which extends the classical quartet tests for scalar variables by applying spectral techniques from multivariate statistics (specifically canonical correlation analysis [2, 22]). Spectral methods have enjoyed recent success in the context of parameter estimation [21, 16, 27, 28]; our work shows that they are also useful for structure learning. We use the spectral quartet test in a simple modification of the recursive grouping algorithm of [8] to perform the tree reconstruction. The algorithm is essentially a robust method for reasoning about the results of quartet tests (viewed simply as hypothesis tests); the tests either confirm or reject hypotheses about the relative topology over quartets of\nvariables. By carefully choosing which tests to consider and properly interpreting their results, the algorithm is able to recover the correct latent tree structure (with high probability) in a provably efficient manner, in terms of both computational and sample complexity. The recursive grouping procedure is similar to the short quartet method from phylogenetics [14], which also guarantees efficient reconstruction in the context of evolutionary trees. However, our method and analysis applies to considerably more general high-dimensional settings; for instance, our sample complexity bound is given in terms of natural correlation conditions that generalize the more restrictive effective depth conditions of previous works [14, 8]. Finally, we note that while we do not directly address the question of parameter estimation, provable parameter estimation methods may derived using the spectral techniques from [21, 16]."
    }, {
      "heading" : "2 Preliminaries",
      "text" : ""
    }, {
      "heading" : "2.1 Latent variable tree models",
      "text" : "Let T be a connected, directed tree graphical model with leaves Vobs := {x1, x2, . . . , xn} and internal nodes Vhid := {h1, h2, . . . , hm} such that every node has at most one parent. The leaves are termed the observed variables and the internal nodes hidden variables. Note that all nodes in this work generally correspond to multivariate random vectors; we will abuse terminology and still refer to these random vectors as random variables. For any h ∈ Vhid, let ChildrenT(h) ⊆ VT denote the children of h in T.\nEach observed variable x ∈ Vobs is modeled as random vector in Rd, and each hidden variable h ∈ Vhid as a random vector in Rk. The joint distribution over all the variables VT := Vobs ∪ Vhid is assumed satisfy conditional independence properties specified by the tree structure over the variables. Specifically, for any disjoint subsets V1, V2, V3 ⊆ VT such that V3 separates V1 from V2 in T, the variables in V1 are conditionally independent of those in V2 given V3."
    }, {
      "heading" : "2.2 Structural and distributional assumptions",
      "text" : "The class of models considered are specified by the following structural and distributional assumptions.\nCondition 1 (Linear conditional means). Fix any hidden variable h ∈ Vhid. For each hidden child g ∈ ChildrenT(h) ∩ Vhid, there exists a matrix A(g|h) ∈ Rk×k such that\nE[g|h] = A(g|h)h;\nand for each observed child x ∈ ChildrenT(h) ∩ Vobs, there exists a matrix C(x|h) ∈ Rd×k such that\nE[x|h] = C(x|h)h.\nWe refer to the class of tree graphical models satisfying Condition 1 as linear tree models. Such models include a variety of continuous and discrete tree distributions (as well as hybrid combinations of the two, such as Gaussian mixture models) which are widely used in practice. Continuous linear tree models include linear-Gaussian models and Kalman filters. In the discrete case, suppose that the observed variables take on d values, and hidden variables take k values. Then, each variable is represented by a binary vector in {0, 1}s, where s = d for the observed variables and s = k for the hidden variables (in particular, if the variable takes value i, then the corresponding vector is the i-th coordinate vector), and any conditional distribution between the variables is represented by a linear relationship. Thus, discrete linear tree models include discrete hidden Markov models [16] and Markovian evolutionary trees [21].\nIn addition to the linearity, the following conditions are assumed in order to recover the hidden tree structure. For any matrix M , let σt(M) denote its t-th largest singular value.\nCondition 2 (Rank condition). The variables in VT = Vhid ∪ Vobs obey the following rank conditions.\n1. For all h ∈ Vhid, E[hh>] has rank k (i.e., σk(E[hh>]) > 0).\n2. For all h ∈ Vhid and hidden child g ∈ ChildrenT(h) ∩ Vhid, A(g|h) has rank k.\n3. For all h ∈ Vhid and observed child x ∈ ChildrenT(h) ∩ Vobs, C(x|h) has rank k.\nThe rank condition is a generalization of parameter identifiability conditions in latent variable models [1, 21, 16] which rules out various (provably) hard instances in discrete variable settings [21].\nCondition 3 (Non-redundancy condition). Each hidden variable has at least three neighbors. Furthermore, there exists ρ2max > 0 such that for each pair of distinct hidden variables h, g ∈ Vhid,\ndet(E[hg>])2\ndet(E[hh>]) det(E[gg>]) ≤ ρ2max < 1.\nThe requirement for each hidden node to have three neighbors is natural; otherwise, the hidden node can be eliminated. The quantity ρmax is a natural multivariate generalization of correlation. First, note that ρmax ≤ 1, and that if ρmax = 1 is achieved with some h and g, then h and g are completely correlated, implying the existence of a deterministic map between hidden nodes h and g; hence simply merging the two nodes into a single node h (or g) resolves this issue. Therefore the non-redundancy condition simply means that any two hidden nodes h and g cannot be further reduced to a single node. Clearly, this condition is necessary for the goal of identifying the correct tree structure, and it is satisfied as soon as h and g have limited correlation in just a single direction. Previous works [24, 23] show that an analogous condition ensures identifiability for general latent tree models (and in fact, the conditions are identical in the Gaussian case). Condition 3 is therefore a generalization of this condition suitable for the multivariate setting.\nOur learning guarantees also require a correlation condition that generalize the explicit depth conditions considered in the phylogenetics literature [14, 21]. To state this condition, first define Fh to be the set of subtrees of that remain after a hidden variable h ∈ Vhid is removed from T (see Figure 2). Also, for any subtree T ′ of T, let Vobs[T ′] ⊆ Vobs be the observed variables in T ′.\nCondition 4 (Correlation condition). There exists γmin > 0 such that for all hidden variables h ∈ Vhid and all triples of subtrees {T1, T2, T3} ⊆ Fh in the forest obtained if h is removed from T,\nmax x1∈Vobs[T1],x2∈Vobs[T2],x3∈Vobs[T3] min {i,j}⊂{1,2,3}\nσk(E[xix>j ]) ≥ γmin.\nThe quantity γmin is related to the effective depth of T, which is the maximum graph distance between a hidden variable and its closest observed variable [14, 8]. The effective depth is at most logarithmic in the number of variables (as achieved by a complete binary tree), though it can also be a constant if every hidden variable is close to an observed variable (e.g., in a hidden Markov model, the effective depth is 1, even though the true depth, or diameter, is m+ 1). If the matrices giving the (conditionally) linear relationship between neighboring variables in T are all well-conditioned, then γmin is at worst exponentially small in the effective depth, and therefore at worst polynomially small in the number of variables.\nAlgorithm 1 SpectralQuartetTest on observed variables {z1, z2, z3, z4}. Input: For each pair {i, j} ⊂ {1, 2, 3, 4}, an empirical estimate Σ̂i,j of the second-moment matrix E[ziz>j ]\nand a corresponding confidence parameter ∆i,j > 0. Output: Either a pairing {{zi, zj}, {zi′ , zj′}} or ⊥.\n1: if there exists a partition of {z1, z2, z3, z4} = {zi, zj} ∪ {zi′ , zj′} such that\nk∏ s=1 [σs(Σ̂i,j)−∆i,j ]+[σs(Σ̂i′,j′)−∆i′,j′ ]+ > k∏ s=1 (σs(Σ̂i′,j) + ∆i′,j)(σs(Σ̂i,j′) + ∆i,j′)\nthen return the pairing {{zi, zj}, {zi′ , zj′}}. 2: else return ⊥.\nFinally, also define γmax := max\n{x1,x2}⊆Vobs {σ1(E[x1x>2 ])}\nto be the largest spectral norm of any second-moment matrix between observed variables. Note γmax ≤ 1 in the discrete case, and, in the continuous case, γmax ≤ 1 if each observed random vector is in isotropic position.\nIn this work, the Euclidean norm of a vector x is denoted by ‖x‖, and the (induced) spectral norm of a matrix A is denoted by ‖A‖, i.e., ‖A‖ := σ1(A) = sup{‖Ax‖ : ‖x‖ = 1}."
    }, {
      "heading" : "3 Spectral quartet tests",
      "text" : "This section describes the core of our learning algorithm, a spectral quartet test that determines topology of the subtree induced by four observed variables {z1, z2, z3, z4}. There are four possibilities for the induced subtree, as shown in Figure 1. Our quartet test either returns the correct induced subtree among possibilities in Figure 1(a)–(c); or it outputs ⊥ to indicate abstinence. If the test returns ⊥, then no guarantees are provided on the induced subtree topology. If it does return a subtree, then the output is guaranteed to be the correct induced subtree (with high probability).\nThe quartet test proposed is described in Algorithm 1 (SpectralQuartetTest). The notation [a]+ denotes max{0, a} and [t] (for an integer t) denotes the set {1, 2, . . . , t}.\nThe quartet test is defined with respect to four observed variables Z := {z1, z2, z3, z4}. For each pair of variables zi and zj , it takes as input an empirical estimate Σ̂i,j of the second-moment matrix E[ziz>j ], and confidence bound parameters ∆i,j which are functions of N , the number of samples used to compute the Σ̂i,j ’s, a confidence parameter δ, and of properties of the distributions of zi and zj . In practice, one uses a single threshold ∆ for all pairs, which is tuned by the algorithm. Our theoretical analysis also applies to this case. The output of the test is either ⊥ or a pairing of the variables {{zi, zj}, {zi′ , zj′}}. For example, if the output is the pairing is {{z1, z2}, {z3, z4}}, then Figure 1(a) is the output topology.\nEven though the configuration in Figure 1(d) is a possibility, the spectral quartet test never returns {{z1, z2, z3, z4}}, as there is no correct pairing of Z. The topology {{z1, z2, z3, z4}} can be viewed as a degenerate case of {{z1, z2}, {z3, z4}} (say) where the hidden variables h and g are deterministically identical, and Condition 3 fails to hold with respect to h and g."
    }, {
      "heading" : "3.1 Properties of the spectral quartet test",
      "text" : "With exact second moments: The spectral quartet test is motivated by the following lemma, which shows the relationship between the singular values of second-moment matrices of the zi’s and the induced topology among them in the latent tree. Let detk(M) := ∏k s=1 σs(M) denote the product of the k largest singular values of a matrix M .\nLemma 1 (Perfect quartet test). Suppose that the observed variables Z = {z1, z2, z3, z4} have the true induced tree topology shown in Figure 1(a), and the tree model satisfies Condition 1 and Condition 2. Then\ndetk(E[z1z>3 ])detk(E[z2z>4 ]) detk(E[z1z>2 ])detk(E[z3z>4 ]) = detk(E[z1z>4 ])detk(E[z2z>3 ]) detk(E[z1z>2 ])detk(E[z3z>4 ]) = det(E[hg>])2 det(E[hh>]) det(E[gg>]) ≤ 1 (1)\nand detk(E[z1z>3 ])detk(E[z2z>4 ]) = detk(E[z1z>4 ])detk(E[z2z>3 ]).\nThis lemma shows that given the true second-moment matrices and assuming Condition 3, the inequality in (1) becomes strict and thus can be used to deduce the correct topology: the correct pairing is {{zi, zj}, {zi′ , zj′}} if and only if\ndetk(E[ziz>j ])detk(E[zi′z>j′ ]) > detk(E[zi′z>j ])detk(E[ziz>j′ ]).\nReliability: The next lemma shows that even if the singular values of E[ziz>j ] are not known exactly, then with valid confidence intervals (that contain these singular values) a robust test can be constructed which is reliable in the following sense: if it does not output ⊥, then the output topology is indeed the correct topology.\nLemma 2 (Reliability). Consider the setup of Lemma 1, and suppose that Figure 1(a) is the correct topology. If for all pairs {zi, zj} ⊂ Z and all s ∈ [k], σs(Σ̂i,j) − ∆i,j ≤ σs(E[ziz>j ]) ≤ σs(Σ̂i,j) + ∆i,j, and if SpectralQuartetTest returns a pairing {{zi, zj}, {zi′ , zj′}}, then {{zi, zj}, {zi′ , zj′}} = {{z1, z2}, {z3, z4}}.\nIn other words, the spectral quartet test never returns an incorrect pairing as long as the singular values of E[ziz>j ] lie in an interval of length 2∆i,j around the singular values of Σ̂i,j . The lemma below shows how to set the ∆i,js as a function of N , δ and properties of the distributions of zi and zj so that this required event holds with probability at least 1 − δ. We remark that any valid confidence intervals may be used; the one described below is particularly suitable when the observed variables are high-dimensional random vectors.\nLemma 3 (Confidence intervals). Let Z = {z1, z2, z3, z4} be four random vectors. Let ‖zi‖ ≤ Mi almost surely, and let δ ∈ (0, 1/6). If each empirical second-moment matrix Σ̂i,j is computed using N iid copies of zi and zj, and if\nd̄i,j := E[‖zi‖2‖zj‖2]− tr(E[ziz>j ]E[ziz>j ]>)\nmax{‖E[‖zj‖2ziz>i ]‖, ‖E[‖zi‖2zjz>j ]‖} , ti,j := 1.55 ln(24d̄i,j/δ),\n∆i,j ≥\n√ 2 max {∥∥E[‖zj‖2ziz>i ]∥∥,∥∥E[‖zi‖2zjz>j ]∥∥}ti,j N + MiMjti,j 3N ,\nthen with probability 1− δ, for all pairs {zi, zj} ⊂ Z and all s ∈ [k],\nσs(Σ̂i,j)−∆i,j ≤ σs(E[ziz>j ]) ≤ σs(Σ̂i,j) + ∆i,j . (2)\nConditions for returning a correct pairing: The conditions under which SpectralQuartetTest returns an induced topology (as opposed to ⊥) are now provided.\nAn important quantity in this analysis is the level of non-redundancy between the hidden variables h and g. Let\nρ2 := det(E[hg>])2\ndet(E[hh>]) det(E[gg>]) . (3)\nIf Figure 1(a) is the correct induced topology among {z1, z2, z3, z4}, then the smaller ρ is, the greater the gap between detk(E[z1z>2 ])detk(E[z3z>4 ]) and either of detk(E[z1z>3 ])detk(E[z2z>4 ]) and detk(E[z1z>4 ])detk(E[z2z>3 ]). Therefore, ρ also governs how small the ∆i,j need to be for the quartet test to return a correct pairing; this is quantified in Lemma 4. Note that Condition 3 implies ρ ≤ ρmax < 1.\nLemma 4 (Correct pairing). Suppose that (i) the observed variables Z = {z1, z2, z3, z4} have the true induced tree topology shown in Figure 1(a); (ii) the tree model satisfies Condition 1, Condition 2, and ρ < 1 (where ρ is defined in (3)), and (iii) the confidence bounds in (2) hold for all {i, j} and all s ∈ [k]. If\n∆i,j < 1\n8k ·min\n{ 1, 1 ρ − 1 } ·min {i,j} {σk(E[ziz>j ])}\nfor each pair {i, j}, then SpectralQuartetTest returns the correct pairing {{z1, z2}, {z3, z4}}."
    }, {
      "heading" : "4 The Spectral Recursive Grouping algorithm",
      "text" : "The Spectral Recursive Grouping algorithm, presented as Algorithm 2, uses the spectral quartet test discussed in the previous section to estimate the structure of a multivariate latent tree distribution from iid samples of the observed leaf variables.1 The algorithm is a modification of the recursive grouping (RG) procedure proposed in [8]. RG builds the tree in a bottom-up fashion, where the initial working set of variables are the observed variables. The variables in the working set always correspond to roots of disjoint subtrees of T discovered by the algorithm. (Note that because these subtrees are rooted, they naturally induce parent/child relationships, but these may differ from those implied by the edge directions in T.) In each iteration, the algorithm determines which variables in the working set to combine. If the variables are combined as siblings, then a new hidden variable is introduced as their parent and is added to the working set, and its children are removed. If the variables are combined as neighbors (parent/child), then the child is removed from the working set. The process repeats until the entire tree is constructed.\nOur modification of RG uses the spectral quartet tests from Section 3 to decide which subtree roots in the current working set to combine. Note that because the test may return ⊥ (a null result), our algorithm uses the tests to rule out possible siblings or neighbors among variables in the working set—this is encapsulated in the subroutine Mergeable (Algorithm 3), which tests quartets of observed variables (leaves) in the subtrees rooted at working set variables. For any pair {u, v} ⊆ R submitted to the subroutine (along with the current working set R and leaf sets L[·]):\n• Mergeable returns false if there is evidence (provided by a quartet test) that u and v should first be joined with different variables (u′ and v′, respectively) before joining with each other; and\n• Mergeable returns true if no quartet test provides such evidence.\nThe subroutine is also used by the subroutine Relationship (Algorithm 4) which determines whether a candidate pair of variables should be merged as neighbors (parent/child) or as siblings: essentially, to check if u is a parent of v, it checks if v is a sibling of each child of u. The use of unreliable estimates of long-range correlations is avoided by only considering highly-correlated variables as candidate pairs to merge (where correlation is measured using observed variables in their corresponding subtrees as proxies). This leads to a sample-efficient algorithm for recovering the hidden tree structure.\nThe Spectral Recursive Grouping algorithm enjoys the following guarantee.\nTheorem 1. Let η ∈ (0, 1). Assume the directed tree graphical model T over variables (random vectors) VT = Vobs ∪ Vhid satisfies Conditions 1, 2, 3, and 4. Suppose the Spectral Recursive Grouping algorithm (Algorithm 2) is provided N independent samples from the distribution over Vobs, and uses parameters given by\n∆xi,xj :=\n√ 2Bxi,xj txi,xj\nN + MxiMxj txi,xj 3N (4)\n1To simplify notation, we assume that the estimated second-moment matrices Σ̂x,y and threshold parameters ∆x,y ≥ 0 for all pairs {x, y} ⊂ Vobs are globally defined. In particular, we assume the spectral quartet tests use these quantities.\nAlgorithm 2 Spectral Recursive Grouping.\nInput: Empirical second-moment matrices Σ̂x,y for all pairs {x, y} ⊂ Vobs computed from N iid samples from the distribution over Vobs; threshold parameters ∆x,y for all pairs {x, y} ⊂ Vobs. Output: Tree structure T̂ or “failure”. 1: let R := Vobs, and for all x ∈ R, T [x] := rooted single-node tree x and L[x] := {x}. 2: while |R| > 1 do 3: let pair {u, v} ∈ {{ũ, ṽ} ⊆ R : Mergeable(R,L[·], ũ, ṽ) = true} be such that max{σk(Σ̂x,y) : (x, y) ∈\nL[u]× L[v]} is maximized. If no such pair exists, then halt and return “failure”. 4: let result := Relationship(R,L[·], T [·], u, v). 5: if result = “siblings” then 6: Create a new variable h, create subtree T [h] rooted at h by joining T [u] and T [v] to h with edges {h, u} and {h, v}, and set L[h] := L[u] ∪ L[v]. 7: Add h to R, and remove u and v from R. 8: else if result = “u is parent of v” then 9: Modify subtree T [u] by joining T [v] to u with an edge {u, v}, and modify L[u] := L[u] ∪ L[v].\n10: Remove v from R. 11: else if result = “v is parent of u” then 12: {Analogous to above case.} 13: end if 14: end while 15: Return T̂ := T [h] where R = {h}.\nAlgorithm 3 Subroutine Mergeable(R,L[·], u, v). Input: Set of nodes R; leaf sets L[v] for all v ∈ R; distinct u, v ∈ R. Output: true or false.\n1: if there exists distinct u′, v′ ∈ R \\ {u, v} and (x, y, x′, y′) ∈ L[u] × L[v] × L[u′] × L[v′] s.t. SpectralQuartetTest({x, y, x′, y′}) returns {{x, x′}, {y, y′}} or {{x, y′}, {x′, y}} then return false. 2: else return true.\nwhere\nBxi,xj := max {∥∥E[‖xi‖2xjx>j ]∥∥,∥∥E[‖xj‖2xix>i ]∥∥}, Mxi ≥ ‖xi‖ almost surely,\nd̄xi,xj := E[‖xi‖2‖xj‖2]− tr(E[xix>j ]E[xjx>i ]) max {∥∥E[‖xj‖2xix>i ]∥∥,∥∥E[‖xi‖2xjx>j ]∥∥} , txi,xj := 4 ln(4d̄xi,xjn/η).\nLet B := maxxi,xj∈Vobs{Bxi,xj}, M := maxxi∈Vobs{Mxi}, t := maxxi,xj∈Vobs{txi,xj}. If\nN > 200 · k2 ·B · t(\nγ2min γmax\n· (1− ρmax) )2 + 7 · k ·M2 · tγ2min\nγmax · (1− ρmax)\n,\nthen with probability at least 1− η, the Spectral Recursive Grouping algorithm returns a tree T̂ with the same undirected graph structure as T.\nConsistency is implied by the above theorem with an appropriate scaling of η with N . The theorem reveals that the sample complexity of the algorithm depends solely on intrinsic spectral properties of the distribution. Note that there is no explicit dependence on the dimensions of the observable variables, which makes the result applicable to high-dimensional settings.\nAlgorithm 4 Subroutine Relationship(R,L[·], T [·], u, v). Input: Set of nodes R; leaf sets L[v] for all v ∈ R; rooted subtrees T [v] for all v ∈ R; distinct u, v ∈ R. Output: “siblings”, “u is parent of v” (“u→ v”), or “v is parent of u” (“v → u”).\n1: if u is a leaf then assert u 6→ v. 2: if v is a leaf then assert v 6→ u. 3: let R[w] := (R \\ {w}) ∪ {w′ : w′ is a child of w in T [w]} for each w ∈ {u, v}. 4: if there exists child u1 of u in T [u] s.t. Mergeable(R[u],L[·], u1, v)=false then assert “u 6→ v”. 5: if there exists child v1 of v in T [v] s.t. Mergeable(R[v],L[·], u, v1)=false then assert “v 6→ u”. 6: if both “u 6→ v” and “v 6→ u” were asserted then return “siblings”. 7: else if “u 6→ v” was asserted then return “v is parent of u” (“v → u”). 8: else return “u is parent of v” (“u→ v”)."
    }, {
      "heading" : "Acknowledgements",
      "text" : "Part of this work was completed while DH was at the Wharton School of the University of Pennsylvania and at Rutgers University. AA was supported by in part by the setup funds at UCI and the AFOSR Award FA9550-10-1-0310."
    }, {
      "heading" : "A Sample-based confidence intervals for singular values",
      "text" : "We show how to derive confidence bounds for the singular values of Σi,j := E[ziz>j ] for {i, j} ⊂ {1, 2, 3, 4} from N iid copies of the random vectors {z1, z2, z3, z4}. That is, we show how to set ∆i,j so that, with high probability, σs(Σ̂i,j)−∆i,j ≤ σs(Σi,j) ≤ σs(Σ̂i,j) + ∆i,j for all {i, j} and all s ∈ [k].\nWe state exponential tail inequalities for the spectral norm of the estimation error Σ̂i,j −Σi,j . The first exponential tail inequality is stated for general random vectors under Bernstein-type conditions, and the second is specific to random vectors in the discrete setting.\nLemma 5. Let zi and zj be random vectors such that ‖zi‖ ≤Mi and ‖zj‖ ≤Mj almost surely, and let\nd̄i,j := E[‖zi‖2‖zj‖2]− tr(Σi,jΣ>i,j) max {∥∥E[‖zj‖2ziz>i ]∥∥,∥∥E[‖zi‖2zjz>j ]∥∥} ≤ max{dim(zi),dim(zj)}.\nLet Σi,j := E[ziz>j ] and let Σ̂i,j be the empirical average of N independent copies of ziz>j . Pick any t > 0. With probability at least 1− 4d̄i,jt(et − t− 1)−1,\n∥∥∥Σ̂i,j −Σi,j∥∥∥ ≤ √ 2 max {∥∥E[‖zj‖2ziz>i ]∥∥,∥∥E[‖zi‖2zjz>j ]∥∥}t\nN + MiMjt 3N .\nRemark 1. For any δ ∈ (0, 1/6), we have 4d̄i,jt(et − t− 1)−1 ≤ δ provided that t ≥ 1.55 ln(4d̄i,j/δ).\nProof. Define the random matrix\nZ :=\n[ ziz > j\nzjz > i\n] .\nLet Z1, . . . , ZN be independent copies of Z. Then Pr [∥∥∥Σ̂i,j −Σi,j∥∥∥ > t] = Pr[∥∥∥∥ 1N N∑ `=1 Z` − E[Z] ∥∥∥∥ > t ] .\nNote that\nE[Z2] = E [ ‖zj‖2ziz>i\n‖zi‖2zjz>j ] so by convexity, ∥∥E[Z2]− E[Z]2∥∥ ≤ ∥∥E[Z2]∥∥\n≤ max {∥∥E[‖zj‖2ziz>i ]∥∥,∥∥E[‖zi‖2zjz>j ]∥∥}\nand\ntr(E[Z2]− E[Z]2) = tr(E[‖zj‖2ziz>i ]) + tr(E[‖zi‖2zjz>j ])− tr(Σi,jΣ>i,j)− tr(Σ>i,jΣi,j) = 2 ( E[‖zi‖2‖zj‖2]− tr(Σi,jΣ>i,j) ) .\nMoreover, ‖Z‖ ≤ ‖zi‖‖zj‖ ≤MiMj .\nBy the matrix Bernstein inequality [17], for any t > 0,\nPr ∥∥∥Σ̂i,j −Σi,j∥∥∥ > √ 2 ( max {∥∥E[‖zj‖2ziz>i ]∥∥,∥∥E[‖zi‖2zjz>j ]∥∥}) t N + MiMjt 3N  ≤ 2 · 2 ( E[‖zi‖2‖zj‖2]− tr(Σi,jΣ>i,j) ) max\n{∥∥E[‖zj‖2ziz>i ]∥∥,∥∥E[‖zi‖2zjz>j ]∥∥} · t(et − t− 1)−1 = 4d̄i,jt(et − t− 1)−1. The claim follows.\nIn the case of discrete random variables (modeled as random vectors as described in Section 2), the following lemma from [16] can give a tighter exponential tail inequality.\nLemma 6 ([16]). Let zi and zj be random vectors, each with support on the vertices of a probability simplex. Let Σi,j := E[ziz>j ] and let Σ̂i,j be the empirical average of N independent copies of ziz>j . Pick any t > 0. With probability at least 1− e−t, ∥∥∥Σ̂i,j −Σi,j∥∥∥ ≤ ∥∥∥Σ̂i,j −Σi,j∥∥∥\nF ≤ 1 +\n√ t√\nN\n(where ‖A‖F denotes the Frobenius norm of a matrix A).\nFor simplicity, we only work with Lemma 5, although it is easy to translate all of our results by changing the tail inequality. The proof of Lemma 3 is immediate from combining Lemma 5 and Weyl’s Theorem.\nLemma 3 provides some guidelines on how to set the ∆i,j as functions of N , δ, and properties of zi and zj . The dependence on the properties of zi and zj comes through the quantities Mi, Mj , d̄i,j , and\nBi,j := max i,j { ∥∥E[‖zj‖2ziz>i ]∥∥,∥∥E[‖zi‖2zjz>j ]∥∥}.\nIn practice, one may use plug-in estimates for these quantities, or use loose upper bounds based on weaker knowledge of the distribution. For instance, d̄i,j is at most max{dim(zi),dim(zj)}, the larger of the explicit vector dimensions of zi and zj . Also, if the maximum directional standard deviation σ∗ of any zi is known, then Bi,j ≤ max{M2i ,M2j }σ2∗. We note that as these are additive confidence intervals, some dependence on the properties of zi and zj is inevitable."
    }, {
      "heading" : "B Analysis of the spectral quartet test",
      "text" : "For any hidden variable h ∈ Vhid, let DescendantsT(h) ⊆ VT be the descendants of h in T. For any g ∈ DescendantsT(h)∩Vhid such that the (directed) path from h to g is h→ g1 → g2 → · · · → gq = g, define A(g|h) ∈ Rk×k to be the product\nA(g|h) := A(gq|gq−1) · · ·A(g2|g1)A(g1|h).\nSimilarly, for any x ∈ DescendantsT(h) ∩ Vobs such that the (directed) path from h to x is h → g1 → g2 → · · · → gq → x, define C(x|h) ∈ Rd×k to be the product\nC(x|h) := C(x|gq)A(gq|gq−1) · · ·A(g2|g1)A(g1|h).\nB.1 log detk metric\nDefine the function µ : VT × VT → R by\nµ(u, v) :=  log detk(E[uu>]−1/2E[uv>]E[vv>]−1/2) if u, v ∈ Vhid log detk(E[uv>]E[vv>]−1/2) if u ∈ Vobs, v ∈ Vhid log detk(E[uu>]−1/2E[uv>]) if u ∈ Vhid, v ∈ Vobs log detk(E[uv>]) if u, v ∈ Vobs .\nProposition 1 (log detk metric). Assume Conditions 1 and 2 hold, and pick any u, v ∈ VT. If w ∈ VT\\{u, v} is on the (undirected) path u v, then µ(u, v) = µ(u,w) + µ(w, v).\nProof. Suppose the induced topology over u, v, w in T is the following.\nu w v\nAssume for now that u, v ∈ Vhid. Then, using Condition 1,\nE[uv>] = E[uw>]A>(v|w) = (E[uw >]E[ww>]−1/2)(E[ww>]−1/2E[wv>])\nso, because rank(E[uu>]−1/2E[uw>]E[ww>]−1/2) = rank(E[ww>]−1/2E[wv>]E[vv>]−1/2) = k by Condition 2,\nµ(u, v) = log detk(E[uu>]−1/2E[uw>]E[ww>]−1/2E[ww>]−1/2E[wv>]E[vv>]−1/2)\n= log detk(E[uu>]−1/2E[uw>]E[ww>]−1/2) + log detk(E[ww>]−1/2E[wv>]E[vv>]−1/2) = µ(u,w) + µ(w, v).\nIf u ∈ Vhid but v ∈ Vobs, then let Uv ∈ Rd×k be a matrix of orthonormal left singular vectors of C(v|w). Then E[uv>] = (E[uw>]E[ww>]−1/2)(E[ww>]−1/2E[wv>]) as before, and\ndetk(E[uu>]−1/2E[uv>]) = |det(E[uu>]−1/2E[uv>]Uv)| = |det(E[uu>]−1/2)| · | det(E[uv>]Uv)| = detk(E[uu>]−1/2E[uw>]E[ww>]−1/2) · detk(E[ww>]−1/2E[wv>]Uv) = detk(E[uu>]−1/2E[uw>]E[ww>]−1/2) · detk(E[ww>]−1/2E[wv>]),\nso\nµ(u, v) = log detk(E[uu>]−1/2E[uw>]E[ww>]−1/2) + log detk(E[ww>]−1/2E[wv>]) = µ(u,w) + µ(w, v).\nSuppose now that the induced toplogy over u, v, w in T is the following.\nu w v\nAgain, first assume that u, v ∈ Vhid. Then, by Condition 1,\nE[uv>] = A(u|w)E[ww>]A>(v|w) = (E[uw >]E[ww>]−1/2)(E[ww>]−1/2E[wv>]),\nso µ(u, v) = µ(u,w) + µ(v, w) as before. The cases where one or both of u and v is in Vobs follow by similar arguments as above.\nB.2 Proof of Lemma 1\nBy Proposition 1,\ndetk(E[z1z>3 ]) · detk(E[z2z>4 ]) = exp(µ(z1, z3) + µ(z2, z4)) = exp(µ(z1, h) + µ(h, g) + µ(g, z3) + µ(z2, h) + µ(h, g) + µ(g, z4))\n= exp(µ(z1, h) + µ(h, g) + µ(g, z4) + µ(z2, h) + µ(h, g) + µ(g, z3))\n= exp(µ(z1, z4) + µ(z2, z3)) = detk(E[z1z>4 ]) · detk(E[z2z>3 ]).\nMoreover,\ndetk(E[z1z>3 ]) · detk(E[z2z>4 ]) detk(E[z1z>2 ]) · detk(E[z3z>4 ]) = exp(µ(z1, z3) + µ(z2, z4)) exp(µ(z1, z2) + µ(z3, z4))\n= exp(µ(z1, h) + µ(h, g) + µ(g, z3) + µ(z2, h) + µ(h, g) + µ(g, z4))\nexp(µ(z1, h) + µ(h, z2) + µ(z3, g) + µ(g, z4))\n= exp(2µ(h, g))\n= det(E[hh>]−1/2E[hg>]E[gg>]−1/2)2\n= det(E[hg>])2\ndet(E[hh>]) · det(E[gg>]) .\nFinally, note that u>E[hh>]−1/2E[hg>]E[gg>]−1/2v ≤ ‖u‖‖v‖ for all vectors u and v by Cauchy-Schwarz, so\ndet(E[hg>])2\ndet(E[hh>]) · det(E[gg>]) = det(E[hh >]−1/2E[hg>]E[gg>]−1/2)2 ≤ 1\nas required. Note that if Condition 3 also holds, then Lemma 1 implies the strict inequalities\nmax { detk(E[z1z>3 ]) · detk(E[z2z>4 ]), detk(E[z1z>4 ]) · detk(E[z2z>3 ]) } < detk(E[z1z>2 ]) · detk(E[z3z>4 ]).\nB.3 Proof of Lemma 2\nGiven that (2) holds for all pairs {i, j} and all s ∈ {1, 2, . . . , k}, if the spectral quartet test returns a pairing {{zi, zj}, {zi′ , zj′}}, it must be that\nk∏ s=1 σs(E[ziz>j ])σs(E[zi′z>j′ ]) ≥ k∏ s=1 [σs(Σ̂i,j)−∆i,j ]+[σs(Σ̂i′,j′)−∆i′,j′ ]+\n> k∏ s=1 (σs(Σ̂i′,j) + ∆i′,j)(σs(Σ̂i,j′) + ∆i,j′) ≥ k∏ s=1 σs(E[zi′z>j ])σs(E[ziz>j′ ]).\nTherefore\ndetk(E[ziz>j ]) · detk(E[zi′z>j′ ]) = k∏ s=1 σs(E[ziz>j ])σs(E[zi′z>j′ ])\n> k∏ s=1 σs(E[zi′z>j ])σs(E[ziz>j′ ]) = detk(E[zi′z>j ]) · detk(E[ziz>j′ ]).\nBut by Lemma 1, the above inequality can only hold if {{zi, zj}, {zi′ , zj′}} = {{z1, z2}, {z3, z4}}.\nB.4 Proof of Lemma 4\nLet Σi,j := E[ziz>j ]. The assumptions in the statement of the lemma imply\nmax{∆1,2,∆3,4} < 0 8k min{σk(Σ1,2), σk(Σ3,4)}\nwhere 0 := min { 1 ρ − 1, 1 } . Therefore\nk∏ s=1 [σs(Σ̂1,2)−∆1,2]+[σs(Σ̂3,4)−∆3,4]+ ≥ k∏ s=1 [σs(Σ1,2)− 2∆1,2]+[σs(Σ3,4)− 2∆3,4]+\n> ( k∏ s=1 σs(Σ1,2)σs(Σ3,4) )( 1− 0 4k )2k ≥ (\nk∏ s=1 σs(Σ1,2)σs(Σ3,4)\n) (1− 0/2). (5)\nIf E[hg>] has rank k, then so do Σi,j for i ∈ {1, 2} and j ∈ {3, 4}. Therefore, for {i′, j′} = {1, 2, 3, 4} \\ {i, j},\nmax{∆i,j ,∆i′,j′} < 0 8k min{σk(Σi′,j′), σk(Σi′,j′)}.\nThis implies\nk∏ s=1 (σs(Σ̂i,j) + ∆i,j)(σs(Σ̂i′,j′) + ∆i′,j′) ≤ k∏ s=1 (σs(Σi,j) + 2∆i,j)(σs(Σi′,j′) + 2∆i′,j′)\n< ( k∏ s=1 σs(Σi,j)σs(Σi′,j′) )( 1 + 0 4k )2k ≤ (\nk∏ s=1 σs(Σi,j)σs(Σi′,j′)\n) (1 + 0). (6)\nTherefore, combining (5), (6), and Lemma 1,\nk∏ s=1 [σs(Σ̂1,2)−∆1,2]+[σs(Σ̂3,4)−∆3,4]+\n> 1− 0/2 1 + 0 · det(E[hh >]) det(E[gg>]) det(E[hg>])2 · k∏ s=1 (σs(Σ̂i,j) + ∆i,j)(σs(Σ̂i′,j′) + ∆i′,j′)\n≥ 1 (1 + 0)2\n· det(E[hh >]) det(E[gg>]) det(E[hg>])2 · k∏ s=1 (σs(Σ̂i,j) + ∆i,j)(σs(Σ̂i′,j′) + ∆i′,j′)\n≥ k∏ s=1 (σs(Σ̂i,j) + ∆i,j)(σs(Σ̂i′,j′) + ∆i′,j′),\nso the spectral quartet test will return the correct pairing {{z1, z2}, {z3, z4}}, proving the lemma.\nB.5 Conditions for returning a correct pairing when rank(E[hg>]) < k The spectral quartet test is also useful in the case where E[hg>] has rank r < k. In this case, the widths of the confidence intervals are allowed to be wider than in the case where rank(E[hg>]) = k. Define\nσmin := min ( {σk(Σ1,2), σk(Σ3,4)} ∪ {σr(Σi,j) : i ∈ {1, 2}, j ∈ {3, 4}} ) .\nρ21 = σ 2(k−r) min ·maxi,j,i′,j′ ∏r s=1 σs(Σi,j)σs(Σi′,j′)∏k\ns=1 σs(Σ1,2)σs(Σ3,4) .\nInstead of depending on mini,j{σk(Σi,j)} and ρ as in the case where rank(E[hg>]) = k, we only depend on σmin and ρ1.\nLemma 7 (Correct pairing, rank r < k). Suppose that (i) the observed variables Z = {z1, z2, z3, z4} have the true induced (undirected) topology shown in Figure 1(a), (ii) the tree model satisfies Condition 1 and Condition 2, (iii) E[hg>] has rank r < k, and (iv) the confidence bounds in (2) hold for all {i, j} and all s ∈ [k]. If\n∆i,j < 1\n8k ·min\n{ 1, 8k ( 1\n2ρ1\n) 1 k−r } · σmin\nfor each {i, j}, then Algorithm 1 returns the correct pairing {{z1, z2}, {z3, z4}}.\nNote that the allowed width increases (to a point) as the rank r decreases.\nProof. The assumptions in the statement of the lemma imply\nmax{∆i,j : {i, j} ⊂ [4]} < 1σmin\n8k\nwhere\n1 := min\n{ 8k · ( 1\n2ρ1\n) 1 k−r\n, 1 } .\nWe have k∏ s=1\n[σs(Σ̂1,2)−∆1,2]+[σs(Σ̂3,4)−∆3,4]+ > (\nk∏ s=1 σs(Σ1,2)σs(Σ3,4)\n) (1− 1/2)\nas in the proof of Lemma 4. Moreover,\nk∏ s=1 (σs(Σ̂i,j) + ∆i,j)(σs(Σ̂i′,j′) + ∆i′,j′)\n< ( r∏ s=1 σs(Σi,j)σs(Σi′,j′) ) · (1 + 1) · ( 1σmin 8k )2(k−r) ≤ (\nk∏ s=1 σs(Σ1,2)σs(Σ3,4)\n) · ρ 2 1\n(σmin)2(k−r) · (1 + 1) · ( 1σmin 8k )2(k−r) =\n( k∏ s=1 σs(Σ1,2)σs(Σ3,4) ) · ρ21 · (1 + 1) · ( 1 8k )2(k−r) <\n( k∏ s=1 [σs(Σ̂1,2)−∆1,2]+[σs(Σ̂3,4)−∆3,4]+ ) · ρ21 · 1 + 1 1− 1/2 · ( 1 8k )2(k−r) ≤ (\nk∏ s=1 [σs(Σ̂1,2)−∆1,2]+[σs(Σ̂3,4)−∆3,4]+ ) · ρ21 · (1 + 1)2 · ( 1 8k )2(k−r) ≤\nk∏ s=1 [σs(Σ̂1,2)−∆1,2]+[σs(Σ̂3,4)−∆3,4]+.\nTherefore the spectral quartet test will return the correct pairing {{z1, z2}, {z3, z4}}; the lemma follows."
    }, {
      "heading" : "C Analysis of Spectral Recursive Grouping",
      "text" : "C.1 Overview\nHere is an outline of the argument for Theorem 1.\n1. First, we condition on a 1− η probability event over the iid samples from the distribution over Vobs in which the empirical second-moment matrices are sufficiently close to the true second-moment matrices in by spectral norm (Equation 8). This is required to reason deterministically about the behavior of the algorithm.\n2. Next, we characterize the pairs {u, v} ⊆ R (where R are the roots of subtrees maintained by the algorithm) that cause the Mergeable subroutine to return true. (Lemma 11), as well as those that cause it to return false (Lemma 12).\n3. We use the above characterizations to show that the main while-loop of the algorithm maintains loop invariants such that when the loop finally terminates, the entire tree structure will have been completely discovered (Lemma 13). This is achieved by showing each iteration of the while-loop\n(a) selects a “Mergeable” pair {u, v} ⊆ R that satisfies certain properties (Claim 2 and Claim 3) such that, if they are properly combined (as siblings or parent/child), the required loop invariants will be perserved; and (b) uses the Relationship subroutine to correctly determine whether the chosen pair {u, v} should be combined as siblings or parent/child (Claim 4).\nC.2 Proof of Theorem 1\nRecall the definitions of A(g|h) ∈ Rk×k and C(x|h) ∈ Rd×k for descendants g ∈ DescendantsT(h) ∩ Vhid and x ∈ DescendantsT(h) ∩ C(x|h) in T, as given in Appendix B.\nLet us define\nmin := min\n{ 1\nρmax − 1, 1\n} , ε :=\nγmin/γmax 8k + γmin/γmax ,\nθ := γmin 1 + ε , ς := γmin γmax · (1− ε) · θ.\nThe sample size requirement ensures that\n∆xi,xj < min · ς\n8k ≤ εθ.\nThis implies conditions on the thresholds ∆xi,xj in Lemma 4 for the spectral quartet test on {x1, x2, x3, x4} to return a correct pairing, provided that\nmin{σk(Σxi,xj ) : {i, j} ⊂ {1, 2, 3, 4}} ≥ ς. (7)\nThe probabilistic event we need is that in which the confidence bounds from Lemma 5 hold for each pair of observed variables. The event\n∀{xi, xj} ⊆ Vobs ‖Σ̂xi,xj −Σxi,xj‖ ≤ ∆xi,xj , (8)\noccurs with probability at least 1−η by Lemma 5 and a union bound. We henceforth condition on the above event.\nThe following is an immediate consequence of Weyl’s Theorem and conditioning on the above event.\nLemma 8. Fix any pair {x, y} ⊆ Vobs. If σk(Σx,y) ≥ (1 + ε)θ, then σk(Σ̂x,y) ≥ θ. If σk(Σ̂x,y) ≥ θ, then σk(Σx,y) ≥ (1− ε)θ.\nBefore continuing, we need some definitions and notation. First, we refer to the variables in VT interchangeably as both nodes and variables. Next, we generally ignore the direction of edges in T, except when it becomes crucial (namely, in Lemma 10). For a node r in T, we say that a subtree T [r] of T (ignoring edge directions) is rooted at r if T [r] contains r, and for every node u in T [r] and any node v not in T [r], the (undirected) path from u to v in T passes through r. Note that a rooted subtree naturally imply parent/child relationships between its constituent nodes, and it is in this sense we use the terms “parent”, “child”, “sibling”, etc. throughout the analysis, rather than in the sense given by the edge directions in T (the exception is in Lemma 10). A collection C of disjoint rooted subtrees of T naturally gives rise to a super-tree ST [C] by starting with T and then collapsing each T [r] ∈ C into a single node. Note that each node in ST [C] is either associated with a subtree in C, or is a node in T that doesn’t appear in any subtree in C. We say a subtree T ∈ C is a leaf component relative to C if it is a leaf in this super-tree ST [C]. Finally, define Vhid[C] := {h ∈ Vhid : h does not appear in any subtree in C}.\nThe following lemma is a simple fact about the super-tree given properties on the subtrees (which will be maintained by the algorithm).\nLemma 9 (Super-tree property). Let R ⊆ VT. Let C := {T [u] : u ∈ R} be a collection of disjoint rooted subtrees, with u being the root of T [u], such that their leaf sets {L[u] : u ∈ R} partition Vobs. Then the nodes of the super-tree ST [C] are C ∪ Vhid[C], and the leaves of ST [C] are all in C.\nProof. This follows because each leaf in T appears in the leaf set of some T [u].\nThe next lemma relates the correlation between two observed variables in a quartet (on opposite sides of the bottleneck) to the correlations of the other pairs crossing the bottleneck.\nLemma 10 (Correlation transfer). Consider the following induced (undirected) topology over {z1, z2, z3, z4} ⊆ Vobs.\nz1\nz2\nz3\nz4\nh g\nThen\nσk(E[z1z>4 ]) ≥ σk(E[z1z>3 ])σk(E[z2z>4 ])\nσ1(E[z2z>3 ]) .\nProof. In this proof, the edge directions and the notion of ancestor are determined according to the edge directions in T. Let r be the least common ancestor of {z1, z2, z3, z4} in T. There are effectively three possible cases to consider, depending on the location of r relative to the zi, h, and g; we may exploit the fact that σk(E[z1z>4 ]) = σk(E[z4z>1 ]) to cover the remaining cases.\n1. Suppose r appears between h and z1.\nz1\nz2\nz3\nz4\nr\nh g\nBy Condition 2, we can choose matrices U1, U2, U3, U4 ∈ Rd×k such that the columns of U1 are an orthonormal basis of range(C(z1|r)), the columns of U2 are an orthonormal basis of range(C(z2|h)), the columns of U3 are an orthonormal basis of range(C(z3|g)), and the columns of U4 are an orthonormal basis of range(C(z4|g)). We have\nU>1 E[z1z>4 ]U4 = U>1 C(z1|r)E[rr >]A>(h|r)C > (z4|h)U4\n= (U>1 C(z1|r)E[rr >])A>(h|r)(C > (z3|h)U3)(C > (z3|h)U3) −1\n(U>2 C(z2|h)E[hh >])−1(U>2 C(z2|h)E[hh >])(C>(z4|h)U4)\n= (U>1 C(z1|r)E[rr >]A>(h|r)C > (z3|h)U3)(U > 2 C(z2|h)E[hh >]C>(z3|h)U3) −1\n(U>2 C(z2|h)E[hh >]C>(z4|h)U4)\n= (U>1 E[z1z>3 ]U3)(U>2 E[z2z>3 ]U3)−1(U>2 E[z2z>4 ]U4).\n2. Suppose r appears between h and z2.\nz1\nz2\nz3\nz4\nr\nh g\nBy Condition 2, we can choose matrices U1, U2, U3, U4 ∈ Rd×k such that the columns of U1 are an orthonormal basis of range(C(z1|h)), the columns of U2 are an orthonormal basis of range(C(z2|r)), the columns of U3 are an orthonormal basis of range(C(z3|g)), and the columns of U4 are an orthonormal\nbasis of range(C(z4|g)). We have\nU>1 E[z1z>4 ]U4 = U>1 C(z1|h)E[hh >]A−>(h|r)C > (z4|r)U4\n= (U>1 C(z1|h)E[hh >])(C>(z3|h)U3)(C > (z3|h)U3) −1A−>(h|r)\n(U>2 C(z2|r)E[rr >])−1(U>2 C(z2|r)E[rr >])(C>(z4|r)U4)\n= (U>1 C(z1|h)E[hh >]C>(z3|h)U3)(U > 2 C(z2|r)E[rr >]A>(h|r)C > (z3|h)U3) −1\n(U>2 C(z2|r)E[rr >]C>(z4|r)U4)\n= (U>1 E[z1z>3 ]U3)(U>2 E[z2z>3 ]U3)−1(U>2 E[z2z>4 ]U4).\n3. Suppose either r = h, or r is between h and g.\nz1\nz2\nz3\nz4\nr g\nz1\nz2\nz3\nz4\nrh g\nIn either case, by Condition 2, we can choose matrices U1, U2, U3, U4 ∈ Rd×k such that the columns of U1 are an orthonormal basis of range(C(z1|h)), the columns of U2 are an orthonormal basis of range(C(z2|h)), the columns of U3 are an orthonormal basis of range(C(z3|g)), and the columns of U4 are an orthonormal basis of range(C(z4|g)). We have\nU>1 E[z1z>4 ]U4 = U>1 C(z1|r)E[rr >]C>(z4|r)U4\n= (U>1 C(z1|r)E[rr >])(C>(z3|r)U3)(C > (z3|r)U3) −1\n(U>2 C(z2|r)E[rr >])−1(U>2 C(z2|r)E[rr >])(C>(z4|r)U4)\n= (U>1 C(z1|r)E[rr >]C>(z3|r)U3)(U > 2 C(z2|r)E[rr >]C>(z3|r)U3) −1\n(U>2 C(z2|r)E[rr >]C>(z4|r)U4)\n= (U>1 E[z1z>3 ]U3)(U>2 E[z2z>3 ]U3)−1(U>2 E[z2z>4 ]U4).\nTherefore, in all cases,\nσk(E[z1z>4 ]) ≥ σk(E[z1z>3 ]) · σk(E[z2z>4 ])\nσ1(E[z2z>3 ]) .\nThe next two lemmas (Lemmas 11 and 12) show a dichotomy in the cases that cause the subroutine Mergeable return either true or false.\nLemma 11 (Mergeable pairs). Let R ⊆ VT. Let C := {T [r] : r ∈ R} be a collection of disjoint rooted subtrees, with r being the root of T [r], such that their leaf sets {L[r] : r ∈ R} partition Vobs. Further, suppose the pair {u, v} ⊆ R are such that one of the following conditions hold.\n1. {u, v} share a common neighbor in T, and both of T [u] and T [v] are leaf components relative to C.\n2. {u, v} are neighbors in T, and at least one of T [u] and T [v] is a leaf component relative to C.\nThen for all pairs {u1, v1} ⊆ R \\ {u, v} and all (x, y, x1, y1) ∈ L[u] × L[v] × L[u1] × L[v1], SpectralQuartetTest({x, y, x1, y1}) returns {{x, y}, {x1, y1}} or ⊥. This implies that Mergeable(R,L[·], u, v) returns true.\nRemark 2. Note that if |R| < 4, then Mergeable(R,L[·], u, v) returns true for all pairs {u, v} ⊆ R.\nProof. Suppose the first condition holds, and let h be the common neighbor. Since T [u] is a leaf component relative to C, the (undirected) path from any node u′ in T [u] to another node w not in T [u] must pass through h. Similarly, the (undirected) path from any node v′ in T [v] to another node w not in T [v] must pass through h. Therefore, each choice of {u1, v1} ⊆ R\\{u, v} and (x, y, x1, y1) ∈ L[u]×L[v]×L[u1]×L[v1] induces one of the following topologies,\nx\ny\nx1\ny1\nh\nx\ny\nx1\ny1\nh\nupon which, by Lemma 2, the quartet test returns either {{x, y}, {x1, y1}} or ⊥. Now instead suppose the second condition holds. Without loss of generality, assume T [u] is a leaf component relative to C, which then implies that the (undirected) path from any node u′ in T [u] to another node w not in T [u] must pass through v. Moreover, since T [v] is rooted at v, the (undirected) path from any node v′ in T [v] to another node w not in T [v] must pass through v. If T [v] is also a leaf component, then it must be that R = {u, v}, in which case R \\ {u, v} = ∅. If T [v] is not a leaf component, then each choice of {u1, v1} ⊆ R \\ {u, v} and (x, y, x1, y1) ∈ L[u] × L[v] × L[u1] × L[v1] induces one of the following topologies,\nx\ny\nx1\ny1\nv\nx\ny\nx1\ny1\nv\nupon which, by Lemma 2, the quartet test returns either {{x, y}, {x1, y1}} or ⊥.\nLemma 12 (Un-mergeable pairs). Let R ⊆ VT. Let C := {T [r] : r ∈ R} be a collection of disjoint rooted subtrees, with r being the root of T [r], such that their leaf sets {L[r] : r ∈ R} partition Vobs. Further, suppose the pair {u, v} ⊆ R are such that all of the following conditions hold.\n1. There exists (x, y) ∈ L[u]× L[v] such that σk(Σ̂x,y) ≥ θ.\n2. {u, v} do not share a common neighbor in T, or at least one of T [u] and T [v] is not a leaf component relative to C.\n3. {u, v} are not neighbors in T, or neither T [u] nor T [v] is a leaf component relative to C.\nThen there exists a pair {u1, v1} ⊆ R \\ {u, v} and (x1, y1) ∈ L[u1] × L[v1] such that SpectralQuartetTest({x, y, x1, y1}) returns {{x, x1}, {y, y1}}. This implies that Mergeable(R,L[·], u, v) returns false.\nProof. First, take (x, y) ∈ L[u]×L[v] such that σk(Σ̂x,y) ≥ θ. By Lemma 8, σk(Σx,y) ≥ (1− ε)θ. Lemma 9 implies that the nodes of ST [C] are C∪Vhid[C], and that each leaf in ST [C] is a subtree T [u] ∈ C. The second and third conditions of the lemma on {u, v} imply that at least one of the following cases holds.\n(i) Neither T [u] nor T [v] is a leaf component relative to C.\n(ii) u and v are not neighbors and do not share a common neighbor.\n(iii) u and v are not neighbors, and one of T [u] and T [v] is not a leaf component relative to C.\nSuppose (i) holds. Then each of T [u] and T [v] have degree ≥ 2 in ST [C]. Note that neither u nor v are leaves in T. Moreover, there exists {u1, v1} ⊆ (R \\ {u, v}) ∪ Vhid[C] such that u1 is adjacent to u in T, v1 is adjacent to v in T, and the (undirected) path from u1 to v1 in T intersects the (undirected) path from u to v in T.\nuu1 v1v\nSince u is not a leaf, it has at least three neighbors by assumption, and thus there exist three subtrees {Tu,1, Tu,2, Tu,3} ⊆ Fu such that u1 is the root of Tu,1, x ∈ Vobs[Tu,2] and y ∈ Vobs[Tu,3]. Moreover, by Condition 4, there exist x1 ∈ Vobs[Tu,1], x2 ∈ Vobs[Tu,2], and x3 ∈ Vobs[Tu,3] such that σk(E[xix>j ]) ≥ γmin for all {i, j} ⊂ {1, 2, 3}. Note that it is possible to have x2 = x and x3 = y. Let u2 denote the node in Tu,2 at which the (undirected) paths x u and x2 u intersect (if x2 = x, then let u2 be the root of Tu,2); similarly, let u3 denote the node in Tu,2 at which the (undirected) paths y u and x3 u intersect (if x3 = y, then let u3 be the root of Tu,3). The induced (undirected) topology over these nodes is shown below.\nu\nu1 u2 u3\nx yx1 x2 x3\nA completely analogous argument can be applied relative to v instead of u, giving the following.\nv\nv1 v2 v3\ny xy1 y2 y3\nClaim 1. The following lower bounds hold.\nmin {σk(Σx1,x), σk(Σx1,y), σk(Σy1,y), σk(Σy1,x)} ≥ γmin · (1− ε)θ\nγmax = ς. (9)\nProof. We just show the inequalities for σk(E[x1x>]) and σk(E[x1y>]); the other two are analogous. If x2 = x, then σk(E[x1x>]) = σk(E[x1x>2 ]) ≥ γmin ≥ ς. If x2 6= x, then we have the following induced (undirected) topology.\nx1\ny\nx2\nx\nu u2\nTherefore, by Lemma 10,\nσk(E[x1x>]) ≥ σk(E[x1x>2 ]) · σk(E[yx>]) σ1(E[yx>2 ]) ≥ γmin · (1− ε)θ γmax = ς.\nThis gives the first claimed inequality; now we show the second. If x3 = y, then σk(E[x1y>]) = σk(E[x1x>3 ]) ≥ γmin ≥ ς. If x3 6= y, then we have the following induced (undirected) topology.\nx1\nx\nx3\ny\nu u3\nAgain, by Lemma 10,\nσk(E[x1y>]) ≥ σk(E[x1x>3 ]) · σk(E[xy>]) σ1(E[xx>3 ]) ≥ γmin · (1− ε)θ γmax = ς.\nClaim 1, Lemma 4, and the sample size requirement of Theorem 1 (as per (7)) imply that the spectral quartet test on {x, x1, y, y1} returns the correct pairing. Since the induced (undirected) topology is\nx1\nx\ny1\ny\nu v\nthe correct pairing is {{x, x1}, {y, y1}}. Because the leaf sets {L[r] : r ∈ R} partition Vobs, and because x1 6∈ L[u] and y1 6∈ L[v], there exists {u′, v′} ⊆ R \\ {u, v} such that x1 ∈ L[u′] and y1 ∈ L[v′]. This proves the lemma in this case.\nNow instead suppose (ii) holds. Since T is connected, and T [u] and T [v] are respectively rooted at u and v, there must exist a pair {u1, v1} ⊂ (R \\ {u, v}) ∪ Vhid[C] such that neither u1 nor v1 are leaves in T, u1 is adjacent to u in T, v1 is adjacent to v in T, and the (undirected) path from u to v in T passes through the path from u1 to v1.\nu u1 v1 v\nAn argument analogous to that in case (i) applies to prove the lemma in this case; we provide a brief sketch below. Because u1 is not a leaf, there exists three subtrees {Tu1,1, Tu1,2, Tu1,3} ⊆ Fu1 such that u is the root of Tu1,2 (so x ∈ Vobs[Tu1,2]) and y ∈ Vobs[Tu1,3]. Moreover, there exist x1 ∈ Vobs[Tu1,1], x2 ∈ Vobs[Tu1,2], and x3 ∈ Vobs[Tu1,3] such that σk(E[xix>j ]) ≥ γmin for all {i, j} ⊂ {1, 2, 3} (it is possible to have x2 = x and x3 = y). Let u ′ 1 denote the root of Tu1,1, u′2 denote the node in Tu1,2 at which the (undirected) paths x u1 and x2 u1 intersect (if x2 = x, then let u′2 = u, which is the root of Tu1,2), and u3 denote the node in Tu1,2 at which the (undirected) paths y u1 and x3 u1 intersect (if x3 = y, then let u3 be the root of Tu1,3). An analogous argument applies relative to v1 instead of u1; the induced (undirected) topologies are given below.\nu1\nu′1 u ′ 2 u ′ 3\nx yx1 x2 x3\nv1\nv′1 v ′ 2 v ′ 3\ny xy1 y2 y3\nUsing the arguments in Claim 1, it can be shown that the inequalities in (9) hold in this case, so by Lemma 4, the quartet test on {x, x1, y, y1} returns {{x, x1}, {y, y1}}. Because the leaf sets {L[r] : r ∈ R} partition Vobs, and because x1 6∈ L[u] = Vobs[Tu1,2] and y1 6∈ L[v] = Vobs[Tv1,2], there exists {u′, v′} ⊆ R \\ {u, v} such that x1 ∈ L[u′] and y1 ∈ L[v′]. This proves the lemma in this case.\nFinally, suppose (iii) holds. Without loss of generality, assume T [u] is not a leaf component relative to C. Since T is connected, and T [u] and T [v] are respectively rooted at u and v, there must exist v1 ∈ (R\\ {u, v})∪Vhid[C] such that v1 is not a leaf in T, v1 is adjacent to v in T, and the (undirected) path from u to v in T passes through v1. Moreover, since T [u] is not a leaf component relative to C, it has degree ≥ 2 in ST [C]. Note that u is not a leaf in T, and moreover, there exists u1 ∈ (R \\ {u, v}) ∪ Vhid[C] such that u1 is adjacent to u in T, and u1 is not on the (undirected) path from u to v.\nuu1 v1 v\nAgain, an argument analogous to that in case (i) applies now to prove the lemma in this case.\nFinally, we give a lemma which analyzes the while-loop of Algorithm 2 and consequently implies Theorem 1.\nLemma 13 (Loop invariants). The following invariants concerning the state of the objects (R, T [·],L[·]) hold before the while-loop in Algorithm 2, and after each iteration of the while-loop.\n1. R ⊆ VT, and for each u ∈ R, T [u] is a subtree of T rooted at u. Moreover, the rooted subtree T [v] is already defined by Algorithm 2 for every node v appearing in T [u] for some u ∈ R. Finally, for each u ∈ R, the subtree T [u] is formed by joining the subtrees T [v] corresponding to children v of u in T [u] via edges {u, v}.\n2. The subtrees in C := {T [u] : u ∈ R} are disjoint, and the leaf sets {L[u] : u ∈ R} partition Vobs.\nMoreover, no iteration of the while-loop terminates in failure.\nBefore proving Lemma 13, we show how it implies Theorem 1. Initially, |R| = n, and each iteration of the while-loop decreases the cardinality of R by one, so there are a total of n−1 iterations of the while-loop. By Lemma 13, the final iteration results in a set R = {h} such that T̂ = T [h] is a subtree of T rooted at h, and L[h] = Vobs. This implies that T̂ has the same (undirected) structure as T, as required. This completes the proof of Theorem 1.\nProof of Lemma 13. The loop invariants clearly hold before the while-loop with the initial settings of R = Vobs, T [x] = rooted single-node tree x, and L[x] = {x} for all x ∈ R. So assume as the inductive hypothesis that the loop invariants hold at the start of a particular iteration (in which |R| > 1). It remains to prove that the iteration does not terminate in failure, and that the loop invariants hold at the end of the iteration. Let R, T [·], and L[·] be in their state at the beginning of the iteration.\nBecause the second loop invariant holds, Lemma 9 implies that the nodes of ST [C] are C ∪ Vhid[C], and that each leaf in ST [C] is a subtree T [u] ∈ C (so we may refer to the leaves of ST [C] as leaf components). Claim 2. If |R| > 1, then there exists a pair {u, v} ⊆ R such that the following hold.\n1. Either u and v are neighbors in T, and at least one of T [u] or T [v] is a leaf component relative to C; or u and v share a common neighbor in Vhid[C], and both T [u] and T [v] are leaf components relative to C.\n2. Mergeable(R,L[·], u, v) = true.\n3. max{σk(Σ̂x,y) : (x, y) ∈ L[u]× L[v]} ≥ θ.\nProof. Suppose there are no pairs {u, v} ⊆ C such that u and v are neighbors in T and at least one of T [u] and T [v] is a leaf component relative to C. Then each leaf component must be adjacent to some h ∈ Vhid[C] in ST [C]. Consider the tree ST ′ obtained from ST [C] by removing all the leaf components in ST [C]. The leaves of ST ′ must be among the h ∈ Vhid[C] that were adjacent to the leaf components in ST [C]. Fix such a leaf h in ST ′, and observe that it has degree one in ST ′. By assumption, no node in T has degree two, so h must have been connected to at least two leaf components in ST [C], say T [u] and T [v]. The node h is therefore a common neighbor of u and v. This proves the existence of a pair {u, v} ⊆ R satisfying the first required property.\nFix the pair {u, v} specified above. By Lemma 11, Mergeable(R,L[·], u, v) returns true, so {u, v} satisfies the second required property.\nTo show the final required property, we consider two cases. Suppose first that u and v are neighbors, and that T [u] is a leaf component relative to C. Note that u and v cannot both be leaves in T. If v is not a leaf, then there exists subtrees Tv,1 and Tv,2 in Fv such that Tv,1 = T [u] (because T [u] is a leaf component) and Tv,2 = T [v′] for some child v′ of v in T [v] (by the first loop invariant). By Condition 4, there exists x ∈ Vobs[Tv,1] = L[u] and y ∈ Vobs[Tv,2] ⊆ L[v] such that σk(Σx,y) ≥ γmin = (1 + ε)θ; by Lemma 8, σk(Σ̂x,y) ≥ θ. If v is a leaf but u is not, then there exists subtrees Tu,1 and Tu,2 in Fu such that\nTu,1 = v and Tu,2 = T [u′] for some child u′ of u in T [u] (by the first loop invariant). So by Condition 4, there y ∈ Vobs[Tu,2] ⊆ L[u] such that σk(Σv,y) ≥ γmin = (1+ε)θ; by Lemma 8, σk(Σ̂v,y) ≥ θ. Now instead suppose that u and v share a common neighbor h, and that both T [u] and T [v] are leaf components relative to C. This latter fact implies that {T [u], T [v]} ⊂ Fh, so Condition 4 implies that there exists x ∈ Vobs[T [u]] = L[u] and y ∈ Vobs[T [v]] = L[v] such that σk(Σx,y) ≥ γmin = (1 + ε)θ. By Lemma 8, σk(Σ̂x,y) ≥ θ.\nClaim 3. Consider any pair {u, v} ⊆ R such that max{σk(Σ̂x,y) : (x, y) ∈ L[u] × L[v]} ≥ θ. If the first property from Claim 2 fails to hold for {u, v}, then Mergeable(R,L[·], u, v) = false.\nProof. This follows immediately from Lemma 12.\nTaken together, Claims 2 and 3 imply that the pair {u, v} ⊆ R selected by the first step in the while-loop indeed exists (so the iteration does not terminate in failure) and satisfies the properties in Claim 2.\nNow we consider the second step of the while-loop, which is the call to the subroutine Relationship.\nClaim 4. Suppose a pair {u, v} satisfies the properties in Claim 2. Then Relationship(R,L[·], T [·], u, v) returns the correct relationship for u and v. Specifically:\n1. If u and v share a common neighbor in T (and both are leaf components relative to C), then “siblings” is returned.\n2. If u and v are neighbors in T and T [v] is a leaf component relative to C but T [u] is not, then “u is parent of v” is returned.\n3. If u and v are neighbors in T and T [u] is a leaf component relative to C but T [v] is not, then “v is parent of u” is returned.\n4. If u and v are neighbors in T and both T [u] and T [v] are leaf components relative to C, and u is a leaf in T but v is not, then “v is parent of u” is returned.\n5. If u and v are neighbors in T and both T [u] and T [v] are leaf components relative to C, and v is a leaf in T but u is not, then “u is parent of v” is returned.\n6. If u and v are neighbors in T and both T [u] and T [v] are leaf components relative to C, and neither u nor v are leaves in T, then “u is parent of v” is returned.\nProof. Fix the pair (x, y) ∈ L[u]×L[v] guaranteed by the third property of Claim 2 such that σk(Σ̂x,y) ≥ θ. Now we consider the possible relationships between u and v.\nSuppose u and v share a common neighbor h ∈ Vhid[C] in T, and that both T [u] and T [v] are leaf components relative to C. We need to show that the subroutine Relationship asserts both “u 6→ v” and “v 6→ u”. To show that “u 6→ v” is asserted, we assume u is not a leaf (otherwise “u 6→ v” is immediately asserted and we’re done), let {u1, . . . , uq} be the children of u in T [u], and takeR[u] as defined in Relationship. By the first loop invariant, the subtrees in C[u] are disjoint, and the leaf sets {L[r] : r ∈ R[u]} partition Vobs. In particular, x ∈ L[ui] for some i ∈ {1, . . . , q}. Since ui and v are not neighbors, and do not share a common neighbor. Therefore, by Lemma 12, Mergeable(R[u],L[·], ui, v) = false, so “u 6→ v” is asserted. A similar argument implies that “v 6→ u” is asserted. Since both “u 6→ v” and “v 6→ u” are asserted, the subroutine returns “siblings”.\nNow instead suppose u and v are neighbors. First, suppose T [u] is a leaf component relative to C. We claim that if v is not a leaf, then “v 6→ u” is not asserted. Let {v1, . . . , vq} be the children of v in T [v], and take R[v] = {u, v1, . . . , vq} as defined in Relationship. By the first loop invariant, the subtrees in C[v] are disjoint, and the leaf sets {L[r] : r ∈ R[v]} partition Vobs. By Lemma 14, T [u] and T [vi] are leaf components relative to C[v] for each i ∈ {1, . . . , q}. For each i ∈ {1, . . . , q}, {u, vi} share v as a common neighbor, and T [u] and T [vi] are both leaf components relative to C[v]. Therefore by Lemma 11, Mergeable(R[v],L[·], u, vi) = true for all i ∈ {1, . . . , q}, so “v 6→ u” is not asserted.\nSuppose T [u] is a leaf component relative to C but T [v] is not. By Lemma 9, v is not a leaf in T, so as argued above, “v 6→ u” is not asserted. It remains to show that “u 6→ v” is asserted. Assume u is not a leaf (or else u 6→ v is immediately asserted and we’re done), let {u1, . . . , uq} be the children of u in T [u], and take R[u] as defined in Relationship. By the first loop invariant, the subtrees in C[u] are disjoint, and the leaf sets {L[r] : r ∈ R[u]} partition Vobs. In particular, x ∈ L[ui] for some i ∈ {1, . . . , q}. By Lemma 14, T [v] is not a leaf component relative to C[u]. Moreover, ui and v are not neighbors. Therefore by Lemma 12, Mergeable(R[u],L[·], ui, v) = false, so “u 6→ v” is asserted. Since “v 6→ u” is not asserted but “u 6→ v” is asserted, the subroutine returns “v → u”. An analogous argument shows that if T [v] is a leaf component relative to C but T [u] is not, then the subroutine returns “u→ v”.\nNow suppose both T [u] and T [v] are leaf components relative to C. By assumption, leaves in T are only adjacent to non-leaves, so it cannot be that both u and v are leaves. Therefore at least one of u and v is not a leaf in T. Without loss of generality, say v is not a leaf in T. Then as argued above, “v 6→ u” is not asserted. If u is a leaf, then “u 6→ v” is asserted, so the subroutine returns “v → u”. If u is not a leaf, then by symmetry, “u 6→ v” is not asserted. Therefore the subroutine returns “u→ v”.\nClaim 4 implies that the remaining steps in the while-loop after the call to Relationship preserve the two loop invariants, simply by construction.\nThere is one last lemma used in the proof of Lemma 13.\nLemma 14 (Leaf components). Suppose the invariants in Lemma 13 are satisfied. Then for each u ∈ R such that u is not a leaf in T, the leaf components relative to the collection\nC[u] := (C \\ {T [u]}) ∪ {T [v] : v is a child of u in T [u]}\nare\n{T [r] : r 6= u ∧ T [r] is a leaf component relative to C} ∪ {T [r] : r is a child of u in T [u]}.\nProof. Pick any u ∈ R such that u is not a leaf in T. Let {v1, . . . , vq} be the children of u in T [u]. By the first loop invariant, each vi is the root of a subtree T [vi]. This implies that the subtrees {T [v1], . . . , T [vq]} are disjoint and {L[v1], . . . ,L[vq]} partition L[u]. Therefore ST [C[u]] is the same as ST [C] except with the following changes.\n1. T [u] is replaced with u.\n2. For each i, T [vi] is added with the edge {u, vi}.\nThis means that each T [vi] has degree one in ST [C[u]] and therefore is a leaf component relative to C[u]."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2011,
    "abstractText" : "<lb>This work considers the problem of learning the structure of multivariate linear tree models, which<lb>include a variety of directed tree graphical models with continuous, discrete, and mixed latent variables<lb>such as linear-Gaussian models, hidden Markov models, Gaussian mixture models, and Markov evolu-<lb>tionary trees. The setting is one where we only have samples from certain observed variables in the tree,<lb>and our goal is to estimate the tree structure (i.e., the graph of how the underlying hidden variables are<lb>connected to each other and to the observed variables). We propose the Spectral Recursive Grouping al-<lb>gorithm, an efficient and simple bottom-up procedure for recovering the tree structure from independent<lb>samples of the observed variables. Our finite sample size bounds for exact recovery of the tree structure<lb>reveal certain natural dependencies on underlying statistical and structural properties of the underlying<lb>joint distribution. Furthermore, our sample complexity guarantees have no explicit dependence on the<lb>dimensionality of the observed variables, making the algorithm applicable to many high-dimensional set-<lb>tings. At the heart of our algorithm is a spectral quartet test for determining the relative topology of a<lb>quartet of variables from second-order statistics.",
    "creator" : "LaTeX with hyperref package"
  }
}