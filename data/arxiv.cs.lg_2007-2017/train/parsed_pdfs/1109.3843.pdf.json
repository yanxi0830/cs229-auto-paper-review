{
  "name" : "1109.3843.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Fast approximation of matrix coherence and statistical leverage",
    "authors" : [ "Petros Drineas", "Michael W. Mahoney", "David P. Woodruff" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n10 9.\n38 43\nv2 [\ncs .D\nS] 5\nD ec\n2 01\n2"
    }, {
      "heading" : "1 Introduction",
      "text" : "The concept of statistical leverage measures the extent to which the singular vectors of a matrix are correlated with the standard basis and as such it has found usefulness recently in large-scale data analysis and in the analysis of randomized matrix algorithms [47, 33, 21]. A related notion is that of matrix coherence, which has been of interest in recently popular problems such as matrix completion and Nyström-based low-rank matrix approximation [13, 46]. Defined more precisely below, the statistical leverage scores may be computed as the squared Euclidean norms of the rows of the matrix containing the top left singular vectors and the coherence of the matrix is the largest statistical leverage score. Statistical leverage scores have a long history in statistical data analysis, where they have been used for outlier detection in regression diagnostics [29, 14]. Statistical leverage scores have also proved crucial recently in the development of improved worst-case randomized matrix algorithms that are also amenable to high-quality numerical implementation and that are useful to domain scientists [21, 33, 12, 20, 45, 22]; see [32] for a detailed discussion. The näıve and best previously existing algorithm to compute these scores would compute an orthogonal basis for the dominant part of the spectrum of A, e.g., the basis provided by the Singular Value Decomposition (SVD) or a basis provided by a QR decomposition [26], and then use that basis to compute diagonal elements of the projection matrix onto the span of that basis.\n∗Dept. of Computer Science, Rensselaer Polytechnic Institute, Troy, NY 12180. Email: drinep@cs.rpi.edu †Dept. of Computer Science, Rensselaer Polytechnic Institute, Troy, NY 12180. Email: magdon@cs.rpi.edu ‡Dept. of Mathematics, Stanford University, Stanford, CA 94305. Email: mmahoney@cs.stanford.edu §IBM Almaden Research Center, 650 Harry Road, San Jose, CA 95120 USA. Email: dpwoodru@us.ibm.com\nWe present a randomized algorithm to compute relative-error approximations to every statistical leverage score in time qualitatively faster than the time required to compute an orthogonal basis. For the case of an arbitrary n × d matrix A, with n ≫ d, our main algorithm runs (under assumptions on the precise values of n and d, see Theorem 1 for an exact statement) in O(nd log n/ǫ2) time, as opposed to the Θ(nd2) time required by the näıve algorithm. As a corollary, our algorithm provides a relative-error approximation to the coherence of an arbitrary matrix in the same time. In addition, several practically-important extensions of the basic idea underlying our main algorithm are also described in this paper."
    }, {
      "heading" : "1.1 Overview and definitions",
      "text" : "We start with the following definition of the statistical leverage scores of a matrix.\nDefinition 1. Given an arbitrary n × d matrix A, with n > d, let U denote the n × d matrix consisting of the d left singular vectors of A, and let U(i) denote the i-th row of the matrix U as a row vector. Then, the statistical leverage scores of the rows of A are given by\nℓi = ∥ ∥U(i) ∥ ∥ 2\n2 , (1)\nfor i ∈ {1, . . . , n}; the coherence γ of the rows of A is\nγ = max i∈{1,...,n} ℓi, (2)\ni.e., it is the largest statistical leverage score of A; and the (i, j)-cross-leverage scores cij are\ncij = 〈 U(i), U(j) 〉 , (3)\ni.e., they are the dot products between the ith row and the jth row of U .\nAlthough we have defined these quantities in terms of a particular basis, they clearly do not depend on that particular basis, but only on the space spanned by that basis. To see this, let PA denote the projection matrix onto the span of the columns of A. Then,\nℓi = ∥ ∥U(i) ∥ ∥ 2\n2 =\n( UUT )\nii = (PA)ii . (4)\nThat is, the statistical leverage scores of a matrix A are equal to the diagonal elements of the projection matrix onto the span of its columns.1 Similarly, the (i, j)-cross-leverage scores are equal to the off-diagonal elements of this projection matrix, i.e.,\ncij = (PA)ij = 〈 U(i), U(j) 〉 . (5)\nClearly, O(nd2) time suffices to compute all the statistical leverage scores exactly: simply perform the SVD or compute a QR decomposition of A in order to obtain any orthogonal basis for the range of A and then compute the Euclidean norm of the rows of the resulting matrix. Thus, in this paper, we are interested in algorithms that run in o(nd2) time.\nSeveral additional comments are worth making regarding this definition. First, since ∑n\ni=1 ℓi = ‖U‖2F = d, we can define a probability distribution over the rows of A as pi = ℓi/d. As discussed\n1In this paper, for simplicity of exposition, we consider the case that the matrix A has rank equal to d, i.e., has full column rank. Theoretically, the extension to rank-deficient matrices A is straightforward—simply modify Definition 1 and thus Eqns. (4) and (5) to let U be any orthogonal matrix (clearly, with fewer than d columns) spanning the column space of A. From a numerical perspective, things are substantially more subtle, and we leave this for future work that considers numerical implementations of our algorithms.\nbelow, these probabilities have played an important role in recent work on randomized matrix algorithms and an important algorithmic question is the degree to which they are uniform or nonuniform.2 Second, one could also define leverage scores for the columns of a “tall” matrix A, but clearly those are all equal to one unless n < d or A is rank-deficient. Third, and more generally, given a rank parameter k, one can define the statistical leverage scores relative to the best rank-k approximation to A to be the n diagonal elements of the projection matrix onto the span of Ak, the best rank-k approximation to A."
    }, {
      "heading" : "1.2 Our main result",
      "text" : "Our main result is a randomized algorithm for computing relative-error approximations to every statistical leverage score, as well as an additive-error approximation to all of the large crossleverage scores, of an arbitrary n × d matrix, with n ≫ d, in time qualitatively faster than the time required to compute an orthogonal basis for the range of that matrix. Our main algorithm for computing approximations to the statistical leverage scores (see Algorithm 1 in Section 3) will amount to constructing a “randomized sketch” of the input matrix and then computing the Euclidean norms of the rows of that sketch. This sketch can also be used to compute approximations to the large cross-leverage scores (see Algorithm 2 of Section 3).\nThe following theorem provides our main quality-of-approximation and running time result for Algorithm 1.\nTheorem 1. Let A be a full-rank n×d matrix, with n ≫ d; let ǫ ∈ (0, 1/2] be an error parameter; and recall the definition of the statistical leverage scores ℓi from Definition 1. Then, there exists a randomized algorithm (Algorithm 1 of Section 3 below) that returns values ℓ̃i, for all i ∈ {1, . . . , n}, such that with probability at least 0.8,\n∣ ∣ ∣ ℓi − ℓ̃i ∣ ∣ ∣ ≤ ǫℓi (6)\nholds for all i ∈ {1, . . . , n}. Assuming d ≤ n ≤ ed, the running time of the algorithm is\nO ( nd ln ( dǫ−1 ) + ndǫ−2 lnn+ d3ǫ−2 (lnn) ( ln ( dǫ−1 ))) .\nAlgorithm 1 provides a relative-error approximation to all of the statistical leverage scores ℓi of A and, assuming d ln d = o (\nn lnn\n)\n, lnn = o (d), and treating ǫ as a constant, its running time is o(nd2), as desired. As a corollary, the largest leverage score (and thus the coherence) is approximated to relative-error in o(nd2) time.\nThe following theorem provides our main quality-of-approximation and running time result for Algorithm 2.\nTheorem 2. Let A be a full-rank n×d matrix, with n ≫ d; let ǫ ∈ (0, 1/2] be an error parameter; let κ be a parameter; and recall the definition of the cross-leverage scores cij from Definition 1. Then, there exists a randomized algorithm (Algorithm 2 of Section 3 below) that returns the pairs {(i, j)} together with estimates {c̃ij} such that, with probability at least 0.8,\ni. If c2ij ≥ d\nκ + 12ǫℓiℓj, then (i, j) is returned; if (i, j) is returned, then c\n2 ij ≥\nd κ − 30ǫℓiℓj.\nii. For all pairs (i, j) that are returned, c̃2ij − 30ǫℓiℓj ≤ c2ij ≤ c̃2ij + 12ǫℓiℓj. 2Observe that if U consists of d columns from the identity, then the leverage scores are extremely nonuniform: d of them are equal to one and the remainder are equal to zero. On the other hand, if U consists of d columns from a normalized Hadamard transform (see Section 2.3 for a definition), then the leverage scores are very uniform: all n of them are equal to d/n.\nThis algorithm runs in O(ǫ−2n lnn+ ǫ−3κd ln2 n) time.\nNote that by setting κ = n lnn, we can compute all the “large” cross-leverage scores, i.e., those satisfying c2ij ≥ dn lnn , to within additive-error in O ( nd ln3 n ) time (treating ǫ as a constant). If ln3 n = o (d) the overall running time is o(nd2), as desired."
    }, {
      "heading" : "1.3 Significance and related work",
      "text" : "Our results are important for their applications to fast randomized matrix algorithms, as well as their applications in numerical linear algebra and large-scale data analysis more generally.\nSignificance in theoretical computer science. The statistical leverage scores define the key structural nonuniformity that must be dealt with (i.e., either rapidly approximated or rapidly uniformized at the preprocessing step) in developing fast randomized algorithms for matrix problems such as least-squares regression [45, 22] and low-rank matrix approximation [39, 45, 21, 33, 12]. Roughly, the best random sampling algorithms use these scores (or the generalized leverage scores relative to the best rank-k approximation to A) as an importance sampling distribution to sample with respect to. On the other hand, the best random projection algorithms rotate to a basis where these scores are approximately uniform and thus in which uniform sampling is appropriate. See [32] for a detailed discussion.\nAs an example, the CUR decomposition of [21, 33] essentially computes pi = ℓi/k, for all i ∈ {1, . . . , n} and for a rank parameter k, and it uses these as an importance sampling distribution. The computational bottleneck for these and related random sampling algorithms is the computation of the importance sampling probabilities. On the other hand, the computational bottleneck for random projection algorithms is the application of the random projection, which is sped up by using variants of the Fast Johnson-Lindenstrauss Transform [2, 3]. By our main result, the leverage scores (and thus these probabilities) can be approximated in time that depends on an application of a Fast Johnson-Lindenstrauss Transform. In particular, the random sampling algorithms of [20, 21, 33] for least-squares approximation and low-rank matrix approximation now run in time that is essentially the same as the best corresponding random projection algorithm for those problems [45].\nApplications to numerical linear algebra. Recently, high-quality numerical implementations of variants of the basic randomized matrix algorithms have proven superior to traditional deterministic algorithms [44, 43, 6]. An important question raised by our main results is how these will compare with an implementation of our main algorithm. More generally, density functional theory [8] and uncertainty quantification [7] are two scientific computing areas where computing the diagonal elements of functions (such as a projection or inverse) of very large input matrices is common. For example, in the former case, “heuristic” methods based on using Chebychev polynomials have been used in numerical linear algebra to compute the diagonal elements of the projector [8]. Our main algorithm should have implications in both of these areas.\nApplications in large-scale data analysis. The statistical leverage scores and the scores relative to the best rank-k approximation to A are equal to the diagonal elements of the socalled “hat matrix” [29, 15]. As such, they have a natural statistical interpretation in terms of the “leverage” or “influence” associated with each of the data points [29, 14, 15]. In the context of regression problems, the ith leverage score quantifies the leverage or influence of the ith constraint/row of A on the solution of the overconstrained least squares optimization problem minx ‖Ax− b‖2 and the (i, j)-th cross leverage score quantifies how much influence or leverage the ith data point has on the jth least-squares fit (see [29, 14, 15] for details). When applied to lowrank matrix approximation problems, the leverage score ℓj quantifies the amount of leverage or influence exerted by the jth column of A on its optimal low-rank approximation. Historically, these quantities have been widely-used for outlier identification in diagnostic regression analysis [47, 16].\nMore recently, these scores (usually the largest scores) often have an interpretation in terms of the data and processes generating the data that can be exploited. For example, depending on the setting, they can have an interpretation in terms of high-degree nodes in data graphs, very small clusters in noisy data, coherence of information, articulation points between clusters, the value of a customer in a network, space localization in sensor networks, etc. [9, 42, 38, 30, 32]. In genetics, dense matrices of size thousands by hundreds of thousands (a size scale at which even traditional deterministic QR algorithms fail to run) constructed from DNA Single Nucleotide Polymorphisms (SNP) data are increasingly common, and the statistical leverage scores can correlate strongly with other metrics of genetic interest [41, 33, 19, 40]. Our main result will permit the computation of these scores and related quantities for significantly larger SNP data sets than has been possible previously [41, 19, 40, 24].\nRemark. Lest there be any confusion, we should emphasize our main contributions. First, note that statistical leverage and matrix coherence are important concepts in statistics and machine learning. Second, recall that several random sampling algorithms for ubiquitous matrix problems such as least-squares approximation and low-rank matrix approximation use leverage scores in a crucial manner; but until now these algorithms were Ω(TSVD), where TSVD is the time required to compute a QR decomposition or a partial SVD of the input matrix. Third, note that, in some cases, o(TSV D) algorithms exist for these problems based on fast random projections. But recall that the existence of those projection algorithms in no way implies that it is easy or obvious how to compute the statistical leverage scores efficiently. Fourth, one implication of our main result is that those random sampling algorithms can now be performed just as efficiently as those random projection algorithms; thus, the solution for those matrix problems can now be obtained while preserving the identity of the rows. That is, these problems can now be solved just as efficiently by using actual rows, rather than the arbitrary linear combinations of rows that are returned by random projections. Fifth, we provide a generalization to “fat” matrices and to obtaining the cross-leverage scores. Sixth, we develop algorithms that can compute leverage scores and related statistics even in streaming environments."
    }, {
      "heading" : "1.4 Empirical discussion of our algorithms",
      "text" : "Although the main contribution of our paper is to provide a rigorous theoretical understanding of fast leverage score approximation, our paper does analyze the theoretical performance of what is meant to be a practical algorithm. Thus, one might wonder about the empirical performance of our algorithms—for example, whether hidden constants render the algorithms useless for data of realistic size. Not surprisingly, this depends heavily on the quality of the numerical implementation, whether one is interested in “tall” or more general matrices, etc. We will consider empirical and numerical aspects of these algorithms in forthcoming papers, e.g., [25]. We will, however, provide here a brief summary of several numerical issues for the reader interested in these issues.\nEmpirically, the running time bottleneck for our main algorithm (Algorithm 1 of Section 3) applied to “tall” matrices is the application of the random projection Π1. Thus, empirically the running time is similar to the running time of random projection based methods for computing approximations to the least-squares problem, which is also dominated by the application of the random projection. The state of the art here is the Blendenpik algorithm of [6] and the LSRN algorithm of [34]. In their Blendenpik paper, Avron, Maymounkov, and Toledo showed that their high-quality numerical implementation of a Hadamard-based random projection (and associated least-squares computation) “beats Lapack’s3 direct dense least-squares solver by a large margin on essentially any dense tall matrix,” and they concluded that their empirical results “suggest\n3 Lapack (short for Linear Algebra PACKage) is a high-quality and widely-used software library of numerical\nroutines for solving a wide range of numerical linear algebra problems.\nthat random projection algorithms should be incorporated into future versions of Lapack” [6]. The LSRN algorithm of Meng, Saunders, and Mahoney improves Blendenpik in several respects, e.g., providing better handling of sparsity and rank deficiency, but most notably the random projection underlying LSRN is particularly appropriate for solving large problems on clusters with high communication cost, e.g., it has been shown to scale well on Amazon Elastic Cloud Compute clusters. Thus, our main algorithm should extend easily to these environments with the use of the random projection underlying LSRN. Moreover, for both Blendenpik and LSRN (when implemented with a Hadamard-based random projection), the hidden constants in the Hadamard-based random projection are so small that the random projection algorithm (and thus the empirical running time of our main algorithm for approximating leverage scores) beats the traditional O(nd2) time algorithm for dense matrices as small as thousands of rows by hundreds of columns."
    }, {
      "heading" : "1.5 Outline",
      "text" : "In Section 2, we will provide a brief review of relevant notation and concepts from linear algebra. Then, in Sections 3 and 4, we will present our main results: Section 3 will contain our main algorithm and Section 4 will contain the proof of our main theorem. Section 5 will then describe extensions of our main result to general “fat” matrices, i.e., those with n ≈ d. Section 6 will conclude by describing the relationship of our main result with another related estimator for the statistical leverage scores, an application of our main algorithm to the under-constrained least-squares approximation problem, and extensions of our main algorithm to streaming environments."
    }, {
      "heading" : "2 Preliminaries on linear algebra and fast random projections",
      "text" : ""
    }, {
      "heading" : "2.1 Basic linear algebra and notation",
      "text" : "Let [n] denote the set of integers {1, 2, . . . , n}. For any matrix A ∈ Rn×d, let A(i), i ∈ [n], denote the i-th row of A as a row vector, and let A(j), j ∈ [d] denote the j-th column of A as a column vector. Let ‖A‖2F = ∑n i=1 ∑d j=1A 2 ij denote the square of the Frobenius norm of A, and let ‖A‖2 = sup ‖x‖2=1 ‖Ax‖2 denote the spectral norm of A. Relatedly, for any vector x ∈ R n, its Euclidean norm (or ℓ2-norm) is the square root of the sum of the squares of its elements. The dot product between two vectors x, y ∈ Rn will be denoted 〈x, y〉, or alternatively as xT y. Finally, let ei ∈ Rn, for all i ∈ [n], denote the standard basis vectors for Rn and let In denote the n × n identity matrix.\nLet the rank of A be ρ ≤ min{n, d}, in which case the “compact” or “thin” SVD of A is denoted by A = UΣV T , where U ∈ Rn×ρ, Σ ∈ Rρ×ρ, and V ∈ Rd×ρ. (For a general matrix X, we will write X = UXΣXV T X .) Let σi(A), i ∈ [ρ] denote the i-th singular value of A, and let σmax(A) and σmin(A) denote the maximum and minimum singular values of A, respectively. The Moore-Penrose pseudoinverse of A is the d×n matrix defined by A† = V Σ−1UT [37]. Finally, for any orthogonal matrix U ∈ Rn×ℓ, let U⊥ ∈ Rn×(n−ℓ) denote an orthogonal matrix whose columns are an orthonormal basis spanning the subspace of Rn that is orthogonal to the subspace spanned by the columns of U (i.e., the range of U). It is always possible to extend an orthogonal matrix U to a full orthonormal basis of Rn as [U U⊥].\nThe SVD is important for a number of reasons [26]. For example, the projection of the columns of A onto the k left singular vectors associated with the top k singular values gives the best rank-k approximation to A in the spectral and Frobenius norms. Relatedly, the solution to the least-squares (LS) approximation problem is provided by the SVD: given an n × d matrix\nA and an n-vector b, the LS problem is to compute the minimum ℓ2-norm vector x such that ‖Ax− b‖2 is minimized over all vectors x ∈ Rd. This optimal vector is given by xopt = A†b. We call a LS problem overconstrained (or overdetermined) if n > d and underconstrained (or underdetermined) if n < d."
    }, {
      "heading" : "2.2 The Fast Johnson-Lindenstrauss Transform (FJLT)",
      "text" : "Given ǫ > 0 and a set of points x1, . . . , xn with xi ∈ Rd, a ǫ-Johnson-Lindenstrauss Transform (ǫ-JLT), denoted Π ∈ Rr×d, is a projection of the points into Rr such that\n(1− ǫ)‖xi‖22 ≤ ‖Πxi‖22 ≤ (1 + ǫ)‖xi‖22. (7)\nTo construct an ǫ-JLT with high probability, simply choose every entry of Π independently, equal to ± √\n3/r with probability 1/6 each and zero otherwise (with probability 2/3) [1]. Let ΠJLT be a matrix drawn from such a distribution over r × d matrices.4 Then, the following lemma holds.\nLemma 1 (Theorem 1.1 of [1]). Let x1, . . . , xn be an arbitrary (but fixed) set of points, where xi ∈ Rd and let 0 < ǫ ≤ 1/2 be an accuracy parameter. If\nr ≥ 1 ǫ2\n(\n12 ln n+ 6 ln 1\nδ\n)\nthen, with probability at least 1− δ, ΠJLT ∈ Rr×d is an ǫ-JLT .\nFor our main results, we will also need a stronger requirement than the simple ǫ-JLT and so we will use a version of the Fast Johnson-Lindenstrauss Transform (FJLT), which was originally introduced in [2, 3]. Consider an orthogonal matrix U ∈ Rn×d, viewed as d vectors in Rn. A FJLT projects the vectors from Rn to Rr, while preserving the orthogonality of U ; moreover, it does so very quickly. Specifically, given ǫ > 0, Π ∈ Rr×n is an ǫ-FJLT for U if\n• ∥ ∥Id − UTΠTΠU ∥ ∥ 2 ≤ ǫ, and\n• given any X ∈ Rn×d, the matrix product ΠX can be computed in O(nd ln r) time.\nThe next lemma follows from the definition of an ǫ-FJLT, and its proof can be found in [20, 22].\nLemma 2. Let A be any matrix in Rn×d with n ≫ d and rank(A) = d. Let the SVD of A be A = UΣV T , let Π be an ǫ-FJLT for U (with 0 < ǫ ≤ 1/2) and let Ψ = ΠU = UΨΣΨV TΨ . Then, all the following hold:\nrank(ΠA) = rank(ΠU) = rank(U) = rank(A) = d, (8) ∥ ∥I − Σ−2Ψ ∥ ∥ 2 ≤ ǫ/(1− ǫ), and (9)\n(ΠA)† = V Σ−1(ΠU)†. (10)"
    }, {
      "heading" : "2.3 The Subsampled Randomized Hadamard Transform (SRHT)",
      "text" : "One can use a Randomized Hadamard Transform (RHT) to construct, with high probability, an ǫ-FJLT. Our main algorithm will use this efficient construction in a crucial way.5 Recall that the\n4When no confusion can arise, we will use ΠJLT to refer to this distribution over matrices as well as to a specific matrix drawn from this distribution.\n5Note that the RHT has also been crucial in the development of o(nd2) randomized algorithms for the general overconstrained LS problem [22] and its variants have been used to provide high-quality numerical implementations of such randomized algorithms [44, 6].\n(unnormalized) n× n matrix of the Hadamard transform Ĥn is defined recursively by\nĤ2n =\n[\nĤn Ĥn Ĥn −Ĥn\n]\n,\nwith Ĥ1 = 1. The n× n normalized matrix of the Hadamard transform is equal to\nHn = Ĥn/ √ n.\nFrom now on, for simplicity and without loss of generality, we assume that n is a power of 2 and we will suppress n and just write H. (Variants of this basic construction that relax this assumption and that are more appropriate for numerical implementation have been described and evaluated in [6].) Let D ∈ Rn×n be a random diagonal matrix with independent diagonal entries Dii = +1 with probability 1/2 and Dii = −1 with probability 1/2. The product HD is a RHT and it has three useful properties. First, when applied to a vector, it “spreads out” its energy. Second, computing the product HDx for any vector x ∈ Rn takes O(n log2 n) time. Third, if we only need to access r elements in the transformed vector, then those r elements can be computed in O(n log2 r) time [4]. The Subsampled Randomized Hadamard Transform (SRHT) randomly samples (according to the uniform distribution) a set of r rows of a RHT.\nUsing the sampling matrix formalism described previously [18, 20, 21, 22], we will represent the operation of randomly sampling r rows of an n× d matrix A using an r × n linear sampling operator ST . Let the matrix ΠFJLT = S\nTHD be generated using the SRHT.6 The most important property about the distribution ΠFJLT is that if r is large enough, then, with high probability, ΠFJLT generates an ǫ-FJLT. We summarize this discussion in the following lemma (which is essentially a combination of Lemmas 3 and 4 from [22], restated to fit our notation).\nLemma 3. Let ΠFJLT ∈ Rr×n be generated using the SRHT as described above and let U ∈ Rn×d (n ≫ d) be an (arbitrary but fixed) orthogonal matrix. If\nr ≥ 14 2d ln(40nd)\nǫ2 ln\n(\n302d ln(40nd)\nǫ2\n)\n,\nthen, with probability at least 0.9, ΠFJLT is an ǫ-FJLT for U ."
    }, {
      "heading" : "3 Our main algorithmic results",
      "text" : "In this section, we will describe our main results for computing relative-error approximations to every statistical leverage score (see Algorithm 1) as well as additive-error approximations to all of the large cross-leverage scores (see Algorithm 2) of an arbitrary matrix A ∈ Rn×d, with n ≫ d. Both algorithms make use of a “randomized sketch” of A of the form A(Π1A)\n†Π2, where Π1 is an ǫ-FJLT and Π2 is an ǫ-JLT. We start with a high-level description of the basic ideas."
    }, {
      "heading" : "3.1 Outline of our basic approach",
      "text" : "Recall that our first goal is to approximate, for all i ∈ [n], the quantities\nℓi = ∥ ∥U(i) ∥ ∥ 2\n2 =\n∥ ∥eTi U ∥ ∥\n2 2 , (11)\n6Again, when no confusion can arise, we will use ΠFJLT to denote a specific SRHT or the distribution on matrices implied by the randomized process for constructing an SRHT.\nwhere ei is a standard basis vector. The hard part of computing the scores ℓi according to Eqn. (11) is computing an orthogonal matrix U spanning the range of A, which takes O(nd2) time. Since UUT = AA†, it follows that\nℓi = ∥ ∥eTi UU T ∥ ∥\n2 2 =\n∥ ∥ ∥ eTi AA † ∥ ∥ ∥ 2\n2 =\n∥ ∥\n∥ (AA†)(i)\n∥ ∥ ∥ 2\n2 , (12)\nwhere the first equality follows from the orthogonality of (the columns of) U . The hard part of computing the scores ℓi according to Eqn. (12) is two-fold: first, computing the pseudoinverse; and second, performing the matrix-matrix multiplication of A and A†. Both of these procedures take O(nd2) time. As we will see, we can get around both of these bottlenecks by the judicious application of random projections to Eqn. (12).\nTo get around the bottleneck of O(nd2) time due to computing A† in Eqn. (12), we will compute the pseudoinverse of a “smaller” matrix that approximates A. A necessary condition for such a smaller matrix is that it preserves rank. So, näıve ideas such as uniformly sampling r1 ≪ n rows from A and computing the pseudoinverse of this sampled matrix will not work well for an arbitrary A. For example, this idea will fail (with high probability) to return a meaningful approximation for matrices consisting of n − 1 identical rows and a single row with a nonzero component in the direction perpendicular to that the identical rows; finding that “outlying” row is crucial to obtaining a relative-error approximation. This is where the SRHT enters, since it preserves important structures of A, in particular its rank, by first rotating A to a random basis and then uniformly sampling rows from the rotated matrix (see [22] for more details). More formally, recall that the SVD of A is UΣV T and let Π1 ∈ Rr1×n be an ǫ-FJLT for U (using, for example, the SRHT of Lemma 3 with the appropriate choice for r1). Then, one could approximate the ℓi’s of Eqn. (12) by\nℓ̂i = ∥ ∥ ∥ eTi A (Π1A) † ∥ ∥ ∥ 2\n2 , (13)\nwhere we approximated the n × d matrix A by the r1 × d matrix Π1A. Computing A (Π1A)† in this way takes O (ndr1) time, which is not efficient because r1 > d (from Lemma 3).\nTo get around this bottleneck, recall that we only need the Euclidean norms of the rows of the matrix A (Π1A)\n† ∈ Rn×r1 . Thus, we can further reduce the dimensionality of this matrix by using an ǫ-JLT to reduce the dimension r1 = Ω(d) to r2 = O(lnn). Specifically, let Π T 2 ∈ Rr2×r1 be an ǫ-JLT for the rows of A (Π1A) † (viewed as n vectors in Rr1) and consider the matrix Ω = A (Π1A) †Π2. This n× r2 matrix Ω may be viewed as our “randomized sketch” of the rows of AA†. Then, we can compute and return\nℓ̃i = ∥ ∥ ∥ eTi A (Π1A) †Π2 ∥ ∥ ∥ 2\n2 , (14)\nfor each i ∈ [n], which is essentially what Algorithm 1 does. Not surprisingly, the sketch A (Π1A)\n†Π2 can be used in other ways: for example, by considering the dot product between two different rows of this randomized sketching matrix (and some additional manipulations) Algorithm 2 approximates the large cross-leverage scores of A."
    }, {
      "heading" : "3.2 Approximating all the statistical leverage scores",
      "text" : "Our first main result is Algorithm 1, which takes as input an n × d matrix A and an error parameter ǫ ∈ (0, 1/2], and returns as output numbers ℓ̃i, i ∈ [n]. Although the basic idea to approximate ∥ ∥(AA†)(i) ∥ ∥ 2 was described in the previous section, we can improve the efficiency of our approach by avoiding the full sketch of the pseudoinverse. In particular, let Â = Π1A and let its SVD be Â = U\nÂ Σ Â V T Â . Let R−1 = V Â Σ−1 Â and note that R−1 ∈ Rd×d is an orthogonalizer\nInput: A ∈ Rn×d (with SVD A = UΣV T ), error parameter ǫ ∈ (0, 1/2]. Output: ℓ̃i, i ∈ [n].\n1. Let Π1 ∈ Rr1×n be an ǫ-FJLT for U , using Lemma 3 with\nr1 = Ω\n(\nd lnn\nǫ2 ln\n(\nd lnn\nǫ2\n))\n.\n2. Compute Π1A ∈ Rr1×d and its SVD, Π1A = UΠ1AΣΠ1AV TΠ1A. Let R−1 = VΠ1AΣ −1 Π1A\n∈ Rd×d. (Alternatively, R could be computed by a QR factorization of Π1A.)\n3. View the normalized rows of AR−1 ∈ Rn×d as n vectors in Rd, and construct Π2 ∈ Rd×r2 to be an ǫ-JLT for n2 vectors (the aforementioned n vectors and their n2 − n pairwise sums), using Lemma 1 with\nr2 = O ( ǫ−2 lnn ) .\n4. Construct the matrix product Ω = AR−1Π2.\n5. For all i ∈ [n] compute and return ℓ̃i = ∥ ∥Ω(i) ∥ ∥ 2\n2 .\nAlgorithm 1: Approximating the (diagonal) statistical leverage scores ℓi.\nfor Â since U Â = ÂR−1 is an orthogonal matrix.7 In addition, note that AR−1 is approximately orthogonal. Thus, we can compute AR−1 and use it as an approximate orthogonal basis for A and then compute ℓ̂i as the squared row-norms of AR\n−1. The next lemma states that this is exactly what our main algorithm does; even more, we could get the same estimates by using any “orthogonalizer” of Π1A.\nLemma 4. Let R−1 be such that Q = Π1AR−1 is an orthogonal matrix with rank(Q) = rank(Π1A). Then, ∥ ∥(AR−1)(i) ∥ ∥ 2\n2 = ℓ̂i.\nProof. Since Â = Π1A has rank d (by Lemma 2) and R −1 preserves this rank, R−1 is a d × d invertible matrix. Using Â = QR and properties of the pseudoinverse, we get ( Â )† = R−1QT .\nThus,\nℓ̂i = ∥ ∥ ∥ (A (Π1A) †)(i) ∥ ∥ ∥ 2\n2 =\n∥ ∥ ∥ ( AR−1QT )\n(i)\n∥ ∥ ∥ 2\n2 =\n∥ ∥ ∥ ( AR−1 )\n(i) QT\n∥ ∥ ∥ 2\n2 =\n∥ ∥ ∥ ( AR−1 )\n(i)\n∥ ∥ ∥ 2\n2 .\nThis lemma says that the ℓ̂i of Eqn. (13) can be computed with any QR decomposition, rather than with the SVD; but note that one would still have to post-multiply by Π2, as in Algorithm 1, in order to compute “quickly” the approximations of the leverage scores.\n7This preprocessing is reminiscent of how [44, 6] preprocessed the input to provide numerical implementations of the fast relative-error algorithm [22] for approximate LS approximation. From this perspective, Algorithm 1 can be viewed as specifying a particular basis Q, i.e., as choosing Q to be the left singular vectors of Π1A."
    }, {
      "heading" : "3.3 Approximating the large cross-leverage scores",
      "text" : "By combining Lemmas 6 and 7 (in Section 4.2 below) with the triangle inequality, one immediately obtains the following lemma.\nLemma 5. Let Ω be either the sketching matrix constructed by Algorithm 1, i.e., Ω = AR−1Π2, or Ω = A (Π1A)\n†Π2 as described in Section 3.1. Then, the pairwise dot-products of the rows of Ω are additive-error approximations to the leverage scores and cross-leverage scores:\n∣ ∣〈U(i), U(j)〉 − 〈Ω(i),Ω(j)〉 ∣ ∣ ≤ 3ǫ 1− ǫ ∥ ∥U(i) ∥ ∥ 2 ∥ ∥U(j) ∥ ∥ 2 .\nThat is, if one were interested in obtaining an approximation to all the cross-leverage scores to within additive error (and thus the diagonal statistical leverage scores to relative-error), then the algorithm which first computes Ω followed by all the pairwise inner products achieves this in time T (Ω) + O ( n2r2 ) , where T (Ω) is the time to compute Ω from Section 3.2 and r2 = O(ǫ −2 lnn).8 The challenge is to avoid the n2 computational complexity and this can be done if one is interested only in the large cross-leverage scores.\nOur second main result is provided by Algorithms 2 and 3. Algorithm 2 takes as input an n×d matrix A, a parameter κ > 1, and an error parameter ǫ ∈ (0, 1/2], and returns as output a subset of [n]× [n] and estimates c̃ij satisfying Theorem 2. The first step of the algorithm is to compute the matrix Ω = AR−1Π2 constructed by Algorithm 1. Then, Algorithm 2 uses Algorithm 3 as a subroutine to compute “heavy hitter” pairs of rows from a matrix.\nInput: A ∈ Rn×d and parameters κ > 1, ǫ ∈ (0, 1/2]. Output: The set H consisting of pairs (i, j) together with estimates c̃ij satisfying Theorem 2.\n1. Compute the n× r2 matrix Ω = AR−1Π2 from Algorithm 1.\n2. Use Algorithm 3 with inputs Ω and κ′ = κ(1 + 30dǫ) to obtain the set H containing all the κ′-heavy pairs of Ω.\n3. Return the pairs in H as the κ-heavy pairs of A.\nAlgorithm 2: Approximating the large (off-diagonal) cross-leverage scores cij ."
    }, {
      "heading" : "4 Proofs of our main theorems",
      "text" : ""
    }, {
      "heading" : "4.1 Sketch of the proof of Theorems 1 and 2",
      "text" : "We will start by providing a sketch of the proof of Theorems 1 and 2. A detailed proof is provided in the next two subsections. In our analysis, we will condition on the events that Π1 ∈ Rr1×n is an ǫ-FJLT for U and Π2 ∈ Rr1×r2 is an ǫ-JLT for n2 points in Rr1 . Note that by setting δ = 0.1 in Lemma 1, both events hold with probability at least 0.8, which is equal to the success probability of Theorems 1 and 2. The algorithm estimates ℓ̃i = ‖ũi‖22, where ũi = eTi A(Π1A)†Π2. First,\n8The exact algorithm which computes a basis first and then the pairwise inner products requires O(nd2 + n2d) time. Thus, by using the sketch, we can already improve on this running time by a factor of d/ lnn.\nInput: X ∈ Rn×r with rows x1, . . . , xn and a parameter κ > 1. Output: H = {(i, j), c̃ij} containing all heavy (unordered) pairs. The pair (i, j), c̃ij ∈ H if and only if c̃2ij = 〈xi, xj〉2 ≥ ∥ ∥XTX ∥ ∥ 2 F /κ.\n1: Compute the norms ‖xi‖2 and sort the rows according to norm, so that ‖x1‖2 ≤ · · · ≤ ‖xn‖2. 2: H ← {}; z1 ← n; z2 ← 1. 3: while z2 ≤ z1 do 4: while ‖xz1‖22‖xz2‖22 < ∥ ∥XTX ∥ ∥ 2 F /κ do 5: z2 ← z2 + 1. 6: if z2 > z1 then 7: return H. 8: end if\n9: end while\n10: for each pair (i, j) where i = z1 and j ∈ {z2, z2 + 1, . . . , z1} do 11: c̃2ij = 〈xi, xj〉2. 12: if c̃2ij ≥ ∥ ∥XTX ∥ ∥ 2 F /κ then 13: add (i, j) and c̃ij to H. 14: end if 15: z1 ← z1 − 1. 16: end for 17: end while 18: return H.\nAlgorithm 3: Computing heavy pairs of a matrix.\nobserve that the sole purpose of Π2 is to improve the running time while preserving pairwise inner products; this is achieved because Π2 is an ǫ-JLT for n 2 points. So, the results will follow if\neTi A(Π1A) †((Π1A) †)TAT ej ≈ eTi UUT ej and (Π1A) † can be computed efficiently. Since Π1 is an ǫ-FJLT for U , where A = UΣV T , (Π1A)† can be computed in O(nd ln r1 + r1d 2) time. By Lemma 2, (Π1A) † = V Σ−1(Π1U)†, and so\neTi A(Π1A) †((Π1A) †)TAT ej = e T i U(Π1U) †(Π1U) †TUT ej .\nSince Π1 is an ǫ-FJLT for U , it follows that (Π1U) †(Π1U)† T ≈ Id, i.e., that Π1U is approximately orthogonal. Theorem 1 follows from this basic idea. However, in order to prove Theorem 2, having a sketch which preserves inner products alone is not sufficient. We also need a fast algorithm to identify the large inner products and to relate these to the actual cross-leverage scores. Indeed, it is possible to efficiently find pairs of rows in a general matrix with large inner products. Combining this with the fact that the inner products are preserved, we obtain Theorem 2."
    }, {
      "heading" : "4.2 Proof of Theorem 1",
      "text" : "We condition all our analysis on the events that Π1 ∈ Rr1×n is an ǫ-FJLT for U and Π2 ∈ Rr1×r2 is an ǫ-JLT for n2 points in Rr1 . Define\nûi = e T i A(Π1A)\n†, and\nũi = e T i A(Π1A) †Π2.\nThen, ℓ̂i = ‖ûi‖22 and ℓ̃i = ‖ũi‖22. The proof will follow from the following two lemmas. Lemma 6. For i, j ∈ [n],\n∣ ∣〈U(i), U(j)〉 − 〈ûi, ûj〉 ∣ ∣ ≤ ǫ 1− ǫ ∥ ∥U(i) ∥ ∥ 2 ∥ ∥U(j) ∥ ∥ 2 . (15)\nLemma 7. For i, j ∈ [n], |〈ûi, ûj〉 − 〈ũi, ũj〉| ≤ 2ǫ‖ûi‖2‖ûj‖2. (16)\nLemma 6 states that 〈ûi, ûj〉 is an additive error approximation to all the cross-leverage scores (i 6= j) and a relative error approximation for the diagonals (i = j). Similarly, Lemma 7 shows that these cross-leverage scores are preserved by Π2. Indeed, with i = j, from Lemma 6 we have |ℓ̂i − ℓi| ≤ ǫ1−ǫℓi, and from Lemma 7 we have |ℓ̂i − ℓ̃i| ≤ 2ǫℓ̂i. Using the triangle inequality and ǫ ≤ 1/2:\n∣ ∣ ∣ ℓi − ℓ̃i ∣ ∣ ∣ = ∣ ∣ ∣ ℓi − ℓ̂i + ℓ̂i − ℓ̃i ∣ ∣ ∣ ≤ ∣ ∣ ∣ ℓi − ℓ̂i ∣ ∣ ∣ + ∣ ∣ ∣ ℓ̂i − ℓ̃i ∣ ∣ ∣ ≤\n(\nǫ 1− ǫ + 2ǫ ) ℓi ≤ 4ǫℓi.\nThe theorem follows after rescaling ǫ.\nProof of Lemma 6. Let A = UΣV T . Using this SVD of A and Eqn. (10) in Lemma 2,\n〈ûi, ûj〉 = eTi UΣV TV Σ−1 (Π1U)† (Π1U)† T Σ−1V TV ΣUT ej = e T i U (Π1U) † (Π1U) †TUT ej.\nBy performing standard manipulations, we can now bound ∣ ∣〈U(i), U(j)〉 − 〈ûi, ûj〉 ∣ ∣:\n∣ ∣〈U(i), U(j)〉 − 〈ûi, ûj〉 ∣ ∣ = eTi UU T ej − eTi U (Π1U)† (Π1U)†T UT ej\n= eTi U ( Id − (Π1U)† (Π1U)†T ) UT ej ≤ ∥ ∥ ∥ Id − (Π1U)† (Π1U)†T ∥ ∥ ∥\n2\n∥ ∥U(i) ∥ ∥\n2\n∥ ∥U(j) ∥ ∥\n2 .\nLet the SVD of Ψ = Π1U be Ψ = UΨΣΨV T Ψ , where VΨ is a full rotation in d dimensions (because rank(A) = rank(Π1U)). Then, Ψ †Ψ† T = VΨΣ −2 Ψ V T Ψ . Thus,\n∣ ∣〈U(i), U(j)〉 − 〈ûi, ûj〉 ∣ ∣ ≤ ∥ ∥Id − VΨΣ−2Ψ V TΨ ∥ ∥\n2\n∥ ∥U(i) ∥ ∥\n2\n∥ ∥U(j) ∥ ∥\n2\n= ∥ ∥VΨV T Ψ − VΨΣ−2Ψ V TΨ ∥ ∥\n2\n∥ ∥U(i) ∥ ∥\n2\n∥ ∥U(j) ∥ ∥\n2\n= ∥ ∥Id − Σ−2Ψ ∥ ∥\n2\n∥ ∥U(i) ∥ ∥\n2\n∥ ∥U(j) ∥ ∥\n2 ,\nwhere we used the fact that VΨV T Ψ = V T Ψ VΨ = Id and the unitary invariance of the spectral norm. Finally, using Eqn. (9) of Lemma 2 the result follows.\nProof of Lemma 7. Since Π2 is an ǫ-JLT for n 2 vectors, it preserves the norms of an arbitrary (but fixed) collection of n2 vectors. Let xi = ûi/‖ûi‖2. Consider the following n2 vectors:\nxi for i ∈ [n], and xi + xj for i, j ∈ [n], i 6= j.\nBy the ǫ-JLT property of Π2 and the fact that ‖xi‖2 = 1,\n1− ǫ ≤ ‖xiΠ2‖22 ≤ 1 + ǫ for i ∈ [n], and (17) (1− ǫ)‖xi + xj‖22 ≤ ‖xiΠ2 + xjΠ2‖ 2 2 ≤ (1 + ǫ)‖xi + xj‖ 2 2 for i, j ∈ [n], i 6= j. (18)\nCombining Eqns. (17) and (18) after expanding the squares using the identity ‖a+ b‖2 = ‖a‖2 + ‖b‖2 + 2〈a, b〉, substituting ‖xi‖ = 1, and after some algebra, we obtain\n〈xi, xj〉 − 2ǫ ≤ 〈xiΠ2, xjΠ2〉 ≤ 〈xi, xj〉+ 2ǫ.\nTo conclude the proof, multiply throughout by ‖ûi‖‖ûj‖ and use the homogeneity of the inner product, together with the linearity of Π2, to obtain:\n〈ûi, ûj〉 − 2ǫ‖ûi‖‖ûj‖ ≤ 〈ûiΠ2, ûjΠ2〉 ≤ 〈ûi, ûj〉+ 2ǫ‖ûi‖‖ûj‖.\nRunning Times. By Lemma 4, we can use VΠ1AΣ −1 Π1A instead of (Π1A) † and obtain the same estimates. Since Π1 is an ǫ-FJLT, the product Π1A can be computed in O(nd ln r1) while its SVD takes an additional O(r1d 2) time to return VΠ1AΣ −1 Π1A\n∈ Rd×d. Since Π2 ∈ Rd×r2 , we obtain VΠ1AΣ −1 Π1A\nΠ2 ∈ Rd×r2 in an additional O(r2d2) time. Finally, premultiplying by A takes O(ndr2) time, and computing and returning the squared row-norms of Ω = AVΠ1AΣ −1 Π1A\nΠ2 ∈ Rn×r2 takes O (nr2) time. So, the total running time is the sum of all these operations, which is\nO(nd ln r1 + ndr2 + r1d 2 + r2d 2).\nFor our implementations of the ǫ-JLTs and ǫ-FJLTs (δ = 0.1), r1 = O ( ǫ−2d (lnn) ( ln ( ǫ−2d ln n ))) and r2 = O(ǫ −2 lnn). It follows that the asymptotic running time is\nO ( nd ln ( dǫ−1 ) + ndǫ−2 lnn+ d3ǫ−2 (lnn) ( ln ( dǫ−1 ))) .\nTo simplify, suppose that d ≤ n ≤ ed and treat ǫ as a constant. Then, the asymptotic running time is\nO ( nd lnn+ d3 (lnn) (ln d) ) ."
    }, {
      "heading" : "4.3 Proof of Theorem 2",
      "text" : "We first construct an algorithm to estimate the large inner products among the rows of an arbitrary matrix X ∈ Rn×r with n > r. This general algorithm will be applied to the matrix Ω = AVΠ1AΣ −1 Π1A\nΠ2. Let x1, . . . , xn denote the rows of X; for a given κ > 1, the pair (i, j) is heavy if\n〈xi, xj〉2 ≥ 1\nκ\n∥ ∥XTX ∥ ∥\n2 F .\nBy the Cauchy-Schwarz inequality, this implies that\n‖xi‖22‖xj‖22 ≥ 1\nκ\n∥ ∥XTX ∥ ∥\n2 F , (19)\nso it suffices to find all the pairs (i, j) for which Eqn. (19) holds. We will call such pairs normheavy. Let s be the number of norm-heavy pairs satisfying Eqn. (19). We first bound the number of such pairs.\nLemma 8. Using the above notation, s ≤ κr.\nProof. Observe that\nn ∑\ni,j=1\n‖xi‖22‖xj‖22 = ( n ∑\ni=1\n‖xi‖22\n)2 = ‖X‖4F = ( r ∑\ni=1\nσ2i\n)2\n,\nwhere σ1, . . . , σr are the singular values of X. To conclude, by the definition of a heavy pair,\n∑\ni,j\n‖xi‖22‖xj‖22 ≥ s\nκ\n∥ ∥XTX ∥ ∥\n2 F =\ns\nκ\nr ∑\ni=1\nσ4i ≥ s\nκr\n(\nr ∑\ni=1\nσ2i\n)2\n,\nwhere the last inequality follows by Cauchy-Schwarz.\nAlgorithm 3 starts by computing the norms ‖xi‖22 for all i ∈ [n] and sorting them (in O (nr + n lnn) time) so that we can assume that ‖x1‖2 ≤ · · · ≤ ‖xn‖2. Then, we initialize the set of norm-heavy pairs to H = {} and we also initialize two pointers z1 = n and z2 = 1. The basic loop in the algorithm checks if z2 > z1 and stops if that is the case. Otherwise, we increment z2 to the first pair (z1, z2) that is norm-heavy. If none of pairs are norm heavy (i.e., z2 > z1 occurs), then we stop and output H; otherwise, we add (z1, z2), (z1, z2 + 1), . . . , (z1, z1) to H. This basic loop computes all pairs (z1, i) with i ≤ z1 that are norm-heavy. Next, we decrease z1 by one and if z1 < z2 we stop and output H; otherwise, we repeat the basic loop. Note that in the basic loop z2 is always incremented. This occurs whenever the pair (z1, z2) is not norm-heavy. Since z2 can be incremented at most n times, the number of times we check whether a pair is norm-heavy and fail is at most n. Every successful check results in the addition of at least one norm-heavy pair into H and thus the number of times we check if a pair is norm heavy (a constant-time operation) is at most n + s. The number of pair additions into H is exactly s and thus the total running time is O(nr+ n lnn+ s). Finally, we must check each norm-heavy pair to verify whether or not it is actually heavy by computing s inner products vectors in Rr; this can be done in O(sr) time. Using s ≤ κr we get the following lemma.\nLemma 9. Algorithm 3 returns H including all the heavy pairs of X in O(nr + κr2 + n lnn) time.\nTo complete the proof, we apply Algorithm 3 with Ω = AVΠ1AΣ −1 Π1A Π2 ∈ Rn×r2 , where r2 = O(ǫ−2 lnn). Let ũ1, . . . , ũn denote the rows of Ω and recall that A = UΣV T . Let u1, . . . , un denote the rows of U ; then, from Lemma 5,\n〈ui, uj〉 − 3ǫ 1− ǫ‖ui‖‖uj‖ ≤ 〈ũi, ũj〉 ≤ 〈ui, uj〉+ 3ǫ 1− ǫ‖ui‖‖uj‖. (20)\nGiven ǫ, κ, assume that for the pair of vectors ui and uj\n〈ui, uj〉2 ≥ 1\nκ\n∥ ∥UTU ∥ ∥\n2 F + 12ǫ‖ui‖2‖uj‖2 =\nd κ + 12ǫ‖ui‖2‖uj‖2,\nwhere the last equality follows from ∥ ∥UTU ∥ ∥ 2 F = ‖Id‖2F = d. By Eqn. (20), after squaring and using ǫ < 0.5,\n〈ui, uj〉2 − 12ǫ‖ui‖2ǫ‖uj‖2 ≤ 〈ũi, ũj〉2 ≤ 〈ui, uj〉2 + 30ǫ‖ui‖2‖uj‖2. (21)\nThus, 〈ũi, ũj〉2 ≥ d/κ and summing Eqn. (21) over all i, j we get ∥ ∥ΩTΩ ∥ ∥ 2 F ≤ d + 30ǫd2, or, equivalently,\nd ≥ ∥ ∥ΩTΩ ∥ ∥ 2 F\n1 + 30dǫ .\nWe conclude that\n〈ui, uj〉2 ≥ d\nκ + 12ǫ‖ui‖2‖uj‖2 =⇒ 〈ũi, ũj〉2 ≥\nd κ ≥\n∥ ∥ΩTΩ ∥ ∥ 2\nF\nκ(1 + 30dǫ) . (22)\nBy construction, Algorithm 3 is invoked with κ′ = κ ∥ ∥ΩTΩ ∥ ∥ 2\nF /d and thus it finds all pairs with\n〈ũi, ũj〉2 ≥ ∥ ∥ΩTΩ ∥ ∥ 2 F /κ′ = d/κ. This set contains all pairs for which\n〈ui, uj〉2 ≥ d\nκ + 12ǫ‖ui‖2‖uj‖2.\nFurther, since every pair returned satisfies 〈ũi, ũj〉2 ≥ d/κ, by Eqn. (21), cij ≥ d/κ−30ǫℓiℓj . This proves the first claim of the Theorem; the second claim follows analogously from Eqn. (21).\nUsing Lemma 9, the running time of our approach is O ( nr2 + κ ′r22 + n lnn ) . Since r2 =\nO ( ǫ−2 lnn ) , and, by Eqn. (22), κ′ = κ ∥ ∥ΩTΩ ∥ ∥ 2 F /d ≤ κ(1 + 30dǫ), the overall running time is O ( ǫ−2n lnn+ ǫ−3κd ln2 n ) ."
    }, {
      "heading" : "5 Extending our algorithm to general matrices",
      "text" : "In this section, we will describe an important extension of our main result, namely the computation of the statistical leverage scores relative to the best rank-k approximation to a general matrix A. More specifically, we consider the estimation of leverage scores for the case of general “fat” matrices, namely input matrices A ∈ Rn×d, where both n and d are large, e.g., when d = n or d = Θ(n). Clearly, the leverage scores of any full rank n× n matrix are exactly uniform. The problem becomes interesting if one specifies a rank parameter k ≪ min{n, d}. This may arise when the numerical rank of A is small (e.g., in some scientific computing applications, more than 99% of the spectral norm of A may be captured by some k ≪ min{n, d} directions), or, more generally, when one is interested in some low rank approximation to A (e.g., in some data analysis applications, a reasonable fraction or even the majority of the Frobenius norm of A may be captured by some k ≪ min{n, d} directions, where k is determined by some exogenously-specified model selection criterion). Thus, assume that in addition to a general n × d matrix A, a rank parameter k < min{n, d} is specified. In this case, we wish to obtain the statistical leverage scores ℓi = ∥ ∥(Uk)(i) ∥ ∥ 2\n2 for Ak = UkΣkV T k , the best rank-k approximation to A. Equivalently, we\nseek the normalized leverage scores\npi = ℓi k . (23)\nNote that ∑n i=1 pi = 1 since ∑n i=1 ℓi = ‖Uk‖2F = k. Unfortunately, as stated, this is an ill-posed problem. Indeed, consider the degenerate case when A = In (i.e., the n × n identity matrix). In this case, Uk is not unique and the leverage scores are not well-defined. Moreover, for the obvious (\nn k\n)\nequivalent choices for Uk, the leverage scores defined according to any one of these choices do not provide a relative error approximation to the leverage scores defined according to any other choices. More generally, removing this trivial degeneracy does not help. Consider the matrix\nA =\n(\nIk 0 0 (1− γ)In−k\n)\n∈ Rn×n.\nIn this example, the leverage scores for Ak are well defined. However, as γ → 0, it is not possible to distinguish between the top-k singular space and its complement. This example suggests that it should be possible to obtain some result conditioning on the spectral gap at the kth singular value. For example, one might assume that σ2k−σ2k+1 ≥ γ > 0, in which case the parameter γ would play an important role in the ability to solve this problem. Any algorithm which cannot distinguish the singular values with an error less than γ will confuse the k-th and (k+1)-th singular vectors and consequently will fail to get an accurate approximation to the leverage scores for Ak.\nIn the following, we take a more natural approach which leads to a clean problem formulation. To do so, recall that the leverage scores and the related normalized leverage scores of Eqn. (23) are used to approximate the matrix in some way, e.g., we might be seeking a low-rank approximation to the matrix with respect to the spectral [21] or the Frobenius [12] norm, or we might be seeking useful features or data points in downstream data analysis applications [41, 33], or we might be seeking to develop high-quality numerical implementations of low-rank matrix approximation algorithms [27], etc. In all these cases, we only care that the estimated leverage scores are a good approximation to the leverage scores of some “good” low-rank approximation to A. The following definition captures the notion of a set of rank-k matrices that are good approximations to A.\nDefinition 2. Given A ∈ Rn×d and a rank parameter k ≪ min {n, d}, let Ak be the best rank-k approximation to A. Define the set Sǫ of rank-k matrices that are good approximations to A as follows (for ξ = 2, F ):\nSǫ = { X ∈ Rn×d : rank(X) = k and ‖A−X‖ξ ≤ (1 + ǫ)‖A−Ak‖ξ } . (24)\nWe are now ready to define our approximations to the normalized leverage scores of any matrix A ∈ Rn×d given a rank parameter k ≪ min {n, d}. Instead of seeking to approximate the pi of Eqn. (23) (a problem that is ill-posed as discussed above), we will be satisfied if we can approximate the normalized leverage scores of some matrix X ∈ Sǫ. This is an interesting relaxation of the task at hand: all matrices X that are sufficiently close to Ak are essentially equivalent, since they can be used instead of Ak in applications.\nDefinition 3. Given A ∈ Rn×d and a rank parameter k ≪ min {n, d}, let Sǫ be the set of matrices of Definition 2. We call the numbers p̂i (for all i ∈ [n]) β-approximations to the normalized leverage scores of Ak (the best rank-k approximation to A) if, for some matrix X ∈ Sǫ,\np̂i ≥ β ∥ ∥(UX)(i) ∥ ∥ 2 2\nk and\nn ∑\ni=1\np̂i = 1.\nHere UX ∈ Rn×k is the matrix of the left singular vectors of X.\nThus, we will seek algorithms whose output is a set of numbers, with the requirement that those numbers are good approximations to the normalized leverage scores of some matrix X ∈ Sǫ (instead of Ak). This removes the ill-posedness of the original problem. Next, we will give two examples of algorithms that compute such β-approximations to the normalized leverage scores of a general matrix A with a rank parameter k for two popular norms, the spectral norm and the Frobenius norm.9"
    }, {
      "heading" : "5.1 Leverage Scores for Spectral Norm Approximators",
      "text" : "Algorithm 4 approximates the statistical leverage scores of a general matrix A with rank parameter k in the spectral norm case. It takes as inputs a matrix A ∈Rn×d with rank(A) = ρ and a rank parameter k ≪ ρ, and outputs a set of numbers p̂i for all i ∈ [n], namely our approximations to the normalized leverage scores of A with rank parameter k.\nThe next lemma argues that there exists a matrix X ∈ Rn×d of rank k that is sufficiently close to A (in particular, it is a member of Sǫ with constant probability) and, additionally, can be written as X = BY, where Y ∈ R2k×d is a matrix of rank k. A version of this lemma was\n9Note that we will not compute Sǫ, but our algorithms will compute a matrix in that set. Moreover, that matrix can be used for high-quality low-rank matrix approximation. See the comments in Section 1.4 for more details.\nInput: A ∈ Rn×d with rank(A) = ρ and a rank parameter k ≪ ρ Output: p̂i, i ∈ [n]\n1. Construct Π ∈ Rd×2k with entries drawn in i.i.d. trials from the normal distribution N (0, 1).\n2. Compute B = ( AAT )q AΠ ∈ Rn×2k, with q as in Eqn. (26).\n3. Approximately compute the statistical leverage scores of the “tall” matrix B by calling Algorithm 1 with inputs B and ǫ; let ℓ̂i (for all i ∈ [n]) be the outputs of Algorithm 1.\n4. Return\np̂i = ℓ̂i\n∑n j=1 ℓ̂j\n(25)\nfor all i ∈ [n].\nAlgorithm 4: Approximating the statistical leverage scores of a general matrix A (spectral norm case).\nessentially proven in [27], but see also [43] for computational details; we will use the version of the lemma that appeared in [10]. (See also the conference version [11], but in the remainder we refer to the technical report version [10] for consistency of numbering.) Note that for our purposes in this section, the computation of Y is not relevant and we defer the reader to [27, 10] for details.\nLemma 10 (Spectral Sketch). Given A ∈ Rn×d of rank ρ, a rank parameter k such that 2 ≤ k < ρ, and an error parameter ǫ such that 0 < ǫ < 1, let Π ∈ Rd×2k be a standard Gaussian matrix (with entries selected in i.i.d. trials from N (0, 1)). If B = ( AAT )q AΠ, where\nq ≥\n\n   \nln ( 1 + √\nk k−1 + e\n√\n2 k\n√ min {n, d} − k )\n2 ln (1 + ǫ/10) − 1/2\n\n    , (26)\nthen there exists a matrix X ∈ Rn×d of rank k satisfying X = BY (with Y ∈ R2k×d) such that\nE [‖A−X‖2] ≤ ( 1 + ǫ\n10\n)\n‖A−Ak‖2.\nThe matrix B can be computed in O (ndkq) time.\nThis version of the above lemma is proven in [10].10 Now, since X has rank k, it follows that ‖A−X‖2 ≥ ‖A−Ak‖2 and thus we can consider the non-negative random variable ‖A−X‖2 − ‖A−Ak‖2 and apply Markov’s inequality to get that\n‖A−X‖2 − ‖A−Ak‖2 ≤ ǫ‖A−Ak‖2 holds with probability at least 0.9. Thus, X ∈ Sǫ with probability at least 0.9.\n10More specifically, the proof may be found in Lemma 32 and in particular in Eqn. (14) in Section A.2; note that for our purposes here we replaced ǫ/ √ 2 by ǫ/10 after adjusting q accordingly.\nThe next step of the proposed algorithm is to approximately compute the leverage scores of B ∈ Rn×2k via Algorithm 1. Under the assumptions of Theorem 1, this step runs in O ( nkǫ−2 lnn ) time. Let UX ∈ Rn×k be the matrix containing the left singular vectors of the matrix X of Lemma 10. Then, since X = BY by Lemma 10, it follows that\nUB = [UX UR]\nis a basis for the subspace spanned by the columns of B. Here UR ∈ Rn×k is an orthogonal matrix whose columns are perpendicular to the columns of UX . Now consider the approximate leverage scores ℓ̂i computed by Algorithm 1 and note that (by Theorem 1),\n∣ ∣ ∣ ∣ ℓ̂i − ∥ ∥ ∥ (UB)(i) ∥ ∥ ∥ 2\n2\n∣ ∣ ∣ ∣ ≤ ǫ ∥ ∥ ∥ (UB)(i) ∥ ∥ ∥ 2\n2\nholds with probability at least 0.8 for all i ∈ [n]. It follows that n ∑\nj=1\nℓ̂j ≤ (1 + ǫ) n ∑\nj=1\n∥ ∥ ∥ (UB)(j) ∥ ∥ ∥ 2\n2 = (1 + ǫ)\nn ∑\nj=1\n‖UB‖2F = 2 (1 + ǫ) k.\nFinally,\np̂i = ℓ̂i\n∑n j=1 ℓ̂j\n≥ (1− ǫ)\n∥ ∥ ∥ (UB)(i) ∥ ∥ ∥ 2\n2 ∑n\nj=1 ℓ̂j\n≥ (1− ǫ)\n∥ ∥ ∥ (UX)(i) ∥ ∥ ∥ 2\n2 +\n∥ ∥ ∥ (UR)(i) ∥ ∥ ∥ 2\n2 ∑n\nj=1 ℓ̂j\n≥ 1− ǫ 2\n∥ ∥ ∥ (UX)(i) ∥ ∥ ∥ 2\n2 ∑n\nj=1 ℓ̂j\n≥ 1− ǫ 2 (1 + ǫ)\n∥ ∥ ∥ (UX)(i) ∥ ∥ ∥ 2\n2\nk .\nClearly, ∥ ∥\n∥ (UX)(i)\n∥ ∥ ∥ 2\n2 /k are the normalized leverage scores of the matrix X. Recall that X ∈ Sǫ\nwith probability at least 0.9 and use Definition 3 to conclude that the scores p̂i of Eqn. (25) are (\n1−ǫ 2(1+ǫ)\n)\n-approximations to the normalized leverage scores of A with rank parameter k. The\nfollowing Theorem summarizes the above discussion:\nTheorem 3. Given A ∈ Rn×d, a rank parameter k, and an accuracy parameter ǫ, Algorithm 4 computes a set of normalized leverage scores p̂i that are ( 1−ǫ 2(1+ǫ) ) -approximations to the normalized leverage scores of A with rank parameter k with probability at least 0.7. The proposed algorithm runs in\nO\n( ndk ln (min{n, d})\nln (1 + ǫ) + nkǫ−2 lnn\n)\ntime.\nInput: A ∈ Rn×d with rank(A) = ρ and a rank parameter k ≪ ρ Output: p̂i, i ∈ [n]\n1. Let r be as in Eqn. (28) and construct Π ∈ Rd×r whose entries are drawn in i.i.d. trials from the normal distribution N (0, 1).\n2. Compute B = AΠ ∈ Rn×r.\n3. Compute a matrix Q ∈ Rn×r whose columns form an orthonormal basis for the column space of B.\n4. Compute the matrix QTA ∈ Rr×d and its left singular vectors UQTA ∈ Rr×d.\n5. Let UQTA,k ∈ Rr×k denote the top k left singular vectors of the matrix QTA (the first k columns of UQTA) and compute, for all i ∈ [n],\nℓ̂i = ∥ ∥ ∥ ( QUQTA,k )\n(i)\n∥ ∥ ∥ 2\n2 . (27)\n6. Return p̂i = ℓ̂i/k for all i ∈ [n].\nAlgorithm 5: Approximating the statistical leverage scores of a general matrix A (Frobenius norm case)."
    }, {
      "heading" : "5.2 Leverage Scores for Frobenius Norm Approximators.",
      "text" : "Algorithm 5 approximates the statistical leverage scores of a general matrix A with rank parameter k in the Frobenius norm case. It takes as inputs a matrix A ∈Rn×d with rank(A) = ρ and a rank parameter k ≪ ρ, and outputs a set of numbers p̂i for all i ∈ [n], namely our approximations to the normalized leverage scores of A with rank parameter k. It is worth noting that\n∑n i=1 ℓ̂i =\n∥ ∥QUQTA,k ∥ ∥ 2\nF =\n∥ ∥UQTA,k ∥ ∥ 2\nF = k and thus the p̂i sum up to one. The next lemma argues that\nthere exists a matrix X ∈ Rn×d of rank k that is sufficiently close to A (in particular, it is a member of Sǫ with constant probability). Unlike the previous section (the spectral norm case), we will now be able to provide a closed-form formula for this matrix X and, more importantly, the normalized leverage scores of X will be exactly equal to the p̂i returned by our algorithm. Thus, in the parlance of Definition 3, we will get a 1-approximation to the normalized leverage scores of A with rank parameter k.\nLemma 11 (Frobenius Sketch). Given A ∈ Rn×d of rank ρ, a rank parameter k such that 2 ≤ k < ρ, and an error parameter ǫ such that 0 < ǫ < 1, let Π ∈ Rd×r be a standard Gaussian matrix (with entries selected in i.i.d. trials from N (0, 1)) with\nr ≥ k + ⌈ 10k\nǫ + 1\n⌉\n. (28)\nLet B = AΠ and let X be as in Eqn. (29). Then,\nE [ ‖A−X‖2F ] ≤ ( 1 + ǫ\n10\n)\n‖A−Ak‖2F .\nThe matrix B can be computed in O ( ndkǫ−1 ) time.\nLet X = Q ( QTA )\nk ∈ Rn×d, (29)\nwhere ( QTA ) k is the best rank-k approximation to the matrix QTA; from standard linear algebra, (\nQTA )\nk = UQTA,kU T QTA,k QTA. Then, the above lemma is proven in [10].11 Now, since X has\nrank k, it follows that ‖A−X‖2F ≥ ‖A−Ak‖2F and thus we can consider the non-negative random variable ‖A−X‖2F − ‖A−Ak‖2F and apply Markov’s inequality to get that\n‖A−X‖2F − ‖A−Ak‖2F ≤ ǫ‖A−Ak‖2F\nholds with probability at least 0.9. Rearranging terms and taking square roots of both sides implies that\n‖A−X‖F ≤ √ 1 + ǫ‖A−Ak‖F ≤ (1 + ǫ) ‖A−Ak‖F .\nThus, X ∈ Sǫ with probability at least 0.9. To conclude our proof, recall that Q is an orthonormal basis for the columns of B. From Eqn. (29),\nX = Q ( QTA )\nk = QUQTA,kU T QTA,kQ TA = QUQTA,kΣQTA,kV T QTA,k.\nIn the above, ΣQTA,k ∈ Rk×k is the diagonal matrix containing the top k singular values of QTA and V T\nQTA,k ∈ Rk×d is the matrix whose rows are the top k right singular vectors of QTA. Thus,\nthe left singular vectors of the matrix X are exactly equal to the columns of the orthogonal matrix QUQTA,k; it now follows that the ℓ̂i of Eqn. (27) are the leverage scores of the matrix X and, finally, that the p̂i returned by the proposed algorithm are the normalized leverage scores of the matrix X.\nWe briefly discuss the running time of the proposed algorithm. First, we can compute B in O(ndr) time. Then, the computation of Q takes O(nr2) time. The computation of QTA takes O(ndr) time and the computation of UQTA takes O(dr\n2) time. Thus, the total time is equal to O ( ndr + (n+ d)r2 ) . The following Theorem summarizes the above discussion.\nTheorem 4. Given A ∈ Rn×d, a rank parameter k, and an accuracy parameter ǫ, Algorithm 5 computes a set of normalized leverage scores p̂i that are 1-approximations to the normalized leverage scores of A with rank parameter k with probability at least 0.7. The proposed algorithm runs in O ( ndkǫ−1 + (n+ d)k2ǫ−2 ) time."
    }, {
      "heading" : "6 Discussion",
      "text" : "We will conclude with a discussion of our main results in a broader context: understanding the relationship between our main algorithm and a related estimator for the statistical leverage scores; applying our main algorithm to solve under-constrained least squares problems; and implementing variants of the basic algorithm in streaming environments."
    }, {
      "heading" : "6.1 A related estimator for the leverage scores",
      "text" : "Magdon-Ismail in [31] presented the following algorithm to estimate the statistical leverage scores: given as input an n× d matrix A, with n ≫ d, the algorithm proceeds as follows.\n• Compute ΠA, where the O (\nn lnd ln2 n\n)\n× n matrix Π is a SRHT or another FJLT. 11More specifically, the proof may be found in Lemma 33 in Section A.3; note that for our purposes here we set\np = ⌈ 10k ǫ + 1 ⌉ .\n• Compute X = (ΠA)†Π.\n• For t = 1, . . . , n, compute the estimate w̃t = AT(t)X(t) and set wt = max { d ln2 n 4n , w̃t } .\n• Return the quantities p̃i = wi/ ∑n i′=1wi′ , for i ∈ [n].\n[31] argued that the output p̃i achieves an O(ln 2 n) approximation to all of the (normalized) statistical leverage scores of A in roughly O(nd2/ ln n) time. (To our knowledge, prior to our work here, this is the only known estimator that obtains any nontrivial provable approximation to the leverage scores of a matrix in o(nd2) time.) To see the relationship between this estimator and our main result, recall that\nℓi = e T i UU T ei = e T i AA †ei = x T i yi,\nwhere the vector xTi = e T i A is cheap to compute and the vector yi = A †ei is expensive to compute. The above algorithm effectively approximates yi = A\n†ei via a random projection as ỹi = (ΠA)\n†Πei, where Π is a SRHT or another FJLT. Since the estimates xTi ỹi are not necessarily positive, a truncation at the negative tail, followed by a renormalization step, must be performed in order to arrive at the final estimator returned by the algorithm. This truncationrenormalization step has the effect of inflating the estimates of the small leverage scores by an O(ln2 n) factor. By way of comparison, Algorithm 1 essentially computes a sketch of AA† of the form A(ΠA)†ΠT that maintains positivity for each of the row norm estimates.\nAlthough both Algorithm 1 and the algorithm of this subsection estimate AA† by a matrix of the form A(ΠA)†ΠT , there are notable differences. The algorithm of this subsection does not actually compute or approximate AAT directly; instead, it separates the matrix into two parts and computes the dot product between eTi A and (ΠA)\n†Πei. Positivity is sacrificed and this leads to some complications in the estimator; however, the truncation step is interesting, since, despite the fact that the estimates are “biased” (in a manner somewhat akin to what is obtained with “thresholding” or “regularization” procedures), we still obtain provable approximation guarantees. The algorithm of this subsection is simpler (since it uses an application of only one random projection), albeit at the cost of weaker theoretical guarantees and a worse running time than our main algorithm. A direction of considerable practical interest is to evaluate empirically the performance of these two estimators, either for estimating all the leverage scores or (more interestingly) for estimating the largest leverage scores for data matrices for which the leverage scores are quite nonuniform."
    }, {
      "heading" : "6.2 An application to under-constrained least-squares problems",
      "text" : "Consider the following under-constrained least-squares problem:\nmin x∈Rd\n‖Ax− b‖2 , (30)\nwhere A ∈ Rn×d has much fewer rows than columns, i.e., n ≪ d. It is well-known that we can solve this problem exactly in O(n2d) time and that the minimal ℓ2-norm solution is given by xopt = A\n†b. For simplicity, let’s assume that the input matrix A has full rank (i.e., rank(A) = n) and thus ‖Axopt − b‖2 = 0.\nIn this section, we will argue that Algorithm 6 computes a simple, accurate estimator x̃opt for xopt. In words, Algorithm 6 samples a small number of columns from A (note that the columns of A correspond to variables in our under-constrained problem) and uses the sampled columns to compute x̃opt. However, in order to determine which columns will be included in the sample,\nthe algorithm will make use of the statistical leverage scores of the matrix AT ; more specifically, columns (and thus variables) will be chosen with probability proportional to the corresponding statistical leverage score. We will state Algorithm 6 assuming that these probabilities are parts of the input; the following theorem is our main quality-of-approximation result for Algorithm 6.\nTheorem 5. Let A ∈ Rn×d be a full-rank matrix with n ≪ d; let ǫ ∈ (0, 0.5] be an accuracy parameter; let δ ∈ (0, 1) be a failure probability; and let xopt = A†b be the minimal ℓ2-norm solution to the least-squares problem of Eqn. (30). Let pi ≥ 0, i ∈ [d], be a set of probabilities satisfying\n∑d i=1 pi = 1 and\npi ≥ β ∥ ∥V(i) ∥ ∥ 2 2\nn (31)\nfor some constant β ∈ (0, 1]. (Here V ∈ Rd×n is the matrix of the right singular vectors of A.) If x̃opt is computed via Algorithm 6 then, with probability at least 1− δ,\n‖xopt − x̃opt‖2 ≤ 2ǫ ‖xopt‖2 .\nAlgorithm 6 runs in O ( n3ǫ−2β−1 ln (n/ǫβδ) + nd ) time.\nProof: Let the singular value decomposition of the full-rank matrix A be A = UΣV T , with U ∈ Rn×n, Σ ∈ Rn×n, and V ∈ Rd×n; note that all the diagonal entries of Σ are strictly positive since A has full rank. We can now apply Theorem 4 of Section 6.1 of [22] to get12 that\n∥ ∥In − V TSSTV ∥ ∥\n2 =\n∥ ∥V TV − V TSSTV ∥ ∥ 2 ≤ ǫ (32)\nfor our choice of r with probability at least 1 − δ. Note that V TS ∈ Rn×r (with r ≥ n) and let σi ( V TS )\ndenote the singular values of V TS for all i ∈ [n]; the above inequality implies that for all i ∈ [n]\n∣ ∣1− σ2i ( V TS ) ∣ ∣ ≤ ∥ ∥In − V TSSTV ∥ ∥ 2 ≤ ǫ ≤ 0.5.\nThus, all the singular values of V TS are strictly positive and hence V TS has full rank equal to n. Also, using ǫ ≤ 0.5,\n∣ ∣1− σ−2i ( V TS )∣ ∣ ≤ ǫ 1− ǫ ≤ 2ǫ. (33)\nWe are now ready to prove our theorem:\n‖xopt − x̃opt‖2 = ∥ ∥ ∥ AT (AS)†T (AS)† b−A†b ∥ ∥ ∥\n2\n= ∥ ∥ ∥ V ΣUT ( UΣV TS )†T ( UΣV TS )† b− V Σ−1UT b ∥ ∥ ∥\n2\n= ∥ ∥ ∥ ΣUTUΣ−1 ( V TS )†T ( V TS )† Σ−1UT b− Σ−1UT b ∥ ∥ ∥\n2\n= ∥ ∥\n∥\n( V TS )†T ( V TS )† Σ−1UT b− Σ−1UT b ∥ ∥\n∥ 2 .\nIn the above derivations we substituted the SVD of A, dropped terms that do not change unitarily invariant norms, and used the fact that V TS and Σ have full rank in order to simplify the pseudoinverse. Now let ( V TS )†T ( V TS )†\n= In + E and note that Eqn. (33) and the fact that V TS has full rank imply\n‖E‖2 = ∥ ∥ ∥ In − ( V TS )†T ( V TS )†∥ ∥ ∥\n2 = max i∈[n]\n∣ ∣1− σ−2i ( V TS ) ∣ ∣ ≤ 2ǫ.\n12We apply Theorem 4 of Section 6.1 of [22] with A = V T and note that ∥ ∥V T ∥ ∥ 2\nF = n ≥ 1,\n∥ ∥V T ∥ ∥\n2 = 1, and\n( V T )(i)\n= V(i).\nThus, we conclude our proof by observing that\n‖xopt − x̃opt‖2 = ∥ ∥(In + E)Σ −1UT b− Σ−1UT b ∥ ∥ 2\n= ∥ ∥EΣ−1UT b ∥ ∥\n2\n≤ ‖E‖2 ∥ ∥Σ−1UT b ∥ ∥\n2\n≤ 2ǫ ‖xopt‖2 .\nIn the above we used the fact that ‖xopt‖2 = ∥ ∥A†b ∥ ∥ 2 = ∥ ∥V Σ−1UT b ∥ ∥ 2 = ∥ ∥Σ−1UT b ∥ ∥ 2 . The running time of the algorithm follows by observing that AS is an n×r matrix and thus computing its pseudoinverse takes O(n2r) time; computing xopt takes an additional O(nr + dn) time.\n⋄\nInput: A ∈ Rn×d, b ∈ Rn, error parameter ǫ ∈ (0, .5], failure probability δ, and a set of probabilities pi (for all i ∈ [d]) summing up to one and satisfying Eqn. (31). Output: x̃opt ∈ Rd.\n1. Let r = 96n βǫ2\nln (\n96n βǫ2 √ δ\n)\n.\n2. Let S ∈ Rd×r be an all-zeros matrix.\n3. For t = 1, . . . , r do\n• Pick it ∈ [d] such that Pr (it = i) = pi. • Sitt = 1/ √ rpit.\n4. Return x̃opt = A T (AS)†T (AS)† b.\nAlgorithm 6: Approximately solving under-constrained least squares problems.\nWe conclude the section with a few remarks. First, assuming that ǫ, β, and δ are constants and n lnn = o(d), it immediately follows that Algorithm 6 runs in o(n2d) time. It should be clear that we can use Theorem 1 and the related Algorithm 1 to approximate the statistical leverage scores, thus bypassing the need to exactly compute them. Second, instead of approximating the statistical leverage scores needed in Algorithm 6, we could use the randomized Hadamard transform (essentially post-multiply A by a randomized Hadamard transform to make all statistical leverage scores uniform). The resulting algorithm could be theoretically analyzed following the lines of [22]. It would be interesting to evaluate experimentally the performance of the two approaches in real data."
    }, {
      "heading" : "6.3 Extension to streaming environments",
      "text" : "In this section, we consider the estimation of the leverage scores and of related statistics when the input data set is so large that an appropriate way to view the data is as a data stream [36]. In this context, one is interested in computing statistics of the data stream while making one pass (or occasionally a few additional passes) over the data from external storage and using only a small amount of additional space. For an n × d matrix A, with n ≫ d, small additional space means\nthat the space complexity only depends logarithmically on the high dimension n and polynomially on the low dimension d. When we discuss bits of space, we assume that the entries of A can be discretized to O(log n) bit integers, though all of our results can be generalized to arbitrary word sizes. The general strategy behind our algorithms is as follows.\n• As the data streams by, compute TA, for an appropriate problem-dependent linear sketching matrix T , and also compute ΠA, for a random projection matrix Π.13\n• After the first pass over the data, compute the matrix R−1, as described in Algorithm 1, corresponding to ΠA (or compute the pseudoinverse of ΠA or the R matrix from any other QR decomposition of A).\n• Compute TAR−1Π2, for a random projection matrix Π2, such as the one used by Algorithm 1.\nWith the procedure outlined above, the matrix T is effectively applied to the rows of AR−1Π2, i.e., to the sketch of A that has rows with Euclidean norms approximately equal to the row norms of U , and pairwise inner products approximately equal to those in U . Thus statistics related to U can be extracted.\nLarge Leverage Scores. Given any n × d matrix A in a streaming setting, it is known how to find the indices of all rows A(i) of A for which ‖A(i)‖22 ≥ τ‖A‖2F , for a parameter τ , and in addition it is known how to compute a (1+ ǫ)-approximation to ‖A(i)‖22 for these large rows. The basic idea is to use the notion of ℓ2-sampling on matrix A, namely, to sample random entries Aij with probability A 2 ij/‖A‖2F . A single entry can be sampled from this distribution in a single pass using O(ǫ−2 log3(nd)) bits of space [35, 5]. More precisely, these references demonstrate that there is a distribution over O(dǫ−2 log3(nd)) × n matrices T for which for any fixed matrix A ∈ Rn×d, there is a procedure which given TA, outputs a sample (i, j) ∈ [n]×[d] with probability (1 ± ǫ) A 2 i,j\n‖A‖2 F ± n−O(1). Technically, these references concern sampling from vectors rather than matrices, so T (A) is a linear operator which treats A as a length-nd vector and applies the algorithm of [35, 5]. However, by simply increasing the number of rows in T by a factor of the small dimension d, we can assume T is left matrix multiplication. By considering the marginal along [n], the probability that i = a, for any a ∈ [n], is\n(1± ǫ) ‖U(a)‖22 ‖U‖2F ± (nd)−O(1).\nBy the coupon collector problem, running O(τ−1 log τ−1) independent copies is enough to find a set containing all rows A(i) for which ‖A(i)‖22 ≥ τ‖A‖2F , and no rows A(i) for which ‖A(i)‖22 < τ 2‖A‖2F with probability at least 0.99.\nWhen applied to our setting, we can apply a random projection matrix Π and a linear sketching matrix T which has O(dτ−1ǫ−2 log3(n) log τ−1) rows in the following manner. First, TA and ΠA are computed in the first pass over the data; then, at the end of the first pass, we compute R−1; and finally, we compute TAR−1Π2, for a random projection matrix Π2. This procedure effectively applies the matrix T to the rows of AR−1Π2, which have norms equal to the row norms of U , up to a factor of 1 + ǫ. The multiplication at the end by Π2 serves only to speed up the time for\n13In the offline setting, one would use an SRHT or another FJLT, while in the streaming setting one could use either of the following. If the stream is such that one sees each entire column of A at once, then one could do an FJLT on the column. Alternatively, if one see updates to the individual entries of A in an arbitrary order, then one could apply any sketching matrix, such as those of [1] or of [17].\nprocessing TAR−1. Thus, by the results of [35, 5], we can find all the leverage scores ‖U(i)‖22 that are of magnitude at least τ‖U‖2F in small space and a single pass over the data. By increasing the space by a factor of O(ǫ−2 log n), we can also use the ℓ2-samples to estimate the norms ‖U(i)‖22 for the row indices i that we find.\nEntropy. Given a distribution ρ, a statistic of ρ of interest is the entropy of this distribution, where the entropy is defined as H(ρ) = ∑\ni ρ(i) log2(1/ρ(i)). This statistic can be approximated in a streaming setting. Indeed, it is known that estimating H(ρ) up to an additive ǫ can be reduced to (1 + ǫ̃)-approximation of the ℓp-norm of the vector (ρ(1), . . . , ρ(n)), for O(log 1/ǫ) different p ∈ (0, 1) [28]. Here ǫ̃ = ǫ/(log3 1/ǫ · log n). When applied to our setting, the distribution of interest is ρ(i) = 1\nd ‖U(i)‖22. To compute the entropy of this distribution, there exist sketching\nmatrices T for providing (1 + ǫ)-approximations to the quantity Fp(F2) of an n × d matrix A, where Fp(F2) is defined as ∑n i=1 ‖A(i)‖ 2p 2 , using O(ǫ\n−4 log2 n log 1/ǫ) bits of space (see Theorem 1 of [23]). Thus, to compute the entropy of the leverage score distribution, we can do the following. First, maintain TA and ΠA in the first pass over the data, where T is a sketching matrix for Fp(F2), p ∈ (0, 1). At the end of the first pass, compute R−1; and finally, compute TAR−1Π2, which effectively applies the Fp(F2)-estimation matrix T to the rows of the matrix AR\n−1Π2. Therefore, by the results of [28, 23], we can compute an estimate φ which is within an additive ǫ of H(ρ) using O(dǫ−4 log6 n log14 1/ǫ) bits of space and a single pass. We note that it is also possible to estimate H(ρ) up to a multiplicative 1 + ǫ factor using small, but more, space; see, e.g., [28].\nSampling Row Identities. Another natural problem is that of obtaining samples of rows of A proportional to their leverage score importance sampling probabilities. To do so, we use ℓ2sampling [35, 5] as used above for finding the large leverage scores. First, compute TA and ΠA in the first pass over the data stream; then, compute R−1; and finally, compute TAR−1. Thus, by applying the procedures of [5] a total of s times independently, we obtain s samples i1, . . . , is, with replacement, of rows of A proportional to ‖U(i1)‖22, . . . , ‖U(is)‖22, i.e., to their leverage score. The algorithm requires O(sdǫ−2 log4 n) bits of space and runs in a single pass. To obtain more than just the row identities i1, . . . , is, e.g., to obtain the actual samples, one can read off these rows from A in a second pass over the matrix."
    } ],
    "references" : [ {
      "title" : "Database-friendly random projections: Johnson-lindenstrauss with binary coins",
      "author" : [ "D. Achlioptas" ],
      "venue" : "Journal of Computer and System Sciences, 66(4):671–687",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Approximate nearest neighbors and the fast Johnson-Lindenstrauss transform",
      "author" : [ "N. Ailon", "B. Chazelle" ],
      "venue" : "Proceedings of the 38th Annual ACM Symposium on Theory of Computing, pages 557–563",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "The fast Johnson-Lindenstrauss transform and approximate nearest neighbors",
      "author" : [ "N. Ailon", "B. Chazelle" ],
      "venue" : "SIAM Journal on Computing, 39(1):302–322",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Fast dimension reduction using Rademacher series on dual BCH codes",
      "author" : [ "N. Ailon", "E. Liberty" ],
      "venue" : "Proceedings of the 19th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 1–9",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Streaming algorithms from precision sampling",
      "author" : [ "A. Andoni", "R. Krauthgamer", "K. Onak" ],
      "venue" : "Technical report. Preprint: arXiv:1011.1263 ",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Blendenpik: Supercharging LAPACK’s leastsquares solver",
      "author" : [ "H. Avron", "P. Maymounkov", "S. Toledo" ],
      "venue" : "SIAM Journal on Scientific Computing, 32:1217–1236",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Low cost high performance uncertainty quantification",
      "author" : [ "C. Bekas", "A. Curioni", "I. Fedulova" ],
      "venue" : "Proceedings of the 2nd Workshop on High Performance Computational Finance, page Article No.: 8",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "An estimator for the diagonal of a matrix",
      "author" : [ "C. Bekas", "E. Kokiopoulou", "Y. Saad" ],
      "venue" : "Applied Numerical Mathematics, 57:1214–1229",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Power and centrality: A family of measures",
      "author" : [ "P. Bonacich" ],
      "venue" : "The American Journal of Sociology, 92(5):1170–1182",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "Near-optimal column-based matrix reconstruction",
      "author" : [ "C. Boutsidis", "P. Drineas", "M. Magdon-Ismail" ],
      "venue" : "Technical report. Preprint: arXiv:1103.0995 ",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Near-optimal column-based matrix reconstruction",
      "author" : [ "C. Boutsidis", "P. Drineas", "M. Magdon-Ismail" ],
      "venue" : "Proceedings of the 52nd Annual IEEE Symposium on Foundations of Computer Science, pages 305–314",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "An improved approximation algorithm for the column subset selection problem",
      "author" : [ "C. Boutsidis", "M.W. Mahoney", "P. Drineas" ],
      "venue" : "Proceedings of the 20th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 968–977",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Exact matrix completion via convex optimization",
      "author" : [ "E.J. Candes", "B. Recht" ],
      "venue" : "Technical report. Preprint: arXiv:0805.4471 ",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Influential observations",
      "author" : [ "S. Chatterjee", "A.S. Hadi" ],
      "venue" : "high leverage points, and outliers in linear regression. Statistical Science, 1(3):379–393",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "Sensitivity Analysis in Linear Regression",
      "author" : [ "S. Chatterjee", "A.S. Hadi" ],
      "venue" : "John Wiley & Sons, New York",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Regression Analysis by Example",
      "author" : [ "S. Chatterjee", "A.S. Hadi", "B. Price" ],
      "venue" : "John Wiley & Sons, New York",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "A sparse Johnson-Lindenstrauss transform",
      "author" : [ "A. Dasgupta", "R. Kumar", "T. Sarlós" ],
      "venue" : "Proceedings of the 42nd Annual ACM Symposium on Theory of Computing, pages 341–350",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Fast Monte Carlo algorithms for matrices I: Approximating matrix multiplication",
      "author" : [ "P. Drineas", "R. Kannan", "M.W. Mahoney" ],
      "venue" : "SIAM Journal on Computing, 36:132–157",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Inferring geographic coordinates of origin for Europeans using small panels of ancestry informative markers",
      "author" : [ "P. Drineas", "J. Lewis", "P. Paschou" ],
      "venue" : "PLoS ONE, 5(8):e11892",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Sampling algorithms for l2 regression and applications",
      "author" : [ "P. Drineas", "M.W. Mahoney", "S. Muthukrishnan" ],
      "venue" : "Proceedings of the 17th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 1127–1136",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Relative-error CUR matrix decompositions",
      "author" : [ "P. Drineas", "M.W. Mahoney", "S. Muthukrishnan" ],
      "venue" : "SIAM Journal on Matrix Analysis and Applications, 30:844–881",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Faster least squares approximation",
      "author" : [ "P. Drineas", "M.W. Mahoney", "S. Muthukrishnan", "T. Sarlós" ],
      "venue" : "Numerische Mathematik, 117(2):219–249",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Estimating hybrid frequency moments of data streams",
      "author" : [ "S. Ganguly", "M. Bansal", "S. Dube" ],
      "venue" : "Proceedings of the 2nd Annual International Workshop on Frontiers in Algorithmics, pages 55–66",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "In preparation",
      "author" : [ "A. Gittens", "M.W. Mahoney" ],
      "venue" : "",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Matrix Computations",
      "author" : [ "G.H. Golub", "C.F. Van Loan" ],
      "venue" : "Johns Hopkins University Press, Baltimore",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions",
      "author" : [ "N. Halko", "P.-G. Martinsson", "J.A. Tropp" ],
      "venue" : "SIAM Review, 53(2):217–288",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Sketching and streaming entropy via approximation theory",
      "author" : [ "N.J.A. Harvey", "J. Nelson", "K. Onak" ],
      "venue" : "Proceedings of the 49th Annual IEEE Symposium on Foundations of Computer Science, pages 489–498",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "The hat matrix in regression and ANOVA",
      "author" : [ "D.C. Hoaglin", "R.E. Welsch" ],
      "venue" : "The American Statistician, 32(1):17–22",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 1978
    }, {
      "title" : "Effective resistance of Gromovhyperbolic graphs: Application to asymptotic sensor network problems",
      "author" : [ "E.A. Jonckheere", "M. Lou", "J. Hespanha", "P. Barooah" ],
      "venue" : "Proceedings of the 46th IEEE Conference on Decision and Control, pages 1453–1458",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Row sampling for matrix algorithms via a non-commutative Bernstein bound",
      "author" : [ "M. Magdon-Ismail" ],
      "venue" : "Technical report. Preprint: arXiv:1008.0587 ",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Randomized algorithms for matrices and data",
      "author" : [ "M.W. Mahoney" ],
      "venue" : "Foundations and Trends in Machine Learning. NOW Publishers, Boston",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "CUR matrix decompositions for improved data analysis",
      "author" : [ "M.W. Mahoney", "P. Drineas" ],
      "venue" : "Proc. Natl. Acad. Sci. USA, 106:697–702",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "LSRN: A parallel iterative solver for strongly over- or under-determined systems",
      "author" : [ "X. Meng", "M.A. Saunders", "M.W. Mahoney" ],
      "venue" : "Technical report. Preprint: arXiv:1109.5981 ",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "1-pass relative-error lp-sampling with applications",
      "author" : [ "M. Monemizadeh", "D.P. Woodruff" ],
      "venue" : "Proceedings of the 21st Annual ACM-SIAM Symposium on Discrete Algorithms, pages 1143–1160",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Data Streams: Algorithms and Applications",
      "author" : [ "S. Muthukrishnan" ],
      "venue" : "Foundations and Trends in Theoretical Computer Science. Now Publishers Inc, Boston",
      "citeRegEx" : "36",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "editor",
      "author" : [ "M.Z. Nashed" ],
      "venue" : "Generalized Inverses and Applications. Academic Press, New York",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 1976
    }, {
      "title" : "A measure of betweenness centrality based on random walks",
      "author" : [ "M.E.J. Newman" ],
      "venue" : "Social Networks, 27:39–54",
      "citeRegEx" : "38",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Latent semantic indexing: a probabilistic analysis",
      "author" : [ "C.H. Papadimitriou", "P. Raghavan", "H. Tamaki", "S. Vempala" ],
      "venue" : "Journal of Computer and System Sciences, 61(2):217–235",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Ancestry informative markers for finescale individual assignment to worldwide populations",
      "author" : [ "P. Paschou", "J. Lewis", "A. Javed", "P. Drineas" ],
      "venue" : "Journal of Medical Genetics, page doi:10.1136/jmg.2010.078212",
      "citeRegEx" : "40",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "PCA-correlated SNPs for structure identification in worldwide human populations",
      "author" : [ "P. Paschou", "E. Ziv", "E.G. Burchard", "S. Choudhry", "W. Rodriguez-Cintron", "M.W. Mahoney", "P. Drineas" ],
      "venue" : "PLoS Genetics, 3:1672–1686",
      "citeRegEx" : "41",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Mining knowledge-sharing sites for viral marketing",
      "author" : [ "M. Richardson", "P. Domingos" ],
      "venue" : "Proceedings of the 8th Annual ACM SIGKDD Conference, pages 61–70",
      "citeRegEx" : "42",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "A randomized algorithm for principal component analysis",
      "author" : [ "V. Rokhlin", "A. Szlam", "M. Tygert" ],
      "venue" : "SIAM Journal on Matrix Analysis and Applications, 31(3):1100–1124",
      "citeRegEx" : "43",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "A fast randomized algorithm for overdetermined linear leastsquares regression",
      "author" : [ "V. Rokhlin", "M. Tygert" ],
      "venue" : "Proc. Natl. Acad. Sci. USA, 105(36):13212–13217",
      "citeRegEx" : "44",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Improved approximation algorithms for large matrices via random projections",
      "author" : [ "T. Sarlós" ],
      "venue" : "Proceedings of the 47th Annual IEEE Symposium on Foundations of Computer Science, pages 143–152",
      "citeRegEx" : "45",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Matrix coherence and the Nyström method",
      "author" : [ "A. Talwalkar", "A. Rostamizadeh" ],
      "venue" : "Proceedings of the 26th Conference in Uncertainty in Artificial Intelligence",
      "citeRegEx" : "46",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Efficient computing of regression diagnostics",
      "author" : [ "P.F. Velleman", "R.E. Welsch" ],
      "venue" : "The American Statistician, 35(4):234–242",
      "citeRegEx" : "47",
      "shortCiteRegEx" : null,
      "year" : 1981
    } ],
    "referenceMentions" : [ {
      "referenceID" : 45,
      "context" : "1 Introduction The concept of statistical leverage measures the extent to which the singular vectors of a matrix are correlated with the standard basis and as such it has found usefulness recently in large-scale data analysis and in the analysis of randomized matrix algorithms [47, 33, 21].",
      "startOffset" : 278,
      "endOffset" : 290
    }, {
      "referenceID" : 31,
      "context" : "1 Introduction The concept of statistical leverage measures the extent to which the singular vectors of a matrix are correlated with the standard basis and as such it has found usefulness recently in large-scale data analysis and in the analysis of randomized matrix algorithms [47, 33, 21].",
      "startOffset" : 278,
      "endOffset" : 290
    }, {
      "referenceID" : 20,
      "context" : "1 Introduction The concept of statistical leverage measures the extent to which the singular vectors of a matrix are correlated with the standard basis and as such it has found usefulness recently in large-scale data analysis and in the analysis of randomized matrix algorithms [47, 33, 21].",
      "startOffset" : 278,
      "endOffset" : 290
    }, {
      "referenceID" : 12,
      "context" : "A related notion is that of matrix coherence, which has been of interest in recently popular problems such as matrix completion and Nyström-based low-rank matrix approximation [13, 46].",
      "startOffset" : 176,
      "endOffset" : 184
    }, {
      "referenceID" : 44,
      "context" : "A related notion is that of matrix coherence, which has been of interest in recently popular problems such as matrix completion and Nyström-based low-rank matrix approximation [13, 46].",
      "startOffset" : 176,
      "endOffset" : 184
    }, {
      "referenceID" : 27,
      "context" : "Statistical leverage scores have a long history in statistical data analysis, where they have been used for outlier detection in regression diagnostics [29, 14].",
      "startOffset" : 152,
      "endOffset" : 160
    }, {
      "referenceID" : 13,
      "context" : "Statistical leverage scores have a long history in statistical data analysis, where they have been used for outlier detection in regression diagnostics [29, 14].",
      "startOffset" : 152,
      "endOffset" : 160
    }, {
      "referenceID" : 20,
      "context" : "Statistical leverage scores have also proved crucial recently in the development of improved worst-case randomized matrix algorithms that are also amenable to high-quality numerical implementation and that are useful to domain scientists [21, 33, 12, 20, 45, 22]; see [32] for a detailed discussion.",
      "startOffset" : 238,
      "endOffset" : 262
    }, {
      "referenceID" : 31,
      "context" : "Statistical leverage scores have also proved crucial recently in the development of improved worst-case randomized matrix algorithms that are also amenable to high-quality numerical implementation and that are useful to domain scientists [21, 33, 12, 20, 45, 22]; see [32] for a detailed discussion.",
      "startOffset" : 238,
      "endOffset" : 262
    }, {
      "referenceID" : 11,
      "context" : "Statistical leverage scores have also proved crucial recently in the development of improved worst-case randomized matrix algorithms that are also amenable to high-quality numerical implementation and that are useful to domain scientists [21, 33, 12, 20, 45, 22]; see [32] for a detailed discussion.",
      "startOffset" : 238,
      "endOffset" : 262
    }, {
      "referenceID" : 19,
      "context" : "Statistical leverage scores have also proved crucial recently in the development of improved worst-case randomized matrix algorithms that are also amenable to high-quality numerical implementation and that are useful to domain scientists [21, 33, 12, 20, 45, 22]; see [32] for a detailed discussion.",
      "startOffset" : 238,
      "endOffset" : 262
    }, {
      "referenceID" : 43,
      "context" : "Statistical leverage scores have also proved crucial recently in the development of improved worst-case randomized matrix algorithms that are also amenable to high-quality numerical implementation and that are useful to domain scientists [21, 33, 12, 20, 45, 22]; see [32] for a detailed discussion.",
      "startOffset" : 238,
      "endOffset" : 262
    }, {
      "referenceID" : 21,
      "context" : "Statistical leverage scores have also proved crucial recently in the development of improved worst-case randomized matrix algorithms that are also amenable to high-quality numerical implementation and that are useful to domain scientists [21, 33, 12, 20, 45, 22]; see [32] for a detailed discussion.",
      "startOffset" : 238,
      "endOffset" : 262
    }, {
      "referenceID" : 30,
      "context" : "Statistical leverage scores have also proved crucial recently in the development of improved worst-case randomized matrix algorithms that are also amenable to high-quality numerical implementation and that are useful to domain scientists [21, 33, 12, 20, 45, 22]; see [32] for a detailed discussion.",
      "startOffset" : 268,
      "endOffset" : 272
    }, {
      "referenceID" : 24,
      "context" : ", the basis provided by the Singular Value Decomposition (SVD) or a basis provided by a QR decomposition [26], and then use that basis to compute diagonal elements of the projection matrix onto the span of that basis.",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 43,
      "context" : ", either rapidly approximated or rapidly uniformized at the preprocessing step) in developing fast randomized algorithms for matrix problems such as least-squares regression [45, 22] and low-rank matrix approximation [39, 45, 21, 33, 12].",
      "startOffset" : 174,
      "endOffset" : 182
    }, {
      "referenceID" : 21,
      "context" : ", either rapidly approximated or rapidly uniformized at the preprocessing step) in developing fast randomized algorithms for matrix problems such as least-squares regression [45, 22] and low-rank matrix approximation [39, 45, 21, 33, 12].",
      "startOffset" : 174,
      "endOffset" : 182
    }, {
      "referenceID" : 37,
      "context" : ", either rapidly approximated or rapidly uniformized at the preprocessing step) in developing fast randomized algorithms for matrix problems such as least-squares regression [45, 22] and low-rank matrix approximation [39, 45, 21, 33, 12].",
      "startOffset" : 217,
      "endOffset" : 237
    }, {
      "referenceID" : 43,
      "context" : ", either rapidly approximated or rapidly uniformized at the preprocessing step) in developing fast randomized algorithms for matrix problems such as least-squares regression [45, 22] and low-rank matrix approximation [39, 45, 21, 33, 12].",
      "startOffset" : 217,
      "endOffset" : 237
    }, {
      "referenceID" : 20,
      "context" : ", either rapidly approximated or rapidly uniformized at the preprocessing step) in developing fast randomized algorithms for matrix problems such as least-squares regression [45, 22] and low-rank matrix approximation [39, 45, 21, 33, 12].",
      "startOffset" : 217,
      "endOffset" : 237
    }, {
      "referenceID" : 31,
      "context" : ", either rapidly approximated or rapidly uniformized at the preprocessing step) in developing fast randomized algorithms for matrix problems such as least-squares regression [45, 22] and low-rank matrix approximation [39, 45, 21, 33, 12].",
      "startOffset" : 217,
      "endOffset" : 237
    }, {
      "referenceID" : 11,
      "context" : ", either rapidly approximated or rapidly uniformized at the preprocessing step) in developing fast randomized algorithms for matrix problems such as least-squares regression [45, 22] and low-rank matrix approximation [39, 45, 21, 33, 12].",
      "startOffset" : 217,
      "endOffset" : 237
    }, {
      "referenceID" : 30,
      "context" : "See [32] for a detailed discussion.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 20,
      "context" : "As an example, the CUR decomposition of [21, 33] essentially computes pi = li/k, for all i ∈ {1, .",
      "startOffset" : 40,
      "endOffset" : 48
    }, {
      "referenceID" : 31,
      "context" : "As an example, the CUR decomposition of [21, 33] essentially computes pi = li/k, for all i ∈ {1, .",
      "startOffset" : 40,
      "endOffset" : 48
    }, {
      "referenceID" : 1,
      "context" : "On the other hand, the computational bottleneck for random projection algorithms is the application of the random projection, which is sped up by using variants of the Fast Johnson-Lindenstrauss Transform [2, 3].",
      "startOffset" : 205,
      "endOffset" : 211
    }, {
      "referenceID" : 2,
      "context" : "On the other hand, the computational bottleneck for random projection algorithms is the application of the random projection, which is sped up by using variants of the Fast Johnson-Lindenstrauss Transform [2, 3].",
      "startOffset" : 205,
      "endOffset" : 211
    }, {
      "referenceID" : 19,
      "context" : "In particular, the random sampling algorithms of [20, 21, 33] for least-squares approximation and low-rank matrix approximation now run in time that is essentially the same as the best corresponding random projection algorithm for those problems [45].",
      "startOffset" : 49,
      "endOffset" : 61
    }, {
      "referenceID" : 20,
      "context" : "In particular, the random sampling algorithms of [20, 21, 33] for least-squares approximation and low-rank matrix approximation now run in time that is essentially the same as the best corresponding random projection algorithm for those problems [45].",
      "startOffset" : 49,
      "endOffset" : 61
    }, {
      "referenceID" : 31,
      "context" : "In particular, the random sampling algorithms of [20, 21, 33] for least-squares approximation and low-rank matrix approximation now run in time that is essentially the same as the best corresponding random projection algorithm for those problems [45].",
      "startOffset" : 49,
      "endOffset" : 61
    }, {
      "referenceID" : 43,
      "context" : "In particular, the random sampling algorithms of [20, 21, 33] for least-squares approximation and low-rank matrix approximation now run in time that is essentially the same as the best corresponding random projection algorithm for those problems [45].",
      "startOffset" : 246,
      "endOffset" : 250
    }, {
      "referenceID" : 42,
      "context" : "Recently, high-quality numerical implementations of variants of the basic randomized matrix algorithms have proven superior to traditional deterministic algorithms [44, 43, 6].",
      "startOffset" : 164,
      "endOffset" : 175
    }, {
      "referenceID" : 41,
      "context" : "Recently, high-quality numerical implementations of variants of the basic randomized matrix algorithms have proven superior to traditional deterministic algorithms [44, 43, 6].",
      "startOffset" : 164,
      "endOffset" : 175
    }, {
      "referenceID" : 5,
      "context" : "Recently, high-quality numerical implementations of variants of the basic randomized matrix algorithms have proven superior to traditional deterministic algorithms [44, 43, 6].",
      "startOffset" : 164,
      "endOffset" : 175
    }, {
      "referenceID" : 7,
      "context" : "More generally, density functional theory [8] and uncertainty quantification [7] are two scientific computing areas where computing the diagonal elements of functions (such as a projection or inverse) of very large input matrices is common.",
      "startOffset" : 42,
      "endOffset" : 45
    }, {
      "referenceID" : 6,
      "context" : "More generally, density functional theory [8] and uncertainty quantification [7] are two scientific computing areas where computing the diagonal elements of functions (such as a projection or inverse) of very large input matrices is common.",
      "startOffset" : 77,
      "endOffset" : 80
    }, {
      "referenceID" : 7,
      "context" : "For example, in the former case, “heuristic” methods based on using Chebychev polynomials have been used in numerical linear algebra to compute the diagonal elements of the projector [8].",
      "startOffset" : 183,
      "endOffset" : 186
    }, {
      "referenceID" : 27,
      "context" : "The statistical leverage scores and the scores relative to the best rank-k approximation to A are equal to the diagonal elements of the socalled “hat matrix” [29, 15].",
      "startOffset" : 158,
      "endOffset" : 166
    }, {
      "referenceID" : 14,
      "context" : "The statistical leverage scores and the scores relative to the best rank-k approximation to A are equal to the diagonal elements of the socalled “hat matrix” [29, 15].",
      "startOffset" : 158,
      "endOffset" : 166
    }, {
      "referenceID" : 27,
      "context" : "As such, they have a natural statistical interpretation in terms of the “leverage” or “influence” associated with each of the data points [29, 14, 15].",
      "startOffset" : 138,
      "endOffset" : 150
    }, {
      "referenceID" : 13,
      "context" : "As such, they have a natural statistical interpretation in terms of the “leverage” or “influence” associated with each of the data points [29, 14, 15].",
      "startOffset" : 138,
      "endOffset" : 150
    }, {
      "referenceID" : 14,
      "context" : "As such, they have a natural statistical interpretation in terms of the “leverage” or “influence” associated with each of the data points [29, 14, 15].",
      "startOffset" : 138,
      "endOffset" : 150
    }, {
      "referenceID" : 27,
      "context" : "In the context of regression problems, the i leverage score quantifies the leverage or influence of the i constraint/row of A on the solution of the overconstrained least squares optimization problem minx ‖Ax− b‖2 and the (i, j)-th cross leverage score quantifies how much influence or leverage the i data point has on the j least-squares fit (see [29, 14, 15] for details).",
      "startOffset" : 348,
      "endOffset" : 360
    }, {
      "referenceID" : 13,
      "context" : "In the context of regression problems, the i leverage score quantifies the leverage or influence of the i constraint/row of A on the solution of the overconstrained least squares optimization problem minx ‖Ax− b‖2 and the (i, j)-th cross leverage score quantifies how much influence or leverage the i data point has on the j least-squares fit (see [29, 14, 15] for details).",
      "startOffset" : 348,
      "endOffset" : 360
    }, {
      "referenceID" : 14,
      "context" : "In the context of regression problems, the i leverage score quantifies the leverage or influence of the i constraint/row of A on the solution of the overconstrained least squares optimization problem minx ‖Ax− b‖2 and the (i, j)-th cross leverage score quantifies how much influence or leverage the i data point has on the j least-squares fit (see [29, 14, 15] for details).",
      "startOffset" : 348,
      "endOffset" : 360
    }, {
      "referenceID" : 45,
      "context" : "Historically, these quantities have been widely-used for outlier identification in diagnostic regression analysis [47, 16].",
      "startOffset" : 114,
      "endOffset" : 122
    }, {
      "referenceID" : 15,
      "context" : "Historically, these quantities have been widely-used for outlier identification in diagnostic regression analysis [47, 16].",
      "startOffset" : 114,
      "endOffset" : 122
    }, {
      "referenceID" : 8,
      "context" : "[9, 42, 38, 30, 32].",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 40,
      "context" : "[9, 42, 38, 30, 32].",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 36,
      "context" : "[9, 42, 38, 30, 32].",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 28,
      "context" : "[9, 42, 38, 30, 32].",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 30,
      "context" : "[9, 42, 38, 30, 32].",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 39,
      "context" : "In genetics, dense matrices of size thousands by hundreds of thousands (a size scale at which even traditional deterministic QR algorithms fail to run) constructed from DNA Single Nucleotide Polymorphisms (SNP) data are increasingly common, and the statistical leverage scores can correlate strongly with other metrics of genetic interest [41, 33, 19, 40].",
      "startOffset" : 339,
      "endOffset" : 355
    }, {
      "referenceID" : 31,
      "context" : "In genetics, dense matrices of size thousands by hundreds of thousands (a size scale at which even traditional deterministic QR algorithms fail to run) constructed from DNA Single Nucleotide Polymorphisms (SNP) data are increasingly common, and the statistical leverage scores can correlate strongly with other metrics of genetic interest [41, 33, 19, 40].",
      "startOffset" : 339,
      "endOffset" : 355
    }, {
      "referenceID" : 18,
      "context" : "In genetics, dense matrices of size thousands by hundreds of thousands (a size scale at which even traditional deterministic QR algorithms fail to run) constructed from DNA Single Nucleotide Polymorphisms (SNP) data are increasingly common, and the statistical leverage scores can correlate strongly with other metrics of genetic interest [41, 33, 19, 40].",
      "startOffset" : 339,
      "endOffset" : 355
    }, {
      "referenceID" : 38,
      "context" : "In genetics, dense matrices of size thousands by hundreds of thousands (a size scale at which even traditional deterministic QR algorithms fail to run) constructed from DNA Single Nucleotide Polymorphisms (SNP) data are increasingly common, and the statistical leverage scores can correlate strongly with other metrics of genetic interest [41, 33, 19, 40].",
      "startOffset" : 339,
      "endOffset" : 355
    }, {
      "referenceID" : 39,
      "context" : "Our main result will permit the computation of these scores and related quantities for significantly larger SNP data sets than has been possible previously [41, 19, 40, 24].",
      "startOffset" : 156,
      "endOffset" : 172
    }, {
      "referenceID" : 18,
      "context" : "Our main result will permit the computation of these scores and related quantities for significantly larger SNP data sets than has been possible previously [41, 19, 40, 24].",
      "startOffset" : 156,
      "endOffset" : 172
    }, {
      "referenceID" : 38,
      "context" : "Our main result will permit the computation of these scores and related quantities for significantly larger SNP data sets than has been possible previously [41, 19, 40, 24].",
      "startOffset" : 156,
      "endOffset" : 172
    }, {
      "referenceID" : 23,
      "context" : ", [25].",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 5,
      "context" : "The state of the art here is the Blendenpik algorithm of [6] and the LSRN algorithm of [34].",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 32,
      "context" : "The state of the art here is the Blendenpik algorithm of [6] and the LSRN algorithm of [34].",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 5,
      "context" : "that random projection algorithms should be incorporated into future versions of Lapack” [6].",
      "startOffset" : 89,
      "endOffset" : 92
    }, {
      "referenceID" : 35,
      "context" : "The Moore-Penrose pseudoinverse of A is the d×n matrix defined by A† = V Σ−1UT [37].",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 24,
      "context" : "The SVD is important for a number of reasons [26].",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 0,
      "context" : "3/r with probability 1/6 each and zero otherwise (with probability 2/3) [1].",
      "startOffset" : 72,
      "endOffset" : 75
    }, {
      "referenceID" : 0,
      "context" : "1 of [1]).",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 1,
      "context" : "For our main results, we will also need a stronger requirement than the simple ǫ-JLT and so we will use a version of the Fast Johnson-Lindenstrauss Transform (FJLT), which was originally introduced in [2, 3].",
      "startOffset" : 201,
      "endOffset" : 207
    }, {
      "referenceID" : 2,
      "context" : "For our main results, we will also need a stronger requirement than the simple ǫ-JLT and so we will use a version of the Fast Johnson-Lindenstrauss Transform (FJLT), which was originally introduced in [2, 3].",
      "startOffset" : 201,
      "endOffset" : 207
    }, {
      "referenceID" : 19,
      "context" : "The next lemma follows from the definition of an ǫ-FJLT, and its proof can be found in [20, 22].",
      "startOffset" : 87,
      "endOffset" : 95
    }, {
      "referenceID" : 21,
      "context" : "The next lemma follows from the definition of an ǫ-FJLT, and its proof can be found in [20, 22].",
      "startOffset" : 87,
      "endOffset" : 95
    }, {
      "referenceID" : 21,
      "context" : "Note that the RHT has also been crucial in the development of o(nd) randomized algorithms for the general overconstrained LS problem [22] and its variants have been used to provide high-quality numerical implementations of such randomized algorithms [44, 6].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 42,
      "context" : "Note that the RHT has also been crucial in the development of o(nd) randomized algorithms for the general overconstrained LS problem [22] and its variants have been used to provide high-quality numerical implementations of such randomized algorithms [44, 6].",
      "startOffset" : 250,
      "endOffset" : 257
    }, {
      "referenceID" : 5,
      "context" : "Note that the RHT has also been crucial in the development of o(nd) randomized algorithms for the general overconstrained LS problem [22] and its variants have been used to provide high-quality numerical implementations of such randomized algorithms [44, 6].",
      "startOffset" : 250,
      "endOffset" : 257
    }, {
      "referenceID" : 5,
      "context" : "(Variants of this basic construction that relax this assumption and that are more appropriate for numerical implementation have been described and evaluated in [6].",
      "startOffset" : 160,
      "endOffset" : 163
    }, {
      "referenceID" : 3,
      "context" : "Third, if we only need to access r elements in the transformed vector, then those r elements can be computed in O(n log2 r) time [4].",
      "startOffset" : 129,
      "endOffset" : 132
    }, {
      "referenceID" : 17,
      "context" : "Using the sampling matrix formalism described previously [18, 20, 21, 22], we will represent the operation of randomly sampling r rows of an n× d matrix A using an r × n linear sampling operator S .",
      "startOffset" : 57,
      "endOffset" : 73
    }, {
      "referenceID" : 19,
      "context" : "Using the sampling matrix formalism described previously [18, 20, 21, 22], we will represent the operation of randomly sampling r rows of an n× d matrix A using an r × n linear sampling operator S .",
      "startOffset" : 57,
      "endOffset" : 73
    }, {
      "referenceID" : 20,
      "context" : "Using the sampling matrix formalism described previously [18, 20, 21, 22], we will represent the operation of randomly sampling r rows of an n× d matrix A using an r × n linear sampling operator S .",
      "startOffset" : 57,
      "endOffset" : 73
    }, {
      "referenceID" : 21,
      "context" : "Using the sampling matrix formalism described previously [18, 20, 21, 22], we will represent the operation of randomly sampling r rows of an n× d matrix A using an r × n linear sampling operator S .",
      "startOffset" : 57,
      "endOffset" : 73
    }, {
      "referenceID" : 21,
      "context" : "We summarize this discussion in the following lemma (which is essentially a combination of Lemmas 3 and 4 from [22], restated to fit our notation).",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 21,
      "context" : "This is where the SRHT enters, since it preserves important structures of A, in particular its rank, by first rotating A to a random basis and then uniformly sampling rows from the rotated matrix (see [22] for more details).",
      "startOffset" : 201,
      "endOffset" : 205
    }, {
      "referenceID" : 42,
      "context" : "This preprocessing is reminiscent of how [44, 6] preprocessed the input to provide numerical implementations of the fast relative-error algorithm [22] for approximate LS approximation.",
      "startOffset" : 41,
      "endOffset" : 48
    }, {
      "referenceID" : 5,
      "context" : "This preprocessing is reminiscent of how [44, 6] preprocessed the input to provide numerical implementations of the fast relative-error algorithm [22] for approximate LS approximation.",
      "startOffset" : 41,
      "endOffset" : 48
    }, {
      "referenceID" : 21,
      "context" : "This preprocessing is reminiscent of how [44, 6] preprocessed the input to provide numerical implementations of the fast relative-error algorithm [22] for approximate LS approximation.",
      "startOffset" : 146,
      "endOffset" : 150
    }, {
      "referenceID" : 20,
      "context" : ", we might be seeking a low-rank approximation to the matrix with respect to the spectral [21] or the Frobenius [12] norm, or we might be seeking useful features or data points in downstream data analysis applications [41, 33], or we might be seeking to develop high-quality numerical implementations of low-rank matrix approximation algorithms [27], etc.",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 11,
      "context" : ", we might be seeking a low-rank approximation to the matrix with respect to the spectral [21] or the Frobenius [12] norm, or we might be seeking useful features or data points in downstream data analysis applications [41, 33], or we might be seeking to develop high-quality numerical implementations of low-rank matrix approximation algorithms [27], etc.",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 39,
      "context" : ", we might be seeking a low-rank approximation to the matrix with respect to the spectral [21] or the Frobenius [12] norm, or we might be seeking useful features or data points in downstream data analysis applications [41, 33], or we might be seeking to develop high-quality numerical implementations of low-rank matrix approximation algorithms [27], etc.",
      "startOffset" : 218,
      "endOffset" : 226
    }, {
      "referenceID" : 31,
      "context" : ", we might be seeking a low-rank approximation to the matrix with respect to the spectral [21] or the Frobenius [12] norm, or we might be seeking useful features or data points in downstream data analysis applications [41, 33], or we might be seeking to develop high-quality numerical implementations of low-rank matrix approximation algorithms [27], etc.",
      "startOffset" : 218,
      "endOffset" : 226
    }, {
      "referenceID" : 25,
      "context" : ", we might be seeking a low-rank approximation to the matrix with respect to the spectral [21] or the Frobenius [12] norm, or we might be seeking useful features or data points in downstream data analysis applications [41, 33], or we might be seeking to develop high-quality numerical implementations of low-rank matrix approximation algorithms [27], etc.",
      "startOffset" : 345,
      "endOffset" : 349
    }, {
      "referenceID" : 25,
      "context" : "essentially proven in [27], but see also [43] for computational details; we will use the version of the lemma that appeared in [10].",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 41,
      "context" : "essentially proven in [27], but see also [43] for computational details; we will use the version of the lemma that appeared in [10].",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 9,
      "context" : "essentially proven in [27], but see also [43] for computational details; we will use the version of the lemma that appeared in [10].",
      "startOffset" : 127,
      "endOffset" : 131
    }, {
      "referenceID" : 10,
      "context" : "(See also the conference version [11], but in the remainder we refer to the technical report version [10] for consistency of numbering.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 9,
      "context" : "(See also the conference version [11], but in the remainder we refer to the technical report version [10] for consistency of numbering.",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 25,
      "context" : ") Note that for our purposes in this section, the computation of Y is not relevant and we defer the reader to [27, 10] for details.",
      "startOffset" : 110,
      "endOffset" : 118
    }, {
      "referenceID" : 9,
      "context" : ") Note that for our purposes in this section, the computation of Y is not relevant and we defer the reader to [27, 10] for details.",
      "startOffset" : 110,
      "endOffset" : 118
    }, {
      "referenceID" : 9,
      "context" : "This version of the above lemma is proven in [10].",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 9,
      "context" : "Then, the above lemma is proven in [10].",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 29,
      "context" : "1 A related estimator for the leverage scores Magdon-Ismail in [31] presented the following algorithm to estimate the statistical leverage scores: given as input an n× d matrix A, with n ≫ d, the algorithm proceeds as follows.",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 29,
      "context" : "[31] argued that the output p̃i achieves an O(ln 2 n) approximation to all of the (normalized) statistical leverage scores of A in roughly O(nd2/ ln n) time.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 21,
      "context" : "1 of [22] to get12 that",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 21,
      "context" : "1 of [22] with A = V T and note that ∥ V T ∥",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 21,
      "context" : "The resulting algorithm could be theoretically analyzed following the lines of [22].",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 34,
      "context" : "3 Extension to streaming environments In this section, we consider the estimation of the leverage scores and of related statistics when the input data set is so large that an appropriate way to view the data is as a data stream [36].",
      "startOffset" : 228,
      "endOffset" : 232
    } ],
    "year" : 2012,
    "abstractText" : "The statistical leverage scores of a matrix A are the squared row-norms of the matrix containing its (top) left singular vectors and the coherence is the largest leverage score. These quantities are of interest in recently-popular problems such as matrix completion and Nyströmbased low-rank matrix approximation as well as in large-scale statistical data analysis applications more generally; moreover, they are of interest since they define the key structural nonuniformity that must be dealt with in developing fast randomized matrix algorithms. Our main result is a randomized algorithm that takes as input an arbitrary n× d matrix A, with n ≫ d, and that returns as output relative-error approximations to all n of the statistical leverage scores. The proposed algorithm runs (under assumptions on the precise values of n and d) in O(nd log n) time, as opposed to the O(nd) time required by the näıve algorithm that involves computing an orthogonal basis for the range of A. Our analysis may be viewed in terms of computing a relative-error approximation to an underconstrained least-squares approximation problem, or, relatedly, it may be viewed as an application of Johnson-Lindenstrauss type ideas. Several practically-important extensions of our basic result are also described, including the approximation of so-called cross-leverage scores, the extension of these ideas to matrices with n ≈ d, and the extension to streaming environments.",
    "creator" : "LaTeX with hyperref package"
  }
}