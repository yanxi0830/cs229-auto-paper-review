{
  "name" : "1705.08076.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Learning from partial correction",
    "authors" : [ "Sanjoy Dasgupta", "Michael Luby" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Partial correction is a natural paradigm for interactive learning. Suppose, for example, that a taxonomy is to be constructed on a large set of species I, using steps of interaction with an expert. To see how one such step might go, let’s say the learner’s current model is some hierarchy h. Since it is likely too large to be fathomed in its entirety, a small set of species q ⊂ I is chosen at random (for instance, q = {dolphin, elephant, mouse, rabbit, whale, zebra}), and the biologist is shown the restriction of h to just these species, denoted h(q). See Figure 1. If this subtree is correct, the biologist accepts it. If not, he or she provides a partial correction in the form of a triplet like ({dolphin, whale}, zebra), meaning “there should be a cluster that contains dolphin and whale but not zebra”, that the correct tree must satisfy. This is easier than fixing the entire subtree.\nEarlier models of interactive learning have typically adopted a question-answer paradigm: the learner asks a question and the expert answers it completely. In active learning of binary classifiers, for example, the question is a data point and the answer is a single bit, its label. When learning broader families of structures, however, partial correction can be more convenient and intuitive. In the tree case, the minimal question would consist of three species, and the expert would need to provide the restriction of the target hierarchy to these three leaves. But seeing a larger snapshot is helpful: it provides more context, and thus more guidance about the levels of granularity of clusters; it allows the expert to select one especially egregious flaw to fix, rather than having to correct minor mistakes that might in any case go away once the bigger problems are resolved; and, by allowing choice, it also potentially produces more reliable feedback. Finally, if the subtree is correct, the expert can accept it with a single click, and is saved the nuisance of having to enter it.\nFormally, we assume that there is a space of structures H (for instance, trees over a fixed set of species), of which some h∗ ∈ H is the target. Any h ∈ H can be specified by its answers to a set of questions Q (for instance, all subsets of six species). On each step of learning:\n• The learner selects some hypothesis h ∈ H based on feedback received so far.\n• Some q ∈ Q is chosen at random.\n• The learner displays q and h(q) to an expert.\n• If h(q) is correct, the expert accepts it. Otherwise, the expert fixes some part of it.\nTo formalize this partial correction, we assume that each h(q) contains up to c atomic components, individual pieces that can be corrected. In the tree example, these are triples of species, so c = ( 6 3 ) = 20. We index these components as (q, 1), . . . , (q, c). The expert picks some j for which h(q, j) 6= h∗(q, j) and provides h∗(q, j). One case of technical interest, which we will later return to, is when the components of q are independently chosen from the same distribution. We will call such a distribution on queries component independent.\nar X\niv :1\n70 5.\n08 07\n6v 3\n[ cs\n.L G\n] 2\n5 M\nay 2\n01 7\nAs another example, suppose each q is a sequence of c video frames of the driver’s view in a car, and h∗(q, j) is the appropriate driving action for the jth frame. On each step of interaction, a human labeler is shown c frames, each labeled with an action, and either accepts all these actions as reasonable or corrects one of them. In this case it is unlikely that the distribution on queries is component independent.\nFormally, on each step of interaction, the learner either finds out that its prediction h(q) = (h(q, 1), . . . , h(q, c)) is entirely correct, or receives the correct value h∗(q, j) for just one atomic component j. This kind of feedback is not i.i.d.: first, the feedback is constrained to be only one component on which h is incorrect if there is such a component; and second, among possibly several such components, the expert chooses one in some haphazard arbitrary manner. Ideally, the expert’s choices are illustrative and help the learning process, and we will soon see a simple example of this kind. But in this paper we also study the other extreme: is it true that even if the expert adversarially chooses what feedback to give, the same rate of convergence as i.i.d. sampling is always assured? We show that this is indeed the case, and this is a crucial sanity check for the partial correction model. Furthermore, we show that our algorithms are optimal with respect to natural metrics."
    }, {
      "heading" : "1.1 Learning procedure",
      "text" : "Let µ be a probability distribution on Q, and let q ∈µ Q indicate that q is chosen independently from Q according to µ; in the tree example above, Q is all subsets of six species and µ is the uniform distribution on Q. On step t = 1, 2, . . . of learning,\n1. Learner selects some ht ∈ H consistent with all feedback received so far\n2. Choose q ∈µ Q, where q has c atomic components, (q, 1), . . . , (q, c).\n3. Learner displays q and ht(q) to expert\n4. If ht(q) is correct:\n• Expert feeds back that ht(q) is correct • Feedback implicitly provides, for all j ∈ [c], h∗(q, j) = ht(q, j).\nElse ht(q) is incorrect:\n• Expert chooses 1 ≤ j ≤ c for which ht(q, j) 6= h∗(q, j) • Expert feeds back j and h∗(q, j)."
    }, {
      "heading" : "1.2 Results",
      "text" : "The error of a hypothesis h ∈ H can be measured in two ways: in terms of full questions q ∈ Q,\nerr(h) = Prq∈µQ[h(q) 6= h∗(q)].\nor in terms of atomic components (q, j):\nerrc(h) = Prq∈µQ,j∈R[c][h(q, j) 6= h ∗(q, j)].\nThese are related by errc(h) ≤ err(h) ≤ c ·errc(h). Note that errc(h) ≈ err(h)/c if µ is component independent and err(h) is small.\nAn important complexity metric is the expert cost per step to provide feedback. This cost can be substantially lower in the new model: The expert can choose a component that is easiest to determine is incorrect amongst a set of c components, instead of being required to provide feedback for a particular component. We leave to future work the study of this metric in more detail.\nAnother crucial complexity metric is the number of steps of feedback required to learn. We start with a simple one-dimensional example (Section 2) that illustrates how the expert’s choice of feedback can significantly affect this metric. In the example, one feedback strategy reduces the number of steps needed for learning by a factor of up to c (so that each feedback component is about as valuable as c randomly chosen components), while a different strategy increases the number of steps by a factor of Ω(c) (slows down learning).\nThe example demonstrates that the number of steps needed to learn can vary by wide margins depending on the expert policy. Our main result (Theorem 2) shows that, despite this, there is a reasonable bound on the number of steps to learn no matter how adversarial the expert policy: For any expert policy, for any 0 < δ, < 1, with probability 1− δ the base algorithm of Section 1.1 produces a hypothesis h with err(h) ≤ within O((c/ ) · log(|H|/δ)) steps of feedback. Moreover (Theorem 8), after the same number of steps, all remaining consistent hypotheses have errc(h) ≤ . Section 6 shows that this number of steps is needed for at least some examples.\nIn the standard supervised learning model [1], labeled data is provided in advance, after which a consistent hypothesis is sought. In our protocol, feedback is obtained in steps, and the learner needs to maintain a consistent hypothesis throughout the process. Because it can be expensive to continually select a consistent hypothesis, we introduce the stick-with-it algorithm, a variant of the base algorithm, that might be preferable in practice (Section 5). Rather than always having to select a hypothesis that is consistent with all feedback received so far at each step, it only updates its hypothesis O(c) times during the entire learning process. It works for any concept class of bounded VC dimension d, it obtains a hypothesis h with err(h) ≤ within O((c/ ) · (d+ log(1/δ))) steps of feedback.\nTo obtain these sample complexity bounds, we look at the effective distribution wt over atomic components (q, j) at each time step t, which is a function of previous feedback, the learning algorithm’s choice of current model ht, and the expert’s criterion for selecting what to correct. This can be quite different from the distribution that would be easy to analyze, where q ∈µ Q and j is chosen at random; in particular, wt can be zero at many (q, j) with µ(q) > 0. Nonetheless, we show that over time, no matter what policy the expert chooses, wt cannot avoid covering the whole Q× [c] space in some suitably amortized sense.\nThe growing area of interactive learning raises many new problems and challenges. Here we have formalized an interactive protocol that is quite natural and intuitive in terms of human-computer interface, but breaks the statistical assumptions that underlie generalization results in other settings like the PAC model [1]. Our key technical contribution is to establish sample complexity bounds in this novel framework."
    }, {
      "heading" : "2 An illustrative example",
      "text" : "Suppose X = [0, 1] and the goal is to learn a threshold classifier:\nH = {hv : v ∈ [0, 1]}, hv(x) = 1(x > v).\nSay the target threshold is 0 (that is, h∗ = h0), so that the correct label for all points in (0, 1] is 1. If we were learning from random examples (x, h∗(x)) then, independent of the distribution on X , after O(1/ ) samples all remaining consistent hypotheses would (with probability close to one) consist entirely of classifiers h with err(h) ≤ . Thus, after O(1) instances, the error would be lower than any pre-specified constant."
    }, {
      "heading" : "2.1 Uniformly distributed, component independent queries",
      "text" : "Let µc be the uniform distribution on atomic components X , and let µ be the component independent distribution over the space of queries Q = X c induced by µc. Thus, for any v ∈ [0, 1], errc(hv) = v and err(hv) = 1− (1− v)c, and thus errc(h) ≈ err(h)/c if err(h) is small. We’ll try to understand how the rate of convergence of vt to zero is affected by c and by the expert labeler’s policy for which errors to correct, where vt is the threshold the learner has determined after t steps, i.e., vt is the smallest component value for which feedback has been provided by the expert and thus only classifiers with threshold at most vt are still consistent with the feedback through t steps.\nWe consider two expert policies:\n• “Largest”: the expert picks the largest component in error. This corresponds to a natural tendency to fix the biggest mistake, but happens to be the least informative correction.\n• “Smallest”: the expert picks the smallest component in error. This is the most informative correction.\nThe next query is chosen by picking x1, . . . , xc ∈R [0, 1]. Let Vt+1 be the random variable that is the threshold value the learner determines at step t+ 1. What is the expected value of Vt+1?\nWhen the labeling policy is “largest”: For any v ∈ [0, vt], the only way Vt+1 can exceed v is if either all the xi are ≥ vt (and thus they are all correctly labeled by hvt) or if at least one of the xi lies in (v, vt) (in which case, there is at least one error, but the largest component in error exceeds vt):\nPr(Vt+1 > v | Vt = vt) = Pr(all xi ≥ vt) + (1− Pr(no xi in (v, vt))) = (1− vt)c + (1− (1− (vt − v))c)\nTherefore, by calculation, E[Vt+1 | Vt = vt] = ∫ vt\n0\nPr(Vt+1 > v | Vt = vt)dv = vt − 1− (1− vt)c · (1 + c · vt)\nc+ 1 .\nWhen the labeling policy is “smallest”: For v ∈ [0, vt], the only way Vt+1 can exceed v is if none of the xi lie in [0, v], so Pr(Vt+1 > v | Vt = vt) = (1− v)c, whereupon, by a similar integral,\nE[Vt+1 | Vt = vt] = 1− (1− vt)c+1\nc+ 1 .\nWhen c = 1, the two policies coincide and E[Vt+1|vt] = vt− v2t /2, so the expected instantaneous reduction in Vt, that is E[vt − Vt+1], from seeing a single-point query is v2t /2. How does this compare to the expected instantaneous reduction from queries consisting of c points? The ratio of the expected reduction with c-point queries to the expected reduction with 1-point queries is shown in Figure 2 for c = 4, 8 and for the “smallest”, “largest” labeling policies. The ratio is given at each value vt.\nAs expected, under the “smallest” labeling policy, c-point queries are always more helpful than single-point queries. Under the “largest” policy, this is true only when vt is sufficiently small. In either case, when vt gets close to zero, the single label yielded by a c-point query is roughly as informative as c random labeled points. This can be checked using simple approximations to the expressions obtained above.\nThis toy example shows that the rate of convergence of learning by partial correction depends on the labeler’s policy for deciding which error to fix. Even in a one-dimensional setting with few degrees of freedom, different labeling policies can cause convergence to either slow down or speed up, by factors of up to c. We now formalize lower bounds of this type."
    }, {
      "heading" : "2.2 A lower bound on component-level error",
      "text" : "We continue with the one-dimensional example, but now turn to distributions that are not component independent.\nWe will consider a learner that begins with a threshold of 1, and at any given time, chooses the largest threshold consistent with all feedback so far: namely, the smallest labeled point it has received."
    }, {
      "heading" : "2.2.1 A single query, repeated",
      "text" : "To start with an especially simple case, say the distribution µ over Q is supported on a single point, (1/c, 2/c, . . . , 1). Suppose moreover that the expert labeler behaves as follows: when presented with a labeling of the points 1/c, 2/c, . . . , 1, he/she always chooses to “correct the most glaring flaw”, that is, the highest value for which a 0 label is suggested.\nIt is clear that x = 1 is labeled in the first round, x = (c − 1)/c in the second round, x = (c − 2)/c in the third round, and so on. The labeler’s behavior is hardly pathological. And yet, it takes c/2 rounds of interaction to bring the error down to 1/2. If the feedback were on random components, then O(1) rounds would have been sufficient."
    }, {
      "heading" : "2.2.2 Lower bound",
      "text" : "Pick any > 0, and now consider a distribution µ over Q that is supported on just two points:( 1 2c , 2 2c , . . . , 1 2 ) probability 2 (\n1 2 + 1 2c , 1 2 + 2 2c , . . . , 1\n) probability 1− 2\nAny hypothesis with errc(hv) ≤ must have v ≤ 1/4. In order to achieve this, the learner must see the first point at least c/2 times, which requires seeing Ω(c/ ) samples overall, with high probability.\nWe have established the following.\nTheorem 1 There is a concept class H of VC dimension 1 such that for any > 0, it is necessary to have Ω(c/ ) rounds of feedback in order to be able to guarantee that with high probability, all hypotheses h consistent with this feedback have errc(h) ≤ ."
    }, {
      "heading" : "3 Main result",
      "text" : "For each h ∈ H, let\nB(h) = {q ∈ Q : h is incorrect on q}, G(h) = {q ∈ Q : h is correct on q}\nNote that err(h) = µ(B(h)) is the probability that h is incorrect on a randomly chosen query. We say that hypothesis h is -good if µ(B(h)) ≤ . On input ( , δ), the goal is to find an h ∈ H that is -good with probability at least 1− δ.\nLet ` = log(H/δ), let ′ = /2, and let N = c · ( ` ′ + 1 ) .\nTheorem 2 The base algorithm of Section 1.1 produces an -good hypothesis within 2 ·N steps with probability at least 1− δ.\nIt is interesting to compare Theorem 2 when µ is component independent to classical learning theory. Theorem 2 shows that after at most 2 ·N = O(c · log(|H|)/ ) steps the output hypothesis h satisfies err(h) ≤ , which implies errc(h) ≤ /c if µ is component independent. This is the same number of steps the classical model would take to achieve component error /c when each question is a single component and the expert provides complete feedback for each question. Of course, the bound of Theorem 2 applies whether or not µ is component independent.\nThe remainder of this section concentrates on proving Theorem 2. The analysis procedes in two phases: the first phase considers the first N steps, and the second phase considers the subsequent N steps. Let\nQ̄ = Q× [c], B̄(h) = {(q, j) ∈ Q̄ : q ∈ B(h) and h(q, j) 6= h∗(q, j)}, Ḡ(h) = G(h)× [c]."
    }, {
      "heading" : "3.1 Effective sampling distribution",
      "text" : "At the beginning of step t, some hypothesis ht is selected. The analysis defines an effective sampling distribution wt over Q̄, as follows:\n• For all (q, j) ∈ B̄(ht), let γ(q, j) denote the conditional probability that the expert provides feedback on (q, j) when query q is made. Define wt(q, j) = µ(q) · γ(q, j).\n• For all q ∈ G(ht) calculate wt(q, 1), . . . , wt(q, c), summing to µ(q), as specified below in Lemma 3.\nFinally, let Wt(q, j) = w1(q, j) + · · ·+ wt(q, j)\ndenote the sum of the individual distributions up to step t. Note that at each step t, for each q ∈ Q, we have wt(q, [c]) = µ(q) and thus Wt(q, [c]) = t · µ(q).\nLemma 3 For all q ∈ G(ht), non-negative values for wt(q, 1), . . . , wt(q, c), summing to µ(q), can be calculated such that if wt(q, j) > 0 then\nWt(q, j) = Wt−1(q, j) + wt(q, j) ≤ t · µ(q) c .\nProof: Since Wt(q, [c]) will be equal to t · µ(q), t·µ(q)c will be the average over j ∈ [c] of Wt(q, j). Thus, we can choose wt(q, 1), . . . , wt(q, c) as follows. Let j1, . . . , jc be an ordering of the elements of [c] such that\nWt−1(q, j1) ≤Wt−1(q, j2) ≤ · · · ≤Wt−1(q, jc).\nInitialize ∆ = µ(q), wt(q, j1) = · · · = wt(q, jc) = 0. Repeat the following for i = 1, . . . , c until ∆ = 0: Reset\nwt(q, ji) = min { t · µ(q) c −Wt−1(q, ji),∆ }\nand reset ∆ = ∆− wt(q, ji)."
    }, {
      "heading" : "3.2 Eliminating inconsistent hypotheses",
      "text" : "Lemma 4 With probability at least 1 − δ, the following holds for all h ∈ H: if there is a step t at which Wt(B̄(h)) ≥ `, then h is not consistent with the feedback received up to that step.\nProof: Pick any h ∈ H. It is eliminated if feedback is received on any (q, j) ∈ B̄(h). The probability that this happens at step t is at least wt(B̄(h)).\nLet t be the first step at which Wt(B̄(h)) ≥ `. The probability that h is not eliminated by the end of step t is at most\n(1− w1(B̄(h))) · (1− w2(B̄(h))) · · · (1− wt(B̄(h))) ≤ exp(−Wt(B̄(h))) ≤ exp(−`) = δ\n|H| .\nTaking a union bound over H, with probability at least 1− δ, any hypothesis h is eliminated from the version space by the step at which Wt(B̄(h)) ≥ `.\nAt the outset of any step t, we may therefore assume that ht satisfies Wt−1(B̄(ht)) < `."
    }, {
      "heading" : "3.3 Analysis for Phase 1",
      "text" : "Consider a first phase consisting of the first N steps. Let\nτ = N\nc =\n`\n′ + 1\nbe a threshold value. We will think of an atomic question (q, j) as having been adequately sampled when Wt(q, j) reaches τ · µ(q).\nAt the beginning of step t, let\nL̄t−1 = {(q, j) ∈ Q̄ : Wt−1(q, j) ≤ τ · µ(q)}.\nThus Wt−1(L̄t−1) = ∑ (q,j)∈L̄t−1 Wt−1(q, j) ≤ c · τ = N\n(substituting a suitable integral over Q if necessary). Let\nL̄′t−1 = {(q, j) ∈ Q̄ : Wt−1(q, j) ≤ (τ − 1) · µ(q) = ` ′ · µ(q)}.\nThis is the set of (q, j) in which there is still some remaining capacity.\nLemma 5 At any step t, if Wt−1(B̄(ht)) < `, then\nwt(B̄(ht) ∩ L̄′t−1) ≥ µ(B(ht))− ′.\nProof: Note that\nµ(B(ht)) = wt(B̄(ht)) = wt(B̄(ht) ∩ L̄′t−1) + wt(B̄(ht) \\ L̄′t−1). (1)\nSince ` > Wt−1(B̄(ht)) ≥Wt−1(B̄(ht) \\ L̄′t−1) ≥ ` ′ · wt(B̄(ht) \\ L̄′t−1),\nit follows that wt(B̄(ht) \\ L̄′t−1) ≤ ′ and thus wt(B̄(ht) ∩ L̄′t−1) ≥ µ(B(ht))− ′ follows from Equation (1).\nLemma 6 At any step t ≤ N , wt(L̄t) ≥ 1− ′.\nProof: Note that wt(L̄t) = wt(B̄(ht) ∩ L̄t) + wt(Ḡ(ht) ∩ L̄t).\nSince any (q, j) ∈ B̄(ht)∩ L̄′t−1 satisfies (q, j) ∈ B̄(ht)∩ L̄t, Lemma 5 implies wt(B̄(ht)∩ L̄t) ≥ µ(B(ht))− ′. For q ∈ G(ht), from Lemma 3 and noting that t ≤ N , any (q, j) with wt(q, j) > 0 satisfies\nWt(q, j) ≤ t · µ(q) c ≤ τ · µ(q),\nand thus (q, j) ∈ L̄t, and it follows that wt(Ḡ(ht) ∩ L̄t) = µ(G(ht)). Overall,\nwt(L̄t) ≥ µ(B(ht))− ′ + µ(G(ht)) = 1− ′.\nLet Ŵt(q, j) = min{Wt(q, j), τ · µ(q)}. As we have seen, Ŵt(Q̄) ≤ N .\nCorollary 7 ŴN (Q̄) ≥ (1− ′) ·N .\nProof: An immediate consequence of Lemma (6)."
    }, {
      "heading" : "3.4 Analysis for Phase 2",
      "text" : "We now finish the proof of Theorem 2. Proof: Consider a second phase of N additional steps. Let ht be the current hypothesis for one of these steps. If µ(B(ht)) ≥ 2 · ′ then µ(B(ht))− ′ ≥ ′, and the first half of the proof of Lemma 6 implies that Ŵt(Q̄) increases by at least ′ during this step. However, since Ŵt(Q̄) ≤ N , and since ŴN (Q̄) ≥ (1− ′) ·N at the beginning of the second phase from Corollary 7, there can be at most N steps in the second phase where Ŵt(Q̄) increases by at least ′. Thus, during one of the steps in the second phase µ(B(ht)) ≤ 2 · ′ = , at which point the base algorithm can select ht as an -good hypothesis and terminate. This concludes the proof of Theorem 2."
    }, {
      "heading" : "4 Generalization bound",
      "text" : "The following generalization bound holds at the end of Phase 1.\nTheorem 8 With probability at least 1− δ, any h ∈ H that remains in the version space at the end of Phase 1 (that is, after N = c · ( ` ′ + 1) rounds of feedback) has errc(h) < .\nProof: Let µ̄ be the distribution over Q̄ that corresponds to picking q from µ and then picking a feature at random: µ̄(q, j) = µ(q)/c. Thus for any h ∈ H, we have errc(h) = µ̄(B̄(h)).\nAt the end of Phase 1, ŴN (Q̄) ≥ (1− ′) ·N . Thus for any h ∈ H,\nŴN (B̄(h)) ≥  ∑ (q,j)∈B̄(h) τ · µ(q) − ′ ·N =  ∑ (q,j)∈B̄(h) N · µ̄(q, j) − ′ ·N = N · (µ̄(B̄(h))− ′). If µ̄(B̄(h)) ≥ = 2 · ′, we get\nWN (B̄(h)) ≥ ŴN (B̄(h)) ≥ N · ′ > c · `.\nBy Lemma 4, with probability at least 1− δ, any such h is eliminated by the end of the Nth step.\nRecall from Theorem 1 that this c/ dependence is inevitable."
    }, {
      "heading" : "5 Stick-with-it algorithm",
      "text" : "There are some practical issues with the base algorithm of Section 1.1. One issue is that at the beginning of each step a current hypothesis needs to be selected that is consistent with all previous steps. This results in a number of selections equal to the number of steps.\nA second issue is that a separate procedure is needed to evaluate whether a given hypothesis is -good in order to terminate the base algorithm with a hypothesis that is verified to be -good, since a current hypothesis may be the current hypothesis for only one step.\nA third issue is that the analysis doesn’t obviously carry over to the case where H = |H| is unbounded but instead the VC-dimension of H is bounded.\nWe introduce the stick-with-it algorithm, a variant of the base algorithm, that addresses all these issues. We use an integer k ≥ 1 to describe the following changes to the base algorithm:\n• Instead of selecting a current hypothesis at each step, a current hypothesis is selected each k consecutive steps. Thus, once a current hypothesis is selected it is used as the current hypothesis for k consecutive steps. (This is where \"stick-with-it\" comes from.)\n• Redefine N = c · ( ` ′ + k ) . All parameters defined in terms of N are similarly redefined, e.g., τ = ` ′ + k.\n• Redefine L̄′t = {(q, j) ∈ Q̄ : Wt(q, j) ≤ (τ − k) · µ(q) = ` ′ · µ(q)}.\nEssentially the same analysis as described for the base algorithm shows that the stick-with-it algorithm produces an h ∈ H that is -good with probability at least 1− δ within 2 ·N steps.\nSetting k = ` ′ = 2·` results in a stick-with-it algorithm with the following properties:\n• The number of steps is at most 2 ·N ≤ 8·c·` .\n• The number of steps a current hypothesis needs to be selected that is consistent with all previous steps is at most 2·Nk ≤ 4 · c.\n• A selected current hypothesis is the current hypothesis for enough steps (k) to determine if it is -good, and if it is -good then the stick-with-it algorithm terminates.\n• Let d be the VC-dimension of H. The same analysis applies when ` = d+ log(1/δ).\nThe stick-with-it algorithm is optimal in the following metrics:\n• The bound on the number of steps, including steps to verify that the output hypothesis is -good, is within a constant factor of the number needed for some examples. (See Section 6.)\n• The bound on the number of selections of a current hypothesis is within a constant factor of the number needed for some examples. (See Section 6.)\n• The same optimality holds when the VC-dimension of H is bounded."
    }, {
      "heading" : "6 Lower bound on number of steps and selected hypotheses",
      "text" : "An example showing the number of needed steps can be proportional to c·log |H| is obtained as follows. Let Q be any fixed subset of Q such that |Q | = · |Q|. Let h∗ be the correct hypothesis. For i = 1, . . . , c/2, let Hi consist of all classifiers h with the following properties:\n• h(q, j) = h∗(q, j) if q 6∈ Q or j /∈ {2i, 2i− 1}.\n• For each q ∈ Q , either\n– h(q, 2i− 1) 6= h∗(q, 2i− 1) and h(q, 2i) = h∗(q, 2i), or\n– h(q, 2i− 1) = h∗(q, 2i− 1) and h(q, 2i) 6= h∗(q, 2i)\nNotice that any such h has err(h) = , and that |Hi| = 2|Q |. Finally, define\nH = c/2⋃ i=1 Hi ∪ {h∗}.\nWrite ` = |Q | = ·Q. Then log |H| ≈ `+ log c ≈ `. Let’s say the learner always prefers to select a hypothesis in H1, then H2, and so on, and will only select h∗ when all these options have been exhausted. When a hypothesis in Hi is selected, it will make a mistake whenever the query lies in Q . This mistake will provide no information about any other q ∈ Q , or about any other hypothesis in Hi′ for i′ 6= i.\nThus, on average `/ queries will be needed to eliminate Hi for each i = 1, . . . , c/2, for a total query complexity of roughly c·`2· .\nIn this example the number of selected hypotheses is at least c/2, i.e., at least one hypothesis from each of H1, . . . ,Hc/2 is selected as the current hypothesis at some step."
    }, {
      "heading" : "7 Acknowledgments",
      "text" : "This work is a direct result of the Foundations of Machine Learning program at the Simons Institute, UC Berkeley."
    } ],
    "references" : [ {
      "title" : "A theory of the learnable",
      "author" : [ "L. Valiant" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1984
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "In the standard supervised learning model [1], labeled data is provided in advance, after which a consistent hypothesis is sought.",
      "startOffset" : 42,
      "endOffset" : 45
    }, {
      "referenceID" : 0,
      "context" : "Here we have formalized an interactive protocol that is quite natural and intuitive in terms of human-computer interface, but breaks the statistical assumptions that underlie generalization results in other settings like the PAC model [1].",
      "startOffset" : 235,
      "endOffset" : 238
    }, {
      "referenceID" : 0,
      "context" : "Suppose X = [0, 1] and the goal is to learn a threshold classifier:",
      "startOffset" : 12,
      "endOffset" : 18
    }, {
      "referenceID" : 0,
      "context" : "H = {hv : v ∈ [0, 1]}, hv(x) = 1(x > v).",
      "startOffset" : 14,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "Thus, for any v ∈ [0, 1], errc(hv) = v and err(hv) = 1− (1− v), and thus errc(h) ≈ err(h)/c if err(h) is small.",
      "startOffset" : 18,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : ", xc ∈R [0, 1].",
      "startOffset" : 8,
      "endOffset" : 14
    } ],
    "year" : 2017,
    "abstractText" : "We introduce a new model of interactive learning in which an expert examines the predictions of a learner and partially fixes them if they are wrong. Although this kind of feedback is not i.i.d., we show statistical generalization bounds on the quality of the learned model.",
    "creator" : "LaTeX with hyperref package"
  }
}