{
  "name" : "1202.3505.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Rich Coresets For Constrained Linear Regression",
    "authors" : [ "Christos Boutsidis" ],
    "emails" : [ "cboutsi@us.ibm.com", "drinep@cs.rpi.edu", "magdon@cs.rpi.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n20 2.\n35 05\nv1 [\ncs .D\nS] 1"
    }, {
      "heading" : "1 Introduction",
      "text" : "Linear regression is an important technique in data analysis (Seber and Lee, 1977). Research in the area ranges from numerical techniques (A. Björck, 1996) to robustness of the prediction error to noise (e.g. using feature selection (Guyon and Elisseeff, 2003)).\nIs it possible to efficiently identify a small subset of the data that contains all the essential information of a learning problem? Such a subset is called a “rich” coreset. We show that the answer is yes, for linear regression. Such a rich coreset is analogous to the support vectors in support vector machines (Cristianini and Shawe-Taylor, 2000). Such rich coresets contain the meaningful or important points in the data and can be used to find good approximate solutions to the full problem by solving a (much) smaller problem. When the constraints are complex (e.g. non-convex constraints), solving a much smaller regression problem could be a significant saving (Gao, 2007).\nWe present coreset constructions for constrained regression (both simple and multiple response), as well as lower bounds for the size of “rich” coresets. In addition to potential computational savings, a rich coreset identifies the important core of a machine learning problem and is of considerable interest in applications with huge data where incremental approaches are necessary (eg. chunking) and applications where data is distributed and bandwith is costly (hence communicating only the essential data is imperative).\nOur first contribution is a deterministic, polynomial-time algorithm for constructing a rich coreset for arbitrarily constrained linear regression. Let k be the “effective dimension” of the data and let ǫ > 0 be the desired accuracy parameter. Our algorithm constructs a rich coreset of size O ( k/ǫ2 )\n, which achieves a (1 + ǫ)-relative error performance guarantee. In other words, solving the regression problem on the coreset results in a solution which fits all the data with an error which is at most (1 + ǫ) worse than the best possible fit to all the data. We extend our results to the setting of multiple response regression using more\nsophisticated techniques. Underlying our proofs are two sparsification tools from linear algebra (Batson et al., 2009; Boutsidis et al., 2011), which may be of general interest to the machine learning community."
    }, {
      "heading" : "1.1 Problem Setup",
      "text" : "Assume the usual setting with n data points (z1, y1), . . . , (zn, yn); zi ∈ Rd are feature vectors (which could have been obtained by applying a non-linear feature transform to raw data) and yi ∈ R are targets (responses). The linear regression problem asks to determine a vector xopt ∈ D ⊆ Rd that minimizes\nE(x) = n ∑\ni=1\nwi(z T i · x− yi)2\nover x ∈ D, where wi are positive weights. So, E(xopt) ≤ E(x), for all x ∈ D. The domain D represents the constraints on the solution, e.g., in non-negative least squares (NNLS) (Lawson and Hanson, 1974; Bellavia et al., 2006), D = Rd+, the nonnegative orthant. Our results hold for arbitrary D.\nA coreset of size r < n is a subset of the data, (zi1 , yi1), . . . , (zir , yir). The coreset regression problem considers the squared error on the coreset with a, possibly different, set of weights sj > 0,\nẼ(x) = r ∑\nj=1\nsj(z T ij · x− yij) 2.\nSuppose that Ẽ is minimized at x̃opt, so Ẽ(x̃opt) ≤ Ẽ(x), for all x ∈ D. The coreset is rich if, for some set of weights sj, x̃opt is nearly as good as xopt for the original regression problem on all the data, i.e., for some small ǫ > 0, E(xopt) ≤ E(x̃opt) ≤ (1 + ǫ)E(xopt). The algorithm which constructs the coreset should also provide the weights sj. For the remainder of the paper, we switch to an equivalent matrix formulation of the problem. We give some linear algebra background in the Appendix.\nMatrix Formulation. Let A ∈ Rn×d be the data matrix whose rows are the weighted data points√ wiz T i and b ∈ Rn is the similarly weighted target vector, bi = √ wiyi. The effective dimension of the data can be measured by the rank of A; let k = rank(A).Our results hold for arbitrary d, however, in most applications, n ≫ d and rank(A) ≈ d. We can rewrite the squared error as E(x) = ‖Ax− b‖22, so,\nxopt = argmin x∈D\n‖Ax− b‖22.\nA coreset of size r < n is a subset C ∈ Rr×d of the rows of A and the corresponding elements bc ∈ Rr of b. Let D ∈ Rr×r be a positive diagonal matrix for the coreset regression (the weights sj of the coreset regression will depend onD). The weighted squared error on the coreset is given by Ẽ(x) = ‖D(Cx−bc)‖22, so the coreset regression seeks x̃opt defined by\nx̃opt = argmin x∈D\n‖D (Cx− bc) ‖22.\nWe say that the coreset is (1 + ǫ)-rich if the solution obtained by fitting the coreset data can fit all the data almost optimally. Formally,\n‖Axopt − b‖22 ≤ ‖Ax̃opt − b‖22 ≤ (1 + ǫ)‖Axopt − b‖22."
    }, {
      "heading" : "1.2 Our contributions",
      "text" : "Constrained Linear Regression (Section 2). Our main result for constrained simple regression is Theorem 1, which describes a deterministic polynomial time algorithm that constructs a (1+ǫ)-rich coreset of size O ( k/ǫ2 )\n. Prior to our work, the best result achieving comparable relative error performance guarantees is Theorem 1 of (Boutsidis and Drineas, 2009) for constrained regression, and the work of (Drineas et al., 2006) for unconstrained regression. Both of these prior results construct coresets of size O ( k log k/ǫ2 ) and they are randomized, so, with some probability, the fit on all the data can be arbitrarily bad (despite the coreset being a logarithmic factor larger). Our methods have comparable, low order polynomial running times and provide deterministic guarantees. The results in (Drineas et al., 2006) and (Boutsidis and Drineas, 2009) are achieved using the matrix concentration results in (Rudelson and Vershynin, 2007). However, these concentration bounds break unless the coreset size is at least Ω ( k log(k)/ǫ2 )\n. We give the first algorithms that break the k log k barrier.\nWe extend our results to multiple response regression, where the target is a matrix B ∈ Rn×ω with ω ≥ 1. Each column of B is a seperate target (or response) that we wish to predict. We seek to minimize ‖AX−B‖ over allX ∈ D ⊆ Rd×ω, and some matrix norm ‖ · ‖. Multiple response regression has numerous applications, but is perhaps most common in multivariate time series analysis; see for example (Hamilton, 1994; Breiman and Friedman, 1997). To illustrate, consider prediction of time series data: let Z ∈ R(n+1)×d be a set of d time series, where each column is a time series with n+1 time steps; we wish to predict time step t+ 1 from time step t. Let A contain the first n rows of Z and let B contain the last n rows. Then, we seek X that minimizes ‖AX−B‖, which is exactly the multiple response regression problem. In our work, we focus on the spectral norm ‖ · ‖2 and the Frobenius norm ‖ · ‖F, the two most common norms in matrix analysis.\nMulti-Objective Regression (Section 3.1). An important variant of multiple regression is the socalled multi-objective regression. Let B = [b1, . . . ,bω] ∈ Rn×ω, where we explicitly identify each column in B as a target response bj . We seek to simultaneously fit multiple target vectors with the same x, i.e. to simultaneously minimize ‖Ax− bj‖22 where j ∈ {1, 2, . . . , ω}. This is common when the goal is to trade off different quality criteria simultaneously. Writing X = [x,x, . . . ,x] ∈ Rd×ω (ω copies of x), we consider minimizing ‖AX−B‖F, which is equivalent to multiple regression with a strong constraint on X. We present results for coreset constructions for the Frobenius-norm multi-objective regression problem in Theorem 4, which describes a deterministic algorithm to construct (1+ ǫ)-rich coresets of size O ( k/ǫ2 )\n. Theorem 4 emerges by applying Theorem 1 after converting the Frobenius-norm multi-objective regression problem to a simple response regression problem.\nArbitrarily-Constrained Multiple-Response Regression (Section 3.2). Using the same approach, converting the problem to a single response regression, we construct a (1 + ǫ)-rich coreset for Frobeniusnorm arbitrarily-constrained regression in Section 3.2. The coreset size here is O ( kω/ǫ2 ) .\nUnconstrained Multiple-Response Regression (Section 4). In Section 4, we consider rich coresets for unconstrained multiple regression for both the spectral and Frobenius norms. The sizes of the coresets are smaller than the constrained case, and our main results are presented in Theorems 6 and 7. Theorem 6 presents a (2+ ǫ)-rich coreset of size O((k+ω)/ǫ2) for spectral norm regression, while Theorem 7 presents a (2 + ǫ)-rich coreset of size O(k/ǫ2) for Frobenius norm regression.\nLower Bounds (Section 5). Finally, in Section 5, we present lower bounds on coreset sizes. In the single response regression setting, we note that our algorithms need to look at the target vector b. We show that this is unavoidable, by arguing that no b-agnostic deterministic coreset construction algorithm\ncan construct rich coresets which are small (Theorem 11). We also present similar results for b-agnostic randomized coreset constructions (Theorem 12). Having shown that we cannot (in general) be b-agnostic, we present lower bounds on the size of rich coresets for spectral and Frobenius norm multiple response regression that apply in the non b-agnostic setting (Theorems 13 and 14)."
    }, {
      "heading" : "2 Constrained Linear Regression",
      "text" : "We define constrained linear regression as follows: given A ∈ Rn×d of rank k, b ∈ Rn, and D ⊆ Rd, we seek xopt ∈ D for which ‖Axopt−b‖22 ≤ ‖Ax−b‖22, for all x ∈ D (the domain D represents the constraints on x and can be arbitrary). To construct a coreset C ∈ Rr×d (i.e., C consists of a few rows of A) and bc ∈ Rr (i.e., bc consists of a few elements of b), we introduce sampling and rescaling matrices S and D respectively. More specifically, we define the row-sampling matrix S ∈ Rr×n whose rows are basis vectors eTi1 , . . . , e T ir . Our coreset C is now equal to SA; clearly, C is a matrix whose rows are the rows of A corresponding to indices i1, . . . , ir. Similarly, bc = Sb contains the corresponding elements of the target vector. Next, let D ∈ Rr×r be a positive diagonal rescaling matrix and define the D-weighted regression problem on the coreset as follows:\nx̃opt = argmin x∈D ‖D (Cx− bc) ‖22 = argmin x∈D ‖DS (Ax− b) ‖22. (1)\nIn the above, the operator DS first samples and then rescales rows of A and b. Theorem 1 is the main result in this section and presents a deterministic algorithm to select a rich coreset by constructing the matrices D and S. (All algorithms are given in the Appendix.)\nTheorem 1. Given A ∈ Rn×d of rank k, b ∈ Rn, and D ⊆ Rd, Algorithm 1 constructs matrices S ∈ Rr×n and D ∈ Rr×r (for any r > k + 1) such that x̃opt of eqn. (1) satisfies\n‖Ax̃opt − b‖22 ‖Axopt − b‖22 ≤ r + k + 1 + 2 √ r(k + 1) r + k + 1− 2 √ r(k + 1) = 1 + 4\n√\nk r + o ( √ k/r ) .\nThe running time of the proposed algorithm is T ( U[A,b] ) +O ( rnk2 ) , where T ( U[A,b] ) is the time needed to compute the left singular vectors of the matrix [A,b] ∈ Rn×(d+1).\nFor any 0 < ǫ < 1, we can set r = k/ǫ2 to get an approximation ratio roughly equal to 1 + 4ǫ. This result considerably improves the result in (Boutsidis and Drineas, 2009), which needs r = O(k log(k)/ǫ2) to achieve the same approximation. Additionally, our bound is deterministic, whereas the bound in (Boutsidis and Drineas, 2009) fails with constant probability. (Boutsidis and Drineas, 2009) requires an SVD computation in the first step, so its running time is comparable to ours.\nIn order to prove the above theorem, we need a linear algebraic sparsification result from (Batson et al., 2009), which we restate using our notation.\nLemma 2 (Single-set Spectral Sparsification (Batson et al., 2009)). Given U ∈ Rn×ℓ satisfying UTU = Iℓ and r > ℓ, we can deterministically construct sampling and rescaling matrices S and D such that, for all y ∈ Rℓ:\n(\n1− √ ℓ/r )2 ‖Uy‖22 ≤ ‖DSUy‖22 ≤ ( 1 + √ ℓ/r )2 ‖Uy‖22.\nThe algorithm runs in O(rnℓ2) time and we denote it as [D,S] = SimpleSampling(U, r).\nProof. (of Theorem 1) Let Y = [A,b] ∈ Rn×(d+1) and compute its SVD: Y = UΣVT. Let ℓ be the rank of Y (ℓ ≤ k + 1, since rank(A) = k) and note that U ∈ Rn×ℓ, Σ ∈ Rℓ×ℓ, and V ∈ R(d+1)×ℓ. Let [D,S] = SimpleSampling(U, r) and define y1,y2 ∈ Rℓ as follows:\ny1 = ΣV T\n[\nxopt −1\n]\n, and y2 =\n[\nx̃opt −1\n]\n.\nNote thatUy1 = Axopt−b, Uy2 = Ax̃opt−b,DSUy1 = DS (Axopt − b), andDSUy2 = DS (Ax̃opt − b). We will bound ‖Uy2‖ in terms of ‖Uy1‖:\n(\n1− √ ℓ/r )2 ‖Uy2‖22 (a) ≤ ‖DSUy2‖22 (b) ≤ ‖DSUy1‖22 (c) ≤ ( 1 + √ ℓ/r )2 ‖Uy1‖22.\n(a) and (c) follow from Lemma 2; (b) follows from the optimality of x̃opt for the coreset regression in eqn. (1). Using ℓ ≤ k+1 and manipulating the above expression concludes the proof of the theorem. The running time of the algorithm is equal to the time needed to compute U and the time needed to run the algorithm of Lemma 2 with ℓ ≤ k + 1."
    }, {
      "heading" : "3 Constrained Multiple-Response Regression",
      "text" : "Constrained multiple-response regression in the Frobenius norm can be reduced to simple regression. So, we can apply the results of the previous section to this setting."
    }, {
      "heading" : "3.1 Multi-Objective Regression",
      "text" : "The task is to minimize, over all x ∈ D, the Frobenius-norm error ‖A[x, . . . ,x]−B‖2F. Let bavg = 1ωB1ω (here 1ω is a vector of all ones and thus bavg is the average of the columns in B). Recall that A ∈ Rn×d, B ∈ Rn×ω, and let X = [x, . . . ,x] ∈ Rd×ω.\nLemma 3. For X = [x, . . . ,x] ∈ Rd×ω, ‖AX−B‖2F = ω‖Ax− bavg‖ 2 2 +\nω ∑\ni=1\n‖bavg −B(i)‖ 2\n2.\nIn the above B(i) denotes the i-th column of B as a column vector. Note that the second term in Lemma 3 does not depend on x and thus the generalized multi-objective regression can be reduced to simple regression on A and bavg. Using Theorem 1, we can get a coreset: let x̃opt minimize ‖DS (Ax− bavg) ‖2, where S and D are obtained via Theorem 1 applied to A and bavg . If X̃opt = [x̃opt, . . . , x̃opt], then, by Lemma 3, X̃opt minimizes ‖DS (AX−B) ‖F. Similarly, if xopt minimizes ‖Ax − bavg‖2 and Xopt = [xopt, . . . ,xopt], then Xopt minimizes ‖AX−B‖F . Theorem 4 says that X̃opt is approximates Xopt (the proof is in the appendix).\nTheorem 4. Given A ∈ Rn×d of rank k and B ∈ Rn×ω, we can construct matrices S ∈ Rr×n and D ∈ Rr×r (for any r > k+1) such that the matrix X̃opt = [x̃opt, . . . , x̃opt] that minimizes ‖DS (AX−B) ‖F over all matrices X = [x,x, . . . ,x] satisfies:\n‖AX̃opt −B‖ 2 F ≤ ( 1 +O ( √ k/r )) ‖AXopt −B‖2F.\nThe run time of the proposed algorithm is T ( U[A,bavg] ) +O ( nω + rnk2 ) , where T ( U[A,bavg] ) is the time needed to compute the left singular vectors of the matrix [A,bavg ] ∈ Rn×(d+1).\nWe note that the coreset size depends only on the rank of A and not on the size of B."
    }, {
      "heading" : "3.2 Arbitrarily-Constrained Multiple-Response Regression",
      "text" : "Multi-objective regression is a special case of constrained multiple-response regression for which we can efficiently obtain the coresets. In the general case, the problem still reduces to simple regression, but the coresets are now larger. We wish to minimize ‖AX−B‖F over X ∈ D ⊆ Rd×ω. Since Rd×ω is isomorphic to Rdω, we can view X ∈ Rd×ω as a “stretched out” vector X̂ ∈ Rdω; corresponding to the domain D is the domain D̂ ⊆ Rdω. Similarly, we can stretch out B ∈ Rn×ω to B̂ ∈ Rnω. To complete the transformation to simple linear regression, we build a transformed block-diagonal data matrix Â from A, by repeating ω copies of A along the diagonal:\nÂ =\n\n   \nA A\n. . .\nA\n\n    ∈ Rnω×dω, X̂ =\n\n   \nX(1) X(2)\n...\nX(ω)\n\n    ∈ Rdω, B̂ =\n\n   \nB(1) B(2)\n...\nB(ω)\n\n    ∈ Rnω\nLemma 5. For all A, X and B of appropriate dimensions, ‖AX−B‖2F = ‖ÂX̂− B̂‖22.\nTheorem 1 gives us coresets for this equivalent regression. Note that rank(Â) ≤ ω · rank(A). The coreset will identify the important rows of A (the same row may get identified multiple times as different rows of Â), and the important elements of B, because the entries in B̂ are elements of B, not rows of B. Let X̂opt be the solution constructed from the coreset, which minimizes ‖ÂX̂− B̂‖ over X̂ ∈ D̂, and let X̃opt ∈ D be the corresponding solution in the original domain D. If r is the size of the coreset and rank(A) = k, then, by Theorem 1,\n‖AX̃opt −B‖ 2 F ≤ ( 1 +O ( √ kω/r )) ‖AXopt −B‖2F.\nSo, for the approximation ratio to be 1+O(ǫ), we set r = O ( kω/ǫ2 ) . The running time would involve the\ntime needed to compute the SVD of [Â, B̂]. Notice that the coresets are large and somewhat costly to compute and they only work for the Frobenius norm. In the next section, using more sophisticated techniques, we will get smaller coresets for unconstrained regression in both the Frobenius and spectral norms."
    }, {
      "heading" : "4 Unconstrained Multiple-Response Regression",
      "text" : "Consider the following problem: given a matrix A ∈ Rn×d with rank exactly k and a matrix B ∈ Rn×ω, we seek to identify the matrix Xopt ∈ Rd×ω that minimizes (ξ = 2 and ξ = F)\nXopt = arg min X∈Rd×ω\n‖AX−B‖2ξ .\nWe can compute Xopt via the pseudoinverse of A, namely Xopt = A +B. If S and D are sampling and rescaling matrices respectively, then the coreset regression problem is:\nX̃opt = arg min X∈Rd×ω\n‖DSAX−DSB‖2ξ . (2)\nThe solution of the coreset regression problem is X̃opt = (DSA) +DSB. The main results in this section are presented in Theorems 6 and 7.\nTheorem 6 (Spectral norm). Given a matrix A ∈ Rn×d with rank exactly k and a matrix B ∈ Rn×ω, Algorithm 2 deterministically constructs matrices S and D such that solving the problem of eqn. (2) satisfies (for any r such that k + 1 < r ≤ n):\n‖AX̃opt −B‖22 ≤ ‖AXopt −B‖22 + ( 1 + √ ω/r\n1− √ k/r\n)2\n‖AXopt −B‖22.\nThe running time of the proposed algorithm is T (UA)+O ( rn ( k2 + ω2 ))\n, where T (UA) is the time needed to compute the left singular vectors of A.\nAsymptotically, for large ω, the approximation ratio of the above theorem is O (ω/r). We will argue that this is nearly optimal by providing a matching lower bound in Theorem 13.\nTheorem 7 (Frobenius norm). Given matrices A ∈ Rn×d of rank k and B ∈ Rn×ω, Algorithm 3 deterministically constructs a sampling matrix S and a rescaling matrix D such that solving the problem of eqn. (2) satisfies (for any r such that k + 1 < r ≤ n):\n‖AX̃opt −B‖2F ≤ ‖AXopt −B‖2F + 1 (\n1− √ k/r )2 ‖AXopt −B‖ 2 F.\nThe running time of the proposed algorithm is T (UA) + O ( rnk2 )\n, where T (UA) is the time needed to compute the left singular vectors of A.\nThe approximation ratio in the above theorem is 2 + O( √\nk/r). In Theorem 14, we will give a lower bound for the approximation ratio which is 1 + Ω(k/r). We conjecture that our lower bound can be achieved, perhaps by a more sophisticated algorithm.\nFinally, we note that the B-agnostic randomized construction of Drineas et al. (2008) achieves a (1+ǫ) approximation ratio using a significantly larger coreset, r = O(k log(k)/ǫ2). Importantly, they do not need any access to B in order to construct the coreset, whereas our approach constructs coresets by carefully choosing important data points with respect to the particular target response matrix B. We will also discuss B-agnostic algorithms in Section 4.2 (Theorem 10) and we will present matching lower bounds in Section 5."
    }, {
      "heading" : "4.1 Proofs of Theorems 6 and 7",
      "text" : "We will make heavy use of facts from Section A. We start with a few simple lemmas.\nLemma 8. Let E = AXopt −B be the regression residual. Then, rank(E) ≤ min{ω, n− k}.\nProof. Using our notation, AXopt − B = ( In −UAUTA ) B = U⊥ A ( U⊥ A )T B. To conclude notice that rank(XY) ≤ min{rank(X), rank(Y)}.\nWe now give our main tool for obtaining approximation guarantees for coreset regression. The proof is deferred to the appendix.\nLemma 9. Assume that the rank of the matrix DSUA ∈ Rr×k is equal to k (i.e., the matrix has full rank). Then, for ξ = 2,F,\n‖AX̃opt −B‖ 2 ξ ≤ ‖AXopt −B‖2ξ + ‖(DSUA)+DS (AXopt −B) ‖2ξ .\nThis lemma provides a framework for coreset construction: all we need are sampling and rescaling matrices S and D, such that rank(DSUA) = k and ‖ (DSUA)+DS (AXopt −B) ‖2ξ is small. The final ingredients for the proofs of Theorems 6 and 7 are two matrix sparsification results, Lemmas 16 and 17 in the Appendix.\nProof. (of Theorem 6) Theorem 6 follows from Lemmas 9 and 16. First, compute the SVD of A to obtain UA, and let E = AXopt − B = UAUTAB − B. Next, run the algorithm of Lemma 16 to obtain [Ω,S] = MultipleSpectralSampling (UA,E, r). This algorithm will run in time TSVD (E) + O ( rn ( k2 + ρ2 E ))\n, where k is the rank of UA and A. The total running time of the algorithm is T (UA) + TSVD (E) + O ( rn (\nk2 + ρ2 E\n)) = T (UA) +O ( rn ( k2 + ω2 ))\n. Lemma 16 guarantees that D and S satisfy the rank assumption of Lemma 9. To conclude the proof,\nwe bound the second term of Lemma 9, using the bounds of Lemma 16 and ρE ≤ min{ω, n− k} ≤ ω:\n‖(DSUA)+DS (AXopt −B) ‖22 ≤ ‖ (DSUA)+ ‖22‖DS (AXopt −B) ‖22 ≤ ( 1 + √ ω/r )2 ( 1− √ k/r )−2\n‖AXopt −B‖22.\nProof. (of Theorem 7) Similar to Theorem 6, using Lemma 17 instead of Lemma 16."
    }, {
      "heading" : "4.2 B-Agnostic Coreset Construction",
      "text" : "All the coreset construction algorithms that we presented so far carefully construct the coreset using knowledge of the response vector. If the algorithm does not need knowledge of B to construct the coreset, and yet can provide an approximation guarantee for every B, then the algorithm is B-agnostic. A Bagnostic coreset construction algorithm is appealing because the coreset, as specified by the sampling and rescaling matrices S and D, can be computed off-line and applied to any B. We briefly digress to show how our methods can be extended to develop B-agnostic coreset constructions.\nTheorem 10 (B-Agnostic Coresets). Given a matrix A ∈ Rn×d with rank exactly k and a matrix B ∈ R n×ω, there exists an algorithm to deterministically construct a sampling matrix S and a rescaling matrix D such that for any B ∈ Rn×ω, the matrix X̃opt that solves the problem of eqn. (2) satisfies (for any r such that k < r ≤ n):\n‖AX̃opt −B‖2ξ ≤ ‖AXopt −B‖2ξ + ( 1 + √ n/r\n1− √ k/r\n)2\n‖AXopt −B‖2ξ .\nThe running time of the proposed algorithm is T (UA) + O ( rnk2 )\n, where T (UA) is the time needed to compute the left singular vectors of A.\nProof. The proof is similar to the proof of Theorem 6, except we now construct the sampling and rescaling matrices as [D,S] = MultipleSpectralSampling (UA, In, r). To bound the second term in Lemma 9, we use\n‖ (DSUA)+DS (AXopt −B) ‖2ξ = ‖ (DSUA)+DSIn (AXopt −B) ‖2ξ ≤ ‖ (DSUA)+ ‖22‖DSIn‖22‖ (AXopt −B) ‖2ξ ,\nand the bounds of Lemma 16.\nThe above bound decreases with r and holds for any B, guaranteeing a constant-factor approximation with a constant fraction of the data. The approximation ratio is O(n/r), which seems quite weak. In the next section, we show that this result is tight."
    }, {
      "heading" : "5 Lower Bounds on Coreset Size",
      "text" : "We have just seen a B-agnostic coreset construction algorithm with a rather weak worst case guarantee of O(n/r) approximation error. We will now show that no deterministic B-agnostic coreset construction algorithm can guarantee a better error (Theorem 11).\n(Drineas et al., 2008) provides anotherB-agnostic coreset construction algorithm with r = O(k log(k)/ǫ2). For a fixed B, the method in (Drineas et al., 2008) delivers a probabilistic bound on the approximation error. However, there are target matrices B for which the bound fails by an arbitrarily large amount. The probabilistic algorithms get away with this by brushing all these (possibly large) errors into a low probability event, with respect to random choices made in the algorithm. So, in some sense, these algorithms are not B-agnostic, in that they do not construct a coreset which works well for all B with some (say) constant probability. Nevertheless, the fact that they give a constant probability of success for a fixed but unknown B makes these algorithms interesting and useful. We will give a lower bound on the approximation ratio of such algorithms as well, for a given probability of success (Theorem 12). Finally, we will give lower bounds on the size of the coreset for the general (non-agnostic) multiple regression setting (Theorems 13 and 14)."
    }, {
      "heading" : "5.1 An Impossibility Result for B-Agnostic Coreset Construction",
      "text" : "We first present the lower bound for simple regression. Recall that a coreset construction algorithm is b-agnostic if it constructs a coreset without knowledge of b, and then provides an approximation guarantee for every b. We show that no coreset can work for every b; therefore a b-agnostic coreset will be bad for some vector b. In fact, there exists a matrix A such that every coreset has an associated “bad” b.\nTheorem 11 (Deterministic b-Agnostic coresets). There exists a matrix A ∈ Rn×d such that for every coreset C ∈ Rr×d of size r ≤ n, there exists b ∈ Rn (depending on C) for which\n‖Ax̃opt − b‖22 ≥ n\nr ‖Axopt − b‖22.\nProof. Let A be any matrix with orthonormal columns whose first column is 1n/ √ n, and consider any\ncoreset C of size r. Let b = 1 C / √ n− r, where 1 C is the n-vector of 1’s except at the coreset locations. So for the coreset regression, bc = 0, and so x̃opt = 0d×1. Therefore, ‖Ax̃opt − b‖22 = ‖b‖22 = 1. Let PA project onto the columns of A and PA(1) project onto the first column of A. The following sequence establishes the result:\n‖Axopt − b‖22 = ‖(I −PA)b‖22 ≤ ‖(I −PA(1))b‖22 = r\nn\nWe now consider randomized algorithms that construct a coreset without looking at b (e.g. (Drineas et al., 2008)). These algorithms work for any fixed (but unknown) b, and deliver a probabilistic approximation guarantee for any single fixed b; in some sense they are b-agnostic. By the previous discussion, the returned coreset must fail for some b, i.e., the probabilistic guarantee does not hold for all b) and, when it fails, it could do so with very bad error. We will now present a lower bound on the approximation accuracy of such existing randomized algorithms for coreset construction, even for a single b.\nFirst, we define randomized coreset construction algorithms. Let C1,C2, . . . ,C(nr ) be the\n(\nn r\n)\ndifferent\ncoresets of size r. A randomized algorithm assigns probabilities p1, p2, . . . , p(nr ) to each coreset, and selects one according to these probabilities. The probabilities pi may depend on A. The algorithm is b-agnostic if the probabilities pi do not depend on b.\nTheorem 12 (Probabilistic b-Agnostic Coresets). For any randomized b-agnostic coreset construction algorithm, and any integer 0 ≤ ℓ ≤ n − r, there exists A ∈ Rn×d and b ∈ Rn, such that, with probability at least\n(n−r ℓ ) / (n ℓ ) ,\n‖Ax̃opt − b‖22 ≥ n\nn− ℓ‖Axopt − b‖ 2 2.\nProof. Let A be any matrix with orthonormal columns whose first column is 1n/ √ n, as in the proof of Theorem 11. Let T be a set of size ℓ ≤ n − r. The neighborhood N(T) is the set of coresets that have non-empty intersection with T. Every coreset appears in (\nn ℓ\n) − ( n−r ℓ )\nsuch neighborhoods (the number of sets of size ℓ which intersect with a coreset of size r). Let Pr [T] be the probability that the coreset selected by the algorithm is in N (T); then, Pr [T] = ∑\nCi∈N(T) Pr [Ci]. Therefore,\n∑\nT\nPr [T] = ∑\nT\n∑\nCi∈N(T)\nPr [Ci] = (n\nℓ\n) − ( n− r ℓ ) ,\nwhere the last equality follows because each coreset appears exactly (n ℓ ) − (n−r ℓ )\ntimes in the summation and ∑\niPr [Ci] = 1. Thus, there is at least one set T ∗ for which\nPr [C ∈ N(T∗)] ≤ (n ℓ ) − (n−r ℓ ) (\nn l\n) = 1− (n−r ℓ ) (\nn r\n) .\nSo with probability at least (n−r\nℓ\n) / (n ℓ ) , the selected coreset does not intersect withT∗. Select b = 1T∗ (the\nunit vector which is 1/ √ ℓ at the indices corresponding to T∗). Now, with probability at least\n(n−r ℓ ) / (n ℓ )\n, x̃opt = 0, and the analysis in the proof of Theorem 11 shows that ‖Ax̃opt − b‖22 ≥ nn−ℓ‖Axopt − b‖22.\nBy Stirling’s formula, after some algebra, the probability (n−r\nℓ\n) / (n ℓ ) is asymptotic to e−2rℓ/n. Setting ℓ = Θ(n/r) gives a success probability that is Θ(1) (a constant), then the approximation ratio cannot be better than 1 + Ω(1/r). With regard to high probability (approaching one) algorithms, consider ℓ = n log n/2r to conclude that if the success probability is at least 1 − 1/n, the approximation ratio is no better than 1 + log(n)/(2r − log n)."
    }, {
      "heading" : "5.2 Lower Bounds for Non-Agnostic Multiple Regression",
      "text" : "For both the spectral and the Frobenius norm, we now consider non-agnostic unconstrained multiple regression, and give lower bounds for coresets of size r > d = rank(A) (for simplicity, we set rank(A) = d). The results are presented in Theorems 13 and 14.\nTheorem 13 (Spectral Norm). There exists A ∈ Rn×d and B ∈ Rn×ω such that for any r > d and any sampling and rescaling matrices S ∈ Rr×n and D ∈ Rr×r, the solution to the coreset regression X̃opt = (DSA) +DSB ∈ Rd×ω satisfies\n‖AX̃opt −B‖ 2 2 ≥ w\nr + 1 ‖AXopt −B‖22.\nProof. First, we need some results from (Boutsidis et al., 2011). Boutsidis et al. (2011) exhibits a matrix B ∈ R(ω−1)×ω such that for any sampling matrix S ∈ Rr×(ω−1) and rescaling matrix D ∈ Rr×r, with C = DSB (rescaled sampled coreset of B),\n‖B−ΠC,k(B)‖22 ≥ ω\nr + 1 ‖B−Bk‖22,\nwhere ΠC,k(B) is the best rank-k approximation to B whose rows lie in the span of all the rows in C (the row-space of C); and, Bk is the best rank-k approximation to B (which could be computed via the truncated SVD of B). Actually, D is irrelevant here because the row-space of SB is not changed by a positive diagonal rescaling matrix D.\nSince ΠC,k(B) is the best rank-k approximation to B in the row-space of C, it follows that ‖B − ΠC,k(B)‖22 ≤ ‖B−XC‖22 for any X∈ R(ω−1)×r with rank at most k (because XC will have rank at most k and is in the row space of C). Set X = UB,k(DSUB,k)\n+, where UB,k ∈ R(ω−1)×k has k columns which are the top-k left singular vectors of B. It is easy to verify that X has the correct dimensions and rank at most k. Since C = DSB, we have that\n‖B−ΠC,k(B)‖22 ≤ ‖B−UB,k(DSUB,k)+DSB‖22.\nWe now construct the regression problem. Let A = UB,d ∈ R(ω−1)×d (i.e., we choose k = d in the above discussion and n = ω− 1. Suppose a coreset construction algorithm gives sampling and rescaling matrices S and D, for a coreset of size r. So, the coreset regression is with Ã = C = DSA and B̃ = DSB. The solution to the coreset regression is\nX̃opt = Ã +B̃ = C+DSB = (DSA)+DSB = (DSUB,d) +DSB,\nwhich means that\n‖AX̃opt −B‖ 2 2 = ‖UB,d(DSUB,d) +DSB−B‖22 ≥ ‖ΠC,d(B)−B‖22 ≥\nω\nr + 1 ‖Bd −B‖22.\nTo conclude the proof, observe that Bd = UB,dU T B,dB = AA +B = AXopt.\nTheorem 14 (Frobenius Norm). There exists A ∈ Rn×d and B ∈ Rn×ω such that for any r > d and any sampling and rescaling matrices S ∈ Rn×r and D ∈ Rr×r, the solution to the coreset regression X̃opt = (DSA) +DSB ∈ Rd×ω satisfies\n‖AX̃opt −B‖2F ≥ ( 1 + d\nr\n)\n‖AXopt −B‖2F.\nProof. The proof of this Frobenius norm lower bound follows the same argument as in the proof of Theorem 13, with ω/(r+1) replaced by 1+d/r, providing that there is a matrix B for which ‖B−ΠC,d(B)‖2F ≥ (1+d/r)‖B−Bd‖2F. Indeed, the construction of such a matrix was presented in (Boutsidis et al., 2011)."
    }, {
      "heading" : "6 Open problems",
      "text" : "Can one determine the minimum size of a coreset that provides a (1+ǫ) relative-error guarantee for simple linear regression? We conjecture that Ω (k/ǫ) is a lower bound, which will make our results almost tight. Certainly, rich coresets of size exactly k cannot be guaranteed: consider two data points (1, 1), (−1, 1). The optimal regression is 0; however any coreset of size one will give non-zero regression. Is it possible to get strong guarantees on small corsets for other learning problems?"
    }, {
      "heading" : "A Linear Algebra Background",
      "text" : "The Singular Value Decomposition (SVD) of a matrix A ∈ Rn×d of rank k is a decomposition A = UAΣAV T A . The singular values σ1 ≥ σ2 ≥ · · · ≥ σk > 0 are contained in the diagonal matrix ΣA ∈ Rk×k; UA ∈ Rn×k contains the left singular vectors of A; and VA ∈ Rd×k contains the right singular vectors. The SVD of A can be computed in deterministic O(ndmin{n, d}) time.\nThe Moore-Penrose pseudo-inverse of A is equal to A+ = VAΣ −1 A UT A . Given an orthonormal matrix UA ∈ Rn×k, the perpendicular matrix U⊥A ∈ Rn×(n−k) to UA satisfies: (U⊥A)TU⊥A = In−k, UTAU⊥A = 0k×(n−k), and UAU T A + U⊥ A (U⊥ A )T = In. All the singular values of both UA and U ⊥ A are equal to one. Given UA, U ⊥ A can be computed in deterministic O ( n (n− k)2 ) time via the QR factorization.\nWe remind the reader of the Frobenius and spectral matrix norms: ‖A‖2F = ∑ i,j A 2 ij = ∑k i=1 σ 2 i and ‖A‖22 = σ21. We will sometimes use the notation ‖A‖ξ to indicate that an expression holds for both ξ = 2 or ξ = F. For any two matrices X and Y, ‖X‖2 ≤ ‖X‖F ≤ √\nrank(X)‖X‖2; ‖XY‖F ≤ ‖X‖F‖Y‖2; ‖XY‖F ≤ ‖X‖2‖Y‖F. These are stronger variants of the standard submultiplicativity property ‖XY‖ξ ≤ ‖X‖ξ‖Y‖ξ and we will refer to them as spectral submultiplicativity. It follows that, if Q is orthonormal, then ‖QX‖ξ ≤ ‖X‖ξ and ‖YQT‖ξ ≤ ‖Y‖ξ. Finally,\nLemma 15 (matrix-Pythagoras). Let X and Y be two n× d matrices. If XYT = 0n×n or XTY = 0d×d, then ‖X+Y‖2ξ ≤ ‖X‖2ξ + ‖Y‖2ξ .\nA.1 Sparsification Results\nWe now state two recent results on matrix sparsification ((Boutsidis, 2011, Lemmas 71 and 72, p. 132),(Boutsidis et al., 2011)) using our notation.\nLemma 16 (Spectral Sparsification). Let Y ∈ Rn×ℓ1 and Ψ ∈ Rn×ℓ2 with respective ranks ρY, and ρΨ. Given r > ρY, there exists a deterministic algorithm that runs in time TSVD (Y)+TSVD (Ψ)+O(rn(ρ 2 Y + ρ2Ψ)) and constructs sampling and rescaling matrices S ∈ Rr×n, D ∈ Rr×r satisfying:\nrank (DSY) = rank (Y) ; ‖ (DSY)+ ‖2 < 1\n1− √ ρY/r ‖Y+‖2; ‖DSΨ‖2 <\n(\n1 +\n√\nρΨ r\n)\n‖Ψ‖2.\nIf Ψ = In, the running time of the algorithm reduces to TSV D (Y) + O ( rnρ2 Y )\n. We write [D,S] = MultipleSpectralSampling (Y,Ψ, r) to denote such a deterministic procedure.\nLemma 17 (Spectral-Frobenius Sparsification). Let Y ∈ Rn×ℓ1 and Ψ ∈ Rn×ℓ2 with respective ranks ρY, and ρΨ. Given r > ρY, there exists a deterministic algorithm that runs in time TSVD(Y)+O(rnρ 2 Y + ℓ2n) and constructs sampling and rescaling matrices S ∈ Rr×n, D ∈ Rr×r satisfying:\nrank (DSY) = rank (Y) ; ‖ (DSY)+ ‖2 < 1\n1− √ ρY/r ‖Y+‖2; ‖DSΨ‖F ≤ ‖Ψ‖F.\nIf Ψ = In, the running time of the algorithm reduces to TSV D (Y) + O ( rnρ2 Y )\n. We write [D,S] = MultipleFrobeniusSampling (Y,Ψ, r) to denote such a deterministic procedure."
    }, {
      "heading" : "B Algorithms",
      "text" : "Input: A ∈ Rn×d of rank k, b ∈ Rn, and r > k + 1. Output: sampling matrix S and rescaling matrix D.\n1: Compute the SVD of Y = [A,b]. Let Y = UΣVT, where U ∈ Rn×ℓ, Σ ∈ Rℓ×ℓ and V ∈ Rd×ℓ, with ℓ ≤ k + 1 (the rank of Y). 2: Return [Ω,S] = SimpleSampling(U, r) (see Lemma 2)\nAlgorithm 1: Deterministic coreset construction for constrained linear regression.\nInput: A ∈ Rn×d of rank k, B ∈ Rn×ω, and r > k. Output: sampling matrix S and rescaling matrix D.\n1: Compute the SVD of A: A = UAΣAV T A , where UA ∈ Rn×k, ΣA ∈ Rk×k, and VA ∈ Rd×k;\ncompute E = UAU T A B−B.\n2: return [S,D] = MultipleSpectralSampling(UA,E, r) (see Lemma 16)\nAlgorithm 2: Deterministic coresets for multiple regression in spectral norm.\nInput: A ∈ Rn×d of rank k, B ∈ Rn×ω, and r > k. Output: sampling matrix S and rescaling matrix D.\n1: Compute the SVD of A: A = UAΣAV T A , where UA ∈ Rn×k, ΣA ∈ Rk×k, and VA ∈ Rd×k;\ncompute E = UAU T A B−B.\n2: return [S,D] = MultipleFrobeniusSampling(UA,E, r) (see Lemma 17)\nAlgorithm 3: Deterministic coresets for multiple regression in Frobenius norm."
    }, {
      "heading" : "C Technical Proofs",
      "text" : "Proof. (Theorem 4) We first construct D and S via Theorem 1 applied to A and bavg . The running time is O (nω) (the time needed to compute bavg) plus the running time of Theorem 1. The result is immediate from the following derivation:\n‖AX̃opt −B‖ 2\nF\n(a) = ω‖Ax̃opt − bavg‖2 +\nω ∑\ni=1\n‖bavg −B(i)‖ 2\n(b) ≤ ( 1 +O ( √ k/r ))2 ω‖Axopt − bavg‖2 + ω ∑\ni=1\n‖bavg −B(i)‖ 2\n≤ ( 1 +O ( √ k/r ))2\n(\nω‖Axopt − bavg‖2 + ω ∑\ni=1\n‖bavg −B(i)‖ 2\n)\n(a) =\n( 1 +O ( √ k/r ))2\n‖AXopt −B‖2F.\n(a) follows by Lemma 3; (b) follows because x̃opt is the output of a coreset regression as in Theorem 1. Finally, r > k + 1 implies that ( 1 +O ( √ k/r ))2 = 1 +O ( √ k/r ) .\nProof. (Lemma 9) To simplify notation, let W = DS. Using the SVD of A, A = UAΣAV T A , we get:\n‖B−AX̃opt‖ 2 ξ = ‖B−UAΣAVTA(WUAΣAVTA)+WB‖ 2 ξ = ‖B−UA(WUA)+WB‖ 2 ξ ,\nwhere the last equality follows from properties of the pseudo-inverse and the fact that WUA is a full-rank matrix. Using B = (\nUAU T A +U⊥ A\n(\nU⊥ A\n)T )\nB, we get\n‖B−AX̃opt‖ 2 ξ = ‖B−UA (WUA) +W\n(\nUAU T A +U ⊥ A\n(\nU⊥A\n) T ) B‖ 2\nξ\n= ‖B−UA (WUA)+WUAUTAB+UA (WUA)+WU⊥A ( U⊥A ) T B‖ 2\nξ\n(a) = ‖U⊥A(U⊥A)TB+UA(WUA)+WU⊥A(U⊥A)TB‖2ξ (b) = ‖U⊥A(U⊥A)TB‖2ξ + ‖UA(WUA)+WU⊥A(U⊥A)TB‖ξ.\n(a) follows from the assumption that the rank of WUA is equal to k and thus (WUA) +WUA = Ik and (b) follows by matrix-Pythagoras (Lemma 15). To conclude, we use spectral submultiplicativity on the second term and the fact that U⊥ A ( U⊥ A )T B = AXopt −B."
    } ],
    "references" : [ {
      "title" : "Numerical Methods for Least Squares Problems",
      "author" : [ "A. Björck" ],
      "venue" : "Twice-ramanujan sparsifiers. In Proc. 41st Annual ACM",
      "citeRegEx" : "Björck.,? \\Q1996\\E",
      "shortCiteRegEx" : "Björck.",
      "year" : 1996
    } ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "A rich coreset is a subset of the data which contains nearly all the essential information. We give deterministic, low order polynomial-time algorithms to construct rich coresets for simple and multiple response linear regression, together with lower bounds indicating that there is not much room for improvement upon our results.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}