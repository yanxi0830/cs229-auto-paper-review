{
  "name" : "1008.5209.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Network Flow Algorithms for Structured Sparsity",
    "authors" : [ "Julien Mairal", "Francis Bach", "Rodolphe Jenatton", "Guillaume Obozinski" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n00 8.\n52 09\nv1 [\ncs .L\nG ]\n3 1\nA ug\n2 01\n0\nappor t de r ech er ch e\nIS S\nN 02\n49 -6\n39 9\nIS R\nN IN\nR IA\n/R R\n-- 73\n72 --\nF R\n+ E\nN G\nVision, Perception and Multimedia Understanding"
    }, {
      "heading" : "INSTITUT NATIONAL DE RECHERCHE EN INFORMATIQUE ET EN AUTOMATIQUE",
      "text" : ""
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity",
      "text" : ""
    }, {
      "heading" : "Julien Mairal — Rodolphe Jenatton — Guillaume Obozinski — Francis Bach",
      "text" : "N° 7372\nAugust 2010"
    }, {
      "heading" : "Centre de recherche INRIA Paris – Rocquencourt Domaine de Voluceau, Rocquencourt, BP 105, 78153 Le Chesnay Cedex",
      "text" : "Téléphone : +33 1 39 63 55 11 — Télécopie : +33 1 39 63 53 30"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity",
      "text" : ""
    }, {
      "heading" : "Julien Mairal∗† , Rodolphe Jenatton∗† , Guillaume Obozinski† , Francis Bach†",
      "text" : "Theme : Vision, Perception and Multimedia Understanding Perception, Cognition, Interaction\nÉquipe-Projet Willow\nRapport de recherche n° 7372 — August 2010 — 23 pages\nAbstract: We consider a class of learning problems that involve a structured sparsity-inducing norm defined as the sum of ℓ∞-norms over groups of variables. Whereas a lot of effort has been put in developing fast optimization methods when the groups are disjoint or embedded in a specific hierarchical structure, we address here the case of general overlapping groups. To this end, we show that the corresponding optimization problem is related to network flow optimization. More precisely, the proximal problem associated with the norm we consider is dual to a quadratic min-cost flow problem. We propose an efficient procedure which computes its solution exactly in polynomial time. Our algorithm scales up to millions of variables, and opens up a whole new range of applications for structured sparse models. We present several experiments on image and video data, demonstrating the applicability and scalability of our approach for various problems.\nKey-words: network flow optimization, convex optimization, sparse methods, proximal algorithms\n∗ Equal contribution. † INRIA - WILLOW Project, Laboratoire d’Informatique de l’Ecole Normale Supérieure (INRIA/ENS/CNRS\nUMR 8548). 23, avenue d’Italie, 75214 Paris. France"
    }, {
      "heading" : "Algorithmes de Flots pour Parcimonie Structurée",
      "text" : "Résumé : Nous considérons une classe de problèmes d’apprentissage régularisés par une norme induisant de la parcimonie structurée, définie comme une somme de normes ℓ∞ sur des groupes de variables. Alors que de nombreux efforts ont étés mis pour développer des algorithmes d’optimisation rapides lorsque les groupes sont disjoints ou structurés hiérarchiquement, nous nous intéressons au cas général de groupes avec recouvrement. Nous montrons que le problème d’optimisation correspondant est lié à l’optimisation de flots sur un réseau. Plus précisément, l’opérateur proximal associé à la norme que nous considérons est dual à la minimisation d’un coût quadratique de flot sur un graphe particulier. Nous proposons une procédure efficace qui calcule cette solution en un temps polynomial. Notre algorithme peut traiter de larges problèmes, comportant des millions de variables, et ouvre de nouveaux champs d’applications pour les modèles parcimonieux structurés. Nous présentons diverses expériences sur des données d’images et de vidéos, qui démontrent l’utilité et l’efficacité de notre approche pour résoudre de nombreux problèmes.\nMots-clés : optimisation de flots, optimisation convexe, méthodes parcimonieuses, algorithmes proximaux"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 3",
      "text" : ""
    }, {
      "heading" : "1 Introduction",
      "text" : "Sparse linear models have become a popular framework for dealing with various unsupervised and supervised tasks in machine learning and signal processing. In such models, linear combinations of small sets of variables are selected to describe the data. Regularization by the ℓ1-norm has emerged as a powerful tool for addressing this combinatorial variable selection problem, relying on both a well-developed theory (see [1] and references therein) and efficient algorithms [2, 3, 4].\nThe ℓ1-norm primarily encourages sparse solutions, regardless of the potential structural relationships (e.g., spatial, temporal or hierarchical) existing between the variables. Much effort has recently been devoted to designing sparsity-inducing regularizations capable of encoding higherorder information about allowed patterns of non-zero coefficients [5, 6, 7, 8, 9], with successful applications in bioinformatics [6, 10], topic modeling [11] and computer vision [8].\nBy considering sums of norms of appropriate subsets, or groups, of variables, these regularizations control the sparsity patterns of the solutions. The underlying optimization problem is usually difficult, in part because it involves nonsmooth components. Proximal methods have proven to be effective in this context, essentially because of their fast convergence rates and their ability to deal with large problems [3, 4]. While the settings where the penalized groups of variables do not overlap [12] or are embedded in a tree-shaped hierarchy [11] have already been studied, sparsityinducing regularizations of general overlapping groups have, to the best of our knowledge, never been considered within the proximal method framework.\nThis paper makes the following contributions:\n• It shows that the proximal operator associated with the structured norm we consider can be computed by solving a quadratic min-cost flow problem, thereby establishing a connection with the network flow optimization literature.\n• It presents a fast and scalable procedure for solving a large class of structured sparse regularized problems, which, to the best of our knowledge, have not been addressed efficiently before.\n• It shows that the dual norm of the sparsity-inducing norm we consider can also be evaluated efficiently, which enables us to compute duality gaps for the corresponding optimization problems.\n• It demonstrates that our method is relevant for various applications, from video background subtraction to estimation of hierarchical structures for dictionary learning of natural image patches."
    }, {
      "heading" : "2 Structured Sparse Models",
      "text" : "We consider in this paper convex optimization problems of the form\nmin w∈Rp f(w) + λΩ(w), (1)\nwhere f : Rp → R is a convex differentiable function and Ω : Rp → R is a convex, nonsmooth, sparsity-inducing regularization function. When one knows a priori that the solutions of this learning problem only have a few non-zero coefficients, Ω is often chosen to be the ℓ1-norm, leading for instance to the Lasso [13]. When these coefficients are organized in groups, a penalty encoding explicitly this prior knowledge can improve the prediction performance and/or interpretability of the learned models [12, 14, 15, 16]. Such a penalty might for example take the form\nΩ(w) , ∑\ng∈G\nηg max j∈g\n|wj | = ∑\ng∈G\nηg‖wg‖∞, (2)\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 4",
      "text" : "where G is a set of groups of indices, wj denotes the j-th coordinate of w for j in [1; p] , {1, . . . , p}, the vector wg in R|g| represents the coefficients of w indexed by g in G, and the scalars ηg are positive weights. A sum of ℓ2-norms is also used in the literature [7], but the ℓ∞-norm is piecewise linear, a property that we take advantage of in this paper. Note that when G is the set of singletons of [1; p], we get back the ℓ1-norm.\nIf G is a more general partition of [1; p], variables are selected in groups rather than individually. When the groups overlap, Ω is still a norm and sets groups of variables to zero together [5]. The latter setting has first been considered for hierarchies [7, 10, 17], and then extended to general group structures [5].1 Solving Eq. (1) in this context becomes challenging and is the topic of this paper. Following [11] who tackled the case of hierarchical groups, we propose to approach this problem with proximal methods, which we now introduce."
    }, {
      "heading" : "2.1 Proximal Methods",
      "text" : "In a nutshell, proximal methods can be seen as a natural extension of gradient-based techniques, and they are well suited to minimizing the sum f + λΩ of two convex terms, a smooth function f —continuously differentiable with Lipschitz-continuous gradient— and a potentially non-smooth function λΩ (see [18] and references therein). At each iteration, the function f is linearized at the current estimate w0 and the so-called proximal problem has to be solved:\nmin w∈Rp\nf(w0) + (w −w0) ⊤∇f(w0) + λΩ(w) +\nL 2 ‖w−w0‖ 2 2.\nThe quadratic term keeps the solution in a neighborhood where the current linear approximation holds, and L > 0 is an upper bound on the Lipschitz constant of ∇f . This problem can be rewritten as\nmin w∈Rp\n1 2 ‖u−w‖22 + λ ′Ω(w), (3)\nwith λ′ , λ/L, and u , w0 − 1L∇f(w0). We call proximal operator associated with the regularization λ′Ω the function that maps a vector u in Rp onto the (unique, by strong convexity) solution w⋆ of Eq. (3). Simple proximal method use w⋆ as the next iterate, but accelerated variants [3, 4] are also based on the proximal operator and require to solve problem (3) exactly and efficiently to enjoy their fast convergence rates. Note that when Ω is the ℓ1-norm, the solution of Eq. (3) is obtained by a soft-thresholding [18].\nThe approach we develop in the rest of this paper extends [11] to the case of general overlapping groups when Ω is a weighted sum of ℓ∞-norms, broadening the application of these regularizations to a wider spectrum of problems.2"
    }, {
      "heading" : "3 A Quadratic Min-Cost Flow Formulation",
      "text" : "In this section, we show that a convex dual of problem (3) for general overlapping groups G can be reformulated as a quadratic min-cost flow problem. We propose an efficient algorithm to solve it exactly, as well as a related algorithm to compute the dual norm of Ω. We start by considering the dual formulation to problem (3) introduced in [11], for the case where Ω is a sum of ℓ∞-norms:\n1Note that other types of structured sparse models have also been introduced, either through a different norm [6], or through non-convex criteria [8, 9].\n2For hierarchies, the approach of [11] applies also to the case of where Ω is a weighted sum of ℓ2-norms.\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 5",
      "text" : "Lemma 1 (Dual of the proximal problem [11]) Given u in Rp, consider the problem\nmin ξ∈Rp×|G|\n1 2 ‖u− ∑\ng∈G\nξg‖22 s.t. ∀g ∈ G, ‖ξ g‖1 ≤ ληg and ξ g j = 0 if j /∈ g, (4)\nwhere ξ = (ξg)g∈G is in R p×|G|, and ξgj denotes the j-th coordinate of the vector ξ g. Then, every solution ξ⋆=(ξ⋆g)g∈G of Eq. (4) satisfies w ⋆=u− ∑ g∈G ξ ⋆g, where w⋆ is the solution of Eq. (3).\nWithout loss of generality,3 we assume from now on that the scalars uj are all non-negative, and we constrain the entries of ξ to be non-negative. We now introduce a graph modeling of problem (4)."
    }, {
      "heading" : "3.1 Graph Model",
      "text" : "Let G be a directed graph G = (V,E, s, t), where V is a set of vertices, E ⊆ V × V a set of arcs, s a source, and t a sink. Let c and c′ be two functions on the arcs, c : E → R and c′ : E → R+, where c is a cost function and c′ is a non-negative capacity function. A flow is a non-negative function on arcs that satisfies capacity constraints on all arcs (the value of the flow on an arc is less than or equal to the arc capacity) and conservation constraints on all vertices (the sum of incoming flows at a vertex is equal to the sum of outgoing flows) except for the source and the sink.\nWe introduce a canonical graph G associated with our optimization problem, and uniquely characterized by the following construction: (i) V is the union of two sets of vertices Vu and Vgr , where Vu contains exactly one vertex for each index j in [1; p], and Vgr contains exactly one vertex for each group g in G. We thus have |V | = |G|+ p. For simplicity, we identify groups and indices with the vertices of the graph. (ii) For every group g in G, E contains an arc (s, g). These arcs have capacity ληg and zero cost. (iii) For every group g in G, and every index j in g, E contains an arc (g, j) with zero cost and infinite capacity. We denote by ξgj the flow on this arc. (iv) For every index j in [1; p], E contains an arc (j, t) with infinite capacity and a cost cj, 12 (uj − ξ̄j) 2, where ξ̄j is the flow on (j, t). Note that by flow conservation, we necessarily have ξ̄j= ∑ g∈G ξ g j .\nExamples of canonical graphs are given in Figures 1(a)-(c). The flows ξgj associated with G can now be identified with the variables of problem (4): indeed, the sum of the costs on the edges leading to the sink is equal to the objective function of (4), while the capacities of the arcs (s, g) match the constraints on each group. This shows that finding a flow minimizing the sum of the costs on such a graph is equivalent to solving problem (4).\nWhen some groups are included in others, the canonical graph can be simplified to yield a graph with a smaller number of edges. Specifically, if h and g are groups with h ⊂ g, the edges (g, j) for j ∈ h carrying a flow ξgj can be removed and replaced by a single edge (g, h) of infinite capacity and zero cost, carrying the flow ∑\nj∈h ξ g j . This simplification is illustrated in Figure 1(d), with a\ngraph equivalent to the one of Figure 1(c). This does not change the optimal value of ξ̄ ⋆ , which is the quantity of interest for computing the optimal primal variable w⋆. We present in Appendix A a formal definition of equivalent graphs. These simplifications are useful in practice, since they reduce the number of edges in the graph and improve the speed of the algorithms we are now going to present.\n3 Let ξ⋆ denote a solution of Eq. (4). Optimality conditions of Eq. (4) derived in [11] show that for all j in [1; p], the signs of the non-zero coefficients ξ⋆g\nj for g in G are the same as the signs of the entries uj . To solve Eq. (4), one\ncan therefore flip the signs of the negative variables uj , then solve the modified dual formulation (with non-negative variables), which gives the magnitude of the entries ξ⋆g\nj (the signs of these being known).\nRR n° 7372\nNetwork Flow Algorithms for Structured Sparsity 6\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 7",
      "text" : ""
    }, {
      "heading" : "3.2 Computation of the Proximal Operator",
      "text" : "Quadratic min-cost flow problems have been well studied in the operations research literature [19]. One of the simplest cases, where G contains a single group g as in Figure 1(a), can be solved by an orthogonal projection on the ℓ1-ball of radius ληg. It has been shown, both in machine learning [20] and operations research [19, 21], that such a projection can be done in O(p) operations. When the group structure is a tree as in Figure 1(d), strategies developed in the two communities are also similar [11, 19], and solve the problem in O(pd) operations, where d is the depth of the tree.\nThe general case of overlapping groups is more difficult. Hochbaum and Hong have shown in [19] that quadratic min-cost flow problems can be reduced to a specific parametric max-flow problem, for which an efficient algorithm exists [22].4 While this approach could be used to solve Eq. (4), it ignores the fact that our graphs have non-zero costs only on edges leading to the sink. To take advantage of this specificity, we propose the dedicated Algorithm 1. Our method clearly shares some similarities with a simplified version of [22] presented in [23], namely a divide and conquer strategy. Nonetheless, we performed an empirical comparison described in Appendix D, which shows that our dedicated algorithm has significantly better performance in practice. Informally,\nAlgorithm 1 Computation of the proximal operator for overlapping groups. 1: Inputs: u ∈ Rp, a set of groups G, positive weights (ηg)g∈G , and λ (regularization parameter).\n2: Build the initial graph G0 = (V0, E0, s, t) as explained in Section 3.2. 3: Compute the optimal flow: ξ̄ ← computeFlow(V0, E0). 4: Return: w = u− ξ̄ (optimal solution of the proximal problem).\nFunction computeFlow(V = Vu ∪ Vgr, E)\n1: Projection step: γ ← argminγ ∑ j∈Vu 1 2 (uj − γj) 2 s.t. ∑ j∈Vu γj ≤ λ ∑ g∈Vgr ηg. 2: For all nodes j in Vu, set γj to be the capacity of the arc (j, t). 3: Max-flow step: Update (ξ̄j)j∈Vu by computing a max-flow on the graph (V,E, s, t). 4: if ∃ j ∈ Vu s.t. ξ̄j 6= γj then 5: Denote by (s, V +) and (V −, t) the two disjoint subsets of (V, s, t) separated by the minimum\n(s, t)-cut of the graph, and remove the arcs between V + and V −. Call E+ and E− the two remaining disjoint subsets of E corresponding to V + and V −.\n6: (ξ̄j)j∈V +u ← computeFlow(V +, E+). 7: (ξ̄j)j∈V −u ← computeFlow(V −, E−). 8: end if 9: Return: (ξ̄j)j∈Vu .\ncomputeFlow(V0, E0) returns the optimal flow vector ξ̄, proceeding as follows: This function first solves a relaxed version of problem Eq. (4) obtained by replacing the sum of the vectors ξg by a single vector γ whose ℓ1-norm should be less than, or equal to, the sum of the constraints on the vectors ξg. The optimal vector γ therefore gives a lower bound ||u − γ||22/2 on the optimal cost. Then, the maximum-flow step [24] tries to find a feasible flow such that the vector ξ̄ matches γ. If ξ̄ = γ, then the cost of the flow reaches the lower bound, and the flow is optimal. If ξ̄ 6= γ, the lower bound cannot be reached, and we construct a minimum (s, t)-cut of the graph [25] that defines two disjoints sets of nodes V + and V −; V + is the part of the graph that can potentially receive more flow from the source, whereas all arcs linking s to V − are saturated. The properties of a min (s, t)-cut [26] imply that there are no arcs from V + to V − (arcs inside V have infinite\n4By definition, a parametric max-flow problem consists in solving, for every value of a parameter, a max-flow problem on a graph whose arc capacities depend on this parameter.\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 8",
      "text" : "capacity by construction), and that there is no flow on arcs from V − to V +. At this point, it is possible to show that the value of the optimal min-cost flow on these arcs is also zero. Thus, removing them yields an equivalent optimization problem, which can be decomposed into two independent problems of smaller size and solved recursively by the calls to computeFlow(V+, E+) and computeFlow(V−, E−). Note that when Ω is the ℓ1-norm, our algorithm solves problem (4) during the first projection step in line 1 and stops. A formal proof of correctness of Algorithm 1 and further details are relegated to Appendix B.\nThe approach of [19, 22] is guaranteed to have the same worst-case complexity as a single maxflow algorithm. However, we have experimentally observed a significant discrepancy between the worst case and empirical complexities for these flow problems, essentially because the empirical cost of each max-flow is significantly smaller than its theoretical cost. Despite the fact that the worstcase guarantee of our algorithm is weaker than their (up to a factor |V |), it is more adapted to the structure of our graphs and has proven to be much faster in our experiments (see supplementary material).\nSome implementation details are crucial to the efficiency of the algorithm:\n• Exploiting maximal connected components: When there exists no arc between two subsets of V , it is possible to process them independently to solve the global min-cost flow problem. To that effect, before calling the function computeFlow(V,E), we look for maximal connected components (V1, E1), . . . , (VN , EN ) and call sequentially the procedure computeFlow(Vi, Ei) for i in [1;N ].\n• Efficient max-flow algorithm: We have implemented the “push-relabel” algorithm of [24] to solve our max-flow problems, using classical heuristics that significantly speed it up in practice (see [24, 27]). Our implementation uses the so-called “highest-active vertex selection rule, global and gap heuristics” (see [24, 27]), and has a worst-case complexity of O(|V |2|E|1/2) for a graph (V,E, s, t). This algorithm leverages the concept of pre-flow that relaxes the definition of flow and allows vertices to have a positive excess.\n• Using flow warm-restarts: Our algorithm can be initialized with any valid pre-flow, enabling warm-restarts when the max-flow is called several times as in our algorithm.\n• Improved projection step: The first line of the procedure computeFlow can be replaced by γ ← argminγ ∑ j∈Vu 1 2 (uj − γj) 2 s.t. ∑ j∈Vu γj ≤ λ ∑ g∈Vgr ηg and |γj | ≤ λ ∑ g∋j ηg. The\nidea is that the structure of the graph will not allow ξ̄j to be greater than λ ∑\ng∋j ηg after the max-flow step. Adding these additional constraints leads to better performance when the graph is not well balanced. This modified projection step can still be computed in linear time [21]."
    }, {
      "heading" : "3.3 Computation of the Dual Norm",
      "text" : "The dual norm Ω∗ of Ω, defined for any vector κ in Rp by Ω∗(κ) , maxΩ(z)≤1 z⊤κ, is a key quantity to study sparsity-inducing regularizations [5, 17, 28]. We use it here to monitor the convergence of the proximal method through a duality gap, and define a proper optimality criterion for problem (1). We denote by f∗ the Fenchel conjugate of f [29], defined by f∗(κ) , supz[z\n⊤κ−f(z)]. The duality gap for problem (1) can be derived from standard Fenchel duality arguments [29] and it is equal to f(w) + λΩ(w) + f∗(−κ) for w,κ in Rp with Ω∗(κ) ≤ λ. Therefore, evaluating the duality gap requires to compute efficiently Ω∗ in order to find a feasible dual variable κ. This is equivalent to solving another network flow problem, based on the following variational formulation:\nΩ∗(κ) = min ξ∈Rp×|G|\nτ s.t. ∑\ng∈G\nξg = κ, and ∀g ∈ G, ‖ξg‖1 ≤ τηg with ξ g j = 0 if j /∈ g. (5)\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 9",
      "text" : "In the network problem associated with (12), the capacities on the arcs (s, g), g ∈ G, are set to τηg , and the capacities on the arcs (j, t), j in [1; p], are fixed to κj . Solving problem (12) amounts to finding the smallest value of τ , such that there exists a flow saturating the capacities κj on the arcs leading to the sink t (i.e., ξ̄ = κ). Equration (12) and the algorithm below are proven to be correct in Appendix B.\nAlgorithm 2 Computation of the dual norm. 1: Inputs: κ ∈ Rp, a set of groups G, positive weights (ηg)g∈G . 2: Build the initial graph G0 = (V0, E0, s, t) as explained in Section 3.3. 3: τ ← dualNorm(V0, E0). 4: Return: τ (value of the dual norm).\nFunction dualNorm(V = Vu ∪ Vgr , E)\n1: τ←( ∑\nj∈Vu κj)/(\n∑\ng∈Vgr ηg) and set the capacities of arcs (s, g) to τηg for all g in Vgr .\n2: Max-flow step: Update (ξ̄j)j∈Vu by computing a max-flow on the graph (V,E, s, t). 3: if ∃ j ∈ Vu s.t. ξ̄j 6= κj then 4: Define (V +, E+) and (V −, E−) as in Algorithm 1, and set τ ← dualNorm(V −, E−). 5: end if 6: Return: τ ."
    }, {
      "heading" : "4 Applications and Experiments",
      "text" : "Our experiments use the algorithm of [4] based on our proximal operator, with weights ηg set to 1. We present this algorithm in more details in Appendix C."
    }, {
      "heading" : "4.1 Speed Comparison",
      "text" : "We compare our method (ProxFlow) and two generic optimization techniques, namely a subgradient descent (SG) and an interior point method,5 on a regularized linear regression problem. Both SG and ProxFlow are implemented in C++. Experiments are run on a single-core 2.8 GHz CPU. We consider a design matrix X in Rn×p built from overcomplete dictionaries of discrete cosine transforms (DCT), which are naturally organized on one- or two-dimensional grids and display local correlations. The following families of groups G using this spatial information are thus considered: (1) every contiguous sequence of length 3 for the one-dimensional case, and (2) every 3×3-square in the two-dimensional setting. We generate vectors y in Rn according to the linear model y = Xw0+ε, where ε ∼ N (0, 0.01‖Xw0‖22). The vectorw0 has about 20% percent nonzero components, randomly selected, while respecting the structure of G, and uniformly generated between [−1, 1].\nIn our experiments, the regularization parameter λ is chosen to achieve this level of sparsity. For SG, we take the step size to be equal to a/(k + b), where k is the iteration number, and (a, b) are the best parameters selected in {10−3, . . . , 10}×{102, 103, 104}. For the interior point methods, since problem (1) can be cast either as a quadratic (QP) or as a conic program (CP), we show in Figure 2 the results for both formulations. Our approach compares favorably with the other methods, on three problems of different sizes, (n, p) ∈ {(100, 103), (1024, 104), (1024, 105)}, see Figure 2. In addition, note that QP, CP and SG do not obtain sparse solutions, whereas ProxFlow does. We have also run ProxFlow and SG on a larger dataset with (n, p) = (100, 106): after 12 hours, ProxFlow and SG have reached a relative duality gap of 0.0006 and 0.02 respectively.6\n5In our simulations, we use the commercial software Mosek, http://www.mosek.com/ 6Due to the computational burden, QP and CP could not be run on every problem.\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 10",
      "text" : ""
    }, {
      "heading" : "4.2 Background Subtraction",
      "text" : "Following [8], we consider a background subtraction task. Given a sequence of frames from a fixed camera, we try to segment out foreground objects in a new image. If we denote by y ∈ Rn this image composed of n pixels, we model y as a sparse linear combination of p other images X ∈ Rn×p, plus an error term e in Rn, i.e., y ≈ Xw + e for some sparse vector w in Rp. This approach is reminiscent of [30] in the context of face recognition, where e is further made sparse to deal with small occlusions. The term Xw accounts for background parts present in both y and X, while e contains specific, or foreground, objects in y. The resulting optimization problem is minw,e 1 2‖y−Xw−e‖ 2 2+λ1‖w‖1+λ2‖e‖1, with λ1, λ2 ≥ 0. In this formulation, the ℓ1-norm penalty on e does not take into account the fact that neighboring pixels in y are likely to share the same label (background or foreground), which may lead to scattered pieces of foreground and background regions (Figure 3). We therefore put an additional structured regularization term Ω on e, where the groups in G are all the overlapping 3×3-squares on the image. A dataset with hand-segmented evaluation images is used to illustrate the effect of Ω.7 For simplicity, we use a single regularization parameter, i.e., λ1 = λ2, chosen to maximize the number of pixels matching the ground truth. We consider p = 200 images with n = 57600 pixels (i.e., a resolution of 120×160, times 3 for the RGB channels). As shown in Figure 3, adding Ω improves the background subtraction results for the two tested images, by removing the scattered artifacts due to the lack of structural constraints of the ℓ1-norm, which encodes neither spatial nor color consistency."
    }, {
      "heading" : "4.3 Multi-Task Learning of Hierarchical Structures",
      "text" : "In [11], Jenatton et al. have recently proposed to use a hierarchical structured norm to learn dictionaries of natural image patches. Following their work, we seek to represent n signals {y1, . . . ,yn} of dimension m as sparse linear combinations of elements from a dictionary X = [x1, . . . ,xp] in R\nm×p. This can be expressed for all i in [1;n] as yi ≈ Xwi, for some sparse vector wi in Rp. In [11], the dictionary elements are embedded in a predefined tree T , via a particular instance of the structured norm Ω, which we refer to it as Ωtree, and call G the underlying set of groups. In this case, each signal yi admits a sparse decomposition in the form of a subtree of dictionary elements.\nInspired by ideas from multi-task learning [16], we propose to learn the tree structure T by pruning irrelevant parts of a larger initial tree T0. We achieve this by using an additional regularization term Ωjoint across the different decompositions, so that subtrees of T0 will simultaneously be removed for all signals yi. In other words, the approach of [11] is extended by the following\n7http://research.microsoft.com/en-us/um/people/jckrumm/wallflower/testimages.htm\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 11",
      "text" : "formulation:\nmin X,W\n1\nn\nn ∑\ni=1\n[1\n2 ‖yi −Xwi‖22 + λ1Ωtree(w\ni) ] +λ2Ωjoint(W), s.t. ‖xj‖2 ≤ 1, for all j in [1; p], (6)\nwhere W , [w1, . . . ,wn] is the matrix of decomposition coefficients in Rp×n. The new regularization term operates on the rows of W and is defined as Ωjoint(W) , ∑ g∈G maxi∈[1;n] |w i g|.\n8 The overall penalty on W, which results from the combination of Ωtree and Ωjoint, is itself an instance of Ω with general overlapping groups, as defined in Eq (2).\nTo address problem (6), we use the same optimization scheme as [11], i.e., alternating between X and W, fixing one variable while optimizing with respect to the other. The task we consider is the denoising of natural image patches, with the same dataset and protocol as [11]. We study whether learning the hierarchy of the dictionary elements improves the denoising performance, compared to standard sparse coding (i.e., when Ωtree is the ℓ1-norm and λ2 = 0) and the hierarchical dictionary learning of [11] based on predefined trees (i.e., λ2 = 0). The dimensions of the training set — 50 000 patches of size 8×8 for dictionaries with up to p = 400 elements — impose to handle extremely large graphs, with |E| ≈ |V | ≈ 4.107. Since problem (6) is too large to be solved exactly sufficiently many times to select the regularization parameters (λ1, λ2) rigorously, we use the following heuristics: we optimize mostly with the currently pruned tree held fixed (i.e., λ2 = 0), and only prune the tree (i.e., λ2 > 0) every few steps on a random subset of 10 000 patches. We consider the same hierarchies as in [11], involving between 30 and 400 dictionary elements. The regularization parameter λ1 is selected on the validation set of 25 000 patches, for both sparse coding (Flat) and hierarchical dictionary learning (Tree). Starting from the tree giving the best performance (in this case the largest one, see Figure 4), we solve problem (6) following our heuristics, for increasing values of λ2. As shown in Figure 4, there is a regime where our approach performs significantly better than the two other compared methods. The standard deviation of the noise is 0.2 (the pixels have values in [0, 1]); no significant improvements were observed for lower levels of noise.\n8The simplified case where Ωtree and Ωjoint are the ℓ1- and mixed ℓ1/ℓ2-norms [14] corresponds to [31].\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 12",
      "text" : ""
    }, {
      "heading" : "5 Conclusion",
      "text" : "We have presented a new optimization framework for solving sparse structured problems involving sums of ℓ∞-norms of any (overlapping) groups of variables. Interestingly, this sheds new light on connections between sparse methods and the literature of network flow optimization. In particular, the proximal operator for the formulation we consider can be cast as a quadratic min-cost flow problem, for which we propose an efficient and simple algorithm. This allows the use of accelerated gradient methods. Several experiments demonstrate that our algorithm can be applied to a wide class of learning problems, which have not been addressed before within sparse methods.\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 13",
      "text" : ""
    }, {
      "heading" : "A Equivalence to Canonical Graphs",
      "text" : "Formally, the notion of equivalence between graphs can be summarized by the following lemma:\nLemma 2 (Equivalence to canonical graphs.) Let G = (V,E, s, t) be the canonical graph corresponding to a group structure G with weights (ηg)g∈G . Let G′ = (V,E′, s, t) be a graph sharing the same set of vertices, source and sink as G, but with a different arc set E′. We say that G′ is equivalent to G if and only if the following conditions hold:\n• Arcs of E′ outgoing from the source are the same as in E, with the same costs and capacities.\n• Arcs of E′ going to the sink are the same as in E, with the same costs and capacities.\n• For every arc (g, j) in E, with (g, j) in Vgr × Vu, there exists a unique path in E′ from g to j with zero costs and infinite capacities on every arc of the path.\n• Conversely, if there exists a path in E′ between a vertex g in Vgr and a vertex j in Vu, then there exists an arc (g, j) in E.\nThen, the cost of the optimal min-cost flow on G and G′ are the same. Moreover, the values of the optimal flow on the arcs (j, t), j in Vu, are the same on G and G ′.\nProof. We first notice that on both G and G′, the cost of a flow on the graph only depends on the flow on the arcs (j, t), j in Vu, which we have denoted by ξ̄ in E.\nWe will prove that finding a feasible flow π on G with a cost c(π) is equivalent to finding a feasible flow π′ on G′ with the same cost c(π) = c(π′). We now use the concept of path flow, which is a flow vector in G carrying the same positive value on every arc of a directed path between two nodes of G. It intuitively corresponds to sending a positive amount of flow along a path of the graph.\nAccording to the definition of graph equivalence introduced in the Lemma, it is easy to show that there is a bijection between the arcs in E, and the paths in E′ with positive capacities on every arc. Given now a feasible flow π in G, we build a feasible flow π′ on G′ which is a sum of path flows. More precisely, for every arc a in E, we consider its equivalent path in E′, with a path flow carrying the same amount of flow as a. Therefore, each arc a′ in E′ has a total amount of flow that is equal to the sum of the flows carried by the path flows going over a′. It is also easy to show that this construction builds a flow on G′ (capacity and conservation constraints are satisfied) and that this flow π′ has the same cost as π, that is, c(π) = c(π′).\nConversely, given a flow π′ on G′, we use a classical path flow decomposition (see Proposition 1.1 in [26]), saying that there exists a decomposition of π′ as a sum of path flows in E′. Using the bijection described above, we know that each path in the previous sums corresponds to a unique arc in E. We now build a flow π in G, by associating to each path flow in the decomposition of π′, an arc in E carrying the same amount of flow. The flow of every other arc in E is set to zero. It is also easy to show that this builds a valid flow in G that has the same cost as π′."
    }, {
      "heading" : "B Convergence Analysis",
      "text" : "We show in this section the correctness of Algorithm 1 for computing the proximal operator, and of Algorithm 2 for computing the dual norm Ω⋆.\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 14",
      "text" : ""
    }, {
      "heading" : "B.1 Computation of the Proximal Operator",
      "text" : "We now prove that our algorithm converges and that it finds the optimal solution of the proximal problem. This requires that we introduce the optimality conditions for problem (4) derived in [11], since our convergence proof essentially checks that these conditions are satisfied upon termination of the algorithm.\nLemma 3 (Optimality conditions of the problem (4), [11]) The primal-dual variables (w, ξ) are respectively solutions of the primal (3) and dual problems (4) if and only if the dual variable ξ is feasible for the problem (4) and\nw = u− ∑ g∈G ξ g,\n∀g ∈ G,\n{\nw⊤g ξ g g = ‖wg‖∞‖ξ g‖1 and ‖ξ g‖1 = ληg, or wg = 0.\nNote that these optimality conditions provide an intuitive view of our min-cost flow problem. Solving the min-cost flow problem is equivalent to sending the maximum amount of flow in the graph under the capacity constraints, while respecting the rule that the flow outgoing from a group g should always be directed to the variables uj with maximum residual uj − ∑ g∈G ξ g j .\nBefore proving the convergence and correctness of our algorithm, we also recall classical properties of the min capacity cuts, which we intensively use in the proofs of this paper. The procedure computeFlow of our algorithm finds a minimum (s, t)-cut of a graph G = (V,E, s, t), dividing the set V into two disjoint parts V + and V −. V + is by construction the sets of nodes in V such that there exists a non-saturating path from s to V , while all the paths from s to V − are saturated. Conversely, arcs from V + to t are all saturated, whereas there can be non-saturated arcs from V − to t. Moreover, the following properties hold\n• There is no arc going from V + to V −. Otherwise the value of the cut would be infinite. (Arcs inside V have infinite capacity by construction of our graph).\n• There is no flow going from V − to V + (see properties of the minimum (s, t)-cut [26]).\n• The cut goes through all arcs going from V + to t, and all arcs going from s to V −.\nAll these properties are illustrated on Figure 5. Recall that we assume (cf. Section 3.1) that the scalars uj are all non negative, and that we add non-negativity constraints on ξ. With the optimality conditions of Lemma 3 in hand, we can show our first convergence result.\nProposition 1 (Convergence of Algorithm 1) Algorithm 1 converges in a finite and polynomial number of operations.\nProof. Our algorithm splits recursively the graph into disjoints parts and processes each part recursively. The processing of one part requires an orthogonal projection onto an ℓ1-ball and a max-flow algorithm, which can both be computed in polynomial time. To prove that the procedure converges, it is sufficient to show that when the procedure computeFlow is called for a graph (V,E, s, t) and computes a cut (V +, V −), then the components V + and V − are both non-empty.\nSuppose for instance that V −= ∅. In this case, the capacity of the min-cut is equal to ∑\nj∈Vu γj ,\nand the value of the max-flow is ∑\nj∈Vu ξ̄j . Using the classical max-flow/min-cut theorem [25], we\nhave equality between these two terms. Since, by definition of both γ and ξ̄, we have for all j in Vu, ξ̄j ≤ γj , we obtain a contradiction with the existence of j in Vu such that ξ̄j 6= γj .\nConversely, suppose now that V += ∅. Then, the value of the max-flow is still ∑\nj∈Vu ξ̄j , and\nthe value of the min-cut is λ ∑\ng∈Vgr ηg. Using again the max-flow/min-cut theorem, we have that\nRR n° 7372\nNetwork Flow Algorithms for Structured Sparsity 15\n∑\nj∈Vu ξ̄j = λ\n∑\ng∈Vgr ηg. Moreover, by definition of γ, we also have\n∑\nj∈Vu ξ̄j ≤\n∑\nj∈Vu γj ≤\nλ ∑\ng∈Vgr ηg, leading to a contradiction with the existence of j in Vu such that ξ̄j 6= γj . This proof\nholds for any graph that is equivalent to the canonical one.\nAfter proving the convergence, we prove that the algorithm is correct with the next proposition.\nProposition 2 (Correctness of Algorithm 1) Algorithm 1 solves the proximal problem of Eq. (3).\nProof. For a group structure G, we first prove the correctness of our algorithm if the graph used is its associated canonical graph that we denote G0 = (V0, E0, s, t). We proceed by induction on the number of nodes of the graph. The induction hypothesis H(k) is the following:\nFor all canonical graphs G = (V = Vu ∪ Vgr , E, s, t) associated with a group structure GV with weights (ηg)g∈GV such that |V | ≤ k, computeFlow(V,E) solves the following optimization problem:\nmin (ξg\nj )j∈Vu,g∈Vgr\n∑\nj∈Vu\n1 2 (uj − ∑\ng∈Vgr\nξ g j ) 2 s.t. ∀g ∈ Vgr , ∑\nj∈Vu\nξ g j ≤ ληg and ξ g j = 0, ∀j /∈ g. (7)\nSince GV0 = G, it is sufficient to show that H(|V0|) to prove the proposition. We initialize the induction by H(2), corresponding to the simplest canonical graph, for which |Vgr| = |Vu| = 1). Simple algebra shows that H(2) is indeed correct. We now suppose that H(k′) is true for all k′ < k and consider a graph G = (V,E, s, t), |V | = k. The first step of the algorithm computes the variable (γj)j∈Vu by a projection on the ℓ1-ball. This is itself an instance of the dual formulation of Eq. (4) in a simple case, with one group containing all variables. We can therefore use Lemma 3 to characterize the optimality of (γj)j∈Vu , which yields\n{ ∑\nj∈Vu (uj − γj)γj =\n( maxj∈Vu |uj − γj | ) ∑ j∈Vu γj and ∑ j∈Vu γj = λ ∑ g∈Vgr ηg,\nor uj − γj = 0, ∀j ∈ Vu. (8)\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 16",
      "text" : "The algorithm then computes a max-flow, using the scalars γj as capacities, and we now have two possible situations:\n1. If ξ̄j = γj for all j in Vu, the algorithm stops; we write wj = uj − ξ̄j for j in Vu, and using Eq. (8), we obtain\n{ ∑\nj∈Vu wj ξ̄j = (maxj∈Vu |wj |)\n∑\nj∈Vu ξ̄j and\n∑\nj∈Vu ξ̄j = λ\n∑\ng∈Vgr ηg,\nor wj = 0, ∀j ∈ Vu. (9)\nWe can rewrite the condition above as ∑\ng∈Vgr\n∑\nj∈g\nwjξ g j =\n∑\ng∈Vgr\n(max j∈Vu\n|wj |) ∑\nj∈Vu\nξ g j .\nSince all the quantities in the previous sum are positive, this can only hold if for all g ∈ Vgr ,\n∑\nj∈Vu\nwjξ g j = (max\nj∈Vu |wj |)\n∑\nj∈Vu\nξ g j .\nMoreover, by definition of the max flow and the optimality conditions, we have\n∀g ∈ Vgr , ∑\nj∈Vu\nξ g j ≤ ληg , and\n∑\nj∈Vu\nξ̄j = λ ∑\ng∈Vgr\nηg,\nwhich leads to ∀g ∈ Vgr , ∑\nj∈Vu\nξ g j = ληg.\nBy Lemma 3, we have shown that the problem (7) is solved.\n2. Let us now consider the case where there exists j in Vu such that ξ̄j 6= γj . The algorithm splits the vertex set V into two parts V + and V −, which we have proven to be non-empty in the proof of Proposition 1. The next step of the algorithm removes all edges between V + and V − (see Figure 5). Processing (V +, E+) and (V −, E−) independently, it updates the value of the flow matrix ξgj , j ∈ Vu, g ∈ Vgr, and the corresponding flow vector ξ̄j , j ∈ Vu. As for\nV , we denote by V +u , V + ∩ Vu, V −u , V − ∩ Vu and V +gr , V + ∩ Vgr , V −gr , V − ∩ Vgr . Then, we notice that (V +, E+, s, t) and (V −, E−, s, t) are respective canonical graphs for the group structures GV + , {g ∩ V +u | g ∈ Vgr}, and GV − , {g ∩ V − u | g ∈ Vgr}. Writing wj = uj − ξ̄j for j in Vu, and using the induction hypotheses H(|V +|) and H(|V −|), we now have the following optimality conditions deriving from Lemma 3 applied on Eq. (7) respectively for the graphs (V +, E+) and (V −, E−):\n∀g ∈ V +gr , g ′ , g ∩ V +u ,\n{ w⊤g′ξ g g′ = ‖wg′‖∞ ∑ j∈g′ξ g j and ∑ j∈g′ξ g j = ληg,\nor wg′ = 0, (10)\nand\n∀g ∈ V −gr , g ′ , g ∩ V −u ,\n{ w⊤g′ξ g g′ = ‖wg′‖∞ ∑ j∈g′ξ g j and ∑ j∈g′ξ g j = ληg,\nor wg′ = 0. (11)\nWe will now combine Eq. (10) and Eq. (11) into optimality conditions for Eq. (7). We first notice that g ∩ V +u = g since there are no arcs between V\n+ and V − in E (see the properties of the cuts discussed before this proposition). It is therefore possible to replace g′ by g in\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 17",
      "text" : "Eq. (10). We will show that it is possible to do the same in Eq. (11), so that combining these two equations yield the optimality conditions of Eq. (7).\nMore precisely, we will show that for all g ∈ V −gr and j ∈ g ∩ V + u , |wj | ≤ maxl∈g∩V −u |wl|, in which case g′ can be replaced by g in Eq. (11). This result is relatively intuitive: (s, V +) and (V −, t) being an (s, t)-cut, all arcs between s and V − are saturated, while there are unsaturated arcs between s and V +; one therefore expects the residuals uj − ξ̄j to decrease on the V + side, while increasing on the V − side. The proof is nonetheless a bit technical.\nLet us show first that for all g in V +gr , ‖wg‖∞ ≤ maxj∈Vu |uj − γj |. We split the set V + into disjoint parts:\nV ++gr , {g ∈ V + gr s.t. ‖wg‖∞ ≤ maxj∈Vu |uj − γj |}, V ++u , {j ∈ V + u s.t. ∃g ∈ V ++ gr , j ∈ g}, V +−gr , V + gr \\ V ++ gr = {g ∈ V\n+ gr s.t. ‖wg‖∞ > maxj∈Vu |uj − γj |},\nV +−u , V + u \\ V ++ u .\nAs previously, we denote V +−, V +−u ∪ V +− gr and V ++ ,V ++u ∪ V ++ gr . We want to show that V +−gr is necessarily empty. We reason by contradiction and assume that V +− gr 6= ∅.\nAccording to the definition of the different sets above, we observe that no arcs are going from V ++ to V +−, that is, for all g in V ++gr , g ∩ V +− u = ∅. We observe as well that the flow from V +−gr to V ++ u is the null flow, because optimality conditions (10) imply that for a group g only nodes j ∈ g such that wj = ‖wg‖∞ receive some flow, which excludes nodes in V ++u provided V +−gr 6= ∅; Combining this fact and the inequality ∑ g∈V +gr ληg ≥ ∑ j∈V +u γj (which is a direct consequence of the minimum (s, t)-cut), we have as well ∑\ng∈V +−gr\nληg ≥ ∑\nj∈V +−u\nγj .\nLet j ∈ V +−u , if ξ̄j 6= 0 then for some g ∈ V +− gr such that j receives some flow from g, which from the optimality conditions (10) implies wj = ‖wg‖∞; by definition of V +−gr , ‖wg‖∞ > uj −γj . But since at the optimum, wj = uj − ξ̄j , this implies that ξ̄j < γj , and in turn that ∑\nj∈V +−u ξ̄j = λ\n∑\ng∈V +−gr ηg. Finally,\nλ ∑\ng∈V +−gr\nηg = ∑\nj∈V +−u , ξ̄j 6=0\nξ̄j < ∑\nj∈V +−u\nγj\nand this is a contradiction.\nWe now have that for all g in V +gr , ‖wg‖∞ ≤ maxj∈Vu |uj − γj |. The proof showing that for all g in V −gr , ‖wg‖∞ ≥ maxj∈Vu |uj − γj |, uses the same kind of decomposition for V\n−, and follows along similar arguments. We will therefore not detail it.\nTo recap, we have shown that for all g ∈ V −gr and j ∈ g ∩ V + u , |wj | ≤ maxl∈g∩V −u |wl|. Since there is no flow from V − to V +, i.e., ξgj = 0 for g in V − gr and j in V + u , we can now replace the definition of g′ in Eq. (11) by g′ , g ∩ Vu, the combination of Eq. (10) and Eq. (11) gives us optimality conditions for Eq. (7).\nThe proposition being proved for the canonical graph, we extend it now for an equivalent graph in the sense of Lemma 2. First, we observe that the algorithm gives the same values of γ for two\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 18",
      "text" : "equivalent graphs. Then, it is easy to see that the value ξ̄ given by the max-flow, and the chosen (s, t)-cut is the same, which is enough to conclude that the algorithm performs the same steps for two equivalent graphs."
    }, {
      "heading" : "B.2 Computation of the Dual Norm Ω⋆",
      "text" : "Similarly to the proximal operator, the computation of dual norm Ω∗ can itself shown to solve another network flow problem, based on the following variational formulation, which extends a previous result from [5]:\nLemma 4 (Dual formulation of the dual-norm Ω⋆.) Let κ ∈ Rp. We have\nΩ∗(κ) = min ξ∈Rp×|G|,τ\nτ s.t. ∑\ng∈G\nξg = κ, and ∀g ∈ G, ‖ξg‖1 ≤ τηg with ξ g j = 0 if j /∈ g. (12)\nProof. By definition of Ω∗(κ), we have\nΩ∗(κ) , max Ω(z)≤1 z⊤κ.\nBy introducing the primal variables (αg)g∈G ∈ R|G|, we can rewrite the previous maximization problem as\nΩ∗(κ) = max∑ g∈Gηgαg≤1 κ⊤z, s.t. ∀ g ∈ G, ‖zg‖∞ ≤ αg,\nwith the additional |G| conic constraints ‖zg‖∞ ≤ αg. This primal problem is convex and satisfies Slater’s conditions for generalized conic inequalities, which implies that strong duality holds [32]. We now consider the Lagrangian L defined as\nL(z, αg , τ, γg, ξ) = κ ⊤z+ τ(1−\n∑\ng∈G\nηgαg) + ∑\ng∈G\n(\nαg zg )⊤( γg ξgg ) ,\nwith the dual variables {τ, (γg)g∈G , ξ} ∈ R+×R |G|×Rp×|G| such that for all g ∈ G, ξgj = 0 if j /∈ g and ‖ξg‖1 ≤ γg. The dual function is obtained by taking the derivatives of L with respect to the primal variables z and (αg)g∈G and equating them to zero, which leads to\n∀j ∈ {1, . . . , p}, κj + ∑ g∈G ξ g j = 0\n∀g ∈ G, τηg − γg = 0.\nAfter simplifying the Lagrangian and flipping the sign of ξ, the dual problem then reduces to\nmin ξ∈Rp×|G|,τ τ s.t.\n{\n∀j ∈ {1, . . . , p},κj = ∑ g∈G ξ g j and ξ g j = 0 if j /∈ g, ∀g ∈ G, ‖ξg‖1 ≤ τηg ,\nwhich is the desired result.\nWe now prove that Algorithm 2 is correct.\nProposition 3 (Convergence and correctness of Algorithm 2) Algorithm 2 computes the value of the dual norm of Eq. (12) in a finite and polynomial number of operations.\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 19",
      "text" : "Proof. The convergence of the algorithm only requires to show that the cardinality of V in the different calls of the function computeFlow strictly decreases. Similar arguments to those used in the proof of Proposition 1 can show that each part of the cuts (V +, V −) are both non-empty. The algorithm thus requires a finite number of calls to a max-flow algorithm and converges in a finite and polynomial number of operations.\nLet us now prove that the algorithm is correct for a canonical graph. We proceed again by induction on the number of nodes of the graph. More precisely, we consider the induction hypothesis H′(k) defined as:\nfor all canonical graphs G = (V,E, s, t) associated with a group structure GV and such that |V | ≤ k, dualNormAux(V = Vu ∪ Vgr , E) solves the following optimization problem:\nmin ξ,τ\nτ s.t. ∀j ∈ Vu,κj = ∑\ng∈Vgr\nξ g j , and ∀g ∈ Vgr,\n∑\nj∈Vu\nξ g j ≤ τηg with ξ g j = 0 if j /∈ g. (13)\nWe first initialize the induction by H(2) (i.e., with the simplest canonical graph, such that |Vgr | = |Vu| = 1). Simple algebra shows that H(2) is indeed correct.\nWe next consider a canonical graphG = (V,E, s, t) such that |V | = k, and suppose thatH′(k−1) is true. After the max-flow step, we have two possible cases to discuss:\n1. If ξ̄j = γj for all j in Vu, the algorithm stops. We know that any scalar τ such that the constraints of Eq. (13) are all satisfied necessarily verifies ∑\ng∈Vgr τηg ≥\n∑\nj∈Vu κj . We have\nindeed that ∑\ng∈Vgr τηg is the value of an (s, t)-cut in the graph, and\n∑\nj∈Vu κj is the value of\nthe max-flow, and the inequality follows from the max-flow/min-cut theorem [25]. This gives a lower-bound on τ . Since this bound is reached, τ is necessarily optimal.\n2. We now consider the case where there exists j in Vu such that ξ̄j 6= κj , meaning that for the given value of τ , the constraint set of Eq. (13) is not feasible for ξ, and that the value of τ should necessarily increase. The algorithm splits the vertex set V into two non-empty parts V + and V − and we remark that there are no arcs going from V + to V −, and no flow going from V − to V +. Since the arcs going from s to V − are saturated, we have that ∑\ng∈V −gr τηg ≤\n∑\nj∈V −u κj .\nLet us now consider τ⋆ the solution of Eq. (13). Using the induction hypothesis H′(|V −|), the algorithm computes a new value τ ′ that solves Eq. (13) when replacing V by V − and this new value satisfies the following inequality ∑\ng∈V −gr τ ′ηg ≥\n∑\nj∈V −u κj . The value of τ ′\nhas therefore increased and the updated flow ξ now satisfies the constraints of Eq. (13) and therefore τ ′ ≥ τ⋆. Since there are no arcs going from V + to V −, τ⋆ is feasible for Eq. (13) when replacing V by V − and we have that τ⋆ ≥ τ ′ and then τ ′ = τ⋆.\nTo prove that the result holds for any equivalent graph, similar arguments to those used in the proof of Proposition 1 can be exploited, showing that the algorithm computes the same values of τ and same (s, t)-cuts at each step."
    }, {
      "heading" : "C Algorithm FISTA with duality gap",
      "text" : "In this section, we describe in details the algorithm FISTA [4] when applied to solve problem (1), with a duality gap as stopping criterion.\nWithout loss of generality, let us assume we are looking for models of the form Xw, for some matrix X ∈ Rn×p (typically, linear models where X is the data matrix of n observations). Thus,\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 20",
      "text" : "we can consider the following primal problem\nmin w∈Rp f(Xw) + λΩ(w), (14)\nin place of (1). Based on Fenchel duality arguments [29],\nf(Xw) + λΩ(w) + f∗(−κ), for w ∈ Rp,κ ∈ Rn and Ω∗(X⊤κ) ≤ λ,\nis a duality gap for (14). where f∗(κ) , supz[z ⊤κ − f(z)] is the Fenchel conjugate of f . Given a primal variable w, a good dual candidate κ can be obtained by looking at the conditions that have to be satisfied by the pair (w,κ) at optimality [29]. In particular, the dual variable κ is chosen to be\nκ = −ρ−1∇f(Xw), with ρ , max { λ−1Ω∗(X⊤∇f(Xw)), 1 } .\nConsequently, computing the duality gap requires evaluating the dual norm Ω∗. We sum up the computation of the duality gap in Algorithm 3.\nMoreover, we refer to the proximal operator associated with λΩ as prox[λΩ]. As a brief reminder, it is defined as the function that maps the vector u in Rp to the (unique, by strong convexity) solution of Eq. (3).\nAlgorithm 3 FISTA procedure to solve problem (14).\n1: Inputs: initial w(0) ∈ Rp, Ω, λ > 0, εgap > 0 (precision for the duality gap). 2: Parameters: ν > 1, L0 > 0. 3: Outputs: solution w. 4: Initialization: y(1) = w(0), t1 = 1, k = 1. 5: while { computeDualityGap ( w(k−1) ) > εgap }\ndo 6: Find the smallest integer sk≥0 such that 7: f(prox[λΩ](y(k))) ≤ f(y(k)) + ∆ ⊤ (k)∇f(y(k)) + L̃ 2 ‖∆(k)‖ 2 2, 8: with L̃ , Lkνsk and ∆(k) , y(k)−prox[λΩ](y(k)). 9: Lk ← Lk−1νsk .\n10: w(k) ← prox[λΩ](y(k)). 11: tk+1 ← (1 + √\n1 + t2k)/2. 12: y(k+1) ← w(k) +\ntk−1 tk+1 (w(k) −w(k−1)). 13: k ← k + 1. 14: end while 15: Return: w ← w(k−1).\nProcedure computeDualityGap(w)\n1: κ ← −ρ−1∇f(Xw), with ρ , max { λ−1Ω∗(X⊤∇f(Xw)), 1 }\n. 2: Return: f(Xw) + λΩ(w) + f∗(−κ)."
    }, {
      "heading" : "D Additional Experimental Results",
      "text" : "D.1 Speed comparison of Algorithm 1 with parametric max-flow algo-\nrithms\nAs shown in [19], min-cost flow problems, and in particular, the dual problem of (3), can be reduced to a specific parametric max-flow problem. We thus compare our approach (ProxFlow) with the\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 21",
      "text" : "efficient parametric max-flow algorithm proposed by Gallo, Grigoriadis, and Tar- jan [22] and a simplified version of the latter proposed by Babenko and Goldberg in [23]. We refer to these two algorithms as GGT and SIMP respectively. The benchmark is established on the same datasets as those already used in the experimental section of the paper, namely: (1) three datasets built from overcomplete bases of discrete cosine transforms (DCT), with respectively 104, 105 and 106 variables, and (2) images used for the background subtraction task, composed of 57600 pixels. For GGT and SIMP, we use the paraF software which is a C++ parametric max-flow implementation available at http://www.avglab.com/andrew/soft.html. Experiments were conducted on a single-core 2.33 Ghz.\nWe report in the following table the execution time in seconds of each algorithm, as well as the statistics of the corresponding problems:\nNumber of variables p 10 000 100 000 1 000 000 57 600\n|V | 20 000 200 000 2 000 000 75 600 |E| 110 000 500 000 11 000 000 579 632\nProxFlow (in sec.) 0.4 3.1 113.0 1.7 GGT (in sec.) 2.4 26.0 525.0 16.7 SIMP (in sec.) 1.2 13.1 284.0 8.31\nAlthough we provide the speed comparison for a single value of λ (the one used in the corresponding experiments of the paper), we observed that our approach consistently outperforms GGT and SIMP for values of λ corresponding to different regularization regimes."
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 22",
      "text" : "[10] S. Kim and E. P. Xing. Tree-guided group lasso for multi-task regression with structured sparsity. In Proc. ICML, 2010.\n[11] R. Jenatton, J. Mairal, G. Obozinski, and F. Bach. Proximal methods for sparse hierarchical dictionary learning. In Proc. ICML, 2010.\n[12] V. Roth and B. Fischer. The Group-Lasso for generalized linear models: uniqueness of solutions and efficient algorithms. In Proc. ICML, 2008.\n[13] R. Tibshirani. Regression shrinkage and selection via the Lasso. J. Roy. Stat. Soc. B, 58(1):267– 288, 1996.\n[14] M. Yuan and Y. Lin. Model selection and estimation in regression with grouped variables. J. Roy. Stat. Soc. B, 68:49–67, 2006.\n[15] J. Huang and T. Zhang. The benefit of group sparsity. Technical report, 2009. Preprint arXiv:0901.2962.\n[16] G. Obozinski, B. Taskar, and M. I. Jordan. Joint covariate selection and joint subspace selection for multiple classification problems. Stat. Comput., 20(2):231–252, 2010.\n[17] F. Bach. Exploring large feature spaces with hierarchical multiple kernel learning. In Adv. NIPS, 2008.\n[18] P. L. Combettes and J.-C. Pesquet. Proximal splitting methods in signal processing. In FixedPoint Algorithms for Inverse Problems in Science and Engineering. Springer, 2010.\n[19] D. S. Hochbaum and S. P. Hong. About strongly polynomial time algorithms for quadratic optimization over submodular constraints. Math. Program., 69(1):269–309, 1995.\n[20] J. Duchi, S. Shalev-Shwartz, Y. Singer, and T. Chandra. Efficient projections onto the ℓ1-ball for learning in high dimensions. In Proc. ICML, 2008.\n[21] P. Brucker. An O(n) algorithm for quadratic knapsack problems. Oper. Res. Lett., 3:163–166, 1984.\n[22] G. Gallo, M. E. Grigoriadis, and R. E. Tarjan. A fast parametric maximum flow algorithm and applications. SIAM J. Comput., 18:30–55, 1989.\n[23] M. Babenko and A.V. Goldberg. Experimental evaluation of a parametric flow algorithm. Technical report, Microsoft Research, 2006. MSR-TR-2006-77.\n[24] A. V. Goldberg and R. E. Tarjan. A new approach to the maximum flow problem. In Proc. of ACM Symposium on Theory of Computing, pages 136–146, 1986.\n[25] L. R. Ford and D. R. Fulkerson. Maximal flow through a network. Canadian J. Math., 8(3):399–404, 1956.\n[26] D. P. Bertsekas. Linear Network Optimization. MIT Press, 1991.\n[27] B. V. Cherkassky and A. V. Goldberg. On implementing the push-relabel method for the maximum flow problem. Algorithmica, 19(4):390–410, 1997.\n[28] S. Negahban, P. Ravikumar, M. J. Wainwright, and B. Yu. A unified framework for highdimensional analysis of M-estimators with decomposable regularizers. In Adv. NIPS, 2009.\nRR n° 7372"
    }, {
      "heading" : "Network Flow Algorithms for Structured Sparsity 23",
      "text" : "[29] J. M. Borwein and A. S. Lewis. Convex analysis and nonlinear optimization: Theory and examples. Springer, 2006.\n[30] J. Wright, A. Y. Yang, A. Ganesh, S. S. Sastry, and Y. Ma. Robust face recognition via sparse representation. IEEE T. Pattern. Anal., 31(2):210–227, 2009.\n[31] P. Sprechmann, I. Ramirez, G. Sapiro, and Y. C. Eldar. Collaborative hierarchical sparse modeling. Technical report, 2010. Preprint arXiv:1003.0400v1.\n[32] S. P. Boyd and L. Vandenberghe. Convex Optimization. Cambridge University Press, 2004.\nRR n° 7372\nCentre de recherche INRIA Paris – Rocquencourt Domaine de Voluceau - Rocquencourt - BP 105 - 78153 Le Chesnay Cedex (France)\nCentre de recherche INRIA Bordeaux – Sud Ouest : Domaine Universitaire - 351, cours de la Libération - 33405 Talence Cedex Centre de recherche INRIA Grenoble – Rhône-Alpes : 655, avenue de l’Europe - 38334 Montbonnot Saint-Ismier\nCentre de recherche INRIA Lille – Nord Europe : Parc Scientifique de la Haute Borne - 40, avenue Halley - 59650 Villeneuve d’Ascq Centre de recherche INRIA Nancy – Grand Est : LORIA, Technopôle de Nancy-Brabois - Campus scientifique\n615, rue du Jardin Botanique - BP 101 - 54602 Villers-lès-Nancy Cedex Centre de recherche INRIA Rennes – Bretagne Atlantique : IRISA, Campus universitaire de Beaulieu - 35042 Rennes Cedex\nCentre de recherche INRIA Saclay – Île-de-France : Parc Orsay Université - ZAC des Vignes : 4, rue Jacques Monod - 91893 Orsay Cedex Centre de recherche INRIA Sophia Antipolis – Méditerranée : 2004, route des Lucioles - BP 93 - 06902 Sophia Antipolis Cedex\nÉditeur INRIA - Domaine de Voluceau - Rocquencourt, BP 105 - 78153 Le Chesnay Cedex (France)\nhttp://www.inria.fr\nISSN 0249-6399"
    } ],
    "references" : [ {
      "title" : "Simultaneous analysis of Lasso and Dantzig selector",
      "author" : [ "P. Bickel", "Y. Ritov", "A. Tsybakov" ],
      "venue" : "Ann. Stat.,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2009
    }, {
      "title" : "Least angle regression",
      "author" : [ "B. Efron", "T. Hastie", "I. Johnstone", "R. Tibshirani" ],
      "venue" : "Ann. Stat.,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2004
    }, {
      "title" : "Gradient methods for minimizing composite objective function",
      "author" : [ "Y. Nesterov" ],
      "venue" : "Technical report, Center for Operations Research and Econometrics (CORE), Catholic University of Louvain,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2007
    }, {
      "title" : "A fast iterative shrinkage-thresholding algorithm for linear inverse problems",
      "author" : [ "A. Beck", "M. Teboulle" ],
      "venue" : "SIAM J. Imag. Sci.,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2009
    }, {
      "title" : "Structured variable selection with sparsity-inducing norms",
      "author" : [ "R. Jenatton", "J-Y. Audibert", "F. Bach" ],
      "venue" : "Technical report,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2009
    }, {
      "title" : "Group Lasso with overlap and graph Lasso",
      "author" : [ "L. Jacob", "G. Obozinski", "J.-P. Vert" ],
      "venue" : "In Proc. ICML,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2009
    }, {
      "title" : "The composite absolute penalties family for grouped and hierarchical variable selection",
      "author" : [ "P. Zhao", "G. Rocha", "B. Yu" ],
      "venue" : "Ann. Stat.,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2009
    }, {
      "title" : "Learning with structured sparsity",
      "author" : [ "J. Huang", "Z. Zhang", "D. Metaxas" ],
      "venue" : "In Proc. ICML,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2009
    }, {
      "title" : "Model-based compressive sensing",
      "author" : [ "R.G. Baraniuk", "V. Cevher", "M. Duarte", "C. Hegde" ],
      "venue" : "IEEE T. Inform. Theory,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2010
    }, {
      "title" : "Tree-guided group lasso for multi-task regression with structured sparsity",
      "author" : [ "S. Kim", "E.P. Xing" ],
      "venue" : "In Proc. ICML,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2010
    }, {
      "title" : "Proximal methods for sparse hierarchical dictionary learning",
      "author" : [ "R. Jenatton", "J. Mairal", "G. Obozinski", "F. Bach" ],
      "venue" : "In Proc. ICML,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2010
    }, {
      "title" : "The Group-Lasso for generalized linear models: uniqueness of solutions and efficient algorithms",
      "author" : [ "V. Roth", "B. Fischer" ],
      "venue" : "In Proc. ICML,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2008
    }, {
      "title" : "Regression shrinkage and selection via the Lasso",
      "author" : [ "R. Tibshirani" ],
      "venue" : "J. Roy. Stat. Soc. B,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1996
    }, {
      "title" : "Model selection and estimation in regression with grouped variables",
      "author" : [ "M. Yuan", "Y. Lin" ],
      "venue" : "J. Roy. Stat. Soc. B,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2006
    }, {
      "title" : "The benefit of group sparsity",
      "author" : [ "J. Huang", "T. Zhang" ],
      "venue" : "Technical report,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2009
    }, {
      "title" : "Joint covariate selection and joint subspace selection for multiple classification problems",
      "author" : [ "G. Obozinski", "B. Taskar", "M.I. Jordan" ],
      "venue" : "Stat. Comput.,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2010
    }, {
      "title" : "Exploring large feature spaces with hierarchical multiple kernel learning",
      "author" : [ "F. Bach" ],
      "venue" : "In Adv. NIPS,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2008
    }, {
      "title" : "Proximal splitting methods in signal processing. In Fixed- Point Algorithms for Inverse Problems in Science and Engineering",
      "author" : [ "P.L. Combettes", "J.-C. Pesquet" ],
      "venue" : null,
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2010
    }, {
      "title" : "About strongly polynomial time algorithms for quadratic optimization over submodular constraints",
      "author" : [ "D.S. Hochbaum", "S.P. Hong" ],
      "venue" : "Math. Program.,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1995
    }, {
      "title" : "Efficient projections onto the l1-ball for learning in high dimensions",
      "author" : [ "J. Duchi", "S. Shalev-Shwartz", "Y. Singer", "T. Chandra" ],
      "venue" : "In Proc. ICML,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2008
    }, {
      "title" : "An O(n) algorithm for quadratic knapsack problems",
      "author" : [ "P. Brucker" ],
      "venue" : "Oper. Res. Lett.,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1984
    }, {
      "title" : "A fast parametric maximum flow algorithm and applications",
      "author" : [ "G. Gallo", "M.E. Grigoriadis", "R.E. Tarjan" ],
      "venue" : "SIAM J. Comput.,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1989
    }, {
      "title" : "Experimental evaluation of a parametric flow algorithm",
      "author" : [ "M. Babenko", "A.V. Goldberg" ],
      "venue" : "Technical report, Microsoft Research,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2006
    }, {
      "title" : "A new approach to the maximum flow problem",
      "author" : [ "A.V. Goldberg", "R.E. Tarjan" ],
      "venue" : "In Proc. of ACM Symposium on Theory of Computing,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1986
    }, {
      "title" : "Maximal flow through a network",
      "author" : [ "L.R. Ford", "D.R. Fulkerson" ],
      "venue" : "Canadian J. Math.,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1956
    }, {
      "title" : "Linear Network Optimization",
      "author" : [ "D.P. Bertsekas" ],
      "venue" : null,
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 1991
    }, {
      "title" : "On implementing the push-relabel method for the maximum flow problem",
      "author" : [ "B.V. Cherkassky", "A.V. Goldberg" ],
      "venue" : null,
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 1997
    }, {
      "title" : "A unified framework for highdimensional analysis of M-estimators with decomposable regularizers",
      "author" : [ "S. Negahban", "P. Ravikumar", "M.J. Wainwright", "B. Yu" ],
      "venue" : "In Adv. NIPS,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2009
    }, {
      "title" : "Convex analysis and nonlinear optimization: Theory and examples",
      "author" : [ "J.M. Borwein", "A.S. Lewis" ],
      "venue" : null,
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2006
    }, {
      "title" : "Robust face recognition via sparse representation",
      "author" : [ "J. Wright", "A.Y. Yang", "A. Ganesh", "S.S. Sastry", "Y. Ma" ],
      "venue" : "IEEE T. Pattern. Anal.,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2009
    }, {
      "title" : "Collaborative hierarchical sparse modeling",
      "author" : [ "P. Sprechmann", "I. Ramirez", "G. Sapiro", "Y.C. Eldar" ],
      "venue" : "Technical report,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2010
    }, {
      "title" : "Convex Optimization",
      "author" : [ "S.P. Boyd", "L. Vandenberghe" ],
      "venue" : "Centre de recherche INRIA Paris – Rocquencourt Domaine de Voluceau",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2004
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Regularization by the l1-norm has emerged as a powerful tool for addressing this combinatorial variable selection problem, relying on both a well-developed theory (see [1] and references therein) and efficient algorithms [2, 3, 4].",
      "startOffset" : 168,
      "endOffset" : 171
    }, {
      "referenceID" : 1,
      "context" : "Regularization by the l1-norm has emerged as a powerful tool for addressing this combinatorial variable selection problem, relying on both a well-developed theory (see [1] and references therein) and efficient algorithms [2, 3, 4].",
      "startOffset" : 221,
      "endOffset" : 230
    }, {
      "referenceID" : 2,
      "context" : "Regularization by the l1-norm has emerged as a powerful tool for addressing this combinatorial variable selection problem, relying on both a well-developed theory (see [1] and references therein) and efficient algorithms [2, 3, 4].",
      "startOffset" : 221,
      "endOffset" : 230
    }, {
      "referenceID" : 3,
      "context" : "Regularization by the l1-norm has emerged as a powerful tool for addressing this combinatorial variable selection problem, relying on both a well-developed theory (see [1] and references therein) and efficient algorithms [2, 3, 4].",
      "startOffset" : 221,
      "endOffset" : 230
    }, {
      "referenceID" : 4,
      "context" : "Much effort has recently been devoted to designing sparsity-inducing regularizations capable of encoding higherorder information about allowed patterns of non-zero coefficients [5, 6, 7, 8, 9], with successful applications in bioinformatics [6, 10], topic modeling [11] and computer vision [8].",
      "startOffset" : 177,
      "endOffset" : 192
    }, {
      "referenceID" : 5,
      "context" : "Much effort has recently been devoted to designing sparsity-inducing regularizations capable of encoding higherorder information about allowed patterns of non-zero coefficients [5, 6, 7, 8, 9], with successful applications in bioinformatics [6, 10], topic modeling [11] and computer vision [8].",
      "startOffset" : 177,
      "endOffset" : 192
    }, {
      "referenceID" : 6,
      "context" : "Much effort has recently been devoted to designing sparsity-inducing regularizations capable of encoding higherorder information about allowed patterns of non-zero coefficients [5, 6, 7, 8, 9], with successful applications in bioinformatics [6, 10], topic modeling [11] and computer vision [8].",
      "startOffset" : 177,
      "endOffset" : 192
    }, {
      "referenceID" : 7,
      "context" : "Much effort has recently been devoted to designing sparsity-inducing regularizations capable of encoding higherorder information about allowed patterns of non-zero coefficients [5, 6, 7, 8, 9], with successful applications in bioinformatics [6, 10], topic modeling [11] and computer vision [8].",
      "startOffset" : 177,
      "endOffset" : 192
    }, {
      "referenceID" : 8,
      "context" : "Much effort has recently been devoted to designing sparsity-inducing regularizations capable of encoding higherorder information about allowed patterns of non-zero coefficients [5, 6, 7, 8, 9], with successful applications in bioinformatics [6, 10], topic modeling [11] and computer vision [8].",
      "startOffset" : 177,
      "endOffset" : 192
    }, {
      "referenceID" : 5,
      "context" : "Much effort has recently been devoted to designing sparsity-inducing regularizations capable of encoding higherorder information about allowed patterns of non-zero coefficients [5, 6, 7, 8, 9], with successful applications in bioinformatics [6, 10], topic modeling [11] and computer vision [8].",
      "startOffset" : 241,
      "endOffset" : 248
    }, {
      "referenceID" : 9,
      "context" : "Much effort has recently been devoted to designing sparsity-inducing regularizations capable of encoding higherorder information about allowed patterns of non-zero coefficients [5, 6, 7, 8, 9], with successful applications in bioinformatics [6, 10], topic modeling [11] and computer vision [8].",
      "startOffset" : 241,
      "endOffset" : 248
    }, {
      "referenceID" : 10,
      "context" : "Much effort has recently been devoted to designing sparsity-inducing regularizations capable of encoding higherorder information about allowed patterns of non-zero coefficients [5, 6, 7, 8, 9], with successful applications in bioinformatics [6, 10], topic modeling [11] and computer vision [8].",
      "startOffset" : 265,
      "endOffset" : 269
    }, {
      "referenceID" : 7,
      "context" : "Much effort has recently been devoted to designing sparsity-inducing regularizations capable of encoding higherorder information about allowed patterns of non-zero coefficients [5, 6, 7, 8, 9], with successful applications in bioinformatics [6, 10], topic modeling [11] and computer vision [8].",
      "startOffset" : 290,
      "endOffset" : 293
    }, {
      "referenceID" : 2,
      "context" : "Proximal methods have proven to be effective in this context, essentially because of their fast convergence rates and their ability to deal with large problems [3, 4].",
      "startOffset" : 160,
      "endOffset" : 166
    }, {
      "referenceID" : 3,
      "context" : "Proximal methods have proven to be effective in this context, essentially because of their fast convergence rates and their ability to deal with large problems [3, 4].",
      "startOffset" : 160,
      "endOffset" : 166
    }, {
      "referenceID" : 11,
      "context" : "While the settings where the penalized groups of variables do not overlap [12] or are embedded in a tree-shaped hierarchy [11] have already been studied, sparsityinducing regularizations of general overlapping groups have, to the best of our knowledge, never been considered within the proximal method framework.",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 10,
      "context" : "While the settings where the penalized groups of variables do not overlap [12] or are embedded in a tree-shaped hierarchy [11] have already been studied, sparsityinducing regularizations of general overlapping groups have, to the best of our knowledge, never been considered within the proximal method framework.",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 12,
      "context" : "When one knows a priori that the solutions of this learning problem only have a few non-zero coefficients, Ω is often chosen to be the l1-norm, leading for instance to the Lasso [13].",
      "startOffset" : 178,
      "endOffset" : 182
    }, {
      "referenceID" : 11,
      "context" : "When these coefficients are organized in groups, a penalty encoding explicitly this prior knowledge can improve the prediction performance and/or interpretability of the learned models [12, 14, 15, 16].",
      "startOffset" : 185,
      "endOffset" : 201
    }, {
      "referenceID" : 13,
      "context" : "When these coefficients are organized in groups, a penalty encoding explicitly this prior knowledge can improve the prediction performance and/or interpretability of the learned models [12, 14, 15, 16].",
      "startOffset" : 185,
      "endOffset" : 201
    }, {
      "referenceID" : 14,
      "context" : "When these coefficients are organized in groups, a penalty encoding explicitly this prior knowledge can improve the prediction performance and/or interpretability of the learned models [12, 14, 15, 16].",
      "startOffset" : 185,
      "endOffset" : 201
    }, {
      "referenceID" : 15,
      "context" : "When these coefficients are organized in groups, a penalty encoding explicitly this prior knowledge can improve the prediction performance and/or interpretability of the learned models [12, 14, 15, 16].",
      "startOffset" : 185,
      "endOffset" : 201
    }, {
      "referenceID" : 6,
      "context" : "A sum of l2-norms is also used in the literature [7], but the l∞-norm is piecewise linear, a property that we take advantage of in this paper.",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 4,
      "context" : "When the groups overlap, Ω is still a norm and sets groups of variables to zero together [5].",
      "startOffset" : 89,
      "endOffset" : 92
    }, {
      "referenceID" : 6,
      "context" : "The latter setting has first been considered for hierarchies [7, 10, 17], and then extended to general group structures [5].",
      "startOffset" : 61,
      "endOffset" : 72
    }, {
      "referenceID" : 9,
      "context" : "The latter setting has first been considered for hierarchies [7, 10, 17], and then extended to general group structures [5].",
      "startOffset" : 61,
      "endOffset" : 72
    }, {
      "referenceID" : 16,
      "context" : "The latter setting has first been considered for hierarchies [7, 10, 17], and then extended to general group structures [5].",
      "startOffset" : 61,
      "endOffset" : 72
    }, {
      "referenceID" : 4,
      "context" : "The latter setting has first been considered for hierarchies [7, 10, 17], and then extended to general group structures [5].",
      "startOffset" : 120,
      "endOffset" : 123
    }, {
      "referenceID" : 10,
      "context" : "Following [11] who tackled the case of hierarchical groups, we propose to approach this problem with proximal methods, which we now introduce.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 17,
      "context" : "1 Proximal Methods In a nutshell, proximal methods can be seen as a natural extension of gradient-based techniques, and they are well suited to minimizing the sum f + λΩ of two convex terms, a smooth function f —continuously differentiable with Lipschitz-continuous gradient— and a potentially non-smooth function λΩ (see [18] and references therein).",
      "startOffset" : 322,
      "endOffset" : 326
    }, {
      "referenceID" : 2,
      "context" : "Simple proximal method use w as the next iterate, but accelerated variants [3, 4] are also based on the proximal operator and require to solve problem (3) exactly and efficiently to enjoy their fast convergence rates.",
      "startOffset" : 75,
      "endOffset" : 81
    }, {
      "referenceID" : 3,
      "context" : "Simple proximal method use w as the next iterate, but accelerated variants [3, 4] are also based on the proximal operator and require to solve problem (3) exactly and efficiently to enjoy their fast convergence rates.",
      "startOffset" : 75,
      "endOffset" : 81
    }, {
      "referenceID" : 17,
      "context" : "(3) is obtained by a soft-thresholding [18].",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 10,
      "context" : "The approach we develop in the rest of this paper extends [11] to the case of general overlapping groups when Ω is a weighted sum of l∞-norms, broadening the application of these regularizations to a wider spectrum of problems.",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 10,
      "context" : "We start by considering the dual formulation to problem (3) introduced in [11], for the case where Ω is a sum of l∞-norms: Note that other types of structured sparse models have also been introduced, either through a different norm [6], or through non-convex criteria [8, 9].",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 5,
      "context" : "We start by considering the dual formulation to problem (3) introduced in [11], for the case where Ω is a sum of l∞-norms: Note that other types of structured sparse models have also been introduced, either through a different norm [6], or through non-convex criteria [8, 9].",
      "startOffset" : 232,
      "endOffset" : 235
    }, {
      "referenceID" : 7,
      "context" : "We start by considering the dual formulation to problem (3) introduced in [11], for the case where Ω is a sum of l∞-norms: Note that other types of structured sparse models have also been introduced, either through a different norm [6], or through non-convex criteria [8, 9].",
      "startOffset" : 268,
      "endOffset" : 274
    }, {
      "referenceID" : 8,
      "context" : "We start by considering the dual formulation to problem (3) introduced in [11], for the case where Ω is a sum of l∞-norms: Note that other types of structured sparse models have also been introduced, either through a different norm [6], or through non-convex criteria [8, 9].",
      "startOffset" : 268,
      "endOffset" : 274
    }, {
      "referenceID" : 10,
      "context" : "For hierarchies, the approach of [11] applies also to the case of where Ω is a weighted sum of l2-norms.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 10,
      "context" : "Lemma 1 (Dual of the proximal problem [11]) Given u in R, consider the problem",
      "startOffset" : 38,
      "endOffset" : 42
    }, {
      "referenceID" : 10,
      "context" : "(4) derived in [11] show that for all j in [1; p], the signs of the non-zero coefficients ξ j for g in G are the same as the signs of the entries uj .",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 10,
      "context" : "The graphs (c) and (d) correspond to a special case of tree-structured hierarchy in the sense of [11].",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 18,
      "context" : "2 Computation of the Proximal Operator Quadratic min-cost flow problems have been well studied in the operations research literature [19].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 19,
      "context" : "It has been shown, both in machine learning [20] and operations research [19, 21], that such a projection can be done in O(p) operations.",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 18,
      "context" : "It has been shown, both in machine learning [20] and operations research [19, 21], that such a projection can be done in O(p) operations.",
      "startOffset" : 73,
      "endOffset" : 81
    }, {
      "referenceID" : 20,
      "context" : "It has been shown, both in machine learning [20] and operations research [19, 21], that such a projection can be done in O(p) operations.",
      "startOffset" : 73,
      "endOffset" : 81
    }, {
      "referenceID" : 10,
      "context" : "When the group structure is a tree as in Figure 1(d), strategies developed in the two communities are also similar [11, 19], and solve the problem in O(pd) operations, where d is the depth of the tree.",
      "startOffset" : 115,
      "endOffset" : 123
    }, {
      "referenceID" : 18,
      "context" : "When the group structure is a tree as in Figure 1(d), strategies developed in the two communities are also similar [11, 19], and solve the problem in O(pd) operations, where d is the depth of the tree.",
      "startOffset" : 115,
      "endOffset" : 123
    }, {
      "referenceID" : 18,
      "context" : "Hochbaum and Hong have shown in [19] that quadratic min-cost flow problems can be reduced to a specific parametric max-flow problem, for which an efficient algorithm exists [22].",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 21,
      "context" : "Hochbaum and Hong have shown in [19] that quadratic min-cost flow problems can be reduced to a specific parametric max-flow problem, for which an efficient algorithm exists [22].",
      "startOffset" : 173,
      "endOffset" : 177
    }, {
      "referenceID" : 21,
      "context" : "Our method clearly shares some similarities with a simplified version of [22] presented in [23], namely a divide and conquer strategy.",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 22,
      "context" : "Our method clearly shares some similarities with a simplified version of [22] presented in [23], namely a divide and conquer strategy.",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 23,
      "context" : "Then, the maximum-flow step [24] tries to find a feasible flow such that the vector ξ̄ matches γ.",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 24,
      "context" : "If ξ̄ 6= γ, the lower bound cannot be reached, and we construct a minimum (s, t)-cut of the graph [25] that defines two disjoints sets of nodes V + and V ; V + is the part of the graph that can potentially receive more flow from the source, whereas all arcs linking s to V − are saturated.",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 25,
      "context" : "The properties of a min (s, t)-cut [26] imply that there are no arcs from V + to V − (arcs inside V have infinite By definition, a parametric max-flow problem consists in solving, for every value of a parameter, a max-flow problem on a graph whose arc capacities depend on this parameter.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 18,
      "context" : "The approach of [19, 22] is guaranteed to have the same worst-case complexity as a single maxflow algorithm.",
      "startOffset" : 16,
      "endOffset" : 24
    }, {
      "referenceID" : 21,
      "context" : "The approach of [19, 22] is guaranteed to have the same worst-case complexity as a single maxflow algorithm.",
      "startOffset" : 16,
      "endOffset" : 24
    }, {
      "referenceID" : 23,
      "context" : "• Efficient max-flow algorithm: We have implemented the “push-relabel” algorithm of [24] to solve our max-flow problems, using classical heuristics that significantly speed it up in practice (see [24, 27]).",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 23,
      "context" : "• Efficient max-flow algorithm: We have implemented the “push-relabel” algorithm of [24] to solve our max-flow problems, using classical heuristics that significantly speed it up in practice (see [24, 27]).",
      "startOffset" : 196,
      "endOffset" : 204
    }, {
      "referenceID" : 26,
      "context" : "• Efficient max-flow algorithm: We have implemented the “push-relabel” algorithm of [24] to solve our max-flow problems, using classical heuristics that significantly speed it up in practice (see [24, 27]).",
      "startOffset" : 196,
      "endOffset" : 204
    }, {
      "referenceID" : 23,
      "context" : "Our implementation uses the so-called “highest-active vertex selection rule, global and gap heuristics” (see [24, 27]), and has a worst-case complexity of O(|V ||E|) for a graph (V,E, s, t).",
      "startOffset" : 109,
      "endOffset" : 117
    }, {
      "referenceID" : 26,
      "context" : "Our implementation uses the so-called “highest-active vertex selection rule, global and gap heuristics” (see [24, 27]), and has a worst-case complexity of O(|V ||E|) for a graph (V,E, s, t).",
      "startOffset" : 109,
      "endOffset" : 117
    }, {
      "referenceID" : 20,
      "context" : "This modified projection step can still be computed in linear time [21].",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 4,
      "context" : "3 Computation of the Dual Norm The dual norm Ω of Ω, defined for any vector κ in R by Ω(κ) , maxΩ(z)≤1 zκ, is a key quantity to study sparsity-inducing regularizations [5, 17, 28].",
      "startOffset" : 168,
      "endOffset" : 179
    }, {
      "referenceID" : 16,
      "context" : "3 Computation of the Dual Norm The dual norm Ω of Ω, defined for any vector κ in R by Ω(κ) , maxΩ(z)≤1 zκ, is a key quantity to study sparsity-inducing regularizations [5, 17, 28].",
      "startOffset" : 168,
      "endOffset" : 179
    }, {
      "referenceID" : 27,
      "context" : "3 Computation of the Dual Norm The dual norm Ω of Ω, defined for any vector κ in R by Ω(κ) , maxΩ(z)≤1 zκ, is a key quantity to study sparsity-inducing regularizations [5, 17, 28].",
      "startOffset" : 168,
      "endOffset" : 179
    }, {
      "referenceID" : 28,
      "context" : "We denote by f the Fenchel conjugate of f [29], defined by f(κ) , supz[z κ−f(z)].",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 28,
      "context" : "The duality gap for problem (1) can be derived from standard Fenchel duality arguments [29] and it is equal to f(w) + λΩ(w) + f(−κ) for w,κ in R with Ω(κ) ≤ λ.",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 3,
      "context" : "4 Applications and Experiments Our experiments use the algorithm of [4] based on our proximal operator, with weights ηg set to 1.",
      "startOffset" : 68,
      "endOffset" : 71
    }, {
      "referenceID" : 7,
      "context" : "2 Background Subtraction Following [8], we consider a background subtraction task.",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 29,
      "context" : "This approach is reminiscent of [30] in the context of face recognition, where e is further made sparse to deal with small occlusions.",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 10,
      "context" : "3 Multi-Task Learning of Hierarchical Structures In [11], Jenatton et al.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 10,
      "context" : "In [11], the dictionary elements are embedded in a predefined tree T , via a particular instance of the structured norm Ω, which we refer to it as Ωtree, and call G the underlying set of groups.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 15,
      "context" : "Inspired by ideas from multi-task learning [16], we propose to learn the tree structure T by pruning irrelevant parts of a larger initial tree T0.",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 10,
      "context" : "In other words, the approach of [11] is extended by the following http://research.",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 10,
      "context" : "To address problem (6), we use the same optimization scheme as [11], i.",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 10,
      "context" : "The task we consider is the denoising of natural image patches, with the same dataset and protocol as [11].",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 10,
      "context" : ", when Ωtree is the l1-norm and λ2 = 0) and the hierarchical dictionary learning of [11] based on predefined trees (i.",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 10,
      "context" : "We consider the same hierarchies as in [11], involving between 30 and 400 dictionary elements.",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 0,
      "context" : "2 (the pixels have values in [0, 1]); no significant improvements were observed for lower levels of noise.",
      "startOffset" : 29,
      "endOffset" : 35
    }, {
      "referenceID" : 13,
      "context" : "The simplified case where Ωtree and Ωjoint are the l1- and mixed l1/l2-norms [14] corresponds to [31].",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 30,
      "context" : "The simplified case where Ωtree and Ωjoint are the l1- and mixed l1/l2-norms [14] corresponds to [31].",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 25,
      "context" : "1 in [26]), saying that there exists a decomposition of π as a sum of path flows in E.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 10,
      "context" : "This requires that we introduce the optimality conditions for problem (4) derived in [11], since our convergence proof essentially checks that these conditions are satisfied upon termination of the algorithm.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 10,
      "context" : "Lemma 3 (Optimality conditions of the problem (4), [11]) The primal-dual variables (w, ξ) are respectively solutions of the primal (3) and dual problems (4) if and only if the dual variable ξ is feasible for the problem (4) and w = u− ∑ g∈G ξ , ∀g ∈ G, { w g ξ g g = ‖wg‖∞‖ξ ‖1 and ‖ξ ‖1 = ληg, or wg = 0.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 25,
      "context" : "• There is no flow going from V − to V + (see properties of the minimum (s, t)-cut [26]).",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 24,
      "context" : "Using the classical max-flow/min-cut theorem [25], we have equality between these two terms.",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 4,
      "context" : "2 Computation of the Dual Norm Ω Similarly to the proximal operator, the computation of dual norm Ω can itself shown to solve another network flow problem, based on the following variational formulation, which extends a previous result from [5]: Lemma 4 (Dual formulation of the dual-norm Ω.",
      "startOffset" : 241,
      "endOffset" : 244
    }, {
      "referenceID" : 31,
      "context" : "This primal problem is convex and satisfies Slater’s conditions for generalized conic inequalities, which implies that strong duality holds [32].",
      "startOffset" : 140,
      "endOffset" : 144
    }, {
      "referenceID" : 24,
      "context" : "j∈Vu κj is the value of the max-flow, and the inequality follows from the max-flow/min-cut theorem [25].",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 3,
      "context" : "C Algorithm FISTA with duality gap In this section, we describe in details the algorithm FISTA [4] when applied to solve problem (1), with a duality gap as stopping criterion.",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 28,
      "context" : "Based on Fenchel duality arguments [29], f(Xw) + λΩ(w) + f(−κ), for w ∈ R,κ ∈ R and Ω(Xκ) ≤ λ, is a duality gap for (14).",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 28,
      "context" : "Given a primal variable w, a good dual candidate κ can be obtained by looking at the conditions that have to be satisfied by the pair (w,κ) at optimality [29].",
      "startOffset" : 154,
      "endOffset" : 158
    }, {
      "referenceID" : 18,
      "context" : "1 Speed comparison of Algorithm 1 with parametric max-flow algorithms As shown in [19], min-cost flow problems, and in particular, the dual problem of (3), can be reduced to a specific parametric max-flow problem.",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 21,
      "context" : "efficient parametric max-flow algorithm proposed by Gallo, Grigoriadis, and Tar- jan [22] and a simplified version of the latter proposed by Babenko and Goldberg in [23].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 22,
      "context" : "efficient parametric max-flow algorithm proposed by Gallo, Grigoriadis, and Tar- jan [22] and a simplified version of the latter proposed by Babenko and Goldberg in [23].",
      "startOffset" : 165,
      "endOffset" : 169
    } ],
    "year" : 2010,
    "abstractText" : "We consider a class of learning problems that involve a structured sparsity-inducing norm defined as the sum of l∞-norms over groups of variables. Whereas a lot of effort has been put in developing fast optimization methods when the groups are disjoint or embedded in a specific hierarchical structure, we address here the case of general overlapping groups. To this end, we show that the corresponding optimization problem is related to network flow optimization. More precisely, the proximal problem associated with the norm we consider is dual to a quadratic min-cost flow problem. We propose an efficient procedure which computes its solution exactly in polynomial time. Our algorithm scales up to millions of variables, and opens up a whole new range of applications for structured sparse models. We present several experiments on image and video data, demonstrating the applicability and scalability of our approach for various problems. Key-words: network flow optimization, convex optimization, sparse methods, proximal algorithms ∗ Equal contribution. † INRIA WILLOW Project, Laboratoire d’Informatique de l’Ecole Normale Supérieure (INRIA/ENS/CNRS UMR 8548). 23, avenue d’Italie, 75214 Paris. France Algorithmes de Flots pour Parcimonie Structurée Résumé : Nous considérons une classe de problèmes d’apprentissage régularisés par une norme induisant de la parcimonie structurée, définie comme une somme de normes l∞ sur des groupes de variables. Alors que de nombreux efforts ont étés mis pour développer des algorithmes d’optimisation rapides lorsque les groupes sont disjoints ou structurés hiérarchiquement, nous nous intéressons au cas général de groupes avec recouvrement. Nous montrons que le problème d’optimisation correspondant est lié à l’optimisation de flots sur un réseau. Plus précisément, l’opérateur proximal associé à la norme que nous considérons est dual à la minimisation d’un coût quadratique de flot sur un graphe particulier. Nous proposons une procédure efficace qui calcule cette solution en un temps polynomial. Notre algorithme peut traiter de larges problèmes, comportant des millions de variables, et ouvre de nouveaux champs d’applications pour les modèles parcimonieux structurés. Nous présentons diverses expériences sur des données d’images et de vidéos, qui démontrent l’utilité et l’efficacité de notre approche pour résoudre de nombreux problèmes. Mots-clés : optimisation de flots, optimisation convexe, méthodes parcimonieuses, algorithmes proximaux Network Flow Algorithms for Structured Sparsity 3",
    "creator" : "LaTeX with hyperref package"
  }
}