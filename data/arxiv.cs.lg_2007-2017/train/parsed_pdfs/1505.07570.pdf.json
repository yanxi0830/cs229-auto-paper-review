{
  "name" : "1505.07570.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Practical Guide to Randomized Matrix Computations with MATLAB Implementations",
    "authors" : [ "Shusen Wang" ],
    "emails" : [ "wssatzju@gmail.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "A Practical Guide to Randomized Matrix Computations with MATLAB\nImplementations1\nShusen Wang wssatzju@gmail.com\nNovember 4, 2015\n1Sample MATLAB code with demos is available at https://github.com/wangshusen/RandMatrixMatlab.\nar X\niv :1\n50 5.\n07 57\n0v 6\n[ cs\n.M S]\n3 N\nov 2\n01 5\n2\nContents\nAbstract 1"
    }, {
      "heading" : "1 Introduction 3",
      "text" : ""
    }, {
      "heading" : "2 Elementary Matrix Algebra 5",
      "text" : "2.1 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n2.2 Matrix Decompositions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n2.3 Matrix (Pseudo) Inverse and Orthogonal Projector . . . . . . . . . . . . . . 6\n2.4 Time and Memory Costs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7"
    }, {
      "heading" : "3 Matrix Sketching 9",
      "text" : "3.1 Theoretical Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n3.2 Random Projection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n3.2.1 Gaussian Projection . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n3.2.2 Subsampled Randomized Hadamard Transform (SRHT) . . . . . . . 11\n3.2.3 Count Sketch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n3.2.4 GaussianProjection + CountSketch . . . . . . . . . . . . . . . . . . . 14\n3.3 Column Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n3.3.1 Uniform Sampling . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n3.3.2 Leverage Score Sampling . . . . . . . . . . . . . . . . . . . . . . . . . 15\n3.3.3 Local Landmark Selection . . . . . . . . . . . . . . . . . . . . . . . . 16"
    }, {
      "heading" : "4 Regression 19",
      "text" : "4.1 Standard Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n4.2 Inexact Solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n4.2.1 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n4.2.2 Theoretical Explanation . . . . . . . . . . . . . . . . . . . . . . . . . 20\n4.3 Machine-Precision Solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n4.3.1 Basic Idea: Preconditioning . . . . . . . . . . . . . . . . . . . . . . . 21\n4.3.2 Algorithm Description . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n4.4 Extension: CX-Type Regression . . . . . . . . . . . . . . . . . . . . . . . . . 22\n4.5 Extension: CUR-Type Regression . . . . . . . . . . . . . . . . . . . . . . . . 23\ni"
    }, {
      "heading" : "5 Rank k Singular Value Decomposition 25",
      "text" : "5.1 Standard Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 5.2 Prototype Randomized k-SVD Algorithm . . . . . . . . . . . . . . . . . . . . 26\n5.2.1 Theoretical Explanation . . . . . . . . . . . . . . . . . . . . . . . . . 26 5.2.2 Algorithm Derivation . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 5.2.3 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n5.3 Faster Randomized k-SVD . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 5.3.1 Theoretical Explanation . . . . . . . . . . . . . . . . . . . . . . . . . 28 5.3.2 Algorithm Derivation . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 5.3.3 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29"
    }, {
      "heading" : "6 SPSD Matrix Sketching 31",
      "text" : "6.1 Motivations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n6.1.1 Forming a Kernel Matrix . . . . . . . . . . . . . . . . . . . . . . . . . 31 6.1.2 Matrix Inversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 6.1.3 Eigenvalue Decomposition . . . . . . . . . . . . . . . . . . . . . . . . 33\n6.2 Prototype Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 6.3 Faster SPSD Matrix Sketching . . . . . . . . . . . . . . . . . . . . . . . . . . 34 6.4 The Nyström Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 6.5 More Efficient Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n6.5.1 Memory Efficient Kernel Approximation (MEKA) . . . . . . . . . . . 37 6.5.2 Structured Kernel Interpolation (SKI) . . . . . . . . . . . . . . . . . 38\n6.6 Extension to Rectangular Matrices: CUR Matrix Decomposition . . . . . . . 38 6.6.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 6.6.2 Prototype CUR Decomposition . . . . . . . . . . . . . . . . . . . . . 39 6.6.3 Faster CUR Decomposition . . . . . . . . . . . . . . . . . . . . . . . 39 6.7 Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 6.7.1 Kernel Principal Component Analysis (KPCA) . . . . . . . . . . . . 41 6.7.2 Spectral Clustering . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 6.7.3 Gaussian Process Regression (GPR) . . . . . . . . . . . . . . . . . . . 43"
    }, {
      "heading" : "A Several Facts of Matrix Algebra 47",
      "text" : ""
    }, {
      "heading" : "B Notes and Further Reading 49",
      "text" : "Bibliography 49\nii\nAbstract\nMatrix operations such as matrix inversion, eigenvalue decomposition, singular value decomposition are ubiquitous in real-world applications. Unfortunately, many of these matrix operations so time and memory expensive that they are prohibitive when the scale of data is large. In real-world applications, since the data themselves are noisy, machine-precision matrix operations are not necessary at all, and one can sacrifice a reasonable amount of accuracy for computational efficiency.\nIn recent years, a bunch of randomized algorithms have been devised to make matrix computations more scalable. Mahoney [16] and Woodruff [34] have written excellent but very technical reviews of the randomized algorithms. Differently, the focus of this paper is on intuition, algorithm derivation, and implementation. This paper should be accessible to people with knowledge in elementary matrix algebra but unfamiliar with randomized matrix computations. The algorithms introduced in this paper are all summarized in a user-friendly way, and they can be implemented in lines of MATLAB code. The readers can easily follow the implementations even if they do not understand the maths and algorithms.\nKeywords: matrix computation, randomized algorithms, matrix sketching, random projection, random selection, least squares regression, randomized SVD, matrix inversion, eigenvalue decomposition, kernel approximation, the Nyström method.\n1\n2\nChapter 1\nIntroduction\nMatrix computation plays a key role in modern data science. However, matrix computations such as matrix inversion, eigenvalue decomposition, SVD, etc, are very time and memory expensive, which limits their scalability and applications. To make large-scale matrix computation possible, randomized matrix approximation techniques have been proposed and widely applied. Especially in the past decade, remarkable progresses in randomized numerical linear algebra has been made, and now large-scale matrix computations are no longer impossible tasks.\nThis paper reviews the most recent progresses of randomized matrix computation. The papers written by Mahoney [16] and Woodruff [34] provide comprehensive and rigorous reviews of the randomized matrix computation algorithms. However, their focus are on the theoretical properties and error analysis techniques, and readers unfamiliar with randomized numerical linear algebra can have difficulty when implementing their algorithms.\nDifferently, the focus of this paper is on intuitions and implementations, and the target readers are those who are familiar with basic matrix algebra but has little knowledge in randomized matrix computations. All the algorithms in this paper are described in a userfriend way. This paper also provides MATLAB implementations of the important algorithms. MATLAB code is easy to understand1, easy to debug, and easy to translate to other languages. The users can even directly use the provided MATLAB code without understanding it.\nThis paper covers the following topics:\n• Chapter 2 briefly reviews some matrix algebra preliminaries. This chapter can be skipped if the reader is familiar with matrix algebra.\n• Chapter 3 introduces the techniques for generating a sketch of a large-scale matrix.\n• Chapter 4 studies the least squares regression (LSR) problem where n d.\n• Chapter 5 studies efficient algorithms for computing the k-SVD of arbitrary matrices. 1If your are unfamiliar with a MATLAB function, you can simply type “help + functionname” in MAT-\nLAB and read the documentation.\n3\n• Chapter 6 introduces techniques for sketching symmetric positive semi-definite (SPSD) matrices. The applications includes spectral clustering, kernel methods (e.g. Gaussian process regression and kernel PCA), and second-order optimization (e.g. Newton’s method).\n4\nChapter 2\nElementary Matrix Algebra\nThis chapter defines the matrix notation and goes through the very basics of matrix decompositions. Particularly, the singular value decomposition (SVD), the QR decomposition, and the Moore-Penrose inverse are used throughout this paper."
    }, {
      "heading" : "2.1 Notation",
      "text" : "Let A = [aij] be a matrix, a = [ai] be a column vector, and a be a scalar. The i-th row and j-th column of A are denoted by ai: and a:j, respectively. When there is no ambiguity, either column or row can be written as al. Let In be the n× n identity matrix, that is, the diagonal entries are ones and off-diagonal entries are zeros. The column space (the space spanned by the columns) of A is the set of all possible linear combinations of its column vectors. Let [n] be the set {1, 2, · · · , n}. Let nnz(A) be the number of nonzero entries of A.\nThe squared vector `2 norm is defined by ‖a‖22 = ∑ i a2i .\nThe squared matrix Frobenius norm is defined by ‖A‖F = ∑ ij a2ij,\nand the matrix spectral norm is defined by\n‖A‖2 = max x 6=0 ‖Ax‖2 ‖x‖2 ."
    }, {
      "heading" : "2.2 Matrix Decompositions",
      "text" : "QR decomposition. Let A be an m×n matrix with m ≥ n. The QR decomposition of A is\nA = QA︸︷︷︸ m×n RA︸︷︷︸ n×n .\n5\nThe matrix QA has orthonormal columns, that is, Q T AQA = In. The matrix RA is upper triangular, that is, for all i < j, the (i, j)-th entry of RA is zero. SVD. Let A be an m × n matrix and ρ = rank(A). The condensed singular value decomposition (SVD) of A is\nA︸︷︷︸ m×n = UA︸︷︷︸ m×ρ ΣA︸︷︷︸ ρ×ρ VTA︸︷︷︸ ρ×n = ρ∑ i=1 σA,iuA,iv T A,i.\nHere σA,1 ≥ · · · ≥ σA,ρ > 0 are the singular values, uA,1, · · · ,uA,ρ ∈ Rm are the left singular vectors, and vA,1, · · · ,vA,ρ ∈ Rn are the right singular vectors. Unless otherwise specified, “SVD” refers to the condensed SVD.\nk-SVD. In applications such as the principal component analysis (PCA), latent semantic indexing (LSI), word2vec, spectral clustering, we are only interested in the top k ( m,n) singular values and singular vectors. The rank k truncated SVD (k-SVD) is denoted by\nAk := k∑ i=1 σA,iuA,iv T A,i = UA,k︸ ︷︷ ︸\nm×k ΣA,k︸︷︷︸ k×k VTA,k︸ ︷︷ ︸ k×n .\nHere UA,k consists of the first k singular vectors of UA, and ΣA,k and VV,k are analogously defined. Among all the m×n rank k matrices, Ak is the closest approximation to A in that\nAk = argmin X ‖A−X‖2F = argmin X ‖A−X‖22, s.t. rank(X) ≤ k.\nEigenvalue decomposition. The eigenvalue decomposition of an n × n symmetric matrix A is defined by\nA = UAΛAU T A = n∑ i=1 λA,iuA,iu T A,i.\nHere λA,1 ≥ · · · ≥ λA,n are the eigenvalues of A, and uA,1, · · · ,uA,n ∈ Rn are the corresponding eigenvectors. A symmetric matrix A is called symmetric positive semidefinite (SPSD) if and only if all the eigenvalues are nonnegative. If A is SPSD, its SVD and eigenvalue decomposition are identical."
    }, {
      "heading" : "2.3 Matrix (Pseudo) Inverse and Orthogonal Projector",
      "text" : "For an n× n square matrix A, the matrix inverse exists if A is non-singular (rank(A) = n). Let A−1 be the inverse of A. Then AA−1 = A−1A = In.\nOnly square and full rank matrices have inverse. For the general rectangular matrices or rank deficient matrices, matrix pseudo-inverse is used as a generalization of matrix inverse. The book [1] offers a comprehensive study of the pseudo-inverses.\n6\nThe Moore-Penrose inverse is the most widely used pseudo-inverse, which is defined by\nA† := VAΣ −1 A U T A.\nLet A be any m× n and rank ρ matrix. Then\nAA† = UAΣA V T AVA︸ ︷︷ ︸ =Iρ Σ−1A U T A = UA︸︷︷︸ m×ρ UTA︸︷︷︸ ρ×m ,\nwhich is a orthogonal projector. It is because for any matrix B, the matrix AA†B = UAU T AB is the projection of B onto the column space of A."
    }, {
      "heading" : "2.4 Time and Memory Costs",
      "text" : "The time complexities of the matrix operations are listed in the following.\n• Multiplying an m× n matrix A by an n× p matrix B: O(mnp) float point operations (flops) in general, and O(p · nnz(A)) if A is sparse. Here nnz(A) is the number of nonzero entries of A.\n• QR decomposition, SVD, or Moore-Penrose inverse of an m × n matrix (m ≥ n): O(mn2) flops.\n• k-SVD of an m × n matrix: O(nmk) flops (assuming that the spectral gap and the logarithm of error tolerance are constant)\n• Matrix inversion or full eigenvalue decomposition of an n× n matrix: O(n3) flops\n• k-eigenvalue decomposition of an n× n matrix: O(n2k) flops.\nPass-efficient means that the algorithm goes constant passes through the data. For example, the Frobenius norm of a matrix can be computed pass-efficiently, because each entry is visited only once. In comparison, the spectral norm cannot be computed passefficiently, because the algorithm goes at least log 1 passes through the matrix, which is not constant. Here indicates the desired precision. Memory cost. If an algorithm scans a matrix for constant passes, the matrix can be placed in large volume disks, so the memory cost is not a bottleneck. However, if an algorithm goes through a matrix for many passes (not constant passes), the matrix should be placed in memory, otherwise the swaps between memory and disk would be highly expensive. In this paper, memory cost means the number of entries frequently visited by the algorithm.\n7\n8\nChapter 3\nMatrix Sketching\nLet A ∈ Rm×n be the given matrix, S ∈ Rn×s be a sketching matrix, e.g. random projection or column selection matrix, and C = AS ∈ Rm×s be a sketch of A. The size of C is much smaller than A, but C preserves some important properties of A."
    }, {
      "heading" : "3.1 Theoretical Properties",
      "text" : "The sketching matrix is useful if it has either or both of the following properties. The two properties are important, and the readers should try to understand them.\nProperty 3.1 (Subspace Embedding). For a fixed m × n (m n) matrix A and all mdimension vector y, the inequality\n1 γ ≤ ‖y TAS‖22 ‖yTA‖22 ≤ γ\nholds with high probability. Here S ∈ Rn×s (s n) is a certain sketching matrix.\nThe subspace embedding property can be intuitively understood in the following way. For all n dimensional vectors x in the row space of A (a rank m subspace within Rn),1 the length of vector x does not change much after sketching: ‖x‖22 ≈ ‖xS‖22. This property can be applied to speedup the `2 regression problems.\nProperty 3.2 (Low-Rank Approximation). Let A be any m×n matrix and k be any positive integer far smaller than m and n. Let C = AS ∈ Rm×s where S ∈ Rn×s is a certain sketching matrix and s ≥ k. The Frobenius norm error bound2\n‖A−CC†A‖2F ≤ η‖A−Ak‖2F\nholds with high probability for some η ≥ 1. 1Thus there always exists an m dimensional vector y such that x can be expressed as x = yTA. 2Spectral norm bounds should be more interesting. However, spectral norm error is difficult to analyze, and existing spectral norm bounds are “weak” for their factors η are far greater than 1.\n9\nThe following error bound is stronger and more interesting:\nmin rank(X)≤k\n‖A−CX‖2F ≤ η‖A−Ak‖2F ."
    }, {
      "heading" : "It is stronger because ‖A−CC†A‖2F ≤ minrank(X)≤k ‖A−CX‖2F .",
      "text" : "Intuitively speaking, the low-rank approximation property means that the columns of Ak are almost in the column space of C = AP. The low-rank approximation property enables us to solve k-SVD more efficiently (for k ≤ s). Later on we will see that computing the k-SVD of CC†A is less expensive than the k-SVD of A.\nThe two properties can be verified by a few lines of MATLAB code. The readers are encouraged to have a try. With a proper sketching method and a relatively large s, both γ and η should be near one."
    }, {
      "heading" : "3.2 Random Projection",
      "text" : "The section presents three matrix sketching techniques: Gaussian projection, subsampled randomized Hadamard transform (SRHT), and count sketch. Gaussian projection and SRHT can be combined with count sketch."
    }, {
      "heading" : "3.2.1 Gaussian Projection",
      "text" : "The n× s Gaussian random projection matrix S is a matrix is formed by S = 1√ s G, where each entry of G is sampled i.i.d. from N (0, 1). The Gaussian projection is also well knows as the Johnson-Lindenstrauss transform due to the seminal work [15]. Gaussian projection can be implemented in four lines of MATLAB code.\n1 f unc t i on [C] = Gauss ianPro jec t ion (A, s ) 2 n = s i z e (A, 2) ; 3 S = randn (n , s ) / s q r t ( s ) ; 4 C = A ∗ S ;\nGaussian projection has the following properties:\n• Time cost: O(mns)\n• Theoretical guarantees\n1. When s = O(m/ 2), the subspace embedding property with γ = 1 + holds with high probability.\n2. When s = k\n+ 1, the low-rank approximation property with η = 1 + holds in expectation [3].\n• Advantages\n10\n1. Easy to implement: four lines of MATLAB code\n2. C is a very high quality sketch of A\n• Disadvantages:\n1. High time complexity to perform matrix multiplication\n2. Sparsity is destroyed: C is dense even if A is sparse"
    }, {
      "heading" : "3.2.2 Subsampled Randomized Hadamard Transform (SRHT)",
      "text" : "The Subsampled Randomized Hadamard Transform (SRHT) matrix is defined by S = 1√ sn DHnP, where\n• D ∈ Rn×n is a diagonal matrix with diagonal entries sampled uniformly from {+1,−1};\n• Hn ∈ Rn×n is defined recursively by\nHn = [ Hn/2 Hn/2 Hn/2 −Hn/2 ] and H2 = [ +1 +1 +1 −1 ] ;\nFor all y ∈ Rn, the matrix vector product yTHn can be performed in O(n log n) time by the fast Walsh–Hadamard transform algorithm in a divide-and-conquer fashion;\n• P ∈ Rn×s samples s from the n columns.\nSRHT can be implemented in nine lines of MATLAB code below. Notice that this implementation of SRHT is has O(mN logN) (N ≥ n is a power of two) time complexity, which is not efficient.\n1 f unc t i on [C] = s rht (A, s ) 2 n = s i z e (A, 2) ; 3 sgn = randi (2 , [ 1 , n ] ) ∗ 2 − 3 ; % one h a l f are +1 and the r e s t are −1 4 A = bsxfun ( @times , A, sgn ) ; % f l i p the s i g n s o f each column w. p . 50% 5 n = 2ˆ( c e i l ( l og2 (n) ) ) ; 6 C = ( fwht (A’ , n ) ) ’ ; % f a s t Walsh−Hadarmard trans form 7 idx = s o r t ( randsample (n , s ) ) ; 8 C = C( : , idx ) ; % subsampling 9 C = C ∗ (n / s q r t ( s ) ) ;\nThe SRHT matrix has the following properties:\n• Time complexity: the matrix product AS can be performed in O(mn log s) time, which makes SRHT more efficient than Gaussian projection. (Unfortunately, the MATLAB code above does not have such low time complexity.)\n• Theoretical property: when s = O( −2(m+ log n) logm), SRHT satisfies the subspace embedding property with γ = 1 + holds with probability 0.99 [34, Theorem 7].\n11"
    }, {
      "heading" : "3.2.3 Count Sketch",
      "text" : "Count sketch stems from the data stream literature [4; 26]. It was applied to speedup matrix computation by [6; 21]. We describe in the following the count sketch for matrix data.\nThere are different ways to implementing count sketch. This paper describe two quite different ways and refer to them as “map-reduce fashion” and “streaming fashion”. Of course, the two are equivalent.\n• The map-reduce fashion has three steps. First, hash each column with a discrete value uniformly sampled from [s]. Second, flip the sign of each column with probability 50%. Third, sum up columns with the same hash value. This procedure is illustrated in\n12\nAlgorithm 3.1 Count Sketch in the Streaming Fashion.\n1: input: A ∈ Rm×n. 2: Initialize C to be an m× s all-zero matrix; 3: for i = 1 to n do 4: sample l from the set [s] uniformly at random; 5: sample g from the set {+1,−1} uniformly at random; 6: update the l-th column of C by c:l ←− c:l + ga:i; 7: end for 8: return C ∈ Rm×s.\nFigure 3.1. As its name suggests, this approach naturally fits the map-reduce systems.\n• The streaming fashion has two steps. First, initialize C to be the m × s all-zero matrix. Second, for each column of A, flip its sign with probability 50%, and add it to a uniformly selected column of C. It is described in Algorithm 3.1 an illustrated in Figure 3.2. It can be implemented in 9 lines of MATLAB code as below. The streaming fashion implementation keeps the sketch C in memory and scans the data A in only one pass. If A does not fit in memory, this approach is better than the mapreduce fashion for it scans the columns sequentially. If A is sparse matrix, randomly accessing the entries may not be efficient, and thus it is better to accessing the column sequentially.\n1 f unc t i on [C] = CountSketch (A, s ) % the streaming f a s h i o n 2 [m, n ] = s i z e (A) ; 3 sgn = randi (2 , [ 1 , n ] ) ∗ 2 − 3 ; % one h a l f are +1 and the r e s t are −1 4 A = bsxfun ( @times , A, sgn ) ; % f l i p the s i g n s o f each column w. p . 50% 5 l l = randsample ( s , n , t rue ) ; % sample n items from [ s ] with replacement 6 C = ze ro s (m, s ) ; % i n i t i a l i z e C 7 f o r j = 1 : n 8 C( : , l l ( j ) ) = C( : , l l ( j ) ) + A( : , j ) ; 9 end\nThe readers may have noticed that count sketch does not explicitly form the sketching matrix S. In fact, S is such a matrix that each row has only one nonzero entry. In the example of Figure 3.1, the matrix ST can be explicitly expressed as\nST =  0 0 1 0 1 −1 1 −1 −1 1 0 0 0 0 0−1 0 0 −1 0 0 0 0 0 0 0 −1 1 −1 −1 0 −1 0 0 0 0 0 0 0 0 1 0 0 0 0  . Count sketch has the following properties:\n• Time cost: O(nnz(A))\n• Memory cost: O(ms). When A does not fit in memory, the algorithm keeps only C in memory and goes one pass through the columns of A.\n13\n• Theoretical guarantees\n1. When s = O(m2/ 2), the subspace embedding property holds with γ = 1 + with high probability.\n2. When s = O(k/ +k2), the low-rank approximation property holds with η = 1+ relative error with high probability.\n• Advantage: the count sketch is very efficient, especially when A is sparse.\n• Disadvantage: compared with Gaussian projection, the count sketch requires larger s to attain the same accuracy. One simple improvement is to combine the count sketch with Gaussian projection or SRHT."
    }, {
      "heading" : "3.2.4 GaussianProjection + CountSketch",
      "text" : "Let Ssc be n × scs count sketch matrix, Sgp be scs × s Gaussian projection matrix, and S = ScsSgp ∈ Rn×s. Then S satisfies the following properties.\n• Time complexity: the matrix product AS can be computed in\nO (\nnnz(A)︸ ︷︷ ︸ count sketch + mscss︸ ︷︷ ︸ Gaussian projection ) time.\n• Theoretical properties:\n14\n1. When scs = O(m2/ 2) and s = O(m/ 2), the GaussianProjection+CountSketch matrix S satisfy the subspace embedding property with γ = 1 + holds with high probability.\n2. When scs = O(k2 + k/ ) and s = O(k/ ), the GaussianProjection+CountSketch matrix S satisfies the low-rank approximation property with η = 1 + [2, Lemma 12].\n• Advantages:\n1. the size of GaussianProjection+CountSketch is as small as Gaussian projection.\n2. the time complexity is much lower than Gaussian projection when n m."
    }, {
      "heading" : "3.3 Column Selection",
      "text" : "This section presents three column selection techniques: uniform sampling, leverage score sampling, and local landmark selection. Different from random projection, column selection do not have to visit every entry of A, and column selection preserves the sparsity/nonnegativity properties of A."
    }, {
      "heading" : "3.3.1 Uniform Sampling",
      "text" : "Uniform sampling is the most efficient way to form a sketch. The most important advantage is that uniform sampling forms a sketch without seeing the whole data matrix. When applied to kernel methods, uniform sampling avoids computing every entry of the kernel matrix.\nThe performance of uniform sampling is data-dependent. When the leverage scores (defined in Section 3.3.2) are uniform, or equivalently, the matrix coherence (namely the greatest leverage score) is small, uniform sampling has good performance. The analysis of uniform sampling can be found in [12; 13]."
    }, {
      "heading" : "3.3.2 Leverage Score Sampling",
      "text" : "Before studying leverage score sampling, let’s first define leverage scores. Let A be an m×n matrix, with ρ = rank(A) < n, and V ∈ Rn×ρ be the right singular vectors. The (column) leverage scores of A are defined by\nli := ‖vi:‖22, for i = 1, · · · , n.\nLeverage score sampling is to select each columns of A with probability proportional to its leverage scores. (Sometimes each selected column should be scaled by √\nρ sli .) It can be\nroughly implemented in 8 lines MATLAB code.\n15\n1 f unc t i on [C, idx ] = LeverageScoreSampling (A, s ) 2 n = s i z e (A, 2) ; 3 [ ˜ , ˜ , V] = svd (A, ’ econ ’ ) ; 4 l e v e r a g e s c o r e s = sum(V. ˆ 2 , 2) ; 5 prob = l e v e r a g e s c o r e s / sum( l e v e r a g e s c o r e s ) ; 6 idx = randsample (n , s , true , prob ) ; 7 idx = unique ( idx ) ; % e l i m i n a t e d u p l i c a t e s 8 C = A( : , idx ) ;\nThere are a few things to remark:\n• To sample columns according to the leverage scores of Ak where k m,n, Line 3 can be replaced by\n3 [ ˜ , ˜ , V] = svds (A, k ) ;\n• Theoretical properties\n1. When s = O(m/ + m logm), the leverage score sampling satisfies the subspace embedding property with γ = 1 + holds with high probability.\n2. When s = O(k/ +k log k), the leverage score sampling (according to the leverage scores of Ak) satisfies the low-rank approximation property with η = 1 + .\n• Computing the leverage scores is as expensive as computing SVD, so leverage score sampling is not a practical way to sketch the matrix A itself.\n• When the leverage scores are near uniform, there is little difference between uniform sampling and leverage score sampling."
    }, {
      "heading" : "3.3.3 Local Landmark Selection",
      "text" : "Local landmark selection is a very effective heuristic for finding representative columns. Zhang and Kwok [36] proposed to set k = s and run k-means or k-centroids clustering algorithm to cluster the columns of A to s class, and use the s centroids as the sketch of A. This heuristic works very well in practice, though it has little theoretical guarantee.\nThere are several tricks to make the local landmark selection more efficient.\n• One can simply solve k-centroids clustering approximately rather than accurately. For example, it is unnecessary to wait for k-centroids clustering to converge; running kcentroids for a few iterations suffices.\n• When n is large, one can uniformly sample a subset of the data, e.g. max{0.2n, 20s} data points, and perform local landmark selection on this smaller dataset.\n16\n• In supervised learning problems, each datum ai is associated with a label yi. We can partition the data to g groups according to the labels and run k-centroids clustering independently on the data in each group. In this way, s = gk data points are selected as a sketch of A.\n17\n18\nChapter 4\nRegression\nLet A be an n× d (n ≥ d) matrix whose rows correspond to data and columns correspond to features, and let b ∈ Rn contain the response/label of each datum. The least squares regression (LSR)\nmin x ‖Ax− b‖22 (4.1)\nis a ubiquitous problem in statistics, computer science, economics, etc. When n d, LSR can be efficiently solved using randomized algorithms."
    }, {
      "heading" : "4.1 Standard Solutions",
      "text" : "The least squares regression (LSR) problem (4.1) has closed form solution\nx? = A†b.\nThe Moore-Penrose inverse can be computed by SVD which costs O(nd2) time. LSR can also be solved by numerical algorithms such as the conjugate gradient (CG) algorithm, and machine-precision can be attained in a reasonable number of iterations. Let κ(A) := σ1(A)\nσd(A) be the condition number of A. The convergence of CG depends on κ(A):\n‖A(x(t) − x?)‖22 ‖A(x(0) − x?)‖22 ≤ 2 ( κ(A)− 1 κ(A) + 1 )t ,\nwhere x(t) is the model in the t-th iteration of CG. The per-iteration time cost of CG is O(nnz(A)). To attain ‖A(x(t) − x?)‖22 ≤ , the number of iteration is roughly(\nlog 1 + log(InitialError) )κ(A)− 1 2 .\nSince the time cost of CG heavily depends on the unknown condition number κ(A), CG can be very slow if A is ill-conditioned.\n19"
    }, {
      "heading" : "4.2 Inexact Solution",
      "text" : "Any sketching matrix S ∈ Rn×s can be used to solve LSR approximately as long as it satisfies the subspace embedding property. We consider the following LSR problem:\nx̃ = min x ‖ (STA)︸ ︷︷ ︸\ns×d\nx− STb‖22, (4.2)\nwhich can be solved in O(sd2) time. If S is a Gaussian projection matrix, SRHT matrix, count sketch, or leverage score sampling matrix, and s = poly(d/ ) for any error parameter ∈ (0, 1], then\n‖Ax̃− b‖22 ≤ (1 + )2 min x ‖Ax− b‖22\nis guaranteed."
    }, {
      "heading" : "4.2.1 Implementation",
      "text" : "If S is count sketch matrix, the inexact LSR algorithm can be implemented in 5 lines of MATLAB code. Here CountSketch is a MATLAB function described in Section 3.2.3. The total time cost is O(nnz(A) + poly(d/ )) and memory cost is O(poly(d/ )), which are lower than the cost of exact LSR when d n.\n1 f unc t i on [ x t i l d e ] = InexactLSR (A, b , s ) 2 d = s i z e (A, 2) ; 3 sketch = ( CountSketch ( [A, b ] ’ , s ) ) ’ ; 4 Asketch = sketch ( : , 1 : d ) ; % Asketch = S ’ ∗ A 5 bsketch = sketch ( : , end ) ; % bsketch = S ’ ∗ b 6 x t i l d e = Asketch \\ bsketch ;\nThere are a few things to remark:\n• The inexact LSR is useful only when n = Ω(d/ + d2).\n• The size of sketch s is a polynomial function of −1 rather than logarithm of −1, thus the algorithm cannot attain high precision."
    }, {
      "heading" : "4.2.2 Theoretical Explanation",
      "text" : "By the subspace embedding property, it can be easily shown that x̃ is a good solution. Let D = [A,b] ∈ Rn×(d+1) and z = [x;−1] ∈ Rn+1. Then\nAx− b = Dz and STAx− STb = STDz,\n20\nand the subspace embedding property indicates 1 η ‖Dz‖22 ≤ ‖STDz‖22 ≤ η‖Dz‖22 for all z. Thus\n1 η ‖Ax̃− b‖22 ≤ ‖ST (Ax̃− b)‖22 and ‖ST (Ax? − b)‖22 ≤ η‖Ax? − b‖22\nThe optimality of x̃ indicates ‖ST (Ax̃− b)‖22 ≤ ‖ST (Ax? − b)‖22, and thus 1\nη ‖Ax̃− b‖22 ≤ ‖ST (Ax̃− b)‖22 ≤ ‖ST (Ax? − b)‖22 ≤ η‖Ax? − b‖22.\n⇒ ‖Ax̃− b‖22 ≤ η2‖Ax? − b‖22.\nTherefore, as long as S satisfies the subspace embedding property, the approximate solution to LSR is nearly as good as the optimal solution (in terms of objective function value)."
    }, {
      "heading" : "4.3 Machine-Precision Solution",
      "text" : "Randomized algorithms can also be applied to find machine-precision solution to LSR, and the time complexity is lower than the standard solutions. The state-of-the-art algorithm [18] is based on very similar idea described in this section."
    }, {
      "heading" : "4.3.1 Basic Idea: Preconditioning",
      "text" : "We have discussed previously that the time cost of the conjugate gradient (CG) algorithm is roughly\nκ(A)− 1 2\n( log 1 + log(InitialError) ) nnz(A),\nwhich dependents on the condition number of A. To make CG efficient, one can find a d× d preconditioning matrix T such that κ(AT) is small, solve\nz? = argmin z ‖(AT)z− b‖22 (4.3)\nby CG, and let x? = Tz?. In this way, the time cost of CG is roughly\nκ(AT)− 1 2\n( log 1 + log(InitialError) ) nnz(A).\nIf κ(AT) is a small constant, e.g. κ(AT) = 2, then (4.3) can be very efficiently solved by CG.\nNow let’s consider how to find the preconditioning matrix T. Let A = QARA be the QR decomposition. Obviously T = R−1A is a perfect preconditioning matrix because κ(AR−1A ) = κ(QA) = 1. Unfortunately, the preconditioning matrix T = R −1 A is not a practical choice because computing the QR decomposition is as expensive as solving LSR. Woodruff [34] proposed to use sketching to find RA approximately inO(nnz(A)+poly(d)) time. Let S ∈ Rn×s be a sketching matrix and form Y = STA. Let Y = QYRY be the QR decomposition of Y. Theory shows that the sketch size s = O(d2) suffices for κ(AR−1Y ) ≤ 2 holding with high probability. Thus R−1Y ∈ Rd×d is a good preconditioning matrix.\n21\nAlgorithm 4.1 Machine-Precision Solution to LSR.\n1: input: A ∈ Rn×d, b ∈ Rn, and step size θ. 2: Draw a sketching matrix S ∈ Rn×s where s = O(d2); 3: Form the sketch Y = STA ∈ Rs×d; 4: Compute the QR decomposition Y = QYRY; 5: Compute the preconditioning matrix T = R−1Y ; 6: Compute the initial solution z(0) = (STAT)†(STb) = QTY(S\nTb); 7: for t = 1, · · · ,O(log −1) do 8: r(t) = b−ATz(t−1) ; // the residual 9: z(t) = z(t−1) + θTTAT r(t); // gradient descent\n10: end for 11: return x? = Tz(t) ∈ Rd."
    }, {
      "heading" : "4.3.2 Algorithm Description",
      "text" : "The algorithm is described in Algorithm 4.1. We first form a sketch Y = STA ∈ Rs×d and compute its QR decomposition Y = QYRY. We can use this QR decomposition to find the initial solution z(0) and the preconditioning matrix T = R−1Y . If we set s = O(d2), the initial solution is only constant times worse than the optimal in terms of objective function value. Theory also ensures that the condition number κ(AT) ≤ 2. With the good initialization and good condition number, the vanilla gradient descent1 or CG takes only O(log −1) steps to attain 1 + solution. Notice that Lines 8 and 9 in the algorithm should be cautiously implemented. Do not compute the matrix product AT because it would take O(nnz(A)d) time!"
    }, {
      "heading" : "4.4 Extension: CX-Type Regression",
      "text" : "Given any matrix A ∈ Rm×n, CX decomposition considers decomposing A into A ≈ CX?, where C ∈ Rm×c is a sketch of A and X? ∈ Rc×n is computed by\nX? = argmin X\n∥∥A−CX∥∥2 F = C†A.\nIt takes O(mnc) time to compute X?. If c m, this problem can be solved more efficiently by sketching. Specifically, we can draw a sketching matrix S ∈ Rm×s and compute the approximate solution\nX̃ = argmin X ‖STC︸︷︷︸\ns×c X︸︷︷︸ c×n −STA︸︷︷︸ s×n ‖2F = (STC)†(STA)\nIf S is a count sketch matrix, we set s = O(c/ + c2); if S samples columns according to the row leverage scores of C, we set s = O(c/ + c log c). It holds with high probability that∥∥A−CX̃∥∥2\nF ≤ (1 + ) min\nX\n∥∥A−CX∥∥2 F .\n1Since AT is well conditioned, the vanilla gradient descent and CG has little difference.\n22"
    }, {
      "heading" : "4.5 Extension: CUR-Type Regression",
      "text" : "A more complicated problem has also been considered in the literature [25; 29; 24]:\nX? = argmin X ‖ C︸︷︷︸ n×c X︸︷︷︸ c×r R︸︷︷︸ r×n − A︸︷︷︸ m×n ‖2F (4.4)\nwhere c, r m,n. The solution is:\nX? = C†AR†,\nwhich cost O(mn · min{c, r}) time. Wang et al. [31] proposed an algorithm to solve (4.4) approximately by\nX̃ = argmin X ‖STC(CXR−A)SR‖2F\nwhere SC ∈ Rm×sc and SR ∈ Rn×sr are leverage score sampling matrices. When sc = c √ q/\nand sr = r √ q/ (where q = min{m,n}), it holds with high probability that\n‖CX̃R−A‖2F ≤ (1 + ) min X ‖CXR−A‖2F .\nThe total time cost is\nO(scsr ·min{c, r}) = O(cr −1 ·min{m,n} ·min{c, r})\ntime, which is useful when max{m,n} c, r. The algorithm can be implemented in 4 lines of MATLAB code:\n1 f unc t i on [ Xt i lde ] = InexactCurTypeRegress ion (C, R, A, sc , s r ) 2 [ ˜ , idxC ] = LeverageScoreSampling (C’ , sc ) ; 3 [ ˜ , idxR ] = LeverageScoreSampling (R, s r ) ; 4 Xt i lde = pinv (C( idxC , : ) ) ∗ A( idxC , idxR ) ∗ pinv (R( : , idxR ) ) ;\nHere the function “LeverageScoreSampling” is described in Section 3.3.2. Empirically, setting s1 = s2 = O(d1 + d2) suffices for high precision. The experiments in [31] indicates that uniform sampling performs equally well as leverage score sampling.\n23\n24\nChapter 5\nRank k Singular Value Decomposition\nThis chapter considers the k-SVD of a large scale matrix A ∈ Rm×n, which may not fit in memory."
    }, {
      "heading" : "5.1 Standard Solutions",
      "text" : "The standard solutions to k-SVD include the power iteration algorithm and the Krylov subspace methods. Their time complexities are considered to be Õ(mnk), where the Õ notation hides parameters such as the spectral gap and logarithm of error tolerance. Here we introduce a simplified version of the block Lanczos method [19]1 which costs time O(mnkq), where q = log n is the number of iterations, and the inherent constant depends weakly on the spectral gap. The block Lanczos algorithm is described in Algorithm 5.1 can be implemented in 18 lines of MATLAB code.\n1 f unc t i on [U, S , V] = BlockLanczos (A, k , q ) 2 s = 2 ∗ k ; % can be tuned 3 [m, n ] = s i z e (A) ; 4 C = A ∗ randn (n , s ) ; 5 Krylov = ze ro s (m, s ∗ q ) ; 6 Krylov ( : , 1 : s ) = C; 7 f o r i = 2 : q 8 C = A’ ∗ C; 9 C = A ∗ C;\n10 [C, ˜ ] = qr (C, 0) ; % opt i ona l 11 Krylov ( : , ( i −1)∗ s +1: i ∗ s ) = C; 12 end 13 [Q, ˜ ] = qr ( Krylov , 0) ; 14 [ Ubar , S , V] = svd (Q’ ∗ A, ’ econ ’ ) ; 15 Ubar = Ubar ( : , 1 : k ) ; 16 S = S ( 1 : k , 1 : k ) ;\n1We introduce this algorithm because it is easy to understand. However, as q grows, columns of the Krylov matrix gets increasingly linearly dependent, which sometimes leads to instability. Thus there are many numerical treatments to strengthen stability (see the numerically stable algorithms in [23]).\n25\nAlgorithm 5.1 k-SVD by the Block Lanczos Algorithm. 1: Input: an m× n matrix A and the target rank k. 2: Set s = k +O(1) be the over-sampling parameter; 3: Set q = O(log n ) be the number of iteration; 4: Draw a n× s sketching matrix S; 5: C = AS; 6: Set K = [ C, (AAT )C, (AAT )2C, · · · , (AAT )q−1C ] ;\n7: QR decomposition: [ QC︸︷︷︸ m×sq ,RC] = qr( K︸︷︷︸ m×sq ); 8: SVD: [ Ū︸︷︷︸ sq×sq , Σ︸︷︷︸ sq×sq , V︸︷︷︸ n×sq ] = svd(QTCA︸ ︷︷ ︸ s×n );\n9: Retain the top k components of Ū, Σ, and V to form sq × k, k × k, n× k matrices; 10: U = QŪ ∈ Rm×k; 11: return UΣVT ≈ Ak.\n17 V = V( : , 1 : k ) ; 18 U = Q ∗ Ubar ;\nAlthough the block Lanczos algorithm can attain machine precision, it inevitably goes many passes through A, and it is thus slow when A does not fit in memory.\nFacing large-scale data, we must trade off between precision and computational costs. We are particularly interested in approximate algorithm that satisfies:\n1. The algorithm goes constant passes through A. Then A can be stored in large volume disks, and there are only constant swaps between disk and memory.\n2. The algorithm only keeps a small-scale sketch of A in memory.\n3. The time cost is O(mnk) or lower.\n5.2 Prototype Randomized k-SVD Algorithm\nThis section describes a randomized algorithm that computes the k-SVD of A up to 1 + Frobenius norm relative error. The algorithm is proposed by [14], and it is described in Algorithm 5.2."
    }, {
      "heading" : "5.2.1 Theoretical Explanation",
      "text" : "If C = AS ∈ Rm×s is a good sketch of A, the column space of C should roughly contain the columns of Ak—this is the low-rank approximation property. If S ∈ Rn×s is Gaussian projection matrix or count sketch and s = O(k/ ), then the low-rank approximation property\nmin rank(Z)≤k\n‖CZ−A‖2F ≤ (1 + )‖A−Ak‖2F (5.1)\n26\nAlgorithm 5.2 Prototype Randomized k-SVD Algorithm. 1: Input: an m× n matrix A and the target rank k. 2: Draw a n× s sketching matrix S where s = O(k ); 3: C = AS; 4: QR decomposition: [QC︸︷︷︸\nm×s\n,RC] = qr( C︸︷︷︸ m×s );\n5: k-SVD: [ Ū︸︷︷︸ s×k , Σ̃︸︷︷︸ k×k , Ṽ︸︷︷︸ n×k ] = svds(QTCA︸ ︷︷ ︸ s×n , k); 6: Ũ = QCŪ ∈ Rm×k; 7: return ŨΣ̃ṼT ≈ Ak.\nholds in expectation."
    }, {
      "heading" : "5.2.2 Algorithm Derivation",
      "text" : "Let QC be any orthonormal bases of C. Since the column space of C is the same to the column space of QC, the minimization problem in (5.1) can be equivalently converted to\nX? = argmin rank(X)≤k ‖ QC︸︷︷︸ m×s X︸︷︷︸ s×n − A︸︷︷︸ m×n ‖2F = (QTCA)k. (5.2)\nHere the second equality is a well known fact. The matrix Ak is well approximated by Ãk := QCX ?, so we need only to find the k-SVD of Ãk:\nÃk := QC︸︷︷︸ m×s X?︸︷︷︸ s×n = QC (Q T CA)k︸ ︷︷ ︸\n:=ŪΣ̃ṼT = QCŪ︸ ︷︷ ︸ :=Ũ Σ̃ṼT = Ũ︸︷︷︸ m×k Σ̃︸︷︷︸ k×k ṼT︸︷︷︸ k×n .\nIt is easy to check that Ũ and Ṽ have orthonormal columns and Σ̃ is a diagonal matrix. Notice that the accuracy of the randomized k-SVD depends only on the quality of the sketch matrix C."
    }, {
      "heading" : "5.2.3 Implementation",
      "text" : "The algorithm is described in Algorithm 5.2 and can be implemented in 5 lines of MATLAB code. Here s = O(k ) is the size of the sketch.\n1 f unc t i on [ Uti lde , S t i l d e , Vt i lde ] = ksvdPrototype (A, k , s ) 2 C = CountSketch (A, s ) ; 3 [Q, R] = qr (C, 0) ; 4 [ Ubar , S t i l d e , Vt i lde ] = svds (Q’ ∗ A, k ) ; 5 Ut i lde = Q ∗ Ubar ;\nEmpirically, using “svd(Q′ ∗ A, ′econ′)” followed by discarding the k + 1 to s components should be faster than the “svds” function in Line 4.\nThe algorithm has the following properties:\n27\n1. The algorithm goes 2 passes through A;\n2. The algorithm only keeps an m×O(k ) sketch C in memory;\n3. The time cost is O(nnz(A)k/ ).\n5.3 Faster Randomized k-SVD\nThe prototype algorithm spends most of its time on solving (5.2); if (5.2) can be solved more efficiently, the randomized k-SVD can be even faster. The readers may have noticed that (5.2) is the least squares regression (LSR) problem discussed in Section 4.4. Yes, we can solve (5.2) efficiently by the inexact LSR algorithm presented in the previous section."
    }, {
      "heading" : "5.3.1 Theoretical Explanation",
      "text" : "Now we draw a m× p GaussianProjection+CountSketch matrix P and solve this problem:\nX̃ = argmin rank(X)≤k ‖PTQC︸ ︷︷ ︸ p×s X︸︷︷︸ s×n −PTA︸ ︷︷ ︸ p×n ‖2F . (5.3)\nTo understand this trick, the readers can retrospect the extension of LSR in Section 4.4. Let\nP = Pcs︸︷︷︸ m×pcs Psrht︸ ︷︷ ︸ pcs×p\nwhere pcs = O(k/ +k2) and p = O(k/ ). The subspace embedding property of RSHT+CountSketch [6, Theorem 46] implies that\n(1 + )−1‖QCX̃−A‖2F ≤ ‖PT (QCX̃−A)‖2F ≤ ‖PT (QCX? −A)‖2F ≤ (1 + )‖QCX? −A‖2F , ⇒ ‖QCX̃−A‖2F ≤ (1 + )2‖QCX? −A‖2F ≤ (1 + )3‖A−Ak‖2F .\nHere the second inequality follows from the optimality of X̃, and the last inequality follows from the low-rank approximation property of the sketch C = AS. Thus, by solving (5.3) we get k-SVD up to 1 +O( ) Frobenius norm relative error."
    }, {
      "heading" : "5.3.2 Algorithm Derivation",
      "text" : "The faster randomized k-SVD is described in Algorithm 5.3 and derived in the following. The algorithm solves\nX̃ = argmin rank(X)≤k ‖PTC︸ ︷︷ ︸ p×s X︸︷︷︸ s×n −PTA︸ ︷︷ ︸ p×n ‖2F (5.4)\nto obtain the rank k matrix X̃ ∈ Rc×n, and approximates Ak by\nAk ≈ CX̃.\n28\nAlgorithm 5.3 Faster Randomized k-SVD Algorithm. 1: Input: an m× n matrix A and the target rank k. 2: Set the parameters as s = Õ(k ), pcs = s 2 log6 s + s , and p = s log s ;\n3: Draw a n× s count sketch matrix S and perform sketching: C = AS; 4: Draw an m× pcs count sketch matrix Pcs and an pcs × p matrix Psrht; 5: Perform Sketching: D = PTsrhtP T csC ∈ Rp×s and L = PTsrhtPTcsA ∈ Rp×n; 6: QR decomposition: [QD︸︷︷︸ p×s , RD︸︷︷︸ s×s ] = qr( D︸︷︷︸ p×s ); 7: k-SVD: [ Ū︸︷︷︸ s×k , Σ̄︸︷︷︸ k×k , V̄︸︷︷︸ n×k ] = svds(QTDL︸ ︷︷ ︸ s×n , k); 8: SVD: [ Ũ︸︷︷︸ n×k , Σ̃︸︷︷︸ k×k , V̂︸︷︷︸ k×k ] = svd(CR†DŪΣ̄︸ ︷︷ ︸ s×k ); 9: Ṽ = V̄︸︷︷︸ n×k V̂︸︷︷︸ k×k ;\n10: return ŨΣ̃ṼT ≈ Ak.\nDefine D = PTC, L = PTA, and let QDRD = D be the QR decomposition. Then (5.4) becomes\nX̃ = argmin rank(X)≤k ‖ D︸︷︷︸ p×s X︸︷︷︸ s×n − L︸︷︷︸ p×n ‖2F = R † D︸︷︷︸\ns×s (QTDL)k︸ ︷︷ ︸ s×n .\nBased on the defined notation, we decompose Ak ≈ CX̃ by\nAk ≈ CX̃ = CR†D (Q T DL)k︸ ︷︷ ︸\n:=ŪΣ̄V̄T = CR†DŪΣ̄︸ ︷︷ ︸ :=ŨΣ̃V̂T V̄T = ŨΣ̃ V̂T V̄T︸ ︷︷ ︸ :=ṼT = Ũ︸︷︷︸ m×k Σ̃︸︷︷︸ k×k ṼT︸︷︷︸ k×n ."
    }, {
      "heading" : "5.3.3 Implementation",
      "text" : "The faster randomized k-SVD is described in Algorithm 5.3 and implemented in 18 lines of MATLAB code.\n1 f unc t i on [ Uti lde , S t i l d e , Vt i lde ] = ksvdFaster (A, k , s , p1 , p2 ) 2 n = s i z e (A, 2) ; 3 C = CountSketch (A, s ) ; 4 A = [A, C ] ; 5 A = A’ ; 6 sketch = CountSketch (A, p1 ) ; 7 c l e a r A % A (m−by−n) w i l l not be used 8 sketch = Gauss ianPro ject ion ( sketch , p2 ) ; 9 sketch = sketch ’ ;\n10 L = sketch ( : , 1 : n ) ; 11 D = sketch ( : , n+1:end ) ; 12 c l e a r sketch % sketch ( p2−by−(n+c ) ) w i l l not be used 13 [QD, RD] = qr (D, 0) ;\n29\n14 [ Ubar , Sbar , Vbar ] = svds (QD’ ∗ L , k ) ; 15 c l e a r L % L ( p2−by−n) w i l l not be used 16 C = C ∗ ( pinv (RD) ∗ ( Ubar ∗ Sbar ) ) ; 17 [ Ut i lde , S t i l d e , Vhat ] = svd (C, ’ econ ’ ) ; 18 Vt i lde = Vbar ∗ Vhat ;\nThere are a few things to remark:\n1. The algorithm goes only two passes through A. 2. The algorithm costs time O ( nnz(A) + (m+ n)poly(k/ ) ) .\n3. The parameters should be set as k < s < p2 < p1 m,n.\n4. Line 8 can be removed or replaced by other sketching methods.\n5. “A”, “sketch”, and “L” are the most memory expensive variables in the program, but fortunately, they are swept only one or two passes. If “A”, “sketch”, and “L” do not fit in memory, they should be stored in disk and loaded to memory block-by-block to perform computations.\n6. Unless both m and n are large enough, this algorithm may be slower than the prototype algorithm.\n30\nChapter 6\nSPSD Matrix Sketching\nThis chapter considers SPSD matrix K ∈ Rn×n, which can be a kernel matrix, a social network graph, a Hessian matrix, or a Fisher information matrix. Our objective is to find a low-rank decomposition K ≈ LLT . (Notice that LLT is always SPSD, no matter what L is.) If K is symmetric but not SPSD, it can be approximated by K ≈ CZCT where Z is symmetric but not necessarily SPSD."
    }, {
      "heading" : "6.1 Motivations",
      "text" : "This section provides three motivation examples to show why we seek to sketch K by K ≈ LLT or K ≈ CZCT ."
    }, {
      "heading" : "6.1.1 Forming a Kernel Matrix",
      "text" : "In the kernel approximation problems, we are given\n• an n× d matrix X, whose rows are data points x1, · · · ,xn ∈ Rd,\n• a kernel function, e.g. the Gaussian RBF kernel function defined by κ(xi,xj) = exp ( − 1\n2σ−2 ‖xi − xj‖22 ) where σ > 0 is the kernel width parameter.\nThe RBF kernel matrix can be computed by the following MATLAB code:\n1 f unc t i on [K] = rb f (X1 , X2 , sigma ) 2 K = X1 ∗ X2 ’ ; 3 X1 row sq = sum(X1. ˆ 2 , 2) / 2 ; 4 X2 row sq = sum(X2. ˆ 2 , 2) / 2 ; 5 K = bsxfun (@minus , K, X1 row sq ) ; 6 K = bsxfun (@minus , K, X2 row sq ’ ) ; 7 K = K / ( sigma ˆ2) ; 8 K = exp (K) ;\n31\nIf X1 and X2 are respectively n1 × d and n2 × d matrices, then the output of “rbf” is an n1 × n2 matrix.\nKernel methods requires forming the n × n kernel matrix K whose the (i, j)-th entry is κ(xi,xj). The RBF kernel matrix can be computed by the MATLAB function\n1 K = rb f (X, X, sigma )\nin O(n2d) time. In presence of millions of data points, it is prohibitive to form such a kernel matrix. Fortunately, a sketch of K can be obtained very efficiently. Let S ∈ Rn×s be a uniform column selection matrix1 described in Section 3.3, then C = KS can be obtained in O(nsd) time by the following MATLAB code.\n1 f unc t i on [C] = rbfSketch (X, sigma , s ) 2 n = s i z e (X, 1) ; 3 idx = s o r t ( randsample (n , s ) ) ; 4 C = rb f (X, X( idx , : ) , sigma ) ;"
    }, {
      "heading" : "6.1.2 Matrix Inversion",
      "text" : "Let K be an n×n kernel matrix, y be an n dimensional vector, and α be a positive constant. Kernel methods such as the Gaussian process regression (or the equivalent the kernel ridge regression) and the least squares SVM require solving\n(K + αIn)w = y\nto obtain w ∈ Rn. The exact solution costs O(n3) time and O(n2) memory. If we have a rank l approximation K ≈ LLT , then w can be approximately obtained in O(nl2) time and O(nl) memory. Here we need to apply the Sherman-Morrison-Woodbury matrix identity\n(A + BCD)−1 = A−1 −A−1B(C−1 + DA−1B)−1DA−1.\nWe expand (LLT + αIn) −1 by the above identity and obtain\n(LLT + αIn) −1 = α−1In − α−1L(αIl + LTL︸ ︷︷ ︸\nl×l\n)−1LT ,\nand thus w = (K + αIn) −1y ≈ α−1y − α−1L(αIl + LTL)−1LTy.\nThe matrix inversion problem not only appears in the kernel methods, but also in the second order optimization problems. Newton’s method and the so-called natural gradient\n1The local landmark selection is sometimes a better choice. Do not use random projections, because they inevitably visit every entry of K.\n32\nmethod require computing H−1g, where g is the gradient and H is the Hessian matrix or the Fisher information matrix. Since low-rank matrices are not invertible, the naive lowrank approximation H ≈ CZCT does not work. To make matrix inversion possible, one can use the spectral shifting trick of [30]: fix a small constant α > 0, form the low-rank approximation H − αIn ≈ CZCT , and compute H−1g ≈ (CZCT + αIn)−1g. Besides the low-rank approximation approach, one can approximate H by a block diagonal matrix or even its diagonal, because it is easy to invert a diagonal matrix or a block diagonal matrix."
    }, {
      "heading" : "6.1.3 Eigenvalue Decomposition",
      "text" : "With the low-rank decomposition K ≈ LLT at hand, we first approximately decompose K by\nK ≈ LLT = (ULΣLVTL)(ULΣLVTL)T = ULΣ2LUTL,\nand then discard the k + 1 to l components in UL and ΣL. Here L = ULΣLV T L is the SVD of L, which can be obtained in O(nl2) time and O(nl) memory. In this way, the rank k (k ≤ rank(L)) eigenvalue decomposition is approximately computed."
    }, {
      "heading" : "6.2 Prototype Algorithm",
      "text" : "From now on, we will consider how to find the low-rank approximation K ≈ LLT . As usual, the simplest approach is to form a sketch C = KS ∈ Rn×s and solve\nX? = min X ‖K−CXCT‖2F = C†K(C†)T or Z? = min Z ‖K−QCZQC‖2F = QTCKQC, (6.1) where QC is the orthonormal bases of C computed by SVD or QR decomposition. It is obvious that CX?C = QCZ\n?QTC. In this way, a rank c approximation to K is obtained. This approach is first studied by [14]. Wang et al. [30] showed that if C contains s = O(k/ ) columns of K chosen by adaptive sampling, the error bound\nE‖K−QCZ?QTC‖2F ≤ (1 + )‖K−Kk‖2F\nis guaranteed. Other sketching methods can also be applied, although currently they do not have 1 + error bound. In the following we implement the prototype algorithm (with the count sketch) in 5 lines of MATLAB code. Since the algorithm goes only two passes through K, when K does not fit in memory, we can store K in the disk and keep one block of K in memory at a time. In this way, O(ns) memory is enough.\n1 f unc t i on [QC, Z ] = spsdPrototype (K, s ) 2 n = s i z e (K, 2) ; 3 C = CountSketch (K, s ) ; 4 [QC, ˜ ] = qr (C, 0) ; 5 Z = QC’ ∗ K ∗ QC;\n33\nAlgorithm 6.1 Faster SPSD Matrix Sketching. 1: Input: an n× n matrix K and integers s and p (s ≤ p n). 2: Draw a column selection matrix S ∈ Rn×s; 3: Perform sketching: C = AS; 4: QR decomposition: [QC,RC] = qr(C); 5: Draw a column selection matrix P ∈ Rn×p; 6: Compute Z̃ = (PTQC) †(PTKP)(QTCP) †;\n7: return QCZ̃Q T C ≈ A.\nDespite its simplicity, the algorithm has several drawbacks.\n• The time cost of this algorithm is O(ns2 + nnz(K)s), which can be quadratic in n.\n• The algorithm must visit every entry of K, which can be a serious drawback when applied to kernel methods. It is because computing the kernel matrix K costs O(n2d) time, where d is the dimension of the data points.\nTherefore, we are interested in computing a low-rank approximation in linear time (w.r.t. n) and avoiding visiting every entry of K."
    }, {
      "heading" : "6.3 Faster SPSD Matrix Sketching",
      "text" : "The readers may have noticed that (6.1) is the problem studied in Section 4.5. We can thus draw a column selection matrix P ∈ Rn×p and approximately solve (6.1) by\nZ̃ = min Z ‖PT (K−QCZQC)P‖2F = (PTQC)†︸ ︷︷ ︸\ns×p\n(PTKP)︸ ︷︷ ︸ p×p (QTCP) †︸ ︷︷ ︸ p×s . (6.2)\nThen we can approximate K by QCZ̃Q T C. We describe the faster SPSD matrix sketching in Algorithm 6.1. There are a few things to remark.\n• Since we are trying to avoid computing every entry of K, we should use uniform sampling or local landmark selection to form C = KS.\n• Let P ∈ Rn×p be a leverage score sampling matrix according to the columns of CT . That is, it samples the i-th column with probability proportional to qi, where qi is the squared `2 norm of the i-th row of QC (for i = 1 to n). When p = O( √ ns −1/2), the\nfollowing error bounds holds with high probability [31]\n‖K−QCZ̃QTC‖2F ≤ (1 + ) min Z ‖K−QCZQTC‖2F .\n• Let S be a uniform sampling matrix and P be a leverage score sampling matrix. The algorithm visits only ns+ p2 = O(n) entries of K. The overall time and memory costs are linear in n.\n34\n• Assume S is a column selection matrix. Let the sketch C = KS contains the columns of K indexed by S ⊂ [n], and the columns selected by P are indexed by P ⊂ [n]. Empirically, enforcing S ⊂ P significantly improves the approximation quality.\n• Empirically, letting p be several times larger than s, e.g. p = 4s, is sufficient for a high quality.\nThe algorithm can be implemented in 12 lines of MATLAB code.\n1 f unc t i on [QC, Z ] = spsdFaster (K, s ) 2 p = 4 ∗ s ; % can be tuned 3 n = s i z e (K, 2) ; 4 S = s o r t ( randsample (n , s ) ) ; % uniform sampling 5 C = K( : , S ) ; 6 [QC, ˜ ] = qr (C, 0) ; 7 q = sum(QC. ˆ 2 , 2) ; % the sampling p r o b a b i l i t y 8 q = q / sum( q ) ; 9 P = randsample (n , p , true , q ) ; % l e v e r a g e s co r e sampling\n10 P = unique ( [P ; S ] ) ; % e n f o r c e P to conta in S 11 PQCinv = pinv (QC(P, : ) ) ; 12 Z = PQCinv ∗ K(P, P) ∗ PQCinv ’ ;\nThe above implementation assumes that K is a given matrix. In the kernel approximation problems, we are only given a n × d matrix X, whose rows are data points, and a kernel function, e.g. the RBF kernel with width parameter σ. We should implement the faster SPSD sketching algorithm in the following way.\n1 f unc t i on [QC, Z ] = spsdFaster (X, sigma , s ) 2 p = 4 ∗ s ; % can be tuned 3 n = s i z e (X, 1) ; 4 S = s o r t ( randsample (n , s ) ) ; % uniform sampling 5 C = rb f (X, X(S , : ) , sigma ) ; 6 [QC, ˜ ] = qr (C, 0) ; 7 q = sum(QC. ˆ 2 , 2) ; % the sampling p r o b a b i l i t y 8 q = q / sum( q ) ; 9 P = randsample (n , p , true , q ) ;\n10 P = unique ( [P ; S ] ) ; % e n f o r c e P conta in s S 11 PQCinv = pinv (QC(P, : ) ) ; 12 Ksub = rb f (X(P, : ) , X(P, : ) , sigma ) ; 13 Z = PQCinv ∗ Ksub ∗ PQCinv ’ ;\nThe above implementation avoids computing the whole kernel matrix, and is thus highly efficient when applied to kernel methods.\n35"
    }, {
      "heading" : "6.4 The Nyström Method",
      "text" : "Let S be an n× s column selection matrix and C = KS ∈ Rn×s be a sketch of K. Recall the model (6.2) proposed in the previous section. It is easy to verify that QCZ̃Q T C = CX̃C\nT , where X̃ is defined by\nX̃ = min X ‖PT (K−CXC)P‖2F = (PTC)†︸ ︷︷ ︸\ns×p (PTKP)︸ ︷︷ ︸ p×p (CTP)†︸ ︷︷ ︸ p×s .\nOne can simply set P = S ∈ Rn×s and let W = STC = STKS. Then the solution X̃ becomes\nX̃ = (STC)†(STKS)(CTS)† = W†WW† = W†.\nThe low-rank approximation K ≈ CW†CT\nis called the Nyström method [20; 32]. The Nyström method is perhaps the most extensively used kernel approximation approach in the literature. See Figure 6.1 for the illustration of the Nyström method.\nThere are a few things to remark:\n• The Nyström is highly efficient. When applied to speedup kernel methods, the scalability can be as large as n = 106.\n• The Nyström method is a rough approximation to K and is well known to be of low accuracy. If a moderately high accuracy is required, one had better use the method in the previous section.\n• The s × s matrix W is usually ill-conditioned, and thus the Moore-Penrose inverse can be numerically instable. (It is because the bottom singular values of W blow up during the Moore-Penrose inverse.) A very effective heuristic is to drop the bottom singular values of W: set a parameter k < s, e.g. k = d0.8se, and approximate K by C(Wk) †CT .\n36\n• There are many choices of the sampling matrix S. See [13] for more discussions.\nThe Nyström method can be implemented in 11 lines of MATLAB code. The output of the algorithm is L ∈ Rn×k, where LLT is the Nyström approximation to K.2\n1 f unc t i on [ L ] = Nystrom (X, sigma , s ) 2 k = c e i l ( 0 . 8 ∗ s ) ; % can be tuned 3 n = s i z e (X, 1) ; 4 S = s o r t ( randsample (n , s ) ) ; % uniform sampling 5 C = rb f (X, X(S , : ) , sigma ) ; % C = K( : , S ) 6 W = C(S , : ) ; 7 [UW, SW, ˜ ] = svd (W) ; 8 SW = diag (SW) ; 9 SW = 1 . / s q r t (SW( 1 : k ) ) ;\n10 UW = bsxfun ( @times , UW( : , 1 : k ) , SW’ ) ; 11 L = C ∗ UW; % K i s approximated by L ∗ L ’\nHere we use the RBF kernel function implemented in Section 6.1. Line 8 sets k = d0.8ce, which can be better tuned to enhance numerical stability. Notice that k should not be set too small, otherwise the accuracy would be affected."
    }, {
      "heading" : "6.5 More Efficient Extensions",
      "text" : "Several SPSD matrix approximation methods has been proposed recently, and they are more scalable than the Nyström method in certain applications. This section briefly describes some of these methods."
    }, {
      "heading" : "6.5.1 Memory Efficient Kernel Approximation (MEKA)",
      "text" : "MEKA [24] exploits the block structure of kernel matrices and is more memory efficient than the Nyström method. MEKA first partitions the data x1, · · · ,xn into b groups (e.g. by inexact kmeans clustering), accordingly, the kernel matrix K has b× b blocks:\nK =  K[1,1] · · · K[1,b]... . . . ... K[b,1] · · · K[b,b]  =  K[1:]... K[b:]  . Then MEKA approximately computes the top left singular vectors of K[1:], · · · ,K[b:], denote U[1], · · · ,U[b], respectively. For each (i, j) ∈ [b]× [b], MEKA finds a very small-scale matrix Z[i,j] by solving\nZ[i,j] = argmin Z ∥∥K[i,j] −U[i]Z[i,j]UT[j]∥∥2F . 2Let Wk = UW,kΛW,kU T W,k be the k-eigenvalue decomposition of W and set L = CUW,kΛ −1 W,k ∈ Rn×k.\n37\nThis can be done efficiently using the approach in Section 4.5. Finally, the low-rank approximation is\nK ≈  U[1] 0. . . 0 U[b]   Z[1,1] · · · Z[1,b]... . . . ... Z[b,1] · · · Z[b,b]   U[1] 0. . . 0 U[b]  T = UZUT .\nSince Z and U[1], · · · ,U[b] are small-scale matrices, MEKA is thus very memory efficient. There are several things to remark:\n• MEKA can be used to speedup Gaussian process regression and least squares SVM. However, MEKA can be hardly applied to speedup k-eigenvalue decomposition, because it requires the k-SVD of UZ1/2, which destroys the sparsity and significantly increases memory cost.\n• Indiscreet implementation, e.g. the implementation provided by [24], can make MEKA numerically unstable, as was reported by [30; 28]. The readers had better to follow the stabler implementation in [28]."
    }, {
      "heading" : "6.5.2 Structured Kernel Interpolation (SKI)",
      "text" : "SKI [33] is a memory efficient extension of the Nyström method. Let S be a column selection matrix, C = KS, and W = STC = STKS. The Nyström method approximates K by CW†CT . SKI further approximates each row of C by a convex combination of two rows of W and obtain C ≈ XW. Notice that each row of X has only two nonzero entries, which makes X extremely sparse. In this way, K is approximated by\nK ≈ CW†C ≈ (XW)W†(XW)T = XWXT .\nMuch accuracy is lost in the second approximation, so SKI is much less accurate than the Nyström method. For the same reason as MEKA, there is no point in applying SKI to speedup k-eigenvalue decomposition of K."
    }, {
      "heading" : "6.6 Extension to Rectangular Matrices: CUR Matrix",
      "text" : "Decomposition\nThis section considers the problem of sketching any rectangular matrix A by the CUR matrix decomposition [16]. The CUR matrix decomposition is an extension of the previously discussed SPSD matrix sketching methods."
    }, {
      "heading" : "6.6.1 Motivation",
      "text" : "Suppose we are given n training data x1, · · · ,xn ∈ Rd, m test data x′1, · · · ,x′m ∈ Rd, and a kernel function κ(·, ·). In their generalization (test) stage, kernel methods such as GPR and\n38\nKPCA form an m × n matrix K∗, where (K∗)ij = κ(x′i,xj), and apply K∗ to some vectors or matrices. Notice that it takes O(mnd) time to form K∗ and O(mnp) time to multiply K∗ by an n × p matrix. If m is as large as n, the generalization stage of such kernel methods can be very expensive. Fortunately, with the help of the CUR matrix decomposition, the generalization stage of GPR or KPCA merely costs time linear in m+ n."
    }, {
      "heading" : "6.6.2 Prototype CUR Decomposition",
      "text" : "Suppose we are given an arbitrary m×n rectangular matrix A, which can be the aforementioned K∗. We sample c columns of A to form C = ASC ∈ Rm×c, sample r rows of A to form R = ASR ∈ Rr×n, and compute the intersection matrix U? ∈ Rc×r by solving\nU? = argmin U ‖ A︸︷︷︸ m×n − C︸︷︷︸ m×c U︸︷︷︸ c×r R︸︷︷︸ r×n ‖2F = C†AR†. (6.3)\nThe approximation A ≈ CU?R is well known as the CUR decomposition [16]. This formulation bears a strong resemblance with the prototype SPSD matrix sketching method in (6.1).\nThe prototype CUR decomposition is not very useful because (1) its time cost is O(mn · min{c, r}) and (2) it visits every entry of A."
    }, {
      "heading" : "6.6.3 Faster CUR Decomposition",
      "text" : "Analogous to the SPSD matrix sketching, we can compute U? approximately and significantly more efficiently. Let PC ∈ Rm×pc and PR ∈ Rn×pr be some column selection matrices. Then we solve this problem in stead of (6.3):\nŨ = argmin U ‖PTCAPR︸ ︷︷ ︸\npc×pr −PTCC︸ ︷︷ ︸ pc×c U︸︷︷︸ c×r RPR︸ ︷︷ ︸ r×pr ‖2F = (PTCC)†(PTCAPR)(RPR)†. (6.4)\nThe faster CUR decomposition is very similar to the faster SPSD matrix sketching method in Section 6.3. The faster CUR decomposition has the following properties:\n• It visits only mc+nr+ pcpr entries of A, which is linear in m+n. This is particularly useful when applied to kernel methods, because it avoids forming the whole kernel matrix.\n• The overall time and memory costs are linear in m+ n.\n• If PC is the leverage score sampling matrix corresponding to the columns of CT and PR is the leverage score sampling matrix corresponding to the columns of R, then Ũ is a very high quality approximation to U? [31]:\n‖A−CŨR‖2F ≤ (1 + ) min U ‖A−CUR‖2F\nholds with high probability.\n39\nEmpirically speaking, setting PC and PR be uniform sampling matrices works nearly as well as leverage score sampling matrices, and setting pc = pr = O(c + r) suffices for a high approximation quality. If A is a full-observed matrix, the CUR matrix decomposition can be computed by the following MATLAB code.\n1 f unc t i on [C, U, R] = curFaste r (A, c , r ) 2 pc = 2 ∗ ( r + c ) ; % can be tuned 3 pr = 2 ∗ ( r + c ) ; % can be tuned 4 [m, n ] = s i z e (A) ; 5 SC = s o r t ( randsample (n , c ) ) ; 6 SR = s o r t ( randsample (m, r ) ) ; 7 C = A( : , SC) ; 8 R = A(SR, : ) ; 9 PC = s o r t ( randsample (m, pc ) ) ;\n10 PR = s o r t ( randsample (n , pr ) ) ; 11 PC = unique ( [PC; SR ] ) ; % e n f o r c e PC to conta in SR 12 PR = unique ( [PR; SC ] ) ; % e n f o r c e PR to conta in SC 13 U = pinv (C(PC, : ) ) ∗ A(PC, PR) ∗ pinv (R( : , PR) ) ;\nLet’s consider the kernel approximation problem in Section 6.6.1. Let Xtrain ∈ Rn×d be the training data and Xtest ∈ Rm×d be the test data. We use the RBF kernel with kernel width parameter σ. The m × n matrix K∗ can be approximated by K̃∗ = CUR, which is the output of the following MATLAB procedure.\n1 f unc t i on [C, U, R] = curFasterKerne l ( Xtest , Xtrain , sigma , c , r ) 2 pc = 2 ∗ ( r + c ) ; % can be tuned 3 pr = 2 ∗ ( r + c ) ; % can be tuned 4 m = s i z e ( Xtest , 1) ; 5 n = s i z e ( Xtrain , 1) ; 6 SC = s o r t ( randsample (n , c ) ) ; 7 SR = s o r t ( randsample (m, r ) ) ; 8 C = rb f ( Xtest , Xtrain (SC, : ) , sigma ) ; 9 R = rb f ( Xtest (SR, : ) , Xtrain , sigma ) ;\n10 PC = s o r t ( randsample (m, pc ) ) ; 11 PR = s o r t ( randsample (n , pr ) ) ; 12 PC = unique ( [PC; SR ] ) ; % e n f o r c e PC to conta in SR 13 PR = unique ( [PR; SC ] ) ; % e n f o r c e PR to conta in SC 14 Kblock = rb f ( Xtest (PC, : ) , Xtrain (PR, : ) , sigma ) ; 15 U = pinv (C(PC, : ) ) ∗ Kblock ∗ pinv (R( : , PR) ) ;\nThe time cost of this procedure is linear in m + n, and K̃∗ = CUR can be applied to n dimensional vector in O ( nr +mc) time. In this way, the generalization of GPR and KPCA can be efficient.\n40"
    }, {
      "heading" : "6.7 Applications",
      "text" : "This section provides the implementations of kernel PCA, spectral clustering, Gaussian process regression, all sped-up by randomized algorithms."
    }, {
      "heading" : "6.7.1 Kernel Principal Component Analysis (KPCA)",
      "text" : "Suppose we are given\n• n training data x1, · · · ,xn ∈ Rd,\n• m test data x′1, · · · ,x′m ∈ Rd, (x′i is not the transpose xTi ),\n• a kernel function κ(·, ·), e.g. the RBF kernel function,\n• a target rank k ( n, d).\nThe goal of KPCA is to extract k features of each training datum and each test datum, which may be used in clustering or classification. The standard KPCA consists of the following steps:\n1. Training\n(a) Form the n× n kernel matrix K of the training data, whose the (i, j)-th entry is κ(xi,xj);\n(b) Compute the k-eigenvalue decomposition Kk = UkΛkU T k ; (c) Form the n× k matrix UkΛ1/2k , whose the i-th row is the feature of xi;\n2. Generalization (test)\n(a) Form the m× n kernel matrix K∗ whose the (i, j)-th entry is κ(x′i,xj); (b) Form the m× k matrix K∗UkΛ−1/2k , whose the i-th row is the feature of x′i.\nThe most time and memory expensive step in training is the k-eigenvalue decomposition of K, which can be sped-up by the sketching techniques discussed in this section. Empirically, the faster SPSD matrix sketching in Section 6.3 is much more accurate than the Nyström method in Section 6.4, and their time and memory costs are all linear in n. Thus the faster SPSD matrix sketching can be better choice. KPCA can be approximately solved by several lines of MATLAB code.\n1 f unc t i on [U, lambda , f e a t u r e t r a i n ] = kpcaTrain ( Xtrain , sigma , k ) 2 s = k ∗ 10 ; % can be tuned 3 [QC, Z ] = spsdFaster ( Xtrain , sigma , s ) ; % QC has orthogona l columns 4 c l e a r Xtrain 5 [UZ, SZ , ˜ ] = svd (Z) ; 6 U = QC ∗ UZ( : , 1 : k ) ; % U conta in s the top k e i g e n v e c t o r s\n41\n7 lambda = diag (SZ) ; 8 lambda = lambda ( 1 : k ) ; % lambda i s the vec to r conta in ing the top k e i g e n v a l u e s 9 f e a t u r e t r a i n = bsxfun ( @times , U, ( s q r t ( lambda ) ) ’ ) ;\n10 end\n1 f unc t i on [ f e a t u r e t e s t ] = kpcaTest ( Xtrain , Xtest , sigma , U, lambda ) 2 Ktest = rb f ( Xtest , Xtrain , sigma ) ; 3 U = bsxfun ( @times , U, (1 . / s q r t ( lambda ) ) ’ ) ; 4 f e a t u r e t e s t = Ktest ∗ U; 5 end\nIn the function “kpcaTrain”, the input variable “Xtrain” has n rows, each of which corresponds to a training datum. The rows of the output “featuretrain” and “featuretest” are the features extracted by KPCA, and the features can be used to perform classification. For example, suppose each datum xi is associated with a label yi, and let y = [y1, · · · , yn]T ∈ Rn. We can use k-nearest-neighbor\n1 [ y t e s t ] = k n n c l a s s i f y ( f e a t u r e t e s t , f e a t u r e t r a i n , y )\nto predict the labels of the test data. When the number of test data m is large, the function “kpcaTest” is costly. The users should apply the CUR decomposition in Section 6.6.3 to speedup computation.\n1 f unc t i on [ f e a t u r e t e s t ] = kpcaTestCUR ( Xtrain , Xtest , sigma , U, lambda ) 2 c = max(100 , c e i l ( s i z e ( Xtrain , 1) / 20) ) ; % can be tuned 3 r = max(100 , c e i l ( s i z e ( Xtest , 1) / 20) ) ; % can be tuned 4 [C, Uti lde , R] = curFasterKerne l ( Xtest , Xtrain , sigma , c , r ) ; 5 U = bsxfun ( @times , U, (1 . / s q r t ( lambda ) ) ’ ) ; 6 f e a t u r e t e s t = C ∗ ( Ut i lde ∗ (R ∗ U) ) ; 7 end"
    }, {
      "heading" : "6.7.2 Spectral Clustering",
      "text" : "Spectral clustering is one of the most popular clustering algorithms. Suppose we are given\n• n data points x1, · · · ,xn ∈ Rd,\n• a kernel function κ(·, ·),\n• k: the number of classes.\nSpectral clustering performs the following operations:\n1. Form an n× n kernel matrix K, where big kij indicates xi and xj are similar; 2. Form the degree matrix D with dii = ∑ j kij and dij = 0 for all i 6= j;\n42\n3. Compute the normalized graph Laplacian G = D−1/2KD−1/2 ∈ Rn×n;\n4. Compute the top k eigenvectors of G, denote U ∈ Rn×k, and normalize the rows of U;\n5. Apply kmeans clustering on the rows of V to obtain the class labels.\nThe first step costs O(n2d) time and the fourth step costs O(n2k) times, which limit the scalability of spectral clustering. Fowlkes et al. [11] proposed to apply the Nyström method to make spectral clustering more scalable by avoiding forming the whole kernel matrix and speeding-up the k-eigenvalue decomposition. Empirically, the algorithm in Section 6.3 is more accurate than the Nyström method in Section 6.4, and they both runs in linear time. Spectral clustering with the randomized algorithm in Section 6.3 can be implemented in 16 lines of MATLAB code.\n1 f unc t i on [ l a b e l s ] = S p e c t r a l C l u s t e r i n g F a s t e r (X, sigma , k ) 2 s = k ∗ 10 ; % can be tuned 3 n = s i z e (X, 1) ; 4 [QC, Z ] = spsdFaster (X, sigma , s ) ; % K i s approximated by QC ∗ Z ∗ QC’ 5 [UZ, SZ , ˜ ] = svd (Z) ; 6 SZ = s q r t ( diag (SZ) ) ; 7 UZ = bsxfun ( @times , UZ, SZ ’ ) ; % now Z = UZ ∗ UZ’ 8 L = QC ∗ UZ; % now K i s approximated by L ∗ L ’ 9 d = ones (n , 1) ;\n10 d = L ∗ (L ’ ∗ d) ; % diagona l o f the degree matrix D 11 d = 1 . / s q r t (d) ; 12 L = bsxfun ( @times , L , d) ; % now G i s approximated by L∗L ’ 13 [U, ˜ , ˜ ] = svd (L , ’ econ ’ ) ; 14 U = U( : , 1 : k ) ; 15 U = normr (U) ; % normal ize the rows o f U 16 l a b e l s = kmeans (U, k , ’ R e p l i c a t e s ’ , 3) ;\nWhen the scale of data is too large for the faster SPSD matrix sketching algorithm in Section 6.3, one can instead use the more efficient Nyström method in Section 6.4: simply replace Lines 4 to 8 by\n1 L = Nystrom (X, sigma , s ) ;"
    }, {
      "heading" : "6.7.3 Gaussian Process Regression (GPR)",
      "text" : "The Gaussian process regression (GPR) is one of the most popular machine learning methods. GPR is the foundation of Bayesian optimization and has important applications such as automatically tuning the hyper-parameters of deep neural networks. Suppose we are given\n• n training data x1, · · · ,xn ∈ Rd,\n• labels y = [y1, · · · yn]T ∈ Rn of the training data,\n• m test data x′1, · · · ,x′m ∈ Rd, (x′i is not the transpose xTi ),\n43\n• and a kernel function κ(·, ·), e.g. the RBF kernel with kernel width parameter σ.\nTraining. In the training stage, GPR requires forming the n × n kernel matrix K where kij = κ(xi,xj) and computing the model\nw = (K + αIn) −1y.\nHere α is a tuning parameter that indicates the noise intensity in the labels y. It takes O(n2d) time to form the kernel matrix and O(n3) time to compute the matrix inversion. To make the training efficient, we can first sketch the SPSD matrix K to obtain K ≈ LLT and then apply the technique in Section 6.1.2 to obtain w. Empirically, when applied to speedup GPR, the algorithms discussed in Section 6.3 and Section 6.4 has similar accuracy, thus we choose to use the Nyström method which is more efficient.\nThe training GPR with the Nyström approximation can be implemented in the following MATLAB code. The time cost is O(nl2 + nld) and the space cost is O(nl + nd).\n1 f unc t i on [w] = gprTrain ( Xtrain , ytra in , sigma , alpha ) 2 l = 100 ; % can be tuned 3 L = Nystrom ( Xtrain , sigma , l ) ; % K i s approximated by L ∗ L ’ 4 l = s i z e (L , 2) ; 5 w = L ’ ∗ yt ra in ; 6 w = ( alpha ∗ eye ( l ) + L ’ ∗ L) \\ w; 7 w = yt ra in − L ∗ w; 8 w = w / alpha ; 9 end\nThe input “sigma” is the kernel width parameter and “alpha” indicates the noise intensity in the observation.\nGeneralization (test). After obtaining the trained model w ∈ Rn, GPR can predict the unknown labels of the m test data x′1, · · · ,x′m ∈ Rd. GPR forms an m×n kernel matrix K∗ whose the (i, j)-th entry is κ(x′i,xj) and compute y∗ = K∗w ∈ Rm. The i-th entry in y∗ is the predictive label of x′i. The generalization can be implemented in four lines of MATLAB code.\n1 f unc t i on [ y t e s t ] = gprTest ( Xtrain , Xtest , sigma , w) 2 Ktest = rb f ( Xtest , Xtrain , sigma ) ; 3 y t e s t = Ktest ∗ w; 4 end\nIt costs O(mnd) time to compute K∗ and O(mn) time to apply K∗ to w. If m is small, the generalization stage can be performed straightforwardly. However, if m is as large as n, the time cost will be quadratic in n, and the user should apply the CUR decomposition in Section 6.6.3 to speedup computation.\n44\n1 f unc t i on [ y t e s t ] = gprTestCUR ( Xtrain , Xtest , sigma , w) 2 c = max(100 , c e i l ( s i z e ( Xtrain , 1) / 20) ) ; % can be tuned 3 r = max(100 , c e i l ( s i z e ( Xtest , 1) / 20) ) ; % can be tuned 4 [C, Uti lde , R] = curFasterKerne l ( Xtest , Xtrain , sigma , c , r ) ; 5 y t e s t = C ∗ ( Ut i lde ∗ (R ∗ w) ) ; 6 end\n45\n46"
    }, {
      "heading" : "Appendix A",
      "text" : "Several Facts of Matrix Algebra\nThis chapter lists some facts that has been applied in this paper.\nFact A.1. The matrices Q1 ∈ Rm×n and Qn×p (m ≥ n ≥ p) have orthonormal columns. Then the matrix Q = Q1Q2 has orthonormal columns.\nFact A.2. Let A be any m×n and rank ρ matrix. Then AA†B = UAUTAB = AX? = UAZ?, where\nX? = argmin X ‖B−AX‖2F , and Z? = argmin Z ‖B−UAZ‖2F .\nThis is the reason why AA†B and UAU T AB are called the projection of B onto the column space of A.\nFact A.3. [34, Lemma 44] The matrices Q ∈ Rm×s (m ≥ s) has orthonormal columns. The solution to\nargmin rank(X)≤k\n‖A−QX‖2F\nis X? = (QTA)k, where (Q TA)k denotes the closest rank k approximation to Q TA.\nFact A.4. Let A† be the Moore-Penrose inverse of A. Then AA†A = A and A†AA† = A†.\nFact A.5. Let A be an m×n (m ≥ n) matrix and A = QARA be the QR decomposition of A. Then\nA†︸︷︷︸ n×m = R†A︸︷︷︸ n×n QTA︸︷︷︸ n×m .\nFact A.6. Let C be a full-rank matrix with more rows than columns. Let C = QCRC be the QR decomposition and C = UCΣCVC be the condensed SVD. Then the leverage scores of C, QC, UC are the same.\n47\n48"
    }, {
      "heading" : "Appendix B",
      "text" : "Notes and Further Reading\nThe `p Regression Problems. Chapter 4 has applied the sketching methods to solve the `2 norm regression problem more efficiently. The more general `p regression problems have also been studied in the literature [5; 7; 17; 8]. Especially, the `1 is of great interest because it demonstrate strong robustness to noise. Currently the strongest result is the `p row sampling by Lewis weights [8].\nDistributed SVD. In the distributed model, each machine holds a subset of columns of A, and the system outputs the top singular values and singular vectors. In this model, the communication cost should also be considered, as well as the time and memory costs. The seminal work [10] proposed to build a coreset to capture the properties of A, which facilitates low computation and communication costs. Later on, several algorithms with stronger error bound and lower communication and computation costs have been proposed. Currently, the state of the art is [2].\nRandom Feature for Kernel Methods. Chapter 6 has introduced the sketching methods for kernel methods. A parallel line of work is the random feature methods [22] which also form low-rank approximations to kernel matrices. Section 6.5.3 of [27] offers simple and elegant proof of a random feature method. Since the sketching methods usually works better than the random feature methods (see the examples in [35]), the users are advised to apply the sketching methods introduced in Chapter 6. Besides the two kinds of low-rank approximation approaches, the stochastic optimization approach [9] also demonstrates very high scalability.\n49\n50"
    } ],
    "references" : [ {
      "title" : "Generalized Inverses: Theory and Applications",
      "author" : [ "Adi Ben-Israel", "Thomas N.E. Greville" ],
      "venue" : "Second Edition. Springer,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2003
    }, {
      "title" : "Communication-optimal distributed principal component analysis in the column-partition model",
      "author" : [ "Christos Boutsidis", "David P Woodruff" ],
      "venue" : "arXiv preprint arXiv:1504.06729,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2015
    }, {
      "title" : "Near-optimal columnbased matrix reconstruction",
      "author" : [ "Christos Boutsidis", "Petros Drineas", "Malik Magdon-Ismail" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2014
    }, {
      "title" : "Finding frequent items in data streams",
      "author" : [ "Moses Charikar", "Kevin Chen", "Martin Farach-Colton" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2004
    }, {
      "title" : "Subgradient and sampling algorithms for l1 regression",
      "author" : [ "Kenneth L Clarkson" ],
      "venue" : "In Proceedings of the sixteenth annual ACM-SIAM symposium on Discrete algorithms,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2005
    }, {
      "title" : "Low rank approximation and regression in input sparsity time",
      "author" : [ "Kenneth L. Clarkson", "David P. Woodruff" ],
      "venue" : "In Annual ACM Symposium on theory of computing (STOC). ACM,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2013
    }, {
      "title" : "The fast cauchy transform and faster robust linear regression",
      "author" : [ "Kenneth L Clarkson", "Petros Drineas", "Malik Magdon-Ismail", "Michael W Mahoney", "Xiangrui Meng", "David P Woodruff" ],
      "venue" : "In Proceedings of the Twenty-Fourth Annual ACM-SIAM Symposium on Discrete Algorithms,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2013
    }, {
      "title" : "`p row sampling by lewis weights",
      "author" : [ "Michael B Cohen", "Richard Peng" ],
      "venue" : "arXiv preprint arXiv:1412.0588,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2014
    }, {
      "title" : "Scalable kernel methods via doubly stochastic gradients",
      "author" : [ "Bo Dai", "Bo Xie", "Niao He", "Yingyu Liang", "Anant Raj", "Maria-Florina F Balcan", "Le Song" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS)",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2014
    }, {
      "title" : "Turning big data into tiny data: Constant-size coresets for k-means, pca and projective clustering",
      "author" : [ "Dan Feldman", "Melanie Schmidt", "Christian Sohler" ],
      "venue" : "In Proceedings of the Twenty-Fourth Annual ACM-SIAM Symposium on Discrete Algorithms,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2013
    }, {
      "title" : "Spectral grouping using the Nyström method",
      "author" : [ "Charless Fowlkes", "Serge Belongie", "Fan Chung", "Jitendra Malik" ],
      "venue" : "IEEE Transactions on Pattern Analysis and Machine Intelligence,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2004
    }, {
      "title" : "The spectral norm error of the naive Nyström extension",
      "author" : [ "Alex Gittens" ],
      "venue" : "arXiv preprint arXiv:1110.5305,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2011
    }, {
      "title" : "Revisiting the nyström method for improved large-scale machine learning",
      "author" : [ "Alex Gittens", "Michael W. Mahoney" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2013
    }, {
      "title" : "Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions",
      "author" : [ "Nathan Halko", "Per-Gunnar Martinsson", "Joel A. Tropp" ],
      "venue" : "SIAM Review,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2011
    }, {
      "title" : "Extensions of Lipschitz mappings into a Hilbert space",
      "author" : [ "William B. Johnson", "Joram Lindenstrauss" ],
      "venue" : "Contemporary mathematics,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1984
    }, {
      "title" : "Randomized algorithms for matrices and data",
      "author" : [ "Michael W. Mahoney" ],
      "venue" : "Foundations and Trends in Machine Learning,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2011
    }, {
      "title" : "Low-distortion subspace embeddings in inputsparsity time and applications to robust linear regression",
      "author" : [ "Xiangrui Meng", "Michael W Mahoney" ],
      "venue" : "In Proceedings of the forty-fifth annual ACM symposium on theory of computing,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2013
    }, {
      "title" : "Lsrn: A parallel iterative solver for strongly over-or underdetermined systems",
      "author" : [ "Xiangrui Meng", "Michael A Saunders", "Michael W Mahoney" ],
      "venue" : "SIAM Journal on Scientific Computing,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2014
    }, {
      "title" : "Stronger approximate singular value decomposition via the block Lanczos and power methods",
      "author" : [ "Cameron Musco", "Christopher Musco" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2015
    }, {
      "title" : "Über die praktische auflösung von integralgleichungen mit anwendungen auf randwertaufgaben",
      "author" : [ "Evert J. Nyström" ],
      "venue" : "Acta Mathematica,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1930
    }, {
      "title" : "Fast and scalable polynomial kernels via explicit feature maps",
      "author" : [ "Ninh Pham", "Rasmus Pagh" ],
      "venue" : "In the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (KDD),",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2013
    }, {
      "title" : "Random features for large-scale kernel machines. In Advances in neural information processing systems (NIPS)",
      "author" : [ "Ali Rahimi", "Benjamin Recht" ],
      "venue" : null,
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2007
    }, {
      "title" : "Numerical methods for large eigenvalue problems. preparation",
      "author" : [ "Yousef Saad" ],
      "venue" : "Available from: http://www-users. cs. umn. edu/saad/books. html,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2011
    }, {
      "title" : "Memory efficient kernel approximation",
      "author" : [ "Si Si", "Cho-Jui Hsieh", "Inderjit Dhillon" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2014
    }, {
      "title" : "Four algorithms for the efficient computation of truncated pivoted QR approximations to a sparse matrix",
      "author" : [ "G.W. Stewart" ],
      "venue" : "Numerische Mathematik,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1999
    }, {
      "title" : "Tabulation-based 5-independent hashing with applications to linear probing and second moment estimation",
      "author" : [ "Mikkel Thorup", "Yin Zhang" ],
      "venue" : "SIAM J. Comput.,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2012
    }, {
      "title" : "An introduction to matrix concentration inequalities",
      "author" : [ "Joel A Tropp" ],
      "venue" : "arXiv preprint arXiv:1501.01571,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2015
    }, {
      "title" : "Structured block basis factorization for scalable kernel matrix evaluation",
      "author" : [ "Ruoxi Wang", "Yingzhou Li", "Michael W Mahoney", "Eric Darve" ],
      "venue" : "arXiv preprint arXiv:1505.00398,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2015
    }, {
      "title" : "Improving CUR matrix decomposition and the Nyström approximation via adaptive sampling",
      "author" : [ "Shusen Wang", "Zhihua Zhang" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2013
    }, {
      "title" : "Spsd matrix approximation via column selection: Theories, algorithms, and extensions",
      "author" : [ "Shusen Wang", "Luo Luo", "Zhihua Zhang" ],
      "venue" : "CoRR, abs/1406.5675,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2014
    }, {
      "title" : "Towards more efficient symmetric matrix sketching and CUR matrix decomposition",
      "author" : [ "Shusen Wang", "Zhihua Zhang", "Tong Zhang" ],
      "venue" : "arXiv preprint arXiv:1503.08395,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2015
    }, {
      "title" : "Using the Nyström method to speed up kernel machines",
      "author" : [ "Christopher Williams", "Matthias Seeger" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2001
    }, {
      "title" : "Kernel interpolation for scalable structured gaussian processes (kiss-gp)",
      "author" : [ "Andrew Gordon Wilson", "Hannes Nickisch" ],
      "venue" : "arXiv preprint arXiv:1503.01057,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2015
    }, {
      "title" : "Sketching as a tool for numerical linear algebra",
      "author" : [ "David P Woodruff" ],
      "venue" : "arXiv preprint arXiv:1411.4357,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2014
    }, {
      "title" : "Nyström method vs random fourier features: A theoretical and empirical comparison",
      "author" : [ "Tianbao Yang", "Yu-Feng Li", "Mehrdad Mahdavi", "Rong Jin", "Zhi-Hua Zhou" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2012
    }, {
      "title" : "Clustered Nyström method for large scale manifold learning and dimension reduction",
      "author" : [ "Kai Zhang", "James T. Kwok" ],
      "venue" : "IEEE Transactions on Neural Networks,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 15,
      "context" : "Mahoney [16] and Woodruff [34] have written excellent but very technical reviews of the randomized algorithms.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 33,
      "context" : "Mahoney [16] and Woodruff [34] have written excellent but very technical reviews of the randomized algorithms.",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 15,
      "context" : "The papers written by Mahoney [16] and Woodruff [34] provide comprehensive and rigorous reviews of the randomized matrix computation algorithms.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 33,
      "context" : "The papers written by Mahoney [16] and Woodruff [34] provide comprehensive and rigorous reviews of the randomized matrix computation algorithms.",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 0,
      "context" : "The book [1] offers a comprehensive study of the pseudo-inverses.",
      "startOffset" : 9,
      "endOffset" : 12
    }, {
      "referenceID" : 14,
      "context" : "The Gaussian projection is also well knows as the Johnson-Lindenstrauss transform due to the seminal work [15].",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 2,
      "context" : "When s = k + 1, the low-rank approximation property with η = 1 + holds in expectation [3].",
      "startOffset" : 86,
      "endOffset" : 89
    }, {
      "referenceID" : 35,
      "context" : "Zhang and Kwok [36] proposed to set k = s and run k-means or k-centroids clustering algorithm to cluster the columns of A to s class, and use the s centroids as the sketch of A.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 17,
      "context" : "The state-of-the-art algorithm [18] is based on very similar idea described in this section.",
      "startOffset" : 31,
      "endOffset" : 35
    }, {
      "referenceID" : 33,
      "context" : "Woodruff [34] proposed to use sketching to find RA approximately inO(nnz(A)+poly(d)) time.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 30,
      "context" : "[31] proposed an algorithm to solve (4.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 30,
      "context" : "The experiments in [31] indicates that uniform sampling performs equally well as leverage score sampling.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 18,
      "context" : "Here we introduce a simplified version of the block Lanczos method [19] which costs time O(mnkq), where q = log n is the number of iterations, and the inherent constant depends weakly on the spectral gap.",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 22,
      "context" : "Thus there are many numerical treatments to strengthen stability (see the numerically stable algorithms in [23]).",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 13,
      "context" : "The algorithm is proposed by [14], and it is described in Algorithm 5.",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 29,
      "context" : "To make matrix inversion possible, one can use the spectral shifting trick of [30]: fix a small constant α > 0, form the low-rank approximation H − αIn ≈ CZC , and compute H−1g ≈ (CZC + αIn)g.",
      "startOffset" : 78,
      "endOffset" : 82
    }, {
      "referenceID" : 13,
      "context" : "This approach is first studied by [14].",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 29,
      "context" : "[30] showed that if C contains s = O(k/ ) columns of K chosen by adaptive sampling, the error bound",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 30,
      "context" : "When p = O( √ ns −1/2), the following error bounds holds with high probability [31] ‖K−QCZ̃QC‖F ≤ (1 + ) min Z ‖K−QCZQC‖F .",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 12,
      "context" : "See [13] for more discussions.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 23,
      "context" : "1 Memory Efficient Kernel Approximation (MEKA) MEKA [24] exploits the block structure of kernel matrices and is more memory efficient than the Nyström method.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 0,
      "context" : "K =  K[1,1] · · · K[1,b] .",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 0,
      "context" : "K =  K[1,1] · · · K[1,b] .",
      "startOffset" : 8,
      "endOffset" : 13
    }, {
      "referenceID" : 0,
      "context" : "Then MEKA approximately computes the top left singular vectors of K[1:], · · · ,K[b:], denote U[1], · · · ,U[b], respectively.",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 0,
      "context" : "K ≈  U[1] 0 .",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 0,
      "context" : "0 U[b]   Z[1,1] · · · Z[1,b] .",
      "startOffset" : 14,
      "endOffset" : 19
    }, {
      "referenceID" : 0,
      "context" : "0 U[b]   Z[1,1] · · · Z[1,b] .",
      "startOffset" : 14,
      "endOffset" : 19
    }, {
      "referenceID" : 0,
      "context" : "Z[b,1] · · · Z[b,b]   U[1] 0 .",
      "startOffset" : 27,
      "endOffset" : 30
    }, {
      "referenceID" : 0,
      "context" : "Since Z and U[1], · · · ,U[b] are small-scale matrices, MEKA is thus very memory efficient.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 23,
      "context" : "the implementation provided by [24], can make MEKA numerically unstable, as was reported by [30; 28].",
      "startOffset" : 31,
      "endOffset" : 35
    }, {
      "referenceID" : 27,
      "context" : "The readers had better to follow the stabler implementation in [28].",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 32,
      "context" : "2 Structured Kernel Interpolation (SKI) SKI [33] is a memory efficient extension of the Nyström method.",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 15,
      "context" : "This section considers the problem of sketching any rectangular matrix A by the CUR matrix decomposition [16].",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 15,
      "context" : "The approximation A ≈ CUR is well known as the CUR decomposition [16].",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 30,
      "context" : "• If PC is the leverage score sampling matrix corresponding to the columns of C and PR is the leverage score sampling matrix corresponding to the columns of R, then Ũ is a very high quality approximation to U [31]: ‖A−CŨR‖F ≤ (1 + ) min U ‖A−CUR‖F",
      "startOffset" : 209,
      "endOffset" : 213
    }, {
      "referenceID" : 10,
      "context" : "[11] proposed to apply the Nyström method to make spectral clustering more scalable by avoiding forming the whole kernel matrix and speeding-up the k-eigenvalue decomposition.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "Currently the strongest result is the `p row sampling by Lewis weights [8].",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 9,
      "context" : "The seminal work [10] proposed to build a coreset to capture the properties of A, which facilitates low computation and communication costs.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 1,
      "context" : "Currently, the state of the art is [2].",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 21,
      "context" : "A parallel line of work is the random feature methods [22] which also form low-rank approximations to kernel matrices.",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 26,
      "context" : "3 of [27] offers simple and elegant proof of a random feature method.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 34,
      "context" : "Since the sketching methods usually works better than the random feature methods (see the examples in [35]), the users are advised to apply the sketching methods introduced in Chapter 6.",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 8,
      "context" : "Besides the two kinds of low-rank approximation approaches, the stochastic optimization approach [9] also demonstrates very high scalability.",
      "startOffset" : 97,
      "endOffset" : 100
    } ],
    "year" : 2015,
    "abstractText" : "1",
    "creator" : "LaTeX with hyperref package"
  }
}