{
  "name" : "1503.05671.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Optimizing Neural Networks with Kronecker-factored Approximate Curvature",
    "authors" : [ "James Martens", "Roger Grosse" ],
    "emails" : [ "jmartens@cs.toronto.edu", "rgrosse@cs.toronto.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "The problem of training neural networks is one of the most important and highly investigated ones in machine learning. Despite work on layer-wise pretraining schemes, and various sophisticated optimization methods which try to approximate Newton-Raphson updates or natural gradient updates, stochastic gradient descent (SGD), possibly augmented with momentum, remains the method of choice for large-scale neural network training (Sutskever et al., 2013).\nFrom the work on Hessian-free optimization (HF) (Martens, 2010) and related methods (e.g. Vinyals and Povey, 2012) we know that updates computed using local curvature information can make much more progress per iteration than the scaled gradient. The reason that HF sees fewer practical applications than SGD are twofold. Firstly, its updates are much more expensive to compute, as they involve running linear conjugate gradient (CG) for potentially hundreds of iterations,\n∗jmartens@cs.toronto.edu †rgrosse@cs.toronto.edu\nar X\niv :1\n50 3.\n05 67\n1v 1\n[ cs\n.L G\n] 1\n9 M\nar 2\neach of which requires a matrix-vector product with the curvature matrix (which are as expensive to compute as the stochastic gradient on the current mini-batch). Secondly, HF’s estimate of the curvature matrix must remain fixed while CG iterates, and thus the method is able to go through much less data than SGD can in a comparable amount of time, making it less well suited to stochastic optimizations.\nAs discussed in Martens and Sutskever (2012), CG has the potential to be much faster at local optimization than gradient descent, when applied to quadratic objective functions. Thus, insofar as the objective can be locally approximated by a quadratic, each step of CG could potentially be doing a lot more work than each iteration of SGD, which would result in HF being much faster overall than SGD.\nHowever, there are examples of quadratic functions (e.g. Li, 2005), characterized by curvature matrices with highly spread-out eigenvalue distributions, where CG will have no distinct advantage over well-tuned gradient descent with momentum. Thus, insofar as the quadratic functions being optimized by CG within HF are of this character, HF shouldn’t in principle be faster than welltuned SGD with momentum. The extent to which neural network objective functions give rise to such quadratics is unclear, although (Sutskever et al., 2013) provides some preliminary evidence that they do.\nCG falls victim to this worst-case analysis because it is a first-order method. This motivates us to consider methods which don’t rely on first-order methods like CG as their primary engines of optimization. One such class of methods which have been widely studied are those which work by directly inverting a diagonal, block-diagonal, or low-rank approximation to the curvature matrix (e.g. Becker and LeCun, 1989; Schaul et al., 2013; Le Roux et al., 2008; Ollivier, 2013). In fact, a diagonal approximation of the Fisher information matrix is used within HF as a preconditioner for CG. However, to the best of our knowledge, these methods provide only a limited performance improvement in practice, especially compared to SGD with momentum (see for example Zeiler, 2013), and many practitioners tend to forgo them in favor of SGD or SGD with momentum.\nWe know that the curvature associated with neural network objective functions is highly nondiagonal, and that updates which properly respect and account for this non-diagonal curvature, such as those generated by HF, can make much more progress minimizing the objective than the plain gradient or updates computed from diagonal approximations of the curvature. Thus, if we had an efficient and direct way to compute the inverse of a high-quality non-diagonal approximation to the curvature matrix (i.e. without relying on first-order methods like CG) this could potentially yield an optimization method whose updates would be large and powerful like HF’s, while being (almost) as cheap to compute as the stochastic gradient.\nIn this work we develop such a method, which we call Kronecker-factored Approximate Curvature (K-FAC). We show that our method can be much faster in practice than even highly tuned implementations of SGD with momentum on certain standard neural network optimization benchmarks.\nThe main ingredient in K-FAC is a sophisticated approximation to the Fisher information\nmatrix, which despite being neither diagonal nor low-rank, nor even block-diagonal with small blocks, can be inverted very efficiently, and can be estimated in an online fashion using arbitrarily large subsets of the training data (without increasing the cost of inversion).\nThis approximation is built in two stages. In the first, the rows and columns of the Fisher are divided into groups, each of which corresponds to all the weights in a given layer, and this gives rise to a block-partitioning of the matrix (where the blocks are much larger than those used by Le Roux et al. (2008) or Ollivier (2013)). These blocks are then approximated as Kronecker products between much smaller matrices, which we show is equivalent to making certain approximating assumptions regarding the statistics of the network’s gradients.\nIn the second stage, this matrix is further approximated as having an inverse which is either block-diagonal or block-tridiagonal. We justify this approximation through a careful examination of the relationships between inverse covariances, tree-structured graphical models, and linear regression. Notably, this justification doesn’t apply to the Fisher itself, and our experiments confirm that while the inverse Fisher does indeed possess this structure (approximately), the Fisher itself does not.\nThe rest of this paper is organized as follows. Section 2 gives basic background and notation for neural networks and the natural gradient. Section 3 describes our initial Kronecker product approximation to the Fisher. Section 4 describes our further block-diagonal and block-tridiagonal approximations of the inverse Fisher, and how these can be used to derive an efficient inversion algorithm. Section 5 describes how we compute online estimates of the quantities required by our approximation. Section 6 describes how we use our approximate Fisher to obtain a practical and robust optimization algorithm which requires very little manual tuning, through the careful application of various “damping” techniques (which compensate both for the local quadratic approximation being made to the objective, and for our further approximation of the Fisher). Section 7 describes a simple and effective way of adding a type of “momentum” to K-FAC, which we have found works very well in practice. Section 8 describes the computational costs associated with KFAC, and various ways to reduce them to the point where each update is at most only several times more expensive than computing the stochastic gradient. Section 9 characterizes a broad class of network transformations and reparameterizations to which K-FAC is essentially invariant. Section 10 considers some related prior methods for neural network optimization. Proofs of formal results are located in the appendix."
    }, {
      "heading" : "2 Background and notation",
      "text" : ""
    }, {
      "heading" : "2.1 Neural Networks",
      "text" : "In this section we will define the basic notation for feed-forward neural networks which we will use throughout this paper. Note that this presentation closely follows the one from Martens (2014).\nA neural network transforms its input a0 = x to an output f(x, θ) = a` through a series of ` layers, each of which consists of a bank of units/neurons. The units each receive as input a weighted sum of the outputs of units from the previous layer and compute their output via a nonlinear “activation” function. We denote by si the vector of these weighted sums for the i-th layer, and by ai the vector of unit outputs (aka “activities”). The precise computation performed at each layer i ∈ {1, . . . , `} is given as follows:\nsi = Wiāi−1\nai = φi(si)\nwhere φi is an element-wise nonlinear function, Wi is a weight matrix, and āi is defined as the vector formed by appending an additional homogeneous coordinate with value 1 to ai. Note that we do not include explicit bias parameters here as these are captured implicitly through our use of homogeneous coordinates. In particular, the last column of each weight matrix Wi corresponds to what is usually thought of as the “bias vector”.\nWe will define θ = [vec(W1)> vec(W2)> . . . vec(W`)>]>, which is the vector consisting of all of the network’s parameters concatenated together, where vec is the operator which vectorizes matrices by stacking their columns together.\nWe let L(y, z) denote the loss function which measures the disagreement between a prediction z made by the network, and a target y. The training objective function h(θ) is the average (or expectation) of losses L(y, f(x, θ)) with respect to a training distribution Q̂x,y over input-target pairs (x, y). h(θ) is a proxy for the objective which we actually care about but don’t have access to, which is the expectation of the loss taken with respect to the true data distribution Qx,y.\nWe will assume that the loss is given by the negative log probability associated with a simple predictive distribution Ry|z for y parameterized by z, i.e. that we have\nL(y, z) = − log r(y|z)\nwhere r is Ry|z’s density function. This is the case for both the standard least-squares and crossentropy objective functions, where the predictive distributions are multivariate normal and multinomial, respectively.\nWe will let Py|x(θ) = Ry|f(x,θ) denote the conditional distribution defined by the neural network, as parameterized by θ, and p(y|x, θ) = r(y|f(x, θ)) its density function. Note that minimizing the objective function h(θ) can be seen as maximum likelihood learning of the model Py|x(θ).\nFor convenience we will define the following additional notation:\nDv = dL(y, f(x, θ)) dv = −d log p(y|x, θ) dv\nand gi = Dsi\nAlgorithm 1 shows how to compute the gradient of the loss function of a neural network using standard backpropagation.\nAlgorithm 1 An algorithm for computing the gradient of the loss L(y, f(x, θ)) for a given (x, y). Note that we are assuming here for simplicity that the φi are defined as coordinate-wise functions.\ninput: a0 = x; θ mapped to (W1,W2, . . . ,W`).\n/* Forward pass */ for all i from 1 to ` do si ← Wiāi−1 ai ← φi(si) end for\n/* Loss derivative computation */ Da` ← − ∂L(y, z)\n∂z\n∣∣∣∣ z=a`\n/* Backwards pass */ for all i from ` downto 1 do gi ← Dai φ′i(si) DWi ← giā>i−1 Dai−1 ← W>i gi end for\noutput: Dθ = [vec(DW1)> vec(DW2)> . . . vec(DW`)>]>"
    }, {
      "heading" : "2.2 The Natural Gradient",
      "text" : "Because our network defines a conditional model Py|x(θ), it has an associated Fisher information matrix (which we will simply call “the Fisher”) which is given by\nF = E\n[ d log p(y|x, θ)\ndθ\nd log p(y|x, θ) dθ\n> ]\n= E[DθDθ>]\nHere, the expectation is taken with respect to the data distributionQx over inputs x, and the model’s predictive distribution Py|x(θ) over y. Since we usually don’t have access to Qx, and the above expectation would likely be intractable even if we did, we will instead compute F using the training distribution Q̂x over inputs x.\nThe well-known natural gradient (Amari, 1998) is defined as F−1∇h(θ). Motivated from the perspective of information geometry (Amari and Nagaoka, 2000), the natural gradient defines the direction in parameter space which gives the largest change in the objective per unit of change in the model, as measured by the KL-divergence. This is to be contrasted with the standard gradient, which can be defined as the direction in parameter space which gives the largest change in the objective per unit of change in the parameters, as measured by the standard Euclidean metric.\nThe natural gradient also has links to several classical ideas from optimization. It can be shown (Martens, 2014; Pascanu and Bengio, 2014) that the Fisher is equivalent to the Generalized Gauss-Newton matrix (GGN) (Schraudolph, 2002; Martens and Sutskever, 2012) in certain important cases, which is a well-known PSD approximation to the Hessian of the objective function. Indeed, the GGN has served as the curvature matrix of choice in HF and related methods, and so in light of its equivalence to the Fisher, these methods can all be seen as approximate natural gradient methods.\nIn particular, (Martens, 2014) showed that when the GGN is defined so that the network is linearized up to the loss function, and the loss function corresponds to the negative log probability of observations under an exponential family model Ry|z with natural parameters z, then the Fisher corresponds exactly to the GGN.1\nFor some good recent discussion and analysis of the natural gradient, see Arnold et al. (2011); Martens (2014); Pascanu and Bengio (2014)."
    }, {
      "heading" : "3 A block-wise Kronecker-factored Fisher approximation",
      "text" : "The main computational challenge associated with using the natural gradient is computing F−1 (or its product with ∇h). For large networks, with potentially millions of parameters, computing this\n1Note that the condition that z is the natural parameters might require one to formally include the nonlinear transformation usually performed by the final nonlinearity φ` of the network (such as the logistic-sigmoid transform before a cross-entropy error) as part of the loss function L instead. Equivalently, one could linearize the network only up to the input s` to φ` when computing the GGN (see Martens and Sutskever (2012)).\ninverse naively is computationally impractical. In this section we develop an initial approximation of F which will be a key ingredient in deriving our efficiently computable approximation to F−1 and the natural gradient.\nNote that Dθ = [vec(DW1)> vec(DW2)> · · · vec(DW`)>]> and so F can be expressed as F = E [ DθDθ> ] = E [ [vec(DW1)> vec(DW2)> · · · vec(DW`)>]>[vec(DW1)> vec(DW2)> · · · vec(DW`)>]\n] =  E [ vec(DW1) vec(DW1)> ] E [ vec(DW1) vec(DW2)> ] · · · E [ vec(DW1) vec(DW`)> ] E [ vec(DW2) vec(DW1)> ] E [ vec(DW2) vec(DW2)> ] · · · E [ vec(DW2) vec(DW`)> ] ... ... . . . ...\nE [ vec(DW`) vec(DW1)> ] E [ vec(DW`) vec(DW2)> ] · · · E [ vec(DW`) vec(DW`)>\n] \nThus, we see that F can be viewed as an ` by ` block matrix, with the (i, j)-th block Fi,j given by Fi,j = E [ vec(DWi) vec(DWj)> ] .\nNoting that DWi = giā>i−1 and that vec(uv>) = v ⊗ u we have vec(DWi) = vec(giā>i−1) = āi−1 ⊗ gi, and thus we can rewrite Fi,j as\nFi,j = E [ vec(DWi) vec(DWj)> ] = E [ (āi−1 ⊗ gi)(āj−1 ⊗ gj)> ] = E [ (āi−1 ⊗ gi)(ā>j−1 ⊗ g>j ) ] = E [ āi−1ā > j−1 ⊗ gig>j\n] where A⊗B denotes the Kronecker product between A and B.\nOur initial approximation F̃ to F will be defined by the following block-wise approximation: Fi,j = E [ āi−1ā > j−1 ⊗ gig>j ] ≈ E [ āi−1ā > j−1 ] ⊗ E [ gig > j ] = Āi−1,j−1 ⊗Gi,j = F̃i,j (1)\nwhere Āi,j = E [ āiā > j ] and Gi,j = E [ gig > j ] .\nThis gives\nF̃ =  Ā0,0 ⊗G1,1 Ā0,1 ⊗G1,2 · · · Ā0,`−1 ⊗G1,` Ā1,0 ⊗G2,1 Ā1,1 ⊗G2,2 · · · Ā1,`−1 ⊗G2,` ... ... . . .\n... Ā`−1,0 ⊗G`,1 Ā`−1,1 ⊗G`,2 · · · Ā`−1,`−1 ⊗G`,`  which has the form of what is known as a Khatri-Rao product in multivariate statistics.\nThe expectation of a Kronecker product is, in general, not equal to the Kronecker product of expectations, and so this is indeed a strong approximation to make, and one which likely won’t become exact under any realistic set of assumptions, or as a limiting case in some kind of asymptotic analysis. Nevertheless, it seems to be fairly accurate in practice, as demonstrated in Figure 1 for an example network.\nAs we will see in later sections, this approximation leads to significant computational savings in terms of storage and inversion, which we will be able to leverage in order to design an efficient algorithm for computing an approximation to the natural gradient."
    }, {
      "heading" : "3.1 Interpretations of this approximation",
      "text" : "Consider an arbitrary pair of weights [Wi]k1,k2 and [Wj]k3,k4 from the network, where [·]i,j denotes the value of the (i, j)-th entry. We have that the corresponding derivatives of these weights are given by D[Wi]k1,k2 = ā(1)g(1) and D[Wj]k3,k4 = ā(2)g(2), where we denote for convenience ā(1) = [āi−1]k1 , ā (2) = [āj−1]k3 , g (1) = [gi]k2 , and g (2) = [gj]k4 .\nThe approximation given by eqn. 1 is equivalent to making the following approximation for each pair of weights:\nE [D[Wi]k1,k2D[Wj]k3,k4 ] = E [ (ā(1)g(1))(ā(2)g(2)) ] = E [ ā(1)ā(2) g(1)g(2) ] ≈ E [ ā(1)ā(2) ] E [ g(1)g(2) ] (2)\nAnd thus one way to interpret the approximation in eqn. 1 is that we are assuming statistical independence between products ā(1)ā(2) of unit activities and products g(1)g(2) of unit input derivatives.\nAnother more detailed interpretation of the approximation emerges by considering the following expression for the approximation error E [ ā(1)ā(2) g(1)g(2) ] −E [ ā(1)ā(2) ] E [ g(1)g(2) ] (which is derived in the appendix):\nκ(ā(1), ā(2), g(1), g(2)) + E[ā(1)]κ(ā(2), g(1), g(2)) + E[ā(2)]κ(ā(1), g(1), g(2)) (3)\nwhere κ(·) denotes the cumulant of its arguments.\nCumulants are a natural generalization of the concept of mean and variance to higher orders, and indeed 1st-order cumulants are means and 2nd-order cumulants are covariances. Intuitively,\ncumulants of order k measure the degree to which the interaction between variables is intrinsically of order k, as opposed to arising from many lower-order interactions.\nA basic upper bound for the approximation error is thus\n|κ(ā(1), ā(2), g(1), g(2))|+ |E[ā(1)]||κ(ā(2), g(1), g(2))|+ |E[ā(2)]||κ(ā(1), g(1), g(2))| (4)\nwhich will be small if all of the higher-order cumulants are small (i.e. those of order 3 or higher). Note that in principle this upper bound may be loose due to possible cancellations between the terms in eqn. 3.\nBecause higher-order cumulants are zero for variables jointly distributed according to a multivariate Gaussian, it follows that this upper bound on the approximation error will be small insofar as the joint distribution over ā(1), ā(2), g(1), and g(2) is well approximated by a multivariate Gaussian. And while we are not aware of an argument for why this should be the case in practice, we can provide some empirical evidence that it is indeed the smallness of the higher-order cumulants which is responsible for approximation error being relatively small. In particular, for the example network from Figure 1, the total approximation error, summed over all pairs of weights in the middle 4 layers, is 291.7, while the corresponding upper bound, whose size is tied to that of the higher order cumulants (due to the impossibility of cancellations in eqn. 4), is 446.8."
    }, {
      "heading" : "4 Additional approximations to F̃ and inverse computations",
      "text" : "To the best of our knowledge there is no efficient general method for inverting a Khatri-Rao product like F̃ . Thus, we must make further approximations if we hope to obtain an efficiently computable approximation of the inverse Fisher.\nIn the following subsections we argue that the inverse of F̃ can be reasonably approximated as having one of two special structures, either of which make it efficiently computable. The second of these will be slightly less restrictive than the first (and hence a better approximation) at the cost of some additional complexity. We will then show how matrix-vector products with these approximate inverses can be efficiently computed, which will thus give an efficient algorithm for computing an approximation to the natural gradient."
    }, {
      "heading" : "4.1 Structured inverses and the connection to linear regression",
      "text" : "Suppose we are given a multivariate distribution over some variables, whose covariance matrix is Σ.\nDefine the matrixB so that for i 6= j [B]i,j is the coefficient on the j-th variable in the optimal linear predictor of the i-th variable from all the other variables, and [B]i,j = 0 for i = j. Then define the matrix D to be the diagonal matrix where [D]i,i is the variance of the error associated with such a predictor of the i-th variable.\nPourahmadi (2011) showed that B can be obtained from the inverse covariance Σ−1 by the formula\n[B]i,j = − [Σ−1]i,j [Σ−1]i,i and [D]i,i = 1 [Σ−1]i,i\nFrom this it follows that the inverse covariance of the data can be expressed as\nΣ−1 = D−1(I −B)\nIntuitively, this result says that each row of the inverse covariance Σ−1 is given by the coefficients of the optimal linear predictor of the i-th variable from the others, up to a scaling factor. So if the j-th variable is much less useful than the other variables for predicting the i-th variable, we can expect that the (i, j)-th entry of the inverse covariance will be relatively small.\nNoting that the Fisher F is a covariance matrix over Dθ w.r.t. the model’s predictive distribution (because E[Dθ] = 0), we can thus apply the above analysis to the distribution over Dθ to gain insight into the approximate structure of F−1, and by extension its approximation F̃−1.\nConsider the derivative DWi of the loss with respect to the weights Wi of layer i. Intuitively, if we are trying to predict one of the entries of DWi from the other entries of Dθ, those entries of Dθ also in DWi will be the most useful in this regard. Thus, it stands to reason that the largest entries of F̃−1 will be those on the diagonal blocks (i.e. those between different entries of a given DWi), so that F̃−1 will be well approximated as block-diagonal, with each block corresponding to a different DWi.\nBeyond the other entries of DWi, it is the entries of DWi+1 and DWi−1 (i.e. those associated with adjacent layers) that will arguably be the most useful in predicting a given entry of DWi. This is because the true process for computing the loss gradient only uses information from the layer below (during the forward pass) and from the layer above (during the backwards pass). Thus, approximating F̃−1 as block-tridiagonal seems like a reasonable and milder alternative than taking it to be block-diagonal.\nIndeed, this approximation would be exact if the distribution over Dθ was given by a directed graphical model which generated each of the DWi’s, one layer at a time, from either DWi+1 or DWi−1. Or equivalently, if DWi were distributed according to an undirected Gaussian graphical model with binary potentials only between entries in the same or adjacent layers. And while in reality the DWi’s are generated using information from adjacent layers according to a process that is neither linear nor Gaussian, it nonetheless stands to reason that their joint statistics might be reasonably approximated by such a model. In fact, the idea of approximating the distribution over loss gradients with a directed graphical model forms the basis of the recent FANG method (Grosse and Salakhutdinov, 2014).\nFigure 2 examines the extent to which the inverse Fisher is well approximated as blockdiagonal or block-tridiagonal for an example network.\nIn the following two subsections we show how both the block-diagonal and block-tridiagonal approximations to F̃−1 give rise to computationally efficient methods for computing matrix-vector products with it. And at the end of Section 4 we present two figures (Figures 4 and 5) which examine the quality of these approximations for an example network."
    }, {
      "heading" : "4.2 Approximating F̃−1 as block-diagonal",
      "text" : "Approximating F̃−1 as block-diagonal is equivalent to approximating F̃ as block-diagonal. A natural choice for such an approximation F̆ of F̃ , is to take the block-diagonal of F̆ to be that of F̃ .\nThis gives the matrix F̆ = diag ( F̃1,1, F̃2,2, . . . , , F̃`,` ) = diag ( Ā0,0 ⊗G1,1, Ā1,1 ⊗G2,2, . . . , Ā`−1,`−1 ⊗G`,` ) whose inverse is easily computed as\nF̆−1 = diag ( Ā−10,0 ⊗G−11,1, Ā−11,1 ⊗G−12,2, . . . , Ā−1`−1,`−1 ⊗G −1 `,` ) Thus, computing F̆−1 amounts to computing the inverses of 2` smaller matrices.\nThen to compute u = F̆−1v, we can make use of the well-known identity (A⊗B) vec(X) = vec(BXA>) to get\nUi = G −1 i,i ViĀ −1 i−1,i−1\nwhere v maps to (V1, V2, . . . , V`) and similarly u maps to (U1, U2, . . . , U`), in an analogous way to how θ maps to (W1,W2, . . . ,W`).\nNote that block-diagonal approximations to the Fisher information have been proposed before (Le Roux et al., 2008), where each block corresponds to the weights associated with a particular unit. In our block-diagonal approximation, the blocks correspond to all the parameters in a given layer, and are thus much larger. In fact, they are so large that they would be impractical to invert as general matrices."
    }, {
      "heading" : "4.3 Approximating F̃−1 as block-tridiagonal",
      "text" : "Note that unlike in the above block-diagonal case, assuming that F̃−1 is block-tridiagonal is not equivalent to assuming that F̃ is block-tridiagonal. Thus we require a more sophisticated approach to deal with such an approximation, which we develop in this subsection.\nTo start, we will define F̂ to be the matrix which agrees with F̃ on the tridiagonal blocks, and which satisfies the property that F̂−1 is block-tridiagonal. Note that this definition implies certain values for the off-tridiagonal blocks of F̂ which will differ from those of F̃ insofar as F̃−1 isn’t well approximated as block-tridiagonal.\nTo establish that this definition of F̂ makes sense and is useful, we will show that under the assumption that F̂−1 is block-tridiagonal, the values of the tridiagonal blocks of F̂ uniquely determine F̂−1. Moreover, this mapping can be efficiently computed in a way that takes advantage of the fact that the blocks are factored as Kronecker products of smaller matrices.\nOur strategy for doing this will be as follows. First, we will show that assuming that F̂−1 is block-tridiagonal is equivalent to assuming that it is the precision matrix of an directed Gaussian graphical model (DGGM) where the ` nodes correspond to each of the DWi’s (or more precisely, their vectorizations vec(DWi)), and where nodes corresponding to adjacent layers are connected, thus giving the model a path-like structure. We will then show that the parameters of this model are determined by the tridiagonal blocks of F̂ . Finally, we will use a generic formula for finding the inverse covariance matrix of DGGMs to obtain a formula for F̂−1. Critically, it will turn out that the particular structure of this formula allows us to take advantage of the Kronecker-product structure of the blocks to simplify the computations.\nTo establish the aforementioned equivalence, we note that a block-tridiagonal inverse covariance gives rise to an undirected Gaussian graphical model (UGGM) over Dθ with the desired path structure, whose density function is proportional to exp(−Dθ>F̂−1Dθ). As paths are examples of trees, we can then use the fact that tree-structured undirected graphical models are equivalent to directed graphical models with the same graph structure (e.g. Bishop, 2006), with directionality added to the edges so that the resulting graph is a DAG. Moreover, this equivalent directed model will also be linear/Gaussian, and hence a DGGM.\nNext we will show how the parameters of the DGGM corresponding to F̂ can be computed from the tridiagonal blocks of F̂ . We will assume here that the direction of the edges are from\nthe higher layers to lower ones. Note that a different choice for these directions would produce a slightly different algorithm that would nonetheless yield the same output.\nFor each i, we will denote the conditional covariance matrix of vec(DWi) on vec(DWi+1) by Σi|i+1 and the linear coefficients from vec(DWi+1) to vec(DWi) by the matrix Ψi,i+1, so that the conditional distributions defining the model are\nvec(DWi) ∼ N ( Ψi,i+1vec(DWi+1), Σi|i+1 ) and vec(DW`) ∼ N ( ~0, Σ` ) See Figure 3 for a depiction of the UGGM corresponding to F̂−1 and its equivalent DGGM.\nSince Σ` is just the covariance of vec(DW`), it is given simply by F̂`,` = F̃`,`. And for i ≤ `− 1, we can see that Ψi,i+1 is given by\nΨi,i+1 = F̂i,i+1F̂ −1 i+1,i+1 = F̃i,i+1F̃ −1 i+1,i+1 = ( Āi−1,i ⊗Gi,i+1 ) ( Āi,i ⊗Gi+1,i+1 )−1 = ΨĀi−1,i ⊗ΨGi,i+1\nwhere\nΨĀi−1,i = Āi−1,iĀ −1 i,i and Ψ G i,i+1 = Gi,i+1G −1 i+1,i+1\nThe conditional covariance Σi|i+1 is thus given by\nΣi|i+1 = F̂i,i −Ψi,i+1F̂i+1,i+1Ψ>i,i+1 = F̃i,i −Ψi,i+1F̃i+1,i+1Ψ>i,i+1 = Āi−1,i−1 ⊗Gi,i −ΨĀi−1,iĀi,iΨĀ>i−1,i ⊗ΨGi,i+1Gi+1,i+1ΨG>i,i+1\nFollowing the work of Grosse and Salakhutdinov (2014), we use the block generalization of well-known “Cholesky” decomposition of the precision matrix of DGGMs (Pourahmadi, 1999),\nwhich gives\nF̂−1 = Ξ>ΛΞ\nwhere,\nΛ = diag (\nΣ−11|2,Σ −1 2|3, . . . , Σ −1 `−1|`,Σ −1 `\n) and Ξ =  I −Ψ1,2 I −Ψ2,3 I . . .\n. . . −Ψ`−1,` I  Thus, matrix-vector multiplication with F̂−1 amounts to performing matrix-vector multipli-\ncation by Ξ, followed by Λ, and then by Ξ>.\nAs in the block-diagonal case considered in the previous subsection, matrix-vector products with Ξ (and Ξ>) can be efficiently computed by using the well-known property (A ⊗ B)−1 = A−1 ⊗B−1. In particular, u = Ξ>v can be computed as\nUi = Vi −ΨG>i−1,iVi−1ΨĀi−2,i−1 and U1 = V1\nand similarly u = Ξv can be computed as\nUi = Vi −ΨGi,i+1Vi+1ΨĀ>i−1,i and U` = V`\nwhere the Ui’s and Vi’s are defined in terms of u and v as in the previous subsection.\nMultiplying a vector v by Λ amounts to multiplying each vec(Vi) by the corresponding Σ−1i|i+1. This is slightly tricky because Σi|i+1 is the difference of Kronecker products, so we cannot use the straightforward identity (A ⊗ B)−1 = A−1 ⊗ B−1. Fortunately, there are efficient techniques for inverting such matrices which we discuss in detail in Section B."
    }, {
      "heading" : "5 Estimating the required Āi,j’s and Gi,j’s",
      "text" : "Recall that Āi,j = E [ āiā > j ] and Gi,j = E [ gig > j ] . Both approximate Fisher inverses discussed in Section 4 require some subset of these. In particular, the block-diagonal approximation requires them for i = j, while the block-tridiagonal approximation requires them for j ∈ {i, i+ 1} (noting that Ā>i,j = Āj,i and G > i,j = Gj,i).\nSince the āi’s don’t depend on y, we can take the expectation E [ āiā > j ] with respect to just\nthe training distribution Q̂x over the inputs x. On the other hand, the gi’s do depend on y, and so the expectation2 E [ gig > j ] must be taken with respect to both Q̂x and the network’s predictive\n2It is important to note this expectation should not be taken with respect to the training/data distribution over y (i.e. Q̂y|x or Qy|x). Using the training/data distribution for y would perhaps give an approximation to a quantity known as the “empirical Fisher information matrix”, which lacks the previously discussed equivalence to the Generalized Gauss-\ndistribution Py|x.\nWhile computing matrix-vector products with the Gi,j could be done exactly and efficiently for a given input x (or small mini-batch of x’s) by adapting the methods of Schraudolph (2002), there doesn’t seem to be a sufficiently efficient method for computing the entire matrix itself. Indeed, the hardness results of Martens et al. (2012) suggest that this would require, for each example x in the mini-batch, work that is asymptotically equivalent to matrix-matrix multiplication involving matrices the same size as Gi,j . While a small constant number of such multiplications is arguably an acceptable cost (see Section 8), a number which grows with the size of the mini-batch would not be.\nInstead, we will approximate the expectation over y by a standard Monte-Carlo estimate obtained by sampling y’s from the network’s predictive distribution and then rerunning the backwards phase of backpropagation (see Algorithm 1) as if these were the training targets.\nNote that computing/estimating the required Āi,j/Gi,j’s involves computing averages over outer products of various āi’s from network’s usual forward pass, and gi’s from the modified backwards pass (with targets sampled as above). Thus we can compute/estimate these quantities on the same input data used to compute the gradient∇h, at the cost of one or more additional backwards passes, and a few additional outer-product averages. Fortunately, this turns out to be quite inexpensive, as we have found that just one modified backwards pass is sufficient to obtain a good quality estimate in practice, and the required outer-product averages are similar to those already used to compute the gradient in the usual backpropagation algorithm.\nIn the case of online/stochastic optimization we have found that the best strategy is to maintain running estimates of the required Āi,j’s andGi,j’s using a simple exponentially decaying averaging scheme. In particular, we take the new running estimate to be the old one weighted by α, plus the estimate on new mini-batch weighted by 1− α, for α = 0.95 (or thereabouts).\nNote that the more naive averaging scheme where the estimates from each iteration are given equal weight would be inappropriate here. This is because the Āi,j’s and Gi,j’s depend on the network’s parameters θ, and these will slowly change over time as optimization proceeds, so that estimates computed many iterations ago will become stale.\nThis kind of exponentially decaying averaging scheme is commonly used in methods involving diagonal or block-diagonal approximations (with much smaller blocks than ours) to the curvature matrix (e.g. Park et al., 2000; Schaul et al., 2013). Such schemes have the desirable property that they allow the curvature estimate to depend on much more data than can be reasonably processed in a single mini-batch.\nNotably, for methods like HF which deal with the exact Fisher indirectly via matrix-vector products, such a scheme would be impossible to implement efficiently, as the exact Fisher matrix\nNewton matrix, and would not be compatible with the theoretical analysis performed in Section 3.1 (in particular, Lemma 4 would break down). Moreover, such a choice would not give rise to what is usually thought of as the natural gradient, and based on the findings of Martens (2010), would likely perform worse in practice as part of an optimization algorithm. See Martens (2014) for a more detailed discussion of the empirical Fisher.\n(or GGN) seemingly cannot be summarized using a compact data structure whose size would be independent of the amount of data used to estimate it. Indeed, it seems that the only representation of the exact Fisher which wouldn’t grow in size with the amount of training cases used to compute it would be an explicit n × n matrix (which is far to big to be practical). Because of this, HF and related methods must base their curvature estimates only on subsets of data that can be reasonably processed all at once, which limits their effectiveness in the stochastic optimization regime."
    }, {
      "heading" : "6 Update damping",
      "text" : "The idealized natural gradient approach is to follow the smooth path3 in the Riemannian manifold (implied by the Fisher information matrix viewed as a metric tensor) that is generated by taking a series of infinitesimally small steps (in the original parameter space) in the direction of the natural gradient (which gets recomputed at each point). While this is clearly impractical as a real optimization method, one can take larger steps and still follow these paths approximately. But in our experience, to obtain an update which satisfies the minimal requirement of not worsening the objective function value, one must make the step size so small that the resulting optimization algorithm is not practical.\nThe reason that the natural gradient can only be reliably followed a short distance is that it is defined merely as an optimal direction (which trades off improvement in the objective versus change in the predictive distribution), and not a discrete update. Fortunately, as observed by Martens (2014), the natural gradient can be understood using a more traditional optimizationtheoretic perspective which implies how it can be used to generate updates that will be useful over larger distances. In particular, when Ry|z is an exponential family model with z as its natural parameters (as it will be in our experiments), Martens (2014) showed that the Fisher becomes equivalent to the Generalized Gauss-Newton matrix (GGN), which is a positive semi-definite approximation of the Hessian of h. From this it follows that\nM(δ) = 1\n2 δ>Fδ +∇h(θ)>δ + h(θ) (5)\ncan be viewed as an approximation of the 2nd-order Taylor series of expansion of h(δ+ θ), whose minimizer is the (negative) natural gradient −F−1∇h(θ).\nNote that if we add an `2 or “weight-decay” regularization term to h of the form η\n2 ‖θ‖22, then\nsimilarly F + ηI can be viewed as an approximation of the Hessian of h, and replacing F with F +ηI in M(δ) yields an approximation of the 2nd-order Taylor series, whose minimizer is a kind of “regularized” (negative) natural gradient −(F + ηI)−1∇h(θ) (which is what we end up using in practice).\n3Which has the interpretation of being a geodesic in the Riemannian manifold from the current predictive distribution towards the training distribution when using a likelihood or KL-divergence based objective function (see Martens (2014)).\nFrom the interpretation of the natural gradient as the minimizer of M(δ), we can see that it fails to be useful as a local update only insofar as M(δ) fails to be a good local approximation to h(δ+θ). And so as argued by Martens (2014), it is natural to make use of the various sophisticated “damping” techniques that have been developed in the optimization literature for dealing with the breakdowns in local quadratic approximations. These include techniques such as Tikhonov damping/regularization, line-searches, and trust regions, etc., all of which tend to be much more effective in practice than merely re-scaling the update. Indeed, a subset of these techniques were exploited in the work of Martens (2010), and have appeared implicitly in older works such as Becker and LeCun (1989). For detailed discussion of these and other damping techniques, we refer the reader to Martens and Sutskever (2012).\nMethods like HF which use the exact Fisher seem to work reasonably well with an adaptive Tikhonov regularization technique where λI is added to F + ηI , and where λ is adapted according to Levenberg-Marquardt style adjustment rule. However, we found that this simple technique is insufficient when used with our approximate natural gradient update proposals. In particular, we have found that there never seems to be a “good” choice for λ that gives rise to updates which are of a quality comparable to those produced by methods that use the exact Fisher, such as HF.\nOne possible explanation for this finding is that, unlike quadratic models based on the exact Fisher (or equivalently, the GGN), the one underlying K-FAC has no guarantee of being accurate up to 2nd-order. Thus, λ must remain large in order to compensate for this this intrinsic 2nd-order inaccuracy of the model, which has the side effect of “washing out” the small eigenvalues (which represent important low-curvature directions).\nFortunately, through trial and error, we were able to find a relatively simple and highly effective damping method which works well for K-FAC. This involves the use of an adaptive Tikhonov damping/regularization technique, combined with a re-scaling technique which makes very limited and economical use of the exact Fisher F (as estimated on the current mini-batch). We discuss the details of this method in the following subsections."
    }, {
      "heading" : "6.1 A factored Tikhonov regularization technique",
      "text" : "In the usual Tikhonov regularization/damping technique, one adds (λ+η)I to the curvature matrix (where η accounts for the `2 regularization), which is equivalent to adding a term of the form λ+ η\n2 ‖δ‖22 toM(δ). For the block-diagonal approximation F̆ of F̃ (from Section 4.2) this amounts to adding (λ + η)I (for a lower dimensional I) to each of the individual diagonal blocks, which gives modified diagonal blocks of the form\nĀi−1,i−1 ⊗Gi,i + (λ+ η)I = Āi−1,i−1 ⊗Gi,i + (λ+ η)I ⊗ I (6)\nBecause this is the sum of two Kronecker products we cannot anymore use the simple identity (A ⊗ B)−1 = A−1 ⊗ B−1. Fortunately however, there are efficient techniques for inverting such matrices, which we discuss in detail in Section B.\nIf we try to apply this same Tikhonov technique to our more sophisticated approximation F̂ of F̃ (from Section 4.3) by adding (λ+η)I to each of the diagonal blocks of F̂ , it is no longer clear how to efficiently invert F̂ . Instead, a solution which we have found works very well in practice is to add πi( √ λ+ η)I and 1 πi ( √ λ+ η)I for a scalar constant πi to the individual Kronecker factors Āi−1,i−1 and Gi,i (resp.) of each diagonal block, giving( Āi−1,i−1 + πi( √ λ+ η)I ) ⊗ ( Gi,i + 1 πi ( √ λ+ η)I ) (7)\nAs this is a single Kronecker product, all of the computations described in Sections 4.2 and 4.3 can still be used here too, simply by replacing each Āi−1,i−1 and Gi,i with their modified versions Āi−1,i−1 + πi( √ λ+ η)I and Gi,i + 1 πi ( √ λ+ η)I .\nTo see why the expression in eqn. 7 is a reasonable approximation to eqn. 6, note that expanding it gives\nĀi−1,i−1 ⊗Gi,i + πi( √ λ+ η)I ⊗Gi,i + 1 πi ( √ λ+ η)Āi−1,i−1 ⊗ I + (λ+ η)I ⊗ I\nwhich differs from eqn. 6 by the residual error expression\nπi( √ λ+ η)I ⊗Gi,i + 1 πi ( √ λ+ η)Āi−1,i−1 ⊗ I\nWhile a choice of πi = 1 is simple and works well in practice, a slightly more principled choice can be found by minimizing the obvious upper bound (following from the triangle inequality) on the matrix norm of this residual expression, for some matrix norm ‖ · ‖υ. This gives\nπi = √ ‖Āi−1,i−1 ⊗ I‖υ ‖I ⊗Gi,i‖υ\nEvaluating this expression can be done efficiently for various common choices of the matrix norm ‖ · ‖υ. For example, for a general B we have ‖I ⊗B‖F = ‖B ⊗ I‖F = √ d‖B‖F where d is the height/dimension of I , and also ‖I ⊗B‖2 = ‖B ⊗ I‖2 = ‖B‖2."
    }, {
      "heading" : "6.2 Re-scaling according to the exact F",
      "text" : "Given an update proposal ∆ produced by multiplying the negative gradient −∇h by our approximate Fisher inverse (subject to the Tikhonov technique described in the previous subsection), the second stage of our proposed damping technique re-scales ∆ according to the quadratic model M(δ). More precisely, we will choose α so that δ = α∆ optimizes the quadratic model M(δ), as\ncomputed using an estimate of the exact Fisher F (to which we also add the `2 regularization + Tikhonov term (λ+ η)I). In particular, we minimize the following function with respect to α:\nM(δ) = M(α∆) = α2\n2 ∆>(F + (λ+ η)I)∆ + α∇h>∆ + h(θ)\nBecause this is a 1-dimensional minimization, the formula for the optimal α can be computed simply as\nα = −∇h>∆\n∆>F∆ + (λ+ η)‖∆‖22\nTo evaluate this formula we use the current stochastic gradient ∇h (i.e. the same one used to produce ∆), and compute matrix-vector products with F using the input data from the same minibatch. While using a mini-batch to compute F gets away from the idea of basing our estimate of the curvature on a long history of data (as we do with the approximate Fisher), it is made slightly less objectionable by the fact that we are only using it estimate a single scalar quantity (∆>F∆). This is to be contrasted with methods like HF which perform a long and careful optimization of M(δ) using such an estimate of F .\nBecause the matrix-vector products with F are only used to compute scalar quantities in KFAC, we can reduce their computational cost by roughly one half (versus standard matrix-vector products with F ) using a simple trick which is discussed in Section C.\nIt is worth mentioning here that by re-scaling ∆ according to M(δ) K-FAC can be viewed as a version of HF which uses our approximate Fisher as a preconditioning matrix (instead of the traditional diagonal preconditioner), and runs CG for only 1 step, initializing it from 0. This observation suggests running CG for longer, thus obtaining an algorithm which is even closer to HF (although using a much better preconditioner for CG). Indeed, this approach works reasonably well in our experience, but suffers from some of the same problems that HF has in the stochastic setting, due its much stronger use of the mini-batch-estimated F ."
    }, {
      "heading" : "6.3 Adapting λ",
      "text" : "It is well known (e.g. Nocedal and Wright, 2006) that optimizing a quadratic function whose curvature matrix is modified by adding λI to it is equivalent to doing the same without this modification, but subject to the constraints that the solution lie within some spherical “trust-region” of radius τ . The relationship of τ to λ is complicated and depends on the properties of the curvature matrix (which is changing constantly), so it is often easier to simply adjust λ directly.\nThe Levenberg-Marquardt style rule used by HF for doing this, which we will also adopt, is given by\nif ρ > 3/4 then λ← ωλ\nif ρ < 1/4 then λ← 1 ω λ\nwhere ρ ≡ h(θ + δ)− h(θ) M(δ) is the “reduction ratio” and 0 < ω < 1 is some decay constant, and all quantities are computed on the current mini-batch. In our experiments we applied this rule every T iterations of K-FAC, with ω = (19/20)T and T = 5, from a starting value of λ = 150. Note that the optimal value of ω and the starting value of λ may be application dependent, and setting them inappropriately could significantly slow down K-FAC in practice.\nComputing ρ can be done quite efficiently. Note that for the optimal δ, M(δ) = 1 2 ∇h>δ, and\nh(θ) is available from the usual forward pass. The only remaining quantity which is needed to evaluate ρ is thus h(θ+ δ), which will require an additional forward pass. But fortunately, we only need to perform this once every T iterations."
    }, {
      "heading" : "7 Momentum",
      "text" : "Sutskever et al. (2013) found that momentum (Polyak, 1964; Plaut et al., 1986) was very helpful in the context of stochastic gradient descent optimization of deep neural networks. A version of momentum is also present in the original HF method, and it plays an arguably even more important role in more “stochastic” versions of HF (Martens and Sutskever, 2012; Kiros, 2013).\nA natural way of adding a momentum-like effect to K-FAC, and one which we have found works well in practice, is to take the update to be δ = α∆ + βδ0, where δ0 is the final update computed at the previous iteration, and where α and β are chosen to minimize M(δ). This allows K-FAC to effectively build up a better solution to the local quadratic optimization problem over many iterations.\nThe optimal solution for α and β can be computed as[ α β ] = − [ ∆>F∆ ∆>Fδ0 δ>0 F∆ δ > 0 Fδ0 ]−1 [∇h>∆ ∇h>δ0 ]\nThe main cost in evaluating this formula is computing the two matrix-vector products F∆ and Fδ0. Fortunately, the technique discussed in Section C can be applied here to compute the 4 required scalars at the cost of only two forwards passes (equivalent to the cost of only one matrixvector product with F ).\nEmpirically we have found that this type of momentum provides substantial acceleration in regimes where the gradient signal has a low noise to signal ratio, which is usually the case in the early to mid stages of stochastic optimization, but can also be the case in later stages if the mini-batch size is made sufficiently large. These findings are consistent with predictions made by\nconvex optimization theory, and with older empirical work done on neural network optimization (LeCun et al., 1998).\nNotably, because the implicit “momentum constant” β in our method is being computed on the fly, one doesn’t have to worry about setting schedules for it, or adjusting it via heuristics, as one often does in the context of SGD.\nInterestingly, if h is a quadratic function (so the definition of M(δ) remains fixed at each iteration), then using this type of momentum makes K-FAC equivalent to performing preconditioned linear CG on M(δ), with the preconditioner given by our approximate Fisher. This follows from the fact that linear CG can be interpreted as a momentum method where the learning rate α and momentum decay constant β are chosen to jointly minimize M(δ) at each iteration."
    }, {
      "heading" : "8 Computational Costs and Efficiency Improvements",
      "text" : "Let d be the average/typical number of units in each layer and m the mini-batch size. The significant computational tasks required to compute a single update/iteration of K-FAC, and rough estimates of their associated computational costs, are as follows:\n1. standard forwards and backwards pass: 2C1`d2m\n2. computation of the gradient ∇h on the current mini-batch using quantities computed in backwards pass: C2`d2m\n3. additional backwards pass with random targets (as described in Section 5): C1`d2m\n4. updating the estimates of the required Āi,j’s and Gi,j’s from quantities computed in the forwards pass and the additional randomized backwards pass: 2C2`d2m\n5. matrix inverses (along with SVDs and matrix square roots for the block-tridiagonal inverse, as described in Section B) required to compute the inverse of the approximate Fisher: C3`d3\nor C4`d3\n6. various matrix-matrix products required to compute the matrix-vector product of the approximate inverse with the stochastic gradient: C4`d3 for the block-diagonal inverse, C5`d3 for the block-tridiagonal inverse\n7. matrix-vector products with the exact F on the current mini-batch using the approach from Section C: 2C1`d2m with momentum, C1`d2m without momentum\n8. additional forward pass required to evaluate the reduction ratio ρ to apply the λ adjustment rule described in Section 6.3: C1`d2m every T iterations (T = 5 in our experiments)\nHere the Ci are various constants that account for implementation details, and we are assuming the use of the naive cubic matrix-matrix multiplication and inversion algorithms when producing the cost estimates. Note that it it is hard to assign precise values to the constants, as they very\nmuch depend on how these various tasks are implemented, and the extent to which parallelism is exploited.\nTasks 1 and 2 represent the standard stochastic gradient computation.\nThe costs of tasks 3 and 4 are similar and slightly smaller than those of tasks 1 and 2. One way to significantly reduce them is to use only a subset of the current mini-batch to update the estimates of the required Āi,j’s andGi,j’s. One can similarly reduce the cost of task 7 by computing the (factored) matrix-vector product with F using such a subset, although we recommend caution when doing this, as using inconsistent sets of data for the quadratic and linear terms in M(δ) can hypothetically cause instability problems which are avoided by using consistent data (see Martens and Sutskever (2012), Section 13.1). In our experiments we used a random 1/8-th of the current mini-batch to update the Āi,j’s and Gi,j’s, and a random 1/4-th to compute the matrix-vector products with F . Doing this seemed to have a negligible effect on the quality of the resultant updates, while significantly reducing per-iteration computation time.\nThe cost of task 8 can be made relatively insignificant by making the adjustment period T for λ large enough. We used T = 5 in our experiments.\nThe costs of tasks 5 and 6 are hard to compare directly with the costs associated with computing the gradient, as their relative sizes will depend on factors such as the architecture of the neural network being trained, as well as the particulars of the implementation. However, one quick observation we can make is that both tasks 5 and 6 involve computations that be performed in parallel across the different layers, which is to be contrasted with many of the other tasks which require sequential passes over the layers of the network.\nClearly, if m d, then the cost of tasks 5 and 6 becomes negligible in comparison to the others. However, it is more often the case that m is comparable or perhaps smaller than d. Moreover, while algorithms for inverses and SVDs tend to have the same asymptotic cost as matrix-matrix multiplication, they are at least several times more expensive in practice, in addition to being harder to parallelize on modern GPU architectures (indeed, CPU implementations are often faster in our experience). Thus, in a naive implementation of K-FAC, task 5 can dominate the overall cost.\nFortunately, there are several possible ways to mitigate the cost of task 5. As mentioned above, one way is to perform the computations for each layer in parallel, and simultaneously with the gradient computation and other tasks. In the case of our block-tridiagonal approximation to the inverse, one can avoid computing any SVDs or matrix square roots by using an iterative Steinequation solver (see Section B). And there are also ways of reducing matrix-inversion (and even matrix square-root) to a short sequence of matrix-matrix multiplications using iterative methods (Pan and Schreiber, 1991). Furthermore, because the matrices in question only change slowly over time, one can consider hot-starting these iterative inversion methods from previous solutions.\nWhile these ideas work reasonable well in practice, perhaps the simplest method, and the one we ended up settling on for our experiments, is to simply recompute the approximate inverses only occasionally, say every 20-50 iterations. As it turns out, the curvature properties of the objective stay relatively stable, especially in later stages of optimization, and so in our experience this strat-\negy of only occasionally recomputing the inverse results in only a modest decrease in the quality of the updates.\nIfm is much smaller than d, the costs associated with task 6 can begin to dominate. And unlike task 5, task 6 must be performed at every iteration. While the simplest solution is to increase m (while reaping the benefits of a less noisy gradient), in the case of the block-diagonal inverse it turns out that we can change the cost of task 6 from C4`d3 to C4`d2m by taking advantage of the low-rank structure of the stochastic gradient. The method for doing this is described below.\nLet Āi and Gi be matrices whose columns are the m āi’s and gi’s (resp.) associated with the current mini-batch. Let ∇Wih denote the gradient of h with respect to Wi, shaped as a matrix (instead of a vector). The estimate of ∇Wih over the mini-batch is given by 1mGiĀ > i−1, which is of rank-m. From Section 4.2, computing the F̆−1∇h amounts to computing Ui = G−1i,i (∇Wih)Ā−1i−1,i−1. Substituting in our mini-batch estimate of∇Wih gives\nUi = G −1 i,i\n( 1\nm GiĀ>i−1\n) Ā−1i−1,i−1 = 1\nm\n( G−1i,i Gi ) ( Ā>i−1Ā−1i−1,i−1 ) Direct evaluation of the expression on the right-hand side involves only matrix-matrix multiplications between matrices of size m× d and d×m (or between those of size d× d and d×m), and thus we can reduce the cost of task 6 to C5`d2m.\nNote that the use of standard `2 weight-decay is not compatible with this trick. This is because the contribution of the weight-decay term to each ∇Wih is νWi, which will typically not be lowrank. Some possible ways around this issue include computing the weight-decay contribution νF̆−1θ separately and refreshing it only occasionally, or using a different regularization method, such as drop-out (Hinton et al., 2012) or weight-magnitude constraints."
    }, {
      "heading" : "9 Invariance Properties and the Relationship to Whitening and",
      "text" : "Centering\nWhen computed with the exact Fisher, the natural gradient specifies a direction in the space of predictive distributions which is invariant to the specific way that the model is parameterized. This invariance means that the smooth path through distribution space produced by following the natural gradient with infinitesimally small steps will be similarly invariant.\nFor a practical natural gradient based optimization method which takes large discrete steps in the direction of the natural gradient, this invariance of the optimization path will only hold approximately. As shown by Martens (2014), the approximation error will go to zero as the effects of damping diminish and the reparameterizing function ζ tends to a locally linear function. Note that the latter will happen as ζ becomes smoother, or the local region containing the update shrinks to zero.\nBecause K-FAC uses an approximation of the natural gradient, these invariance results are not applicable in our case. Fortunately, as was shown by Martens (2014), one can establish invariance of an update direction with respect to a given reparameterization of the model by verifying certain simple properties of the curvature matrix C used to compute the update. We will use this result to show that, under the assumption that damping is absent (or negligible in its affect), K-FAC is invariant to a broad and natural class of affine transformations of the network.\nThis class of transformations is given by the following modified network definition (c.f. the definition in Section 2.1):\ns∗i = Wiā ∗ i−1 ā∗i = Ωiφ̄i(Φis ∗ i )\nwhere φ̄i is the function that computes φi and then appends a homogeneous coordinate (with value 1), Ωi and Φi are arbitrary invertible matrices of the appropriate sizes (except that we assume Ω` = I), ā∗0 = Ω0ā0, and where the network’s output is given by f\n∗(x, θ) = a∗` . Note that because Ωi multiplies φ̄i(Φis∗i ), it can implement arbitrary translations of the unit activities φi(Φis ∗ i ) in addition to arbitrary linear transformations.\nHere, and going forward, we will add a “∗” superscript to any network-dependent quantity in order to denote the analogous version of it computed by the transformed network. Note that under this identification, the loss derivative formulas for the transformed network are analogous to those of the original network, and so our various Fisher approximations are still well defined.\nThe following theorem describes the main technical result of this section.\nTheorem 1. There exists an invertible linear function θ = ζ(θ∗) so that f ∗(x, θ∗) = f(x, θ) = f(x, ζ(θ∗)), and thus the transformed network can be viewed as a reparameterization of the original network by θ∗. Moreover, additively updating θ with −αF̆−1∇h or −αF̂−1∇h in the original network is equivalent to additively updating θ∗ by −αF̆ ∗−1∇h∗ or −αF̂ ∗−1∇h∗ (resp.) in the transformed network.\nThis immediately implies the following corollary which characterizes the invariance of a basic version of K-FAC to the given class of network transformations.\nCorollary 2. The optimization path taken by K-FAC (using either of our Fisher approximations F̆ or F̂ ) through the space of predictive distributions is the same for the default network as it is for the transformed network (where the Ωi’s and Φi’s remain fixed). This assumes the use of an equivalent initialization (θ0 = ζ(θ∗0)), and a basic version of K-FAC where damping is absent or negligible in effect, and where the learning rates are chosen in a way that is independent of the network’s parameterization.\nWhile this corollary assumes that the Ωi’s and Φi’s are fixed, if we relax this assumption so that they are allowed to vary smoothly with θ, then ζ will be a smooth function of θ, and so as discussed in Martens (2014), invariance of the optimization path will hold approximately in a way that depends on the smoothness of ζ (which measures how quickly the Ωi’s and Φi’s change) and\nthe size of the update. Moreover, invariance will hold exactly in the limit as the learning rate goes to 0.\nNote that the network transformations can be interpreted as replacing the network’s nonlinearity φ̄i(si) at each layer i with a “transformed” version Ωiφ̄i(Φisi). So since the well-known logistic sigmoid and tanh functions are related to each other by such a transformation, an immediate consequence of Corollary 2 is that K-FAC is invariant to the choice of logistic sigmoid vs. tanh activation functions (provided that equivalent initializations are used and that the effect of damping is negligible, etc.).\nAlso note that because the network inputs are also transformed by Ω0, K-FAC is thus invariant to arbitrary affine transformations of the input, which includes many popular training data preprocessing techniques.\nMany other natural network transformations, such as ones which “center” and normalize unit activities so that they have mean 0 and variance 1 can be described using diagonal choices for the Ωi’s and Φi’s which vary smoothly with θ. In addition to being approximately invariant to such transformations (or exactly, in the limit as the step size goes to 0), K-FAC is similarly invariant to a more general class of such transformations, such as those which transform the units so that they have a mean of 0, so they are “centered”, and a covariance matrix of I , so they are “whitened”, which is a much stronger condition than the variances of the individual units each being 1.\nIn the case where we use the block-diagonal approximation F̆ and compute updates without damping, Theorem 1 affords us an additional elegant interpretation of what K-FAC is doing. In particular, the updates produced by K-FAC end up being equivalent to those produced by standard gradient descent using a network which is transformed so that the unit activities and the unitgradients are both centered and whitened (with respect to the model’s distribution). This is stated formally in the following corollary.\nCorollary 3. Additively updating θ with αF̆−1∇h in the original network is equivalent to additively updating θ∗ by ∇h∗ (where θ = ζ(θ∗) as in Theorem 1) in a network which is transformed so that the unit activities a∗i and the unit-gradients g ∗ i are both centered and whitened with respect to the model’s distribution."
    }, {
      "heading" : "10 Related Work",
      "text" : "The Hessian-free optimization method of Martens (2010) uses linear conjugate gradient (CG) to optimize local quadratic models of the form of eqn. 5 (subject to an adaptive Tikhonov damping technique) in lieu of directly solving it using matrix inverses. As discussed in the introduction, the main advantages of K-FAC over HF are twofold. Firstly, K-FAC uses an efficiently computable direct solution for the inverse of the curvature matrix and thus avoids the costly matrix-vector products associated with running CG within HF. Secondly, it can estimate the curvature matrix from a lot of data by using an online exponentially-decayed average, as opposed to relatively\nsmall-sized fixed mini-batches used by HF. The cost of doing this is of course the use of an inexact approximation to the curvature matrix.\nLe Roux et al. (2008) proposed a neural network optimization method known as TONGA based on a block-diagonal approximation of the empirical Fisher where each block corresponds to the weights associated with a particular unit. By contrast, K-FAC uses much larger blocks, each of which corresponds to all the weights within a particular layer. The matrices which are inverted in K-FAC are roughly the same size as those which are inverted in TONGA, but rather than there being one per unit as in TONGA, there are only two per layer. Therefore, K-FAC is significantly less computationally intensive than TONGA, despite using what is arguably a much more accurate approximation to the Fisher. Note that to help mitigate the cost of the many matrix inversions it requires, TONGA approximates the blocks as being low-rank + a diagonal term, although this introduces further approximation error.\nCentering methods work by either modifying the gradient (Schraudolph, 1998) or dynamically reparameterizing the network itself (Raiko et al., 2012; Vatanen et al., 2013), so that various unit-wise scalar quantities like the activities (the ai’s) and local derivatives (the φ′i(si)’s) are 0 on average (i.e. “centered”), as they appear in the formula for the gradient. Typically, these methods require the introduction of additional “skip” connections (which bypass the nonlinearities of a given layer) in order to preserve the expressive power/efficiency of the network after these transformations are applied.\nIt is argued by Raiko et al. (2012) that the application of centering methods moves the Fisher closer to a diagonal matrix, and thus makes the gradient a reasonable approximation to the natural gradient. However, this argument uses the strong approximating assumption that the correlations between various network-dependent quantities, such as the activities of different units within a given layer, are zero. In our notation, this would be like assuming that the Gi,i’s are diagonal, and that the Āi,i’s are rank-1 plus a diagonal term. Indeed, using such an approximation within the block-diagonal version of K-FAC would yield an algorithm similar to standard centering, although without the need for skip connections.\nAs shown in Corollary 3, K-FAC can be interpreted as automatically performing centering, along with the much stronger operation of whitening, of the unit activities and various other quantities which appear in the formula for the gradient. Intuitively, it is this whitening which accounts for the correlations between activities (or back-propagated gradients) within a given layer.\nOllivier (2013) proposed a neural network optimization method which uses a block-diagonal approximation of the Fisher, with the blocks corresponding to the incoming weights (and bias) of each unit. This method is similar to TONGA, except that it approximates the Fisher instead of the empirical Fisher (see Martens (2014) for a discussion of the difference between these). Because computing blocks of the Fisher is expensive (it requires k backpropagations, where k is the number of output units), this method uses a biased deterministic approximation which can be computed more efficiently, and is similar in spirit to the deterministic approximation used by LeCun et al. (1998). Note that while such an approximation could hypothetically be used within K-FAC to compute the Gi,j’s, we have found that our basic unbiased stochastic approximation works nearly\nas well as the exact values in practice.\nThe work most closely related to ours is that of Heskes (2000), who proposed an approximation of the Fisher of feed-forward neural networks similar to our Kronecker-factored blockdiagonal approximation F̆ from Section 4.2, and used it to derive an efficient approximate naturalgradient based optimization method by exploiting the identity (A ⊗ B)−1 = A−1 ⊗ B−1. K-FAC differs from Heskes’ method in several important ways which turn out to be crucial to it working well in practice.\nIn Heskes’ method, update damping is accomplished using a basic factored Tikhonov technique where γI is added to each Gi,i and Āi,i for a fixed parameter γ > 0 which is set by hand. By contrast, K-FAC uses a factored Tikhonov technique where γ = √ η + λ with λ adapted dynamically as described in Section 6.3, combined with a re-scaling technique based on a local quadratic model computed using the exact Fisher (see Section 6.2). Note that the adaptation of γ (via the adaptation of λ) is important since what constitutes a good or even merely acceptable value of γ will change significantly over the course of optimization. And the use of our rescaling technique, or something similar to it, is also crucial as we have observed empirically that basic Tikhonov damping is incapable of producing high quality updates by itself, even when γ is chosen optimally at each iteration.\nAlso, while Heskes’ method computes the Gi,i’s exactly, K-FAC uses a stochastic approximation which scales efficiently to neural networks with much higher-dimensional outputs (see Section 5).\nOther advances we have introduced include the more accurate block-tridiagonal approximation to the inverse Fisher, a parameter-free type of momentum (see Section 7), online estimation of the Gi,i and Āi,i matrices, and various improvements in computational efficiency (see Section 8). We have found that each of these additional elements is important in order for K-FAC to work as well as it does in various settings.\nHeskes discussed an alternative interpretation of the block-diagonal approximation which yields some useful insight to complement our own theoretical analysis. In particular, he observed that the block-diagonal Fisher approximation F̆ is the curvature matrix corresponding to the following quadratic function which measures the difference between the new parameter value θ′ and the current value θ:\nD(θ′, θ) = 1\n2 ∑̀ i=1 E [ (si − s′i)>Gi,i(si − s′i) ] Here, s′i = W ′ i āi−1, and the si’s and āi’s are determined by θ and are independent of θ\n′ (which determines the W ′i ’s).\nD(θ′, θ) can be interpreted as a reweighted sum of squared changes of each of the si’s. The reweighing matrix Gi,i is given by\nGi,i = E [ gig > i ] = E[F\nP (i) y|si\n]\nwhere P (i)y|si is the network’s predictive distribution as parameterized by si, and FP (i)y|si is its Fisher information matrix, and where the expectation is taken w.r.t. the distribution on si (as induced by the distribution on the network’s input x). Thus, the effect of reweighing by the Gi,i’s is to (approximately) translate changes in si into changes in the predictive distribution over y, although using the expected/average Fisher Gi,i = E[FP (i)\ny|si ] instead of the more specific Fisher F P (i) y|si .\nInterestingly, if one used F P\n(i) y|si\ninstead of Gi,i in the expression for D(θ′, θ), then D(θ′, θ)\nwould correspond to a basic layer-wise block-diagonal approximation of F where the blocks are computed exactly (i.e. without the Kronecker-factorizing approximation introduced in Section 3). Such an approximate Fisher would have the interpretation of being the Hessian w.r.t. θ′ of either of the measures ∑̀\ni=1\nE [ KL ( P\n(i) y|si ‖ P (i) y|s′i\n)] or ∑̀ i=1 E [ KL ( P (i) y|s′i ‖ P (i)y|si )] Note that each term in either of these sums is a function measuring an intrinsic quantity (i.e. changes in the output distribution), and so overall these are intrinsic measures except insofar as they assume that θ is divided into ` independent groups that each parameterize one of the ` different predictive distributions (which are each conditioned on their respective ai−1’s).\nIt is not clear whether F̆ , with its Kronecker-factorizing structure can similarly be interpreted as the Hessian of such a self-evidently intrinsic measure. If it could be, then this would considerably simplify the proof of our Theorem 1 (e.g. using the techniques of Arnold et al. (2011)). Note that D(θ′, θ) itself doesn’t work, as it isn’t obviously intrinsic. Despite this, as shown in Section 9, both F̆ and our more advanced approximation F̂ produce updates which have strong invariance properties."
    }, {
      "heading" : "11 Experiments",
      "text" : "To investigate the practical performance of K-FAC we applied it to the 3 deep-autoencoder optimization problems from Hinton and Salakhutdinov (2006), which use the “MNIST”, “CURVES”, and “FACES” datasets respectively (see Hinton and Salakhutdinov (2006) for a complete description of the network architectures and datasets). Due to their high difficulty, performance on these problems has become a standard benchmark for neural network optimization methods (e.g. Martens, 2010; Vinyals and Povey, 2012; Sutskever et al., 2013).\nAs a baseline we used the version of SGD with momentum described in Sutskever et al. (2013), which was calibrated to work well on these particular deep autoencoder problems. For each problem we followed the prescription given by Sutskever et al. (2013) for determining the learning rate, and the schedule for the decay constant µ.\nOur implementation of K-FAC used most of the efficiency improvements described in Section 8, except that all “tasks” were computed serially (and thus with better engineering and more hard-\nware, a faster and more parallel implementation could likely be obtained). Because the mini-batch sizem tended to be comparable to or larger than the typical/average layer size d, we did not use the technique described at the end of Section 8 for accelerating the computation of the approximate inverse, as this only improves efficiency in the case where m < d, and will otherwise decrease efficiency.\nBoth K-FAC and the baseline were implemented using vectorized MATLAB code accelerated with the GPU package Jacket. All tests were performed on a single computer with a fast 6 core Intel CPU and an NVidia GTX 580 GPU with 3GB of memory.\nEach method used the same initial parameter setting, which was generated using the “sparse initialization” technique from Martens (2010) (which was also used by Sutskever et al. (2013)). We report the error on the training set as we are chiefly interested in optimization speed.\nTo help mitigate the detrimental effect that the noise in the stochastic gradient has on the convergence of both the baseline and K-FAC we used a exponentially decayed iterate averaging approach based loosely on Polyak averaging (e.g Swersky et al., 2010). In particular, at each iteration we took the “averaged” parameter estimate to be the previous such estimate, multiplied by ξ, plus the new iterate produced by the optimizer, multiplied by 1 − ξ, for ξ = 0.99. Since the training error associated with the optimizer’s current iterate may sometimes be lower than the training error associated with the averaged estimate (which will often be the case when the minibatch size m is very large), we report minimum of these two quantities.\nIn our first experiment we examined the relationship between between the mini-batch size m and the per-iteration rate of progress made by K-FAC and the baseline on the MNIST problem. The results from this experiment are plotted in Figure 6. They strongly suggest that the per-iteration rate of progress of K-FAC tends to a super-linear function of m (which can be most clearly seen by examining the plots of training error vs training cases processed), which is to be contrasted with the baseline, where increasing m has a much smaller effect on the per-iteration progress. It thus appears that the main limiting factor in K-FAC is the noise in the gradient, at least in later stages of optimization, and that this is not true of the baseline to nearly the same extent.\nThe fact that the per-iteration rate of progress tends to a super-linear function of m, while the per-iteration computational cost of K-FAC is a linear or slightly sub-linear function of m, suggests that in order to obtain the best per-second rate of progress with K-FAC, we should use a rapidly increasing schedule for m. To this end we designed an exponentially increasing schedule for m, given bymi = min(m1 exp((i−1)/b), |S|), where i is the current iteration,m1 = 1000, and where b is chosen so that m500 = |S|. Note that for other neural net optimization problems, such as ones involving much larger training datasets than these autoencoder problems, a more slowly increasing schedule, or one that stops increasing before m reaches |S|, may be more appropriate.\nIn our second experiment we evaluated the performance of K-FAC versus the baseline on all 3 deep autoencoder problems, where we used the above described exponentially increasing schedule for m within K-FAC, and a fixed setting of m within the baseline (which was chosen from a small range of candidates to give the best overall per-second rate of progress). Note that in order to process very large mini-batches without overwhelming the memory of the GPU, we partitioned the mini-batches into smaller “chunks” and performed all computation involving the mini-batches, or subsets thereof, one chunk at a time.\nThe results from this second experiment are plotted in Figures 7 and 8. For each problem K-FAC had a per-iteration rate of progress which was orders of magnitude higher than that of the baseline’s (Figure 8), which translated into an overall much higher per-second rate of progress (Figure 7), despite the higher cost of K-FAC’s iterations (due mostly to the much larger mini-batch sizes used).\nAlso apparent from these results is that the block-tridiagonal version of K-FAC has a periteration rate of progress which is typically 25% to 40% larger than the simpler block-diagonal version. This observation provides empirical support for the idea that the block-tridiagonal approximate inverse Fisher F̂−1 is a more accurate approximation of F−1 than the block-diagonal approximation F̆−1. However, due to the higher cost of the iterations in the block-tridiagonal version, its overall per-second rate of progress seems to be only slightly higher than the block-diagonal version’s.\nWhile matrix-matrix multiplication, matrix inverse, and SVD computation all have the same computational complexity, in practice their costs differ significantly (in increasing order as listed). Computation of the approximate Fisher inverse, which is performed in our experiments once every 20 iterations (and for the first 10 iterations), requires matrix inverses for the block-diagonal version, and SVDs for the block-tridiagonal version. For the FACES problem, where the layers can have as many as 2000 units, this accounts for a significant portion of the difference in their average per-iteration computational cost (as these operations must be performed on 2000 × 2000 sized matrices).\nWhile our results suggest that the block-diagonal version is probably the better option overall due to its greater simplicity, the situation may be different given a more efficient implementation of K-FAC where the inverses or SVDs are computed approximately and/or in parallel with the other tasks, or perhaps even while the network is being optimized."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We gratefully acknowledge support from Google and NSERC."
    }, {
      "heading" : "A Derivation of the expression for the approximation from Sec-",
      "text" : "tion 3.1\nIn this section we will show that E [ ā(1)ā(2) g(1)g(2) ] −E [ ā(1)ā(2) ] E [ g(1)g(2) ] = κ(ā(1), ā(2), g(1), g(2)) + κ(ā(1))κ(ā(2), g(1), g(2)) + κ(ā(2))κ(ā(1), g(1), g(2))\nThe only specific property of the distribution over ā(1), ā(2), g(1), and g(2) which we will require to do this is captured by the following lemma.\nLemma 4. Suppose u is a scalar variable which is independent of y when conditioned on the network’s output f(x, θ), and v is some intermediate quantity computed during the evaluation of f(x, θ) (such as the activities of the units in some layer). Then we have\nE [uDv] = 0\nOur proof of this lemma (which is at the end of this section) makes use of the fact that the expectations are taken with respect to the network’s predictive distribution Py|x as opposed to the training distribution Q̂y|x.\nIntuitively, this lemma says that the intermediate quantities computed in the forward pass of Algorithm 1 (or various functions of these) are statistically uncorrelated with various derivative quantities computed in the backwards pass, provided that the targets y are sampled according to the network’s predictive distribution Py|x (instead of coming from the training set). Valid choices for u include ā(k), ā(k) − E [ ā(k) ]\nfor k ∈ {1, 2}, and products of these. Examples of invalid choices for u include expressions involving g(k), since these will depend on the derivative of the loss, which is not independent of y given f(x, θ). According to a well-known general formula relating moments to cumulants we may write E [ ā(1)ā(2) g(1)g(2) ] as a sum of 15 terms, each of which is a product of various cumulants corresponding to one of the 15 possible ways to partition the elements of {ā(1), ā(2), g(1), g(2)} into nonoverlapping sets. For example, the term corresponding to the partition {{ā(1)}, {ā(2), g(1), g(2)}} is κ(ā(1))κ(ā(2), g(1), g(2)).\nObserving that 1st-order cumulants correspond to means and 2nd-order cumulants correspond to covariances, for k ∈ {1, 2} Lemma 4 gives\nκ(g(k)) = E [ g(k) ] = E [ Dx(k) ] = 0\nwhere x(1) = [xi]k2 , and x (2) = [xj]k4 (so that g (k) = Dx(k)). And similarly for k,m ∈ {1, 2} it gives\nκ(ā(k), g(m)) = E [( ā(m) − E [ ā(m) ]) ( g(k) − E [ g(k) ])] = E [( ā(m) − E [ ā(m) ]) g(k) ] = 0\nUsing these identities we can eliminate 10 of the terms. The remaining expression for E [ ā(1)ā(2) g(1)g(2) ] is thus\nκ(ā(1), ā(2), g(1), g(2)) + κ(ā(1))κ(ā(2), g(1), g(2)) + κ(ā(2))κ(ā(1), g(1), g(2))\n+ κ(ā(1), ā(2))κ(g(1), g(2)) + κ(ā(1))κ(ā(2))κ(g(1), g(2))\nNoting that\nκ(ā(1), ā(2))κ(g(1), g(2)) + κ(ā(1))κ(ā(2))κ(g(1), g(2)) = Cov(ā(1), ā(2)) E [ g(1)g(2) ] + E [ ā(1) ] E [ ā(2) ] E [ g(1)g(2) ] = E [ ā(1)ā(2) ] E [ g(1)g(2) ] it thus follows that\nE [ ā(1)ā(2) g(1)g(2) ] −E [ ā(1)ā(2) ] E [ g(1)g(2) ] = κ(ā(1), ā(2), g(1), g(2)) + κ(ā(1))κ(ā(2), g(1), g(2)) + κ(ā(2))κ(ā(1), g(1), g(2))\nas required.\nIt remains to prove Lemma 4.\nProof of Lemma 4. The chain rule gives\nDv = −d log p(y|x, θ) dv = −d log r(y|z) dz ∣∣∣∣> z=f(x,θ) df(x, θ) dv\nFrom which it follows that E [uDv] = EQ̂x [ EPy|x [uDv] ] = EQ̂x [ ERy|f(x,θ) [uDv] ] = EQ̂x [ ERy|f(x,θ) [ −u d log r(y|z)\ndz\n∣∣∣∣> z=f(x,θ) df(x, θ) dv ]]\n= EQ̂x −uERy|f(x,θ) [ d log r(y|z) dz ∣∣∣∣ z=f(x,θ) ]> df(x, θ) dv  = EQ̂x [−u~0> df(x, θ)dv ] = 0\nThat the inner expectation above is ~0 follows from the fact that the expected score of a distribution, when taken with respect to that distribution, is ~0."
    }, {
      "heading" : "B Efficient techniques for inverting A⊗B ± C ⊗D",
      "text" : "It is well known that (A ⊗ B)−1 = A−1 ⊗ B−1, and that matrix-vector products with this matrix can thus be computed as (A−1 ⊗ B−1)v = vec(B−1V A−>), where V is the matrix representation of v (so that v = vec(V )).\nSomewhat less well known is that there are also formulas for (A⊗B ±C ⊗D)−1 which can be efficiently computed and likewise give rise to efficient methods for computing matrix-vector products.\nFirst, note that (A⊗B ± C ⊗D)−1v = u is equivalent to (A⊗B ± C ⊗D)v = u, which is equivalent to the linear matrix equationBUA>±DUC> = V , where u = vec(U) and v = vec(V ). This is known as a generalized Stein equation, and different examples of it have been studied in the control theory literature, where they have numerous applications. For a recent survey of this topic, see Simoncini (2014).\nOne well-known class of methods called Smith-type iterations (Smith, 1968) involve rewriting this matrix equation as a fixed point iteration and then carrying out this iteration to convergence. Interestingly, through the use of a special squaring trick, one can simulate 2i of these iterations with only O(i) matrix-matrix multiplications.\nAnother class of methods for solving Stein equations involves the use of matrix decompositions (e.g. Chu, 1987; Gardiner et al., 1992). Here we will present such a method particularly well suited for our application, as it produces a formula for (A ⊗ B + C ⊗D)−1v, which after a fixed overhead cost (involving the computation of SVDs and matrix square roots), can be repeatedly evaluated for different choices of v using only a few matrix-matrix multiplications.\nWe will assume that A, B, C, and D are symmetric positive semi-definite, as they always are in our applications. We have\nA⊗B ± C ⊗D = (A1/2 ⊗B1/2)(I ⊗ I ± A−1/2CA−1/2 ⊗B−1/2DB−1/2)(A1/2 ⊗B1/2)\nInverting both sides of the above equation gives\n(A⊗B ± C ⊗D)−1 = (A−1/2 ⊗B−1/2)(I ⊗ I ± A−1/2CA−1/2 ⊗B−1/2DB−1/2)−1(A−1/2 ⊗B−1/2)\nUsing the symmetric eigen/SVD-decomposition, we can write A−1/2CA−1/2 = E1S1E>1 and B−1/2DB−1/2 = E2S2E > 2 , where for i ∈ {1, 2} the Si are diagonal matrices and the Ei are unitary matrices.\nThis gives\nI ⊗ I ± A−1/2CA−1/2 ⊗B−1/2DB−1/2 = I ⊗ I ± E1S1E>1 ⊗ E2S2E>2 = E1E > 1 ⊗ E2E>2 ± E1S1E>1 ⊗ E2S2E>2\n= (E1 ⊗ E2)(I ⊗ I ± S1 ⊗ S2)(E>1 ⊗ E>2 )\nso that\n(I ⊗ I ± A−1/2CA−1/2 ⊗B−1/2DB−1/2)−1 = (E1 ⊗ E2)(I ⊗ I ± S1 ⊗ S2)−1(E>1 ⊗ E>2 )\nNote that both I⊗I and S1⊗S2 are diagonal matrices, and thus the middle matrix (I⊗I±S1⊗S2)−1 is just the inverse of a diagonal matrix, and so can be computed efficiently.\nThus we have\n(A⊗B ± C ⊗D)−1 = (A−1/2 ⊗B−1/2)(E1 ⊗ E2)(I ⊗ I ± S1 ⊗ S2)−1(E>1 ⊗ E>2 )(A−1/2 ⊗B−1/2) = (K1 ⊗K2)(I ⊗ I ± S1 ⊗ S2)−1(K>1 ⊗K>2 )\nwhere K1 = A−1/2E1 and K2 = B−1/2E2.\nAnd so matrix-vector products with (A⊗B ± C ⊗D)−1 can be computed as\n(A⊗B ± C ⊗D)−1v = vec ( K2 [ (K>2 V K1) ( 11> ± s2s>1 )] K>1 )\nwhere E F denotes element-wise division of E by F , si = diag(Si), and 1 is the vector of ones (sized as appropriate).\nNote that in the considerably simpler case where A and B are both scalar multiples of the identity, and ξ is the product of these multiples, we have\n(ξI ⊗ I ± C ⊗D)−1 = (E1 ⊗ E2)(ξI ⊗ I ± S1 ⊗ S2)−1(E>1 ⊗ E>2 )\nwhere E1S1E>1 and E2S2E > 2 are the symmetric eigen/SVD-decompositions of C and D, respectively. And so matrix-vector products with (ξI ⊗ I ± C ⊗D)−1 can be computed as\n(ξI ⊗ I ± C ⊗D)−1v = vec ( E2 [ (E>2 V E1) ( ξ11> ± s2s>1 )] E>1 )\nC Computing v>Fv and u>Fv more efficiently\nNote that the Fisher is given by\nF = EQ̂x [ J>FRJ ] where J is the Jacobian of f(x, θ) and FR is the Fisher information matrix of the network’s predictive distribution Ry|z, evaluated at z = f(x, θ) (where we treat z as the “parameters”).\nTo compute the matrix-vector product Fv as estimated from a mini-batch we simply compute J>FRJv for each x in the mini-batch, and average the results. This latter operation can be computed in 3 stages (Martens, 2014), which correspond to multiplication of the vector v first by J , then by FR, and then by J>.\nMultiplication by J can be performed by a forward pass which is like a linearized version of the standard forward pass of Algorithm 1. As FR is usually diagonal or diagonal plus rank1, matrix-vector multiplications with it are cheap and easy. Finally, multiplication by J> can be performed by a backwards pass which is essentially the same as that of Algorithm 1. See Schraudolph (2002); Martens (2014) for further details.\nThe naive way of computing v>Fv is to compute Fv as above, and then compute the inner product of Fv with v. Additionally computing u>Fv and u>Fu would require another such matrix-vector product Fu.\nHowever, if we instead just compute the matrix-vector products Jv (which requires only half the work of computing Fv), then computing v>Fv as (Jv)>FR(Jv) is essentially free. And with Ju computed, we can similarly obtain u>Fv as (Ju)>FR(Jv) and u>Fu as (Ju)>FR(Ju).\nThis trick thus reduces the computational cost associated with computing these various scalars by roughly half."
    }, {
      "heading" : "D Proofs for Section 9",
      "text" : "Proof of Theorem 1. First we will show that the given network transformation can be viewed as reparameterization of the network according to an invertible linear function ζ .\nDefine θ∗ = (W ∗1 ,W ∗ 2 , . . . ,W ∗ ` ), where W ∗ i = Φ −1 i WiΩ −1 i−1 (so that Wi = ΦiW ∗ i Ωi−1) and let\nζ be the function which maps θ∗ to θ. Clearly ζ is an invertible linear transformation.\nIf the transformed network uses θ∗ in place of θ then we have\nā∗i = Ωiāi and s ∗ i = Φ −1 i si\nwhich we can prove by a simple induction. First note that ā∗0 = Ω0ā0 by definition. Then, assuming by induction that ā∗i−1 = Ωi−1āi−1, we have\ns∗i = W ∗ i ā ∗ i−1 = Φ −1 i WiΩ −1 i−1Ωi−1āi−1 = Φ −1 i Wiāi−1 = Φ −1 i si\nand therefore also\nā∗i = Ωiφ̄i(Φis ∗ i ) = Ωiφ̄i(ΦiΦ −1 i si) = Ωiφ̄i(si) = Ωiāi\nAnd because Ω` = I , we have ā∗` = ā`, or simply that a ∗ ` = a`, and thus both the original\nnetwork and the transformed one have the same output (i.e. f(x, θ) = f ∗(x, θ∗)). From this it follows that f ∗(x, θ∗) = f(x, θ) = f(x, ζ(θ∗)), and thus the transformed network can be viewed as a reparameterization of the original network by θ∗. Similarly we have that h∗(θ∗) = h(θ) = h(ζ(θ∗)).\nThe following lemma is adapted from (Martens, 2014).\nLemma 5. Let ζ be some invertible affine function mapping θ∗ to θ, which reparameterizes the objective h(θ) as h(ζ(θ∗)). Suppose that C and C∗ are invertible matrices satisfying\nJ>ζ CJζ = C ∗\nThen, additively updating θ with−αC−1∇h is equivalent to additively updating θ∗ with−αC∗−1∇θ∗h(ζ(θ∗)).\nBecause h∗(θ∗) = h(θ) = h(ζ(θ∗)) we have that ∇h∗ = ∇θ∗h(ζ(θ∗)). So, by the above lemma, to prove the theorem it suffices to show that J>ζ F̆ Jζ = F̆ ∗ and J>ζ F̃ Jζ = F̃ ∗.\nUsing Wi = ΦiW ∗i Ωi−1 it is straightforward to verify that\nJζ = diag(Ω > 0 ⊗ Φ1,Ω>1 ⊗ Φ2, . . . , Ω>`−1 ⊗ Φ`)\nBecause si = Φis∗i and the fact that the networks compute the same outputs (so the loss derivatives are identical), we have by the chain rule that, g∗i = Ds∗i = Φ>i Dsi = Φ>i gi, and therefore\nG∗i,j = E [ g∗i g ∗> j ] = E [ Φ>i gi(Φ > i gi) >] = Φ>i E [gig>i ]Φj = Φ>i Gi,jΦj Furthermore,\nĀ∗i,j = E [ ā∗i ā ∗> j ] = E [ (Ωiāi)(Ωj āj) >] = Ωi E [āiā>j ]Ω>j = ΩiĀi,jΩ>j Using these results we may express the Kronecker-factored blocks of the approximate Fisher\nF̃ ∗, as computed using the transformed network, as follows:\nF̃ ∗i,j = Ā ∗ i−1,j−1 ⊗G∗i,j = Ωi−1Āi−1,j−1Ω>j−1 ⊗ Φ>i Gi,jΦj = (Ωi−1 ⊗ Φ>i )(Āi−1,j−1 ⊗Gi,j)(Ω>j−1 ⊗ Φj)\n= (Ωi−1 ⊗ Φ>i )F̃i,j(Ω>j−1 ⊗ Φj)\nGiven this identity we thus have F̆ ∗ = diag ( F̃ ∗1,1, F̃ ∗ 2,2, . . . , F̃ ∗ `,` ) = diag ( (Ω0 ⊗ Φ>1 )F̃1,1(Ω>0 ⊗ Φ1), (Ω1 ⊗ Φ>2 )F̃2,2(Ω>1 ⊗ Φ2), . . . , (Ω`−1 ⊗ Φ>` )F̃`,`(Ω>`−1 ⊗ Φ`)\n) = diag(Ω0 ⊗ Φ>1 ,Ω1 ⊗ Φ>2 , . . . , Ω`−1 ⊗ Φ>` ) diag ( F̃1,1, F̃2,2, . . . , , F̃`,`\n) · diag(Ω>0 ⊗ Φ1,Ω>1 ⊗ Φ2, . . . , Ω>`−1 ⊗ Φ`)\n= J>ζ F̆ Jζ\nWe now turn our attention to the F̂ (see Section 4.3 for the relevant notation).\nFirst note that\nΨ∗i,i+1 = F̃ ∗ i,i+1F̃ ∗−1 i+1,i+1 = (Ωi−1 ⊗ Φ>i )F̃i,i+1(Ω>i ⊗ Φi+1) ( (Ωi ⊗ Φ>i+1)F̃i+1,i+1(Ω>i ⊗ Φi+1) )−1 = (Ωi−1 ⊗ Φ>i )F̃i,i+1(Ω>i ⊗ Φi+1)(Ω>i ⊗ Φi+1)−1F̃−1i+1,i+1(Ωi ⊗ Φ>i+1)−1\n= (Ωi−1 ⊗ Φ>i )F̃i,i+1F̃−1i+1,i+1(Ωi ⊗ Φ>i+1)−1 = (Ωi−1 ⊗ Φ>i )Ψi,i+1(Ωi ⊗ Φ>i+1)−1\nand so\nΣ∗i|i+1 = F̃ ∗ i,i −Ψ∗i,i+1F̃ ∗i+1,i+1Ψ∗>i,i+1\n= (Ωi−1 ⊗ Φ>i )F̃i,i(Ω>i−1 ⊗ Φi) − (Ωi−1 ⊗ Φ>i )Ψi,i+1(Ωi ⊗ Φ>i+1)−1(Ωi ⊗ Φ>i+1)F̃i+1,i+1(Ω>i ⊗ Φi+1)(Ωi ⊗ Φ>i+1)−>\n·Ψ>i,i+1(Ωi−1 ⊗ Φ>i )>\n= (Ωi−1 ⊗ Φ>i )(F̃i,i −Ψi,i+1F̃i+1,i+1Ψ>i,i+1)(Ω>i−1 ⊗ Φi) = (Ωi−1 ⊗ Φ>i )Σi|i+1(Ω>i−1 ⊗ Φi)\nAlso, Σ∗` = F̃ ∗ `,` = (Ω`−1 ⊗ Φ>` )F̃`,`(Ω>`−1 ⊗ Φ`) = (Ω`−1 ⊗ Φ>` )Σ`(Ω>`−1 ⊗ Φ`).\nFrom these facts it follows that\nΛ∗−1 = diag ( Σ∗1|2,Σ ∗ 2|3, . . . , Σ ∗ `−1|`,Σ ∗ ` ) = diag ( (Ω0 ⊗ Φ>1 )Σ1|2(Ω0 ⊗ Φ>1 ), (Ω1 ⊗ Φ>2 )Σ2|3(Ω1 ⊗ Φ>2 ), . . . ,\n(Ω`−2 ⊗ Φ>`−1)Σ`−1|`(Ω`−2 ⊗ Φ>`−1), (Ω`−1 ⊗ Φ>` )Σ`(Ω>`−1 ⊗ Φ`) )\n= diag(Ω0 ⊗ Φ>1 ,Ω1 ⊗ Φ>2 , . . . , Ω`−2 ⊗ Φ>`−1,Ω`−1 ⊗ Φ>` ) diag ( Σ1|2,Σ2|3, . . . , Σ`−1|`,Σ` ) diag(Ω>0 ⊗ Φ1,Ω>1 ⊗ Φ2, . . . , Ω>`−2 ⊗ Φ`−1,Ω>`−1 ⊗ Φ`) = J>ζ Λ −1Jζ\nInverting both sides gives Λ∗ = J−1ζ ΛJ −> ζ .\nNext, observe that\nΨ∗>i,i+1(Ω > i−1 ⊗ Φi)−1 = (Ωi ⊗ Φ>i+1)−>Ψ>i,i+1(Ωi−1 ⊗ Φ>i )>(Ω>i−1 ⊗ Φi)−1 = (Ω>i ⊗ Φi+1)−1Ψ>i,i+1\nfrom which it follows that\nΞ∗>J−1ζ =  I −Ψ∗>1,2 I\n−Ψ∗>2,3 I . . . . . . −Ψ∗>`−1,` I\n diag((Ω>0 ⊗ Φ1)−1, (Ω>1 ⊗ Φ2)−1, . . . , (Ω>`−1 ⊗ Φ`)−1)\n=  (Ω>0 ⊗ Φ1)−1 −Ψ∗>1,2(Ω>0 ⊗ Φ1)−1 (Ω>1 ⊗ Φ2)−1 −Ψ∗>2,3(Ω>1 ⊗ Φ2)−1 (Ω>2 ⊗ Φ3)−1\n. . . . . . −Ψ∗>`−1,`(Ω>`−2 ⊗ Φ`−1)−1 (Ω>`−1 ⊗ Φ`)−1\n\n=  (Ω>0 ⊗ Φ1)−1 −(Ω>0 ⊗ Φ1)−1Ψ>1,2 (Ω>1 ⊗ Φ2)−1 −(Ω>1 ⊗ Φ2)−1Ψ>2,3 (Ω>2 ⊗ Φ3)−1\n. . . . . . −(Ω>`−2 ⊗ Φ`−1)−1Ψ>`−1,` (Ω>`−1 ⊗ Φ`)−1\n\n= diag((Ω>0 ⊗ Φ1)−1, (Ω>1 ⊗ Φ2)−1, . . . , (Ω>`−1 ⊗ Φ`)−1)  I −Ψ>1,2 I\n−Ψ>2,3 I . . . . . . −Ψ>`−1,` I  = J−1ζ Ξ >\nCombining Λ∗ = J−1ζ ΛJ −> ζ and Ξ ∗>J−1ζ = J −1 ζ Ξ > we have\nF̂ ∗−1 = Ξ∗>Λ∗Ξ∗ = Ξ∗>J−1ζ ΛJ −> ζ Ξ ∗ = (Ξ∗>J−1ζ )Λ(Ξ ∗>J−1ζ ) > = (J−1ζ Ξ >)Λ(J−1ζ Ξ >)>\n= J−1ζ Ξ >ΛΞJ−>ζ = J−1ζ F̂ −1J−>ζ\nInverting both sides gives F̂ ∗ = J>ζ F̂ Jζ as required.\nProof of Corollary 3. First note that a network which is transformed so that G∗i,i = I and Ā ∗ i,i = I will satisfy the required properties. To see this, note that E[g∗i g ∗> i ] = G ∗ i,i = I means that g ∗ i is whitened with respect to the model’s distribution by definition (since the expectation is taken with respect to the model’s distribution), and furthermore we have that E[g∗i ] = 0 by default (e.g. using Lemma 4), so g∗i is centered. And since E[a ∗ i a ∗> i ] is the square submatrix of Ā ∗ i,i = I which\nleaves out the last row and column, we also have that E[a∗i a ∗> i ] = I and so a ∗ i is whitened. Finally, observe that E[a∗i ] is given by the final column (or row) of Āi,i, excluding the last entry, and is thus equal to 0, and so a∗i is centered.\nNext, we note that if G∗i,i = I and Ā ∗ i,i = I then\nF̆ ∗ = diag ( Ā∗0,0 ⊗G∗1,1, Ā∗1,1 ⊗G∗2,2, . . . , Ā∗`−1,`−1 ⊗G∗`,` ) = diag (I ⊗ I, I ⊗ I, . . . , I ⊗ I) = I\nand so −αF̆−1∇h∗ = −α∇h∗ is indeed a standard gradient descent update.\nFinally, we observe that there are choices of Ωi and Φi which will make the transformed model satisfy G∗i,i = I and Ā ∗ i,i = I . In particular, from the proof of Theorem 1 we have that G∗i,j = Φ > i Gi,jΦj and Ā ∗ i,j = ΩiĀi,jΩ > j , and so taking Φi = G −1/2 i,i and Ωi = Ā −1/2 i,i works.\nThe result now follows from Theorem 1."
    } ],
    "references" : [ {
      "title" : "Methods of Information Geometry, volume 191 of Translations of Mathematical monographs",
      "author" : [ "S. Amari", "H. Nagaoka" ],
      "venue" : null,
      "citeRegEx" : "Amari and Nagaoka.,? \\Q2000\\E",
      "shortCiteRegEx" : "Amari and Nagaoka.",
      "year" : 2000
    }, {
      "title" : "Natural gradient works efficiently in learning",
      "author" : [ "Shun-Ichi Amari" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "Amari.,? \\Q1998\\E",
      "shortCiteRegEx" : "Amari.",
      "year" : 1998
    }, {
      "title" : "Information-geometric optimization algorithms: A unifying picture via invariance principles",
      "author" : [ "Ludovic Arnold", "Anne Auger", "Nikolaus Hansen", "Yann Ollivier" ],
      "venue" : null,
      "citeRegEx" : "Arnold et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Arnold et al\\.",
      "year" : 2011
    }, {
      "title" : "Improving the Convergence of Back-Propagation Learning with Second Order Methods",
      "author" : [ "Sue Becker", "Yann LeCun" ],
      "venue" : "Proceedings of the 1988 Connectionist Models Summer School,",
      "citeRegEx" : "Becker and LeCun.,? \\Q1989\\E",
      "shortCiteRegEx" : "Becker and LeCun.",
      "year" : 1989
    }, {
      "title" : "Pattern Recognition and Machine Learning (Information Science and Statistics)",
      "author" : [ "Christopher M. Bishop" ],
      "venue" : "Linear Algebra and its Applications,",
      "citeRegEx" : "Bishop.,? \\Q2006\\E",
      "shortCiteRegEx" : "Bishop.",
      "year" : 2006
    }, {
      "title" : "Solution of the sylvester matrix equation AXB + CXD = E",
      "author" : [ "Judith D. Gardiner", "Alan J. Laub", "James J. Amato", "Cleve B. Moler" ],
      "venue" : "ACM Trans. Math. Softw.,",
      "citeRegEx" : "Gardiner et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Gardiner et al\\.",
      "year" : 1992
    }, {
      "title" : "Scaling up natural gradient by factorizing fisher information",
      "author" : [ "Roger Grosse", "Ruslan Salakhutdinov" ],
      "venue" : null,
      "citeRegEx" : "Grosse and Salakhutdinov.,? \\Q2014\\E",
      "shortCiteRegEx" : "Grosse and Salakhutdinov.",
      "year" : 2014
    }, {
      "title" : "On “natural” learning and pruning in multilayered perceptrons",
      "author" : [ "Tom Heskes" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "Heskes.,? \\Q2000\\E",
      "shortCiteRegEx" : "Heskes.",
      "year" : 2000
    }, {
      "title" : "Reducing the dimensionality of data with neural networks",
      "author" : [ "G.E. Hinton", "R.R. Salakhutdinov" ],
      "venue" : null,
      "citeRegEx" : "Hinton and Salakhutdinov.,? \\Q2006\\E",
      "shortCiteRegEx" : "Hinton and Salakhutdinov.",
      "year" : 2006
    }, {
      "title" : "Improving neural networks by preventing co-adaptation of feature detectors",
      "author" : [ "Geoffrey E. Hinton", "Nitish Srivastava", "Alex Krizhevsky", "Ilya Sutskever", "Ruslan Salakhutdinov" ],
      "venue" : "CoRR, abs/1207.0580,",
      "citeRegEx" : "Hinton et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hinton et al\\.",
      "year" : 2012
    }, {
      "title" : "Training neural networks with stochastic Hessian-free optimization",
      "author" : [ "Ryan Kiros" ],
      "venue" : "In International Conference on Learning Representations,",
      "citeRegEx" : "Kiros.,? \\Q2013\\E",
      "shortCiteRegEx" : "Kiros.",
      "year" : 2013
    }, {
      "title" : "Topmoumoute online natural gradient algorithm",
      "author" : [ "Nicolas Le Roux", "Pierre-antoine Manzagol", "Yoshua Bengio" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Roux et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Roux et al\\.",
      "year" : 2008
    }, {
      "title" : "Efficient backprop",
      "author" : [ "Y. LeCun", "L. Bottou", "G. Orr", "K. Müller" ],
      "venue" : "Neural networks: Tricks of the trade,",
      "citeRegEx" : "LeCun et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "LeCun et al\\.",
      "year" : 1998
    }, {
      "title" : "Sharpness in rates of convergence for cg and symmetric Lanczos methods",
      "author" : [ "R-C Li" ],
      "venue" : "Technical Report 05-01,",
      "citeRegEx" : "Li.,? \\Q2005\\E",
      "shortCiteRegEx" : "Li.",
      "year" : 2005
    }, {
      "title" : "Deep learning via Hessian-free optimization",
      "author" : [ "J. Martens" ],
      "venue" : "In Proceedings of the 27th International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Martens.,? \\Q2010\\E",
      "shortCiteRegEx" : "Martens.",
      "year" : 2010
    }, {
      "title" : "New perspectives on the natural gradient method, 2014, arXiv:1411.7717",
      "author" : [ "J. Martens" ],
      "venue" : null,
      "citeRegEx" : "Martens.,? \\Q2014\\E",
      "shortCiteRegEx" : "Martens.",
      "year" : 2014
    }, {
      "title" : "Training deep and recurrent networks with Hessian-free optimization",
      "author" : [ "J. Martens", "I. Sutskever" ],
      "venue" : "In Neural Networks: Tricks of the Trade,",
      "citeRegEx" : "Martens and Sutskever.,? \\Q2012\\E",
      "shortCiteRegEx" : "Martens and Sutskever.",
      "year" : 2012
    }, {
      "title" : "Estimating the Hessian by backpropagating curvature",
      "author" : [ "J. Martens", "I. Sutskever", "K. Swersky" ],
      "venue" : "In Proceedings of the 29th International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Martens et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Martens et al\\.",
      "year" : 2012
    }, {
      "title" : "Riemannian metrics for neural networks. 2013, arXiv:1303.0818",
      "author" : [ "Yann Ollivier" ],
      "venue" : null,
      "citeRegEx" : "Ollivier.,? \\Q2013\\E",
      "shortCiteRegEx" : "Ollivier.",
      "year" : 2013
    }, {
      "title" : "An improved newton iteration for the generalized inverse of a matrix, with applications",
      "author" : [ "V. Pan", "R. Schreiber" ],
      "venue" : "SIAM Journal on Scientific and Statistical Computing,",
      "citeRegEx" : "Pan and Schreiber.,? \\Q1991\\E",
      "shortCiteRegEx" : "Pan and Schreiber.",
      "year" : 1991
    }, {
      "title" : "Adaptive natural gradient learning algorithms for various stochastic models",
      "author" : [ "H. Park", "S.-I. Amari", "K. Fukumizu" ],
      "venue" : "Neural Networks,",
      "citeRegEx" : "Park et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Park et al\\.",
      "year" : 2000
    }, {
      "title" : "Revisiting natural gradient for deep networks",
      "author" : [ "Razvan Pascanu", "Yoshua Bengio" ],
      "venue" : "In International Conference on Learning Representations,",
      "citeRegEx" : "Pascanu and Bengio.,? \\Q2014\\E",
      "shortCiteRegEx" : "Pascanu and Bengio.",
      "year" : 2014
    }, {
      "title" : "Experiments on learning by back propagation",
      "author" : [ "D. Plaut", "S. Nowlan", "G.E. Hinton" ],
      "venue" : "Technical Report CMU-CS-86-126,",
      "citeRegEx" : "Plaut et al\\.,? \\Q1986\\E",
      "shortCiteRegEx" : "Plaut et al\\.",
      "year" : 1986
    }, {
      "title" : "Some methods of speeding up the convergence of iteration methods",
      "author" : [ "B.T. Polyak" ],
      "venue" : "USSR Computational Mathematics and Mathematical Physics,",
      "citeRegEx" : "Polyak.,? \\Q1964\\E",
      "shortCiteRegEx" : "Polyak.",
      "year" : 1964
    }, {
      "title" : "Joint mean-covariance models with applications to longitudinal data: unconstrained parameterisation",
      "author" : [ "M. Pourahmadi" ],
      "venue" : null,
      "citeRegEx" : "Pourahmadi.,? \\Q1999\\E",
      "shortCiteRegEx" : "Pourahmadi.",
      "year" : 1999
    }, {
      "title" : "Covariance Estimation: The GLM and Regularization Perspectives",
      "author" : [ "M. Pourahmadi" ],
      "venue" : "Statistical Science,",
      "citeRegEx" : "Pourahmadi.,? \\Q2011\\E",
      "shortCiteRegEx" : "Pourahmadi.",
      "year" : 2011
    }, {
      "title" : "Deep learning made easier by linear transformations in perceptrons",
      "author" : [ "Tapani Raiko", "Harri Valpola", "Yann LeCun" ],
      "venue" : "In AISTATS,",
      "citeRegEx" : "Raiko et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Raiko et al\\.",
      "year" : 2012
    }, {
      "title" : "No More Pesky Learning Rates",
      "author" : [ "Tom Schaul", "Sixin Zhang", "Yann LeCun" ],
      "venue" : "In Proceedings of the 30th International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Schaul et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Schaul et al\\.",
      "year" : 2013
    }, {
      "title" : "Centering neural network gradient factors",
      "author" : [ "Nicol N. Schraudolph" ],
      "venue" : "Neural Networks: Tricks of the Trade,",
      "citeRegEx" : "Schraudolph.,? \\Q1998\\E",
      "shortCiteRegEx" : "Schraudolph.",
      "year" : 1998
    }, {
      "title" : "Fast curvature matrix-vector products for second-order gradient descent",
      "author" : [ "Nicol N. Schraudolph" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "Schraudolph.,? \\Q2002\\E",
      "shortCiteRegEx" : "Schraudolph.",
      "year" : 2002
    }, {
      "title" : "Computational methods for linear matrix equations",
      "author" : [ "V. Simoncini" ],
      "venue" : null,
      "citeRegEx" : "Simoncini.,? \\Q2014\\E",
      "shortCiteRegEx" : "Simoncini.",
      "year" : 2014
    }, {
      "title" : "Matrix equation XA+BX = C",
      "author" : [ "R.A. Smith" ],
      "venue" : "SIAM J. Appl. Math.,",
      "citeRegEx" : "Smith.,? \\Q1968\\E",
      "shortCiteRegEx" : "Smith.",
      "year" : 1968
    }, {
      "title" : "On the importance of initialization and momentum in deep learning",
      "author" : [ "Ilya Sutskever", "James Martens", "George Dahl", "Geoffrey Hinton" ],
      "venue" : "In Proceedings of the 30th International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Sutskever et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Sutskever et al\\.",
      "year" : 2013
    }, {
      "title" : "A tutorial on stochastic approximation algorithms for training restricted boltzmann machines and deep belief nets",
      "author" : [ "K. Swersky", "Bo Chen", "B. Marlin", "N. de Freitas" ],
      "venue" : "In Information Theory and Applications Workshop (ITA),",
      "citeRegEx" : "Swersky et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Swersky et al\\.",
      "year" : 2010
    }, {
      "title" : "Pushing stochastic gradient towards second-order methods – backpropagation learning with transformations in nonlinearities",
      "author" : [ "Tommi Vatanen", "Tapani Raiko", "Harri Valpola", "Yann LeCun" ],
      "venue" : null,
      "citeRegEx" : "Vatanen et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Vatanen et al\\.",
      "year" : 2013
    }, {
      "title" : "Krylov subspace descent for deep learning",
      "author" : [ "O. Vinyals", "D. Povey" ],
      "venue" : "In International Conference on Artificial Intelligence and Statistics (AISTATS),",
      "citeRegEx" : "Vinyals and Povey.,? \\Q2012\\E",
      "shortCiteRegEx" : "Vinyals and Povey.",
      "year" : 2012
    }, {
      "title" : "ADADELTA: An adaptive learning rate method",
      "author" : [ "Matthew D. Zeiler" ],
      "venue" : null,
      "citeRegEx" : "Zeiler.,? \\Q2013\\E",
      "shortCiteRegEx" : "Zeiler.",
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 32,
      "context" : "Despite work on layer-wise pretraining schemes, and various sophisticated optimization methods which try to approximate Newton-Raphson updates or natural gradient updates, stochastic gradient descent (SGD), possibly augmented with momentum, remains the method of choice for large-scale neural network training (Sutskever et al., 2013).",
      "startOffset" : 310,
      "endOffset" : 334
    }, {
      "referenceID" : 14,
      "context" : "From the work on Hessian-free optimization (HF) (Martens, 2010) and related methods (e.",
      "startOffset" : 48,
      "endOffset" : 63
    }, {
      "referenceID" : 32,
      "context" : "The extent to which neural network objective functions give rise to such quadratics is unclear, although (Sutskever et al., 2013) provides some preliminary evidence that they do.",
      "startOffset" : 105,
      "endOffset" : 129
    }, {
      "referenceID" : 27,
      "context" : "One such class of methods which have been widely studied are those which work by directly inverting a diagonal, block-diagonal, or low-rank approximation to the curvature matrix (e.g. Becker and LeCun, 1989; Schaul et al., 2013; Le Roux et al., 2008; Ollivier, 2013).",
      "startOffset" : 178,
      "endOffset" : 266
    }, {
      "referenceID" : 18,
      "context" : "One such class of methods which have been widely studied are those which work by directly inverting a diagonal, block-diagonal, or low-rank approximation to the curvature matrix (e.g. Becker and LeCun, 1989; Schaul et al., 2013; Le Roux et al., 2008; Ollivier, 2013).",
      "startOffset" : 178,
      "endOffset" : 266
    }, {
      "referenceID" : 11,
      "context" : "As discussed in Martens and Sutskever (2012), CG has the potential to be much faster at local optimization than gradient descent, when applied to quadratic objective functions.",
      "startOffset" : 16,
      "endOffset" : 45
    }, {
      "referenceID" : 11,
      "context" : "In the first, the rows and columns of the Fisher are divided into groups, each of which corresponds to all the weights in a given layer, and this gives rise to a block-partitioning of the matrix (where the blocks are much larger than those used by Le Roux et al. (2008) or Ollivier (2013)).",
      "startOffset" : 251,
      "endOffset" : 270
    }, {
      "referenceID" : 11,
      "context" : "In the first, the rows and columns of the Fisher are divided into groups, each of which corresponds to all the weights in a given layer, and this gives rise to a block-partitioning of the matrix (where the blocks are much larger than those used by Le Roux et al. (2008) or Ollivier (2013)).",
      "startOffset" : 251,
      "endOffset" : 289
    }, {
      "referenceID" : 14,
      "context" : "Note that this presentation closely follows the one from Martens (2014).",
      "startOffset" : 57,
      "endOffset" : 72
    }, {
      "referenceID" : 1,
      "context" : "The well-known natural gradient (Amari, 1998) is defined as F−1∇h(θ).",
      "startOffset" : 32,
      "endOffset" : 45
    }, {
      "referenceID" : 0,
      "context" : "Motivated from the perspective of information geometry (Amari and Nagaoka, 2000), the natural gradient defines the direction in parameter space which gives the largest change in the objective per unit of change in the model, as measured by the KL-divergence.",
      "startOffset" : 55,
      "endOffset" : 80
    }, {
      "referenceID" : 15,
      "context" : "It can be shown (Martens, 2014; Pascanu and Bengio, 2014) that the Fisher is equivalent to the Generalized Gauss-Newton matrix (GGN) (Schraudolph, 2002; Martens and Sutskever, 2012) in certain important cases, which is a well-known PSD approximation to the Hessian of the objective function.",
      "startOffset" : 16,
      "endOffset" : 57
    }, {
      "referenceID" : 21,
      "context" : "It can be shown (Martens, 2014; Pascanu and Bengio, 2014) that the Fisher is equivalent to the Generalized Gauss-Newton matrix (GGN) (Schraudolph, 2002; Martens and Sutskever, 2012) in certain important cases, which is a well-known PSD approximation to the Hessian of the objective function.",
      "startOffset" : 16,
      "endOffset" : 57
    }, {
      "referenceID" : 29,
      "context" : "It can be shown (Martens, 2014; Pascanu and Bengio, 2014) that the Fisher is equivalent to the Generalized Gauss-Newton matrix (GGN) (Schraudolph, 2002; Martens and Sutskever, 2012) in certain important cases, which is a well-known PSD approximation to the Hessian of the objective function.",
      "startOffset" : 133,
      "endOffset" : 181
    }, {
      "referenceID" : 16,
      "context" : "It can be shown (Martens, 2014; Pascanu and Bengio, 2014) that the Fisher is equivalent to the Generalized Gauss-Newton matrix (GGN) (Schraudolph, 2002; Martens and Sutskever, 2012) in certain important cases, which is a well-known PSD approximation to the Hessian of the objective function.",
      "startOffset" : 133,
      "endOffset" : 181
    }, {
      "referenceID" : 15,
      "context" : "In particular, (Martens, 2014) showed that when the GGN is defined so that the network is linearized up to the loss function, and the loss function corresponds to the negative log probability of observations under an exponential family model Ry|z with natural parameters z, then the Fisher corresponds exactly to the GGN.",
      "startOffset" : 15,
      "endOffset" : 30
    }, {
      "referenceID" : 0,
      "context" : "Motivated from the perspective of information geometry (Amari and Nagaoka, 2000), the natural gradient defines the direction in parameter space which gives the largest change in the objective per unit of change in the model, as measured by the KL-divergence. This is to be contrasted with the standard gradient, which can be defined as the direction in parameter space which gives the largest change in the objective per unit of change in the parameters, as measured by the standard Euclidean metric. The natural gradient also has links to several classical ideas from optimization. It can be shown (Martens, 2014; Pascanu and Bengio, 2014) that the Fisher is equivalent to the Generalized Gauss-Newton matrix (GGN) (Schraudolph, 2002; Martens and Sutskever, 2012) in certain important cases, which is a well-known PSD approximation to the Hessian of the objective function. Indeed, the GGN has served as the curvature matrix of choice in HF and related methods, and so in light of its equivalence to the Fisher, these methods can all be seen as approximate natural gradient methods. In particular, (Martens, 2014) showed that when the GGN is defined so that the network is linearized up to the loss function, and the loss function corresponds to the negative log probability of observations under an exponential family model Ry|z with natural parameters z, then the Fisher corresponds exactly to the GGN.1 For some good recent discussion and analysis of the natural gradient, see Arnold et al. (2011); Martens (2014); Pascanu and Bengio (2014).",
      "startOffset" : 56,
      "endOffset" : 1502
    }, {
      "referenceID" : 0,
      "context" : "Motivated from the perspective of information geometry (Amari and Nagaoka, 2000), the natural gradient defines the direction in parameter space which gives the largest change in the objective per unit of change in the model, as measured by the KL-divergence. This is to be contrasted with the standard gradient, which can be defined as the direction in parameter space which gives the largest change in the objective per unit of change in the parameters, as measured by the standard Euclidean metric. The natural gradient also has links to several classical ideas from optimization. It can be shown (Martens, 2014; Pascanu and Bengio, 2014) that the Fisher is equivalent to the Generalized Gauss-Newton matrix (GGN) (Schraudolph, 2002; Martens and Sutskever, 2012) in certain important cases, which is a well-known PSD approximation to the Hessian of the objective function. Indeed, the GGN has served as the curvature matrix of choice in HF and related methods, and so in light of its equivalence to the Fisher, these methods can all be seen as approximate natural gradient methods. In particular, (Martens, 2014) showed that when the GGN is defined so that the network is linearized up to the loss function, and the loss function corresponds to the negative log probability of observations under an exponential family model Ry|z with natural parameters z, then the Fisher corresponds exactly to the GGN.1 For some good recent discussion and analysis of the natural gradient, see Arnold et al. (2011); Martens (2014); Pascanu and Bengio (2014).",
      "startOffset" : 56,
      "endOffset" : 1518
    }, {
      "referenceID" : 0,
      "context" : "Motivated from the perspective of information geometry (Amari and Nagaoka, 2000), the natural gradient defines the direction in parameter space which gives the largest change in the objective per unit of change in the model, as measured by the KL-divergence. This is to be contrasted with the standard gradient, which can be defined as the direction in parameter space which gives the largest change in the objective per unit of change in the parameters, as measured by the standard Euclidean metric. The natural gradient also has links to several classical ideas from optimization. It can be shown (Martens, 2014; Pascanu and Bengio, 2014) that the Fisher is equivalent to the Generalized Gauss-Newton matrix (GGN) (Schraudolph, 2002; Martens and Sutskever, 2012) in certain important cases, which is a well-known PSD approximation to the Hessian of the objective function. Indeed, the GGN has served as the curvature matrix of choice in HF and related methods, and so in light of its equivalence to the Fisher, these methods can all be seen as approximate natural gradient methods. In particular, (Martens, 2014) showed that when the GGN is defined so that the network is linearized up to the loss function, and the loss function corresponds to the negative log probability of observations under an exponential family model Ry|z with natural parameters z, then the Fisher corresponds exactly to the GGN.1 For some good recent discussion and analysis of the natural gradient, see Arnold et al. (2011); Martens (2014); Pascanu and Bengio (2014).",
      "startOffset" : 56,
      "endOffset" : 1545
    }, {
      "referenceID" : 14,
      "context" : "Equivalently, one could linearize the network only up to the input s` to φ` when computing the GGN (see Martens and Sutskever (2012)).",
      "startOffset" : 104,
      "endOffset" : 133
    }, {
      "referenceID" : 6,
      "context" : "In fact, the idea of approximating the distribution over loss gradients with a directed graphical model forms the basis of the recent FANG method (Grosse and Salakhutdinov, 2014).",
      "startOffset" : 146,
      "endOffset" : 178
    }, {
      "referenceID" : 24,
      "context" : "Following the work of Grosse and Salakhutdinov (2014), we use the block generalization of well-known “Cholesky” decomposition of the precision matrix of DGGMs (Pourahmadi, 1999),",
      "startOffset" : 159,
      "endOffset" : 177
    }, {
      "referenceID" : 6,
      "context" : "Following the work of Grosse and Salakhutdinov (2014), we use the block generalization of well-known “Cholesky” decomposition of the precision matrix of DGGMs (Pourahmadi, 1999),",
      "startOffset" : 22,
      "endOffset" : 54
    }, {
      "referenceID" : 27,
      "context" : "This kind of exponentially decaying averaging scheme is commonly used in methods involving diagonal or block-diagonal approximations (with much smaller blocks than ours) to the curvature matrix (e.g. Park et al., 2000; Schaul et al., 2013).",
      "startOffset" : 194,
      "endOffset" : 239
    }, {
      "referenceID" : 23,
      "context" : "While computing matrix-vector products with the Gi,j could be done exactly and efficiently for a given input x (or small mini-batch of x’s) by adapting the methods of Schraudolph (2002), there doesn’t seem to be a sufficiently efficient method for computing the entire matrix itself.",
      "startOffset" : 167,
      "endOffset" : 186
    }, {
      "referenceID" : 14,
      "context" : "Indeed, the hardness results of Martens et al. (2012) suggest that this would require, for each example x in the mini-batch, work that is asymptotically equivalent to matrix-matrix multiplication involving matrices the same size as Gi,j .",
      "startOffset" : 32,
      "endOffset" : 54
    }, {
      "referenceID" : 14,
      "context" : "Moreover, such a choice would not give rise to what is usually thought of as the natural gradient, and based on the findings of Martens (2010), would likely perform worse in practice as part of an optimization algorithm.",
      "startOffset" : 128,
      "endOffset" : 143
    }, {
      "referenceID" : 14,
      "context" : "Moreover, such a choice would not give rise to what is usually thought of as the natural gradient, and based on the findings of Martens (2010), would likely perform worse in practice as part of an optimization algorithm. See Martens (2014) for a more detailed discussion of the empirical Fisher.",
      "startOffset" : 128,
      "endOffset" : 240
    }, {
      "referenceID" : 14,
      "context" : "Fortunately, as observed by Martens (2014), the natural gradient can be understood using a more traditional optimizationtheoretic perspective which implies how it can be used to generate updates that will be useful over larger distances.",
      "startOffset" : 28,
      "endOffset" : 43
    }, {
      "referenceID" : 14,
      "context" : "Fortunately, as observed by Martens (2014), the natural gradient can be understood using a more traditional optimizationtheoretic perspective which implies how it can be used to generate updates that will be useful over larger distances. In particular, when Ry|z is an exponential family model with z as its natural parameters (as it will be in our experiments), Martens (2014) showed that the Fisher becomes equivalent to the Generalized Gauss-Newton matrix (GGN), which is a positive semi-definite approximation of the Hessian of h.",
      "startOffset" : 28,
      "endOffset" : 378
    }, {
      "referenceID" : 14,
      "context" : "3Which has the interpretation of being a geodesic in the Riemannian manifold from the current predictive distribution towards the training distribution when using a likelihood or KL-divergence based objective function (see Martens (2014)).",
      "startOffset" : 223,
      "endOffset" : 238
    }, {
      "referenceID" : 13,
      "context" : "And so as argued by Martens (2014), it is natural to make use of the various sophisticated “damping” techniques that have been developed in the optimization literature for dealing with the breakdowns in local quadratic approximations.",
      "startOffset" : 20,
      "endOffset" : 35
    }, {
      "referenceID" : 13,
      "context" : "And so as argued by Martens (2014), it is natural to make use of the various sophisticated “damping” techniques that have been developed in the optimization literature for dealing with the breakdowns in local quadratic approximations. These include techniques such as Tikhonov damping/regularization, line-searches, and trust regions, etc., all of which tend to be much more effective in practice than merely re-scaling the update. Indeed, a subset of these techniques were exploited in the work of Martens (2010), and have appeared implicitly in older works such as Becker and LeCun (1989).",
      "startOffset" : 20,
      "endOffset" : 514
    }, {
      "referenceID" : 3,
      "context" : "Indeed, a subset of these techniques were exploited in the work of Martens (2010), and have appeared implicitly in older works such as Becker and LeCun (1989). For detailed discussion of these and other damping techniques, we refer the reader to Martens and Sutskever (2012).",
      "startOffset" : 135,
      "endOffset" : 159
    }, {
      "referenceID" : 3,
      "context" : "Indeed, a subset of these techniques were exploited in the work of Martens (2010), and have appeared implicitly in older works such as Becker and LeCun (1989). For detailed discussion of these and other damping techniques, we refer the reader to Martens and Sutskever (2012). Methods like HF which use the exact Fisher seem to work reasonably well with an adaptive Tikhonov regularization technique where λI is added to F + ηI , and where λ is adapted according to Levenberg-Marquardt style adjustment rule.",
      "startOffset" : 135,
      "endOffset" : 275
    }, {
      "referenceID" : 23,
      "context" : "(2013) found that momentum (Polyak, 1964; Plaut et al., 1986) was very helpful in the context of stochastic gradient descent optimization of deep neural networks.",
      "startOffset" : 27,
      "endOffset" : 61
    }, {
      "referenceID" : 22,
      "context" : "(2013) found that momentum (Polyak, 1964; Plaut et al., 1986) was very helpful in the context of stochastic gradient descent optimization of deep neural networks.",
      "startOffset" : 27,
      "endOffset" : 61
    }, {
      "referenceID" : 16,
      "context" : "A version of momentum is also present in the original HF method, and it plays an arguably even more important role in more “stochastic” versions of HF (Martens and Sutskever, 2012; Kiros, 2013).",
      "startOffset" : 151,
      "endOffset" : 193
    }, {
      "referenceID" : 10,
      "context" : "A version of momentum is also present in the original HF method, and it plays an arguably even more important role in more “stochastic” versions of HF (Martens and Sutskever, 2012; Kiros, 2013).",
      "startOffset" : 151,
      "endOffset" : 193
    }, {
      "referenceID" : 12,
      "context" : "convex optimization theory, and with older empirical work done on neural network optimization (LeCun et al., 1998).",
      "startOffset" : 94,
      "endOffset" : 114
    }, {
      "referenceID" : 19,
      "context" : "And there are also ways of reducing matrix-inversion (and even matrix square-root) to a short sequence of matrix-matrix multiplications using iterative methods (Pan and Schreiber, 1991).",
      "startOffset" : 160,
      "endOffset" : 185
    }, {
      "referenceID" : 14,
      "context" : "One can similarly reduce the cost of task 7 by computing the (factored) matrix-vector product with F using such a subset, although we recommend caution when doing this, as using inconsistent sets of data for the quadratic and linear terms in M(δ) can hypothetically cause instability problems which are avoided by using consistent data (see Martens and Sutskever (2012), Section 13.",
      "startOffset" : 341,
      "endOffset" : 370
    }, {
      "referenceID" : 9,
      "context" : "Some possible ways around this issue include computing the weight-decay contribution νF̆−1θ separately and refreshing it only occasionally, or using a different regularization method, such as drop-out (Hinton et al., 2012) or weight-magnitude constraints.",
      "startOffset" : 201,
      "endOffset" : 222
    }, {
      "referenceID" : 14,
      "context" : "As shown by Martens (2014), the approximation error will go to zero as the effects of damping diminish and the reparameterizing function ζ tends to a locally linear function.",
      "startOffset" : 12,
      "endOffset" : 27
    }, {
      "referenceID" : 14,
      "context" : "Fortunately, as was shown by Martens (2014), one can establish invariance of an update direction with respect to a given reparameterization of the model by verifying certain simple properties of the curvature matrix C used to compute the update.",
      "startOffset" : 29,
      "endOffset" : 44
    }, {
      "referenceID" : 14,
      "context" : "While this corollary assumes that the Ωi’s and Φi’s are fixed, if we relax this assumption so that they are allowed to vary smoothly with θ, then ζ will be a smooth function of θ, and so as discussed in Martens (2014), invariance of the optimization path will hold approximately in a way that depends on the smoothness of ζ (which measures how quickly the Ωi’s and Φi’s change) and",
      "startOffset" : 203,
      "endOffset" : 218
    }, {
      "referenceID" : 14,
      "context" : "The Hessian-free optimization method of Martens (2010) uses linear conjugate gradient (CG) to optimize local quadratic models of the form of eqn.",
      "startOffset" : 40,
      "endOffset" : 55
    }, {
      "referenceID" : 28,
      "context" : "Centering methods work by either modifying the gradient (Schraudolph, 1998) or dynamically reparameterizing the network itself (Raiko et al.",
      "startOffset" : 56,
      "endOffset" : 75
    }, {
      "referenceID" : 26,
      "context" : "Centering methods work by either modifying the gradient (Schraudolph, 1998) or dynamically reparameterizing the network itself (Raiko et al., 2012; Vatanen et al., 2013), so that various unit-wise scalar quantities like the activities (the ai’s) and local derivatives (the φi(si)’s) are 0 on average (i.",
      "startOffset" : 127,
      "endOffset" : 169
    }, {
      "referenceID" : 34,
      "context" : "Centering methods work by either modifying the gradient (Schraudolph, 1998) or dynamically reparameterizing the network itself (Raiko et al., 2012; Vatanen et al., 2013), so that various unit-wise scalar quantities like the activities (the ai’s) and local derivatives (the φi(si)’s) are 0 on average (i.",
      "startOffset" : 127,
      "endOffset" : 169
    }, {
      "referenceID" : 11,
      "context" : "Le Roux et al. (2008) proposed a neural network optimization method known as TONGA based on a block-diagonal approximation of the empirical Fisher where each block corresponds to the weights associated with a particular unit.",
      "startOffset" : 3,
      "endOffset" : 22
    }, {
      "referenceID" : 11,
      "context" : "Le Roux et al. (2008) proposed a neural network optimization method known as TONGA based on a block-diagonal approximation of the empirical Fisher where each block corresponds to the weights associated with a particular unit. By contrast, K-FAC uses much larger blocks, each of which corresponds to all the weights within a particular layer. The matrices which are inverted in K-FAC are roughly the same size as those which are inverted in TONGA, but rather than there being one per unit as in TONGA, there are only two per layer. Therefore, K-FAC is significantly less computationally intensive than TONGA, despite using what is arguably a much more accurate approximation to the Fisher. Note that to help mitigate the cost of the many matrix inversions it requires, TONGA approximates the blocks as being low-rank + a diagonal term, although this introduces further approximation error. Centering methods work by either modifying the gradient (Schraudolph, 1998) or dynamically reparameterizing the network itself (Raiko et al., 2012; Vatanen et al., 2013), so that various unit-wise scalar quantities like the activities (the ai’s) and local derivatives (the φi(si)’s) are 0 on average (i.e. “centered”), as they appear in the formula for the gradient. Typically, these methods require the introduction of additional “skip” connections (which bypass the nonlinearities of a given layer) in order to preserve the expressive power/efficiency of the network after these transformations are applied. It is argued by Raiko et al. (2012) that the application of centering methods moves the Fisher closer to a diagonal matrix, and thus makes the gradient a reasonable approximation to the natural gradient.",
      "startOffset" : 3,
      "endOffset" : 1535
    }, {
      "referenceID" : 11,
      "context" : "Le Roux et al. (2008) proposed a neural network optimization method known as TONGA based on a block-diagonal approximation of the empirical Fisher where each block corresponds to the weights associated with a particular unit. By contrast, K-FAC uses much larger blocks, each of which corresponds to all the weights within a particular layer. The matrices which are inverted in K-FAC are roughly the same size as those which are inverted in TONGA, but rather than there being one per unit as in TONGA, there are only two per layer. Therefore, K-FAC is significantly less computationally intensive than TONGA, despite using what is arguably a much more accurate approximation to the Fisher. Note that to help mitigate the cost of the many matrix inversions it requires, TONGA approximates the blocks as being low-rank + a diagonal term, although this introduces further approximation error. Centering methods work by either modifying the gradient (Schraudolph, 1998) or dynamically reparameterizing the network itself (Raiko et al., 2012; Vatanen et al., 2013), so that various unit-wise scalar quantities like the activities (the ai’s) and local derivatives (the φi(si)’s) are 0 on average (i.e. “centered”), as they appear in the formula for the gradient. Typically, these methods require the introduction of additional “skip” connections (which bypass the nonlinearities of a given layer) in order to preserve the expressive power/efficiency of the network after these transformations are applied. It is argued by Raiko et al. (2012) that the application of centering methods moves the Fisher closer to a diagonal matrix, and thus makes the gradient a reasonable approximation to the natural gradient. However, this argument uses the strong approximating assumption that the correlations between various network-dependent quantities, such as the activities of different units within a given layer, are zero. In our notation, this would be like assuming that the Gi,i’s are diagonal, and that the Āi,i’s are rank-1 plus a diagonal term. Indeed, using such an approximation within the block-diagonal version of K-FAC would yield an algorithm similar to standard centering, although without the need for skip connections. As shown in Corollary 3, K-FAC can be interpreted as automatically performing centering, along with the much stronger operation of whitening, of the unit activities and various other quantities which appear in the formula for the gradient. Intuitively, it is this whitening which accounts for the correlations between activities (or back-propagated gradients) within a given layer. Ollivier (2013) proposed a neural network optimization method which uses a block-diagonal approximation of the Fisher, with the blocks corresponding to the incoming weights (and bias) of each unit.",
      "startOffset" : 3,
      "endOffset" : 2618
    }, {
      "referenceID" : 11,
      "context" : "Le Roux et al. (2008) proposed a neural network optimization method known as TONGA based on a block-diagonal approximation of the empirical Fisher where each block corresponds to the weights associated with a particular unit. By contrast, K-FAC uses much larger blocks, each of which corresponds to all the weights within a particular layer. The matrices which are inverted in K-FAC are roughly the same size as those which are inverted in TONGA, but rather than there being one per unit as in TONGA, there are only two per layer. Therefore, K-FAC is significantly less computationally intensive than TONGA, despite using what is arguably a much more accurate approximation to the Fisher. Note that to help mitigate the cost of the many matrix inversions it requires, TONGA approximates the blocks as being low-rank + a diagonal term, although this introduces further approximation error. Centering methods work by either modifying the gradient (Schraudolph, 1998) or dynamically reparameterizing the network itself (Raiko et al., 2012; Vatanen et al., 2013), so that various unit-wise scalar quantities like the activities (the ai’s) and local derivatives (the φi(si)’s) are 0 on average (i.e. “centered”), as they appear in the formula for the gradient. Typically, these methods require the introduction of additional “skip” connections (which bypass the nonlinearities of a given layer) in order to preserve the expressive power/efficiency of the network after these transformations are applied. It is argued by Raiko et al. (2012) that the application of centering methods moves the Fisher closer to a diagonal matrix, and thus makes the gradient a reasonable approximation to the natural gradient. However, this argument uses the strong approximating assumption that the correlations between various network-dependent quantities, such as the activities of different units within a given layer, are zero. In our notation, this would be like assuming that the Gi,i’s are diagonal, and that the Āi,i’s are rank-1 plus a diagonal term. Indeed, using such an approximation within the block-diagonal version of K-FAC would yield an algorithm similar to standard centering, although without the need for skip connections. As shown in Corollary 3, K-FAC can be interpreted as automatically performing centering, along with the much stronger operation of whitening, of the unit activities and various other quantities which appear in the formula for the gradient. Intuitively, it is this whitening which accounts for the correlations between activities (or back-propagated gradients) within a given layer. Ollivier (2013) proposed a neural network optimization method which uses a block-diagonal approximation of the Fisher, with the blocks corresponding to the incoming weights (and bias) of each unit. This method is similar to TONGA, except that it approximates the Fisher instead of the empirical Fisher (see Martens (2014) for a discussion of the difference between these).",
      "startOffset" : 3,
      "endOffset" : 2924
    }, {
      "referenceID" : 11,
      "context" : "Le Roux et al. (2008) proposed a neural network optimization method known as TONGA based on a block-diagonal approximation of the empirical Fisher where each block corresponds to the weights associated with a particular unit. By contrast, K-FAC uses much larger blocks, each of which corresponds to all the weights within a particular layer. The matrices which are inverted in K-FAC are roughly the same size as those which are inverted in TONGA, but rather than there being one per unit as in TONGA, there are only two per layer. Therefore, K-FAC is significantly less computationally intensive than TONGA, despite using what is arguably a much more accurate approximation to the Fisher. Note that to help mitigate the cost of the many matrix inversions it requires, TONGA approximates the blocks as being low-rank + a diagonal term, although this introduces further approximation error. Centering methods work by either modifying the gradient (Schraudolph, 1998) or dynamically reparameterizing the network itself (Raiko et al., 2012; Vatanen et al., 2013), so that various unit-wise scalar quantities like the activities (the ai’s) and local derivatives (the φi(si)’s) are 0 on average (i.e. “centered”), as they appear in the formula for the gradient. Typically, these methods require the introduction of additional “skip” connections (which bypass the nonlinearities of a given layer) in order to preserve the expressive power/efficiency of the network after these transformations are applied. It is argued by Raiko et al. (2012) that the application of centering methods moves the Fisher closer to a diagonal matrix, and thus makes the gradient a reasonable approximation to the natural gradient. However, this argument uses the strong approximating assumption that the correlations between various network-dependent quantities, such as the activities of different units within a given layer, are zero. In our notation, this would be like assuming that the Gi,i’s are diagonal, and that the Āi,i’s are rank-1 plus a diagonal term. Indeed, using such an approximation within the block-diagonal version of K-FAC would yield an algorithm similar to standard centering, although without the need for skip connections. As shown in Corollary 3, K-FAC can be interpreted as automatically performing centering, along with the much stronger operation of whitening, of the unit activities and various other quantities which appear in the formula for the gradient. Intuitively, it is this whitening which accounts for the correlations between activities (or back-propagated gradients) within a given layer. Ollivier (2013) proposed a neural network optimization method which uses a block-diagonal approximation of the Fisher, with the blocks corresponding to the incoming weights (and bias) of each unit. This method is similar to TONGA, except that it approximates the Fisher instead of the empirical Fisher (see Martens (2014) for a discussion of the difference between these). Because computing blocks of the Fisher is expensive (it requires k backpropagations, where k is the number of output units), this method uses a biased deterministic approximation which can be computed more efficiently, and is similar in spirit to the deterministic approximation used by LeCun et al. (1998). Note that while such an approximation could hypothetically be used within K-FAC to compute the Gi,j’s, we have found that our basic unbiased stochastic approximation works nearly",
      "startOffset" : 3,
      "endOffset" : 3282
    }, {
      "referenceID" : 7,
      "context" : "The work most closely related to ours is that of Heskes (2000), who proposed an approximation of the Fisher of feed-forward neural networks similar to our Kronecker-factored blockdiagonal approximation F̆ from Section 4.",
      "startOffset" : 49,
      "endOffset" : 63
    }, {
      "referenceID" : 2,
      "context" : "using the techniques of Arnold et al. (2011)).",
      "startOffset" : 24,
      "endOffset" : 45
    }, {
      "referenceID" : 35,
      "context" : "Due to their high difficulty, performance on these problems has become a standard benchmark for neural network optimization methods (e.g. Martens, 2010; Vinyals and Povey, 2012; Sutskever et al., 2013).",
      "startOffset" : 132,
      "endOffset" : 201
    }, {
      "referenceID" : 32,
      "context" : "Due to their high difficulty, performance on these problems has become a standard benchmark for neural network optimization methods (e.g. Martens, 2010; Vinyals and Povey, 2012; Sutskever et al., 2013).",
      "startOffset" : 132,
      "endOffset" : 201
    }, {
      "referenceID" : 8,
      "context" : "To investigate the practical performance of K-FAC we applied it to the 3 deep-autoencoder optimization problems from Hinton and Salakhutdinov (2006), which use the “MNIST”, “CURVES”, and “FACES” datasets respectively (see Hinton and Salakhutdinov (2006) for a complete description of the network architectures and datasets).",
      "startOffset" : 117,
      "endOffset" : 149
    }, {
      "referenceID" : 8,
      "context" : "To investigate the practical performance of K-FAC we applied it to the 3 deep-autoencoder optimization problems from Hinton and Salakhutdinov (2006), which use the “MNIST”, “CURVES”, and “FACES” datasets respectively (see Hinton and Salakhutdinov (2006) for a complete description of the network architectures and datasets).",
      "startOffset" : 117,
      "endOffset" : 254
    }, {
      "referenceID" : 8,
      "context" : "To investigate the practical performance of K-FAC we applied it to the 3 deep-autoencoder optimization problems from Hinton and Salakhutdinov (2006), which use the “MNIST”, “CURVES”, and “FACES” datasets respectively (see Hinton and Salakhutdinov (2006) for a complete description of the network architectures and datasets). Due to their high difficulty, performance on these problems has become a standard benchmark for neural network optimization methods (e.g. Martens, 2010; Vinyals and Povey, 2012; Sutskever et al., 2013). As a baseline we used the version of SGD with momentum described in Sutskever et al. (2013), which was calibrated to work well on these particular deep autoencoder problems.",
      "startOffset" : 117,
      "endOffset" : 620
    }, {
      "referenceID" : 8,
      "context" : "To investigate the practical performance of K-FAC we applied it to the 3 deep-autoencoder optimization problems from Hinton and Salakhutdinov (2006), which use the “MNIST”, “CURVES”, and “FACES” datasets respectively (see Hinton and Salakhutdinov (2006) for a complete description of the network architectures and datasets). Due to their high difficulty, performance on these problems has become a standard benchmark for neural network optimization methods (e.g. Martens, 2010; Vinyals and Povey, 2012; Sutskever et al., 2013). As a baseline we used the version of SGD with momentum described in Sutskever et al. (2013), which was calibrated to work well on these particular deep autoencoder problems. For each problem we followed the prescription given by Sutskever et al. (2013) for determining the learning rate, and the schedule for the decay constant μ.",
      "startOffset" : 117,
      "endOffset" : 781
    }, {
      "referenceID" : 14,
      "context" : "Each method used the same initial parameter setting, which was generated using the “sparse initialization” technique from Martens (2010) (which was also used by Sutskever et al.",
      "startOffset" : 122,
      "endOffset" : 137
    }, {
      "referenceID" : 14,
      "context" : "Each method used the same initial parameter setting, which was generated using the “sparse initialization” technique from Martens (2010) (which was also used by Sutskever et al. (2013)).",
      "startOffset" : 122,
      "endOffset" : 185
    } ],
    "year" : 2017,
    "abstractText" : "We propose an efficient method for approximating natural gradient descent in neural networks which we call Kronecker-factored Approximate Curvature (K-FAC). K-FAC is based on an efficiently invertible approximation of a neural network’s Fisher information matrix which is neither diagonal nor low-rank, and in some cases is completely non-sparse. It is derived by approximating various large blocks of the Fisher (corresponding to entire layers) as factoring as Kronecker products between two much smaller matrices. While only several times more expensive to compute than the plain stochastic gradient, the updates produced by K-FAC make much more progress optimizing the objective, which results in an algorithm that can be much faster than stochastic gradient descent with momentum in practice. And unlike some previously proposed approximate natural-gradient/Newton methods such as Hessian-free methods, K-FAC works very well in highly stochastic optimization regimes.",
    "creator" : "LaTeX with hyperref package"
  }
}