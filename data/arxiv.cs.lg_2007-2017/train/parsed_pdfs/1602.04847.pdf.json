{
  "name" : "1602.04847.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Black-box optimization with a politician",
    "authors" : [ "Sébastien Bubeck", "Yin Tat Lee" ],
    "emails" : [ "sebubeck@microsoft.com", "yintat@mit.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "In standard black-box convex optimization Nemirovski and Yudin [1983], Nesterov [2004], Bubeck [2015] first-order methods interact with an oracle: given a query point x, the oracle reports the value and gradient of the underlying objective function f at x. In this paper we propose to replace the oracle by a politician. Instead of answering the original query x the politician changes the question and answers a new query y which is guaranteed to be better than the original query x in the sense that f(y) ≤ f(x). The newly selected query y also depends on the history of queries that were made to the politician. Formally we introduce the following definition (for sake of simplicty we write∇f(x) for either a gradient or a subgradient of f at x).\nDefinition 1 Let X ⊂ Rn and f : X → R. A politician Φ for f is a mapping from X ×∪∞k=0(X × R × Rn)k to X such that for any k ≥ 0, x ∈ X , h ∈ (X × R × Rn)k one has f(Φ(x, h)) ≤ f(x). Furthermore when queried at x with history h a politician for f also output f(Φ(x, h)) and ∇f(Φ(x, h)) (in order to not overload notation we do not include these outputs in the range of Φ).\nLet us clarify the interaction of a first-order method with a politician. Note that we refer to the couple (first-order method, politician) as the algorithm. Let M : ∪∞k=0(X × R × Rn)k → X be a first-order method and Φ a politician for some function f : X → R. The course of the algorithm (M,Φ) then goes as follows: at iteration k+1 one first calculates the method’s query point xk+1 =\n∗Most of this work were done while the author was at Microsoft Research, Redmond. The author was supported by NSF awards 0843915 and 1111109.\nar X\niv :1\n60 2.\n04 84\n7v 1\n[ m\nat h.\nO C\n] 1\n5 Fe\nM(hk) (with h0 = ∅), then one calculates the politician’s new query point yk+1 = Φ(xk+1, hk) and the first order information at this point (f(yk+1),∇f(yk+1)), and finally one updates the history with this new information hk+1 = (hk, (yk+1, f(yk+1),∇f(yk+1))). Note that a standard oracle simply corresponds to a politician O for f such that O(x, h) = (x, f(x),∇f(x)) (in particular the algorithm (M,O) is the usual algorithm corresponding to the first-order method M ).\nThe philosophy of the above definition is that it gives in some sense an automatic way to combine different optimization algorithms. Say for example that we wish to combine the ellipsoid method with gradient descent. One way to do so is to design an “ellipsoidal politician”: the politician keeps track of a feasible ellipsoidal region based on the previously computed gradients, and when asked with the query x the politician chooses as a new query y the result of a line-search on the line between x and the center of current ellipsoid. Gradient descent with this ellipsoidal politician would then replace the step x← x− η∇f(x) by x← y − η∇f(y). The hope is that in practice such a combination would integrate the fast incremental progress of gradient descent with the geometrical progress of the ellipsoid method.\nIn this paper we focus on unconstrained convex optimization. We are particularly interested in situations where calculating a (sub)gradient has superlinear complexity (i.e., n) such as in logistic regression and semidefinite programming. In such cases it is natural to try to make the most out of the computed gradients by incorporating geometric reasoning (such as in the ellipsoid method). We do so by introducing the geometric politician (Section 3), which is based on a combination of the recent ideas of Bubeck et al. [2015] with standard cutting plane/interior point methods machinery (through the notion of a “center” of a set, see Section 4). For a given first order method M , we denote by M+ the algorithm obtained by running M with the geometric politician. We demonstrate empirically (Section 5) the effectiveness of the geometric politician on various standard first-order methods for convex optimization (gradient descent, Nesterov’s accelerated gradient descent, non-linear conjugate gradient, BFGS). In particular we show that BFGS+ is a surprisingly robust and parameter-free algorithm with state of the art performance across a wide range of problems (both smooth and non-smooth)."
    }, {
      "heading" : "2 Affine invariant politician",
      "text" : "As mentioned above we assume that the complexity of computing the map x 7→ ∇f(x) is superlinear. This implies that we can afford to have a politician such that the complexity of computing the map (x, h) 7→ Φ(x, h) is O(n × poly(k)) (we think of the number of iterations k as typically much smaller than the dimension n). We show in this section that this condition is (essentially) automatically satisfied as long as the politician is affine invariant in the following sense (we use a slight abuse of language and refer to a map f 7→ Φf , where Φf is a politician for f , as a politician):\nDefinition 2 A politician f 7→ Φf is called affine invariant if for any function f and any affine map T : Rm → Rn such that T (x) = z + Lx for some matrix L, k ≥ 0, x ∈ Rn, (yi, vi, gi) ∈ Rm × R× Rn, one has\nT (Φf◦T (x, (yi, vi, L >gi)i∈[k])) = Φf (T (x), (T (yi), vi, gi)i∈[k]).\nWe say that an affine invariant politician has cost ψ : N → N if for any f : Rk → R the map (x, h) ∈ Rk × (Rk × R× Rk)k 7→ Φf (x, h) can be computed in time ψ(k).\nProposition 1 Let Φ be an affine invariant politician with cost ψ. Then for any f : Rn → R, (yi, vi, gi) ∈ Rn × R × Rn, i ∈ [k] and x, yi ∈ y1 + Span(g1, . . . , gk) one can compute Φf (x, (yi, vi, gi)i∈[k]) ∈ Rn in time ψ(k) +O(nk2).\nProof Let G be the n× k matrix with ith column given by gi. We consider the QR decomposition of G which can be computed in time O(nk2), that is Q is an n × k matrix and R a k × k matrix such that G = QR and Q>Q = Ik. Let T be the affine map defined by T = y1 + Q. Note that since x ∈ y1 + Span(g1, . . . , gk) one has x = T (Q>(x− y1)) (and similarly for yi). Thus by affine invariance one has\nΦf (x, (yi, vi, gi)) = Φf (T (Q >(x− y1)), (T (Q>(yi − y1)), vi, gi))\n= y1 +QΦf◦T (Q >(x− y1), (Q>(yi − y1), vi, Ri)),\nwhere Ri is the ith column of R. Furthermore by definition of the cost ψ and since f ◦T is defined on Rk we see that this last quantity can be computed in time ψ(k) + O(nk2), thus concluding the proof.\nThe above proposition shows that with an affine invariant politician and a first order method M verifying for any (yi, vi, gi)i∈[k] ∈ (Rn × R× Rn)k,\nM((yi, vi, gi)i∈[k]) ∈ y1 + Span(y1, . . . , yk, g1, . . . , gk),\none can run k steps of the corresponding algorithm in time O(nk2 + kψ(k)) plus the time to compute the k function values and gradients of the underlying function f to be optimized. Note that one gets a time of O(nk2) instead of O(nk3) as one can store the QR decomposition from one step to the next, and updating the decomposition only cost O(nk)."
    }, {
      "heading" : "3 Geometric politician",
      "text" : "We describe in this section the geometric politician which is based on ideas developed in Bubeck et al. [2015]. A key observation in the latter paper is that if f is a α-strongly convex function minimized at x∗ then one has for any x,∥∥∥∥x∗ − x− 1α∇f(x)\n∥∥∥∥2 ≤ ‖∇f(x)‖2α2 − 2α (f(x)− f(x∗)) . This motivates the following definition:\nB(x, α, fval) := { z ∈ Rn : ∥∥∥∥z − x− 1α∇f(x) ∥∥∥∥2 ≤ ‖∇f(x)‖2α2 − 2α (f(x)− fval) } .\nIn particular given the first order information at y1, . . . , yk one knows that the optimum x∗ lies in the region Rk ⊂ Rn defined by\nRk = ⋂ i∈[k] B(yi, α, fval) where fval = min i∈[k] f(yi). (1)\nNow suppose that given this first order information at y1, . . . , yk the first order method asks to query x. How should we modify this query in order to take into account the geometric information that x∗ ∈ Rk? First observe that for any z, B(z, α, fval) is contained in a halfspace that has z on its boundary (in the limiting case α → 0 the set B(z, α, f(z)) is exactly a halfspace). In particular if the next query point yk+1 is the center of gravity of Rk then we have that the volume of Rk+1 is at most 1 − 1/e times the volume of Rk (see Grünbaum [1960]), thus leading to an exponential convergence rate. However the region Rk can be very large initially, and the center of gravity might have a large function value and gradient, which means that Rk would be intersected with a large sphere (possibly so large that it is close to a halfspace). On the other hand the first order method recommends to query x, which we can think of as a local improvement of yk, which should lead to a much smaller sphere. The issue is that the position of this sphere might be such that the intersection with Rk is almost as large as the sphere itself. In order to balance between the geometric and function value/gradient considerations we propose for the new query to do a line search between the center of Rk and the recommended query x. The geometric politician follows this recipe with two important modifications: (i) there are many choices of centers that would guarantee an exponential convergence rate while being much easier to compute than the center of gravity, and we choose here to consider the volumetric center, see Section 4 for the definition and more details about this notion; (ii) we use a simple heuristic to adapt online the strong convexity parameter α, namely we start with some large value for α and if it happens that the feasible region Rk is empty then we know that α was too large, in which case we reduce it. We can now describe formally the geometric politician, see Algorithm 1. Importantly one can verify that the geometric politician is affine invariant and thus can be implemented efficiently (see the proof of Proposition 1).\nAlgorithm 1: Geometric Politician Parameter: An upper bound on the strong convexity parameter α. (Can be +∞.) Input: Query x, past queries and the corresponding first order information (yi, f(yi),∇f(yi))i∈[k]. Let fval = mini∈[k] f(yi) and the feasible region Rk(α) = ⋂ i∈[k] B(yi, α, fval).\nif Rk(α) = ∅ then Let α be the largest number such that Rk(α) 6= ∅. α← α/4. end Let yk+1 = argminy∈{tx+(1−t)c(Rk(α)),t∈R} f(y) where c(Rk(α)) is the volumetric center of Rk(α) (see Section 4). Output: yk+1, f(yk+1) and ∇f(yk+1)."
    }, {
      "heading" : "4 Volumetric center",
      "text" : "The volumetric barrier for a polytope was introduced in Vaidya [1996] to construct an algorithm with both the oracle complexity of the center of gravity method and the computational complexity of the ellipsoid method (see [Section 2.3, Bubeck [2015]] for more details and Lee et al. [2015] for\nrecent advances on this construction). Recalling that the standard logarithmic barrier FP for the polytope P = {x ∈ Rn : a>i x < bi, i ∈ [m]} is defined by\nFP (x) = − m∑ i=1 log(bi − a>i x),\none defines the volumetric barrier vP for P by\nvP (x) = logdet(∇2FP (x)). The volumetric center c(P ) is then defined as the minimizer of vP . In the context of the geometric politician (see Algorithm 1) we are dealing with an intersection of balls rather than an intersection of halfspaces. More precisely the region of interest is of the form:\nR = k⋂ i=1 {x ∈ Rn : ‖x− ci‖ ≤ ri} .\nFor such a domain the natural self-concordant barrier to consider is:\nFR(x) = − 1\n2 k∑ i=1 log ( r2i − ‖x− ci‖2 ) .\nThe volumetric barrier is defined as before by\nvR(x) = logdet(∇2FR(x)), and the volumetric center of R is the minimizer of vR. It is shown in Anstreicher [2004] that vR is a self-concordant barrier which means that the center can be updated (when a new ball is added to R) via few iterations of Newton’s method. Often in practice, it takes less than 5 iterations to update the minimizer of a self-concordant barrier Goffin and Vial [1999], Bahn et al. [1995] when we add a new constraint. Hence, the complexity merely depends on how fast we can compute the gradient and Hessian of FR and vR.\nProposition 2 For the analytic barrier FR, we have that\n∇FR(x) =A>1k×1, ∇2FR(x) =2A>A+ λ(1)I\nwhere d is a vector defined by (r2i − ‖x− ci‖2) −1, A is a k × n matrix with ith row given by di(x)(x− ci), λ(p) = ∑ i∈[k] d p i (x) and 1k×1 is a k × 1 matrix with all entries being 1.\nFor the volumetric center, we have that ∇vR(x) = (( 2trH−1 ) I + 4H−1 ) A>d+ 8A>σ,\n∇2vR(x) = 48A>ΣA− 64A> ( AH−1A> )(2) A\n+ ( 8tr(DΣ) + 2λ(2)tr(H−1) ) I + 4λ(2)H−1\n+ 8tr(H−1)A>DA+ 16sym ( A>DAH−1 ) − 4tr(H−2)A>DJDA− 8H−1A>DJDAH−1\n− 8sym(A>DJDAH−2)− 8 ( d>AH−1A>d ) H−1\n− 16sym ( A>diag ( AH−2A> ) JDA ) − 32sym ( A>diag(AH−1A>d)AH−1 )\nwhere H = ∇2FR(x), σi = e>i AH−1A>ei, ei is the indicator vector with ith coordinate, J is a k × k matrix with all entries being 1, sym(B) = B + B>, diag(v) is a diagonal matrix with diag(v)ii = vi, Σ = diag(σ), and B(2) is the Schur square of B defined by B (2) ij = B 2 ij .\nThe above proposition shows that one step of Newton method for analytic center requires 1 dense matrix multiplication and solving 1 linear system; and for volumetric center, it requires 5 dense matrix multiplications, 1 matrix inversion and solving 1 linear system if implemented correctly. Although the analytic center is a more popular choice for “geometrical” algorithms, we choose volumetric center here because it gives a better convergence rate Vaidya [1996], Atkinson and Vaidya [1995] and the extra cost ψ(k) is negligible to the cost of updating QR decomposition nk."
    }, {
      "heading" : "5 Experiments",
      "text" : "In this section, we compare the geometric politician against two libraries for first order methods, minFunc Schmidt [2012] and TFOCS Becker et al. [2011]. Both are popular MATLAB libraries for minimizing general smooth convex functions. Since the focus of this paper is all about how to find a good step direction using a politician, we use the exact line search (up to machine accuracy) whenever possible. This eliminates the effect of different line searches and reduces the number of algorithms we need to test. TFOCS is the only algorithm we use which does not use line search because they do not provide such option. To compensate on the unfairness to TFOCS, we note that the algorithm TFOCS uses is accelerated gradient descent and hence we implement the GonzagaKaras’s accelerated gradient descent Gonzaga and Karas [2013], which is specifically designed to be used with exact line search. Another reason we pick this variant of accelerated gradient descent is because we found it to be the fastest variant of accelerated gradient descent (excluding the geometric descent of Bubeck et al. [2015]) for our tested data (Gonzaga and Karas also observed that on their own dataset).\nThe algorithms to be tested are the following:\n• [SD] Steepest descent algorithm in minFunc.\n• [Nes] Accelerated gradient descent, General Scheme 2.2.6 in Nesterov [2004].\n• [TFOCS] Accelerated gradient descent in TFOCS.\n• [GK] Gonzaga-Karas’s of Accelerated Gradient Descent (Sec 5.1).\n• [Geo] Geometric Descent Bubeck et al. [2015].\n• [CG] Non-Linear Conjugate Gradient in minFunc.\n• [BFGS] Broyden–Fletcher–Goldfarb–Shanno algorithm in minFunc.\n• [PCG] Preconditioned Non-Linear Conjugate Gradient in minFunc.\n• [∅+] Geometric Politician itself (Sec 5.1).\n• [GK+] Using GK with Geometric Oracle (Sec 5.1).\n• [BFGS+] Using BFGS with Geometric Oracle (Sec 5.1).\nWe only tested the geometric oracle on GK and BFGS because they are respectively the best algorithms in theory and practice on our tested data. The ∅+ algorithm is used as the control group to test if the geometric politician by itself is sufficient to achieve good convergence rate. We note that all algorithms except Nes are parameter free; each step of SD, Nes, TFOCS, GK, Geo, CG takes O(n) time and each step of BFGS, PCG, ∅+, GK+ and BFGS+ takes roughly O(nk) time for kth iteration."
    }, {
      "heading" : "5.1 Details of Implementations",
      "text" : "The first algorithm we implement is the ∅+ algorithm which simply repeatedly call the politician. As we will see, this algorithm is great for non smooth problems but not competitive for smooth problems.\nAlgorithm 2: ∅+ Input: x0. for k ← 1, 2, · · · do\nSet xk+1 ← Φf (xk, (xi, f(xi),∇f(xi))i∈[k]). end\nThe second algorithm we implement is the accelerated gradient descent proposed by Gonzaga and Karas Gonzaga and Karas [2013]. This algorithm uses line search to learn the the smoothness parameter and strong convexity parameter, see Algorithm 3. We disable the line (*) in the algorithm if Φf is a politician instead of an oracle because γ ≥ α does not hold for the strong convexity parameter α if Φf is not an oracle.\nThe third algorithm we implemented is the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm. This algorithm uses the gradients to reconstruct the Hessian and use it to approximate Newton’s method, see Algorithm 4. We note that another natural way to employ the politician with BFGS is to set xk+1 = line search(Φf (xk), p) and this runs faster in practice; however, this algorithm computes two gradients per iteration (namely ∇f(xk) and ∇f(Φf (xk))) while we restrict ourselves to algorithms which compute one gradient per iteration."
    }, {
      "heading" : "5.2 Quadratic function",
      "text" : "We consider the function\nf(x) = (x− c)>D(x− c), (2)\nwhere D is a diagonal matrix with entries uniformly sampled from [0, 1] and c is a random vector with entries uniformly sampled from the normal distribution N(0, 1). Since this is a quadratic function, CG, BFGS and BFGS+ are equivalent and optimal, namely, they output the minimum point in the span of all previous gradients.\nAlgorithm 3: Gonzaga-Karas’s variant of Accelerated Gradient Descent Input: x1. γ = 2α, v0 = x0 and y0 = x0. for k ← 1, 2, · · · do\nyk ← Φf (yk−1). xk+1 = line search(yk,−∇f(yk)). if α ≥ γ/1.02 and we are using first order oracle then α = γ/2. (*) if α ≥ ‖∇f(yk)‖ 2\n2(f(yk)−f(xk+1)) then α = ‖∇f(yk)‖ 2 20(f(yk)−f(xk+1)) . G = γ ( α 2 ‖vk − yk‖2 + 〈∇f(yk), vk − yk〉 ) . A = G+ 1 2 ‖∇f(yk)‖2 + (α− γ)(f(xk)− f(yk)). B = (α− γ)(f(xk+1)− f(xk))− γ(f(yk)− f(xk))−G. C = γ(f(xk+1)− f(xk)). β = −B+ √ B2−4AC 2A\n, γ = (1− β)γ + βα. vk+1 = 1 γ ((1− β)γvk + β(αyk −∇f(yk)).\nend"
    }, {
      "heading" : "5.3 Variant of Nesterov’s Worst Function",
      "text" : "Nesterov [2004] introduced the function\nf(x) = (1− x[1])2 + n−1∑ k=1 (x[k]− x[k + 1])2\nand used it to give a lower bound for all first-order methods. To distinguish the performance between CG, BFGS and BFGS+, we consider the following non-quadratic variant\nf(x) = g(1− x[1]) + n−1∑ k=1 g(x[k]− x[k + 1]) (3)\nfor some function g to be defined. If we pick g(x) = |x| then all first order methods takes at least n iterations to minimize f exactly. On the other hand with g(x) = max(|x| − 0.1, 0) one of the minimizer of f is (1, 9\n10 , 8 10 , · · · , 1 10 , 0, 0, · · · , 0), and thus it takes at least 11 iterations for\nfirst order methods to minimize f in this case. We “regularize” the situation a bit and consider the function\ng(x) =  √ (x− 0.1)2 + 0.0012 − 0.001 if x ≥ 0.1√ (x+ 0.1)2 + 0.0012 − 0.001 if x ≤ −0.1\n0 otherwise\n.\nSince this function is far from quadratic, our algorithms (∅+, GK+, BFGS+) converge much faster. This is thus a nice example where the geometric politician helps a lot because the underlying dimension of the problem is small.\nAlgorithm 4: BFGS Input: x1. for k ← 1, 2, · · · do\np = −∇f(xk). for i← k − 1, · · · , 1 do\nαi ← 〈si, p〉 / 〈si, yi〉. p = p− αiyi.\nend p = 〈sk−1, yk−1〉 / 〈yk−1, yk−1〉 p. for i← 1, · · · , k − 1 do\nβi ← 〈yi, p〉 / 〈si, yi〉. p = p+ (αi − βi)yi.\nend xk+1 = Φf (line search(xk, p)). sk = xk+1 − xk, yk = ∇f(xk+1)−∇f(xk).\nend"
    }, {
      "heading" : "5.4 Binary regression with smoothed hinge loss",
      "text" : "We consider the binary classification problem on the datasets from Chang and Lin [2011]. The problem is to minimize the regularized empirical risk:\nft(x) = 1\nn n∑ i=1 ϕt(bia T i x) + λ 2 |x|2 (4)\nwhere ai ∈ Rd, bi ∈ R are given by the datasets, λ is the regularization coefficient, ϕt is the smoothed hinge loss defined by\nϕt(z) =  0 if z ≤ −1 z + 1− t 2 if z ≥ −1 + t\n1 2t (z + 1)2 otherwise\nand t is the smoothness parameter. The usual choice for t is 1, here we test both t = 1 and t = 10−4. The latter case is to test how well the algorithms perform when the function is non-smooth.\nWe note that for this problem it would be natural to compare ourselves with SGD (stochastic gradient descent) or more refined stochastic algorithms such as SAG Le Roux et al. [2012] or SVRG Johnson and Zhang [2013]. However since the focus of this paper is on general black-box optimization we stick to comparing only to general methods. It is an interesting open problem to extend our algorithms to the stochastic setting, see Section 6.\nIn figures 3 and 4, we show the performance profile for problems in the LIBSVM datasets (and with different values for the regularization parameter λ). More precisely for a given algorithm we plot x ∈ [1, 10] versus the fraction of datasets that the algorithm can solve (up to a certain prespecified accuracy) in a number of iterations which is at most x times the number of iterations of the best algorithm for this dataset. Figure 3 shows the case t = 1 with the targeted accuracy 10−6; Figure 4 shows the case t = 10−4 with the targeted accuracy 10−3. We see that TFOCS is\nslower than SD for many problems, this is simply because SD uses the line search while TFOCS does not, and this makes a huge difference for simple problems. Among algorithms taking O(n) time per iteration, CG and Geo perform the best, while for theO(nk) algorithms we see that BFGS, BFGS+ and GK+ perform the best. The gap in performance is particularly striking in the nonsmooth case where BFGS+ is the fastest algorithm on almost all problems and all other methods (except GK+) are lagging far behind (for 20% of the problems all other methods take 10 times more iterations than BFGS+ and GK+).\nFinally in figures 5 and 6 we test five algorithms on three specific datasets (respectively in the smooth and non-smooth case). In both figures we see that BFGS+ performs the best for all three datasets. BFGS performs second for smooth problems while GK+ performs second for nonsmooth problems."
    }, {
      "heading" : "5.5 Summary",
      "text" : "The experiments show that BFGS+ and BFGS perform the best among all methods for smooth test problems while BFGS+ and GK+ perform the best for nonsmooth test problems. The first phenomenon is due to the optimality of these algorithm for quadratic problems. We leave the explanation for the second phenomenon as an open problem. At least, the experiments show that this is not due to the geometric oracle itself since ∅+ is much slower, and this is not due to the original algorithm since GK performs much worse than GK+ for those problems. Overall these experiments are very promising for the geometric oracle as a replacement of quasi Newton method for non-smooth problems and as a general purpose solver due to its robustness."
    }, {
      "heading" : "6 Discussion",
      "text" : "First order methods generally involve only very basic operations at each step (addition, scalar multiplication). In this paper we formalize each step’s operations (besides the gradient calculation) as the work of the politician. We showed that the cost per step of an affine invariant politician ψ(k) is negligible compared to the gradient calculation (which is Ω(n)). This opens up a lot of possibilities: instead of basic addition or scalar multiplication one can imagine computing a center of gravity, solving a linear program, or even searching over an exponential space (indeed, say k < 30 and n > 1010, then 2k < n). Our experiments demonstrate the effectiveness of this strategy. On the other hand from a theoretical point of view a lot remains to be done. For example one can prove results of the following flavor:\nTheorem 1 Let f such that αI ∇2f(x) βI,∀x ∈ Rn and let κ = β/α. Suppose that in the Geometric Politician we replace the volumetric center by the center of gravity or the center of the John ellipsoid. Let yk be the output of the kth step of SD+ with some initial point x0. Then, we have that\nf(yk)− f(x∗) ≤ κ (\n1− 1 Θ(min(n log(κ), κ))\n)k (f(x0)− f(x∗)) .\nand\nf(yk)− f(x∗) ≤ 2βR2\nk + 4\nwhere R = maxf(x)≤f(x0) ‖x− x∗‖.\nThis claim says that, up to a logarithmic factor, SD+ enjoys simultaneously the incremental progress of gradient descent and the geometrical progress of cutting plane methods. There are three caveats in this claim:\n• We use the center of gravity or the center of the John ellipsoid instead of the volumetric center. Note however that it is well-known that the volumetric center is usually more difficult to analyze, Vaidya [1996], Atkinson and Vaidya [1995].\n• The extraneous log(κ) comes from the number of potential restart when we decrease α. Is there a better way to learn α that would not incur this additional logarithmic term?\n• Bubeck et al. [2015] shows essentially that one can combine the ellipsoid method with gradient descent to achieve the optimal 1− √ 1/κ rate. Can we prove such a result for SD+?\nThe geometric politician could be refined in many ways. Here are two simple questions that we leave for future work:\n• One can think that gradient descent stores 1 gradient information, accelerated gradient descent stores 2 gradient information, and our method stores all past gradient information. We believe that neither 1, 2 nor all is the correct answer. Instead, the algorithm should dynamically decide the number of gradients to store based on the size of its memory, the cost of computing gradients, and the information each gradient reveals.\n• Is there a stochastic version of our algorithm? How well would such a method compare with state of the art stochastic algorithms such as SAG Le Roux et al. [2012] and SVRG Johnson and Zhang [2013]?\nA Convergence of SD+ Let f such that αI ∇2f(x) βI for all x ∈ Rn and let κ = β/α. Let yk be the output of the kth step of SD+ (where the volumetric center is replaced by the center of gravity or the center of the John ellipsoid) with some initial point x0. We prove two rates of convergence for SD+, one with the condition number κ, and one with the ambient dimension n. We start by the former.\nTheorem 2 One has\nf(yk)− f(x∗) ≤ (\n1− 1 κ\n)k (f(x0)− f(x∗))\nand\nf(yk)− f(x∗) ≤ 2βr2\nk + 4\nwhere r = maxf(x)≤f(x0) ‖x− x∗‖.\nProof Let δk = f(yk)− f(x∗). Since f is α-strongly convex we have that\nδk ≤ 1\n2α ‖∇f(yk)‖2.\nDue to the decrease guarantee of politicians and the line search in steepest descent, we have that f(yk+1) ≤ f(xk+1) ≤ f(yk)− 12β‖∇f(yk)‖ 2 and hence\nδk − δk+1 ≥ 1\n2β ‖∇f(yk)‖2 ≥ δk κ . (5)\nHence, we have δk+1 ≤ ( 1− 1\nκ\n) δk and this gives the first inequality.\nTo obtain a rate independent of α we instead use the following estimate\nδk ≤ 〈∇f(yk), yk − x∗〉 ≤ ‖∇f(yk)‖ · ‖yk − x∗‖.\nUsing the decrease guarantee of politicians and line search we have that f(yk) ≤ f(xk) ≤ f(yk−1) ≤ · · · ≤ f(x0), and thus by definition of R:\n‖yk − x∗‖ ≤ r.\nDue to the line search in steepest descent again, we have that\nδk − δk+1 ≥ 1\n2β ‖∇f(yk)‖2 ≥\n1\n2β ( δk r )2 .\nSince δk ≥ δk+1, we have\n1 δk+1 − 1 δk = δk − δk+1 δkδk+1 ≥ δk − δk+1 δ2k ≥ 1 2βr2 .\nSo, by induction, we have that 1 δk ≥ 1 δ0 + k 2βr2 . Now, we note that\nδ0 ≤ 〈∇f(x∗), x0 − x∗〉+ β\n2 ‖x0 − x∗‖2 ≤\nβr2\n2 .\nThus, we have that\nδk ≤ 2βr2\nk + 4 .\nWe now turn to the dimension dependent analysis of SD+. We first show a simple geometric result, namely that if an intersection of spheres has a “small” volume then the intersection must lie close close to the boundary of one of the spheres.\nLemma 1 Let R = ∩ki=1{x ∈ Rn : ‖x− ci‖ ≤ ri}, D = maxi∈[k] ri, and ωn the volume of the unit ball in Rn. Then, there exists i ∈ [k] such that for all x ∈ R,\n‖x− ci‖2 ≥ r2i − 24k2 ( volR\nDnωn\n)1/n D2.\nProof Since − log(1 − ‖x‖2) is a 1-self concordant barrier function, 2FR is a k-self concordant function. Let y be the minimizer of FR. Let E = {x ∈ Rn : x>∇2(2FR)(y)x ≤ 1}. Theorem 4.2.6 in Nesterov [2004] shows that\ny + E ⊂ R ⊂ y + (k + 2 √ k)E. (6)\nIn particular, this shows that volE ≤ volR. We have that( det∇2FR(y) )1/2 =\nωn 2n/2 1 volE ≥ ωn 2n/2 1 volR .\nBy the AM-GM inequality, we have that\ntr∇2FR(y) n ≥ 1 2 ( ωn volR )2/n . (7)\nBy Proposition 1, we have that∇2FR(y) = 2A>A+ λ(1)I and hence,\ntr∇2FR(y) = 2trA>A+ nλ(1)\n= 2 k∑ i=1\n‖y − ci‖2\n(r2i − ‖y − ci‖2)2 + n k∑ i=1\n1\nr2i − ‖y − ci‖2 .\nApplying (7), we have that\n2\nn k∑ i=1\n‖y − ci‖2\n(r2i − ‖y − ci‖2)2 + k∑ i=1\n1 r2i − ‖y − ci‖2 ≥ 1 2 ( ωn volR )2/n So, there exists i such that\n‖y − ci‖2\n(r2i − ‖y − ci‖2)2 ≥ n 8k ( ωn volR )2/n or\n1 r2i − ‖y − ci‖2 ≥ 1 4k ( ωn volR )2/n .\nUsing ‖y − ci‖ ≤ ri ≤ D and volR ≤ Dnωn, we have that\nr2i − ‖y − ci‖2 ≤ max\n(√ 8k\nn\n( volR\nωn\n)1/n ‖y − ci‖, 4k ( volR\nωn\n)2/n)\n≤ 4k ( volR\nDnωn\n)1/n D2.\nTherefore, the width of the ellipsoid E in the direction y − ci is at most\nri − ‖y − ci‖ ≤ ri − √ r2i − 4k ( volR\nDnωn\n)1/n D2.\nThe right hand side of (6) shows that, for all x ∈ R, we have\n‖x− ci‖ ≥ ri − (1 + k + 2 √ k) ri − √ r2i − 4k ( volR\nDnωn\n)1/n D2  ≥ ri − (1 + k + 2 √ k) ( ri − ri ( 1− 4k ( volR\nDnωn\n)1/n D2\nr2i\n))\n≥ [ 1− 12k2 ( volR\nDnωn\n)1/n D2\nr2i\n] ri.\nHence, we have\n‖x− ci‖2 ≥ [ 1− 24k2 ( volR\nDnωn\n)1/n D2\nr2i\n] r2i .\nFinally, equipped with the above geometrical result, we can bound the convergence of SD+ using the dimension n. We start with a lemma taking care of the adaptivity to the strong convexity in the geometric politician.\nLemma 2 In the first k = Θ(n log(κn ε )) iterations, either SD+ restarts the estimate of the strong convexity or\nf(yk)− f(x∗) ≤ ε (f(x0)− f(x∗)) .\nProof The decrease guarantee and the smoothness imply that\n‖∇f(yk)‖2\n2β ≤ f(yk)− f(x∗) ≤ f(x0)− f(x∗).\nTherefore, all the spheres found by the geometric politician have radius squared at most D2 where, denoting α for the convexity upper bound the algorithm is currently using,\nD2 = max k≥1\n‖∇f(yk)‖2 α2 ≤ 2β(f(x0)− f(x ∗)) α2 .\nLemma 1 shows that for any step k, there is i ∈ [k] such that for all x ∈ Rk,\n‖x− ci‖2 ≥ r2i − 48βk2\nα2 ( volRk Dnωn )1/n (f(x0)− f(x∗)).\nLet k = Θ(n log(κn ε )) and recall the discussion in Section 3 about the volume decrease of the geometric politician with the center of gravity (the same discussion applies to the John ellipsoid). We see that if the algorithm does not restart α within the first k iterations then we have\nvolRk Dnωn = ( O ( ε κ2k2 ))n ,\nand hence (for an appropriate numerical constant in k)\n‖x− ci‖2 ≥ r2i − ε(f(x0)− f(x∗))\nακ . (8)\nRecall from (5) that\nf(yk+1) ≤ f(yk)− f(yk)− f(x∗)\nκ ,\nand therefore we have (by the improvement of the previous balls): Rk+1 ⊂ { ‖x− ci‖2 ≤ r2i −\n2(f(yk)− f(x∗)) ακ\n} ∩Rk.\nHowever, from (8), we know that either the above intersection is empty or f(yk) − f(x∗) < ε(f(x0)− f(x∗)). This proves the statement.\nTheorem 3 We have that f(yk)− f(x∗) ≤ κ (\n1− 1 Θ(n log(κ))\n)k (f(x0)− f(x∗)) .\nProof If κ < n, the statements follows from Theorem 2. Hence, we can assume κ ≥ n. Set T = Θ(n log(nκ\nε ) log(κ)), Lemma 2 shows that for every Θ(n log(nκ ε )) iteration, the algo-\nrithm either finds y such that\nf(y)− f(x∗) ≤ ε (f(x0)− f(x∗))\nor decreases αk by a constant where αk is the convexity upper bound the algorithm is using at kth iteration. Note that α1 ≤ β because of the line search, and thus the algorithm can restart αk at most log(κ) many times. Hence, after T iterations, we must have\nf(yT )− f(x∗) ≤ ε (f(x0)− f(x∗)) ,\nthus concluding the proof."
    } ],
    "references" : [ {
      "title" : "The volumetric barrier for convex quadratic constraints",
      "author" : [ "M.K. Anstreicher" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Anstreicher.,? \\Q2004\\E",
      "shortCiteRegEx" : "Anstreicher.",
      "year" : 2004
    }, {
      "title" : "A cutting plane algorithm for convex programming that uses analytic centers",
      "author" : [ "David S Atkinson", "Pravin M Vaidya" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Atkinson and Vaidya.,? \\Q1995\\E",
      "shortCiteRegEx" : "Atkinson and Vaidya.",
      "year" : 1995
    }, {
      "title" : "A cutting plane method from analytic centers for stochastic programming",
      "author" : [ "Olivier Bahn", "O Du Merle", "J-L Goffin", "J-P Vial" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Bahn et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Bahn et al\\.",
      "year" : 1995
    }, {
      "title" : "Templates for convex cone problems with applications to sparse signal recovery",
      "author" : [ "Stephen R Becker", "Emmanuel J Candès", "Michael C Grant" ],
      "venue" : "Mathematical programming computation,",
      "citeRegEx" : "Becker et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Becker et al\\.",
      "year" : 2011
    }, {
      "title" : "Convex optimization: Algorithms and complexity",
      "author" : [ "S. Bubeck" ],
      "venue" : "Foundations and Trends in Machine Learning,",
      "citeRegEx" : "Bubeck.,? \\Q2015\\E",
      "shortCiteRegEx" : "Bubeck.",
      "year" : 2015
    }, {
      "title" : "A geometric alternative to nesterov’s accelerated gradient descent",
      "author" : [ "S. Bubeck", "Y.-T. Lee", "M. Singh" ],
      "venue" : "Arxiv preprint arXiv:1506.08187,",
      "citeRegEx" : "Bubeck et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Bubeck et al\\.",
      "year" : 2015
    }, {
      "title" : "Libsvm: A library for support vector machines",
      "author" : [ "Chih-Chung Chang", "Chih-Jen Lin" ],
      "venue" : "ACM Transactions on Intelligent Systems and Technology (TIST).,",
      "citeRegEx" : "Chang and Lin.,? \\Q2011\\E",
      "shortCiteRegEx" : "Chang and Lin.",
      "year" : 2011
    }, {
      "title" : "Shallow, deep and very deep cuts in the analytic center cutting plane method",
      "author" : [ "Jean-Louis Goffin", "Jean-Philippe Vial" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Goffin and Vial.,? \\Q1999\\E",
      "shortCiteRegEx" : "Goffin and Vial.",
      "year" : 1999
    }, {
      "title" : "Fine tuning nesterovs steepest descent algorithm for differentiable convex programming",
      "author" : [ "Clóvis C Gonzaga", "Elizabeth W Karas" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Gonzaga and Karas.,? \\Q2013\\E",
      "shortCiteRegEx" : "Gonzaga and Karas.",
      "year" : 2013
    }, {
      "title" : "Partitions of mass-distributions and of convex bodies by hyperplanes",
      "author" : [ "B. Grünbaum" ],
      "venue" : "Pacific J. Math,",
      "citeRegEx" : "Grünbaum.,? \\Q1960\\E",
      "shortCiteRegEx" : "Grünbaum.",
      "year" : 1960
    }, {
      "title" : "Accelerating stochastic gradient descent using predictive variance reduction",
      "author" : [ "R. Johnson", "T. Zhang" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "Johnson and Zhang.,? \\Q2013\\E",
      "shortCiteRegEx" : "Johnson and Zhang.",
      "year" : 2013
    }, {
      "title" : "A stochastic gradient method with an exponential convergence rate for strongly-convex optimization with finite training sets",
      "author" : [ "N. Le Roux", "M. Schmidt", "F. Bach" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "Roux et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Roux et al\\.",
      "year" : 2012
    }, {
      "title" : "A faster cutting plane method and its implications for combinatorial and convex optimization",
      "author" : [ "Y.-T. Lee", "A. Sidford", "S.C.-W Wong" ],
      "venue" : "Arxiv preprint arXiv:1508.04874,",
      "citeRegEx" : "Lee et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lee et al\\.",
      "year" : 2015
    }, {
      "title" : "Problem Complexity and Method Efficiency in Optimization",
      "author" : [ "A. Nemirovski", "D. Yudin" ],
      "venue" : "Wiley Interscience,",
      "citeRegEx" : "Nemirovski and Yudin.,? \\Q1983\\E",
      "shortCiteRegEx" : "Nemirovski and Yudin.",
      "year" : 1983
    }, {
      "title" : "Introductory lectures on convex optimization: A basic course",
      "author" : [ "Y. Nesterov" ],
      "venue" : "Kluwer Academic Publishers,",
      "citeRegEx" : "Nesterov.,? \\Q2004\\E",
      "shortCiteRegEx" : "Nesterov.",
      "year" : 2004
    }, {
      "title" : "minfunc: unconstrained differentiable multivariate optimization in matlab",
      "author" : [ "M Schmidt" ],
      "venue" : "URL http://www. di. ens. fr/mschmidt/Software/minFunc. html,",
      "citeRegEx" : "Schmidt.,? \\Q2012\\E",
      "shortCiteRegEx" : "Schmidt.",
      "year" : 2012
    }, {
      "title" : "A new algorithm for minimizing convex functions over convex sets",
      "author" : [ "P.M. Vaidya" ],
      "venue" : "Mathematical programming,",
      "citeRegEx" : "Vaidya.,? \\Q1996\\E",
      "shortCiteRegEx" : "Vaidya.",
      "year" : 1996
    } ],
    "referenceMentions" : [ {
      "referenceID" : 12,
      "context" : "In standard black-box convex optimization Nemirovski and Yudin [1983], Nesterov [2004], Bubeck [2015] first-order methods interact with an oracle: given a query point x, the oracle reports the value and gradient of the underlying objective function f at x.",
      "startOffset" : 42,
      "endOffset" : 70
    }, {
      "referenceID" : 12,
      "context" : "In standard black-box convex optimization Nemirovski and Yudin [1983], Nesterov [2004], Bubeck [2015] first-order methods interact with an oracle: given a query point x, the oracle reports the value and gradient of the underlying objective function f at x.",
      "startOffset" : 42,
      "endOffset" : 87
    }, {
      "referenceID" : 4,
      "context" : "In standard black-box convex optimization Nemirovski and Yudin [1983], Nesterov [2004], Bubeck [2015] first-order methods interact with an oracle: given a query point x, the oracle reports the value and gradient of the underlying objective function f at x.",
      "startOffset" : 88,
      "endOffset" : 102
    }, {
      "referenceID" : 4,
      "context" : "We do so by introducing the geometric politician (Section 3), which is based on a combination of the recent ideas of Bubeck et al. [2015] with standard cutting plane/interior point methods machinery (through the notion of a “center” of a set, see Section 4).",
      "startOffset" : 117,
      "endOffset" : 138
    }, {
      "referenceID" : 4,
      "context" : "We describe in this section the geometric politician which is based on ideas developed in Bubeck et al. [2015]. A key observation in the latter paper is that if f is a α-strongly convex function minimized at x∗ then one has for any x, ∥∥∥∥x∗ − x− 1 α ∥∥∥∥2 ≤ ‖∇f(x)‖ α2 − 2 α (f(x)− f(x∗)) .",
      "startOffset" : 90,
      "endOffset" : 111
    }, {
      "referenceID" : 9,
      "context" : "In particular if the next query point yk+1 is the center of gravity of Rk then we have that the volume of Rk+1 is at most 1 − 1/e times the volume of Rk (see Grünbaum [1960]), thus leading to an exponential convergence rate.",
      "startOffset" : 158,
      "endOffset" : 174
    }, {
      "referenceID" : 14,
      "context" : "The volumetric barrier for a polytope was introduced in Vaidya [1996] to construct an algorithm with both the oracle complexity of the center of gravity method and the computational complexity of the ellipsoid method (see [Section 2.",
      "startOffset" : 56,
      "endOffset" : 70
    }, {
      "referenceID" : 4,
      "context" : "3, Bubeck [2015]] for more details and Lee et al.",
      "startOffset" : 3,
      "endOffset" : 17
    }, {
      "referenceID" : 4,
      "context" : "3, Bubeck [2015]] for more details and Lee et al. [2015] for",
      "startOffset" : 3,
      "endOffset" : 57
    }, {
      "referenceID" : 0,
      "context" : "It is shown in Anstreicher [2004] that vR is a self-concordant barrier which means that the center can be updated (when a new ball is added to R) via few iterations of Newton’s method.",
      "startOffset" : 15,
      "endOffset" : 34
    }, {
      "referenceID" : 0,
      "context" : "It is shown in Anstreicher [2004] that vR is a self-concordant barrier which means that the center can be updated (when a new ball is added to R) via few iterations of Newton’s method. Often in practice, it takes less than 5 iterations to update the minimizer of a self-concordant barrier Goffin and Vial [1999], Bahn et al.",
      "startOffset" : 15,
      "endOffset" : 312
    }, {
      "referenceID" : 0,
      "context" : "It is shown in Anstreicher [2004] that vR is a self-concordant barrier which means that the center can be updated (when a new ball is added to R) via few iterations of Newton’s method. Often in practice, it takes less than 5 iterations to update the minimizer of a self-concordant barrier Goffin and Vial [1999], Bahn et al. [1995] when we add a new constraint.",
      "startOffset" : 15,
      "endOffset" : 332
    }, {
      "referenceID" : 15,
      "context" : "Although the analytic center is a more popular choice for “geometrical” algorithms, we choose volumetric center here because it gives a better convergence rate Vaidya [1996], Atkinson and Vaidya [1995] and the extra cost ψ(k) is negligible to the cost of updating QR decomposition nk.",
      "startOffset" : 160,
      "endOffset" : 174
    }, {
      "referenceID" : 1,
      "context" : "Although the analytic center is a more popular choice for “geometrical” algorithms, we choose volumetric center here because it gives a better convergence rate Vaidya [1996], Atkinson and Vaidya [1995] and the extra cost ψ(k) is negligible to the cost of updating QR decomposition nk.",
      "startOffset" : 175,
      "endOffset" : 202
    }, {
      "referenceID" : 10,
      "context" : "In this section, we compare the geometric politician against two libraries for first order methods, minFunc Schmidt [2012] and TFOCS Becker et al.",
      "startOffset" : 108,
      "endOffset" : 123
    }, {
      "referenceID" : 3,
      "context" : "In this section, we compare the geometric politician against two libraries for first order methods, minFunc Schmidt [2012] and TFOCS Becker et al. [2011]. Both are popular MATLAB libraries for minimizing general smooth convex functions.",
      "startOffset" : 133,
      "endOffset" : 154
    }, {
      "referenceID" : 3,
      "context" : "In this section, we compare the geometric politician against two libraries for first order methods, minFunc Schmidt [2012] and TFOCS Becker et al. [2011]. Both are popular MATLAB libraries for minimizing general smooth convex functions. Since the focus of this paper is all about how to find a good step direction using a politician, we use the exact line search (up to machine accuracy) whenever possible. This eliminates the effect of different line searches and reduces the number of algorithms we need to test. TFOCS is the only algorithm we use which does not use line search because they do not provide such option. To compensate on the unfairness to TFOCS, we note that the algorithm TFOCS uses is accelerated gradient descent and hence we implement the GonzagaKaras’s accelerated gradient descent Gonzaga and Karas [2013], which is specifically designed to be used with exact line search.",
      "startOffset" : 133,
      "endOffset" : 830
    }, {
      "referenceID" : 3,
      "context" : "In this section, we compare the geometric politician against two libraries for first order methods, minFunc Schmidt [2012] and TFOCS Becker et al. [2011]. Both are popular MATLAB libraries for minimizing general smooth convex functions. Since the focus of this paper is all about how to find a good step direction using a politician, we use the exact line search (up to machine accuracy) whenever possible. This eliminates the effect of different line searches and reduces the number of algorithms we need to test. TFOCS is the only algorithm we use which does not use line search because they do not provide such option. To compensate on the unfairness to TFOCS, we note that the algorithm TFOCS uses is accelerated gradient descent and hence we implement the GonzagaKaras’s accelerated gradient descent Gonzaga and Karas [2013], which is specifically designed to be used with exact line search. Another reason we pick this variant of accelerated gradient descent is because we found it to be the fastest variant of accelerated gradient descent (excluding the geometric descent of Bubeck et al. [2015]) for our tested data (Gonzaga and Karas also observed that on their own dataset).",
      "startOffset" : 133,
      "endOffset" : 1103
    }, {
      "referenceID" : 3,
      "context" : "In this section, we compare the geometric politician against two libraries for first order methods, minFunc Schmidt [2012] and TFOCS Becker et al. [2011]. Both are popular MATLAB libraries for minimizing general smooth convex functions. Since the focus of this paper is all about how to find a good step direction using a politician, we use the exact line search (up to machine accuracy) whenever possible. This eliminates the effect of different line searches and reduces the number of algorithms we need to test. TFOCS is the only algorithm we use which does not use line search because they do not provide such option. To compensate on the unfairness to TFOCS, we note that the algorithm TFOCS uses is accelerated gradient descent and hence we implement the GonzagaKaras’s accelerated gradient descent Gonzaga and Karas [2013], which is specifically designed to be used with exact line search. Another reason we pick this variant of accelerated gradient descent is because we found it to be the fastest variant of accelerated gradient descent (excluding the geometric descent of Bubeck et al. [2015]) for our tested data (Gonzaga and Karas also observed that on their own dataset). The algorithms to be tested are the following: • [SD] Steepest descent algorithm in minFunc. • [Nes] Accelerated gradient descent, General Scheme 2.2.6 in Nesterov [2004]. • [TFOCS] Accelerated gradient descent in TFOCS.",
      "startOffset" : 133,
      "endOffset" : 1356
    }, {
      "referenceID" : 3,
      "context" : "In this section, we compare the geometric politician against two libraries for first order methods, minFunc Schmidt [2012] and TFOCS Becker et al. [2011]. Both are popular MATLAB libraries for minimizing general smooth convex functions. Since the focus of this paper is all about how to find a good step direction using a politician, we use the exact line search (up to machine accuracy) whenever possible. This eliminates the effect of different line searches and reduces the number of algorithms we need to test. TFOCS is the only algorithm we use which does not use line search because they do not provide such option. To compensate on the unfairness to TFOCS, we note that the algorithm TFOCS uses is accelerated gradient descent and hence we implement the GonzagaKaras’s accelerated gradient descent Gonzaga and Karas [2013], which is specifically designed to be used with exact line search. Another reason we pick this variant of accelerated gradient descent is because we found it to be the fastest variant of accelerated gradient descent (excluding the geometric descent of Bubeck et al. [2015]) for our tested data (Gonzaga and Karas also observed that on their own dataset). The algorithms to be tested are the following: • [SD] Steepest descent algorithm in minFunc. • [Nes] Accelerated gradient descent, General Scheme 2.2.6 in Nesterov [2004]. • [TFOCS] Accelerated gradient descent in TFOCS. • [GK] Gonzaga-Karas’s of Accelerated Gradient Descent (Sec 5.1). • [Geo] Geometric Descent Bubeck et al. [2015]. • [CG] Non-Linear Conjugate Gradient in minFunc.",
      "startOffset" : 133,
      "endOffset" : 1519
    }, {
      "referenceID" : 8,
      "context" : "The second algorithm we implement is the accelerated gradient descent proposed by Gonzaga and Karas Gonzaga and Karas [2013]. This algorithm uses line search to learn the the smoothness parameter and strong convexity parameter, see Algorithm 3.",
      "startOffset" : 82,
      "endOffset" : 125
    }, {
      "referenceID" : 14,
      "context" : "3 Variant of Nesterov’s Worst Function Nesterov [2004] introduced the function",
      "startOffset" : 13,
      "endOffset" : 55
    }, {
      "referenceID" : 6,
      "context" : "4 Binary regression with smoothed hinge loss We consider the binary classification problem on the datasets from Chang and Lin [2011]. The problem is to minimize the regularized empirical risk:",
      "startOffset" : 112,
      "endOffset" : 133
    }, {
      "referenceID" : 10,
      "context" : "We note that for this problem it would be natural to compare ourselves with SGD (stochastic gradient descent) or more refined stochastic algorithms such as SAG Le Roux et al. [2012] or SVRG Johnson and Zhang [2013].",
      "startOffset" : 163,
      "endOffset" : 182
    }, {
      "referenceID" : 10,
      "context" : "[2012] or SVRG Johnson and Zhang [2013]. However since the focus of this paper is on general black-box optimization we stick to comparing only to general methods.",
      "startOffset" : 15,
      "endOffset" : 40
    }, {
      "referenceID" : 11,
      "context" : "Note however that it is well-known that the volumetric center is usually more difficult to analyze, Vaidya [1996], Atkinson and Vaidya [1995].",
      "startOffset" : 100,
      "endOffset" : 114
    }, {
      "referenceID" : 1,
      "context" : "Note however that it is well-known that the volumetric center is usually more difficult to analyze, Vaidya [1996], Atkinson and Vaidya [1995]. • The extraneous log(κ) comes from the number of potential restart when we decrease α.",
      "startOffset" : 115,
      "endOffset" : 142
    }, {
      "referenceID" : 1,
      "context" : "Note however that it is well-known that the volumetric center is usually more difficult to analyze, Vaidya [1996], Atkinson and Vaidya [1995]. • The extraneous log(κ) comes from the number of potential restart when we decrease α. Is there a better way to learn α that would not incur this additional logarithmic term? • Bubeck et al. [2015] shows essentially that one can combine the ellipsoid method with gradient descent to achieve the optimal 1− √ 1/κ rate.",
      "startOffset" : 115,
      "endOffset" : 341
    }, {
      "referenceID" : 1,
      "context" : "Note however that it is well-known that the volumetric center is usually more difficult to analyze, Vaidya [1996], Atkinson and Vaidya [1995]. • The extraneous log(κ) comes from the number of potential restart when we decrease α. Is there a better way to learn α that would not incur this additional logarithmic term? • Bubeck et al. [2015] shows essentially that one can combine the ellipsoid method with gradient descent to achieve the optimal 1− √ 1/κ rate. Can we prove such a result for SD+? The geometric politician could be refined in many ways. Here are two simple questions that we leave for future work: • One can think that gradient descent stores 1 gradient information, accelerated gradient descent stores 2 gradient information, and our method stores all past gradient information. We believe that neither 1, 2 nor all is the correct answer. Instead, the algorithm should dynamically decide the number of gradients to store based on the size of its memory, the cost of computing gradients, and the information each gradient reveals. • Is there a stochastic version of our algorithm? How well would such a method compare with state of the art stochastic algorithms such as SAG Le Roux et al. [2012] and SVRG Johnson and Zhang [2013]?",
      "startOffset" : 115,
      "endOffset" : 1212
    }, {
      "referenceID" : 1,
      "context" : "Note however that it is well-known that the volumetric center is usually more difficult to analyze, Vaidya [1996], Atkinson and Vaidya [1995]. • The extraneous log(κ) comes from the number of potential restart when we decrease α. Is there a better way to learn α that would not incur this additional logarithmic term? • Bubeck et al. [2015] shows essentially that one can combine the ellipsoid method with gradient descent to achieve the optimal 1− √ 1/κ rate. Can we prove such a result for SD+? The geometric politician could be refined in many ways. Here are two simple questions that we leave for future work: • One can think that gradient descent stores 1 gradient information, accelerated gradient descent stores 2 gradient information, and our method stores all past gradient information. We believe that neither 1, 2 nor all is the correct answer. Instead, the algorithm should dynamically decide the number of gradients to store based on the size of its memory, the cost of computing gradients, and the information each gradient reveals. • Is there a stochastic version of our algorithm? How well would such a method compare with state of the art stochastic algorithms such as SAG Le Roux et al. [2012] and SVRG Johnson and Zhang [2013]?",
      "startOffset" : 115,
      "endOffset" : 1246
    }, {
      "referenceID" : 14,
      "context" : "6 in Nesterov [2004] shows that",
      "startOffset" : 5,
      "endOffset" : 21
    } ],
    "year" : 2016,
    "abstractText" : "We propose a new framework for black-box convex optimization which is well-suited for situations where gradient computations are expensive. We derive a new method for this framework which leverages several concepts from convex optimization, from standard first-order methods (e.g. gradient descent or quasi-Newton methods) to analytical centers (i.e. minimizers of self-concordant barriers). We demonstrate empirically that our new technique compares favorably with state of the art algorithms (such as BFGS).",
    "creator" : "LaTeX with hyperref package"
  }
}