{
  "name" : "1603.03515.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Dimension Coupling: Optimal Active Learning of Halfspaces via Query Synthesis",
    "authors" : [ "Lin Chen", "Hamed Hassani", "Amin Karbasi" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 3.\n03 51\n5v 1\n[ cs\n.A I]\nWe develop a general framework, called dimension coupling (DC), that 1) reduces a d-dimensional learning problem to d − 1 low-dimensional sub-problems, 2) solves each sub-problem efficiently, and 3) appropriately aggregates the results and outputs a linear classifier. We consider the three most common scenarios in the literature: idealized noise-free, independent noise realizations, and agnostic settings. We show that the DC framework avoids the curse of dimensionality: its computational complexity in all three cases scales linearly with the dimension. Moreover, in the noiseless and noisy cases, we show that the query complexity of DC is near optimal (within a constant factor of the optimum algorithm). We also develop an agnostic variant of DC for which we provide strong theoretical guarantees. To further support our theoretical analysis, we compare the performance of DC with the existing work in all three settings. We observe that DC consistently outperforms the prior arts in terms of query complexity while often running orders of magnitude faster."
    }, {
      "heading" : "Introduction",
      "text" : "In contrast to the passive model of supervised learning, where all the labels are provided without any interactions with the learning mechanism, the key insight in active learning is that the learning algorithm can perform significantly better if it is allowed to choose which data points to label. This approach has found far-reaching applications, including the classical problems in AI (e.g., classification [17], information retrieval [16], speech recognition [8]) as well as the modern ones (e.g., interactive recommender systems [10], optimal decision making [9]).\nIn statistical learning theory, one assumes that a set of hypotheses H along with a set of unlabeled data points X are given, where each data point x ∈ X is drawn i.i.d. from some distribution D. Classical probably approximately correct (PAC) bounds then yield the sample complexity (i.e., the number of required i.i.d. examples) from D to output a hypothesis h ∈ H that will have estimation error at most ǫ with probability at least 1−δ, for some fixed ǫ, δ > 0. Here, the estimation error is defined as error(h) = Prx∼D[h(x) ≠ h∗(x)], where h∗ is the unknown true hypothesis. In the realizable case of learning a halfspace, i.e., when h∗ ∈ Rd perfectly separates the data points into positive and negative labels, it is known that with Õ(d/ǫ)1 i.i.d. samples one can find a linear separator with an estimation error ǫ. In contrast, a simple counting argument based on sphere packing shows that any algorithm needs Ω(d log(1/ǫ)) examples to achieve an estimation error of ǫ [6].\nIf one is not careful, active learning may require more samples than passive learning to achieve the same estimation error. One setting that is guaranteed to perform at least as well as passive learning is pool-based active learning [12]: a set of unlabeled examples are drawn i.i.d. where instead of obtaining all labels at once, the learning algorithm sequentially decides which labels to request and which ones to discard. The key challenge is to develop an algorithm that requests informative labels from the pool in such a way that the remaining labels can be inferred as quickly as possible. A principled way is to define a version space V containing all hypotheses consistent with the labels obtained so far and try to shrink it significantly by requesting new labels from the pool. An effective but computationally expensive method is the halving algorithm, also referred to as generalized binary search (GBS), where at each iteration the next example to label is chosen in such a way that it approximately cuts the version space by one half. The new version space is constructed and the process is repeated until the estimation error is less than ǫ. In many cases, computing the version space is computationally prohibitive. Dasgupta [6], in the idealized case that the labels are noise-free and there exists a realizable linear separator, showed that one requires Õ(d log2(1/ǫ)) labels, an exponential improvement over Õ(d/ǫ). Unfortunately,the algorithm achieving this bound is generally intractable. Perhaps the most common query methods that approximate the idealized halving algorithm are uncertainty sampling [12] and queryby-committee (QBC) [7]. Freund et al. [7] showed that QBC requests Õ(d log(1/ǫ)) labels, but comes at the price of prohibitive computational cost in each iteration. Similarly, Balcan et al. [4] showed that uncertainty sampling also achieves an exponential reduction in sample complexity, requiring Õ(d2 log(1/ǫ)) labels. Unfortunately, most approximation methods are only guaranteed to work if the pool size grows exponentially fast in each iteration. Hence, one needs to always store a large amount of data in addition to computing a complex version space.\nAn attractive alternative to the pool-based framework is query synthesis [3]: a learner can request for any unlabeled data instance from the input space, including queries that the learner synthesizes from scratch. This way the pool size limitation is entirely eliminated. In many recent applications, ranging from automated science [11], to robotics [5], and to adversarial reverse engineering [13], query synthesis is the appropriate model. For instance, in security-sensitive applications (e.g., spam filters\n1We use the Õ notation to ignore terms that are logarithmic or dependent on δ.\nand intrusion detection systems) that routinely use machine learning tools, a growing concern is the ability of adversarial attacks to identify the blind spots of the learning algorithms. Concretely, classifiers are commonly deployed to detect miscreant activities. However, they are attacked by adversaries who generate exploratory queries to elicit information that in return allows them to evade detection [14]. In this work, we show how an adversary can use active learning methods by making synthetically de novo queries and thus identify the linear separator used for classification.\nWe should emphasize that in active learning via synthesized queries the learning algorithm can query the label of any points (irrespective of the underlying distribution D) in order to explore the hypothesis space. However, for evaluating the performance of the algorithm in terms of the estimation error, one may use the distribution D. This is quite different from pool-based framework where queries should be among the data points drawn i.i.d. from the underlying distribution D.\nThere is little known about the theoretical performance of actively learning a linear classifier via query synthesis. The closest work to our efforts is [2] where they propose a heuristic algorithm that approximates the version space by a convex body with promising empirical results in the noise-free setting. Their method is not appropriate for high dimensional data, as its computational complexity scales cubically with the dimension. Moreover, their algorithm fails in the presence of noise.\nIn this paper, we develop a framework, called Dimension Coupling (DC), with the following guarantees. In the noiseless setting, we show that its computational complexity is Õ(d log 1 ǫ̃ ) and its query complexity is Õ(d log 1 ǫ̃ ). Similarly, in the noisy\nsetting, we show that the computational complexity of DC is Õ(d(log 1 ǫ̃ + log 1 δ̃ )2) and\nits query complexity is Õ(d(log 1 ǫ̃ + log 1 δ̃ )). Note that in both settings the computational complexity scales linearly with the dimension. Moreover, the query complexity in both settings is near-optimal. Finally, we generalize our results to the agnostic case. Our empirical experiments demonstrate that DC runs orders of magnitude faster than the existing methods."
    }, {
      "heading" : "Problem Formulation",
      "text" : "Our objective is to estimate an unknown halfspace H∗ = {x ∈ Rd ∶ ⟨h∗, x⟩ > 0}, using as few queries as possible. Here, ⟨⋅, ⋅⟩ is the standard inner product of the Euclidean space (also ∥ ⋅ ∥ denotes the Euclidean norm), h∗ is some (hidden) unit vector that we want to estimate, and a generic query is of the form sign(⟨h∗, x⟩) where x is selected in Rd. Let us emphasize here that the only information we obtain from a query is the sign of the inner product and not the value. E.g., the queries of the form sign(⟨h∗, ei⟩), where ei is the ith standard basis vector, will only reveal the sign of the ith component of h∗ (and nothing further about its value). In the noiseless setting, we observe the true outcome of the query, i.e. sign ⟨h∗, x⟩ ∈{1,−1}. In the noisy setting, the outcome is a flipped version of the true sign with independent flip probability ρ. That is, denoting the outcome by Y we have Y ∈ {−1,1} and Pr[Y ≠ sign ⟨h∗, x⟩] ∶= ρ < 1/2.\nSince the length of the selected vector x will not affect the outcome of the query, we only query the points on the unit sphere Sd−1 = {x ∈ Rd ∶ ∥x∥ = 1}. Hence, we term\nX = Sd−1 as the query space. All possible unit vectors also reside on the unit sphere Sd−1. Therefore, the initial version space, denoted by H, is also Sd−1.\nAs aforementioned, to evaluate the performance of halfspace learning algorithms, we assume that unlabeled data points are drawn from the distribution D with a continuous probability density function fD. The estimation error is defined as error(h) = Prx∼D[h(x) ≠ h∗(x)] = ∫ 1{h(x) ≠ h∗(x)}fD(x)dx ≤ 4MD arcsin(∥h − h∗∥/2), where MD = maxx fD(x). To make sure the estimation error error(h) ≤ ǫ , it suffices to ensure ∥h − h∗∥ < ǫD, where ǫD = 2 sin[ǫ/(4MD)]; e.g., when D is uniform, ǫD = 2 sin(πǫ/2). Therefore, hereinafter we only discuss how to guarantee∥h − h∗∥ < ǫD with high probability (say, at least 1 − δ). We report all the results in terms of ∥h − h∗∥ but it is easy to convert them to the estimation error. Thus, given ǫ, δ > 0, we seek an algorithm that (i) adaptively selects vectors x1, x2,⋯, (ii) observes the (noisy) responses to each query sign⟨h∗, xi⟩, (iii) and outputs, using as few queries as possible, an estimate ĥ of h∗ such that ∥ĥ − h∗∥ < ǫ with probability at least 1 − δ."
    }, {
      "heading" : "Dimension Coupling Based Framework",
      "text" : "Suppose that h∗ has the form h∗ = ∑di=1 ciei, where {ei}di=1 is an arbitrarily chosen orthonormal basis for Rd. We assume w.l.o.g. that h∗ is normalised (i.e., ∑di=1 c2i = 1). Our objective is then to learn the coefficients {ci}di=1 within a given precision by using the (noisy) responses to the selected sign queries. The key insight here is that this task can be partitioned in a divide-and-conquer fashion into many smaller tasks, each involving a few dimensions. The final answer (the values of {ci}di=1) will then be obtained by aggregating the answers of these subproblems.\nExample 1. Assume h∗ = c1e1 + c2e2 + c3e3 + c4e4, where ei’s are the standard basis vectors for R4. Define\nê1 = c1e1 + c2e2√\nc21 + c 2 2\n, ê2 = c3e3 + c4e4√\nc23 + c 2 4\nNote here that ê1 is the (normalised) orthogonal projection of h∗ onto span{e1, e2} and ê2 is the (normalised) orthogonal projection of h∗ onto span{e3, e4}. Consider the following procedure to learn h∗: first find out what ê1 and ê2 are, and then use the relation h∗ = √ c21 + c 2 2ê1 + √ c23 + c 2 4ê2 to find h\n∗ based on the orthonormal vectors ê1, ê2. By this procedure, the original “four-dimensional” problem has been broken into three “two-dimensional” problems.\nFor general d, the idea is similar: We break the problem into at most d − 1 “twodimensional” problems that each can be solved efficiently. More formally, let us assume that we have an algorithm, called DC2 (e1, e2, ǫ, δ), that takes as input two orthonormal vectors e1, e2 and outputs with probability at least 1 − δ a vector ê with the following three properties:\nê ∈ span{e1, e2}, ∥ê∥ = 1, ∥ê − ⟨h∗,e1⟩e1+⟨h∗,e2⟩e2∥⟨h∗,e1⟩e1+⟨h∗,e2⟩e2∥∥ < ǫ. In other words, the unit vector ê is within a distance ǫ to the (normalised) projection of h∗ onto the subspace span{e1, e2}. In the next section, we will explain in detail how\nto design an optimal candidate for DC2 that uses (noisy) responses to queries of the form sign ⟨x,h∗⟩. In the current section, we explain a framework DC that estimates h∗ using at most d − 1 calls to DC2 (a formal description is given in Algorithm 1). Consider the decomposition h∗ = ∑di=1 ciei. For simplicity assume that d is an even number. We can write\nh∗ = d\n∑ i=1 ciei = d/2 ∑ j=1 ĉj c2j−1e2j−1 + c2je2j√\nc22j−1 + c 2 2j\n, (1)\nwhere in the last step we have taken ĉj ≜ √ c22j−1 + c 2 2j . Now, note that\nc2j−1e2j−1+c2je2j√ c2 2j−1 +c2 2j\nis the (normalised) orthogonal projection of h∗ onto span{e2j−1, e2j}. Hence, by using DC2 (e2j−1, e2j , ǫ, δ) we can obtain, with probability at least 1− δ, a good approximation êj (within a distance ǫ) of this projection. Therefore, for small enough ǫ we have h∗ ≈ ∑d/2j=1 ĉj êj . Since h ∗ is now expressed (approximately) in terms of d/2 known orthonormal vectors {êj}d/2j=1, we have effectively reduced the dimensionality of problem from d to d/2. The idea is then to repeat the same procedure as in (1) to the newly obtained representation of h∗. Hence, by repeating this procedure at most log2 d times we will reach a vector which is the final approximation of h∗.\nAlgorithm 1 Dimension Coupling (DC) Input: an orthonormal basis E = {e1, e2, . . . , ed} of Rd. while d > 2\n1. for j = 1 to ⌊d/2⌋ Replace the two vectors e2j−1, e2j in E with the vector DC2 (e2j−1, e2j , ǫ, δ). end for\n2. Set d ← ⌈d/2⌉ . end while return DC2 (e1, e2, ǫ, δ). Theorem 2. For DC (outlined in Algorithm 1) we have:\n1. DC will call the two-dimensional subroutine DC2 at most d − 1 times.\n2. Provided that the output of DC2 is with probability 1 − δ within distance ǫ of the true value and ǫ ≤ 1\n6d , DC ensures an estimation error of at most 6ǫd with\nprobability at least 1 − δd.\nWe defer the proof of all theorems to the appendix. As a result of Theorem 2, if we desire the framework DC to estimate h∗ within distance ǫ̃ and with probability at least 1− δ̃, then it is enough to fix the corresponding parameters of DC2 to ǫ = ǫ̃\n6d and δ = δ̃ d .\nDC2: Solving in 2 Dimensions\nBefore illustrating the algorithm DC2, let us review some notation. Given two orthonormal vectors e1, e2 we denote the (normalised) projection of h∗ onto span{e1, e2} by h⊥, i.e.,\nh⊥ = ⟨h∗, e1⟩ e1 + ⟨h∗, e2⟩ e2∥⟨h∗, e1⟩ e1 + ⟨h∗, e2⟩ e2∥2 . (2)\nThe objective of DC2 (e1, e2, ǫ, δ) is to find a unit vector ê ∈ span{e1, e2} such that∥ê − h⊥∥ < ǫ. In fact, we require the latter to hold with probability at least 1 − δ. Any unit vector inside span{e1, e2}, e.g., h⊥, can equivalently be represented as a\npair (c1, c2) on the two-dimensional unit circle S1 (e.g., h⊥ = c1e1+ c2e2 and c21 + c22 = 1). To simplify notation, we use a point (c1, c2) ∈ S1 and its corresponding unit vector c1e1+c2e2 interchangeably. In this setting, it is easy to see that for any x ∈ span{e1, e2} sign ⟨x,h∗⟩ = sign ⟨x,h⊥⟩ . (3) We take a Bayesian approach. In the beginning, when no queries have been performed, DC2 assumes no prior information about the vector h⊥. Therefore, it takes the uniform distribution on S1 (with pdf p0(h) = 12π ) as its prior belief about h⊥. After performing each query, the posterior (belief) about h⊥ will be updated according to the observation. We let pm(h) denote the (pdf of the) posterior after performing the first m queries. In this manner, DC2 runs in total of Tǫ,δ rounds, where in each round a specific query is selected and posed to the oracle. The number Tǫ,δ will be specified later (see Theorems 3 and 4). Upon the completion of round Tǫ,δ, the algorithm returns as its final output a vector ê ∈ S1 that maximises the posterior pdf pTǫ,δ(h). If there are multiple such maximisers, it picks one arbitrarily. We now proceed with a detailed description of DC2 (a formal description is provided in Algorithm 2). We first consider the simpler noise-free case and the other settings will follow afterwards.\nNoise-Free Case: We explain DC2 (outlined in Algorithm 2) with the help of a running example given in Figure 1. As we will see, after each round of DC2 the possible region that h⊥ can belong to will be “halved”.\nWe first note that as the initial distribution p0 is assumed to be the uniform distribution on S1, the vector x1 (see step 2-(a) of Algorithm 2) can indeed be any point on the unit circle S1. Thus, DC2 chooses x1 arbitrarily on S1. By (3), using the query sign ⟨x1, h∗⟩ will also give us the value of sign ⟨x1, h⊥⟩. Depending on this value, it is easy to verify that only half of S1 can possibly contain h⊥ (see Figure 1). Let us denote this region by R1. Hence, the probability distribution p1(h) (which is our current belief about h⊥) is updated as follows: for h ∉ R1 we have that p1(h) = 0, and as all the points inside the half-circle R1 are equiprobable, we have for h ∈ R1 that p1(h) = 1/π. In other words, at time m = 0 the vector h⊥ could have been anywhere on the unit circle, but, after round m = 1 it can only belong to the half-circle R1. Thus, after the first round, DC2 “halves” the admissible region of h⊥. Continuing in this theme, it is not hard to verify that (see Figure 1) at round m = 2 the value of p2(h) is non-zero and uniform only on a region R2 which is a quarter-circle. In an inductive manner, letting Rm−1 denote the admissible region (sector) at round m − 1 (see Figure 1) and assuming that pm−1 is only non-zero and uniform on the sector Rm−1, then xm at round m is\nAlgorithm 2 DC2\nInput: orthonormal vectors e1, e2, estimation error at most ǫ, success probability at least 1 − δ.\n1. Set p0(h) to be uniform, i.e., ∀h ∈ S1 ∶ p0(h) = 1/2π. 2. for m = 1 to Tǫ,δ\n(a) find a vector xm ∈ S1 which is a solution to the following equation: ∫S1 sign ⟨x,h⟩ pm−1(h)dh = 0. If there are multiple solutions, choose one arbitrarily. (b) ask from the oracle the value of sign ⟨xm, h∗⟩. (c) based on the response obtained from the oracle, update the distribution\npm−1(h) to pm(h). end for\n3. return ê = argmaxh∈S1 pTǫ,δ(h).\nprecisely the vector that is orthogonal to the midpoint of the sector Rm−1. Therefore, after observing the value of sign ⟨xm, h∗⟩, the admissible region Rm is the better half of Rm−1 that is compatible with the observation (i.e., it contains h⊥). Also, Rm is again a sector and pm will be uniform on Rm and zero outside. It is also easy to see that the circular angle for the sector Rm is π2m . The following statement is now immediate. Theorem 3. Consider DC in the absence of noise (ρ = 0). If we let Tǫ,δ = ⌈log2 πǫ ⌉, then it outputs a vector that is within a distance ǫ of h⊥.\nA few comments are in order: The above guarantee for DC2 holds with probability one and thus the parameter δ is irrelevant in the noiseless setting. Furthermore, during each round of DC2, the distribution pm can be represented by only two numbers (the starting and ending points of the sector Rm), and the vector xm can be computed efficiently (it is the orthogonal vector to the midpoint of Rm). Therefore, assuming one unit of complexity for performing the queries, DC2 can be implemented with complexity O(Tǫ,δ). Finally, by using Theorem 2, we conclude that DC requires Õ(d log 1ǫ ) queries with computational complexity Õ(d log 1 ǫ ). Noisy Case: In general, DC2 follows a similar procedure as in the noiseless case except that the distributions pm does not look as simple. However, as we now discuss, these distributions can still be stored efficiently and as a result the vector xm can be computed efficiently. Indeed, (the pdf of) pm is piecewise constant on the unit circle (see Figure 2). More precisely, at any round m, there are at most 2m points u1, u2,⋯, u2m that are ordered clock-wise on the unit-circle and pm is constant when restricted to each of the sectors [ui, ui+1). At round m + 1, in order to find xm+1 (see step 2-(a) of Algorithm 2), DC2 first finds a line that passes through the centre of S1 and cuts S1 into two “halves” which have the same measure with respect to pm. Note that finding such a line can be done in O(m) steps because pm has the piecewise constant property. Once such a line is found, it is then easy to see that xm+1 can be any of the two points orthogonal to the line. As a result, DC2 at round m + 1 can find xm+1 in O(m) operations. We denote the half-circle containing xm+1 by R+ and the other half by R−. We refer to Figure 2 for a schematic illustration. Once a noisy response to the query sign ⟨xm+1, h∗⟩ is obtained, the probability distribution pm will be updated to pm+1 in the following way. First, consider the event that the outcome of sign ⟨xm+1, h∗⟩ is +1. We have pm(sign ⟨xm+1, h∗⟩ = +1) = (1−ρ) pm(R+)+ρ pm(R−) = 1/2, and similarly pm(sign ⟨xm+1, h∗⟩ = +1) = 1/2. Therefore, by Bayes theorem we obtain the following update rules for pm+1. If we observe that sign ⟨xm+1, h∗⟩ = +1, then for h ∈ R+ we have pm+1(h) = 2(1−ρ)pm(h) and for h ∈ R− we have pm+1(h) = (2ρ)pm(h). Also, if we observe that sign ⟨xm+1, h∗⟩ = −1, then for h ∈ R+ ∶ pm+1(h) = (2ρ)pm(h) and for h ∈ R− ∶ pm+1(h) = 2(1 − ρ)pm(h). (note that the factor of 2 here is due to the normalization.) It is easy to verify that pm+1 is also a piecewise constant distribution (now on 2(m + 1) sectors; see Fig. 2). Theorem 4. In the noisy setting (with independent flip probability ρ), having\nTǫ,δ ≥M +max{T0, T1, T2, T3} = O(log 1 ǫ + log 1 δ ) (4)\nis sufficient to guarantee that DC2 outputs with probability at least 1 − δ a vector that is within a distance ǫ of h⊥. Here, we have M = ⌈ 2 log 2δ− log(4ρ(1−ρ)) ⌉, T0 = 8 log 2δlog(2(1−ρ)) , T1 = 8 log 1\n8πǫ log(2(1−ρ)) , T2 = 8 log(2(1−ρ)) (log(2M) + log( 4log(2(1−ρ)))) andT3 = 24ρ log2 1−ρρlog2(2(1−ρ)) (log(M) + log( 4δ )). Theorem 2 indicates that DC requires Õ(d(log 1\nǫ + log 1 δ )) queries. Also, as dis-\ncussed above, the computational complexity of DC2 is O(T 2ǫ,δ). Hence, DC has computational complexity Õ(d(log 1\nǫ + log 1 δ )2).\nAgnostic Case: A common approach used in the agnostic setting is the empirical risk minimization (ERM), which generates queries by independently sampling from the marginal distribution of X , i.e., PX , and then selects a unit vector that minimizes the number of errors made on these n queries. We follow a similar approach as in [15]. Suppose that we are given a query budget of n. We allocate n/3 queries to DC and let h1 denote the unit vector selected by DC. Then we allocate n/3 queries to ERM and let h2 denote the unit vector proposed by ERM using its n/3 queries. Consider the region ∆ that h1 and h2 disagree on, i.e., ∆ = {x ∈ Sd−1 ∶ h1(x) ≠ h2(x)}. Let P∆ be the restriction of the probability measure PX on ∆. Here we sample the remaining n/3 queries from ∆ according to P∆. We write R̂∆(hi) for the average number of errors made by hi on the sampled n/3 queries. Finally, we set R∆(hi) = E[R̂∆(hi)]. The algorithm will output ĥ = argminh∈{h1,h2} R̂∆(h) as the final result. Theorem 5. Using the above procedure we have the following bounded error proba-\nbility in expectation E[R(ĥ)] ≤ min{E[R(h1),E[R(h2)]} + 2√ 3ne , where n is the number of queries and e is the base of the natural logarithm."
    }, {
      "heading" : "Empirical Results",
      "text" : "In this section, we extensively evaluate the performance of DC against the following baselines:\n• RANDOM-SAMPLING: Queries are generated by sampling uniformly at random from the unit sphere Sd−1.\n• UNCERTAINTY-SAMPLING: Queries are sampled uniformly at random from the orthogonal complement of w, where w is the vector learned by linear SVM.\n• QUERY-BY-BAGGING: The bag size is set to 20 and 1000 queries are generated at each iteration. The query with the largest disagreement is picked [1].\n• SPECTRAL: The version space is approximated by the largest ellipsoid consistent with all previous query-label pairs. Then, at each iteration a query is selected to approximately halve the ellipsoid [2].\n• REPETITIVE-DC: In the noisy setting, one easy way to apply DC is to query each point R times and use the majority rule to determine its label.\nOur metrics to compare different algorithms are: a) estimation error, b) query complexity, and c) execution time. In particular, as we increase the number of queries we\nmeasure the average estimation errors and execution times for all the baselines (with 90% confidence intervals). By nature, in active learning via query synthesis, all data points and queries are generated synthetically. For all the baselines, we used the fastest available implementations in MATLAB.\nNoise-free setting: Figures 3a, 3b and 3c (with dimension d = 25,50,100, respectively) show that in terms of estimation error, DC outperforms all other baselines, and significantly outperforms RANDOM-SAMPLING, UNCERTAINTY-SAMPLING and QUERY-BY-BAGGING. Note that the estimation errors are plotted in log-scales. In terms of execution times, we see in Fig. 3d that DC runs three orders of magnitude faster than other baselines. Training an SVM at each iteration for RANDOMSAMPLING, UNCERTAINTY-SAMPLING and QUERY-BY-BAGGING comes with a huge computational cost. Similarly, SPECTRAL requires solving a convex optimization problem at each iteration; thus its performance drastically deteriorates as the dimension increases, which makes it infeasible for many practical problems.\nNoisy setting: We set the noise level to ρ = 0.1 and compare the performance of DC against RANDOM-SAMPLING, UNCERTAINTY-SAMPLING, QUERY-BY-BAGGING, and REPETITIVE-DC (for R = 5). As mentioned in [2], and we have also observed in our experiments, SPECTRAL does not work even for small amounts of noise as it incorrectly shrinks the version space and misses the true linear separator. We see again in Figures 3e and 3f (for d = 25,50) that DC significantly outperforms all other methods in terms of estimation error as we increase the number of queries. Figure 3g shows that DC still runs ∼100 times faster than RANDOM-SAMPLING, UNCERTAINTYSAMPLING, and QUERY-BY-BAGGING. Clearly, DC has a higher computational cost than REPETITIVE-DC, as DC performs a Bayesian update after each query. Finally, as we increase the dimension to d = 1000, RANDOM-SAMPLING, UNCERTAINTYSAMPLING, and QUERY-BY-BAGGING become significantly slower. Hence, in Fig. 3h we only show how the estimation error (for noise levels ρ = 0.01,0.1,0.2) decreases for DC and REPETITIVE-DC with more queries.\nAgnostic setting: We sample a set of size 1000 from the Von Mises–Fisher distribution (the analog of the normal distribution on Sd−1) and compute the empirical error . The noise level at each point is drawn independently from the truncated normal N (0.1,0.5) on [0,0.5]. Fig. 3i shows the error probability of RANDOMSAMPLING, UNCERTAINTY-SAMPLING, QUERY-BY-BAGGING and AGNOSTIC-DC (for d = 25). Both AGNOSTIC-DC and UNCERTAINTY-SAMPLING achieve an error probability ∼0.1 after 700 queries. However, as shown by Theorem 5, AGNOSTIC-DC has a strong theoretical guarantee which, by contrast, other baselines do not have."
    }, {
      "heading" : "Appendix A: Proof of Theorem 2",
      "text" : "At each round of DC, the value of d is replaced by ⌈d 2 ⌉. It is thus not hard to verify\nthat DC runs in ⌊log2 d⌋ rounds until d ≤ 2 and in total there are at most d − 1 usages of DC2. As a result, if the probability of success for DC2 is at least 1 − δ, then by the union bound the probability of success of DC is at least 1 − (d − 1)δ.\nFor the last part of the theorem, we prove a more general statement: Assume that we run DC with an input being an orthonormal set {e1, e2,⋯, ed} where ei, h∗ ∈ RK for some K ≥ d. We prove that DC outputs a vector that is close to the (normalised) orthogonal projection of h∗ into span{e1, e2,⋯, ed}. More precisely, we define\nh⊥ = ∑ d i=1⟨ei, h∗⟩ei∥⟨ei, h∗⟩ei∥ . (5)\nThen, DC runs in log2 d rounds, calls DC 2 d − 1 times, and outputs with probability at\nleast 1 − δd a vector ĥ for which ∥h⊥ − ĥ∥ < 6ǫd. In exactly similar way as discussed above, we can conclude that DC runs in log2 d times and uses DC\n2 d − 1 times. Also, again by the union bound, with probability at least 1 − δd all the outputs of DC2 are a close estimate (within distance ǫ) of their corresponding objective. Thus, by assuming that all the calls of DC2 have been successful (which happens w.p. at least 1 − δd), we use an inductive argument to prove that ∥h⊥ − ĥ∥ < 6ǫd. We use induction on d. For d = 2 the result is clear. We now prove the result when d = k assuming that it holds for all d < k. For simplicity, we assume that k is an even number, i.e, k = 2t (the proof follows very similarly for k being odd). We can then write\nh⊥ = d\n∑ i=1\nciei = t\n∑ j=1\nĉjh ⊥ j , (6)\nwhere ĉj = √ c22j−1 + c 2 2j and h ⊥ j =\nc2j−1ej+c2je2j√ c2 2j−1 +c2 2j . Note that h⊥j = c2j−1ej+c2je2j√ c2 2j−1 +c2 2j is pre-\ncisely the (normalised) orthogonal projection of h∗ (and also h⊥) onto span{e2j−1, e2j}. As we explained in Section , in the first round of DC each vector h⊥j will be replaced by the output of DC2 (e2j−1, e2j , ǫ, δ) which we denote by êj . Let us now define the vector ĥ⊥ as\nh⊥1 = ∑tj=1⟨h⊥, êj⟩êj√ ∑tj=1⟨h⊥, êj⟩2\nIt is easy to verify that ∣∣h⊥1 ∣∣ = 1 as {ê1, ê2,⋯, êt} is an orthonormal set. By the assumption of the induction, the final output of DC, which we denote by ĥ⊥, will be within the distance 6ǫt of ĥ⊥. That is, ∣∣h⊥1 − ĥ⊥∣∣ < 6ǫt. (7) We now prove that ∣∣h⊥ − h⊥1 ∣∣ < 6ǫt. (8)\nFrom (7) and (8) the induction hypothesis will be immediate as we can write ∣∣h⊥ − ĥ⊥∣∣ ≤ ∣∣h⊥ − h⊥1 ∣∣ + ∣∣h⊥1 − ĥ⊥∣∣ < 6ǫt + 6ǫt = 6ǫd. It thus remains to prove (8).\nFirstly, we define β ≜ √ ∑tj=1⟨h⊥, êj⟩2. We have\n∣∣h⊥ − h⊥1 ∣∣ = ∣∣h⊥ − ∑tj=1⟨h⊥, êj⟩êj β\n∣∣ = ∣∣βh⊥ −∑tj=1⟨h⊥, êj⟩êj\nβ ∣∣\n= ∣∣ (β − 1)h⊥ + h⊥ −∑tj=1⟨h⊥, êj⟩êj β\n∣∣ ≤ ∣1 − β\nβ ∣ + ∣∣h⊥ −∑tj=1⟨h⊥, êj⟩êj β ∣∣. (9)\nSecondly, we have\n∣β2 − 1∣ = ∣ t∑ j=1 ⟨h⊥, êj⟩2 − ⟨h⊥, h⊥j ⟩2∣ ≤ t\n∑ j=1 ∣⟨h⊥, êj⟩ − ⟨h⊥, h⊥j ⟩∣∣⟨h⊥, êj⟩ + ⟨h⊥, h⊥j ⟩∣ ≤ t\n∑ j=1 ∣∣h⊥∣∣ ⋅ ∣∣êj − h⊥j ∣∣ ⋅ (∣∣h⊥∣∣ ⋅ ∣∣êj ∣∣ + ∣∣h⊥∣∣ ⋅ ∣∣h⊥j ∣∣) ≤ 2ǫt,\nwhere the last step follows from ∣∣h⊥∣∣ = ∣∣h⊥j ∣∣ = ∣∣êj ∣∣ = 1 and ∣∣êj − h⊥j ∣∣ ≤ ǫ. Hence, by noting the fact that 2ǫt = ǫd ≤ 1\n6 we obtain\nβ ∈ [√1 − 2ǫt,√1 + 2ǫt], (10) and ∣1 − β\nβ ∣ ≤max{ 1√ 1 − 2ǫt − 1,1 − 1√ 1 + 2ǫt } ≤ 2ǫt. (11) Fourthly, similar as above we can show that\n∣∣h⊥ − t∑ j=1 ⟨h⊥, êj⟩êj ∣∣ = ∣∣ t∑ j=1 ⟨h⊥, h⊥j ⟩h⊥j − ⟨h⊥, êj⟩êj ∣∣ ≤ 2ǫt. (12) Now, by plugging (10), (11) and (12) into (9) we get (8)."
    }, {
      "heading" : "Appendix B: Proof of Theorem 4",
      "text" : "Let {ζn, n ≥ 1} be a sequence of independent and identically distributed (iid) Bernoulli(ρ) random variables. Denote by (F ,Ω,Pr) the probability space generated by this sequence. At the m-th round of DC2, if ζm = 1 (which takes place with independent probability ρ) then we observe a flipped version of sign⟨xm, h∗⟩. Also, if ζm = 0 we observe the correct version of sign⟨xm, h∗⟩.\nConsider a query of the form sign⟨x,h∗⟩. This query divides the unit circle into two parts (half-circles) depending on the sign of ⟨x,h∗⟩ (see Figure 4). The two parts are: (i) Preferred part: all h such that sign⟨x,h⟩ = sign⟨x,h⊥⟩, and (ii) Unpreferred part: all h such that sign⟨x,h⟩ = − sign⟨x,h⊥⟩. The two parts can be separated by a line ℓx that passes through the origin. We refer to Figure 4 for a schematic explanation.\nIn this setting, we say that the query sign⟨x,h∗⟩ prefers a point z if z belongs to the preferred part of the query. Otherwise, we say that the query does not prefer z. Also, we frequently use the line ℓx rather than the query sign⟨x,h∗⟩ when it causes no ambiguity. Finally, for a region A on the unit circle say that the query sign⟨x,h∗⟩ cuts the region A if and only if the line ℓx passes through region A. Otherwise, we say that the query does not cut A. If ℓx does not cut A, then ℓx prefers A if A is in the preferred part and does not prefer A otherwise (see Figure 4). Finally, for two points x, y we define the distance d(x, y) to be the length of the (smaller) sector between them (see Figure 4). Clearly, we have d(x, y) ≥ ∥x − y∥2.\nAt round m of DC2 a vector xm is chosen and the (noisy) outcome of sign⟨xm, h∗⟩ is observed. As explained in Section ??, xm is chosen in a way that the preferred and unpreferred parts have equal measures under pm−1, i.e., pm−1(Fxm) = pm−1(Uxm) = 1 2\n. Let us see what happens to pm (the posterior belief about h⊥ at round m) after we conduct the query sign⟨xm, h∗⟩. As the result of the query is noisy, we have two\ndifferent update rules depending on each of the following cases: (i) ζm = 0, i.e., we observe the correct value sign⟨xm, h∗⟩. In this case, the measure pm is updated as follows\npm+1(h) = ⎧⎪⎪⎨⎪⎪⎩ 2(1 − ρ)pm(h) if h ∈ Fxm ,(2ρ)pm(h) if h ∈ Uxm .\n(ii) ζm = 1, i.e., we observe the flipped value − sign⟨xm, h∗⟩. In this case, the measure pm is updated as follows\npm+1(h) = ⎧⎪⎪⎨⎪⎪⎩ (2ρ)pm(h) if h ∈ Fxm , 2(1 − ρ)pm(h) if h ∈ Uxm .\nConsider the number Tǫ,δ given in (4). Our goal is to show that\nPr [∃y ∈ S1 ∶ d(y, h⊥) > ρ and pTǫ,δ(y) ≥ pTǫ,δ(h⊥)] < δ. (13) Clearly, the result of the theorem follows from (13). For better illustration, we assume w.l.o.g that h⊥ = (0,1). Consider a point y on the right-hand side of the unit circle such that d(y, h⊥) > ǫ 2 . Also, Consider points z0, zK such that d(z0, h⊥) = ǫ/4 and\nd(h⊥, zK) = ǫ/2. We now divide the sector starting with z0 and ending with zK into K ∶= Tǫ,δ+1 pints. That is, for i = 1,2,⋯,K we denote by zi the point that d(h⊥, zi) = ǫ 4 + i ǫ 4(Tǫ,δ+1) (see Figure 5). Also, for i ≥ 1, we let the sector starting with zi−1 and\nending with zi be denoted by Ai. Note that in the very beginning of the algorithm when we have uniform measure on the unit circle, each of the regions Ai has p0(Ai) =\nǫ 8π⋅(Tǫ,δ+1) (as ∣Ai∣ = ǫ4(Tǫ,δ+1) ).\nDC2 has in total Tǫ,δ rounds and in each round m it conducts a query with an associated line ℓxm . We let M ∶= ⌈ 2 log 2δlog 4(ρ(1−ρ))⌉ and consider the following events: • E1: There is at least M lines which separate zK from h⊥ or equivalently, there\nis at least M lines that cut the region (h⊥, zK). • E2,j (1 ≤ j ≤K): The region Aj is not cut by any of the lines ℓ1, ℓ2, . . . , ℓTǫ,δ .\n• E3: ∃y such that d(y, h⊥) > ρ2 and pTǫ,δ(y) ≥ pTǫ,δ(h⊥). It is easy to see that Pr [⋃Kj=1E2,j] = 1 as we have Tǫ,δ queries and hence by the pigeon-hole principle there is always a region Aj that is not cut by any of the lines. We can write:\nPr [E3] = Pr [E3 ∩E1] +Pr [E3 ∩Ec1] ≤ Pr [E3 ∣ E1] + Tǫ,δ+1∑\nj=1 Pr [E3 ∩Ec1 ∩E2,j] . (14)\nNow using Lemma 6 (stated below), we have\nPr [E3 ∣ E1] ≤ Pr [E3 ∣ E1] ≤ (4ρ(1 − ρ))M2 ≤ δ 2 . (15)\nLet us now bound Pr [E3 ∩Ec1 ∩E2,j] . We have Pr [E3 ∩Ec1 ∩E2,j] ≤ Pr [E2,j ∩Ec1] , and using the fact that ∣E2,j ∣ = ρ4(Tǫ,δ+1) we obtain from Lemma 7 that Pr [E2,j ∩Ec1] ≤ (M − 1)(θ1 + θ2),\nand thus Tǫ,δ+1\n∑ j=1 Pr [E2,j ∩Ec1] ≤ (Tǫ,δ + 1)M(θ1 + θ2), (16) where θ1 and θ2 are given in Lemma 7 with m ← Tρ,δ and k ←M . Now, we show that the above expression is upper bounded by δ/2, and hence by using relations (14) and (15), we get the proof of the main theorem.\nThe value of T0 is chosen in such a way that we have\n2 log(Tǫ,δ + 1) Tǫ,δ −M ≤ log(2(1 − ρ)) 4 . (17)\nT1 ensures that 2\nTǫ,δ −M log\n8π ǫ ≤ log(2(1 − ρ)) 4 . (18)\nT2 and ensures that 2M Tǫ,δ −M log(2ρ) ≤ log(1 − 2ρ) 2 . (19)\nFinally, T3 ensures that\n(Tǫ,δ + 1)M exp ⎧⎪⎪⎪⎨⎪⎪⎪⎩−ρ T −M 6 ⎛⎝ log(2(1 − ρ))2ρ log 1−ρ ρ ⎞⎠ 2⎫⎪⎪⎪⎬⎪⎪⎪⎭ ≤ δ 4 . (20)\nNow, by plugging in (17)-(20) into the values of θ1 and θ2 in (16) we conclude that the right side of (16) is bounded by δ\n2 .\nLemma 6. Let x1, x2,⋯, xm be the vectors chosen by DC 2 up to round m with Fxi\nand Uxi being their associated preferred and unpreferred parts (i.e. pi−1(Fxi) = pi−1(Uxi) = 1/2). Consider two points h1, h2 such that h1 ∈ ∩mi=1Fxi and h2 ∈ ∩mi=1Uxi . We have for β > 0 that Pr [pm(x) < pm(y)] ≤ (4ρ(1 − ρ))m . Proof. For i ∈ [m], define the random variable Zi as Zi ≜ log pi(x)pi(y) . Using the update rules of pi that we explained above, it is easy to see that for i ≥ 1: Zi = Zi−1 +(1 − 2ζi) log 1−ρρ . Also, as p0 is uniform over S1 we have Z0 = 0. We thus have Zm = ∑mi=1(1 − 2ζi) log 1−ρρ . Hence,\nPr [Zm ≤ 0] = Pr [log 1 − ρ\nρ\nm\n∑ i=1 (1 − 2ζi) ≤ 0] = Pr [m∑\ni=1 ζi ≥\n1 2 ]\n≤ (4ρ(1 − ρ))m2 , where the last step follows directly from the so called Chernoff bound.\nWe note that the vector h⊥ is always a member of the preferred part of any test. As a result, at any round of DC2 we have that h⊥ ∈ ∩mi=1Fxi .\nLemma 7. Consider a region A on the unit circle which does not contain h⊥. Assume we are at round m of DC2 where a sequence of queries with associated lines ℓx1 , ℓx2 , . . . , ℓxm have been conducted. We define events E1 and E2 as\n• E1 ≜ None of the lines ℓxi cuts A;\n• E2 ≜ At most k of the lines do not prefer A,\nwhere k is an an integer. We have Pr [E1 ∩E2] ≤ k(θ1 + θ2), where\nθ1 = exp ⎧⎪⎪⎪⎨⎪⎪⎪⎩−ρ m − k 6 ⎛⎝ log(2(1 − ρ)) − 2 m−k log 2π∣A∣) ρ log( 1−ρ ρ ) ⎞⎠ 2⎫⎪⎪⎪⎬⎪⎪⎪⎭ ,\nand\nθ2 = exp ⎧⎪⎪⎪⎨⎪⎪⎪⎩−ρ m − k 6 ⎛⎝ log(2(1 − ρ)) + 2k m−k log(2ρ) ρ log( 1−ρ ρ ) ⎞⎠ 2⎫⎪⎪⎪⎬⎪⎪⎪⎭ .\nProof. We have\nPr [E1 ∩E2] ≤ Pr [E2 ∣ E1] ≤ k∑ j=1 Pr [E2,j ∣ E1] , (21) where we define\nE2,j ≜ Exactly j lines do not prefer A.\nWe will now calculate Pr [E2,j ∣ E1] . In the beginning, p0 puts a uniform measure on A and hence p0(A) = ∣A∣2π . Let us first investigate the dynamics of pi−1(A) when we conduct the i-th query and condition on event E1 (i.e. given that none of the lines cut A). In this setting, we define the random variables Zi = log pi(A). At time i, assuming that the line ℓxi does not cut A, Zi has different update rules depending on the two cases whether the line ℓxi prefers A or does not prefer A. (i) first case: if the line ℓxi prefers A, then we know that either with probability 1 − ρ (if ζi = 0) we have pi(A) = 2(1−ρ)pi−1(A) and with probability ρ (if ζi = 1) we have pi(A) = (2ρ)pi−1(A). Thus, we can write Zi = Zi−1+Fi, where Fi ≜ ζi log(2ρ)+(1−ζi) log(2(1−ρ)). (ii) second case: if ℓxi does not prefer A, then using a similar argument we obtain Zi = Zi−1 +Ui, where Ui ≜ ζi log(2(1 − ρ)) + (1 − ζi) log(2ρ). Now, in order to find an upper bound on Pr [E2,j ∣ E1], we assume without loss of generality that in the first m − j rounds we the lines are as in the first case and in the last j rounds the lines are as in the second case (note that any other given order of the lines is statistically equivalent to this simple order that we consider).\nZm = Z0 + m−j\n∑ i=1\nFi + m\n∑ i=m−j+1 Ui\n= log2 ∣A∣ 2π + m−j ∑ i=1 Fi + m ∑ i=m−j+1 Ui.\nNow, noting that pm(A) ≤ 1 and hence logpm(A) ≤ 0, we obtain Pr [E2,j ∣ E1]\n≤ Pr ⎡⎢⎢⎢⎣log2 p0(A) + m−j ∑ i=1 Fi + m ∑ i=m−j+1 Ui ≤ 0 ⎤⎥⎥⎥⎦ = Pr ⎡⎢⎢⎢⎣ m−j ∑ i=1 Fi + m ∑ i=m−j+1 Ui ≤ log2 2π∣A∣\n⎤⎥⎥⎥⎦ Let us now define\nα1 = Pr ⎡⎢⎢⎢⎢⎣ m−j 2 ∑ i=1 Fi ≤ log 2π A ⎤⎥⎥⎥⎥⎦ and\nα2 = Pr ⎡⎢⎢⎢⎢⎢⎣ m−j ∑ i=1+m−j 2 Fi + m ∑ i=m−j+1 Ui ≤ 0 ⎤⎥⎥⎥⎥⎥⎦\nUsing the union bound, we have Pr [E2,j ∣ E1] ≤ α1 + α2. (22) Now, to bound α1 we obtain after some simplifications that\nα1 = Pr ⎡⎢⎢⎢⎢⎣ m−j 2 ∑ i=1 ζi ≥ ρ × m − j 2 × log(2(1 − ρ)) − 2 m−j log 2π∣A∣ ρ log 1−ρ ρ ⎤⎥⎥⎥⎥⎦ , and by using the Chernoff bound we get\nα1 ≤ exp ⎧⎪⎪⎪⎨⎪⎪⎪⎩−ρ m − j 6 ⎛⎝ log(2(1 − ρ)) − 2 m−j log 2π∣A∣) ρ log( 1−ρ ρ ) ⎞⎠ 2⎫⎪⎪⎪⎬⎪⎪⎪⎭ . (23)\nTo bound α2 we can similarly write after some simple steps that\nα2 ≤ Pr ⎡⎢⎢⎢⎢⎢⎣ m−j ∑ i=1+m−j 2 ζi ≥ ρ × m − j 2 log(2(1 − ρ)) + 2j m−j log(2ρ) ρ log 1−ρ ρ ⎤⎥⎥⎥⎥⎥⎦ ,\nand using the Chernoff bound we get\nα2 ≤ exp ⎧⎪⎪⎪⎨⎪⎪⎪⎩−ρ m − j 6 ⎛⎝ log(2(1 − ρ)) + 2j m−j log(2ρ) ρ log( 1−ρ ρ ) ⎞⎠ 2⎫⎪⎪⎪⎬⎪⎪⎪⎭ . (24)\nWe further note that both of the upper bounds on α1 and α2 decrease when we increase j. Hence, the proof of the theorem follows by letting j = k in (23) and (24), and also plugging these bounds into (21)."
    }, {
      "heading" : "Appendix C: Proof of Theorem 5",
      "text" : "First of all, we consider Pr[R(ĥ) >min{R(h1),R(h2)}]. Let δ ≜ R∆(h1)−R∆(h2) and δ̂ ≜ R̂∆(h1) − R̂∆(h2). By Hoeffding’s inequality, we have\nPr[∣δ̂ − δ∣ ≥ γ] ≤ 2 exp(−nγ2 6 ) . If δ > 0, then letting γ = δ yields that Pr[δ̂ < 0] ≤ 2 exp(−nδ2/6). Therefore Pr[R̂∆(h1) < R̂∆(h2)] ≤ 2 exp(−nδ2/6). Since we know that R∆(h1) > R∆(h2) (δ > 0), we have R(h1) > R(h2) because h1 and h2 agree on the complement of ∆. Thus R(ĥ) > min{R(h1),R(h2)} with probability at most 2 exp(−nδ2/6). Similarly if δ < 0, then we have Pr[δ̂ > 0] ≤ 2 exp(−nδ2/6). Therefore Pr[R̂∆(h1) > R̂∆(h2)] ≤ 2 exp(−nδ2/6). SinceR(h1) < R(h2), henceR(ĥ) >min{R(h1),R(h2)}\nwith probability at most 2 exp(−nδ2/6). In sum, we have R(ĥ) >min{R(h1),R(h2)} with probability at most 2 exp(−n∣R∆(h1) −R∆(h2)∣2/6).\nLet δn denote 2 exp(−n∣R∆(h1)−R∆(h2)∣2/6). Now we want to bound E[R(ĥ) ∣ h1, h2]. We have\nE[R(ĥ) ∣ h1, h2] ≤ (1 − δn)min{R(h1),R(h2)} + δnmax{R(h1),R(h2)} = min{R(h1),R(h2)} + δn∣R(h1) −R(h2)∣ = min{R(h1),R(h2)} + 2∣R(h1) −R(h2)∣\nexp(−n∣R∆(h1) −R∆(h2)∣2/6 ≤ min{R(h1),R(h2)} + 2∣R(h1) −R(h2)∣\nexp(−n∣R(h1) −R(h2)∣2/6, where the last inequality holds because ∣R(h1) −R(h2)∣ ≤ ∣R∆(h1) −R∆(h2)∣.\nWhen u = √ 3/n, the function f(u) = 2ue−nu2/6 achieves its maximum 2√ 3\nne .\nThus we obtain that\nE[R(ĥ) ∣ h1, h2] ≤min{R(h1),R(h2)} + 2 √ 3\nne .\nBy Jensen’s inequality, we conclude that\nE[R(ĥ)] ≤ E[min{R(h1),R(h2)] + 2 √ 3\nne ≤ min{E[R(h1),E[R(h2)]} + 2 √ 3\nne ."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "<lb>In this paper, we consider the problem of actively learning a linear classifier<lb>through query synthesis where the learner can construct artificial queries in order<lb>to estimate the true decision boundaries. This problem has recently gained a lot of<lb>interest in automated science and adversarial reverse engineering for which only<lb>heuristic algorithms are known. In such applications, queries can be constructed<lb>de novo to elicit information (e.g., automated science) or to evade detection with<lb>minimal cost (e.g., adversarial reverse engineering).<lb>We develop a general framework, called dimension coupling (DC), that 1) re-<lb>duces a d-dimensional learning problem to d − 1 low-dimensional sub-problems,<lb>2) solves each sub-problem efficiently, and 3) appropriately aggregates the results<lb>and outputs a linear classifier. We consider the three most common scenarios in<lb>the literature: idealized noise-free, independent noise realizations, and agnostic<lb>settings. We show that the DC framework avoids the curse of dimensionality: its<lb>computational complexity in all three cases scales linearly with the dimension.<lb>Moreover, in the noiseless and noisy cases, we show that the query complexity of<lb>DC is near optimal (within a constant factor of the optimum algorithm). We also<lb>develop an agnostic variant of DC for which we provide strong theoretical guaran-<lb>tees. To further support our theoretical analysis, we compare the performance of<lb>DC with the existing work in all three settings. We observe that DC consistently<lb>outperforms the prior arts in terms of query complexity while often running orders<lb>of magnitude faster.",
    "creator" : "LaTeX with hyperref package"
  }
}