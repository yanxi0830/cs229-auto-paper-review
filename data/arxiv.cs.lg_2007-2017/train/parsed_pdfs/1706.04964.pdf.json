{
  "name" : "1706.04964.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Learning Deep ResNet Blocks Sequentially using Boosting Theory",
    "authors" : [ "Furong Huang" ],
    "emails" : [ "furongh@cs.umd.edu", "jordantash@gmail.com", "jcl@microsoft.com", "schapire@microsoft.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 6.\n04 96\n4v 1\n[ cs\n.L G\n] 1"
    }, {
      "heading" : "1 Introduction",
      "text" : "Deep neural networks have elicited breakthrough successes in machine learning, especially in image classification and object recognition (Krizhevsky et al. , 2012; Sermanet et al. , 2013; Simonyan & Zisserman, 2014; Zeiler & Fergus, 2014) in recent years. As the number of layers increases, the nonlinear network becomes more powerful, deriving richer features from input data. Empirical studies suggest that challenging tasks in image classification (He et al. , 2015; Ioffe & Szegedy, 2015; Simonyan & Zisserman, 2014; Szegedy et al. , 2015) and object recognition (Girshick, 2015; Girshick et al. , 2014; He et al. , 2014; Long et al. , 2015; Ren et al. , 2015) often require “deep” networks, consisting of tens or hundreds of layers. Theoretical analyses have further justified the power of deep networks (Mhaskar & Poggio, 2016) compared to shallow networks.\nHowever deep neural networks are difficult to train despite their intrinsic viability. Stochastic gradient descent with back-propagation (BP) (LeCun et al. , 1989) and its variants are commonly used to solve the non-convex optimization problem. A major challenge that exists for training both shallow and deep networks is vanishing/exploding gradients (Bengio et al. , 1994; Glorot & Bengio, 2010). Recent works have proposed normalization techniques (Glorot & Bengio, 2010; LeCun et al. , 2012; Ioffe & Szegedy, 2015; Saxe et al. , 2013) to effectively ease the problem and achieve convergence. In training deep networks, however, a surprising training performance degradation is observed\n31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, CA, USA.\n(He & Sun, 2015; Srivastava et al. , 2015; He et al. , 2016): the training performance degrades rapidly along with the increased network depth after some saturation point. This training performance degradation is unexpected as one can easily construct a deep network identical to a shallow network by enforcing any part of the deep network to be the same as the shallow network and the rest layers to be identity maps. He et al. (He et al. , 2016) have presented a residual network (ResNet) learning framework to ease the training of networks that are substantially deeper than those used previously. And they explicitly reformulate the layers as learning residual functions with reference to the layer inputs by adding identity loops to the layers. It is shown in (Hardt & Ma, 2016) that identity loops ease the problem of spurious local optima in shallow networks. Srivastava et al. (Srivastava et al. , 2015) introduce a novel architecture that enables the optimization of networks with virtually arbitrary depth through the use of a learned gating mechanism for regulating i34nformation flow.\nAlthough empirical evidence shows that these deep residual networks are easier to optimize than non-residual ones, there lacks a theoretical justification for this observation. For example, there have been no performance guarantees on the training or testing error for networks of this deep residual architecture. Furthermore, the entire training still relies on the unstable end-to-end back-propagation which are susceptible to suboptimal solutions (Ge et al. , 2015) in deep networks."
    }, {
      "heading" : "1.1 Summary of Results",
      "text" : "We propose a novel framework, multi-channel telescoping sum boosting (defined in Section 4), to characterize a feed forward ResNet in Section 3. We show that the top level (final) output of a ResNet is a telescoping sum of its pairs of consecutive module differences. Theoretical analyses such as training error guarantees and generalization error bounds for telescoping sum boosting are provided.\nTo remedy the problem of training error degradation as depth increases, we introduce a guaranteed learning algorithm, called BoostResNet, to train modules of ResNet sequentially. BoostResNet adaptively selects training samples or changes the cost function (Section 4 Theorem 4.2). BoostResNet trains the ResNet with guarantees: the training error decays exponentially with the depth of the network. As discussed later in Section 4.4, the generalization error of BoostResNet is analyzed and advice to avoid over-fitting is provided. Our procedure trains each residual block sequentially, only requiring that each provides a better-than-random-guessing prediction of dataset labels.\nOur BoostResNet algorithm enjoys several superiorities over the end-to-end back-propagation (e2eBP) training convention despite the theoretical guarantees. First, BoostResNet is substantially more memory efficient than e2eBP as the former requires only two modules of the network to be in the GPU whereas the latter inevitably keeps all modules in the GPU. The advantage is crucial for efficient training for deep networks. Also, BoostResNet is more computational efficient than e2eBP since each e2eBP step involves back propagating through the entire deep network.\nExperimentally, we compare BoostResNet with e2eBP over two types of feed forward ResNets, multilayer perceptron residual network (MLP-ResNet) and convolutional neural network residual network (CNN-ResNet), on multiple datasets. BoostResNet shows drastic performance improvement under the MLP-ResNet architecture. Under CNN-ResNet, a slightly faster convergence for BoostResNet is observed. The tremendous advantages of BoostResNet on memory and computation efficiency are justified as well in the experiments. Our multi-channel telescoping sum boosting learning framework is not limited to ResNet and can be extended to other even non-differentiable nonlinear hypothesis units, such as decision trees and tensor decompositions."
    }, {
      "heading" : "1.2 Related Works",
      "text" : "Training deep neural networks has been an active research area in the past few years. The main optimization challenge lies in the highly non-convex nature of the loss function. There are two main ways to address this optimization problem, one is to select a loss function and network architecture that have better geometric properties, and the other is to improve the network’s learning procedure.\nLoss function and architecture selection In neural network optimization, there are many predefined loss functions and criteria that are commonly used. For instance, mean squared error, negative log likelihood, margin criterion and so forth. There are extensive works (Girshick, 2015; Rubinstein & Kroese, 2013; Tygert et al. , 2015) on selecting or modifying loss functions to prevent\nempirical difficulties such as exploding/vanishing gradients or slow learning (Balduzzi et al. , 2017). However, there are no rigorous principles for selecting a loss function in general. Other works consider variations of the MLP or CNN by adding identity skip connections (He et al. , 2016), allowing information to bypass particular layers. However, no theoretical guarantees on the training error are provided despite breakthrough empirical successes. Hardt et al. (Hardt & Ma, 2016) have shown the advantage of identity loops in linear neural networks with theoretical justifications, however the linear setting is unrealistic in practice.\nLearning algorithm design There have been extensive works on improving BP (LeCun et al. , 1989). For instance, momentum (Qian, 1999), Nesterov accelerated gradient (Nesterov, 1983), Adagrad (Duchi et al. , 2011) and its extension Adadelta (Zeiler, 2012). Most recently, Adaptive Moment Estimation (Adam) (Kingma & Ba, 2014), a combination of momentum and adagrad, has received substantial success in practice. All these methods are modifications of SGD, but our method only requires an arbitrary oracle, which does not necessarily need to be an SGD solver. Bengio et al. (Bengio et al. , 2006) introduce single hidden layer convex neural networks, and propose a gradient boosting algorithm to learn the weights of the linear classifier, however a generalization of their method to deep networks with more than one hidden layer is not possible. Shalev-Shwartz (Shalev-Shwartz, 2014) proposes a selfieBoost which boosts the accuracy of a single network. Our algorithm is different as we instead construct ensembles of classifiers. AdaBoost (Cortes et al. , 2016) also considers ensembles of classifiers, but they require connections between top layer and all other lower level layers, which are not amenable to a standard ResNet architecture.\n2 Preliminaries\nA residual neural network (ResNet) is composed of stacked entities referred to as modules. Each module consists of a multiple-layer neural network. Commonly used modules include MLP and CNN.\nThroughout this paper, we consider training examples (x, y) = {(x1, y1), (x2, y2), . . . , (xm, ym)} ∈ D, where D is the distribution of the data. We will use S to denote the samples.\nA Module of ResNet Let each module map its input to ft(·) where t denotes the level of the modules. Each module ft(x) is a nonlinear unit with n channels, i.e., ft(x) ∈ Rn. In multilayer perceptron residual network (MLP-ResNet), ft(x) is a shallow MLP, for instance, a connected nonlinear ft(x) = Ṽ ⊤ t σ(W̃ ⊤ t x) where W̃t ∈ Rn×k, Ṽt ∈ Rk×n and σ is a nonlinear operator such as sigmoidal function or relu function. Similarly, in convolutional neural network residual network (CNN-ResNet), the function ft(x) represents the t-th convolutional module. Then the t-th module outputs gt+1(x)\ngt+1(x) = ft(gt(x)) + gt(x), (1)\nwhere x is the input fed to the ResNet. See Figure 1 for an illustration of a ResNet, which consists of stacked modules with identity loops.\nOutput of ResNet Due to the recursive relation specified in Equation (1), the output of the T -th module is equal to the summation over lower module outputs, i.e., gT+1(x) = fT (gT (x))+gT (x) =∑T\nt=1 ft(gt(x)), where g1(x) = x. For classification tasks, the final output of a ResNet given input x is rendered after a linear classifier w ∈ Rn on representation gT+1(x):\nŷ = σ̃ (F (x)) = σ̃(w⊤gT+1(x)) = σ̃ ( w⊤ T∑\nt=1\nft(gt(x))\n) (2)\nwhere σ̃(·) denotes a map from representation to labels σ̃(z) : z → Y . For instance σ̃(z) = sign(z) for binary classification, or σ̃(z) = argmax\ni zi for multi-class classification. The form of the\noutput from a classification ResNet is thus as follows. The parameters of a depth-T ResNet are\n{w, {ft(·), ∀t ∈ T }}. A ResNet training involves training the classifier w and the weights of modules ft(·) ∀t ∈ [T ] when training samples (x1, y1), (x2, y2), . . . , (xm, ym) are available.\nBoosting Boosting (Freund & Schapire, 1995) assumes the availability of a weak learning algorithm which, given labeled training examples, produces a weak classifier (a.k.a. base classifier) ht(x). The goal of boosting is to improve the performance of the weak learning algorithm. The key idea behind boosting is to choose training sets for the weak classifier in such a fashion as to force it to infer something new about the data each time it is called. The weak learning algorithm will finally combine many weak classifiers ht(x) into a single combined strong classifier ∑T\nt=1 ht(x) whose prediction power is strong.\nFrom empirical experiences, ResNet remedies the problem of increased training error in deeper neural networks. We are curious about whether there is a theoretical justification that the training error of ResNet asymptotically converges to 0 as the depth T increases. More importantly, we are interested in proposing a new algorithm that avoids end-to-end back-propagation (e2eBP) through the deep network and thus is immune to the instability of the non-convex optimization."
    }, {
      "heading" : "3 ResNet in Telescoping Sum Boosting Framework",
      "text" : "As we recall from Equation 2, ResNet indeed has a similar form as the strong classifier in boosting. The key difference is that boosting is an ensemble of estimated hypotheses ∑T\nt=1 ht(x) whereas\nResNet is an ensemble of estimated feature representations F (x) = ∑T\nt=1 ft(gt(x)). To solve this problem, we introduce an auxiliary linear classifier wt on top of each ResNet module ft(gt(x)) to construct a hypothesis module. Formally, a hypothesis module is defined as\not(x) def = w⊤t gt(x) ∈ R (3)\nin the binary classification setting. Therefore ot+1(x) = w ⊤ t+1[ft(gt(x)) + gt(x)] as gt+1(x) = ft(gt(x)) + gt(x). In the multi-class setting, let C be the number of classes, we define hypothesis module ot(x) def = W⊤t gt(x) ∈ RC where linear classifier Wt ∈ Rn×C is a matrix instead of a vector. Our analysis applies to both binary and multi-class, but we will focus on the binary class for simplicity in the main text and defer the multi-class analysis to the Appendix E.\nNow the naive ensemble of the hypothesis module is not a ResNet unless all the auxiliary linear classifiers wt’s are equivalent to the ResNet’s top classifier w. However note that the input gt+1(x) of the t+1-th module is the output ft(gt(x))+gt(x) of the t-th module, one has to train the modules sequentially. Therefore the common auxiliary linear classifier assumption prevents us from training the T hypothesis module sequentially and is thus unrealistic. We design a weak module classifier using the idea of telescoping sum as follows.\nDefinition 3.1. A weak module classifier is defined as ht(x) def = αt+1ot+1(x) − αtot(x) where ot(x) def = w⊤t gt(x) is a hypothesis module. We call the boosting framework a “telescoping sum boosting” if the weak learners are restricted to the form of the weak module classifier.\nResNet: Ensemble of Weak Module Classifier Recall that the T -th module of a ResNet outputs gT+1(x), which is fed to the top/final linear classifier for the final classification. We show that an ensemble of the weak module classifiers is equivalent to a ResNet’s final output. We state it formally in Lemma 3.2.\nLemma 3.2. Let the input gt(x) of the t-th module be the output of the previous module, i.e., gt+1(x) = ft(gt(x)) + gt(x), then the summation of T weak module classifiers is identical to the output, F (x) in Equation 2, of the depth-T ResNet,\nF (x) ≡ 1 αT+1\nT∑\nt=1\nht(x), (4)\nwhere the weak module classifier is ht(x) def = αt+1ot+1(x) − αtot(x) and the hypothesis module is ot(x) def = w⊤t gt(x).\nSee Appendix A for the proof. Note that we will abusively call F (x) the output of ResNet although a σ̃ function is applied on top of F (x), mapping the output to the label space Y . We now analyze the telescoping sum boosting framework in Section 4."
    }, {
      "heading" : "4 Telescoping Sum Boosting for Binary Classification",
      "text" : "Recall that the weak module classifier is defined as ht(x) = αt+1ot+1(x) − αtot(x). We restrict to bounded classifiers |ot(x)| ≤ 1. Throughout this paper, we will assume that the covariance between exp(−yot+1(x)) and exp(yot(x)) is non-positive. We propose a learning algorithm whose training error decays exponentially with the number of weak module classifiers T under a weak learning condition in the following."
    }, {
      "heading" : "4.1 Weak Learning Condition",
      "text" : "Let γ̃t def = Ei∼Dt−1 [yiot(xi)] > 0 be the edge of the hypothesis module ot(x), where Dt−1 is the sample weight. A naive weak learning condition would be γ̃2t+1 − γ̃2t ≥ γ′ 2 > 0. However this naive weak learning condition is too strong. Even when γ̃t is close to 1, we still seek weak learner which performances consistently better than γ′. Instead, we consider a much weaker weak learning condition as follows.\nDefinition 4.1 (γ-Weak Learning Condition). Let γ̃t = Ei∼Dt−1 [yot(x)] > 0. A weak module classifier ht(x) = αt+1ot+1 −αtot satisfies the γ-weak learning condition with respect to a pair of distributions (Dt, Dt−1) if γ̃2t+1−γ̃ 2 t\n1−γ̃2t ≥ γ2 > 0.\nThe weak learning condition is motivated by the learning theory and it is met in practice as shown\nin Figure 5a. For each weak module classifier, γt def = √ γ̃2t+1−γ̃2t 1−γ̃2t is defined as the “edge” which characterizes the correlation between the true labels y and the weak module classifier ht(x) over the training samples. The condition specified in Definition 4.1 is extremely mild as it requires the weak module classifier ht(x) to perform only slightly better than random guessing. As the hypothesis module ot(x) is bounded by 1, we obtain that |γ̃t| ≤ 1."
    }, {
      "heading" : "4.2 BoostResNet",
      "text" : "We now propose a novel training algorithm for telescoping sum boosting under the setting of binaryclass classification as in Algorithm 1. In particular, we introduce a training procedure for deep ResNet in Algorithm 1 and 2, called BoostResNet, which only requires sequential training shallow ResNets. Each of the shallowResNet ft(gt(x))+gt(x) is combinedwith an auxiliary linear classifier wt+1 to form a hypothesis module ot+1(x). The weights of the ResNet are trained on these shallow ResNets and the auxiliary linear classifiers wt+1 are discarded (except for the top classifier). The training algorithm is therefore a module-by-module procedure following a bottom-to-up fashion as the outputs of the t-th module gt+1(x) are fed as the training examples to the next t+ 1-th module.\nAlgorithm 1 BoostResNet: telescoping sum boosting for binary-class classification Input: m labeled samples [(xi, yi)]m where yi ∈ {−1,+1} and a threshold γ Output: {ft(·), ∀t} andwT+1 ⊲ Discardwt+1, ∀t 6= T 1: Initialize t ← 0, γ̃0 ← 0, α0 ← 0, o0(x) ← 0 2: Initialize sample weights at round 0: D0(i) ← 1/m, ∀i ∈ [m] 3: while γt > γ do 4: ft(·), αt+1,wt+1, ot+1(x) ← Algorithm 2(gt(x), Dt, ot(x), αt)\n5: Compute γt ← √\nγ̃2t+1−γ̃2t 1−γ̃2t\n⊲ where γ̃t+1 ← Ei∼Dt [yiot+1(xi)]\n6: UpdateDt+1(i) ← Dt(i) exp(−yiht(xi))m∑ i=1 Dt(i) exp[−yiht(xi)] ⊲ where ht(x) = αt+1ot+1(x) − αtot(x) 7: t ← t+ 1 8: end while 9: T ← t− 1\nTheorem 4.2. [ Training error bound ] The training error of a T -module telescoping sum boosting using Algorithm 1 and 2 decays exponentially with the number of modules T ,\nPr i∼S\n( σ̃ ( ∑\nt\nht (xi) ) 6= yi ) ≤ e− 12Tγ2\nAlgorithm 2 BoostResNet: oracle implementation for training a ResNet module\nInput: gt(x),Dt,ot(x) and αt Output: ft(·), αt+1,wt+1 and ot+1(x) 1: (ft, αt+1,wt+1) ← arg min\n(f,α,v) m∑ i=1 Dt(i) exp ( −yiαv⊤ [f(gt(xi)) + gt(xi)] + yiαtot(xi) )\n2: ot+1(x) ← w⊤t+1 [ft(gt(x)) + gt(x)]\nif ∀t ∈ [T ] the weak module classifier ht(x) satisfies the γ-weak learning condition defined in Definition 4.1 and the covariance between exp(−yot+1(x)) and exp(yot(x)) is non-positive ∀t.\nThe training error of Algorithm 1 and 2 is guaranteed to decay exponentially with the ResNet depth even when each weak learning module ht(x) performs only slightly better than random (i.e., γ > 0). The assumption of the covariance between exp(−yot+1(x)) and exp(yot(x)) being non-positive is suggesting that the weak module classifiers should not be adversarial, which is a reasonable assumption for ResNet. Refer to Appendix E for the algorithm and theoretical guarantees for multi-class classification."
    }, {
      "heading" : "4.3 Oracle Implementation for ResNet",
      "text" : "In Algorithm 2, the implementation of the oracle is equivalent to\n(ft, αt+1,wt+1) = arg min (f,α,v)\n1\nm\nm∑\ni=1\nexp ( −yiαv⊤ [f(gt(xi)) + gt(xi)] ) (5)\nIn practice, there are various ways to implement Equation (5). For instance, Janzamin et. al. (Janzamin et al. , 2015) propose a tensor decomposition technique which decomposes a tensor formed by some transformation of the features x combined with labels y and recovers the weights of a one-hidden layer neural network with guarantees. One can also use back-propagation as numerous works have shown that gradient based training are relatively stable on shallow networks with identity loops (Hardt & Ma, 2016; He et al. , 2016)."
    }, {
      "heading" : "4.4 Generalization Error Analysis",
      "text" : "In this section, we analyze the generalization error to understand the possibility of over-fitting under Algorithm 1. The strong classifier or the ResNet is F (x) = ∑ t ht(x)\nαT+1 . Now we define the margin for\nexample (x, y) as yF (x).\nFor simplicity, we consider MLP-ResNet with multiple channels n and assume that the weight vector connecting a neuron at layer t with its precedent layer neurons is l1 norm bounded by Λt,t−1. Recall that there exists a linear classifier w on top, and we restrict to l1 norm bounded classifiers, i.e., ‖w‖1 ≤ C0 < ∞. The expected training examples are l∞ norm bounded r∞ def = ES∼D [ maxi∈[m]‖xi‖∞ ] < ∞. We introduce Lemma 4.3 according to Lemma 2 from (Cortes et al. , 2016).\nLemma 4.3. Let D be a distribution over X × Y and S be a sample of m examples chosen independently at random according to D. With probability at least 1− δ, for θ > 0, the strong classifier F (x) (ResNet) satisfies that\nPr D (yF (x) ≤ 0) ≤ Pr S (yF (x) ≤ θ) + 4C0r∞ θ\n√ log(2n)\n2m\nT∑\nt=1\nΛt + 2\nθ\n√ logT\nm + β(θ,m, T, δ) (6)\nwhere Λt def = ∏t t′=1 2Λt′,t′−1 and β(θ,m, T, δ) def = √⌈ 4 θ2 log ( θ2m log T )⌉ log T m + log 2 δ 2m .\nFrom Lemma 4.3, we obtain a generalization error bound in terms of margin boundPrS (yF (x) ≤ θ) and network complexity 4C0r∞\nθ\n√ log(2n)\n2m ∑T t=1 Λt+ 2 θ √ log T m +β(θ,m, T, δ). Larger margin bound\n(larger θ) contributes positively to generalization accuracy, and l1 norm bounded weights (smaller\n∑T t=1 Λt ) are beneficial to control network complexity and to avoid overfitting. The dominant term in the network complexity is 4C0r∞ θ √ log(2n) 2m ∑T t=1 Λt which scales as least linearly with the depth T . See appendix C for the proof.\nThis lemma suggests that stronger weak module classifiers which produce higher accuracy predictions and larger edges, will yield larger margins and suffer less from over-fitting. The larger the\nvalue of θ, the smaller the term 4C0r∞ θ\n√ log(2n)\n2m ∑T t=1 Λt+ 2 θ √ log T m +β(θ,m, T, δ) is. With larger\nedges on the training set and when γ̃T+1 < 1, we are able to choose larger values of θ while keeping the error term zero or close to zero."
    }, {
      "heading" : "5 Experiments",
      "text" : "We compare our proposed BoostResNet algorithm with e2eBP training a ResNet on the MNIST (LeCun et al. , 1998) and street view house numbers (SVHN) (Netzer et al. , 2011) benchmark datasets. Two different types of architectures are tested: multilayer perceptron residual network (MLP-ResNet) and convolutional neural network residual network (CNN-ResNet). In each experiment the architecture of both algorithms is identical, and they are both initialized with the same random seed. Our experiments were programmed in the Torch deep learning framework for Lua and executed on NVIDIA Tesla P100 GPUs.\nIn our training, a mini-batch size 100 is used for both BoostResNet and e2eBP. The learning rate is initialized at 1e-2 with a decaying rate of 1e-4. The optimization method used in e2eBP is the stateof-the-art Adaptive Moment Estimation (Adam) Kingma & Ba (2014) variant of SGD introduced earlier. The oracle we used in BoostResNet to solve the weak module classifier is Adam as well, but could be extended to tensor methods Janzamin et al. (2015), decision trees Safavian & Landgrebe (1991) or other nonlinear classifiers for non-differentiable data.\nResNet-MLP on MNIST The MNIST database (LeCun et al. , 1998) of handwritten digits has a training set of 60,000 examples, and a test set of 10,000 examples. The data contains 10 number of classes. We test the performance of BoostResNet on MLP-ResNet using MNIST dataset, and compare it with e2eBP baseline. Each residual block is composed of an MLP with a single, 1024- dimensional hidden layer. The training and testing error between BoostResNet and e2eBP is in Figure 2 as a function of depth. Surprisingly, we observe a training error degradation for e2eBP although the ResNet’s identity loop is supposed to alleviate this problem. Despite the presence of identity loops, the e2eBP eventually is susceptible to spurious local optima. Our proposed sequential training procedure, BoostResNet, relieves gradient instability issues, and continues to perform well as depth increases.\nResNet-CNN on SVHN SVHN (Netzer et al. , 2011) is a real-world image dataset, obtained from house numbers in Google Street View images, for recognizing digits and numbers in natural scene images and is therefore significantly harder than MNIST. Many of the images contain some distractors at the sides. The dataset contains over 600,000 digit images, an order of magnitude more labeled data. There are 604,388 digits for training, 26,032 digits for testing. We test the performance of BoostResNet on CNN-ResNet using SVHN dataset, and compare it with e2eBP. Each residual block is composed of a CNN using 15 3× 3 filters. The training and testing error between BoostResNet and e2eBP is in Figure 3. The training error degradation of e2eBP is alleviated on CNN-ResNet, but the learning is relatively slow compare to our BoostResNet.\nWe further investigate performance of e2eBP and BoostResNet on a shallower fine tuned network of 25 residual blocks and 50 layers in total 1. Each residual block contains convolution(5x5), batch normalization, ReLU, convolution(5x5), batch normalization, addition with identity loop and ReLU. The learning rate is fixed to be 10e-4 with no decay as suggested. The accuracy result is shown in Figure 4. Both algorithms are comparable using e2eBP’s fine tuned network architecture and hyper parameters although the parameters of BoostResNet is not fine tuned.\nWeak Learning Condition Check The weak learning condition (Definition 4.1) inspired by learning theory is checked in Figure 5. The required better than random guessing edge γt is depicted in Figure 5a, it is always greater than 0 and our weak learning condition is thus non-vacuous. In Figure 5b, the representationswe learned using BoostResNet is increasingly better (for this classification task) as the depth increases.\nComputational and Memory Efficiency It is worth noting that BoostResNet training is memory efficient as the training process only requires parameters of two consecutive residual blocks to be in memory. Given that the limited GPU memory being one of the main bottlenecks for computational efficiency, BoostResNet requires significantly less training time than e2eBP in deep networks as a result of reduced communication overhead and the speed-up in shallow gradient forwarding and back-propagation. LetM1 be the memory required for one module, andM2 be the memory required for one linear classifier, the memory consumption isM1 +M2 by BoostResNet andM1T +M2 by e2eBP. Let the flops needed for gradient update over one module and one linear classifier be C1 and C2 respectively, the computation cost is C1 + C2 by BoostResNet and C1T + C2 by BoostResNet.\n1The network is from https://github.com/facebook/fb.resnet.torch.\nIn practice, a 50 layer CNN-ResNet requires 3 days to train using e2eBP but 1 day to train using BoostResNet."
    }, {
      "heading" : "6 Conclusions and Future Works",
      "text" : "Our proposed BoostResNet algorithm achieves exponentially decaying (with the depth T ) training error under the weak learning condition. BoostResNet is much more computationally efficient compared to end-to-end back-propagation in deep ResNet. More importantly, the memory required by BoostResNet is trivial compared to end-to-end back-propagation. It is particularly beneficial given the limited GPU memory and large network depth. Our learning framework is natural for nondifferentiable data. For instance, our learning framework is amendable to take weak learning oracles using tensor decomposition techniques. Tensor decomposition, a spectral learning framework with theoretical guarantees, is applied to learning one layer MLP in (Janzamin et al. , 2015). We plan to extend our learning framework to non-differentiable data using general weak learning oracles."
    }, {
      "heading" : "A Proof for Lemma 3.2: the strong learner is a ResNet",
      "text" : "Proof. In our algorithm, the input of the next module is the output of the current module\ngt+1(x) = ft(gt(x)) + gt(x), (7)\nwe thus obtain that each weak learning module is\nht(x) = αt+1w ⊤ t+1(ft(gt(x)) + gt(x))− αtw⊤t gt(x) (8)\n= αt+1w ⊤ t+1gt+1(x)− αtw⊤t gt(x), (9)\nand similarly\nht+1 = αt+2w ⊤ t+2gt+2(x)− αt+1w⊤t+1gt+1(x). (10)\nTherefore the sum over ht(x) and ht+1(x) is\nht(x) + ht+1(x) = αt+2w ⊤ t+2gt+2(x) − αtw⊤t gt(x) (11)\nAnd we further see that the weighted summation over all ht(x) is a telescoping sum T∑\nt=1\nht(x) = αT+1w ⊤ T+1gT+1(x)− α1w⊤1 g1(x) = αT+1w⊤T+1gT+1(x). (12)"
    }, {
      "heading" : "B Proof for Theorem 4.2: binary class telescoping sum boosting theory",
      "text" : "Proof. We will use a 0-1 loss to measure the training error. In our analysis, the 0-1 loss is bounded by exponential loss.\nThe training error is therefore bounded by\nPr i∼D1\n(p(αT+1w ⊤ T+1gT+1(xi)) 6= yi) (13)\n= m∑\ni=1\nD1(i)1{σ̃(αT+1w⊤T+1gT+1(xi)) 6= yi} (14)\n=\nm∑\ni=1\nD1(i)1\n{ σ̃ ( T∑\nt=1\nht(xi) ) 6= yi } (15)\n≤ m∑\ni=1\nD1(i) exp { −yi T∑\nt=1\nht(xi)\n} (16)\n=\nm∑\ni=1\nDT+1(i)\nT∏\nt=1\nZt (17)\n= T∏\nt=1\nZt (18)\nwhere Zt = m∑ i=1 Dt(i) exp (−yiht(xi)).\nWe choose αt+1 to minimize Zt.\n∂Zt ∂αt+1\n= − m∑\ni=1\nDt(i)yiot+1 exp (−yiht(xi)) (19)\n= −Zt m∑\ni=1\nDt+1(i)yiot+1(i) = 0 (20)\nFurthermore each learning module is bounded as we see in the following analysis. We obtain\nZt = m∑\ni=1\nDt(i)e −yiht(xi) (21)\n=\nm∑\ni=1\nDt(i)e −αt+1yiot+1(xi)+αtyiot(xi) (22)\n≤ m∑\ni=1\nDt(i)e −αt+1yiot+1(xi)\nm∑\ni=1\nDt(i)e αtyiot(xi) (23)\n=\nm∑\ni=1\nDt(i)e −αt+1\n1+yiot+1(xi) 2 +αt+1 1−yiot+1(xi) 2\nm∑\ni=1\nDt(i)e αt\n1+yiot(xi) 2 −αt 1−yiot(xi)\n2 (24)\n≤ m∑\ni=1\nDt(i)\n( 1 + yiot+1(xi)\n2 e−αt+1 + 1− yiot+1(xi) 2\neαt+1 ) · (25)\nm∑\ni=1\nDt(i)\n( 1 + yiot(xi)\n2 eαt + 1− yiot(xi) 2\ne−αt )\n(26)\n=\nm∑\ni=1\nDt(i)\n( 1 + yiot+1(xi)\n2 e−αt+1 + 1− yiot+1(xi) 2\neαt+1 ) eαt + e−αt\n2 (27)\n= m∑\ni=1\nDt(i)\n( e−αt+1 + eαt+1\n2 + e−αt+1 − eαt+1 2 yiot+1(xi)\n) eαt + e−αt\n2 (28)\n=\n( e−αt+1 + eαt+1\n2 + e−αt+1 − eαt+1 2 γ̃t\n) eαt + e−αt\n2 (29)\nEquation (23) is due to the non-positive correlation between exp(−yot+1(x)) and exp(yot(x)). Jensen’s inequality in Equation (26) holds only when |yiot+1(xi)| ≤ 1 which is satisfied by the definition of the weak learning module.\nThe algorithm chooses αt+1 to minimize Zt. We achieve an upper bound on Zt,\n√ 1−γ̃2t\n1−γ̃2t−1 by\nminimizing the bound in Equation (29)\nZt ≤ ( e−αt+1 + eαt+1\n2 + e−αt+1 − eαt+1 2 γ̃t\n) eαt + e−αt\n2\n∣∣∣∣ αt+1= 1 2 ln( 1+γ̃t 1−γ̃t ) (30)\n= √ 1− γ̃2t 1− γ̃2t−1 = √ 1− γ2t (31)\nTherefore over the T modules, the training error is upper bounded as follows\nPr i∼D\n(p(αT+1w ⊤ T+1gT+1(xi))) 6= yi) ≤\nT∏\nt=1\n√ 1− γ2t ≤ T∏\nt=1\n√ 1− γ2 = exp ( −1 2 Tγ2 ) (32)\nOverall, Algorithm 1 leads us to consistent learning of ResNet."
    }, {
      "heading" : "C Proof for Lemma 4.3: Generalization Bound",
      "text" : "Rademacher complexity technique is powerful for measuring the complexity of H any family of functions h : X → R, based on easiness of fitting any dataset using classifiers in H (where X is any space). Let S =< x1, . . . , xm > be a sample of m points in X . The empirical Rademacher complexity ofH with respect to S is defined to be\nRS(H) def= Eσ [ sup h∈H 1 m m∑\ni=1\nσih(xi)\n] (33)\nwhere σ is the Rademacher variable. The Rademacher complexity on m data points drawn from distribution D is defined by Rm(H) = ES∼D [RS(H)] . (34) Proposition C.1. (Theorem 1 Cortes et al. (2014)) LetH be a hypothesis set admitting a decomposition H = ∪li=1Hi for some l > 1. Hi are distinct hypothesis sets. Let S be a random sequence of m points chosen independently from X according to some distribution D. For θ > 0 and any H = ∑T t=1 ht, with probability at least 1− δ,\nPr D (yH(x) ≤ 0) ≤ Pr S (yH(x) ≤ θ) + 4 θ\nT∑\nt=1\nRm(Hkt) + 2\nθ\n√ log l\nm\n+\n√\n⌈ 4 θ2 log\n( θ2m\nlog l\n) ⌉ log l\nm +\nlog 2 δ\n2m (35)\nfor all ht ∈ Hkt . Lemma C.2. Let h̃ = w̃⊤ f̃ , where w̃ ∈ Rn, f̃ ∈ Rn. Let H̃ and F̃ be two hypothesis sets, and h̃ ∈ H̃ , f̃j ∈ F̃ , ∀j ∈ [n]. The Rademacher complexity of H̃ and F̃ with respect to m points from D are related as follows\nRm(H̃) = ‖w̃‖1Rm(F̃). (36)\nC.1 ResNet Module Hypothesis Space\nLet n be the number of channels in ResNet, i.e., the number of input or output neurons in a module ft(gt(x)). We have proved that ResNet is equivalent as\nF (x) = w⊤ T∑\nt=1\nf(gt(x)) (37)\nWe define the family of functions that each neuron ft,j , ∀j ∈ [n] belong to as Ft = {x → ut−1,j(σ ◦ ft−1)(x) : ut−1,j ∈ Rn, ‖ut−1,j‖1 ≤ Λt,t−1, ft−1,i ∈ Ft−1} (38) where ut−1,j denotes the vector of weights for connections from unit j to a lower layer t − 1, σ ◦ ft−1 denotes element-wise nonlinear transformation on ft−1. The output layer of each module is connected to the output layer of previous module. We consider 1-layer modules for convenience of analysis.\nTherefore in ResNet with probability at least 1− δ,\nPr D (yF (x) ≤ 0) ≤ Pr S (yF (x) ≤ θ) + 4 θ\nT∑\nt=1\n‖w‖1Rm(Ft) + 2\nθ\n√ logT\nm\n+\n√\n⌈ 4 θ2 log\n( θ2m\nlogT\n) ⌉ logT\nm +\nlog 2 δ\n2m (39)\nfor all ft ∈ Ft.\nDefine the maximum infinity norm over samples as r∞ def = ES∼D [ maxi∈[m]‖xi‖∞ ] and the product of l1 norm bound on weights as Λt def = ∏t\nt′=1 2Λt′,t′−1. According to lemma 2 of Cortes et al. (2016), the empirical Rademacher complexity is bounded as a function of r∞, Λt and n:\nRm(Ft) ≤ r∞Λt √ log(2n)\n2m (40)\nOverall, with probability at least 1− δ,\nPr D (yF (x) ≤ 0) ≤ Pr S (yF (x) ≤ θ) +\n4‖w‖1r∞ √ log(2n) 2m\nθ\nT∑\nt=1\nΛt\n+ 2\nθ\n√ logT\nm +\n√\n⌈ 4 θ2 log\n( θ2m\nlogT\n) ⌉ logT\nm +\nlog 2 δ\n2m (41)\nfor all ft ∈ Ft."
    }, {
      "heading" : "D Proof for Theorem D: Margin and Generalization Bound",
      "text" : "Theorem D.1. [ Generalization error bound ] Given algorithm 1, the fraction of training examples with margin at most θ is at most (1 + 21√ γ̃T+1 −1 ) θ 2 exp(− 12γ2T ). And the generalization error PrD(yF (x) ≤ 0) satisfies\nPr D (yF (x) ≤ 0) ≤ (1 + 21\nγ̃T+1 − 1)\nθ 2 exp(−1\n2 γ2T )\n+ 4C0r∞\nθ\n√ log(2n)\n2m\nT∑\nt=1\nΛt + 2\nθ\n√ logT\nm + β(θ,m, T, δ) (42)\nwith probability at least 1− δ for β(θ,m, T, δ) def= √⌈\n4 θ2\nlog (\nθ2m log T )⌉ log T m + log 2 δ 2m .\nNow the proof for Theorem D is the following.\nProof. The fraction of examples in sample set S being smaller than θ is bounded\nPr S (yF (x) ≤ θ) ≤ 1 m\nm∑\ni=1\n1{yiF (xi) ≤ θ} (43)\n= 1\nm\nm∑\ni=1\n1{yi T∑\nt=1\nht(xi) ≤ θαT+1} (44)\n≤ 1 m\nm∑\ni=1\nexp(−yi T∑\nt=1\nht(xi) + θαT+1) (45)\n= exp(θαT+1) 1\nm\nm∑\ni=1\nexp(−yi T∑\nt=1\nht(xi)) (46)\n= exp(θαT+1)\nT∏\nt=1\nZt (47)\nTo bound exp(θαT+1) = √ (1+γ̃T+11−γ̃T+1 ) θ , we first bound γ̃T+1: We know that ∑T t=1 ∏T t′=t+1(1 − γ2t′)γ 2 t ≤ (1 − γ2)T−tγ2 for all ∀γt ≥ γ2 + ǫ if γ2 ≥ 1−ǫ2 . Therefore ∀ γt ≥ γ2 + ǫ and γ2 ≥ 1−ǫ2\nγ̃2T+1 = (1− γ2T )γ̃2T + γ2T (48)\n=\nT∑\nt=1\nT∏\nt′=t+1\n(1 − γ2t′)γ2t + T∏\nt=1\n(1− γ2t )γ̃21 (49)\n≤ T∑\nt=1\n(1− γ2)T−tγ2 + (1− γ2)T γ̃21 (50)\n=\nT−1∑\nt=0\n(1− γ2)tγ2 + (1− γ2)T γ̃21 (51)\n= 1− (1− γ2)T + (1− γ2)T γ̃21 (52) = 1− (1− γ̃21)(1− γ2)T (53)\nTherefore\nPr S (yF (x) ≤ θ) ≤ exp(θαT+1)\nT∏\nt=1\nZt (54)\n= ( 1 + γ̃T+1 1− γ̃T+1 ) θ 2\nT∏\nt=1\nZt (55)\n= ( 1 + γ̃T+1 1− γ̃T+1 ) θ 2\nT∏\nt=1\n√ 1− γ2t (56)\n= (1 + 2\n1 γ̃T+1\n− 1) θ 2 exp(−1 2 γ2T ) (57)\n≤ (1 + 21√ 1−(1−γ̃21)(1−γ2)T − 1) θ 2 exp(−1 2 γ2T ) (58)\nAs T → ∞, PrS(yF (x) ≤ θ) ≤ 0 as exp(− 12γ2T ) decays faster than (1 + 21√ 1−(1−γ̃21 )(1−γ 2)T −1 ) θ 2 ."
    }, {
      "heading" : "E Telescoping Sum Boosting for Multi-calss Classification",
      "text" : "Recall that the weak module classifier is defined as\nht(x) = αt+1ot+1(x)− αtot(x) ∈ RC , (59) where ot(x) ∈ ∆C−1. The weak learning condition for multi-class classification is different from the binary classification stated in the previous section, although minimal demands placed on the weak module classifier require prediction better than random on any distribution over the training set intuitively.\nWe now define the weak learning condition. It is again inspired by the slightly better than random idea, but requires a more sophisticated analysis in the multi-class setting.\nE.1 Cost Matrix\nIn order to characterize the training error, we introduce the cost matrix C ∈ Rm×C where each row denote the cost incurred by classifying that example into one of the C categories. We will bound the training error using exponential loss, and under the exponential loss function defined as in Definition F.1, the optimal cost function used for best possible training error is therefore determined.\nLemma E.1. The optimal cost function under the exponential loss is\nCt(i, l) = { exp (st(xi, l)− st(xi, yi)) if l 6= yi − ∑\nl′ 6=yi exp (st(xi, l\n′)− st(xi, yi)) if l = yi (60)\nwhere st(x) = t∑\nτ=1 hτ (x).\nE.2 Weak Learning Condition\nDefinition E.2. Let γ̃t+1 = −\nm∑ i=1 <Ct(i,:),ot+1(xi)>\nm∑\ni=1\n∑\nl 6=yi\nCt(i,l) and γ̃t =\n− m∑\ni=1 <Ct−1(i,:),ot(xi)>\nm∑\ni=1\n∑\nl 6=yi\nCt−1(i,l) . A multi-class\nweak module classifier ht(x) = αt+1ot+1(x) − αtot(x) satisfies the γ-weak learning condition if γ̃2t+1−γ̃ 2 t\n1−γ̃2t ≥ γ2 > 0.\nWe propose a novel learning algorithm using the optimal edge-over-randomcost function for training ResNet under multi-class classification task as in Algorithm 3.\nAlgorithm 3 BoostResNet: telescoping sum boosting for multi-class classification Input: Given (x1, y1), . . . (xm, ym) where yi ∈ Y = {1, . . . , C} and a threshold γ Output: {ft(·),∀t} andWT+1 ⊲ Discardwt+1, ∀t 6= T 1: Initialize t ← 0, γ̃0 ← 1, α0 ← 0, o0 ← 0 ∈ RC , s0(xi, l) = 0, ∀i ∈ [m], l ∈ Y 2: Initialize cost functionC0(i, l) ← { 1 if l 6= yi 1− C if l = yi\n3: while γt > γ do 4: ft(·), αt+1,Wt+1, ot+1(x) ← Algorithm 4(gt(x),Ct, ot(x), αt) 5: Compute γt ← √\nγ̃2t+1−γ̃2t 1−γ̃2t\n⊲ where γ̃t+1 ← −\nm∑\ni=1 Ct(i,:)·ot+1(xi) m∑\ni=1\n∑\nl 6=yi\nCt(i,l)\n6: Update st+1(xi, l) ← st(xi, l) + ht(xi, l) ⊲ where ht(xi, l) = αt+1ot+1(xi, l)− αtot(xi, l) 7: Update cost functionCt+1(i, l) ← { est+1(xi,l)−st+1(xi,yi) if l 6= yi − ∑\nl′ 6=yi est+1(xi,l ′)−st+1(xi,yi) if l = yi\n8: t ← t+ 1 9: end while 10: T ← t− 1\nAlgorithm 4 BoostResNet: oracle implementation for training a ResNet module (multi-class)\nInput: gt(x),st,ot(x) and αt Output: ft(·), αt+1,Wt+1 and ot+1(x) 1: (ft, αt+1,Wt+1) ← arg min\n(f,α,V ) m∑ i=1 ∑ l 6=yi eαV ⊤[f(gt(xi),l)−f(gt(xi),yi)+gt(xi,l)−gt(xi,yi)]\n2: ot+1(x) ← W⊤t+1 [ft(gt(x)) + gt(x)]\nTheorem E.3. The training error of a T -module ResNet using Algorithm 3and 4 decays exponentially with the depth of the ResNet T ,\nC − 1 m\nm∑\ni=1\nLexpη (sT (xi)) ≤ (C − 1)e− 1 2Tγ 2\n(61)\nif the weak module classifier ht(x) satisfies the γ-weak learning condition ∀t ∈ [T ].\nThe exponential loss function defined as in Definition F.1\nE.3 Oracle Implementation\nWe implement an oracle to minimize Zt def = m∑ i=1 ∑ l 6=yi est(xi,l)−st(xi,yi)eht(xi,l)−ht(xi,yi) given current state st and hypothesis module ot(x). Therefore minimizing Zt is equivalent to the following.\nmin (f,α,V )\nm∑\ni=1\n∑\nl 6=yi\nest(xi,l)−st(xi,yi)e−αt(ot(xi,l)−ot(xi,yi))eαV ⊤[f(gt(xi),l)−f(gt(xi),yi)+gt(xi,l)−gt(xi,yi)]\n(62)\n≡ min (f,α,V )\nm∑\ni=1\n∑\nl 6=yi\neαV ⊤[f(gt(xi),l)−f(gt(xi),yi)+gt(xi,l)−gt(xi,yi)] (63)\n≡ min α,f,v\nm∑\ni=1\ne−αv ⊤[f(xi,yi)+gt(xi,yi)]\n∑\nl 6=yi\neαv ⊤[f(xi,l)+gt(xi,l)] (64)"
    }, {
      "heading" : "F Proof for Theorem E.3 multi-class boosting theory",
      "text" : "Proof. To characterize the training error, we use the exponential loss function\nDefinition F.1. Define loss function for a multi-class hypothesisH(xi) on a sample (xi, yi) as\nLexpη (H(xi), yi) = ∑\nl 6=yi\nexp ((H(xi, l)−H(xi, yi))) . (65)\nDefine the accumulated weak learner st(xi, l) = t∑\nt′=1\nht′(xi, l) and the loss Zt =\nm∑ i=1 ∑ l 6=yi exp(st(xi, l)− st(xi, yi)) exp(ht(xi, l)− ht(xi, yi)).\nRecall that st(xi, l) = t∑\nt′=1\nht′(xi, l) = αt+1W ⊤ t+1gt+1(xi), the loss for a T -module multiclass\nresnet is thus\nPr i∼D1\n(p(αT+1W ⊤ T+1gT+1(xi)) 6= yi) ≤\n1\nm\nm∑\ni=1\nLexpη (sT (xi)) (66)\n≤ 1 m\nm∑\ni=1\n∑\nl 6=yi\nexp (η(sT (xi, l)− sT (xi, yi))) (67)\n≤ 1 m ZT (68)\n=\nT∏\nt=1\nZt Zt−1\n(69)\nNote that Z0 = 1 m as the initial accumulated weak learners s0(xi, l) = 0.\nThe loss fraction between module t and t− 1, Zt Zt−1 , is related to Zt−Zt−1 as ZtZt−1 = Zt−Zt−1 Zt−1 +1.\nThe Zt is bounded Zt = m∑\ni=1\n∑\nl 6=yi\nexp(st(xi, l)− st(i, yi) + ht(xi, l)− ht(xi, yi)) (70)\n≤ m∑\ni=1\n∑\nl 6=yi\nest(xi,l)−st(xi,yi)eαt+1ot+1(xi,l)−αt+1ot+1(xi,yi) m∑\ni=1\n∑\nl 6=yi\nest(xi,l)−st(xi,yi)e−αtot(xi,l)+αtot(xi,yi)\n(71)\n≤ m∑\ni=1\n∑\nl 6=yi\nest(xi,l)−st(xi,yi) ( e−αt+1 + eαt+1\n2 + e−αt+1 − eαt+1 2\n(ot+1(xi, yi)− ot+1(xi, l)) )\nm∑\ni=1\n∑\nl 6=yi\nest−1(xi,l)−st−1(xi,yi) ( eαt + e−αt\n2\n) (72)\n=( e−αt+1 + eαt+1 − 2\n2 Zt−1 + eαt+1 − e−αt+1 2 m∑\ni=1\n< Ct(xi, :), ot+1(xi, :) >)\n( eαt + e−αt\n2\n)\n(73)\n≤(e −αt+1 + eαt+1 − 2\n2 Zt−1 + eαt+1 − e−αt+1 2 m∑\ni=1\n< Ct(xi, :), Uγ̃t(xi, :) >)\n( eαt + e−αt\n2\n)\n(74)\n=( e−αt+1 + eαt+1 − 2\n2 Zt−1 + eαt+1 − e−αt+1 2\n(−γ̃t)Zt−1) ( eαt + e−αt\n2\n) (75)\nTherefore Zt Zt−1 ≤ ( e−αt+1 + eαt+1 2 + e−αt+1 − eαt+1 2 γ̃t )( eαt + e−αt 2 ) (76)\nThe algorithm chooses αt+1 to minimize Zt. We achieve an upper bound on Zt,\n√ 1−γ̃2t\n1−γ̃t−12\nby minimizing the bound in Equation (76)\nZt ≤ ( e−αt+1 + eαt+1\n2 + e−αt+1 − eαt+1 2 γ̃t\n) eαt + e−αt\n2\n∣∣∣∣ αt+1= 1 2 ln( 1+γ̃t 1−γ̃t ) (77)\n= √ 1− γ̃2t 1− γ̃2t−1 = √ 1− γ2t (78)\nTherefore over the T modules, the training error is upper bounded as follows\nPr i∼D\n(p(αT+1w ⊤ T+1gT+1(xi))) 6= yi) ≤\nT∏\nt=1\n√ 1− γ2t ≤ T∏\nt=1\n√ 1− γ2 = exp ( −1 2 Tγ2 ) (79)\nOverall, Algorithm 3 and 4 leads us to consistent learning of ResNet."
    }, {
      "heading" : "G Minimal Weak Learning Condition",
      "text" : "Mukherjee and SchapireMukherjee & Schapire (2013) introduced a sufficient and necessary weak learning condition based on a concept called edge over random.\nIt is intuitive to restrict the cost matrices to a space of edge-over-random cost-matrices Ceor who put the least cost on the correct label. Definition G.1. The space of edge-over-random cost matrices Ceor ⊆ Rm×C is the space of cost matrices C ∈ Ceor that satisfies\nC(i, yi) ≤ C(i, l), ∀l 6= yi, ∀i ∈ {1, . . . ,m}. (80)\nLet us define a random classifier as a baseline predictor B ∈ Rm×C , where each row lies on a simplexB(i, :) ∈ ∆{1, . . . , C}. We consider the space of baselines, called edge-over-random,who have a faint clue about the correct answer. Definition G.2. The space of edge-over-random baselines Mukherjee & Schapire (2013) Beorγ ⊆ R\nm×C is the space of baselinesB ∈ Beorγ that satisfy B(i, yi) ≥ B(i, l) + γ, ∀l 6= yi, ∀i ∈ {1, . . . ,m}. (81)\nNote that cost function for sample xi is C(i, :) ∈ R1×C , weak module classifier vector h(txi) ∈ RC and baseline predictorB(i, :) ∈ R1×C . Definition G.3. A multi-class weak module classifier ht(x) = αt+1ot+1−αtot satisfies the γ-weak learning condition if ∀C ∈ Ceor, ∃ hV,f(·),αt such that\nm∑\ni=1\nC(i, :)h V,f(·),W t (xi) ≤ max\nB∈Beorγ\nm∑\ni=1\nC(i, :)B(i, :)⊤. (82)\nLemma G.4. A weak classifier space H is boostable if and only if H satisfies the weak-learning condition defined in Definition G.3.\nRefer to Mukherjee and Schapire Mukherjee & Schapire (2013) for the proof."
    }, {
      "heading" : "H Experiments",
      "text" : "We investigate e2eBP training performance on various depth ResNet. Surprisingly, we observe a training error degradation for e2eBP although the ResNet’s identity loop is supposed to alleviate this problem. Despite the presence of identity loops, the e2eBP eventually is susceptible to spurious local optima. This phenomenon is explored further in Figures 6a and 6b, which respectively show how training and test accuracies vary throughout the fitting process. Our proposed sequential training procedure, BoostResNet, relieves gradient instability issues, and continues to perform well as depth increases."
    } ],
    "references" : [ {
      "title" : "The Shattered Gradients Problem: If resnets are the answer, then what is the question? arXiv preprint arXiv:1702.08591",
      "author" : [ "Balduzzi", "David", "Frean", "Marcus", "Leary", "Lennox", "JP Lewis", "Ma", "Kurt Wan-Duo", "McWilliams", "Brian" ],
      "venue" : null,
      "citeRegEx" : "Balduzzi et al\\.,? \\Q2017\\E",
      "shortCiteRegEx" : "Balduzzi et al\\.",
      "year" : 2017
    }, {
      "title" : "Learning long-term dependencies with gradient descent is difficult",
      "author" : [ "Bengio", "Yoshua", "Simard", "Patrice", "Frasconi", "Paolo" ],
      "venue" : "IEEE transactions on neural networks,",
      "citeRegEx" : "Bengio et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Bengio et al\\.",
      "year" : 1994
    }, {
      "title" : "Deep boosting. Pages 1179–1187",
      "author" : [ "Cortes", "Corinna", "Mohri", "Mehryar", "Syed", "Umar" ],
      "venue" : "of: Proceedings of the 31st International Conference on Machine Learning (ICML-14)",
      "citeRegEx" : "Cortes et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Cortes et al\\.",
      "year" : 2014
    }, {
      "title" : "Adaptive subgradientmethods for online learning and stochastic optimization",
      "author" : [ "Duchi", "John", "Hazan", "Elad", "Singer", "Yoram" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Duchi et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Duchi et al\\.",
      "year" : 2011
    }, {
      "title" : "A desicion-theoretic generalization of on-line learning and an application to boosting",
      "author" : [ "Freund", "Yoav", "Schapire", "Robert E" ],
      "venue" : "Pages 23–37",
      "citeRegEx" : "Freund et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Freund et al\\.",
      "year" : 1995
    }, {
      "title" : "Escaping From Saddle Points-Online Stochastic Gradient for Tensor Decomposition",
      "author" : [ "Ge", "Rong", "Huang", "Furong", "Jin", "Chi", "Yuan", "Yang" ],
      "venue" : null,
      "citeRegEx" : "Ge et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Ge et al\\.",
      "year" : 2015
    }, {
      "title" : "Fast r-cnn",
      "author" : [ "Girshick", "Ross." ],
      "venue" : "Pages 1440–1448 of: Proceedings of the IEEE International Conference on Computer Vision.",
      "citeRegEx" : "Girshick and Ross.,? 2015",
      "shortCiteRegEx" : "Girshick and Ross.",
      "year" : 2015
    }, {
      "title" : "Rich feature hierarchies for accurate object detection and semantic segmentation. Pages 580–587",
      "author" : [ "Girshick", "Ross", "Donahue", "Jeff", "Darrell", "Trevor", "Malik", "Jitendra" ],
      "venue" : "of: Proceedings of the IEEE conference on computer vision and pattern recognition",
      "citeRegEx" : "Girshick et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Girshick et al\\.",
      "year" : 2014
    }, {
      "title" : "Understanding the difficulty of training deep feedforward neural networks. Pages 249–256",
      "author" : [ "Glorot", "Xavier", "Bengio", "Yoshua" ],
      "venue" : "of: Aistats,",
      "citeRegEx" : "Glorot et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Glorot et al\\.",
      "year" : 2010
    }, {
      "title" : "Identity Matters in Deep Learning",
      "author" : [ "Hardt", "Moritz", "Ma", "Tengyu" ],
      "venue" : "arXiv preprint arXiv:1611.04231",
      "citeRegEx" : "Hardt et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Hardt et al\\.",
      "year" : 2016
    }, {
      "title" : "Convolutional neural networks at constrained time cost. Pages 5353–5360",
      "author" : [ "He", "Kaiming", "Sun", "Jian" ],
      "venue" : "of: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition",
      "citeRegEx" : "He et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "He et al\\.",
      "year" : 2015
    }, {
      "title" : "Spatial pyramid pooling in deep convolutional networks for visual recognition. Pages 346–361",
      "author" : [ "He", "Kaiming", "Zhang", "Xiangyu", "Ren", "Shaoqing", "Sun", "Jian" ],
      "venue" : "of: European Conference on Computer Vision. Springer",
      "citeRegEx" : "He et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "He et al\\.",
      "year" : 2014
    }, {
      "title" : "Delving deep into rectifiers: Surpassing human-level performance on imagenet classification",
      "author" : [ "He", "Kaiming", "Zhang", "Xiangyu", "Ren", "Shaoqing", "Sun", "Jian" ],
      "venue" : "Pages 1026–1034 of: Proceedings of the IEEE international conference on computer vision",
      "citeRegEx" : "He et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "He et al\\.",
      "year" : 2015
    }, {
      "title" : "Deep residual learning for image recognition. Pages 770–778",
      "author" : [ "He", "Kaiming", "Zhang", "Xiangyu", "Ren", "Shaoqing", "Sun", "Jian" ],
      "venue" : "of: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition",
      "citeRegEx" : "He et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "He et al\\.",
      "year" : 2016
    }, {
      "title" : "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
      "author" : [ "Ioffe", "Sergey", "Szegedy", "Christian" ],
      "venue" : "arXiv preprint arXiv:1502.03167",
      "citeRegEx" : "Ioffe et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Ioffe et al\\.",
      "year" : 2015
    }, {
      "title" : "Beating the perils of non-convexity: Guaranteed training of neural networks using tensor methods",
      "author" : [ "Janzamin", "Majid", "Sedghi", "Hanie", "Anandkumar", "Anima" ],
      "venue" : "arXiv preprint arXiv:1506.08473",
      "citeRegEx" : "Janzamin et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Janzamin et al\\.",
      "year" : 2015
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "Kingma", "Diederik", "Ba", "Jimmy" ],
      "venue" : "arXiv preprint arXiv:1412.6980",
      "citeRegEx" : "Kingma et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kingma et al\\.",
      "year" : 2014
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks. Pages 1097–1105 of: Advances in neural information processing systems",
      "author" : [ "Krizhevsky", "Alex", "Sutskever", "Ilya", "Hinton", "Geoffrey E" ],
      "venue" : null,
      "citeRegEx" : "Krizhevsky et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Krizhevsky et al\\.",
      "year" : 2012
    }, {
      "title" : "Backpropagation applied to handwritten zip code recognition",
      "author" : [ "LeCun", "Yann", "Boser", "Bernhard", "Denker", "John S", "Henderson", "Donnie", "Howard", "Richard E", "Hubbard", "Wayne", "Jackel", "Lawrence D" ],
      "venue" : "Neural computation,",
      "citeRegEx" : "LeCun et al\\.,? \\Q1989\\E",
      "shortCiteRegEx" : "LeCun et al\\.",
      "year" : 1989
    }, {
      "title" : "Gradient-based learning applied to document recognition",
      "author" : [ "LeCun", "Yann", "Bottou", "Léon", "Bengio", "Yoshua", "Haffner", "Patrick" ],
      "venue" : "Proceedings of the IEEE,",
      "citeRegEx" : "LeCun et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "LeCun et al\\.",
      "year" : 1998
    }, {
      "title" : "Efficient backprop. Pages 9–48 of: Neural networks: Tricks of the trade",
      "author" : [ "LeCun", "Yann A", "Bottou", "Léon", "Orr", "Genevieve B", "Müller", "Klaus-Robert" ],
      "venue" : null,
      "citeRegEx" : "LeCun et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "LeCun et al\\.",
      "year" : 2012
    }, {
      "title" : "Fully convolutional networks for semantic segmentation. Pages 3431–3440",
      "author" : [ "Long", "Jonathan", "Shelhamer", "Evan", "Darrell", "Trevor" ],
      "venue" : "of: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition",
      "citeRegEx" : "Long et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Long et al\\.",
      "year" : 2015
    }, {
      "title" : "Deep vs. shallow networks: An approximation theory perspective",
      "author" : [ "Mhaskar", "Hrushikesh N", "Poggio", "Tomaso" ],
      "venue" : "Analysis and Applications,",
      "citeRegEx" : "Mhaskar et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Mhaskar et al\\.",
      "year" : 2016
    }, {
      "title" : "A theory of multiclass boosting",
      "author" : [ "Mukherjee", "Indraneel", "Schapire", "Robert E" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Mukherjee et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Mukherjee et al\\.",
      "year" : 2013
    }, {
      "title" : "A method for unconstrained convex minimization problem with the rate of convergence O (1/k2)",
      "author" : [ "Nesterov", "Yurii." ],
      "venue" : "Pages 543–547 of: Doklady an SSSR, vol. 269.",
      "citeRegEx" : "Nesterov and Yurii.,? 1983",
      "shortCiteRegEx" : "Nesterov and Yurii.",
      "year" : 1983
    }, {
      "title" : "Reading digits in natural images with unsupervised feature learning. Page 5 of: NIPS workshop on deep learning and unsupervised feature",
      "author" : [ "Netzer", "Yuval", "Wang", "Tao", "Coates", "Adam", "Bissacco", "Alessandro", "Wu", "Bo", "Ng", "Andrew Y" ],
      "venue" : null,
      "citeRegEx" : "Netzer et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Netzer et al\\.",
      "year" : 2011
    }, {
      "title" : "On the momentum term in gradient descent learning algorithms",
      "author" : [ "Qian", "Ning." ],
      "venue" : "Neural networks, 12(1), 145–151.",
      "citeRegEx" : "Qian and Ning.,? 1999",
      "shortCiteRegEx" : "Qian and Ning.",
      "year" : 1999
    }, {
      "title" : "Faster r-cnn: Towards real-time object detection with region proposal networks. Pages 91–99 of: Advances in neural information processing systems",
      "author" : [ "Ren", "Shaoqing", "He", "Kaiming", "Girshick", "Ross", "Sun", "Jian" ],
      "venue" : null,
      "citeRegEx" : "Ren et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Ren et al\\.",
      "year" : 2015
    }, {
      "title" : "The cross-entropy method: a unified approach to combinatorial optimization, Monte-Carlo simulation and machine learning",
      "author" : [ "Rubinstein", "Reuven Y", "Kroese", "Dirk P" ],
      "venue" : null,
      "citeRegEx" : "Rubinstein et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Rubinstein et al\\.",
      "year" : 2013
    }, {
      "title" : "A survey of decision tree classifier methodology",
      "author" : [ "Safavian", "S Rasoul", "Landgrebe", "David" ],
      "venue" : "IEEE transactions on systems, man, and cybernetics,",
      "citeRegEx" : "Safavian et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Safavian et al\\.",
      "year" : 1991
    }, {
      "title" : "Exact solutions to the nonlinear dynamics of learning in deep linear neural networks. arXiv preprint arXiv:1312.6120",
      "author" : [ "Saxe", "Andrew M", "McClelland", "James L", "Ganguli", "Surya" ],
      "venue" : null,
      "citeRegEx" : "Saxe et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Saxe et al\\.",
      "year" : 2013
    }, {
      "title" : "Overfeat: Integrated recognition, localization and detection using convolutional networks. arXiv preprint arXiv:1312.6229",
      "author" : [ "Sermanet", "Pierre", "Eigen", "David", "Zhang", "Xiang", "Mathieu", "Michaël", "Fergus", "Rob", "LeCun", "Yann" ],
      "venue" : null,
      "citeRegEx" : "Sermanet et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Sermanet et al\\.",
      "year" : 2013
    }, {
      "title" : "SelfieBoost: A Boosting Algorithm for Deep Learning",
      "author" : [ "Shalev-Shwartz", "Shai." ],
      "venue" : "arXiv preprint arXiv:1411.3436.",
      "citeRegEx" : "Shalev.Shwartz and Shai.,? 2014",
      "shortCiteRegEx" : "Shalev.Shwartz and Shai.",
      "year" : 2014
    }, {
      "title" : "Very deep convolutional networks for large-scale image recognition",
      "author" : [ "Simonyan", "Karen", "Zisserman", "Andrew" ],
      "venue" : "arXiv preprint arXiv:1409.1556",
      "citeRegEx" : "Simonyan et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Simonyan et al\\.",
      "year" : 2014
    }, {
      "title" : "Convolutional networks and learning invariant to homogeneous multiplicative scalings",
      "author" : [ "Tygert", "Mark", "Szlam", "Arthur", "Chintala", "Soumith", "Ranzato", "Marc’Aurelio", "Tian", "Yuandong", "Zaremba", "Wojciech" ],
      "venue" : "arXiv preprint arXiv:1506.08230",
      "citeRegEx" : "Tygert et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Tygert et al\\.",
      "year" : 2015
    }, {
      "title" : "ADADELTA: an adaptive learning rate method",
      "author" : [ "Zeiler", "Matthew D." ],
      "venue" : "arXiv preprint arXiv:1212.5701.",
      "citeRegEx" : "Zeiler and D.,? 2012",
      "shortCiteRegEx" : "Zeiler and D.",
      "year" : 2012
    }, {
      "title" : "Visualizing and understanding convolutional networks. Pages 818–833",
      "author" : [ "Zeiler", "Matthew D", "Fergus", "Rob" ],
      "venue" : "of: European conference on computer vision. Springer",
      "citeRegEx" : "Zeiler et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Zeiler et al\\.",
      "year" : 2014
    }, {
      "title" : "LetH be a hypothesis set admitting a decomposition H",
      "author" : [ "Cortes" ],
      "venue" : null,
      "citeRegEx" : "Cortes,? \\Q2014\\E",
      "shortCiteRegEx" : "Cortes",
      "year" : 2014
    }, {
      "title" : "Let us define a random classifier as a baseline predictor B ∈ Rm×C , where each row lies on a simplexB(i",
      "author" : [ ],
      "venue" : "Beor",
      "citeRegEx" : "C..,? \\Q2013\\E",
      "shortCiteRegEx" : "C..",
      "year" : 2013
    }, {
      "title" : "A weak classifier space H is boostable if and only if H satisfies the weak-learning condition defined in Definition G.3",
      "author" : [ "Lemma G" ],
      "venue" : null,
      "citeRegEx" : "G.4.,? \\Q2013\\E",
      "shortCiteRegEx" : "G.4.",
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 17,
      "context" : "5 Experiments We compare our proposed BoostResNet algorithm with e2eBP training a ResNet on the MNIST (LeCun et al. , 1998) and street view house numbers (SVHN) (Netzer et al. , 2011) benchmark datasets. Two different types of architectures are tested: multilayer perceptron residual network (MLP-ResNet) and convolutional neural network residual network (CNN-ResNet). In each experiment the architecture of both algorithms is identical, and they are both initialized with the same random seed. Our experiments were programmed in the Torch deep learning framework for Lua and executed on NVIDIA Tesla P100 GPUs. In our training, a mini-batch size 100 is used for both BoostResNet and e2eBP. The learning rate is initialized at 1e-2 with a decaying rate of 1e-4. The optimization method used in e2eBP is the stateof-the-art Adaptive Moment Estimation (Adam) Kingma & Ba (2014) variant of SGD introduced earlier.",
      "startOffset" : 103,
      "endOffset" : 876
    }, {
      "referenceID" : 15,
      "context" : "The oracle we used in BoostResNet to solve the weak module classifier is Adam as well, but could be extended to tensor methods Janzamin et al. (2015), decision trees Safavian & Landgrebe (1991) or other nonlinear classifiers for non-differentiable data.",
      "startOffset" : 127,
      "endOffset" : 150
    }, {
      "referenceID" : 15,
      "context" : "The oracle we used in BoostResNet to solve the weak module classifier is Adam as well, but could be extended to tensor methods Janzamin et al. (2015), decision trees Safavian & Landgrebe (1991) or other nonlinear classifiers for non-differentiable data.",
      "startOffset" : 127,
      "endOffset" : 194
    }, {
      "referenceID" : 2,
      "context" : "(Theorem 1 Cortes et al. (2014)) LetH be a hypothesis set admitting a decomposition H = ∪i=1Hi for some l > 1.",
      "startOffset" : 11,
      "endOffset" : 32
    }, {
      "referenceID" : 2,
      "context" : "According to lemma 2 of Cortes et al. (2016), the empirical Rademacher complexity is bounded as a function of r∞, Λt and n: Rm(Ft) ≤ r∞Λt √ log(2n) 2m (40) Overall, with probability at least 1− δ,",
      "startOffset" : 24,
      "endOffset" : 45
    }, {
      "referenceID" : 38,
      "context" : "G Minimal Weak Learning Condition Mukherjee and SchapireMukherjee & Schapire (2013) introduced a sufficient and necessary weak learning condition based on a concept called edge over random.",
      "startOffset" : 24,
      "endOffset" : 84
    }, {
      "referenceID" : 38,
      "context" : "G Minimal Weak Learning Condition Mukherjee and SchapireMukherjee & Schapire (2013) introduced a sufficient and necessary weak learning condition based on a concept called edge over random. It is intuitive to restrict the cost matrices to a space of edge-over-random cost-matrices Ceor who put the least cost on the correct label. Definition G.1. The space of edge-over-random cost matrices Ceor ⊆ Rm×C is the space of cost matrices C ∈ Ceor that satisfies C(i, yi) ≤ C(i, l), ∀l 6= yi, ∀i ∈ {1, . . . ,m}. (80) Let us define a random classifier as a baseline predictor B ∈ Rm×C , where each row lies on a simplexB(i, :) ∈ ∆{1, . . . , C}. We consider the space of baselines, called edge-over-random,who have a faint clue about the correct answer. Definition G.2. The space of edge-over-random baselines Mukherjee & Schapire (2013) Beor γ ⊆ R m×C is the space of baselinesB ∈ Beor γ that satisfy B(i, yi) ≥ B(i, l) + γ, ∀l 6= yi, ∀i ∈ {1, .",
      "startOffset" : 24,
      "endOffset" : 832
    }, {
      "referenceID" : 38,
      "context" : "i=1 C(i, :)B(i, :)⊤. (82) Lemma G.4. A weak classifier space H is boostable if and only if H satisfies the weak-learning condition defined in Definition G.3. Refer to Mukherjee and Schapire Mukherjee & Schapire (2013) for the proof.",
      "startOffset" : 4,
      "endOffset" : 218
    } ],
    "year" : 2017,
    "abstractText" : "Deep neural networks are known to be difficult to train due to the instability of back-propagation. A deep residual network (ResNet) with identity loops remedies this by stabilizing gradient computations. We prove a boosting theory for the ResNet architecture. We construct T weak module classifiers, each contains two of the T layers, such that the combined strong learner is a ResNet. Therefore, we introduce an alternative Deep ResNet training algorithm, BoostResNet, which is particularly suitable in non-differentiable architectures. Our proposed algorithm merely requires a sequential training of T “shallow ResNets” which are inexpensive. We prove that the training error decays exponentially with the depth T if the weak module classifiers that we train perform slightly better than some weak baseline. In other words, we propose a weak learning condition and prove a boosting theory for ResNet under the weak learning condition. Our results apply to general multi-class ResNets. A generalization error bound based on margin theory is proved and suggests ResNet’s resistant to overfitting under network with l1 norm bounded weights.",
    "creator" : "LaTeX with hyperref package"
  }
}