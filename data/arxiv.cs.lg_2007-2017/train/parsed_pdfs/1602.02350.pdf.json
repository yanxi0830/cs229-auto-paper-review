{
  "name" : "1602.02350.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Solving Ridge Regression using Sketched Preconditioned SVRG",
    "authors" : [ "Alon Gonen", "Francesco Orabona", "Shai Shalev-Shwartz" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 2.\n02 35\n0v 2\n[ cs\n.L G\n] 2"
    }, {
      "heading" : "1 Introduction",
      "text" : "Consider the ridge regression problem:\nmin w∈Rd\n{\nL(w) = 1\nn\nn∑\ni=1\n1 2 (w⊤xi − yi)2 + λ 2 ‖w‖2\n}\n, (1)\nwhere λ > 0 is a regularization parameter, xi ∈ Rd and yi ∈ R for i = 1, · · · , n the training data. We focus on the large scale regime, where both n and d are large. In this setting, stochastic iterative methods such as SDCA [15], SVRG [5], and SAG [11] have become a standard choice for minimizing the objective L. Specifically, the overall complexity of a recent improved variant of SVRG due to [21] depends on the average condition number, which is defined as follows. Denote the empirical correlation matrix and its eigenvalue decomposition by\nC := 1\nn\nn∑\ni=1\nxix ⊤ i =\nd∑\ni=1\nλiuiu ⊤ i . (2)\nThe average condition number of C + λI is defined as the ratio between the trace of the Hessian of L and its minimal eigenvalue:\nκ̂ := κ̂(C + λI) = tr(C + λI)\nλd(C + λI) =\nd∑\ni=1\nλi + λ λd + λ . (3)\n∗School of Computer Science, The Hebrew University, Jerusalem, Israel †Yahoo Labs, New York, NY, USA ‡School of Computer Science, The Hebrew University, Jerusalem, Israel\nThe mentioned variant of SVRG finds an ǫ-approximate minimizer of L in time Õ((κ̂+ n)d log(1/ǫ)). Namely, the output of the algorithm, denoted ŵ, satisfies E[L(ŵ)] − L(w⋆) ≤ ǫ, where the expectation is over the randomness of the algorithm. For an accelerated version of the algorithm, we can replace κ̂ by √ nκ̂ [16, 7].\nThe regularization parameter, λ, increases the smallest eigenvalue of C + λI to be at least λ, thus improves the condition number and makes the optimization problem easier. However, to control the under/over fitting tradeoff, λ has to decrease as n increases [14]. Moreover, in many machine learning applications λd approaches zero and it is usually smaller than the value of λ. Overall, this yields a large condition number in most of the interesting cases.\nA well-known approach for reducing the average condition number is preconditioning. Concretely, for a (symmetric) positive definite (pd) matrix P ∈ Rd×d, we define the preconditioned optimization problem as\nmin w̃∈Rd\nL̃(w̃) := L(P−1/2w̃) . (4)\nNote that w̃ is an ǫ-approximate minimizer of L̃ if and only if w = P−1/2w̃ forms an ǫ-approximate minimizer of L. Hence, we can minimize Equation (4) rather than Equation (1). As we shall see, the structure of the objective allows us to apply the preconditioning directly to the data (as a preprocessing step) and consequently rewrite the preconditioned objective as a ridge regression problem with respect to the preconditioned data (see Section 5.1). For a suitable choice of a matrix P , the average condition number is significantly reduced. Precisely, as will be apparent from the analysis, the pd matrix that minimizes the average condition number is P = C + λI , and the corresponding average condition number is d. However, we note that such preconditioning process would require both the computation of P−1/2 and the computation of P−1/2xi for each i ∈ [n]. By first order conditions, computing (C + λI)−1/2 is equivalent to solving the original problem in Equation (1), rendering this “optimal” preconditioner useless.\nYet, the optimal preconditioner might not needed in many cases. In fact, a common empirical observation (see Section 6) is that (high-dimensional) machine learning problems tend to have few dominant features, while the other coordinates are strongly correlated with the stronger features. As a result, the spectrum of the correlation matrix decays very fast. Hence, it is natural to expect to gain a lot from devising preconditioning methods that focus on the stronger directions of the data.\nOur contributions are as follows. We develop a relatively cheap preconditioning method that, coupled with SVRG, assures to speed-up the convergence in practical applications while having a computational cost comparable to SVRG alone. In order to approximately extract the stronger directions while incurring a low computational cost, we rely on a variant of the Block Lanczos method due to [8] in order to compute an approximated truncated SVD (Singular Value Decomposition) of the correlation matrix C. Finally, by equipping SVRG with this preconditioner, we obtain our main result."
    }, {
      "heading" : "2 Main Result",
      "text" : "Theorem 1. Let k ∈ [d] be a given parameter and assume that the regularization parameter, λ, is larger than λd. Our preconditioning process runs in time O(ndk log(n)). By equipping the SVRG of [21] with this preconditioner, we find an ǫ-approximate minimizer for Equation (1) (with probability at least 9/10) in additional runtime of\nO((κ̃ + n + d)d log(1/ǫ)), where κ̃ = kλk+\n∑ i>k\nλi λ or κ̃ =\n( n(kλk+ ∑ i>k λi)\nλ\n)1/2\nif\nwe use accelerated SVRG.\nWhen the runtimes of both the (accelerated) SVRG and our preconditioned (accelerated) SVRG are controlled by the average condition number (and both runtimes dominate ndk), then ignoring logarithmic dependencies, we obtain a speed-up of order\nratio =\n∑d i=1 λi\nk λk + ∑ i>k λi =\n∑k i=1 λi + ∑ i>k λi\nk λk + ∑ i>k λi . (5)\n(or √ ∑d\ni=1 λi/(λkk + ∑ i>k λi) if acceleration is used) over SVRG. If the spectrum\ndecays fast then k λk ≪ ∑k i=1 λi and ∑\ni>k λi ≪ k λk. In this case, the ratio will be large. Indeed, as we show in the experimental section, this ratio is often huge for relatively small k."
    }, {
      "heading" : "2.1 Main challenges and perspective",
      "text" : "While the idea of developing a preconditioner that focuses on the stronger directions of the data matrix sounds plausible, there are several difficulties that have to be solved.\n• First, since a preconditioner must correspond to an invertible transformation, it is not clear how to form a preconditioner based on a low rank approximation and, in particular, how should we treat the non-leading components.\n• One of the main technical challenges in our work is to translate the approximation guarantees of the Lanczos method into a guarantee on the resulted average condition number. The standard measures of success for low-rank approximation are based on either Frobenius norm or spectral norm errors. As will be apparent from the analysis (see Section 5.4), such bounds do not suffice for our needs. Our analysis relies on stronger per vector error guarantees Equation (9) due to [8].\nIt should be emphasized that while we use a variant of SVRG due to [21], we could equally use a variant of SDCA [13] or develop such a variant for SAG or SAGA. Furthermore, while we focus on the quadratic case, we believe that our ideas can be lifted to more general setting. For example, when applied to self-concordant functions, each step of Newton’s method requires the minimization of a quadratic objective. Therefore, it is natural to ask if we can benefit from applying our method for approximating the Newton step."
    }, {
      "heading" : "2.2 Bias-complexity tradeoff",
      "text" : "As we mentioned above, λ controls a tradeoff between underfitting and overfitting. In this view, we can interpret our result as follows. Assuming for simplicity that n ≥ d and ignoring logarithmic dependencies, we note that if\nλ = kλk +\n∑\ni>k λi\nnk , (6)\nthen the runtime of our preconditioned SVRG is Õ(ndk). For comparison, the runtime of (unconditioned) SVRG is Õ(ndk) if\nλ = ∑d i=1 λi nk . (7)\nThe ratio between the RHS of Equation (7) and Equation (6) is the ratio given in Equation (5). Hence, for a given “runtime budget” of order Õ(ndk), we can set the regularization parameter of the preconditioned SVRG to be smaller by this ratio. Similar interpretation holds for the accelerated versions."
    }, {
      "heading" : "3 Related Work",
      "text" : "Existing algorithms and their complexities: Since minimizing Equation (1) is equivalent to solving the system (C+λI)w = 1n ∑n i=1 yixi, standard numerical linear algebra solvers such as Gaussian elimination can be used to solve the problem in time O(nd2).\nIterative deterministic methods, such as Gradient Descent (GD), finds an ǫ-approximate minimizer in time ndκ log(1/ǫ), where κ = λ1(C+λI)λd(C+λI) is the condition number of C + λI (see Theorem 2.1.15 in [10]). The Kaczmarz algorithm [6] has an identical complexity. Both the Conjugate Gradient (CG) method [4] and the Accelerated Gradient Descent (AGD) algorithm of [9] enjoy a better runtime of nd √ κ log(1/ǫ). In fact, CG has a more delicate analysis (see Corollary 16.7 in [18]): If all but c ∈ [d] eigenvalues of C+λI are contained in a range [a, b], then the runtime of CG is at most nd(c+ √\nb/a log(1/ǫ)). In particular, CG’s runtime is at most O(nd2). Furthermore, following the interpretation of our main result in Section 2.2, we note that for a “runtime budget” of Õ(ndk), we can set the regularization parameter of CG to be of order λk/k 2 (which is usually much greater than the RHS of Equation (6)).\nLinear Sketching: Several recently developed methods in numerical linear algebra are based on the so-called sketch-and-solve approach, which essentially suggests that given a matrixA, we first replace it with a smaller random matrix AS, and then perform the computation on AS [20, 2, 12]. For example, it is known that if the entries of S are i.i.d. standard normal variables and S has p = Ω(k/ǫ) columns, then with high probability, the column space of AS contains a (1 + ǫ) rank-k approximation to A with respect to the Frobenius norm. This immediately yields a fast PCA algorithm (see Section 4.1 in [20]).\nWhile the above sketch-and-solve approach sounds promising for this purpose, our analysis reveals that controlling the Frobenius norm error does not suffice for our needs. We need spectral norm bounds, which are known to be more challenging [19]. Furthermore, as mentioned above, the success of our conditioning method heavily depends on the stronger per vector error guarantees Equation (9) obtained by [8] which are not obtained by simpler linear sketching methods.\nSketched preconditioning: Recently, subspace embedding methods were used to develop cheap preconditioners for linear regression with respect to the squared loss [20]. Precisely, [2] considered the case λ = 0 (i.e, standard least-squares) and developed a preconditioning method that reduces the average condition number to a constant. Thereafter, they suggest applying a basic solver such as CG. The overall running time is dominated by the preconditioning process which runs in time Õ(d3 + nd). Hence, a significant improvement over standard solvers is obtained if n ≫ d.\nThe main shortcoming of this method is that it does not scale well to large dimensions. Indeed, when d is very large, the overhead resulted from the preconditioning process can not be afforded.\nEfficient preconditioning based on random sampling: While we focus on reducing the dependence on the dimensionality of the data, other work investigated the gain from using only a random subset of the data points to form the conditioner [22]. The theoretical gain of this approach has been established under coherence assumptions [22]."
    }, {
      "heading" : "4 Preliminaries",
      "text" : ""
    }, {
      "heading" : "4.1 Additional notation and definitions",
      "text" : "Any matrix B ∈ Rd×n of rank r can be written in (thin) SVD form as B = UΣV ⊤ = ∑r\ni=1 σi(B)uiv ⊤ i . The singular values are ordered in descending order. The spectral norm of B is defined by ‖B‖ = σ1(B). The spectral norm is submultiplicative, i.e., ‖AB‖ ≤ ‖A‖‖B‖ for all A and B. Furthermore, the spectral norm is unitary invariant, i.e., for all A and U such that the columns of U are orthonormal, ‖UA‖ = ‖A‖. For any k ∈ [r], it is well known that the truncated SVD of B, Bk := UkΣkVk = ∑k\ni=1 σi(B)uiv ⊤ i , is the best rank-k approximation of B w.r.t. the spectral norm [17]. A twice continuously differentiable function f : Rd → R is said to be β-smooth if ‖∇2f(w)‖ ≤ β for all w, where ∇2f(w) is the Hessian of f at w. f is said to be α-strongly convex if λd(∇2f(w)) ≥ α for all w. If g is convex and f is α-strongly convex, then f + g is α-strongly convex."
    }, {
      "heading" : "4.2 Stochastic Variance Reduced Gradient (SVRG)",
      "text" : "We consider a variant of the Stochastic Variance Reduced Gradient (SVRG) algorithm of [5] due to [21]. The algorithm is an epoch-based iterative method for minimizing an average, F (w) = 1N ∑N i=1 fi(w), of smooth functions. It is assumed that each fi :\nAlgorithm 1 SVRG citexiao2014proximal\n1: Input: Functions f1, . . . , fn, β1, . . . , βn 2: Parameters: w̄0 ∈ Rd, m, η, S ∈ N 3: for s = 1, 2, . . . , S do 4: w̄ = w̄s−1 5: v̄ = ∇F (w̄) 6: w0 = w̄ 7: for t = 1, . . . ,m do # New epoch 8: Pick it ∈ [N ] with probability qit = βit/ ∑ βj\n9: vt = (∇fit(wt−1)−∇fit(w̄))/qit + v̄ 10: wt = wt−1 − ηvt 11: end for 12: w̄s = 1 m ∑m t=1 wt 13: end for 14: Output: the vector w̄S\nR d → R is convex and βi-smooth. The entire function F is assumed to be α-strongly convex. The algorithm is detailed in Algorithm 1. Its convergence rate depends on the averaged smoothness of the individual functions and the average condition number of F , defined as\nβ̂ = 1\nN\nN∑\ni=1\nβi ; κ̂F = β̂\nα . (8)\nTheorem 2. [21] Fix ǫ > 0. Running SVRG (Algorithm 1) with anyw0, S ≥ log((F (w0)− minw∈Rd F (w))/ǫ), m = ⌈κ̂F ⌉, and η = 0.1/β̂ yields an ǫ-approximate minimizer of F . Furthermore, assuming that each single gradient ∇fi(w) can be computed in time O(d), the overall runtime is O((κ̂F +N)d log(ǫ0/ǫ)).\nIn the original definition of SVRG [5], the indices it are chosen uniformly at random from [n], rather than proportional to βi. As a result, the convergence rate depends on the maximal smoothness, max{βi}, rather than the average, β̂. It will be apparent from our analysis (see Theorem 4) that in our case, max{βi} is proportional to the maximum norm of any preconditioned xi. Since we rely on the improved variant of [21], our bound depends on the average of the βi’s, which scale with the average norm of the preconditioned xi’s. To simplify the presentation, in the sequel we refer to Algorithm 1 as SVRG."
    }, {
      "heading" : "4.3 Randomized Block Lanczos",
      "text" : "A randomized variant of the Block Lanczos method due to [8] is detailed1 in Algorithm 2. Note that the matrix ŨkΣ̃kṼ ⊤k forms an SVD of the matrix Ãk := Q(Q ⊤A)k = ŨkŨ ⊤ k A.\n1More precisely, Algorithm 2 in [8] returns the projection matrix ŨkŨ⊤k , while we also compute the\nSVD of ŨkŨ⊤k A. The additional runtime is negligible.\nAlgorithm 2 Block Lanczos method [8]\n1: Input: A ∈ Rd×n, k ≤ d, ǫ′ ∈ (0, 1) 2: q = Θ ( log(n)√\nǫ\n)\n, p = qk, Π ∼ N (0, 1)n×k\n3: Compute K = [AΠ, (AA⊤)AΠ, . . . , (AA⊤)q−1AΠ] 4: Orthonormalize K’s columns to obtain Q ∈ Rd×qk 5: Compute the truncated SVD (Q⊤A)k = W̃kΣ̃kṼ ⊤k 6: Compute Ũk = QW̃k 7: Output: the matrices Ũk, Σ̃k, Ṽk\nTheorem 3. [8] Consider the run of Algorithm 2 and denote Ãk = ŨkΣ̃kṼk =∑k i=1 σ̃iũiṽ ⊤ i . Denote the SVD of A by A = ∑d i=1 σiviu ⊤ i . The following bounds hold with probability at least 9/10:\n‖A− Ãk‖ ≤ (1 + ǫ′)‖A−Ak‖ ≤ (1 + ǫ′)σk\n∀i ∈ [k], |z⊤i AA⊤zi − u⊤i AA⊤ui| = |σ̃2i − σ2i | ≤ ǫ′σ2k+1 . (9)\nThe runtime of the algorithm is O (\nndk log(n)√ ǫ′ + k 2(n+d) ǫ′\n)\n."
    }, {
      "heading" : "5 Sketched Conditioned SVRG",
      "text" : "In this section we develop our sketched conditioning method. By analyzing the properties of this conditioner and combining it with SVRG, we will conclude Theorem 1.\nRecall that we aim at devising cheaper preconditioners that lead to a significant reduction of the condition number. Specifically, given a parameter k ∈ [d], we will consider only preconditioners P−1/2 for which both the computation of P−1/2 itself and the computation of the set {P−1/2xi, . . . , P−1/2xn} can be carried out in time Õ(ndk). We will soon elaborate more on the considerations when choosing the preconditioner, but first we would like to address some important implementation issues."
    }, {
      "heading" : "5.1 Preconditioned regularization",
      "text" : "In order to implement the preconditioning scheme suggested above, we should be able to find a simple form for the function L̃. In particular, since we would like to use SVRG, we should write L̃ as an average of n components whose gradients can be easily computed. Denote by x̃i = P−1/2xi for all i ∈ [n]. Since for every i ∈ [n], ((P−1/2w)⊤xi − yi)2 = (w⊤x̃i − yi)2, it seems natural to write L̃(w) = L(P−1/2w) as follows:\nL̃(w) = 1\nn\nn∑\ni=1\n1 2 (w⊤x̃i − yi)2 ︸ ︷︷ ︸\n=:ℓ̃i\n+ λ\n2 ‖P−1/2w‖2 .\nAssume momentarily that λ = 0. Note that the gradient of ℓ̃i at any point w is given by ∇ℓ̃i(wt) = (w⊤x̃i − yi)x̃i. Hence, by computing all the x̃i’s in advance, we are able to apply SVRG directly to the preconditioned function and computing the stochastic gradients in time O(d).\nWhen λ > 0, the computation of the gradient at some point w involves the computation of P−1w. We would like to avoid this overhead. To this end, we decompose the regularization function as follows. Denote the standard basis of Rd by e1, . . . , ed. Note that the function L can be rewritten as follows:\nL(w) = 1\nn+ d\nn+d∑\ni=1\nℓi(w) ,\nwhere ℓi(w) = n+dn 1 2 (w ⊤xi−yi)2 for i = 1, . . . , n and ℓn+i(w) = λ(n+d)12 (w⊤ei)2 for i = 1, . . . , d. Finally, denoting bi = P−1/2ei for all i, we can rewrite the preconditioned function L̃ as follows:\nL̃(w) = 1\nn+ d\nn+d∑\ni=1\nℓ̃i(w) ,\nwhere ℓ̃i(w) = n+dn 1 2 (w ⊤x̃i−yi)2 for i = 1, . . . , n and ℓ̃n+i(w) = λ(n+d)12 (w⊤bi)2 for i = 1, . . . , d. By computing the x̃i’s and the bi’s in advance, we are able to apply SVRG while computing stochastic gradients in time O(d)."
    }, {
      "heading" : "5.2 The effect of conditioning",
      "text" : "We are now in position to address the following fundamental question: How does the choice of the preconditioner, P−1/2, affects the resulted average condition number of the function L̃ (8)? The following lemma upper bounds κ̂L̃ by the average condition number of the matrix P−1/2(C +λI)P−1/2, which we denote by κ̃ (when the identity of the matrix P is understood).\nTheorem 4. Let P−1/2 be a preconditioner. Then, the average condition number of L̃ is upper bounded by\nκ̂L̃ ≤ κ̃ = tr(P−1/2(C + λI)P−1/2)\nλd(P−1/2(C + λI)P−1/2) .\nThe proof is in the appendix. Note that an optimal bound of O(d) is attained by the whitening matrix P−1/2 = (C + λI)−1/2."
    }, {
      "heading" : "5.3 Exact sketched conditioning",
      "text" : "Our sketched preconditioner is based on a random approximation of the best rankk approximation of the data matrix. It will be instructive to consider first a preconditioner that is based on an exact rank-k approximation of the data matrix. Let X ∈ Rd×n be the matrix whose i-th columns is xi and let X̄ = n−1/2X . Denote by\nX̄ = ∑rank(X̄)\ni=1 σiuiv ⊤ i = UΣV ⊤ the SVD of X̄ and recall that X̄k = ∑k i=1 σiuiv ⊤ i\nis the best k-rank approximation of X̄ . Note that X̄X̄⊤ = C and therefore σ2i = λi(C) = λi. Furthermore, the left singular vectors of X̄ , u1, . . . , uk, coincide with the k leading eigenvectors of the matrix C. Consider the preconditioner,\nP−1/2 =\nk∑\ni=1\nuiu ⊤ i√\nλi + λ + I −∑ki=1 uiu⊤i√ λk + λ ,\nwhere uk+1, . . . , ud are obtained from a completion of u1, . . . , uk to an orthonormal basis.\nLemma 1. Let k ∈ [d] be a parameter and assume that the regularization parameter, λ, is larger than λd. Using the exact sketched preconditioner, we obtain\nκ̂L̃ ≤ kλk +\n∑\ni>k λi\nλ + d . (10)\nProof. A simple calculation shows that for i = 1, . . . , k,\nλi(P −1/2(C + λI)P−1/2) =\nλi + λ λi + λ = 1 .\nSimilarly, for i = k + 1, . . . , d,\nλi(P −1/2(C + λI)P−1/2) =\nλi + λ λk + λ .\nFinally,\nλd(P −1/2(C + λI)P−1/2) ≥ λ\nλk + λ .\nCombining the above with Theorem 4, we obtain that\nκ̂L̃ ≤ tr(P−1/2(C + λI)P−1/2)\nλd(P−1/2(C + λI)P−1/2)\n≤ kλk + λ λ +\nd∑\ni=k+1\nλi + λ\nλ\n= kλk +\n∑\ni>k λi\nλ + d ."
    }, {
      "heading" : "5.4 Sketched conditioning",
      "text" : "An exact computation of the SVD of the matrix X̄ takes O(nd2). Instead, we will use the Block Lanczos method in order to approximate the truncated SVD of X̄ . Specifically, given a parameter k ∈ [d], we invoke the Block Lanczos method with the parameters X̄, k and ǫ′ = 1/2. Recall that the output has the form X̃k = ŨkΣ̃kṼ ⊤k = ∑k\ni=1 σ̃iũiṽ ⊤ i . Analogously to the exact sketched preconditioner, we define our sketched\npreconditioner by\nP−1/2 =\nk∑\ni=1\nũiũ ⊤ i\n√ σ̃2i + λ +\nI −∑ki=1 ũiũ⊤i √\nσ̃2k + λ . (11)\nTheorem 5. Let k ∈ [d] be a parameter and assume that the regularization parameter, λ, is larger that λd. Using the sketched preconditioner defined in Equation (11), up to a multiplicative constant, we obtain the bound Equation (10) on the average condition number with probability at least 9/10.\nThe rest of this section is devoted to the proof of Theorem 5. We follow along the lines of the proof of Lemma 1. Up to a multiplicative constant, we derive the same upper and lower bounds on the eigenvalues of P−1/2(C + λI)P−1/2.\nFrom now on, we assume that the bounds in Theorem 3 (where ǫ′ = 1/2) hold. This assumption will be valid with probability of at least 9/10. We next introduce some notation. We can rewrite P−1/2 = Ũ(Σ̃2 + λI)−1/2Ũ⊤ where Σ̃ is a diagonal d × d with Σ̃i,i = σ̃i if i ≤ k and Σ̃i = σ̃k if i > k. and the columns of Ũ are a completion of ũ1, . . . , ũk to an orthonormal basis. Recall that the SVD of X̄ is denoted by X̄ =\n∑d i=1 σiuiv ⊤ i = UΣV ⊤.\nLemma 2. (Upper bound on the leading eigenvalue) We have\nλ1(P −1/2(C + λI)P−1/2) ≤ 17 .\nProof. Since λ1(P−1/2(C+λI)P−1/2) = ‖P−1/2(C+λI)P−1/2‖ = ‖P−1/2CP−1/2+ λP−1‖, using the triangle inequality we have that\nλ1(P −1/2(C + λI)P−1/2) ≤ ‖P−1/2CP−1/2‖+ λ‖P−1‖ .\nBy the definition of P we have that ‖P−1‖ = 1 σ̃2 k +λ and therefore the second summand on the right hand side of the above is at most λ σ̃2 k +λ\n≤ 1. As to the first summand, recall that C = X̄X̄⊤ and therefore ‖P−1/2CP−1/2‖ = ‖X̄⊤P−1/2‖2. We will show that ‖X̄⊤P−1/2‖ ≤ 4 which will imply that ‖P−1/2CP−1/2‖ ≤ 16. To do so, we first apply the triangle inequality,\n‖X̄⊤P−1/2‖ = ‖(X̃k + (X̄ − X̃k))⊤P−1/2‖ ≤ ‖X̃⊤k P−1/2‖+ ‖(X̄ − X̃k)⊤P−1/2‖ .\nLet us consider one term at the time. Recall that X̃k = ŨkΣ̃kṼ ⊤k . Since Ũ ⊤ k Ũ ∈ Rk,d is a diagonal matrix with ones on the diagonal, and since the spectral norm is invariant to multiplication by unitary matrices, we obtain that\n‖X̃⊤k P−1/2‖ = ‖ṼkΣ̃kŨ⊤k Ũ(Σ̃2 + λI)−1/2Ũ⊤‖ = ‖Σ̃kŨ⊤k Ũ(Σ̃2 + λI)−1/2‖\n= max i∈[k]\nσ̃i √\nσ̃2i + λ ≤ max i∈[k]\nσ̃i\nσ̃i + √ λ ≤ 1 .\nNext, by the submutiplicativity of the spectral norm,\n‖(X̄ − X̃k)⊤P−1/2‖ ≤ ‖X̄ − X̃k‖ · ‖P−1/2‖ .\nTheorem 3 implies that ‖X̄ − X̃k‖ ≤ 32σk and\n‖P−1/2‖ = 1√ σ̃2k + λ ≤ 1√ σ̃2k ≤ 1√ σ2k − (1/2)σ2k+1\n≤ 1 σk √ 1 2 =\n√ 2 σk < 2 σk .\nHence, ‖X̄ − X̃k‖ · ‖P−1/2‖ ≤ 3. Combining all of the above bounds concludes our proof.\nLemma 3. (Refined upper bound on the last d − k eigenvalues) For any i ∈ {k + 1, . . . , d},\nλi\n( P−1/2(C + λI)P−1/2 ) ≤ 2(λi + λ) λk + λ .\nProof. Using the Courant minimax principle [1], we obtain the following bound for all i ∈ {k + 1, . . . , d}:\nλi\n( P−1/2(C + λI)P−1/2 )\n= max M⊆Rd:\ndim(M)=i\nmin x∈M: x 6=0\nx⊤P−1/2(C + λI)P−1/2x\n‖x‖2\n= max M⊆Rd:\ndim(M)=i\nmin x∈M: x 6=0\nx⊤P−1/2(C + λI)P−1/2x ‖P−1/2x‖2 · ‖P−1/2x‖2 ‖x‖2\n≤\n\n  max\nM⊆Rd: dim(M)=i\nmin x∈M: x 6=0\nx⊤P−1/2(C + λI)P−1/2x\n‖P−1/2x‖2\n\n ×\n\nmax x∈Rd: x 6=0\nx⊤P−1x\n‖x‖2\n\n\n= λi (C + λI) · λ1(P−1) = (λi + λ) · (σ̃2k + λ)−1 .\nFinally, using Theorem 3 we have that σ̃2k ≥ σ2k − 12σ2k+1 ≥ 12σ2k = 12λk and therefore,\n(σ̃2k + λ) −1 ≤ (12λk + λ)−1 ≤ 2 (λk + λ)−1 .\nLemma 4. (Lower bound on the smallest eigenvalue)\nλd(P −1/2CP−1/2) ≥ λ\n19(λk + λ) .\nProof. Note that\nλd(P −1/2(C + λI)P−1/2) =\n1\n‖P 1/2(C + λI)−1P 1/2‖ , (12)\nso we can derive an upper bound on ‖P 1/2(C + λI)−1P 1/2‖. Consider an arbitrary completion of ṽ1, . . . , ṽk to an orthonormal set, ṽ1, . . . , ṽd ∈ Rn. Let Ṽ ∈ Rn×d be the matrix whose i-th column is ṽi. Since the spectral norm is unitary invariant and both Ũ and Ṽ have orthonormal columns,\n‖P 1/2(C + λI)−1P 1/2‖ = ‖Ũ(Σ̃2 + λI)1/2Ũ⊤(C + λI)−1Ũ(Σ̃2 + λI)1/2Ũ⊤‖ = ‖Ṽ (Σ̃2 + λI)1/2Ũ⊤(C + λI)−1Ũ(Σ̃2 + λI)1/2Ṽ ⊤‖ .\nDenote by Z̃ = Ũ(Σ̃2 + λI)1/2Ṽ ⊤. By the triangle inequality and the submutiplicativity of the spectral norm,\n‖Z̃⊤(C + λI)−1Z̃‖ ≤ ‖X̄⊤(C + λI)−1X̄‖ + ‖(Z̃ − X̄)⊤(C + λI)−1(Z̃ − X̄)‖\n≤ ‖X̄⊤(C + λI)−1X̄‖+ ‖Z̃ − X̄‖2‖(C + λI)−1‖ . (13)\nTo bound the first summand of Equation (13), we use the unitary invariance to obtain\n‖X̄⊤(C + λI)−1X̄‖ = ‖V ΣU⊤U(Σ2 + λI)−1U⊤UΣV ⊤‖\n= ‖Σ(Σ2 + λI)−1Σ‖ = max i λ2i λ2i + λ ≤ 1 .\nFor the second summand of Equation (13), note that ‖(C + λI)−1‖ = 1λd+λ and that, using the triangle inequality,\n‖Z̃ − X̄‖ = ‖(ŨΣ̃Ṽ ⊤ − X̄) + (Z̃ − Ũ Σ̃Ṽ ⊤)‖ ≤ ‖ŨΣ̃Ṽ ⊤ − X̄‖+ ‖Ũ((Σ̃2 + λI)1/2 − Σ̃)Ṽ ⊤‖ .\nBy using unitary invariance together with the inequality √ σ̃2i + λ − σ̃i ≤ √ λ (which holds for every i), we get\n‖Ũ((Σ̃2 + λI)1/2 − Σ̃)Ṽ ⊤‖ = ‖(Σ̃2 + λI)1/2 − Σ̃‖ ≤ √ λ .\nHence, using the inequality (x+ y)2 ≤ 2x2 + 2y2, we obtain\n‖Z̃ − X̄‖2 ≤ 2‖ŨΣ̃Ṽ ⊤ − X̄‖2 + 2λ .\nWe next derive an upper bound on ‖ŨΣ̃Ṽ ⊤−X̄‖. Since Ũ Σ̃Ṽ ⊤ = X̃k+σ̃k ∑d i=k+1 ũiṽ ⊤ i ,\n‖ŨΣ̃Ṽ ⊤ − X̄‖ ≤ ‖X̃k − X̄‖+ σ̃k ∥ ∥ ∥ ∥ ∥ d∑\ni=k+1\nũiṽ ⊤ i ∥ ∥ ∥ ∥ ∥ .\nUsing Theorem 3 we know that ‖X̃k−X̄‖ ≤ 1.5 σk and that σ̃k ≤ √ σ2k + 0.5 σ 2 k+1 ≤ 1.5 σk. Combining this with the fact that ‖ ∑d i=k+1 ũiṽ ⊤ i ‖ = 1, we obtain\n‖ŨΣ̃Ṽ ⊤ − X̄‖ ≤ 3 σk .\nCombining the above inequalities, we obtain\n‖P 1/2(C + λI)−1P 1/2‖ ≤ 1 + 2 · (3σk) 2 + 2λ\nλd + λ\n≤ 19(λk + λ) λ ,\nand using Equation (12) we conclude our proof.\nProof. (of Theorem 5) The three last lemmas imply that the inequalities derived during the proof of Lemma 1 remain intact up to a multiplicative constant. Therefore, the bound Equation (10) on the condition number also holds up to a multiplicative constant. This completes the proof."
    }, {
      "heading" : "5.5 Sketched Preconditioned SVRG",
      "text" : "By equipping SVRG with the sketched preconditioner Equation (11), we obtain the Sketched Preconditioned SVRG (see Algorithm 3).\nProof. (of Theorem 1) The theorem follows from Theorem 5 and Theorem 2.\nAlgorithm 3 Sketched Preconditioned SVRG\n1: Input: x1, . . . , xn ∈ Rd, y1, . . . , yn ∈ R, ǫ > 0 2: Parameters: λ > 0, k ∈ [d] 3: Let X̄ ∈ Rd,n be the matrix whose i’th column is (1/n)xi 4: Run the Block Lanczos method (Algorithm 2) with the input X̄, k, ǫ′ = 1/2 to\nobtain X̃k = ŨkΣ̃kṼk 5: Let ũi be the columns of Ũk and σ̃i be the diagonal elements of Σ̃k 6: Form the preconditioner P−1/2 according to Equation (11) 7: Compute x̃i = P−1/2xi, bi = P−1/2ei 8: Let ℓi(w) = n+dn 1 2 (w\n⊤x̃i − yi)2 for i = 1, . . . , n and ℓi(w) = λ(n + d)(w⊤bi)2 for i = n+ 1, . . . , n+ d 9: Let βi = n+dn ‖x̃i‖2 for i = 1, . . . , n and βi = λ(n+d)‖bi‖ for i = n+1, . . . , n+ d. Let β̂ = 1n ∑n+d i=1 βi\n10: Run SVRG (Algorithm 1) 11: Return ŵ = P 1/2w̃"
    }, {
      "heading" : "6 The Empirical Gain of Sketched Preconditioning",
      "text" : "In this section we empirically demonstrate the gain of our method. We consider both regression problems and binary classifications tasks, where the square loss serves as a surrogate for the zero-one loss. We use the following datasets:\n0 100 200 300 400 500 600 700 100\n101\n102\n103\n104\n105\n106\n(a) MNIST dataset.\n0 200 400 600 800 1,000 1,200 1,400 1,600 1,800 2,000 100\n101\n102\n103\n104\n(b) CIFAR-10 dataset.\n0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300 1\n1.05\n1.1\n1.15\n1.2\n1.25\n(c) RCV1 dataset.\n0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300 1\n1.02\n1.04\n1.06\n1.08\n1.1\n1.12\n1.14\n(d) Real-sim dataset.\n• real-sim:5 Here, n = 72309, d = 20958, and we consider a standard binary document classification task."
    }, {
      "heading" : "6.1 Inspecting our theoretical speed-up",
      "text" : "Recall that the ratio Equation (5) quantifies our theoretical speedup. Hence, we first empirically inspect the prefixes of the corresponding quantities (as a function of k) for each of the datasets (see Figure 1). We can see that while in MNIST and CIFAR-10 the ratio is large for small values of k, in RCV1 and real-sim the ratio increases very slowly (note that for the former two datasets we use logarithmic scale)."
    }, {
      "heading" : "6.2 Empirical advantage of Sketched Preconditioned SVRG",
      "text" : "We now evaluate Algorithm 3 and compare it to the SVRG algorithm of [21]. To minimally affect the inherent condition number, we added only a slight amount of regularization, namely, λ = 10−8. The loss used is the square loss. The step size, η, is optimally tuned for each method. Similarly to previous work on SVRG [21, 5], the size of each epoch, m, is proportional to the number of points, n. We minimally preprocessed the data by average normalization: each instance vector is divided by the average ℓ2-norm of the instances. The number of epochs is up to 60. Note that in all cases we choose a small preconditioning parameter, namely k = 30, so that the preprocessing time of Algorithm 3 is negligible. There is a clear correspondence between the ratios depicted in Figure 1 and the actual speedup. In other words, the empirical results strongly affirm our theoretical results."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We thank Edo Liberty for helpful discussions. The work is supported by ICRI-CI and by the European Research Council (TheoryDL project).\n5https://www.csie.ntu.edu.tw/ cjlin/libsvmtools/datasets/"
    }, {
      "heading" : "A Omitted Proofs",
      "text" : "Proof. (of Theorem 4) We first show that the average smoothness of L̃ is bounded by\n1\nn+ d\nn+d∑\ni=1\nβ̃i ≤ tr ( P−1/2 (C + λI)P−1/2 ) . (14)\nNote that for any w,\n∇2ℓ̃i(w) = { n+d n x̃ix̃ ⊤ i 1 ≤ i ≤ n,\nλ(n+ d)bi−nb ⊤ i−n n < i ≤ n+ d .\nTherefore, using the fact that the spectral norm of a rank-1 psd matrix is equal to its trace, we obtain\n1\nn+ d\nn∑\ni=1\nβ̃i = 1\nn+ d\nn+ d\nn\nn∑\ni=1\n‖x̃ix̃⊤i ‖+ 1\nn+ d λ(n+ d)\nd∑\nj=1\n‖bjb⊤j ‖\n= 1\nn\nn∑\ni=1\ntr(x̃ix̃ ⊤ i ) + λ\nd∑\nj=1\ntr(bib ⊤ i )\n= 1\nn tr(\nn∑\ni=1\nP−1/2xix ⊤ i P\n−1/2) + λ tr d∑\nj=1\n(P−1/2eie ⊤ i P −1/2)\n= tr(P−1/2(C + λI)P−1/2) .\nHence, we deduce (14). We will conclude the theorem by showing that L̃ is λd(P−1/2(C + λI)P−1/2)strongly convex. Indeed, a similar calculation shows that the Hessian of L at any point w is given by\n∇2L̃(w) = P−1/2(C + λI)P−1/2 .\nHence, we conclude the claimed bound."
    } ],
    "references" : [ {
      "title" : "Matrix analysis, volume 169",
      "author" : [ "Rajendra Bhatia" ],
      "venue" : "Springer Science & Business Media,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2013
    }, {
      "title" : "Low rank approximation and regression in input sparsity time",
      "author" : [ "Kenneth L Clarkson", "David P Woodruff" ],
      "venue" : "In Proceedings of the forty-fifth annual ACM symposium on Theory of computing,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2013
    }, {
      "title" : "Un-regularizing: approximate proximal point and faster stochastic algorithms for empirical risk minimization",
      "author" : [ "Roy Frostig", "Rong Ge", "Sham M Kakade", "Aaron Sidford" ],
      "venue" : "arXiv preprint arXiv:1506.07512,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2015
    }, {
      "title" : "Methods of conjugate gradients for solving linear systems",
      "author" : [ "Magnus Rudolph Hestenes", "Eduard Stiefel" ],
      "venue" : "NBS,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1952
    }, {
      "title" : "Accelerating stochastic gradient descent using predictive variance reduction",
      "author" : [ "Rie Johnson", "Tong Zhang" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2013
    }, {
      "title" : "Angenäherte auflösung von systemen linearer gleichungen",
      "author" : [ "Stefan Kaczmarz" ],
      "venue" : "Bulletin International de l’Académie Polonaise des Sciences et des Lettres,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1937
    }, {
      "title" : "A universal catalyst for firstorder optimization",
      "author" : [ "Hongzhou Lin", "Julien Mairal", "Zaid Harchaoui" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2015
    }, {
      "title" : "Randomized block krylov methods for stronger and faster approximate singular value decomposition",
      "author" : [ "Cameron Musco", "Christopher Musco" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2015
    }, {
      "title" : "A method of solving a convex programming problem with convergence rate O(1/k)",
      "author" : [ "Yurii Nesterov" ],
      "venue" : "In Soviet Mathematics Doklady,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1983
    }, {
      "title" : "Introductory lectures on convex optimization, volume 87",
      "author" : [ "Yurii Nesterov" ],
      "venue" : "Springer Science & Business Media,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2004
    }, {
      "title" : "A stochastic gradient method with an exponential convergence rate for finite training sets",
      "author" : [ "Nicolas L Roux", "Mark Schmidt", "Francis R Bach" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2012
    }, {
      "title" : "Improved approximation algorithms for large matrices via random projections",
      "author" : [ "Tamas Sarlos" ],
      "venue" : "In Foundations of Computer Science,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2006
    }, {
      "title" : "Sdca without duality, regularization, and individual convexity",
      "author" : [ "Shai Shalev-Shwartz" ],
      "venue" : "arXiv preprint arXiv:1602.01582,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2016
    }, {
      "title" : "Understanding Machine Learning: From Theory to Algorithms",
      "author" : [ "Shai Shalev-Shwartz", "Shai Ben-David" ],
      "venue" : null,
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2014
    }, {
      "title" : "Stochastic dual coordinate ascent methods for regularized loss",
      "author" : [ "Shai Shalev-Shwartz", "Tong Zhang" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2013
    }, {
      "title" : "Accelerated proximal stochastic dual coordinate ascent for regularized loss minimization",
      "author" : [ "Shai Shalev-Shwartz", "Tong Zhang" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2014
    }, {
      "title" : "Numerical linear algebra, volume 50",
      "author" : [ "Lloyd N Trefethen", "David Bau III" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1997
    }, {
      "title" : "Laplacian solvers and their algorithmic applications",
      "author" : [ "Nisheeth K Vishnoi" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2012
    }, {
      "title" : "Randomized algorithms for low-rank matrix factorizations: sharp performance",
      "author" : [ "Rafi Witten", "Emmanuel Candès" ],
      "venue" : "bounds. Algorithmica,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2013
    }, {
      "title" : "Sketching as a tool for numerical linear algebra",
      "author" : [ "David P Woodruff" ],
      "venue" : "arXiv preprint arXiv:1411.4357,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2014
    }, {
      "title" : "A proximal stochastic gradient method with progressive variance reduction",
      "author" : [ "Lin Xiao", "Tong Zhang" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2014
    }, {
      "title" : "On data preconditioning for regularized loss minimization",
      "author" : [ "Tianbao Yang", "Rong Jin", "Shenghuo Zhu", "Qihang Lin" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 14,
      "context" : "In this setting, stochastic iterative methods such as SDCA [15], SVRG [5], and SAG [11] have become a standard choice for minimizing the objective L.",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 4,
      "context" : "In this setting, stochastic iterative methods such as SDCA [15], SVRG [5], and SAG [11] have become a standard choice for minimizing the objective L.",
      "startOffset" : 70,
      "endOffset" : 73
    }, {
      "referenceID" : 10,
      "context" : "In this setting, stochastic iterative methods such as SDCA [15], SVRG [5], and SAG [11] have become a standard choice for minimizing the objective L.",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 20,
      "context" : "Specifically, the overall complexity of a recent improved variant of SVRG due to [21] depends on the average condition number, which is defined as follows.",
      "startOffset" : 81,
      "endOffset" : 85
    }, {
      "referenceID" : 15,
      "context" : "For an accelerated version of the algorithm, we can replace κ̂ by √ nκ̂ [16, 7].",
      "startOffset" : 72,
      "endOffset" : 79
    }, {
      "referenceID" : 6,
      "context" : "For an accelerated version of the algorithm, we can replace κ̂ by √ nκ̂ [16, 7].",
      "startOffset" : 72,
      "endOffset" : 79
    }, {
      "referenceID" : 13,
      "context" : "However, to control the under/over fitting tradeoff, λ has to decrease as n increases [14].",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 7,
      "context" : "In order to approximately extract the stronger directions while incurring a low computational cost, we rely on a variant of the Block Lanczos method due to [8] in order to compute an approximated truncated SVD (Singular Value Decomposition) of the correlation matrix C.",
      "startOffset" : 156,
      "endOffset" : 159
    }, {
      "referenceID" : 20,
      "context" : "By equipping the SVRG of [21] with this preconditioner, we find an ǫ-approximate minimizer for Equation (1) (with probability at least 9/10) in additional runtime of O((κ̃ + n + d)d log(1/ǫ)), where κ̃ = kλk+ ∑ i>k λi λ or κ̃ = ( n(kλk+ ∑ i>k λi) λ )1/2 if we use accelerated SVRG.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 7,
      "context" : "Our analysis relies on stronger per vector error guarantees Equation (9) due to [8].",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 20,
      "context" : "It should be emphasized that while we use a variant of SVRG due to [21], we could equally use a variant of SDCA [13] or develop such a variant for SAG or SAGA.",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 12,
      "context" : "It should be emphasized that while we use a variant of SVRG due to [21], we could equally use a variant of SDCA [13] or develop such a variant for SAG or SAGA.",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 9,
      "context" : "15 in [10]).",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 5,
      "context" : "The Kaczmarz algorithm [6] has an identical complexity.",
      "startOffset" : 23,
      "endOffset" : 26
    }, {
      "referenceID" : 3,
      "context" : "Both the Conjugate Gradient (CG) method [4] and the Accelerated Gradient Descent (AGD) algorithm of [9] enjoy a better runtime of nd √ κ log(1/ǫ).",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 8,
      "context" : "Both the Conjugate Gradient (CG) method [4] and the Accelerated Gradient Descent (AGD) algorithm of [9] enjoy a better runtime of nd √ κ log(1/ǫ).",
      "startOffset" : 100,
      "endOffset" : 103
    }, {
      "referenceID" : 17,
      "context" : "7 in [18]): If all but c ∈ [d] eigenvalues of C+λI are contained in a range [a, b], then the runtime of CG is at most nd(c+ √ b/a log(1/ǫ)).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 19,
      "context" : "Linear Sketching: Several recently developed methods in numerical linear algebra are based on the so-called sketch-and-solve approach, which essentially suggests that given a matrixA, we first replace it with a smaller random matrix AS, and then perform the computation on AS [20, 2, 12].",
      "startOffset" : 276,
      "endOffset" : 287
    }, {
      "referenceID" : 1,
      "context" : "Linear Sketching: Several recently developed methods in numerical linear algebra are based on the so-called sketch-and-solve approach, which essentially suggests that given a matrixA, we first replace it with a smaller random matrix AS, and then perform the computation on AS [20, 2, 12].",
      "startOffset" : 276,
      "endOffset" : 287
    }, {
      "referenceID" : 11,
      "context" : "Linear Sketching: Several recently developed methods in numerical linear algebra are based on the so-called sketch-and-solve approach, which essentially suggests that given a matrixA, we first replace it with a smaller random matrix AS, and then perform the computation on AS [20, 2, 12].",
      "startOffset" : 276,
      "endOffset" : 287
    }, {
      "referenceID" : 19,
      "context" : "1 in [20]).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 18,
      "context" : "We need spectral norm bounds, which are known to be more challenging [19].",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 7,
      "context" : "Furthermore, as mentioned above, the success of our conditioning method heavily depends on the stronger per vector error guarantees Equation (9) obtained by [8] which are not obtained by simpler linear sketching methods.",
      "startOffset" : 157,
      "endOffset" : 160
    }, {
      "referenceID" : 19,
      "context" : "Sketched preconditioning: Recently, subspace embedding methods were used to develop cheap preconditioners for linear regression with respect to the squared loss [20].",
      "startOffset" : 161,
      "endOffset" : 165
    }, {
      "referenceID" : 1,
      "context" : "Precisely, [2] considered the case λ = 0 (i.",
      "startOffset" : 11,
      "endOffset" : 14
    }, {
      "referenceID" : 21,
      "context" : "Efficient preconditioning based on random sampling: While we focus on reducing the dependence on the dimensionality of the data, other work investigated the gain from using only a random subset of the data points to form the conditioner [22].",
      "startOffset" : 237,
      "endOffset" : 241
    }, {
      "referenceID" : 21,
      "context" : "The theoretical gain of this approach has been established under coherence assumptions [22].",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 16,
      "context" : "the spectral norm [17].",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 4,
      "context" : "2 Stochastic Variance Reduced Gradient (SVRG) We consider a variant of the Stochastic Variance Reduced Gradient (SVRG) algorithm of [5] due to [21].",
      "startOffset" : 132,
      "endOffset" : 135
    }, {
      "referenceID" : 20,
      "context" : "2 Stochastic Variance Reduced Gradient (SVRG) We consider a variant of the Stochastic Variance Reduced Gradient (SVRG) algorithm of [5] due to [21].",
      "startOffset" : 143,
      "endOffset" : 147
    }, {
      "referenceID" : 20,
      "context" : "[21] Fix ǫ > 0.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 4,
      "context" : "In the original definition of SVRG [5], the indices it are chosen uniformly at random from [n], rather than proportional to βi.",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 20,
      "context" : "Since we rely on the improved variant of [21], our bound depends on the average of the βi’s, which scale with the average norm of the preconditioned xi’s.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 7,
      "context" : "3 Randomized Block Lanczos A randomized variant of the Block Lanczos method due to [8] is detailed1 in Algorithm 2.",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 7,
      "context" : "1More precisely, Algorithm 2 in [8] returns the projection matrix ŨkŨ k , while we also compute the SVD of ŨkŨ k A.",
      "startOffset" : 32,
      "endOffset" : 35
    }, {
      "referenceID" : 7,
      "context" : "Algorithm 2 Block Lanczos method [8] 1: Input: A ∈ Rd×n, k ≤ d, ǫ′ ∈ (0, 1) 2: q = Θ ( log(n) √ ǫ ) , p = qk, Π ∼ N (0, 1)n×k 3: Compute K = [AΠ, (AA⊤)AΠ, .",
      "startOffset" : 33,
      "endOffset" : 36
    }, {
      "referenceID" : 7,
      "context" : "[8] Consider the run of Algorithm 2 and denote Ãk = ŨkΣ̃kṼk = ∑k i=1 σ̃iũiṽ ⊤ i .",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "Using the Courant minimax principle [1], we obtain the following bound for all i ∈ {k + 1, .",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 2,
      "context" : "Following [3], the classification task is to distinguish between the animal categories to the automotive ones.",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 20,
      "context" : "2 Empirical advantage of Sketched Preconditioned SVRG We now evaluate Algorithm 3 and compare it to the SVRG algorithm of [21].",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 20,
      "context" : "Similarly to previous work on SVRG [21, 5], the size of each epoch, m, is proportional to the number of points, n.",
      "startOffset" : 35,
      "endOffset" : 42
    }, {
      "referenceID" : 4,
      "context" : "Similarly to previous work on SVRG [21, 5], the size of each epoch, m, is proportional to the number of points, n.",
      "startOffset" : 35,
      "endOffset" : 42
    } ],
    "year" : 2016,
    "abstractText" : "We develop a novel preconditioning method for ridge regression, based on recent linear sketching methods. By equipping Stochastic Variance Reduced Gradient (SVRG) with this preconditioning process, we obtain a significant speed-up relative to fast stochastic methods such as SVRG, SDCA and SAG.",
    "creator" : "LaTeX with hyperref package"
  }
}