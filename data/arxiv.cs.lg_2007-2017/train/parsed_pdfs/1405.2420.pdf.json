{
  "name" : "1405.2420.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Optimal Learners for Multiclass Problems",
    "authors" : [ "Amit Daniely" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 5.\n24 20\nv1 [\ncs .L\nG ]\n1 0\nM ay\n2 01"
    }, {
      "heading" : "1. Introduction",
      "text" : "Multiclass classification is the problem of learning a classifier h from a domain X to a label space Y, where |Y| > 2 and the error of a prediction is measured by the probability that h(x) is not the correct label. It is a basic problem in machine learning, surfacing a variety of domains, including object recognition, speech recognition, document categorization and many more. Over the years, multiclass classification has been subject to intense study, both theoretical (Natarajan, 1989; Ben-David et al., 1995; Rubinstein et al., 2006; Daniely et al., 2011, 2012) and practical (e.g. (Shalev-Shwartz et al., 2004; Collins, 2005; Keshet et al., 2005; Torralba et al., 2007)). Many methods have been developed to tackle this problem, starting from the the naive one-vs-all method, to more complex methods, such as structured output prediction (Collins, 2000, 2002; Lafferty et al., 2001; Taskar et al., 2003; Tsochantaridis et al., 2004), error correcting output codes (Dietterich and Bakiri, 1995) and others. These developments made it possible to handle a variety of multiclass classification problems, including even problems that have a very complex label space, that is structured and exponentially large (e.g. speech recognition, OCR, and multiple object categorization).\nDespite being very basic and natural, and despite these developments and efforts, our theoretical understanding of multiclass classification is still far from being satisfactory, in particular relatively to our understanding of binary classification (i.e., when |Y| = 2). In this work, we focus on the sample complexity of (distribution free) learning of hypothesis classes H ⊆ YX . The two most fundamental questions are:\n1. What is learnable? More quantitatively, what is the sample complexity of a given class H?\n2. How to learn? In particular, is there a generic algorithm with optimal sample complexity?\nFor binary classification problems, these two questions are essentially solved (up to logfactors of the error and confidence parameters ǫ and δ): The fundamental result of Vapnik and Chervonenkis (1971) asserts that the VC dimension characterizes the sample complexity, and that any Empirical Risk Minimization (ERM) algorithm enjoys close-to-optimal sample complexity.\nIn a recent surprising result, Daniely et al. (2011) have shown that in multiclass classification there might be substantial gaps between the sample complexity of different ERMs. We start by showing an even stronger “peculiarity”, discriminating binary from multiclass classification. Recall that an algorithm is called improper if it might return a hypothesis that does not belong to the learnt class. Traditionally, improper learning has been applied to enable efficient computations. It seems counter intuitive that computationally unbounded learner would benefit from returning a hypothesis outside of the learnt class. Surprisingly, we show that an optimal learning algorithm must be improper! Namely, we show that there are classes that are learnable only by an improper algorithm. Pointing out that we actually do not understand how to learn optimally, these results “reopen” the above two basic questions for multiclass classification.\nIn this paper we essentially resolve these two questions. We give a new analysis of the multiclass one inclusion algorithm (Rubinstein et al. (2006) based on Haussler et al. (1988), see also Simon and Szörényi (2010)), showing that it is optimal up to a constant factor of 2 in a transductive setting. This improves on the original analysis, that yielded optimality only\nup to a factor of log(|Y|) (which, as explained, might be quite large in several situations). By showing reductions from transductive to inductive learning, we consequently obtain an optimal learner in the PAC model, up to a logarithmic factor of 1δ and 1 ǫ . The analysis of the one inclusion algorithm results with a characterization of the sample complexity of a class H by a sequence of numbers µH(m). Concretely, it follows that the best possible guarantee on the error, after seeing m examples, is Θ (\nµH(m) m\n)\n.\nComparing to binary classification, we should still strive for a better characterization: We would like to have a characterization of the sample complexity by a single number (i.e. some notion of dimension) rather than a sequence. Our analysis of the one inclusion algorithm naturally leads to a new notion of dimension, of somewhat different character than previously studied notions. We show that this notion have certain advantages comparing to other previously studied notions, and formulate a concrete combinatorial conjecture that, if true, would lead to a crisper characterization of the sample complexity.\nDeparting general theory, we turn our focus to investigate hypothesis classes that are used in practice, in light of the above results and the result of Daniely et al. (2011). We consider classes of multiclass linear classifiers that are learnt by several popular learning paradigms, including multiclass SVM with kernels (Crammer and Singer, 2001), structured output prediction (Collins, 2000, 2002; Lafferty et al., 2001; Taskar et al., 2003; Tsochantaridis et al., 2004), and others. Arguably, the two most natural questions in this context are: (i) is the ERM rule still sub-optimal even for such classes? and (ii) If yes, are there efficient optimal learnears for these classes?\nRegarding the first question, we show that even though the sample complexity of these classes is upper bounded in terms of the dimension or the margin, there are sub-optimal ERMs whose sample complexity has additional multiplicative factor that depends on the number of labels. This settles in negative an open question due to Collins (2005). Regarding the second question above, as opposed to the one-inclusion algorithm, which is in general inefficient, for linear classes we derive computationally efficient learners (provided that the hypotheses can be evaluated efficiently), that enjoy optimal sample complexity.\nBasic definitions: Let X be an instance space and Y a label space. To account for margin-based classifiers as well, it would be convenient to allow classifiers to return the label ⊖ that will stand for “don’t know”. A classifier (or hypothesis) is a mapping h : X → (Y ∪ {⊖}). A hypothesis class is a set of classifiers, H ⊂ (Y ∪ {⊖})X . The error of a classifier with respect to a joint distribution over X × Y is the probability that h(x) 6= y. Throughout this paper, we mainly consider learning in the realizable case, which means that there is h∗ ∈ H which has zero error (extensions to agnostic learning are discussed in section A). Therefore, we can focus on the marginal distribution D over X and denote the error of a classifier h with respect to the realizing classifier h∗ as ErrD,h∗(h) := Prx∼D (h(x) 6= h\n∗(x)). A learning algorithm is a function A that receives a training set of m instances, S ∈ Xm, together with their labels according to h∗. We denote the restriction of h∗ to the instances in S by h∗|S . The output of the algorithm A, denoted A(S, h\n∗|S) is a classifier. A learning algorithm is proper if it always outputs a hypothesis from H. A learning algorithm is an ERM learner for the class H if, for any sample, it returns a function in H that minimizes the empirical error relative to any other function in H. The (PAC) sample complexity of a learning algorithm A is the function mA,H defined as follows: For every ǫ, δ > 0,\nmA,H(ǫ, δ) is the minimal integer such that for every m ≥ mA,H(ǫ, δ), every distribution D on X , and every target hypothesis h∗ ∈ H, PrS∼Dm (ErrD,h∗(A(S, h\n∗|S)) > ǫ) ≤ δ. Here and in subsequent definitions, we omit the subscript H when it is clear from context. If no integer satisfying the inequality above, define mA(ǫ, δ) = ∞. H is learnable with A if for all ǫ and δ the sample complexity is finite. The (PAC) sample complexity of a class H is mPAC,H(ǫ, δ) = infAmA,H(ǫ, δ), where the infimum is taken over all learning algorithms. The ERM sample complexity (a.k.a. the uniform convergence sample complexity) of H is the sample complexity that can be guaranteed for any ERM learner. It is defined by mERM,H(ǫ, δ) = supA∈ERM m a A,H(ǫ, δ) where the supremum is taken over all ERM learners for H. Clearly, we always have mPAC ≤ mERM. We use [m] to denote the set {1, . . . ,m}. We treat vectors as column vectors. We denote by ei ∈ R d the i’th vector in the standard basis of Rd. We denote by Bd the closed unit ball in Rd. We denote by Md×k the space of real matrices with d rows and k columns. For a matrix X ∈ Md×k and i ∈ [k], we denote by X\ni ∈ Rd the i’th column of X. Given a subset A ⊆ X , we define H|A = {h|A : h ∈ H}."
    }, {
      "heading" : "2. No optimal learner can be proper",
      "text" : "Our first result shows that, surprisingly, any learning algorithm with a close to optimal sample complexity must be improper.\nTheorem 1 For every 1 ≤ d ≤ ∞ there exists a hypothesis class Hd, with 2 d + 1 labels such that:\n• The PAC sample complexity of Hd is O ( log(1/δ) ǫ ) .\n• The PAC sample complexity of any proper learning algorithm for Hd is Ω ( d+log(1/δ) ǫ ) .\n• In particular, H∞ is a learnable class that is not learnable by a proper algorithm.\nA detailed proof is given in the appendix, and here we sketch the main idea of the proof. Let X be some finite set and let Y = 2X ∪ {∗}. For every A ⊆ X define hA : X → Y\nby hA(x) =\n{\nA x ∈ A ∗ otherwise . Consider the hypothesis class HX ,Cantor = {hA | A ⊂ X} .\nThis class is due to Daniely et al. (2011) and we call it the first Cantor class due to the resemblance to the construction used for proving the famous theorem of Cantor from set theory (e.g., http://en.wikipedia.org/wiki/Cantor’s_theorem). Daniely et al. (2011) employed this class to establish gaps between the sample complexity of different ERM learners. In particular, they have shown that there is an ERM learner with sample complexity ≤ ln(1/δ)ǫ , while there are other ERMs whose sample complexity is Ω ( |X |+ln(1/δ) ǫ ) .\nTo show that no proper learner can be optimal, let Xd be a set consisting of d elements and define the following subclass of HXd,Cantor: Hd = { hA | |A| = ⌊ d 2 ⌋}\n. Since Hd ⊂ HXd,Cantor, we can apply the “good” ERM learner described in Daniely et al. (2011) with respect to the class HXd,Cantor and obtain an algorithm for Hd whose sample complexity is ≤ ln(1/δ)ǫ . Note that this algorithm is improper — it might output a hypothesis from\nHXd,Cantor which is not in Hd. As we show, no proper algorithm is able to learn Hd using o (\nd ǫ\n)\nexamples. To understand the main point in the proof, suppose that an adversary chooses hA ∈ Hd uniformly at random, and let the algorithm learn it, where the distribution on Xd is uniform on the complement of A, denoted A\nc. Now, the error of every hypothesis hB ∈ Hd is |B\\A| d . Therefore, to return a hypothesis with small error, the algorithm must recover a set that is almost disjoint from A, and therefore should recover A. However, if it sees only o(d) examples, all it knows is that some o(d) elements in X do not belong to A. It is not hard to be convinced that with this little information, the probability that the algorithm will succeed is negligible."
    }, {
      "heading" : "3. An optimal learner for general classes",
      "text" : "In this section we describe and analyze a generic optimal learning algorithm. We start with an algorithm for a transductive learning setting, in which the algorithm observes m − 1 labeled examples and an additional unlabeled example, and it should output the label of the unlabeled example. Later, in Section 3.3 we show a generic reduction from the transductive setting to the usual inductive learning model (that is, the vanilla PAC model).\nFormally, in the transductive model, the algorithm observes a set of m unlabeled examples, S ∈ Xm, and then one of them is picked uniformly at random, x ∼ U(S). The algorithm observes the labels of all the examples but the chosen one, and should predict the label of the chosen example. That is, the input of the algorithm, A, is the set S ∈ Xm, and the restriction of some h∗ ∈ H to S \\ x, denoted h∗|S\\x. The algorithm should output y ∈ Y. The error rate of a transductive algorithm A is the function ǫA,H : N → [0, 1] defined as ǫA,H(m) = supS∈Xm,h∗∈H [ Prx∼U(S) ( A(S, h∗|S\\x) 6= h ∗(x) )]\n. The error rate of a class H in the transductive model is defined as ǫH(m) = infA ǫA,H(m), where the infimum is over all transductive learning algorithms."
    }, {
      "heading" : "3.1. The one-inclusion algorithm",
      "text" : "We next describe the one-inclusion transductive learning algorithm of Rubinstein et al. (2006). Let S = {x1, . . . , xm} be an unlabelled sample. For every i ∈ [m] and h ∈ H|S, let ei,h ⊂ H|S be all the hypotheses in H|S whose restriction to S\\{xi} equals to h|S\\{xi}. That is, h′ ∈ ei,h iff for all j 6= i we have h ′(xj) = h(xj). Note that if h ′ ∈ ei,h then ei,h′ = ei,h.\nGiven (x1, y1), . . . , (xi−1, yi−1), (xi+1, yi+1), . . . , (xm, ym) let h ∈ H|S be some hypothesis for which h(xj) = yj for all j 6= i. We know that the target hypothesis can be any hypothesis in ei,h. Therefore, we can think on the transductive algorithm as an algorithm that obtains some ei,h and should output one hypothesis from ei,h. Clearly, if |ei,h| = 1 we know that the target hypothesis is h. But, what should the algorithm do when |ei,h| > 1 ?\nThe idea of the one-inclusion algorithm is to think on the collection E = {ei,h}i∈[m],H∈H|S as a collection of hyperedges of a hypergraph G = (V,E). Recall that in a hypergraph, V is some set of vertices and each hyperedge e ∈ E is some subset of V . In our case, the vertex set is V = H|S . This hypergraph is called the one-inclusion hypergraph. Note that if |e| = 2 for every e ∈ E we obtain the usual definition of a graph. In such a case, an orientation of an undirected edge e = {v1, v2} is picking one of the vertices (e.g. v1) to be the “head” of the edge. Similarly, an orientation of a hyperedge is choosing one v ∈ e to be the “head” of\nthe hyperedge. And, an orientation of the entire hypergraph is a function f : E → V such that for all e ∈ E we have that f(e) ∈ e.\nGetting back to our transductive learning task, it is easy to see that any (deterministic) transductive learning algorithm is equivalent to an orientation function f : E → V of the one-inclusion hypergraph. The error rate of such an algorithm, assuming the target function is h∗ ∈ H|S , is\nPr i∼U([m])\n[f(ei,h∗) 6= h ∗] =\n1\nm\nm ∑\ni=1\n1[f(ei,h∗) 6= h ∗] =\n|{e ∈ E : h∗ ∈ e ∧ f(e) 6= h∗}|\nm . (1)\nThe quantity |{e ∈ E : h∗ ∈ e ∧ f(e) 6= h∗}| is called the out-degree of the vertex h∗ and denoted d+(h∗). It follows that the error rate of an orientation f is maxh∗∈H|S d+(h∗)\nm . It follows that the best deterministic transductive algorithm should find an orientation of the hypergraph that minimizes the maximal out degree. This leads to the one-inclusion algorithm.\nAlgorithm 1 Multiclass one inclusion algorithm for H ⊂ YX\n1: Input: unlabeled examples S = (x1, . . . , xm), labels (y1, . . . , yi−1, yi+1, . . . , ym) 2: Define the one-inclusion graph G = (V,E) where V = H|S and E = {ej,h}j∈[m],h∈V 3: Find orientation f : E → V that minimizes the maximal out-degree of G 4: Let h ∈ V be s.t. h(xj) = yj for all j 6= i, and let ĥ = f(ei,h) 5: Output: predict ĥ(xi)"
    }, {
      "heading" : "3.2. Analysis",
      "text" : "The main result of this section is a new analysis of the one inclusion algorithm, showing its optimality in the transductive model, up to a constant factor of 1/2. In the next subsection we deal with the PAC model.\nTo state our results, we need a few definitions. Let G = (V,E) be a hypergraph. Throughout, we only consider hypergraphs for which E is an antichain (i.e., there are no e1, e2 ∈ E such that e1 is strictly contained in e2). Given U ⊆ V , define the induced hypergraph, G[U ], as the hypergraph whose vertex set is U and whose edge set is all sets e ⊆ U such that e = U∩e′ for some e′ ∈ E, |e| ≥ 2, and e is maximal w.r.t. these conditions.\nThe degree of a vertex v in a hypergraph G = (V,E) is the number of hyperedges, e ∈ E, such that |e| ≥ 2 and v ∈ e. The average degree of G is d(G) = 1|V | ∑ v∈V d(v). The maximal average degree of G is md(G) = maxU⊆V :|U |<∞ d(G[U ]). For a hypothesis class H define\nµH(m) = max{md(G(H|S)) | S ∈ X m} ,\nwhere G(H|S) is the one-inclusion hypergraph defined in Algorithm 1.\nTheorem 2 For every class H, 12 µH(m) m ≤ ǫH(m) ≤ µH(m) m .\nProof To prove the upper bound, recall that the one inclusion algorithm uses an orientation of the one-inclusion hypergraph that minimizes the maximal out-degree, and recall that in\n(1) we have shown that the error rate of an orientation function is upper bounded by the maximal out-degree over m. Therefore, the proof of the upper bound of the theorem follows directly from the following lemma:\nLemma 3 Let G = (V,E) be a hypergraph with maximal average degree d. Then, there exists an orientation of G with maximal out-degree of at most d.\nThe proof of the lemma is given in the appendix. While the above proof of the upper bound is close in spirit to the arguments used by Haussler et al. (1988) and Rubinstein et al. (2006), the proof of the lower bound relies on a new argument. As opposed to Rubinstein et al. (2006) who lower bounded ǫH(m) using the Natarajan dimension, we give a direct analysis.\nLet S ∈ Xm be a set such that md(G(H|S)) = µH(m). For simplicity we assume that |S| = m (i.e., S does not contain multiple elements). Since md(G(H|S)) = µH(m), there is finite F ⊂ G with d(G(F|S)) = µH(m). Consider the following scenario. Suppose that h∗ ∈ F|S is chosen uniformly at random, and in addition, a point x ∈ S is also chosen uniformly at random. Now, suppose that a learner A is given the sample S with all points labelled by h∗ except x that is unlabelled. It is enough to show that the probability that A errs is ≥ µH(m)2m .\nDenote by U the event that x correspond to an edge in G(F|S) coming out of h ∗. Given U , the value of h∗(x), given what the algorithm sees, is distributed uniformly in the set {h(x) | h ∈ F and h|S\\{x} = h ∗|S\\{x}}. Since this set consists of at least two elements, given U , the algorithm errs with probability ≥ 12 .\nIt is therefore enough to prove that Pr(U) ≥ µH(m)m . Indeed, given h ∗, the probability that x corresponds to an edge coming out of h∗ is exactly the degree of h∗ over m. Therefore, the probability that x corresponds to an edge coming out of a randomly chosen h∗ is the average degree of G(F|S) over m, i.e., µH(m) m ."
    }, {
      "heading" : "3.3. PAC optimality: from transductive to inductive learning",
      "text" : "In the previous section we have analyzed the optimal error rate of learning in the transductive learning. We now turn to the inductive PAC model. By a simple reduction from inductive to transductive learning, we will show that a variant of the one-inclusion algorithm is essentially optimal in the PAC model.\nFirst, any transductive algorithm A can be naturally interpreted as an inductive algorithm, which we denote by Ai. Specifically, Ai returns, after seeing the sample S = {(xi, yi)} m−1 i=1 , the hypothesis h : X → Y such that h(x) is the label A would have predicted for x after seeing the labelled sample S. It holds that (see the appendix) the (worst case) expectation of the error of the hypothesis returned by Ai operating on m points sample, is the same, up to a factor of e to ǫA(m). Using this fact and a simple amplification argument, it is not hard to show that a variant of the one-inclusion algorithm is essentially optimal in the PAC model.\nNamely, we consider the algorithm I that splits the sample into 2 log(1/δ) parts, run the one inclusion algorithm on log(1/δ) different parts to obtain log(1/δ) candidate hypotheses, and finally chooses the best one, by validation on the remaining points. As the following\ntheorem (whose proof is given in the appendix) shows, I is optimal up to a factor of O ( log (\n1 δ\n) log ( 1 ǫ )) in the PAC model, in the following sense:\nTheorem 4 For some c > 0, and every class H, mI,H(ǫ, δ) ≤ mPAC,H (cǫ, δ)· 1 c log(1/δ) log(1/ǫ)."
    }, {
      "heading" : "4. Efficient optimal learning and gaps for linear classes",
      "text" : "In this section we study the family of linear hypothesis classes. This family is widely used in practice and received a lot of attention in the literature—see for example Crammer and Singer (2001); Collins (2000, 2002); Lafferty et al. (2001); Taskar et al. (2003); Tsochantaridis et al. (2004). We show that, rather surprisingly, even for such simple classes, there can be gaps between the ERM sample complexity and the PAC sample complexity. This settles in negative an open question raised by Collins (2005). We also derive computationally efficient optimal learners for linear classes, based on the concept of compression schemes. This is in contrast to the one-inclusion algorithm from the previous section, which in general is inefficient. Due to the lack of space, most proofs are deferred to the appendix."
    }, {
      "heading" : "4.1. Linear hypothesis classes",
      "text" : "We first define the various hypothesis classes of multiclass linear classifiers that we study. All of these classes depend on a class-specific feature mapping, Ψ : X × Y → Rd. We will provide several examples of feature mappings that are widely used in practice."
    }, {
      "heading" : "4.1.1. Dimension based linear classifiers (denoted HΨ)",
      "text" : "For w ∈ Rd and x ∈ X , define the multiclass predictor hw(x) = argmaxy∈Y〈w,Ψ(x, y)〉. In case of a tie, hw(x) is assumed to be the “don’t know label”, ⊖. The corresponding hypothesis class is defined as HΨ = {hw | w ∈ R d}.\nExample 1 (multivector construction) If the labels are unstructured, a canonical choice of Ψ is the so called multivector construction. Here, Y = [k], X = Rd and Ψ : X ×Y → Rdk is defined as follows: Ψ(x, y) is the d × k matrix whose y’th column is x, while the rest are 0. In this case, every classifier corresponds to a matrix W , and the prediction on an instance x ∈ Rd is the index of the column that maximizes the inner product with x."
    }, {
      "heading" : "4.1.2. Large margin linear classifiers (denoted HΨ,R)",
      "text" : "The second kind of hypothesis class induced by Ψ is margin based. Here, we assume that the range of Ψ is contained in the unit ball of Rd. Every vector w ∈ Rd defines a function hw : X → (Y ∪ {⊖}) by\n∀x ∈ X , hw(x) =\n{\ny if〈w,Ψ(x, y) −Ψ(x, y′)〉 ≥ 1 for every y′ 6= y\n⊖ if no such y exists\nThe class of linear classifiers of complexity R > 0 induced by Ψ is HΨ,R = { hw | ‖w‖ 2 ≤ R } .\nExample 2 (multivector construction with margin) The margin based analogue to example 1 is defined similarly. This class is the class that is learnt by multiclass SVM.\n4.1.3. The classes Hd,t,q and Hd,t,q,R for structured output prediction\nNext we consider an embedding Ψ that is specialized and used in classification tasks where the number of possible labels is exponentially large, but the labels are structured (e.g. Taskar et al. (2003)). For example, in speech recognition, the label space might me the collection of all sequences of ≤ 20 English words.\nTo motivate the definition, consider the case that we are to recognize a t-letter word appearing in an image. Let q be the size of the alphabet. The set of possible labels is naturally associated with [q]t. A popular method to tackle this task (see for example Taskar et al. (2003)) is the following: The image is broken into t parts, each of which contains a single letter. Each letter is represented as a vector in Rd. Thus, each image is represented as a matrix in Md×t. To devise a linear hypothesis class to this problem, we should specify a mapping Ψ : Md×t × [q]\nt → Rn for some n. Given X ∈ Md×t and y ∈ [q]t, Ψ(X, y) will be a pair (Ψ1(X, y),Ψ2(X, y)). The mapping Ψ1 allows the classifiers to take into account the shape of the letters appearing in the different t parts the word was broken into. The mapping Ψ2 allows the classifiers to take into account the structure of the language (e.g. the fact that the letter “u” usually appears after the letter “q”). Ψ1(X, y) ∈ Md×q is the matrix whose j’th column is the sum of the columns X\ni with yi = j (in other words, the j’th column is the sum of the letters in the image that are predicted to be j by y). Ψ2(X, y) ∈ Mq,q will be the matrix with 1 in the (i, j) entry if the letter j appears after the letter i somewhere in the word y, and 0 in all other entries. Even though the number of labels is exponential in t, this class (in the realizable case) can be learnt in time polynomial in d, t and q (see Collins (2005)).\nWe will show gaps in the performance of different ERMs for the class HΨ. If fact, we will prove a slightly stronger result. We will consider the class HΨ1 , that we will denote by Hd,t,q. It is easy to see that HΨ1 can be realized by HΨ. Therefore, any lower bound for HΨ1 automatically lower bounds also HΨ. As for upper bounds, as long as q = O(d), the upper bounds we show are the same for HΨ and HΨ1 . To summarize, the gaps we show for HΨ1 automatically (as long as q = O(d)) hold for HΨ as well.\nFinally, we define a margin-based analogue to Hd,t,q. The instance space is (B d)t, and we treat each X ∈ (Bd)t as a matrix with t columns, each of which is a vector in Bd. The labels are [q]t. Define Ψ : (Bd)t × [q]k → Md×q as follows: for X ∈ (B\nd)t and y ∈ [q]t, Ψ(X, y) is the matrix whose j’th column is 1q of the average of all columns X\ni such that yi = j. Note that the range of Ψ is contained in the unit ball. For R > 0, define Hd,t,q,R := HΨ,R."
    }, {
      "heading" : "4.2. Results",
      "text" : "We begin with linear predictors without margin. The first part of the following theorem asserts that for every Ψ : X ×Y → Rd there is some algorithm that learns HΨ with sample complexity O (\nd log(1/ǫ)+log(1/δ) ǫ\n)\n. The second part of the theorem shows that in several\ncases (i.e., for some Ψ’s), this algorithm outperforms other ERMs, by a factor of log(|Y|).\nTheorem 5\n• For every Ψ : X × Y → Rd, the PAC sample complexity of HΨ is O ( d log(1/ǫ)+log(1/δ) ǫ ) ,\nand is achievable by a new efficient1 compression scheme. • For every Y and d > 0, there is some Ψ : X × Y → Rd for which the ERM sample\ncomplexity of HΨ is Ω ( d log(|Y|)+log(1/δ) ǫ ) .\nTo put the result in the relevant context, it was known (e.g. Daniely et al. (2011)) that the sample complexity of every ERM for this class is O (\nd log(|Y|) log(1/ǫ)+log(1/δ) ǫ\n)\n. In particular,\nthe second part of the theorem is tight, up to the logarithmic dependence over 1ǫ . However, it was not known whether the factor of log(|Y|) for general ERM is necessary. The second part of the theorem shows that this factor is indeed necessary.\nAs to the tightness of the first part, for certain embeddings, including the multivector\nconstruction (example 1), a lower bound of Ω (\nd+log(1/δ) ǫ\n)\nis known for every algorithm.\nHence, the first part of the theorem is also tight up to the logarithmic dependence over 1ǫ . Our second theorem for linear classes is analogous to theorem 5 for margin based classes. The first part shows that for every Ψ : X × Y → Bd there is some algorithm that learns HΨ,R with sample complexity O ( R log(1/ǫ)+log(1/δ) ǫ ) . The second part of the theorem shows that in several cases, the above algorithm outperforms other ERMs, by a factor of log(|Y|).\nTheorem 6\n• For every Ψ : X × Y → Bd and R > 0, the PAC sample complexity of HΨ,R is\nO (\nR log(1/ǫ)+log(1/δ) ǫ\n)\n. • For every Y and R > 0, there is some Ψ : X × Y → Bd for2 which the ERM sample\ncomplexity of HΨ,R is Ω ( R log(|Y|)+log(1/δ) ǫ ) .\nThe first part of the theorem is not new. An algorithm that achieves this bound is the perceptron. It was known (e.g. Collins (2005)) that the sample complexity of every ERM for this class is O (\nR log(|Y|/ǫ)+log(1/δ) ǫ\n)\n. In particular, the second part of the theorem is tight,\nup to the logarithmic dependence over 1ǫ . However, it was not known whether the gap is real: In (Collins, 2005), it was left as an open question to show whether the perceptron’s bound holds for every ERM. The second part of the theorem answers this open question in negative. Regarding lower bounds, as in the case of HΨ, for certain embeddings, including the multivector construction with margin (example 1), a lower bound of Ω (\nR+log(1/δ) ǫ\n)\nis\nknown and valid for every learning algorithm. In particular, the first part of the theorem is also tight up to the logarithmic dependence over 1ǫ .\nAn additional result that we report on shows that, for every Ψ : X × Y → Rd, the Natarajan dimension of HΨ is at most d (the definition of the Natarajan dimension is recalled in the appendix). This strengthens the result of (Daniely et al., 2011) who showed that it is bounded by O(d log(d)). It is known (e.g. Daniely et al. (2012)) that for the multivector construction (example 1), in which the dimension of the range of Ψ is dk, the\n1. Assuming we have an appropriate separation oracle. 2. Here, d can be taken to be polynomial in R and log(|Y|).\nNatarajan dimension is lower bounded by (d − 1)(k − 1). Therefore, the theorem is tight up to a factor of 1 + o(1).\nTheorem 7 For every Ψ : X × Y → Rd, Ndim(HΨ) ≤ d.\nNext, we give analogs to theorems 5 and 6 for the structured output classes Hd,k and Hd,k,R. These theorems show that the phenomenon of gaps between different ERMs, as reported in (Daniely et al., 2011), happens also in hypothesis classes that are used in practice.\nTheorem 8 • For every d, t, q > 0, the PAC sample complexity of Hd,t,q is O ( dq log(1/ǫ)+log(1/δ) ǫ ) . • For every d, t, q > 0 the ERM sample complexity of Hd,t,q is Ω ( dq log(t)+log(1/δ) ǫ ) .\nTheorem 9 • For every d, t, q,R > 0, the PAC sample complexity of Hd,t,q,R is O ( R log(1/ǫ)+log(1/δ) ǫ )\n. • For every t, q,R > 0 and d ≥ (t + 1)R, the ERM sample complexity of Hd,t,q,R is\nΩ (\nR log(t)+log(1/δ) ǫ\n)\n.\nThe first parts of theorems 8 and 9 are direct consequences of theorems 5 and 6. These results are also tight up to the logarithmic dependence over 1ǫ . The second parts of the theorems do not follow from theorems 5 and 6. Regarding the tightness of the second part, the best known upper bounds for the ERM sample complexity of Hd,t,q and Hd,t,q,R are O ( dqt log( 1 ǫ )+log(1/δ)\nǫ\n) and O ( Rt log( 1 ǫ )+log(1/δ)\nǫ\n)\nrespectively. Closing the gap between these\nupper bounds and the lower bounds of theorems 8 and 9 is left as an open question."
    }, {
      "heading" : "4.3. The compression-based optimal learners",
      "text" : "Each of the theorems 5, 6, 8 and 9 are composed of two statements. The first claims that some algorithm have a certain sample complexity, while the second claims that there exists an ERM whose sample complexity is worse than the sample complexity of the algorithm from the first part. As explained in this subsection, the first parts of these theorems are established by devising (efficient) compression schemes. In the next subsection we will elaborate on the proof of the second parts (the lower bounds on specific ERMs). Unfortunately, due to lack of space, we must be very brief.\nWe now show that for linear classes, it is possible to derive optimal learners which are also computationally efficient. For the case of margin-based classes, this result is not new — an efficient algorithm based on the multiclass perceptron has been proposed in Collins (2002). For completeness, we briefly survey this approach in the appendix. For dimension based linear classes, we give a new efficient algorithm.\nThe algorithm relies on compression based generalization bounds (see Theorem 18 in the appendix). Based on this theorem, it is enough to show that for every Ψ : X ×Y → Rd, HΨ has a compression scheme of size d. We consider the following compression scheme. Given a realizable sample (x1, y1), . . . , (xm, ym), let Z ⊆ R\nd be the set of all vectors of the form Ψ(xi, yi) − Ψ(xi, y) for y 6= yi. Let w be the vector of minimal norm in the convex hull of Z, conv(Z). Note that by the convexity of conv(Z), w is unique and can be found efficiently using a convex optimization procedure. Represent w as a convex combination of\nd vectors from Z. This is possible since, by claim 1 below, 0 6∈ conv(Z). Therefore, w is in the boundary of the polytope conv(Z). Thus, w lies in a convex polytope whose dimension is ≤ d− 1, and is the convex hull of points from Z. Therefore, by Caratheodory’s theorem (and using its efficient constructive proof), w is a convex combination of ≤ d points from Z. Output the examples in the sample that correspond to the vectors in the above convex combination. If there are less than d such examples, arbitrarily output more examples.\nThe De-Compression procedure is as follows. Given (x1, y1), . . . , (xd, yd), let Z ′ ⊆ Rd be the set of all vectors of the form Ψ(xi, yi)− Ψ(xi, y) for y 6= yi. Then, output the minimal norm vector w ∈ conv(Z ′).\nIn the appendix (Section D.5) we show that this is indeed a valid compression scheme, that is, if we start with a realizable sample (x1, y1), . . . , (xm, ym), compress it, and then de-compress it, we are left with a hypothesis that makes no errors on the original sample."
    }, {
      "heading" : "4.4. Lower bounds for specific ERMs",
      "text" : "Next, we explain how we prove the second parts of theorems 5, 6, 8 and 9. For theorems 5 and 6, the idea is to start with the first Cantor class (introduced in section 2) and by a geometric construction, realize it by a linear class. This realization enables us to extend the “bad ERM” for the first Cantor class, to a “bad ERM” for that linear class. The idea behind the lower bounds of theorems 8 and 9 is similar, but technically more involved. Instead of the first Cantor class, we introduce a new discrete class, the second Cantor class, which may be of independent interest. This class, which can be viewed as a dual to the first Cantor class, is defined as follows. Let Ỹ be some non-empty finite set. Let X = 2Ỹ and\nlet Y = Ỹ ∪ {∗}. For every y ∈ Ỹ define a function hy : X → Y by hy(A) =\n{\ny y ∈ A ∗ otherwise .\nAlso, let h∗ : X → Y be the constant function ∗. Finally, let HY ,Cantor = {hy | y ∈ Y}. In section C we show that the graph dimension (see a definition in the appendix) of HY ,Cantor is Θ(log(|Y|)). The analysis of the graph dimension of this class is more involved than the first Cantor class: by a probabilistic argument, we show that a random choice of Ω (log(|Y|)) points from X is shattered with positive probability. We show also (see section C) that the PAC sample complexity of HY ,Cantor is ≤ log(1/δ)\nǫ . Since the graph dimension characterizes the ERM sample complexity (see the appendix), this class provides another example of a hypothesis class with gaps between ERM and PAC learnability."
    }, {
      "heading" : "5. A new dimension",
      "text" : "Consider again the question of characterizing the sample complexity of learning a class H. Theorem 2 shows that the sample complexity of a class H is characterized by the sequence of densities µH(m). A better characterization would be a notion of dimension that assigns a single number, dim(H), that controls the growth of µH(m), and consequently, the sample complexity of learning H. To reach a plausible generalization, let us return for a moment to binary classification, and examine the relationships between the VC dimension and the sequence µH(m). It is not hard to see that\n• The VC dimension of H is the maximal number d such that µH(d) = d.\nMoreover, a beautiful result of Haussler et al. (1988) shows that\n• If |Y| = 2, then VCdim(H) ≤ µH(m) ≤ 2VCdim(H) for every m ≥ VCdim(H).\nThese definition and theorem naturally suggest a generalization to multiclass classification:\nDefinition 10 The dimension, dim(H), of the class H ⊂ YX is the maximal number d such that µH(d) = d.\nConjecture 11 There exists a constant C > 0 such that for every H and m ≥ dim(H), dim(H) ≤ µH(m) ≤ C · dim(H) . Consequently, by Theorem 2,\nǫH(m) = Θ\n(\ndim(H)\nm\n)\nand Ω\n(\ndim(H) + log ( 1 δ )\nǫ\n)\n≤ mH(ǫ, δ) ≤ O\n(\ndim(H) log ( 1 δ )\nǫ\n)\nFor concreteness, we give an equivalent definition of dim(H) and a formulation of conjecture 11 that are somewhat simpler, and do not involve the sequence µH(m)\nDefinition 12 Let H ⊂ YX . We say that A ⊂ X is shattered by H is there exists a finite F ⊂ H such that for every x ∈ A and f ∈ F there is g ∈ F such that g(x) 6= f(x) and g|A\\{x} = f |A\\{x}. The dimension of H is the maximal cardinality of a shattered set.\nRecall that the degree (w.r.t. H ⊂ YX ) of f ∈ H is the number of points x ∈ X for which there exists g ∈ H that disagree with f only on x. We denote the average degree of H by d(H).\nConjecture 13 There exists C > 0 such that for every finite H, d(H) ≤ C · dim(H).\nBy combination of theorems 2 and Rubinstein et al. (2006), a weaker version of conjecture 11 is true. Namely, that for some absolute constant C > 0\ndim(H) ≤ µH(m) ≤ C · log(|Y|) · dim(H) . (2)\nIn addition, it is not hard to see that the new dimension is bounded between the Natarajan and Graph dimensions, Ndim(H) ≤ dim(H) ≤ Gdim(H). For the purpose of characterizing the sample complexity, this inequality is appealing for two reasons. First, it is known (Daniely et al., 2011) that the graph dimension does not characterize the sample complexity, since it can be substantially larger than the sample complexity in several cases. Therefore, any notion of dimension that do characterize the sample complexity must be upper bounded by the graph dimension. As for the Natarajan dimension, it is known to lower bound the sample complexity. By Theorem 2 and equation (2), the new dimension also lower bounds the sample complexity. Therefore, the left inequality shows that the new dimension always provides a lower bound that is at least as good as the Natarajan dimension’s lower bound."
    }, {
      "heading" : "Appendix A. Agnostic learning and further directions",
      "text" : "In this work we focused on learning in the realizable setting. For general hypothesis classes, it is left as an open question to find an optimal algorithm for the agnostic setting. However, for linear classes, our upper bounds are attained by compression schemes. Therefore, as indicated by Theorem 18, our results can be extended to the agnostic setting, yielding algorithms for HΨ and HΨ,R whose sample complexity is O ( d log(d/ǫ)+log(1/δ) ǫ2 ) and O (\nR log(R/ǫ)+log(1/δ) ǫ2\n)\nrespectively. We note that these upper bounds are optimal, up to the\nfactors of log(d/ǫ) and log(R/ǫ). Our lower bounds clearly hold for agnostic learning (this is true for any lower bound on the realizable case). Yet, we would be excited to see better lower bounds for the agnostic setting. Specifically, are there classes H ⊂ YX of Natarajan dimension d with ERMs whose agnostic sample complexity is Ω (\nd log(|Y|) ǫ2\n)\n?\nExcept extensions to the agnostic settings, the current work suggests several more directions for further research. First, it would be very interesting to go beyond multiclass classification, and to devise generic optimal algorithms for other families of learning problems. Second, as noted before, naive implementation of the one-inclusion algorithm is prohibitively inefficient. Yet, we still believe that the ideas behind the one-inclusion algorithm might lead to better efficient algorithms. In particular, it might be possible to derive efficient algorithms based on the principles behind the one-inclusion algorithm, and maybe even give an efficient implementation of the one-inclusion algorithm for concrete hypothesis classes."
    }, {
      "heading" : "Appendix B. Background",
      "text" : ""
    }, {
      "heading" : "B.1. The Natarajan and Graph Dimensions",
      "text" : "We recall two of the main generalizations of the VC dimension to multiclass hypothesis classes.\nDefinition 14 (Graph dimension) Let H ⊆ (Y ∪ {⊖})X be a hypothesis class. We say that A ⊆ X is G-shattered if there exists h : A → Y such that for every B ⊆ A there is h′ ∈ H with h(A) ⊂ Y for which\n∀x ∈ B, h′(x) = h(x) while ∀x ∈ A \\B, h′(x) 6= h(x) .\nThe graph dimension of H, denoted Gdim(H), is the maximal cardinality of a G-shattered set.\nAs the following theorem shows, the graph dimension essentially characterizes the ERM sample complexity.\nTheorem 15 (Daniely et al. (2011)) For every hypothesis class H with graph dimension d,\nΩ\n(\nd+ log(1/δ)\nǫ\n)\n≤ mERM(ǫ, δ) ≤ O\n(\nd log(1/ǫ) + log(1/δ)\nǫ\n)\n.\nDefinition 16 (Natarajan dimension) Let H ⊆ (Y ∪ {⊖})X be a hypothesis class. We say that A ⊆ X is N -shattered if there exist h1, h2 : A → Y such that ∀x ∈ A, h1(x) 6= h2(x) and for every B ⊆ A there is h ∈ H for which\n∀x ∈ B, h(x) = h1(x) while ∀x ∈ A \\B, h(x) = h2(x) .\nThe Natarajan dimension of H, denoted Ndim(H), is the maximal cardinality of an N - shattered set.\nTheorem 17 (essentially Natarajan (1989)) For every hypothesis class H ⊂ (Y ∪ {⊖})X with Natarajan dimension d,\nΩ\n(\nd+ log(1/δ)\nǫ\n)\n≤ mPAC(ǫ, δ) ≤ O\n(\nd log(|Y|) log(1/ǫ) + log(1/δ)\nǫ\n)\n.\nWe note that the upper bound in the last theorem follows from theorem 15 and the fact that (see Ben-David et al. (1995)) for every hypothesis class H,\nGdim(H) ≤ 5 log(|Y|)Ndim(H) . (3)\nWe also note that (Daniely et al., 2011) conjectured that the logarithmic factor of |Y| in Theorem 17 can be eliminated (maybe with the expense of poly-logarithmic factors of 1ǫ , 1 δ and Ndim(H))."
    }, {
      "heading" : "B.2. Compression Schemes",
      "text" : "A compression scheme of size d for a class H is a pair of functions:\nCom : ∪∞m=d(X × Y) m → (X × Y)d and DeCom : (X × Y)d → YX ,\nwith the property that for every realizable sample\nS = (x1, y1), . . . , (xm, ym)\nit holds that, if h = DeCom ◦Com(S) then\n∀1 ≤ i ≤ m, yi = h(xi) .\nEach compression scheme yields a learning algorithm, namely, DeCom ◦Com. It is known that the sample complexity of this algorithm is upper bounded by the size of the compression scheme. Precisely, we have:\nTheorem 18 (Littlestone and Warmuth (1986)) Suppose that there exists a compression scheme of size d for a class H. Then:\n• The PAC sample complexity of H is upper bounded by O ( d log(1/ǫ)+ 1 δ\nǫ\n)\n• The agnostic PAC sample complexity of H is upper bounded by O ( d log(d/ǫ)+ 1 δ\nǫ2\n)"
    }, {
      "heading" : "Appendix C. The Cantor classes",
      "text" : "C.1. The first Cantor class\nLet X be some finite set and let Y = 2X ∪ {∗}. For every A ⊆ X define hA : X → Y by\nhA(x) =\n{\nA x ∈ A ∗ otherwise .\nFinally, let HX ,Cantor = {hA | A ⊂ X} .\nLemma 19 (Daniely et al. (2011))\n• The graph dimension of HX ,Cantor is |X |. Therefore, the ERM sample complexity of\nHX ,Cantor is Ω ( |X |+log(1/δ) ǫ ) .\n• The Natarajan dimension of HX ,Cantor is 1. Furthermore, the PAC sample complexity\nof HX ,Cantor is O ( log(1/δ) ǫ ) .\nProof For the first part, it is not hard to see that the function f∅ witnesses the G-shattering of X . The second part follows directly from Lemma 20, given below.\nLemma 20 (essentially Daniely et al. (2011)) Let H ⊂ YX be a hypothesis class with the following property: There is a label ∗ ∈ Y such that, for every f ∈ H and x ∈ X , either f(x) = ∗ or f is the only function in H whose value at x is f(x). Then,\n• The PAC sample complexity of H is ≤ log(1/δ)ǫ .\n• Ndim(H) ≤ 1.\nProof We first prove the second part. Assume on the way of contradiction that Ndim(H) > 1. Let {x1, x2} ⊆ X be an N -shattered set of cardinality 2 and let f1, f2 be two functions that witness the shattering. Since f1(x1) 6= f2(x1), at least one of f1(x1), f2(x1) is different from ∗. W.l.o.g, assume that f1(x1) 6= ∗. Now, by the definition of N -shattering, there is a function f ∈ HY ,Cantor such that f(x1) = f1(x1) and f(x2) = f2(x2) 6= f1(x2). However, the only function in H satisfying f(x1) = f1(x1) is f1. A contradiction.\nWe proceed to the first part. Assume w.l.o.g. the the function f∗ ≡ ∗ is in H. Consider the following algorithm. Given a (realizable) sample\n(x1, y1), . . . , (xm, ym),\nif yi = ∗ for every i then return the function f∗. Otherwise, return the hypothesis h ∈ H, that is consistent with the sample. Note the the existence of a consistent hypothesis is guaranteed, as the sample is realizable. This consistent hypothesis is also unique: if yi 6= ∗ then, by the assumption on H, there is at most one function f ∈ H for which h(xi) = yi.\nThis algorithm is an ERM with the following property: For every learnt hypothesis and underlying distribution, the algorithm might return only one out of two functions – either f∗ or the learnt hypothesis. We claim that the sample complexity of such an ERM must be ≤ log(1/δ)ǫ . Indeed such an algorithm returns a hypothesis with error ≥ ǫ only if:\n• Err(f∗) ≥ ǫ.\n• For every i ∈ [m], yi = ∗.\nHowever, if Err(f∗) ≥ ǫ, the probability that yi = ∗ is ≤ 1 − ǫ. Therefore, the probability of the the second condition is ≤ (1− ǫ)m ≤ e−mǫ, which is ≤ δ if m ≥ log(1/δ)ǫ .\nC.2. The second Cantor class\nLet Ỹ be some non-empty finite set. Let X = 2Ỹ and let Y = Ỹ ∪ {∗}. For every y ∈ Ỹ define a function hy : X → Y by\nhy(A) =\n{\ny y ∈ A ∗ otherwise .\nAlso, let h∗ : X → Y be the constant function ∗. Finally, let HY ,Cantor = {hy | y ∈ Y}.\nLemma 21\n• The graph dimension of HY ,Cantor is Θ(log (|Y|)). Therefore, the ERM sample com-\nplexity of HY ,Cantor is Ω ( log(|Y|)+log(1/δ) ǫ ) .\n• The Natarajan dimension of HY ,Cantor is 1. Furthermore, the PAC sample complexity\nof HY ,Cantor is O ( log(1/δ) ǫ ) .\nProof The second part of the lemma follows from Lemma 20. We proceed to the first part. First, by equation (3) and the second part, Gdim(HY ,Cantor) ≤ 5 log(|Y|). It remains to show that Gdim(HY ,Cantor) ≥ Ω (log(|Y|)). To do so, we must show that there are r = Ω(log(|Y|)) sets A = {A1, . . . , Ar} ⊆ X such that A is G-shattered by HY ,Cantor. To do so, we will use the probabilistic method (see e.g. Alon and Spencer (2000)). We will choose A1, . . . , Ar ⊆ Ỹ at random, such that each Ai is chosen uniformly at random from all subsets of Ỹ (i.e., each y ∈ Ỹ is independently chosen to be in Ai with probability 1 2 ) and the different Ai’s are independent. We will show that if r = ⌊ log(|Y|−1)\n2 ⌋ − 2, then with positive probability A = {A1, . . . , Ar} is G-shattered and |A| = r (i.e., the Ai’s are different).\nDenote d = |Ỹ |. Let ψ : [r] → X be the (random) function ψ(i) = Ai and let φ : Y → {0, 1} be the function that maps each y ∈ Ỹ to 1 and ∗ to 0. Consider the (random) binary hypothesis class H = {φ ◦ hy ◦ ψ | y ∈ Ỹ}. As we will show, for r = ⌊ log(d)\n2 ⌋ − 2, E[|H|] > 2r − 1. In particular, there exists some choice of A = {A1, . . . , Ar} for which |H| > 2r − 1. Fix those sets for a moment. Since always |H| ≤ 2r, it must be the case that |H| = 2r, i.e., H = 2[r]. By the definition of H, it follows that for every B ⊆ [r], there is hy ∈ HY ,Cantor such that for every i ∈ B, hy(Ai) = ∗, while for every i /∈ B, hy(Ai) 6= ∗. It follows that |A| = r and A is G-shattered.\nIt remains to show that indeed, for r = ⌊ log(d)2 ⌋ − 2, E[|H|] > 2 r − 1. For every S ⊆ [r],\nLet χS be the indicator random variable that is 1 if and only if 1S ∈ H. We have\nE[|H|] = E[ ∑\nS⊆[r]\nχS] = ∑\nS⊆[r]\nE[χS ] . (4)\nFix some S ⊆ [r]. For every y ∈ Ỹ let χS,y be the indicator function that is 1 if and only if 1S = φ ◦ hy ◦ ψ. Note that ∑\ny∈Ỹ χS,y > 0 if and only if χS = 1. Therefore,\nE[χS ] = Pr (χS = 1) = Pr ( ∑ y∈Ỹ χS,y > 0 ) . Observe that\nE[ ∑\ny∈Ỹ\nχS,y] = ∑\ny∈Ỹ\nPr (y ∈ Ai iff i ∈ S) = d · 2 −r .\nWe would like to use Chebyshev’s inequality for the sum ∑\ny∈Ỹ χS,y. For this to be effective,\nwe show next that for different y1, y2 ∈ Ỹ , χS,y1 and χS,y2 are uncorrelated. Note that E[χS,y1χS,y2 ] is the probability that for every i ∈ S, y1, y2 ∈ Ai while for every i /∈ S, y1, y2 /∈ Ai. It follows that\nE[χS,y1χS,y2 ] = 2 −2r .\nTherefore, cov(χS,y1χS,y2) = E[χS,y1χS,y2 ] − E[χS,y1 ]E[χS,y2 ] = 2 −2r − 2−r2−r = 0. We conclude that χS,y1 and χS,y2 are uncorrelated. Thus, by Chebyshev’s inequality,\nPr (χS = 0) = Pr\n\n\n∑\ny∈Ỹ\nχS,y = 0\n\n\n≤ Pr\n\n\n∣ ∣ ∣ ∣ ∣ ∣ ∑\ny∈Ỹ\nχS,y − d · 2 −r\n∣ ∣ ∣ ∣ ∣ ∣ ≥ d · 2−r−1  \n≤ 22r+2\nd2 var\n\n\n∑\ny∈Ỹ\nχS,y\n\n\n= 22r+2\nd2\n∑\ny∈Ỹ\nvar (χS,y)\n≤ 22r+2\nd2\n∑\ny∈Ỹ\nE[χS,y]\n= 22r+2\nd2 d2−r =\n2r+2\nd .\nRemember that r = ⌊ log(d)2 ⌋−2, so that d > 2 2r+2. Hence, E[χS ] = 1−Pr(χS = 0) ≥ 1−2 −r. Using equation (4), we conclude that\nE[|H|] > (1− 2−r)2r = 2r − 1."
    }, {
      "heading" : "Appendix D. Proofs",
      "text" : "D.1. Some lemmas and additional notations\nLet X ′,Y ′ be another instance and label spaces. Let Γ : X ′ → X and Λ : Y∪{⊖} → Y ′∪{⊖}. We denote\nΛ ◦ H ◦ Γ = {Λ ◦ h ◦ Γ | h ∈ H} .\nIf Γ (respectively Λ) is the identity function we simplify the above notation to Λ ◦ H (respectively H ◦ Γ). We say that a hypothesis class H′ ⊆ (Y ′ ∪ {⊖})X ′\nis realizable by H ⊆ (Y ∪ {⊖})X if H′ ⊆ Λ ◦ H ◦ Γ for some functions Γ and Λ. Note that in this case, the different notions of sample complexity with respect to H′ are never larger than the corresponding notions with respect to H.\nLet H ⊂ (Y ∪ {⊖})X be a hypothesis class. The disjoint union of m copies of H is the hypothesis class Hm whose instance space is Xm := X × [m], whose label space is Y ∪ {⊖}, and that is composed of all functions f : Xm → Y ∪ {⊖} whose restriction to each copy of X is a function in H (namely, for every i ∈ [m], the function x 7→ f(x, i) belongs to H).\nLemma 22 Let H ⊆ YX be a hypothesis class. Let Hm be a disjoint union of m copies of H.\n1. If H is realized by HΨ for some Ψ : X ′ × Y ′ → Rd, then Hm is realized by HΨm for\nsome Ψm : X ′ m × Y ′ → Rdm. Here, X ′m is a disjoint union of m copies of X ′.\n2. If H is realized by HΨ,R for some Ψ : X ′ ×Y ′ → Bd, then Hm is realized by HΨm,mR\nfor some Ψm : X ′ m × Y ′ → Bdm. Here, X ′m is a disjoint union of m copies of X ′.\n3. If H is realized by Hd,k, then Hm is realized by Hdm,k.\n4. If H is realized by Hd,k,R, then Hm is realized by Hdm,k,mR.\nProof We prove only part 1. The remaining three are very similar. Let Γ : X → X ′,Λ : Y ′ → Y be two mappings for which\nH ⊆ Λ ◦ HΨ ◦ Γ .\nLet Xm = X × [m] be a disjoint union of m copies of X . Let Ti : R d → Rdm be the linear mapping that maps ej to e(i−1)d+j . Define Ψm : Xm × Y → R dm by Ψm((x, i), y) = Ti(Ψ(x, y)). Define Γm : Xm → X ′ m by Γm(x, i) = (Γ(x), i). It is not hard to check that\nHm ⊆ Λ ◦ HΨm ◦ Γm .\nLemma 23 Let H ⊆ (Y ∪ {⊖)X be a hypothesis class and let Hm be a disjoint union of m copies of H. Then Gdim(Hm) = m ·Gdim(H).\nProof A routine verification."
    }, {
      "heading" : "D.2. Proof of Theorem 1",
      "text" : "For simplicity, we prove the theorem for d even and d = ∞. For finite d, fix some d-elements set Xd. Let Yd = 2 Xd ∪ {∗}. For A ⊆ Xd define hA : Xd → Yd by\nhA(x) =\n{\nA x ∈ A ∗ otherwise .\nFinally, let\nHd =\n{\nhA | |A| = d\n2\n}\n.\nWe next define a “limit” of the classes Hd. Suppose that the sets {Xd}d is even integer are pairwise disjoint. Let X∞ = ∪d is evenXd and Y∞ = ( ∪d is even2 Xd )\n∪ {∗}. For A ⊆ Xd, extend hA : Xd → Yd to a function hA : X∞ → Y∞ by defining it to be ∗ outside of Xd. Finally, let\nH∞ =\n{\nhA | for some d, A ⊆ Xd and |A| = d\n2\n}\n.\nWe will use the following version of Chernoff’s bound:\nTheorem 24 Let X1, . . . ,Xn ∈ {0, 1} be independent random variables, X = X1+. . .+Xn and µ = E[X]. Then Pr (X ≥ 2µ) ≤ exp (\n−µ3 ) .\nWe are now ready to prove Theorem 1. The first part follows from Lemma 20. The last part is a direct consequence of the first and second part. We proceed to the second part. For d < ∞, the task of properly learning Hd can be easily reduced to the task of properly learning H∞. Therefore, the sample complexity of learning H∞ by a proper learning algorithm is lower bounded by the sample complexity of properly learning Hd. Therefore, it is enough to prove the second part for finite d.\nFix some x0 ∈ X . Let ǫ > 0. Let A ⊂ Xd \\ {x0} be a set with d 2 elements. Let DA be a distribution on Xd × Yd that assigns a probability of 1 − 16ǫ to some point (x0, hA(x0)) ∈ Xd ×Yd and is uniform on the remaining points of the form {(x, hA(x)) | x 6∈ A}.\nWe claim that there is some A such that whenever A runs on DA with m ≤ 1 128 d ǫ examples, it outputs with probability ≥ 12 a hypothesis with error ≥ ǫ. This shows that for every δ < 12 , mA(ǫ, δ) ≥ 1 128 d ǫ . Also, since Hd contains two different function that agree on some point, by a standard argument, we have mA(ǫ, δ) = Ω ( log(1/δ) ǫ ) . Combining these two estimates, the proof is established. It remains to show the existence of such A. Suppose that A is chosen uniformly at random among all subsets of Xd \\ {x0} of size d 2 . Let X be the random variable counting the number of samples, out of 1128 d ǫ i.i.d. examples drawn from DA, which are not (x0, hA(x0)). We have E[X] = 1 8d. Therefore, by Chernoff’s bound 24, with probability > 1 − exp (\n− d24 ) > 12 , the algorithm will see less than d 4 examples whose instance is from\nX \\ {x0} \\A. Conditioning on this event, A is a uniformly chosen random set of size d 2 that is chosen uniformly from all subsets of a set X ′ ⊂ X with |X ′| ≥ 34d (X ′ is the set of all points that are not present in the sample), and the hypothesis returned by the algorithm is hB , where B ⊂ X is a subset of size d 2 that is independent from A. It is not hard to see that in this case E|B \\ A| ≥ 16d. Hence, there exists some A for which, with probability > 12 over the choice of the sample, |B \\ A| ≥ 1 6d. For such A we have, since hB errs on all elements in B \\ A and the probability of each such element is ≥ 16ǫd 2 = 32d ǫ,\nErrDA(hB) ≥ |B \\ A| 32ǫ\nd ≥\nd\n6\n32ǫ\nd > ǫ\nwith probability > 12 over the choice of the sample."
    }, {
      "heading" : "D.3. Proof of Lemma 3",
      "text" : "We first prove it to finite hypergraphs. We use induction on the number of vertices. By assumption, d(G) ≤ d. Therefore, there is v0 ∈ V with d(v0) ≤ d. Let G\n′ = (V ′, E′) = G[V \\ {v0}]. By the induction hypothesis, there exists an orientation h\n′ : E′ → V ′ with maximal out-degree d. We define an orientation h : E → V by\nh(e) =\n{\nv e = {v0, v} h′(e \\ {v0}) otherwise\nThe lemma extend to the case where Y is infinite by a standard application of the compactness theorem for propositional calculus."
    }, {
      "heading" : "D.4. Proof of theorem 4",
      "text" : "Let A be some learning algorithm, and denote by I the one inclusion algorithm. Suppose that we run A on mA,H ( ǫ 2 , ǫ 2 )\nexamples, obtain a hypothesis h and predict h(x) on some new example. The probability of error if ≤ (\n1− ǫ2 ) ǫ 2 + ǫ 2 ≤ ǫ. By theorem 2, it follows that\nmA,H\n( ǫ 2 , ǫ 2 ) ≥ min\n{\nm | 1\n2e\nµH(m)\nm ≤ ǫ\n}\n=: m̄ .\nNow, if we run the one inclusion algorithm on m̄ examples then, again by theorem 2, the probability that the hypothesis it return will err a new example is ≤ 2eǫ. Therefore, the probability that the error of the returned hypothesis is ≥ 4eǫ is ≤ 12 . In follows that\nm̄ ≥ mI,H\n(\n4eǫ, 1\n2\n)\n.\nCombining the two inequalities, we obtain that\nmI,H\n(\n4eǫ, 1\n2\n)\n≤ mA,H\n( ǫ 2 , ǫ 2 )\nSince this is true for every algorithm A, we have\nmI,H\n(\n4eǫ, 1\n2\n)\n≤ mPAC,H\n( ǫ 2 , ǫ 2 ) ≤ mPAC,H\n(\nǫ 4 , 1 2\n)\n· O (log(1/ǫ))\nHere, the last inequality follows by a standard repetition argument. Equivalently,\nmI,H\n(\nǫ, 1\n2\n)\n≤ mPAC,H\n(\nǫ 16e , 1 2\n)\n· O (log(1/ǫ))\nAgain, using a repetition argument we conclude that\nmI,H(ǫ, δ) ≤ mI,H\n(\nǫ 2 , 1 2\n)\n·O (log(1/δ)) ≤ mPAC,H\n(\nǫ 32e , 1 2\n)\n·O (log(1/δ) log(1/ǫ))\nD.5. Validity of the compression scheme given in Section 4.3\nIt is not hard to see that the hypothesis we output is the minimal-norm vector w ∈ conv(Z) (where Z is the set defined in the compression step). It is left to show that w makes no errors on the original sample. Indeed, otherwise there exists z ∈ Z for which 〈w, z〉 ≤ 0. By claim 1, z 6= 0. For α = ‖w‖ 2\n‖z‖2+‖w‖2 ∈ (0, 1), let w′ = (1 − α)w + αz. We have that\nw′ ∈ conv(Z). Moreover,\n‖w′‖2 = (1− α)2‖w‖2 + α2‖z‖2 + 2α(1 − α)〈w, z〉 ≤ (1− α)2‖w‖2 + α2‖z‖2\n= ‖z‖4‖w‖2 + ‖w‖4‖z‖2\n(‖z‖2 + ‖w‖2)2 =\n‖z‖2‖w‖2\n‖z‖2 + ‖w‖2 < ‖w‖2 .\nThis contradicts the minimality of w. It only remains to prove the following claim, which was used in the analysis.\nClaim 1 Let (x1, y1), . . . , (xm, ym) be a realizable sample and let Z be the set of all vectors of the form Ψ(xi, yi)−Ψ(xi, y) for y 6= yi. Then 0 6∈ conv(Z).\nProof Since the sample is realizable, there exists a vector w in Rd for which, ∀z ∈ Z, 〈w, z〉 > 0. Clearly, this holds also for every z ∈ conv(Z), hence 0 6∈ conv(Z).\nD.6. Proof of the second part of Theorem 5\nWithout loss of generality, we assume that Y consists of 2n + 1 elements for some natural number n (otherwise, use only 2n + 1 labels, where n is the largest number satisfying 2n + 1 ≤ |Y|). Let X be a set consisting of n elements. By renaming the names of the labels, we can assume that Y = 2X ∪ {∗}. By Lemma 21, the ERM sample complexity of HX ,Cantor is Ω ( log(|Y|)+log(1/δ) ǫ ) . We will show that there exists a function Ψ : X ×Y → R3, such that HX ,Cantor is realized by HΨ. It follows that the ERM sample complexity of HΨ is also Ω (\nlog(|Y|)+log(1/δ) ǫ\n)\n. Therefore, the second part of Theorem 5 is proved for d = 3. The\nextension of the result to general d follows from Lemma 22. Definition of Ψ: Denote k = 2|X | and let f : 2X → {0, 1, . . . , k − 1} be some one-to-one mapping. For A ⊆ X define\nφ(A) =\n(\ncos\n(\n2πf(A)\nk\n)\n, sin\n(\n2πf(A)\nk\n)\n, 0\n)\n.\nAlso, define φ(∗) = (0, 0, 1) .\nNote that for different subsets A,B ⊆ X we have that\n〈φ(A), φ(B)〉 = cos\n(\n2π(f(A)− f(B))\nk\n)\n≤ cos\n(\n2π\nk\n)\n< 1\n2 +\n1 2 cos\n(\n2π\nk\n)\n< 1 (5)\nDefine Ψ : X × Y → R3 by\n∀A ⊂ X , Ψ(x,A) =\n{\nφ(A) x ∈ A\n0 x 6∈ A\nΨ(x, ∗) =\n(\n1 2 + 1 2 cos\n(\n2π\nk\n))\n· φ(∗)\nClaim 2 HX ,Cantor is realized by HΨ.\nProof We will show that HX ,Cantor ⊆ HΨ. Let B ⊆ X . We must show that hB ∈ HΨ. Let w ∈ R3 be the vector\nw = φ(B) + φ(∗) .\nWe claim that for the function hw ∈ HΨ, defined by w we have hw = hB . Indeed, let x ∈ X we split into the cases x ∈ B and x /∈ B.\nCase 1 (x ∈ B): We must show that hw(x) = B. That is, for every y ∈ Y \\ {B},\n〈w,Ψ(x,B)〉 > 〈w,Ψ(x, y)〉 .\nNote that 〈w,Ψ(x,B)〉 = 〈φ(B) + φ(∗), φ(B)〉 = 1 .\nTherefore, for every y ∈ Y \\ {B}, we must show that 1 > 〈w,Ψ(x, y)〉. We split into three cases. If y = A for some A ⊆ X and x ∈ A then, using equation (5),\n〈w,Ψ(x, y)〉 = 〈φ(B) + φ(∗), φ(A)〉 = 〈φ(B), φ(A)〉 < 1 .\nIf y = A for some A ⊆ X and x 6∈ A then,\n〈w,Ψ(x, y)〉 = 〈φ(B) + φ(∗), 0〉 = 0 < 1 .\nIf y = ∗ then,\n〈w,Ψ(x, y)〉 =\n〈\nφ(B) + φ(∗),\n(\n1 2 + 1 2 cos\n(\n2π\nk\n))\n· φ(∗)\n〉\n= 1\n2 +\n1 2 cos\n(\n2π\nk\n)\n< 1 .\nCase 2 (x /∈ B): We must show that hw(x) = ∗. That is, for every A ∈ Y \\ {∗},\n〈w,Ψ(x, ∗)〉 > 〈w,Ψ(x,A)〉 .\nNote that\n〈w,Ψ(x, ∗)〉 =\n〈\nφ(B) + φ(∗),\n(\n1 2 + 1 2 cos\n(\n2π\nk\n))\nφ(∗)\n〉\n= 1\n2 +\n1 2 cos\n(\n2π\nk\n)\n.\nTherefore, for every A ∈ Y \\{B}, we must show that 12 + 1 2 cos\n(\n2π k\n)\n> 〈w,Ψ(x,A)〉. Indeed, if x ∈ A then A 6= B (since x /∈ B). Therefore, using equation (5),\n〈w,Ψ(x,A)〉 = 〈φ(B) + φ(∗), φ(A)〉 = 〈φ(B), φ(A)〉 < 1\n2 +\n1 2 cos\n(\n2π\nk\n)\n.\nIf x /∈ A then\n〈w,Ψ(x,A)〉 = 〈φ(B) + φ(∗), 0〉 = 0 < 1\n2 +\n1 2 cos\n(\n2π\nk\n)\n."
    }, {
      "heading" : "D.7. Proof of Theorem 6",
      "text" : "To prove the first part of Theorem 6, we will rely again on Theorem 18. We will show a compression scheme of size O(R), which is based on the multiclass perceptron. This compression scheme is not new. However, for completeness, we briefly survey it next. Recall that the multiclass perceptron is an online classification algorithm. At each step it receives an instance and tries to predict its label, based on the observed past. The two crucial properties of the preceptron that we will rely on are the following:\n• If the perceptron runs on a sequence of examples that is realizable by HΨ,R, then it makes at most O(R) mistakes.\n• The predictions made by the perceptron algorithm, are affected only by previous erroneous predictions.\nBased on these two properties, the compression scheme proceeds as follows: Given a realizable sample S = {(x1, y1), . . . , (xm, ym)}, it runs the preceptron algorithm Ω(R) times on the sequence (x1, y1), . . . , (xm, ym) (without a reset between consecutive runs). By the first property, in at least one of these runs, the preceprton will make no mistakes on the sequence (x1, y1), . . . , (xm, ym) (otherwise, there would be Ω(R) mistakes in total). The output of the compression step would be the erroneous examples previous to this sequence. By the first property, the number of such examples is O(R). The decompression will run the preceptron on these examples, and output the hypothesis h : X → Y, such that h(x) is the prediction of the perceptron on x, after operating on these examples. By the second property, h is correct on every xi.\nWe proceed to the second part. By Lemma 23 and Lemma 19, it is enough to show that a disjoint union of Ω(R) copies of HX ,Cantor, with |X | = Ω(log(|Y|)), can be realized by HΨ,R for an appropriate mapping Ψ : X × Y → B\nd for some d > 0. By Lemma 22, it is enough to show that, for some universal constant C > 0, HX ,Cantor, with |X | = Ω(log(|Y|)), can be realized by HΨ,C for an appropriate mapping Ψ : X × Y → B\nd for some d > 0. Without loss of generality, we assume that |Y| − 1 is a power of 2 (otherwise, use only k labels, where k is the largest integer such that k− 1 is a poser of 2 and k ≤ |Y|). Denote k = |Y| − 1. Fix some finite set X of cardinality log(|Y| − 1). By renaming the labels, we can assume that Y = 2X ∪ {∗}.\nLet {ey}y∈Y be a collection of unit vectors in R d with the property that for y1 6= y2,\n|〈ey1 , ey2〉| < 1\n100 . (6)\nRemark 25 Clearly, it is possible to find such a collection when d = k + 1 (simply take {ey}y∈Y to be an orthogonal basis of R\nk+1). However, equation (6) requires the collection to be just “almost orthogonal”. Such a collection can be found in Rd for d = O(log(k)) (see, e.g. Matousek (2002), chapter 13).\nDefine Ψ : X × Y → Bd by\n∀A ⊂ X , Ψ(x,A) =\n{\neA x ∈ A\n0 x 6∈ A\nΨ(x, ∗) = e∗\nThe following claim establishes the proof of Theorem 6.\nClaim 3 HX ,Cantor is realized by HΨ,8.\nProof We will show that HX ,Cantor ⊆ HΨ,8. Let B ⊆ X . We must show that hB ∈ HΨ,8. Let w = W ·(eB+ 1 2e∗) for W = 100 45 . We claim that the hypothesis in HΨ,8 that corresponds to w is hB . Indeed, let x ∈ X . We split into the cases x ∈ B and x /∈ B.\nCase 1 (x ∈ B): We must show that for every y ∈ Y \\ {B},\n〈w,Ψ(x,B)〉 ≥ 1 + 〈w,Ψ(x, y)〉 .\nNote that\n〈w,Ψ(x,B)〉 =\n〈\nW ·\n(\neB + 1\n2 e∗\n)\n, eB\n〉\n= W\n(\n1 + 1\n2 〈e∗, eB〉\n)\n≥ W\n(\n1− 1\n100\n)\n.\nNow, if y ∈ Y \\ {B} then either y ⊆ X and x 6∈ y. In this case, 〈w,Ψ(x, y)〉 = 〈w, 0〉 = 0. In the remaining cases,\n〈w,Ψ(x, y)〉 =\n〈\nW ·\n(\neB + 1\n2 e∗\n)\n, ey\n〉\n= W\n(\n〈ey , eB〉+ 1\n2 〈e∗, eB〉\n)\n≤ W 1\n50 .\nIt follows that\n〈w,Ψ(x,B)〉 − 〈w,Ψ(x, y)〉 ≥ 24\n25 W ≥ 1 .\nCase 2 (x /∈ B): We must show that for every y ∈ Y \\ {∗},\n〈w,Ψ(x, ∗)〉 ≥ 1 + 〈w,Ψ(x, y)〉 .\nNote that\n〈w,Ψ(x, ∗)〉 =\n〈\nW ·\n(\neB + 1\n2 e∗\n)\n, e∗\n〉\n= W\n(\n〈eB , e∗〉+ 1\n2\n)\n≥ W\n(\n1 2 − 1 100\n)\n.\nNow, suppose that A = y ∈ Y \\ {∗}. If x /∈ A then,\n〈w,Ψ(x, y)〉 =\n〈\nW ·\n(\neB + 1\n2 e∗\n)\n, 0\n〉\n= 0 ≤ 1\n25 W .\nIf x ∈ A then A 6= B. Therefore,\n〈w,Ψ(x, y)〉 =\n〈\nW ·\n(\neB + 1\n2 e∗\n)\n, eA\n〉\n= W\n(\n〈eB , eA〉+ 1\n2 〈e∗, eA〉\n)\n≤ 1\n25 W .\nIt follows that\n〈w,Ψ(x, ∗)〉 − 〈w,Ψ(x, y)〉 ≥ 45\n100 W ≥ 1 ."
    }, {
      "heading" : "D.8. Proof of Theorem 9",
      "text" : "The first part of the theorem follows directly from the first part of Theorem 6. We proceed to the second part. First, we note that Hd,t,2,R can be realized by Hd,t,q,R. Therefore, it is enough to restrict to the case q = 2. To simplify notations, we denote Hd,t,2,R by Hd,t,R. Also, the label space of Hd,t,R will be {0, 1}\nt instead of [2]q. By Lemma 23 and Lemma 21, it is enough to show that a disjoint union of Ω(R) copies of HY ,Cantor, with |Y| = Ω(t), can be realized by Hd,t,R for d ≥ (t+ 1)R. By Lemma 22, it is enough to show that, for some universal constant C > 0, HY ,Cantor, with |Y| = t+1, can be realized by Ht+1,t,C . Indeed:\nClaim 4 Let Ỹ = [t]. The class HY ,Cantor is realized by Ht+1,t,128.\nProof Recall that the instance space of HY ,Cantor is X = 2 [t]. Also, let e∗ := et+1 ∈ B t+1. Consider the mapping Γ : X → (Bt+1)t defined as follows. For every A ∈ X , Γ(A) is the matrix whose i’th column is 12ei + 1 4e∗ if i ∈ A and 1 4e∗ otherwise. Let Λ : {0, 1}\nt ∪ {⊖} → [t] ∪ {∗} be any mapping that maps ei ∈ {0, 1}\nt to i and 0 ∈ {0, 1}t to ∗. To establish the claim we will show that\nHY ,Cantor ⊆ Λ ◦ Ht+1,t,128 ◦ Γ .\nWe must show that for every i ∈ [t], hi ∈ Λ ◦ Ht+1,t,128 ◦ Γ and that h∗ ∈ Λ ◦ Ht+1,t,128 ◦ Γ. We start with hi. Let W ∈ M(t+1)×2 be the matrix whose left column is 0 and whose right column is 8ei − 8e∗. Let hW ∈ Ht+1,t,128 be the hypothesis corresponding to W . We claim that hi = Λ ◦ hW ◦ Γ. Indeed, let A ∈ X . We must show that Λ(hW (Γ(A))) = hi(A). By the definition of Λ and hi, it is enough to show that hW (Γ(A)) = ei if i ∈ A, while hW (Γ(A)) = 0 otherwise. Let Ψ : (B\nt+1)t × {0, 1}t → Mt+1,2 be the mapping for which Ht+1,t,128 = HΨ,128. Since the left column of W is zero, we have that 〈W,Ψ(Γ(A), 0)〉 = 0, and for 0 6= y ∈ {0, 1}t,\n〈W,Ψ(Γ(A), y)〉 = 1\n2 · |{j | yj = 1}|\n∑\nj|yj=1\n〈4ei − 4e∗, (Γ(A)) j〉\n= 1\n|{j | yj = 1}|\n∑\nj|yj=1\n(2 · 1[i = j and i ∈ A]− 1)\n= 2 · 1[i ∈ A and yi = 1]\n|{j | yj = 1}| − 1 .\nIt follows that if i ∈ A then 〈W,Ψ(Γ(A), ei)〉 = 1 while 〈W,Ψ(Γ(A), y)〉 ≤ 0 for every y 6= ei. Therefore, hW (Γ(A)) = ei. If i /∈ A then 〈W,Ψ(Γ(A), 0)〉 = 0 while 〈W,Ψ(Γ(A), y)〉 ≤ −1 for every y 6= 0. Therefore hW (Γ(A)) = 0.\nThe fact that h∗ ∈ Λ◦Ht+1,t,128◦Γ follows from a similar argument, whereW ∈ M(t+1)×2 is the matrix whose left column is 0 and whose right column is −8e∗. It is not hard to see that if hW ∈ Ht+1,t,128 is the hypothesis corresponding to W , we have h∗ = Λ ◦ hW ◦ Γ."
    }, {
      "heading" : "D.9. Proof of Theorem 8",
      "text" : "The first part of the theorem follows directly from the first part of Theorem 5. We proceed to the second part. First, by the following lemma, it is enough to restrict ourselves to the case q = 2. Given two hypothesis classes H ⊆ YX and H′ ⊆ Y ′X ′ , we say that H′ finitely realizes H if, for every finite U ⊂ X , H′ realizes H|U . It is clear that in this case Gdim (H′) ≥ Gdim (H).\nLemma 26 For every d, t and q ≥ 2, a disjoint union of ⌊ q2⌋ copies of Hd,t,2 is finitely realized by Hd+2,t,q\nProof For simplicity, assume that q is even and let r = q2 . Let X1, . . . ,Xr be finite subsets of Md,t. We should show that there is a mapping Γ : X1∪̇ . . . ∪̇Xr → Md+2,t and a mapping\nΛ : [q]t → [2]t such that\n(Hd,t,2)m |X1∪̇...∪̇Xr ⊂ (Λ ◦ Hd+2,t,q ◦ Γ) |X1∪̇...∪̇Xr (7)\nFor x ∈ Xj we define\nΓ(x) =\n(\nxT , cos\n(\nj 2π\nr\n)\n, sin\n(\nj 2π\nr\n))T\nAlso, let λ : [q] → [2] be the function that maps odd numbers to 1 and even numbers to 2. Finally, define Λ : [q]t → [2]t by Λ(y1, . . . , yt) = (λ(y1), . . . , λ(yt)). We claim that (7) holds with these Λ and Γ.\nIndeed, letW1, . . . ,Wr ∈ Md×2. We should show that the function g ∈ (Hd,t,2)m |X1∪̇...∪̇Xr defined by these function is of the form (Λ ◦ h ◦ Γ) |X1∪̇...∪̇Xr for some h ∈ Hd+2,t,q. Fix M > 0 and let h be the hypothesis defined by the matrix W ∈ Md+2,q defined as follows\nW =\n\n\nW 11 W 2 1 W 1 2 W 2 2 · · · W 1 r W 2 r\nM cos ( 2π r ) M cos ( 2π r ) M cos ( 22πr ) M cos ( 22πr ) · · · M cos ( r 2πr ) M cos ( r 2πr ) M sin (\n2π r\n) M sin ( 2π r ) M sin ( 22πr ) M sin ( 22πr ) · · · M sin ( r 2πr ) M sin ( r 2πr )\n\n\nIt is not hard to check that for large enough M , g = (Λ ◦ h ◦ Γ) |X1∪̇...∪̇Xr\nNext we prove Theorem 8 for q = 2. To simplify notation, we let Hd,t := Hd,t,2. We make one further reduction, showing that it is enough to prove the theorem for the case d = 3. Indeed, by Lemma 23 and Lemma 21, it is enough to show that a disjoint union of Ω(d) copies of HY ,Cantor, with |Y| = Ω(k), can be realized by Hd,t. By Lemma 22, it is enough to show that, for some universal constant C > 0 (we will take C = 3), HY ,Cantor, with |Y| = t+ 1, can be realized by HC,t. Indeed:\nClaim 5 Let Ỹ = [t]. The class HY ,Cantor is realized by H3,t.\nProof [(sketch)] The proof is similar to the proof of the second part of Theorem 9. Recall that the instance space ofHY ,Cantor is X = 2 [t]. For i ∈ [t] define φ(i) = ( cos ( i2π t ) , sin ( i2π t ) , 0 )\n. Also, let\nφ(∗) =\n(\n0, 0, 1\n2 +\n1 2 cos\n(\n2π\nt\n))\n.\nConsider the mapping Γ : X → (B3)t defined as follows. For every A ∈ X , Γ(A) is the matrix whose i’th column is 12φ(i) + 1 2φ(∗) if i ∈ A and 1 2φ(∗) otherwise. Let Λ : {0, 1}\nt ∪ {⊖} → [k] ∪ {∗} be any mapping that maps ei ∈ {0, 1}\nt to i and 0 ∈ {0, 1}t to ∗. To establish the claim we will show that\nHY ,Cantor ⊆ Λ ◦ H3,t ◦ Γ .\nWe must show that for every i ∈ [t], hi ∈ Λ ◦ H3,t ◦ Γ and that h∗ ∈ Λ ◦ H3,t ◦ Γ. We start with hi. Let W ∈ M3×2 be the matrix whose left column is 0 and whose right column is φ(i)− e3. It is not hard to see that if hW ∈ H3,t is the hypothesis corresponding to W , we have hi = Λ ◦ hW ◦ Γ.\nFor h∗, let W ∈ M3×2 be the matrix whose left column is 0 and whose right column is −e3. It is not hard to see that for hW ∈ H3,t, we have h∗ = Λ ◦ hW ◦ Γ."
    }, {
      "heading" : "D.10. Proof of Theorem 27",
      "text" : "Theorem 27 For every Ψ : X × Y → Rd, Ndim(HΨ) ≤ d.\nProof Let C ⊆ X be an N -shattered set, and let f0, f1 : C → Y be two functions that witness the shattering. We must show that |C| ≤ d. For every x ∈ C let ρ(x) = Ψ(x, f0(x)) − Ψ(x, f1(x)). We claim that ρ(C) = {ρ(x) | x ∈ C} consists of |C| elements (i.e. ρ is one to one) and is shattered by the binary hypothesis class of homogeneous linear separators on Rd,\nH = {x 7→ sign(〈w, x〉) | w ∈ Rd} .\nSince VCdim(H) = d, it will follow that |C| = |ρ(C)| ≤ d, as required. To establish our claim it is enough to show that |H|ρ(C)| = 2\n|C|. Indeed, given a subset B ⊆ C, by the definition of N -shattering, there exists hB ∈ HΨ for which\n∀x ∈ B,hB(x) = f0(x) and ∀x ∈ C \\B,hB(x) = f1(x) .\nIt follows that there exists a vector wB ∈ R d such that, for every x ∈ B,\n〈w,Ψ(x, f0(x))〉 > 〈w,Ψ(x, f1(x))〉 ⇒ 〈w, ρ(x)〉 > 0 .\nSimilarly, for every x ∈ C \\B, 〈w, ρ(x)〉 < 0 .\nIt follows that the hypothesis gB ∈ H defined by w ∈ R d label the points in ρ(B) by 1 and the points in ρ(C \\ B) by 0. It follows that if B1, B2 ⊆ C are two different sets then (hB1)|ρ(C) 6= (hB2)|ρ(C). Therefore |H|C | = 2 |C| as required.\nRemark 28 (Tightness of Theorem 27) Theorem 27 is tight for some functions Ψ : X × Y → Rd. For example, consider the case that X = [d], Y = {±1} and Ψ(x, y) = y · ex. It is not hard to see that HΨ = Y\nX . Therefore, Ndim(HΨ) = VCdim(HΨ) = d. On the other hand, the theorem is not tight for every Ψ. For example, if |X | < d, then for every Ψ, Ndim(HΨ) ≤ |X | < d."
    } ],
    "references" : [ {
      "title" : "The Probabilistic Method",
      "author" : [ "N. Alon", "J.H. Spencer" ],
      "venue" : "Wiley-Interscience, second edition,",
      "citeRegEx" : "Alon and Spencer.,? \\Q2000\\E",
      "shortCiteRegEx" : "Alon and Spencer.",
      "year" : 2000
    }, {
      "title" : "Characterizations of learnability for classes",
      "author" : [ "S. Ben-David", "N. Cesa-Bianchi", "D. Haussler", "P. Long" ],
      "venue" : "n}-valued functions. Journal of Computer and System Sciences,",
      "citeRegEx" : "Ben.David et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Ben.David et al\\.",
      "year" : 1995
    }, {
      "title" : "Discriminative reranking for natural language parsing",
      "author" : [ "M. Collins" ],
      "venue" : "In Machine Learning,",
      "citeRegEx" : "Collins.,? \\Q2000\\E",
      "shortCiteRegEx" : "Collins.",
      "year" : 2000
    }, {
      "title" : "Discriminative training methods for hidden Markov models: Theory and experiments with perceptron algorithms",
      "author" : [ "M. Collins" ],
      "venue" : "In Conference on Empirical Methods in Natural Language Processing,",
      "citeRegEx" : "Collins.,? \\Q2002\\E",
      "shortCiteRegEx" : "Collins.",
      "year" : 2002
    }, {
      "title" : "Parameter estimation for statistical parsing models: Theory and practice of distribution-free methods",
      "author" : [ "Michael Collins" ],
      "venue" : "In New developments in parsing technology,",
      "citeRegEx" : "Collins.,? \\Q2005\\E",
      "shortCiteRegEx" : "Collins.",
      "year" : 2005
    }, {
      "title" : "On the algorithmic implementation of multiclass kernel-based vector machines",
      "author" : [ "K. Crammer", "Y. Singer" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Crammer and Singer.,? \\Q2001\\E",
      "shortCiteRegEx" : "Crammer and Singer.",
      "year" : 2001
    }, {
      "title" : "Multiclass learnability and the erm principle",
      "author" : [ "A. Daniely", "S. Sabato", "S. Ben-David", "S. Shalev-Shwartz" ],
      "venue" : "In COLT,",
      "citeRegEx" : "Daniely et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Daniely et al\\.",
      "year" : 2011
    }, {
      "title" : "multiclass learning approaches: A theoretical comparision with implications",
      "author" : [ "A. Daniely", "S. Sabato", "S. Shalev-Shwartz" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "Daniely et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Daniely et al\\.",
      "year" : 2012
    }, {
      "title" : "Solving multiclass learning problems via error-correcting output codes",
      "author" : [ "T.G. Dietterich", "G. Bakiri" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Dietterich and Bakiri.,? \\Q1995\\E",
      "shortCiteRegEx" : "Dietterich and Bakiri.",
      "year" : 1995
    }, {
      "title" : "Predicting {0, 1}-functions on randomly drawn points",
      "author" : [ "David Haussler", "Nick Littlestone", "Manfred K. Warmuth" ],
      "venue" : "In FOCS,",
      "citeRegEx" : "Haussler et al\\.,? \\Q1988\\E",
      "shortCiteRegEx" : "Haussler et al\\.",
      "year" : 1988
    }, {
      "title" : "Phoneme alignment based on discriminative learning",
      "author" : [ "J. Keshet", "S. Shalev-Shwartz", "Y. Singer", "D. Chazan" ],
      "venue" : "In Interspeech,",
      "citeRegEx" : "Keshet et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Keshet et al\\.",
      "year" : 2005
    }, {
      "title" : "Conditional random fields: Probabilistic models for segmenting and labeling sequence data",
      "author" : [ "J. Lafferty", "A. McCallum", "F. Pereira" ],
      "venue" : "In International Conference on Machine Learning,",
      "citeRegEx" : "Lafferty et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Lafferty et al\\.",
      "year" : 2001
    }, {
      "title" : "Relating data compression and learnability",
      "author" : [ "N. Littlestone", "M. Warmuth" ],
      "venue" : "Unpublished manuscript,",
      "citeRegEx" : "Littlestone and Warmuth.,? \\Q1986\\E",
      "shortCiteRegEx" : "Littlestone and Warmuth.",
      "year" : 1986
    }, {
      "title" : "Lectures on discrete geometry, volume 212",
      "author" : [ "J. Matousek" ],
      "venue" : null,
      "citeRegEx" : "Matousek.,? \\Q2002\\E",
      "shortCiteRegEx" : "Matousek.",
      "year" : 2002
    }, {
      "title" : "On learning sets and functions",
      "author" : [ "B.K. Natarajan" ],
      "venue" : "Mach. Learn.,",
      "citeRegEx" : "Natarajan.,? \\Q1989\\E",
      "shortCiteRegEx" : "Natarajan.",
      "year" : 1989
    }, {
      "title" : "Shifting, one-inclusion mistake bounds and tight multiclass expected risk bounds",
      "author" : [ "Benjamin I Rubinstein", "Peter L Bartlett", "J Hyam Rubinstein" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Rubinstein et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Rubinstein et al\\.",
      "year" : 2006
    }, {
      "title" : "Max-margin markov networks",
      "author" : [ "B. Taskar", "C. Guestrin", "D. Koller" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "Taskar et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Taskar et al\\.",
      "year" : 2010
    }, {
      "title" : "Let H ⊂ YX be a hypothesis class with the following property: There is a label ∗ ∈ Y such that, for every f ∈ H and x ∈ X , either f(x) = ∗ or f is the only function in H whose value at x is f(x)",
      "author" : [ "Daniely" ],
      "venue" : "Multiclass Learning Lemma",
      "citeRegEx" : "Daniely,? \\Q2011\\E",
      "shortCiteRegEx" : "Daniely",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 12,
      "context" : "This brings back the fundmamental question of “how to learn”? We give a complete answer to this question by giving a new analysis of the one-inclusion multiclass learner of Rubinstein et al. (2006) showing that its sample complexity is essentially optimal.",
      "startOffset" : 173,
      "endOffset" : 198
    }, {
      "referenceID" : 2,
      "context" : "Furthermore, we show that the sample complexity of these learners is better than the sample complexity of the ERM rule, thus settling in negative an open question due to Collins (2005).",
      "startOffset" : 170,
      "endOffset" : 185
    }, {
      "referenceID" : 14,
      "context" : "Over the years, multiclass classification has been subject to intense study, both theoretical (Natarajan, 1989; Ben-David et al., 1995; Rubinstein et al., 2006; Daniely et al., 2011, 2012) and practical (e.",
      "startOffset" : 94,
      "endOffset" : 188
    }, {
      "referenceID" : 1,
      "context" : "Over the years, multiclass classification has been subject to intense study, both theoretical (Natarajan, 1989; Ben-David et al., 1995; Rubinstein et al., 2006; Daniely et al., 2011, 2012) and practical (e.",
      "startOffset" : 94,
      "endOffset" : 188
    }, {
      "referenceID" : 15,
      "context" : "Over the years, multiclass classification has been subject to intense study, both theoretical (Natarajan, 1989; Ben-David et al., 1995; Rubinstein et al., 2006; Daniely et al., 2011, 2012) and practical (e.",
      "startOffset" : 94,
      "endOffset" : 188
    }, {
      "referenceID" : 4,
      "context" : "(Shalev-Shwartz et al., 2004; Collins, 2005; Keshet et al., 2005; Torralba et al., 2007)).",
      "startOffset" : 0,
      "endOffset" : 88
    }, {
      "referenceID" : 10,
      "context" : "(Shalev-Shwartz et al., 2004; Collins, 2005; Keshet et al., 2005; Torralba et al., 2007)).",
      "startOffset" : 0,
      "endOffset" : 88
    }, {
      "referenceID" : 11,
      "context" : "Many methods have been developed to tackle this problem, starting from the the naive one-vs-all method, to more complex methods, such as structured output prediction (Collins, 2000, 2002; Lafferty et al., 2001; Taskar et al., 2003; Tsochantaridis et al., 2004), error correcting output codes (Dietterich and Bakiri, 1995) and others.",
      "startOffset" : 166,
      "endOffset" : 260
    }, {
      "referenceID" : 8,
      "context" : ", 2004), error correcting output codes (Dietterich and Bakiri, 1995) and others.",
      "startOffset" : 39,
      "endOffset" : 68
    }, {
      "referenceID" : 1,
      "context" : "Over the years, multiclass classification has been subject to intense study, both theoretical (Natarajan, 1989; Ben-David et al., 1995; Rubinstein et al., 2006; Daniely et al., 2011, 2012) and practical (e.g. (Shalev-Shwartz et al., 2004; Collins, 2005; Keshet et al., 2005; Torralba et al., 2007)). Many methods have been developed to tackle this problem, starting from the the naive one-vs-all method, to more complex methods, such as structured output prediction (Collins, 2000, 2002; Lafferty et al., 2001; Taskar et al., 2003; Tsochantaridis et al., 2004), error correcting output codes (Dietterich and Bakiri, 1995) and others. These developments made it possible to handle a variety of multiclass classification problems, including even problems that have a very complex label space, that is structured and exponentially large (e.g. speech recognition, OCR, and multiple object categorization). Despite being very basic and natural, and despite these developments and efforts, our theoretical understanding of multiclass classification is still far from being satisfactory, in particular relatively to our understanding of binary classification (i.e., when |Y| = 2). In this work, we focus on the sample complexity of (distribution free) learning of hypothesis classes H ⊆ YX . The two most fundamental questions are: 1. What is learnable? More quantitatively, what is the sample complexity of a given class H? 2. How to learn? In particular, is there a generic algorithm with optimal sample complexity? For binary classification problems, these two questions are essentially solved (up to logfactors of the error and confidence parameters ǫ and δ): The fundamental result of Vapnik and Chervonenkis (1971) asserts that the VC dimension characterizes the sample complexity, and that any Empirical Risk Minimization (ERM) algorithm enjoys close-to-optimal sample complexity.",
      "startOffset" : 112,
      "endOffset" : 1714
    }, {
      "referenceID" : 1,
      "context" : "Over the years, multiclass classification has been subject to intense study, both theoretical (Natarajan, 1989; Ben-David et al., 1995; Rubinstein et al., 2006; Daniely et al., 2011, 2012) and practical (e.g. (Shalev-Shwartz et al., 2004; Collins, 2005; Keshet et al., 2005; Torralba et al., 2007)). Many methods have been developed to tackle this problem, starting from the the naive one-vs-all method, to more complex methods, such as structured output prediction (Collins, 2000, 2002; Lafferty et al., 2001; Taskar et al., 2003; Tsochantaridis et al., 2004), error correcting output codes (Dietterich and Bakiri, 1995) and others. These developments made it possible to handle a variety of multiclass classification problems, including even problems that have a very complex label space, that is structured and exponentially large (e.g. speech recognition, OCR, and multiple object categorization). Despite being very basic and natural, and despite these developments and efforts, our theoretical understanding of multiclass classification is still far from being satisfactory, in particular relatively to our understanding of binary classification (i.e., when |Y| = 2). In this work, we focus on the sample complexity of (distribution free) learning of hypothesis classes H ⊆ YX . The two most fundamental questions are: 1. What is learnable? More quantitatively, what is the sample complexity of a given class H? 2. How to learn? In particular, is there a generic algorithm with optimal sample complexity? For binary classification problems, these two questions are essentially solved (up to logfactors of the error and confidence parameters ǫ and δ): The fundamental result of Vapnik and Chervonenkis (1971) asserts that the VC dimension characterizes the sample complexity, and that any Empirical Risk Minimization (ERM) algorithm enjoys close-to-optimal sample complexity. In a recent surprising result, Daniely et al. (2011) have shown that in multiclass classification there might be substantial gaps between the sample complexity of different ERMs.",
      "startOffset" : 112,
      "endOffset" : 1934
    }, {
      "referenceID" : 1,
      "context" : "Over the years, multiclass classification has been subject to intense study, both theoretical (Natarajan, 1989; Ben-David et al., 1995; Rubinstein et al., 2006; Daniely et al., 2011, 2012) and practical (e.g. (Shalev-Shwartz et al., 2004; Collins, 2005; Keshet et al., 2005; Torralba et al., 2007)). Many methods have been developed to tackle this problem, starting from the the naive one-vs-all method, to more complex methods, such as structured output prediction (Collins, 2000, 2002; Lafferty et al., 2001; Taskar et al., 2003; Tsochantaridis et al., 2004), error correcting output codes (Dietterich and Bakiri, 1995) and others. These developments made it possible to handle a variety of multiclass classification problems, including even problems that have a very complex label space, that is structured and exponentially large (e.g. speech recognition, OCR, and multiple object categorization). Despite being very basic and natural, and despite these developments and efforts, our theoretical understanding of multiclass classification is still far from being satisfactory, in particular relatively to our understanding of binary classification (i.e., when |Y| = 2). In this work, we focus on the sample complexity of (distribution free) learning of hypothesis classes H ⊆ YX . The two most fundamental questions are: 1. What is learnable? More quantitatively, what is the sample complexity of a given class H? 2. How to learn? In particular, is there a generic algorithm with optimal sample complexity? For binary classification problems, these two questions are essentially solved (up to logfactors of the error and confidence parameters ǫ and δ): The fundamental result of Vapnik and Chervonenkis (1971) asserts that the VC dimension characterizes the sample complexity, and that any Empirical Risk Minimization (ERM) algorithm enjoys close-to-optimal sample complexity. In a recent surprising result, Daniely et al. (2011) have shown that in multiclass classification there might be substantial gaps between the sample complexity of different ERMs. We start by showing an even stronger “peculiarity”, discriminating binary from multiclass classification. Recall that an algorithm is called improper if it might return a hypothesis that does not belong to the learnt class. Traditionally, improper learning has been applied to enable efficient computations. It seems counter intuitive that computationally unbounded learner would benefit from returning a hypothesis outside of the learnt class. Surprisingly, we show that an optimal learning algorithm must be improper! Namely, we show that there are classes that are learnable only by an improper algorithm. Pointing out that we actually do not understand how to learn optimally, these results “reopen” the above two basic questions for multiclass classification. In this paper we essentially resolve these two questions. We give a new analysis of the multiclass one inclusion algorithm (Rubinstein et al. (2006) based on Haussler et al.",
      "startOffset" : 112,
      "endOffset" : 2974
    }, {
      "referenceID" : 1,
      "context" : "Over the years, multiclass classification has been subject to intense study, both theoretical (Natarajan, 1989; Ben-David et al., 1995; Rubinstein et al., 2006; Daniely et al., 2011, 2012) and practical (e.g. (Shalev-Shwartz et al., 2004; Collins, 2005; Keshet et al., 2005; Torralba et al., 2007)). Many methods have been developed to tackle this problem, starting from the the naive one-vs-all method, to more complex methods, such as structured output prediction (Collins, 2000, 2002; Lafferty et al., 2001; Taskar et al., 2003; Tsochantaridis et al., 2004), error correcting output codes (Dietterich and Bakiri, 1995) and others. These developments made it possible to handle a variety of multiclass classification problems, including even problems that have a very complex label space, that is structured and exponentially large (e.g. speech recognition, OCR, and multiple object categorization). Despite being very basic and natural, and despite these developments and efforts, our theoretical understanding of multiclass classification is still far from being satisfactory, in particular relatively to our understanding of binary classification (i.e., when |Y| = 2). In this work, we focus on the sample complexity of (distribution free) learning of hypothesis classes H ⊆ YX . The two most fundamental questions are: 1. What is learnable? More quantitatively, what is the sample complexity of a given class H? 2. How to learn? In particular, is there a generic algorithm with optimal sample complexity? For binary classification problems, these two questions are essentially solved (up to logfactors of the error and confidence parameters ǫ and δ): The fundamental result of Vapnik and Chervonenkis (1971) asserts that the VC dimension characterizes the sample complexity, and that any Empirical Risk Minimization (ERM) algorithm enjoys close-to-optimal sample complexity. In a recent surprising result, Daniely et al. (2011) have shown that in multiclass classification there might be substantial gaps between the sample complexity of different ERMs. We start by showing an even stronger “peculiarity”, discriminating binary from multiclass classification. Recall that an algorithm is called improper if it might return a hypothesis that does not belong to the learnt class. Traditionally, improper learning has been applied to enable efficient computations. It seems counter intuitive that computationally unbounded learner would benefit from returning a hypothesis outside of the learnt class. Surprisingly, we show that an optimal learning algorithm must be improper! Namely, we show that there are classes that are learnable only by an improper algorithm. Pointing out that we actually do not understand how to learn optimally, these results “reopen” the above two basic questions for multiclass classification. In this paper we essentially resolve these two questions. We give a new analysis of the multiclass one inclusion algorithm (Rubinstein et al. (2006) based on Haussler et al. (1988), see also Simon and Szörényi (2010)), showing that it is optimal up to a constant factor of 2 in a transductive setting.",
      "startOffset" : 112,
      "endOffset" : 3006
    }, {
      "referenceID" : 1,
      "context" : "Over the years, multiclass classification has been subject to intense study, both theoretical (Natarajan, 1989; Ben-David et al., 1995; Rubinstein et al., 2006; Daniely et al., 2011, 2012) and practical (e.g. (Shalev-Shwartz et al., 2004; Collins, 2005; Keshet et al., 2005; Torralba et al., 2007)). Many methods have been developed to tackle this problem, starting from the the naive one-vs-all method, to more complex methods, such as structured output prediction (Collins, 2000, 2002; Lafferty et al., 2001; Taskar et al., 2003; Tsochantaridis et al., 2004), error correcting output codes (Dietterich and Bakiri, 1995) and others. These developments made it possible to handle a variety of multiclass classification problems, including even problems that have a very complex label space, that is structured and exponentially large (e.g. speech recognition, OCR, and multiple object categorization). Despite being very basic and natural, and despite these developments and efforts, our theoretical understanding of multiclass classification is still far from being satisfactory, in particular relatively to our understanding of binary classification (i.e., when |Y| = 2). In this work, we focus on the sample complexity of (distribution free) learning of hypothesis classes H ⊆ YX . The two most fundamental questions are: 1. What is learnable? More quantitatively, what is the sample complexity of a given class H? 2. How to learn? In particular, is there a generic algorithm with optimal sample complexity? For binary classification problems, these two questions are essentially solved (up to logfactors of the error and confidence parameters ǫ and δ): The fundamental result of Vapnik and Chervonenkis (1971) asserts that the VC dimension characterizes the sample complexity, and that any Empirical Risk Minimization (ERM) algorithm enjoys close-to-optimal sample complexity. In a recent surprising result, Daniely et al. (2011) have shown that in multiclass classification there might be substantial gaps between the sample complexity of different ERMs. We start by showing an even stronger “peculiarity”, discriminating binary from multiclass classification. Recall that an algorithm is called improper if it might return a hypothesis that does not belong to the learnt class. Traditionally, improper learning has been applied to enable efficient computations. It seems counter intuitive that computationally unbounded learner would benefit from returning a hypothesis outside of the learnt class. Surprisingly, we show that an optimal learning algorithm must be improper! Namely, we show that there are classes that are learnable only by an improper algorithm. Pointing out that we actually do not understand how to learn optimally, these results “reopen” the above two basic questions for multiclass classification. In this paper we essentially resolve these two questions. We give a new analysis of the multiclass one inclusion algorithm (Rubinstein et al. (2006) based on Haussler et al. (1988), see also Simon and Szörényi (2010)), showing that it is optimal up to a constant factor of 2 in a transductive setting.",
      "startOffset" : 112,
      "endOffset" : 3042
    }, {
      "referenceID" : 5,
      "context" : "We consider classes of multiclass linear classifiers that are learnt by several popular learning paradigms, including multiclass SVM with kernels (Crammer and Singer, 2001), structured output prediction (Collins, 2000, 2002; Lafferty et al.",
      "startOffset" : 146,
      "endOffset" : 172
    }, {
      "referenceID" : 11,
      "context" : "We consider classes of multiclass linear classifiers that are learnt by several popular learning paradigms, including multiclass SVM with kernels (Crammer and Singer, 2001), structured output prediction (Collins, 2000, 2002; Lafferty et al., 2001; Taskar et al., 2003; Tsochantaridis et al., 2004), and others.",
      "startOffset" : 203,
      "endOffset" : 297
    }, {
      "referenceID" : 2,
      "context" : "Departing general theory, we turn our focus to investigate hypothesis classes that are used in practice, in light of the above results and the result of Daniely et al. (2011). We consider classes of multiclass linear classifiers that are learnt by several popular learning paradigms, including multiclass SVM with kernels (Crammer and Singer, 2001), structured output prediction (Collins, 2000, 2002; Lafferty et al.",
      "startOffset" : 153,
      "endOffset" : 175
    }, {
      "referenceID" : 2,
      "context" : "We consider classes of multiclass linear classifiers that are learnt by several popular learning paradigms, including multiclass SVM with kernels (Crammer and Singer, 2001), structured output prediction (Collins, 2000, 2002; Lafferty et al., 2001; Taskar et al., 2003; Tsochantaridis et al., 2004), and others. Arguably, the two most natural questions in this context are: (i) is the ERM rule still sub-optimal even for such classes? and (ii) If yes, are there efficient optimal learnears for these classes? Regarding the first question, we show that even though the sample complexity of these classes is upper bounded in terms of the dimension or the margin, there are sub-optimal ERMs whose sample complexity has additional multiplicative factor that depends on the number of labels. This settles in negative an open question due to Collins (2005). Regarding the second question above, as opposed to the one-inclusion algorithm, which is in general inefficient, for linear classes we derive computationally efficient learners (provided that the hypotheses can be evaluated efficiently), that enjoy optimal sample complexity.",
      "startOffset" : 204,
      "endOffset" : 850
    }, {
      "referenceID" : 6,
      "context" : "This class is due to Daniely et al. (2011) and we call it the first Cantor class due to the resemblance to the construction used for proving the famous theorem of Cantor from set theory (e.",
      "startOffset" : 21,
      "endOffset" : 43
    }, {
      "referenceID" : 6,
      "context" : "This class is due to Daniely et al. (2011) and we call it the first Cantor class due to the resemblance to the construction used for proving the famous theorem of Cantor from set theory (e.g., http://en.wikipedia.org/wiki/Cantor’s_theorem). Daniely et al. (2011) employed this class to establish gaps between the sample complexity of different ERM learners.",
      "startOffset" : 21,
      "endOffset" : 263
    }, {
      "referenceID" : 6,
      "context" : "Since Hd ⊂ HXd,Cantor, we can apply the “good” ERM learner described in Daniely et al. (2011) with respect to the class HXd,Cantor and obtain an algorithm for Hd whose sample complexity is ≤ ln(1/δ) ǫ .",
      "startOffset" : 72,
      "endOffset" : 94
    }, {
      "referenceID" : 15,
      "context" : "The one-inclusion algorithm We next describe the one-inclusion transductive learning algorithm of Rubinstein et al. (2006). Let S = {x1, .",
      "startOffset" : 98,
      "endOffset" : 123
    }, {
      "referenceID" : 9,
      "context" : "While the above proof of the upper bound is close in spirit to the arguments used by Haussler et al. (1988) and Rubinstein et al.",
      "startOffset" : 85,
      "endOffset" : 108
    }, {
      "referenceID" : 9,
      "context" : "While the above proof of the upper bound is close in spirit to the arguments used by Haussler et al. (1988) and Rubinstein et al. (2006), the proof of the lower bound relies on a new argument.",
      "startOffset" : 85,
      "endOffset" : 137
    }, {
      "referenceID" : 9,
      "context" : "While the above proof of the upper bound is close in spirit to the arguments used by Haussler et al. (1988) and Rubinstein et al. (2006), the proof of the lower bound relies on a new argument. As opposed to Rubinstein et al. (2006) who lower bounded ǫH(m) using the Natarajan dimension, we give a direct analysis.",
      "startOffset" : 85,
      "endOffset" : 232
    }, {
      "referenceID" : 2,
      "context" : "This family is widely used in practice and received a lot of attention in the literature—see for example Crammer and Singer (2001); Collins (2000, 2002); Lafferty et al.",
      "startOffset" : 105,
      "endOffset" : 131
    }, {
      "referenceID" : 2,
      "context" : "This family is widely used in practice and received a lot of attention in the literature—see for example Crammer and Singer (2001); Collins (2000, 2002); Lafferty et al. (2001); Taskar et al.",
      "startOffset" : 132,
      "endOffset" : 177
    }, {
      "referenceID" : 2,
      "context" : "This family is widely used in practice and received a lot of attention in the literature—see for example Crammer and Singer (2001); Collins (2000, 2002); Lafferty et al. (2001); Taskar et al. (2003); Tsochantaridis et al.",
      "startOffset" : 132,
      "endOffset" : 199
    }, {
      "referenceID" : 2,
      "context" : "This family is widely used in practice and received a lot of attention in the literature—see for example Crammer and Singer (2001); Collins (2000, 2002); Lafferty et al. (2001); Taskar et al. (2003); Tsochantaridis et al. (2004). We show that, rather surprisingly, even for such simple classes, there can be gaps between the ERM sample complexity and the PAC sample complexity.",
      "startOffset" : 132,
      "endOffset" : 229
    }, {
      "referenceID" : 2,
      "context" : "This family is widely used in practice and received a lot of attention in the literature—see for example Crammer and Singer (2001); Collins (2000, 2002); Lafferty et al. (2001); Taskar et al. (2003); Tsochantaridis et al. (2004). We show that, rather surprisingly, even for such simple classes, there can be gaps between the ERM sample complexity and the PAC sample complexity. This settles in negative an open question raised by Collins (2005). We also derive computationally efficient optimal learners for linear classes, based on the concept of compression schemes.",
      "startOffset" : 132,
      "endOffset" : 445
    }, {
      "referenceID" : 13,
      "context" : "Taskar et al. (2003)).",
      "startOffset" : 0,
      "endOffset" : 21
    }, {
      "referenceID" : 13,
      "context" : "Taskar et al. (2003)). For example, in speech recognition, the label space might me the collection of all sequences of ≤ 20 English words. To motivate the definition, consider the case that we are to recognize a t-letter word appearing in an image. Let q be the size of the alphabet. The set of possible labels is naturally associated with [q]t. A popular method to tackle this task (see for example Taskar et al. (2003)) is the following: The image is broken into t parts, each of which contains a single letter.",
      "startOffset" : 0,
      "endOffset" : 421
    }, {
      "referenceID" : 2,
      "context" : "Even though the number of labels is exponential in t, this class (in the realizable case) can be learnt in time polynomial in d, t and q (see Collins (2005)).",
      "startOffset" : 142,
      "endOffset" : 157
    }, {
      "referenceID" : 6,
      "context" : "Daniely et al. (2011)) that the sample complexity of every ERM for this class is O (",
      "startOffset" : 0,
      "endOffset" : 22
    }, {
      "referenceID" : 2,
      "context" : "Collins (2005)) that the sample complexity of every ERM for this class is O (",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 4,
      "context" : "However, it was not known whether the gap is real: In (Collins, 2005), it was left as an open question to show whether the perceptron’s bound holds for every ERM.",
      "startOffset" : 54,
      "endOffset" : 69
    }, {
      "referenceID" : 6,
      "context" : "This strengthens the result of (Daniely et al., 2011) who showed that it is bounded by O(d log(d)).",
      "startOffset" : 31,
      "endOffset" : 53
    }, {
      "referenceID" : 6,
      "context" : "This strengthens the result of (Daniely et al., 2011) who showed that it is bounded by O(d log(d)). It is known (e.g. Daniely et al. (2012)) that for the multivector construction (example 1), in which the dimension of the range of Ψ is dk, the 1.",
      "startOffset" : 32,
      "endOffset" : 140
    }, {
      "referenceID" : 6,
      "context" : "These theorems show that the phenomenon of gaps between different ERMs, as reported in (Daniely et al., 2011), happens also in hypothesis classes that are used in practice.",
      "startOffset" : 87,
      "endOffset" : 109
    }, {
      "referenceID" : 2,
      "context" : "For the case of margin-based classes, this result is not new — an efficient algorithm based on the multiclass perceptron has been proposed in Collins (2002). For completeness, we briefly survey this approach in the appendix.",
      "startOffset" : 142,
      "endOffset" : 157
    }, {
      "referenceID" : 9,
      "context" : "Moreover, a beautiful result of Haussler et al. (1988) shows that • If |Y| = 2, then VCdim(H) ≤ μH(m) ≤ 2VCdim(H) for every m ≥ VCdim(H).",
      "startOffset" : 32,
      "endOffset" : 55
    }, {
      "referenceID" : 6,
      "context" : "First, it is known (Daniely et al., 2011) that the graph dimension does not characterize the sample complexity, since it can be substantially larger than the sample complexity in several cases.",
      "startOffset" : 19,
      "endOffset" : 41
    }, {
      "referenceID" : 12,
      "context" : "By combination of theorems 2 and Rubinstein et al. (2006), a weaker version of conjecture 11 is true.",
      "startOffset" : 33,
      "endOffset" : 58
    }, {
      "referenceID" : 6,
      "context" : "Theorem 15 (Daniely et al. (2011)) For every hypothesis class H with graph dimension d, Ω ( d+ log(1/δ) ǫ )",
      "startOffset" : 12,
      "endOffset" : 34
    }, {
      "referenceID" : 14,
      "context" : "Definition 16 (Natarajan dimension) Let H ⊆ (Y ∪ {⊖}) be a hypothesis class. We say that A ⊆ X is N -shattered if there exist h1, h2 : A → Y such that ∀x ∈ A, h1(x) 6= h2(x) and for every B ⊆ A there is h ∈ H for which ∀x ∈ B, h(x) = h1(x) while ∀x ∈ A \\B, h(x) = h2(x) . The Natarajan dimension of H, denoted Ndim(H), is the maximal cardinality of an N shattered set. Theorem 17 (essentially Natarajan (1989)) For every hypothesis class H ⊂ (Y ∪ {⊖}) with Natarajan dimension d, Ω ( d+ log(1/δ) ǫ )",
      "startOffset" : 15,
      "endOffset" : 410
    }, {
      "referenceID" : 6,
      "context" : "(3) We also note that (Daniely et al., 2011) conjectured that the logarithmic factor of |Y| in Theorem 17 can be eliminated (maybe with the expense of poly-logarithmic factors of 1ǫ , 1 δ and Ndim(H)).",
      "startOffset" : 22,
      "endOffset" : 44
    }, {
      "referenceID" : 1,
      "context" : "We note that the upper bound in the last theorem follows from theorem 15 and the fact that (see Ben-David et al. (1995)) for every hypothesis class H, Gdim(H) ≤ 5 log(|Y|)Ndim(H) .",
      "startOffset" : 96,
      "endOffset" : 120
    }, {
      "referenceID" : 12,
      "context" : "Precisely, we have: Theorem 18 (Littlestone and Warmuth (1986)) Suppose that there exists a compression scheme of size d for a class H.",
      "startOffset" : 32,
      "endOffset" : 63
    }, {
      "referenceID" : 6,
      "context" : "Lemma 19 (Daniely et al. (2011)) • The graph dimension of HX ,Cantor is |X |.",
      "startOffset" : 10,
      "endOffset" : 32
    }, {
      "referenceID" : 6,
      "context" : "Lemma 20 (essentially Daniely et al. (2011)) Let H ⊂ YX be a hypothesis class with the following property: There is a label ∗ ∈ Y such that, for every f ∈ H and x ∈ X , either f(x) = ∗ or f is the only function in H whose value at x is f(x).",
      "startOffset" : 22,
      "endOffset" : 44
    }, {
      "referenceID" : 0,
      "context" : "Alon and Spencer (2000)).",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 13,
      "context" : "Matousek (2002), chapter 13).",
      "startOffset" : 0,
      "endOffset" : 16
    } ],
    "year" : 2014,
    "abstractText" : "The fundamental theorem of statistical learning states that for binary classification problems, any Empirical Risk Minimization (ERM) learning rule has close to optimal sample complexity. In this paper we seek for a generic optimal learner for multiclass prediction. We start by proving a surprising result: a generic optimal multiclass learner must be improper, namely, it must have the ability to output hypotheses which do not belong to the hypothesis class, even though it knows that all the labels are generated by some hypothesis from the class. In particular, no ERM learner is optimal. This brings back the fundmamental question of “how to learn”? We give a complete answer to this question by giving a new analysis of the one-inclusion multiclass learner of Rubinstein et al. (2006) showing that its sample complexity is essentially optimal. Then, we turn to study the popular hypothesis class of generalized linear classifiers. We derive optimal learners that, unlike the one-inclusion algorithm, are computationally efficient. Furthermore, we show that the sample complexity of these learners is better than the sample complexity of the ERM rule, thus settling in negative an open question due to Collins (2005).",
    "creator" : "LaTeX with hyperref package"
  }
}