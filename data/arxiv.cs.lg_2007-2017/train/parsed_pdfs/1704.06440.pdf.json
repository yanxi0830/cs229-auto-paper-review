{
  "name" : "1704.06440.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Equivalence Between Policy Gradients and Soft Q-Learning",
    "authors" : [ "John Schulman", "Xi Chen", "Pieter Abbeel" ],
    "emails" : [ "pieter}@openai.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Experimentally, we explore the entropy-regularized versions of Q-learning and policy gradients, and we find them to perform as well as (or slightly better than) the standard variants on the Atari benchmark. We also show that the equivalence holds in practical settings by constructing a Q-learning method that closely matches the learning dynamics of A3C without using a target network or -greedy exploration schedule."
    }, {
      "heading" : "1 Introduction",
      "text" : "Policy gradient methods (PG) and Q-learning (QL) methods perform updates that are qualitatively similar. In both cases, if the return following an action at is high, then that action is reinforced: in policy gradient methods, the probability π(at | st) is increased; whereas in Q-learning methods, the Q-value Q(st, at) is increased. The connection becomes closer when we add entropy regularization to these algorithms. With an entropy cost added to the returns, the optimal policy has the form π(a | s) ∝ exp(Q(s, a)); hence policy gradient methods solve for the optimal Q-function, up to an additive constant (Ziebart [2010]). O’Donoghue et al. [2016] also discuss the connection between the fixed points and updates of PG and QL methods, though the discussion of fixed points is restricted to the tabular setting, and the discussion comparing updates is informal and shows an approximate equivalence. Going beyond past work, this paper shows that under appropriate conditions, the gradient of the loss function used in n-step Q-learning is equal to the gradient of the loss used in an n-step policy gradient method, including a squared-error term on the value function. Altogether, the update matches what is typically done in “actor-critic” policy gradient methods such as A3C, which explains why Mnih et al. [2016] obtained qualitatively similar results from policy gradients and n-step Q-learning.\nSection 2 uses the bandit setting to provide the reader with a simplified version of our main calculation. (The main calculation applies to the MDP setting.) Section 3 discusses the entropy-regularized formulation of RL, which is not original to this work, but is included for the reader’s convenience. Section 4 shows that the soft Q-learning loss gradient can be interpreted as a policy gradient term plus a baseline-error-gradient term, corresponding to policy gradient instantiations such as A3C [Mnih et al., 2016]. Section 5 draws a connection between QL methods that use batch updates or replay-buffers, and natural policy gradient methods.\nSome previous work on entropy regularized reinforcement learning (e.g., O’Donoghue et al. [2016], Nachum et al. [2017]) uses entropy bonuses, whereas we use a penalty on Kullback-Leibler (KL) divergence, which is a bit more general. However, in the text, we often refer to “entropy” terms; this refers to “relative entropy”, i.e., the KL divergence."
    }, {
      "heading" : "2 Bandit Setting",
      "text" : "Let’s consider a bandit problem with a discrete or continuous action space: at each timestep the agent chooses an action a, and the reward r is sampled according to P (r |a), where P is unknown to the agent. Let\nar X\niv :1\n70 4.\n06 44\n0v 1\n[ cs\n.L G\n] 2\n1 A\npr 2\n01 7\nr̄(a) = E [r | a], and let π denote a policy, where π(a) is the probability of action a. Then, the expected pertimestep reward of the policy π is Ea∼π [r] = ∑ a π(a)r̄(a) or ∫ da π(a)r̄(a). Let’s suppose we are maximizing η(π), an entropy-regularized version of this objective:\nη(π) = Ea∼π,r [r]− τDKL [π ‖ π] (1)\nwhere π is some “reference” policy, τ is a “temperature” parameter, and DKL is the Kullback-Leibler divergence. Note that the temperature τ can be eliminated by rescaling the rewards. However, we will leave it so that our calculations are checkable through dimensional analysis, and to make the temperaturedependence more explicit.\nFirst, let us calculate the policy π that maximizes η. We claim that η(π) is maximized by πBr̄ , defined as\nπBr̄ (a) = π(a) exp(r̄(a)/τ)/Ea′∼π [exp(r̄(a′)/τ)]︸ ︷︷ ︸ normalizing constant . (2)\nTo derive this, consider the KL divergence between π and πBr̄ :\nDKL [ π ∥∥ πBr̄ ] = Ea∼π [log π(a)− log πBr̄ (a)] (3)\n= Ea∼π [log π(a)− log π(a)− r̄(a)/τ + logEa∼π [exp(r̄(a)/τ)]] (4) = DKL [π ‖ π]− Ea∼π [r̄(a)/τ ] + logEa∼π [exp(r̄(a)/τ)] (5)\nRearranging and multiplying by τ , Ea∼π [r̄(a)]− τDKL [π ‖ π] = τ logEa∼π [exp(r̄(a)/τ)]− τDKL [ π ∥∥ πBr̄ ] (6)\nClearly the left-hand side is maximized (with respect to π) when the KL term on the right-hand side is minimized (as the other term does not depend on π), and DKL [ π ∥∥ πBr̄ ] is minimized at π = πBr̄ .\nThe preceding calculation gives us the optimal policy when r̄ is known, but in the entropy-regularized bandit problem, it is initially unknown, and the agent learns about it by sampling. There are two approaches for solving the entropy-regularized bandit problem:\n1. A direct, policy-based approach, where we incrementally update the agent’s policy π based on stochastic gradient ascent on η.\n2. An indirect, value-based approach, where we learn an action-value function qθ that estimates and approximates r̄, and we define π based on our current estimate of qθ.\nFor the policy-based approach, we can obtain unbiased estimates the gradient of η. For a parameterized policy πθ, the gradient is given by\n∇θη(πθ) = Ea∼πθ,r [∇θ log πθ(a)r − τ∇θDKL [πθ ‖ π]] . (7)\nWe can obtain an unbiased gradient estimate using a single sample (a, r). In the indirect, value-based approach approach, it is natural to use a squared-error loss:\nLπ(θ) := 1 2Ea∼π,r [ (qθ(a)− r)2 ] (8)\nTaking the gradient of this loss, with respect to the parameters of qθ, we get\n∇θLπ(θ) = Ea∼π,r [∇θqθ(a)(qθ(a)− r)] (9)\nSoon, we will calculate the relationship between this loss gradient and the policy gradient from Equation (7). In the indirect, value-based approach, a natural choice for policy π is the one that would be optimal if qθ = r̄. Let’s denote this policy, called the Boltzmann policy, by π B qθ , where\nπBqθ (a) = π(a) exp(qθ(a)/τ)/Ea′∼π [exp(qθ(a ′)/τ)] . (10)\nIt will be convenient to introduce a bit of notation for the normalizing factor; namely, we define the scalar\nvθ = τ logEa∼π [exp(qθ(a))/τ ] (11)\nThen the Boltzmann policy can be written as\nπBqθ (a) = π(a) exp((qθ(a)− vθ)/τ). (12)\nNote that the term τ logEa∼π [exp(r̄(a)/τ)], appeared earlier in Equation (6)). Repeating the calculation from Equation (2) through Equation (6), but with qθ instead of r̄,\nvθ = Ea∼πBqθ [qθ(a)]− τDKL [ πBqθ ∥∥ π] . (13) Hence, vθ is an estimate of η(π B qθ\n), plugging in qθ for r̄. Now we shall show the connection between the gradient of the squared-error loss (Equation (9)) and the policy gradient (Equation (7)). Rearranging Equation (12), we can write qθ in terms of vθ and the Boltzmann policy πBqθ :\nqθ(a) = vθ + τ log\n( πBqθ (a)\nπ(a)\n) (14)\nLet’s substitute this expression for qθ into the squared-error loss gradient (Equation (9)).\n∇θLπ(qθ) = Ea∼π,r [∇θqθ(a)(qθ(a)− r)] (15) = Ea∼π,r [ ∇θ ( vθ + τ log ( πBqθ (a)\nπ(a)\n))( vθ + τ log ( πBqθ (a)\nπ(a)\n) − r )]\n(16) = Ea∼π,r [ τ∇θ log πBqθ (a) ( vθ + τ log ( πBqθ (a) π(a) ) − r ) +∇θvθ ( vθ + τ log ( πBqθ (a) π(a) ) − r )] (17)\nNote that we have not yet decided on a sampling distribution π. Henceforth, we’ll assume actions were sampled by π = πBqθ . Also, note the derivative of the KL-divergence:\n∇θDKL [ πBqθ ∥∥ π] = ∇θ ∫ da πBqθ (a) log(πBqθ (a)π(a) ) (18) = ∫ da ∇θπBqθ (a) ( log ( πBqθ (a) π(a) ) + πBqθ (a)\n1 πBqθ (a)\n) (19)\n= ∫ da πBqθ (a)∇θ log πBqθ (a) log ( πBqθ (a) π(a) ) (20)\n= Ea∼πBqθ [ ∇θ log πBqθ (a) log ( πBqθ (a) π(a) )] (21)\nContinuing from Equation (17) but setting π = πBqθ ,\n∇θLπBqθ (qθ) = Ea∼πBqθ ,r [ τ∇θ log πBqθ (a)(vθ − r) + τ2∇θDKL [ πBqθ ∥∥ π]] +∇θEa∼πBqθ ,r [ vθ ( vθ + τDKL [ πBqθ\n∥∥ π]− r)] (22) = −τ ∇θEa∼πBqθ ,r [ r − τDKL [ πBqθ\n∥∥ π]]︸ ︷︷ ︸ policy gradient +∇θEa∼πBqθ ,r [ 1 2 (vθ − (r − τDKL [ πBqθ ∥∥ π]))2]︸ ︷︷ ︸ value error gradient (23)\nHence, the gradient of the squared error for our action-value function can be broken into two parts: the first part is the policy gradient of the Boltzmann policy corresponding to qθ, the second part arises from a squared error objective, where we are fitting vθ to the entropy-augmented expected reward r̄(a)− τDKL [ πBqθ ∥∥ π]. Soon we will derive an equivalent interpretation of Q-function regression in the MDP setting, where we are approximating the state-value function Qπ,γ . However, we first need to introduce an entropy-regularized version of the reinforcement learning problem."
    }, {
      "heading" : "3 Entropy-Regularized Reinforcement Learning",
      "text" : "We shall consider an entropy-regularized version of the reinforcement learning problem, following various prior work (Ziebart [2010], Fox et al. [2015], Haarnoja et al. [2017], Nachum et al. [2017]). Specifically, let us define the entropy-augmented return to be ∑∞ t=0 γ\nt(rt − τ KLt) where rt is the reward, γ ∈ [0, 1] is the discount factor, τ is a scalar temperature coefficient, and KLt is the Kullback-Leibler divergence between the current policy π and a reference policy π at timestep t: KLt = DKL [π(· | st) ‖ π(· | st)]. We will sometimes use the notation KL(s) = DKL [π ‖ π] (s) = DKL [π(· | s) ‖ π(· | s)]. To emulate the effect of a standard entropy bonus (up to a constant), one can define π to be the uniform distribution. The subsequent sections will generalize some of the concepts from reinforcement learning to the setting where we are maximizing the entropy-augmented discounted return."
    }, {
      "heading" : "3.1 Value Functions",
      "text" : "We are obliged to alter our definitions of value functions to include the new KL penalty terms. We shall define the state-value function as the expected return:\nVπ(s) = E [ ∞∑ t=0 γt(rt − τ KLt) ∣∣∣∣∣ s0 = s ] (24)\nand we shall define the Q-function as\nQπ(s, a) = E [ r0 +\n∞∑ t=1 γt(rt − τ KLt) ∣∣∣∣∣ s0 = s, a0 = a ] (25)\nNote that this Q-function does not include the first KL penalty term, which does not depend on the action a0. This definition makes some later expressions simpler, and it leads to the following relationship between Qπ and Vπ:\nVπ(s) = Ea∼π [Qπ(s, a)]− τ KL(s), (26)\nwhich follows from matching terms in the sums in Equations (24) and (25)."
    }, {
      "heading" : "3.2 Boltzmann Policy",
      "text" : "In standard reinforcement learning, the “greedy policy” for Q is defined as [GQ](s) = arg maxaQ(s, a). With entropy regularization, we need to alter our notion of a greedy policy, as the optimal policy is stochastic. Since Qπ omits the first entropy term, it is natural to define the following stochastic policy, which is called the Boltzmann policy, and is analogous to the greedy policy:\nπBQ(· | s) = arg max π {Ea∼π [Q(s, a)]− τDKL [π ‖ π] (s)} (27)\n= π(a | s) exp(Q(s, a)/τ)/Ea′∼π [exp(Q(s, a′)/τ)]︸ ︷︷ ︸ normalizing constant . (28)\nwhere the second equation is analogous to Equation (2) from the bandit setting. Also analogously to the bandit setting, it is natural to define VQ (a function of Q) as\nVQ(s) = τ logEa′∼π [exp(Q(s, a′)/τ)] (29)\nso that\nπBQ(a | s) = π(a | s) exp((Q(s, a)− VQ(s))/τ) (30)\nUnder this definition, it also holds that VQ(s) = Ea∼πBqθ (s) [Q(s, a)]− τDKL [ πBQ ∥∥ π] (s) (31)\nin analogy with Equation (13). Hence, VQ(s) can be interpreted as an estimate of the expected entropyaugmented return, under the Boltzmann policy πBQ.\nAnother way to interpret the Boltzmann policy is as the exponentiated advantage function. Defining the\nadvantage function as AQ(s, a) = Q(s, a)− VQ(s), Equation (30) implies that π B Q(a | s) π(a | s) = exp(AQ(s, a)/τ)."
    }, {
      "heading" : "3.3 Fixed-Policy Backup Operators",
      "text" : "The Tπ operators (for Q and V ) in standard reinforcement learning correspond to computing the expected return with a one-step lookahead: they take the expectation over one step of dynamics, and then fall back on the value function at the next timestep. We can easily generalize these operators to the entropy-regularized setting. We define\n[TπV ](s) = Ea∼π,(r,s′)∼P (r,s′ | s,a) [r − τ KL(s) + γV (s′)] (32) [TπQ](s, a) = E(r,s′)∼P (r,s′ | s,a) [r + γ(Ea′∼π [Q(s′, a′)]− τ KL(s′))] . (33)\nRepeatedly applying the Tπ operator (T nπ V = Tπ(Tπ(. . . Tπ︸ ︷︷ ︸ n times (V )))) corresponds to computing the expected\nreturn with a multi-step lookahead. That is, repeatedly expanding the definition of Tπ, we obtain\n[T nπ V ](s) = E [ n−1∑ t=0 γt(rt − τ KLt) + γnV (sn) ∣∣∣∣∣ s0 = s ] (34)\n[T nπ Q](s, a)− τ KL(s) = E [ n−1∑ t=0 γt(rt − τ KLt) + γn(Q(sn, an)− τ KLn) ∣∣∣∣∣ s0 = s, a0 = a ] . (35)\nAs a sanity check, note that in both equations, the left-hand side and right-hand side correspond to estimates of the total discounted return ∑∞ t=0 γ\nt(rt − τ KLt). The right-hand side of these backup formulas can be rewritten using “Bellman error” terms δt. To rewrite\nthe state-value (V ) backup, define\nδt = (rt − τ KLt) + γV (st+1)− V (st) (36)\nThen we have\n[T nπ V ](s) = E [ n−1∑ t=0 γtδt + γ nV (sn) ∣∣∣∣∣ s0 = s ] . (37)"
    }, {
      "heading" : "3.4 Boltzmann Backups",
      "text" : "We can define another set of backup operators corresponding to the Boltzmann policy, π(a|s) ∝ π(a|s) exp(Q(s, a)/τ). We define the following Boltzmann backup operator:\n[T Q](s, a) = E(r,s′)∼P (r,s′ | s,a) r + γ Ea′∼GQ [Q(s, a)]− τDKL [GQ ‖ π] (s′)︸ ︷︷ ︸ (∗)  (38) = E(r,s′)∼P (r,s′ | s,a)\nr + γ τ logEa′∼π [exp(Q(s′, a′)/τ)]︸ ︷︷ ︸ (∗∗)  (39) where the simplification from (∗) to (∗∗) follows from the same calculation that we performed in the bandit setting (Equations (11) and (13)).\nThe n-step operator T nπ for Q-functions also simplifies in the case that we are executing the Boltzmann policy. Starting with the equation for T nπ Q (Equation (35)) and setting π = πBQ, and then using Equation (31)\nto rewrite the expected Q-function terms in terms of VQ, we obtain\n[(TπBQ) nQ](s, a)− τ KL(s) = E [ n−1∑ t=0 γt(rt − τ KLt) + γn(Q(sn, an)− τ KLn) ∣∣∣∣∣ s0 = s, a0 = a ] (40)\n= E [ n−1∑ t=0 γt(rt − τ KLt) + γnVQ ∣∣∣∣∣ s0 = s, a0 = a ] . (41)\nFrom now on, let’s denote this n-step backup operator by TπB,n. (Note TπBQ,n 6= T nQ, even though TπBQ,1Q = T Q, because TπBQ depends on Q.) One can similarly define the TD(λ) version of this backup operator\n[TπBQ,λQ] = (1− λ)(1 + λTπBQ + (λTπBQ) 2 + . . . )TπBQQ. (42)\nOne can straightforwardly verify by comparing terms that it satisfies [TπBQ,λQ](s, a) = Q(s, a) + E [ ∞∑ t=0 (γλ)tδt ∣∣∣∣∣ s0 = s, a0 = a ] ,\nwhere δt = (rt − τ KLt) + γVQ(st+1)− VQ(st). (43)\n3.5 Soft Q-Learning\nThe Boltzmann backup operators defined in the preceding section can be used to define practical variants of Q-learning that can be used with nonlinear function. These methods, which optimize the entropy-augmented, will be called soft Q-learning. Following Mnih et al. [2015], modern implementations of Q-learning, and nstep Q-learning (see Mnih et al. [2016]) update the Q-function incrementally to compute the backup against a fixed target Q-function, which we’ll call Q. In the interval between each target network update, the algorithm is approximately performing the backup operation Q← T Q (1-step) or Q← TπBQ,nQ (n-step). To perform this approximate minimization, the algorithms minimize the least squares loss\nL(Q) = Et,st,at [ 1 2 (Q(st, at)− yt)2 ] , where (44)\nyt = rt + γVQ(st+1) 1-step Q-learning (45)\nyt = τ KLt + n−1∑ d=0 γd(rt+d − τ KLt+d) + γt+nVQ(st+n) n-step Q-learning (46)\n= τ KLt +VQ(st) + n−1∑ d=0 γdδt+d\nwhere δt = (rt − τ KLt) + γVQ(st+1)− VQ(st) (47)\nIn one-step Q-learning (Equation (45)), yt is an unbiased estimator of [T Q](st, at), regardless of what behavior policy was used to collect the data. In n-step Q-learning (Equation (46)), for n > 1, yt is only an unbiased estimator of [TπBQ,nQ](st, at) if actions at, at+1, . . . , at+d−1 are sampled using π B Q."
    }, {
      "heading" : "3.6 Policy Gradients",
      "text" : "Entropy regularization is often used in policy gradient algorithms, with gradient estimators of the form\nEt,st,at ∇θ log πθ(at | st)∑ t′≥t rt′ − τ∇θDKL [πθ ‖ π] (st)  (48) (Williams [1992], Mnih et al. [2016]).\nHowever, these are not proper estimators of the entropy-augmented return ∑ t(rt − τ KLt), since they don’t account for how actions affect entropy at future timesteps. Intuitively, one can think of the KL terms as a cost for “mental effort”. Equation (48) only accounts for the instantaneous effect of actions on mental effort, not delayed effects.\nTo compute proper gradient estimators, we need to include the entropy terms in the return. We will define the discounted policy gradient in the following two equivalent ways—first, in terms of the empirical return; second, in terms of the value functions Vπ and Qπ:\ngγ(πθ) = E [ ∞∑ t=0 ( ∇θ log πθ(at | st) ∞∑ d=0 γd(rt+d − τ KLt+d)− τ∇θDKL [πθ ‖ π] (st) )]\n(49)\n= E [ ∞∑ t=0 ∇θ log πθ(at | st)(Qπ(st, at)− τ KLt−Vπ(st))− τ∇θDKL [πθ ‖ π] (st) ]\n(50)\nIn the special case of a finite-horizon problem—i.e., rt = KLt = 0 for all t ≥ T—the undiscounted (γ = 1) return is finite, and it is meaningful to compute its gradient. In this case, g1(πθ) equals the undiscounted policy gradient:\ng1(π) = ∇θE [ T−1∑ t=0 (rt − τ KLt) ]\n(51)\nThis result is obtained directly by considering the stochastic computation graph for the loss (Schulman et al. [2015a]), shown in the figure on the right. The edges from θ to the KL loss terms lead to the ∇θDKL [πθ ‖ π] (st) terms in the gradient; the edges to the stochastic actions at lead to the ∇θ log πθ(at | st) ∑T−1 t=d (rt+d − τ KLt+d) terms in the gradient.\ns0 s1 . . . sT−1\na0 a1 . . . aT−1\nr0 r1 . . . rT−1\nk0 k1 . . . kT−1\nθ\nSince g1(πθ) computes the gradient of the entropy-regularized return, one interpretation of gγ(πθ) is that it is an approximation of the undiscounted policy gradient g1(πθ), but that it allows for lower-variance gradient estimators by ignoring some long-term dependencies. A different interpretation of gγ(π) is that it gives a gradient flow such that π∗ = πBQ∗ is the (possibly unique) fixed point.\nAs in the standard MDP setting, one can define approximations to gγ that use a value function to truncate the returns for variance reduction. These approximations can take the form of n-step methods (Mnih et al. [2016]) or TD(λ)-like methods (Schulman et al. [2015b]), though we will focus on n-step returns here. Based on the definition of gγ above, the natural choice of variance-reduced estimator is\nEt,st,at [ ∇θ log πθ(at | st) n−1∑ d=0 γdδt+d ] (52)\nwhere δt was defined in Equation (36). The state-value function V we use in the above formulas should approximate the entropy augmented return ∑∞ t=0 γ\nt(rt − τ KLt). We can fit V iteratively by approximating the n-step backup V ← T nπ V , by minimizing a squared-error loss\nL(V ) = Et,st [ 1 2 (V (st)− yt)2 ] , (53)\nwhere yt = n−1∑ d=0 γdrt+d + γ dV (st+d) = V (st) + n−1∑ d=0 γdδt+d. (54)\n4 Soft Q-learning Gradient Equals Policy Gradient\nThis section shows that the gradient of the squared-error loss from soft Q-learning (Section 3.5) equals the policy gradient (in the family of policy gradients described in Section 3.6) plus the gradient of a squared-error term for fitting the value function. We will not make any assumption about the parameterization of the Q-function, but we define Vθ and πθ as the following functions of the parameterized Q-function Qθ:\nVθ(s) := τ logEa [exp(Qθ(s, a)/τ)] (55) πθ(a | s) := π(a | s) exp((Qθ(s, a)− Vθ(s))/τ) (56)\nHere, πθ is the Boltzmann policy for Qθ, and Vθ is the normalizing factor we described above. From these definitions, it follows that the Q-function can be written as\nQθ(s, a) = Vθ(s) + τ log πθ(a | s) π(a | s) (57)\nWe will substitute this expression into the squared-error loss function. First, for convenience, let us define ∆t = ∑n−1 d=0 γ\ndδt+d. Now, let’s consider the gradient of the n-step soft Q-learning objective:\n∇θEt,st,at∼πθ [ 1 2‖Qθ(st, at)− yt‖ 2 ]\n(58)\nswap gradient and expectation, treating state distribution as fixed:\n= Et,st,at∼πθ [∇θQθ(st, at)(Qθ(st, at)− yt)] (59) replace Qθ using Equation (57), and replace Q-value backup yt by Equation (46):\n= Et,st,at∼πθ [ ∇θQθ(st, at)(τ log π(at | st)π(at | st) + Vθ(st)− (Vθ(st)− τDKL [πθ ‖ π] (st) + ∆t)) ] (60)\ncancel out Vθ(st): = Et,st,at∼πθ [ ∇θQθ(st, at)(τ log π(at | st)π(at | st) − τDKL [πθ ‖ π] (st)−∆t) ] (61)\nreplace the other Qθ by Equation (57):\n= Et,st,at∼πθ [ (τ∇θ log πθ(at | st) +∇θVθ(st)) · (τ log π(at | st)π(at | st) − τDKL [πθ ‖ π] (st)−∆t) ] (62)\nexpand out terms:\n= Et,st,at∼πθ [ τ2∇θ log πθ(at | st) log πθ(at | st)π(at | st) + τ\n2∇θ log πθ(at | st)DKL [πθ ‖ π] (st)︸ ︷︷ ︸ (∗)\n− τ∇θ log πθ(at | st)∆t + τ∇θVθ(st) log πθ(at | st)π(at | st) + τ∇θVθ(st)DKL [πθ ‖ π] (st)︸ ︷︷ ︸ (∗∗)\n−∇θVθ(st)∆t ]\n(63)\n(∗) vanishes because Ea∼πθ(· | st) [∇θ log πθ(at | st) · const] = 0 (∗∗) vanishes because Ea∼πθ(· | st) [ πθ(at | st) π(at | st) ] = DKL [πθ ‖ π] (st)\n= Et,st,at∼πθ [ − τ2∇θDKL [πθ ‖ π] (st) + 0− τ∇θ log πθ(at | st)∆t + 0−∇θVθ(st)∆t ] (64)\nrearrange terms: = Et,st,at∼πθ [ −τ∇θ log πθ(at | st)∆t + τ2∇θDKL [πθ ‖ π]](st)︸ ︷︷ ︸\npolicy grad\n+∇θ 12 ∥∥∥Vθ(st)− V̂t∥∥∥2︸ ︷︷ ︸\nvalue function grad\n] (65)\nNote that the equivalent policy gradient method multiplies the policy gradient by a factor of τ , relative to the value function error. Effectively, the value function error has a coefficient of τ−1, which is larger than what is typically used in practice (Mnih et al. [2016]). We will analyze this choice of coefficient in the experiments.\n5 Soft Q-learning and Natural Policy Gradients\nThe previous section gave a first-order view on the equivalence between policy gradients and soft Q-learning; this section gives a second-order, coordinate-free view. As previous work has pointed out, the natural gradient is the solution to a regression problem; here we will explore the relation between that problem and the nonlinear regression in soft Q-learning.\nThe natural gradient is defined as F−1g, where F is the average Fisher information matrix, F = Es,a∼π [ (∇θ log πθ(a | s))T (∇θ log πθ(a | s)) ] , and g is the policy gradient estimate g ∝ E [∇θ log πθ(a | s)∆], where ∆ is an estimate of the advantage function. As pointed out by Kakade [2002], the natural gradient step can be computed as the solution to a least squares problem. Given timesteps t = 1, 2, . . . , T , define ψt = ∇θ log πθ(at | st). Define Ψ as the matrix whose tth row is ψt, let ∆ denote the vector whose tth element is the advantage estimate ∆t, and let denote a scalar stepsize parameter. Consider the least squares problem\nmin w\n1 2‖Ψw − ∆‖ 2 (66)\nThe least-squares solution is w = (ΨTΨ)−1ΨT∆. Note that E [ ΨTΨ ] is the Fisher information matrix F ,\nand E [ ΨT∆ ] is the policy gradient g, so w is the estimated natural gradient.\nNow let us interpret the least-squares problem in Equation (66). Ψw is the vector whose tth row is ∇θ log πθ(a | s) · w. According to the definition of the gradient, if we perform a parameter update with θ − θold = w, the change in log πθ(a | s) is as follows, to first order in :\nlog πθ(a | s)− log πθold(a | s) ≈ ∇θ log πθ(a | s) · w = ψ ·w (67)\nThus, we can interpret the least squares problem (Equation (66)) as solving\nmin θ T∑ t=1 1 2 (log πθ(at | st)− log πθold(at | st)− ∆t)2 (68)\nThat is, we are adjusting each log-probility log πθold(at | st) by the advantage function ∆t, scaled by . In entropy-regularized reinforcement learning, we have an additional term for the gradient of the KLdivergence:\ng ∝ E [∇θ log πθ(at | st)∆t − τ∇θ KL[πθ, π](st)] (69) = E [ ∇θ log πθ(at | st) ( ∆t − τ [ log ( πθ(at | st) π(at | st) ) −KL[πθ, π](st) ])] (70)\nwhere the second line used the formula for the KL-divergence (Equation (21)) and the identity that Eat∼πθ [∇θ log πθ(at | st) · const] = 0 (where the KL term is the constant.) In this case, the corresponding least squares problem (to compute F−1g) is\nmin θ T∑ t=1 1 2 ( log πθ(at | st)− log πθold(at | st)− ( ∆t − τ [ log ( πθ(at | st) π(at | st) ) −KL[πθold , π](st) ]))2 . (71)\nNow let’s consider Q-learning. Let’s assume that the value function is unchanged by optimization, so Vθ = Vθold . (Otherwise, the equivalence will not hold, since the value function will try to explain the measured advantage ∆, shrinking the advantage update.)\n1 2 (Qθ(st, at)− yt) 2 = 12 (( Vθ(st, at) + τ log ( πθ(at | st) π(at | st) )) − (Vθold(st) + τ KL[πθold , π](st) + ∆t) )2 (72)\n= 12\n( τ log ( πθ(at | st) π(at | st) ) − (∆t + τ KL[πθold , π](st)) )2 (73)\nEvidently, we are regressing log πθ(at | st) towards log πθold(at | st) + ∆t/τ + KL[πθold , π](st). This loss is not equivalent to the natural policy gradient loss that we obtained above.\nWe can recover the natural policy gradient by instead solving a damped version of the Q-function regression problem. Define Q̂ t = (1− )Qθold(st, at) + Q̂t, i.e., we are interpolating between the old value and the backed-up value.\nQ̂ t = (1− )Qθold(st, at) + Q̂t = Qθold(st, at) + (Q̂t −Qθold(st, at)) (74) Q̂t −Qθold(st, at) = (Vθ(st) + τ KL[πθold , π](st) + ∆t)− ( Vθold(st) + τ log ( πθold (at | st) π(at | st) )) (75)\n= ∆t + τ [ KL[πθold , π](st)− log ( πθold (at | st) π(at | st) )] (76)\nQθ(st, at)− Q̂ t = Qθ(st, at)− ( Qθold(st, at) + ( Q̂t −Qθold(st, at) )) (77)\n= Vθ(st) + log ( πθ(at | st) π(at | st) ) − { Vθold(st) + log ( πθold (at | st) π(at | st) ) + ( ∆ + τ [ KL[πθold , π](st)− log ( πθold (at | st) π(at | st) )])} = log πθ(at | st)− log πθold(at | st)− ( ∆t − τ [ log ( πθold (at | st) π(at | st) ) −KL[πθold , π](st) ]) (78)\nwhich exactly matches the expression in the least squares problem in Equation (71), corresponding to entropyregularized natural policy gradient. Hence, the “damped” Q-learning update corresponds to a natural gradient step."
    }, {
      "heading" : "6 Experiments",
      "text" : "To complement our theoretical analyses, we designed experiments to study the following questions:\n1. Though one-step entropy bonuses are used in PG methods for neural network policies (Williams [1992], Mnih et al. [2016]), how do the entropy-regularized RL versions of policy gradients and Q-learning described in Section 3 perform on challenging RL benchmark problems? How does the “proper” entropy-regularized policy gradient method (with entropy in the returns) compare to the naive one (with one-step entropy bonus)? (Section 6.1)\n2. How do the entropy-regularized versions of Q-learning (with logsumexp) compare to the standard DQN of Mnih et al. [2015]? (Section 6.2)\n3. The equivalence between PG and soft Q-learning is established in expectation, however, the actual gradient estimators are slightly different due to sampling. Furthermore, soft Q-learning is equivalent to PG with a particular penalty coefficient on the value function error. Does the equivalence hold under practical conditions? (Section 6.3)"
    }, {
      "heading" : "6.1 A2C on Atari: Naive vs Proper Entropy Bonuses",
      "text" : "Here we investigated whether there is an empirical effect of including entropy terms when computing returns, as described in Section 3. In this section, we compare the naive and proper policy gradient estimators:\nnaive / 1-step: ∇ log πθ(at | st) ( n−1∑ d=0 γdrt+d − V (st) ) + τ∇θDKL [πθ ‖ π] (st) (79)\nproper: ∇ log πθ(at | st) ( n−1∑ d=0 γd(rt+d − τDKL [πθ ‖ π] (st+d))− V (st) ) + τ∇θDKL [πθ ‖ π] (st) (80)\nIn the experiments on Atari, we take π to be the uniform distribution, which gives a standard entropy bonus up to a constant.\nWe start with a well-tuned (synchronous, deterministic) version of A3C (Mnih et al. [2016]), henceforth called A2C (advantage actor critic), to optimize the entropy-regularized return. We use the parameter τ = 0.01 and train for 320 million frames. We did not tune any hyperparameters for the “proper” algorithm— we used the same hyperparameters that had been tuned for the “naive” algorithm.\nAs shown in Figure 1, the “proper” version yields performance that is the same or possibly greater than the “naive” version. Hence, besides being attractive theoretically, the entropy-regularized formulation could lead to practical performance gains."
    }, {
      "heading" : "6.2 DQN on Atari: Standard vs Soft",
      "text" : "Here we investigated whether soft Q-learning (which optimizes the entropy-augmented return) performs differently from standard “hard” Q-learning on Atari. We made a one-line change to a DQN implementation:\nyt = rt + γmax a′\nQ(st+1, a ′) Standard (81)\nyt = rt + γ log ∑ a′ exp(Q(st+1, a ′)/τ)− log|A| “Soft”: KL penalty (82)\nyt = rt + γ log ∑ a′ exp(Q(st+1, a ′)/τ) “Soft”: Entropy bonus (83)\nThe difference between the entropy bonus and KL penalty (against uniform) is simply a constant, however, this constant made a big difference in the experiments, since a positive constant added to the reward encourages longer episodes. Note that we use the same epsilon-greedy exploration in all conditions; the only difference is the backup equation used for computing yt and defining the loss function.\nThe results of two runs on each game are shown in Figure 2. The entropy-bonus version with τ = 0.1 seems to perform a bit better than standard DQN, however, the KL-bonus version performs worse, so the benefit may be due to the effect of adding a small constant to the reward. We have also shown the results for 5-step Q-learning, where the algorithm is otherwise the same. The performance is better on Pong and Q-bert but worse on other games—this is the same pattern of performance found with n-step policy gradients. (E.g., see the A2C results in the preceding section.)\n6.3 Entropy Regularized PG vs Online Q-Learning on Atari\nNext we investigate if the equivalence between soft Q-learning and PG is relevant in practice—we showed above that the gradients are the same in expectation, but their variance might be different, causing different\nlearning dynamics. For these experiments, we modified the gradient update rule used in A2C while making no changes to any algorithmic component, i.e. parallel rollouts, updating parameters every 5 steps, etc. The Q-function was represented as: Qθ(s, a) = Vθ(s) + τ log πθ(a | s), which can be seen as a form of dueling architecture with τ log πθ(a | s) being the “advantage stream” (Wang et al. [2015]). Vθ, πθ are parametrized as the same neural network as A2C, where convolutional layers and the first fully connected layer are shared. πθ(a | s) is used as behavior policy.\nA2C can be seen as optimizing a combination of a policy surrogate loss and a value function loss, weighted by hyperparameter c:\nLpolicy = − log πθ(at | st)∆t + τDKL [πθ ‖ π]](st) (84)\nLvalue = 1 2 ∥∥∥Vθ(st)− V̂t∥∥∥2 (85) La3c = Lpolicy + cLvalue (86)\nIn normal A2C, we have found c = 0.5 to be a robust setting that works across multiple environments. On the other hand, our theory suggests that if we use this Q-function parametrization, soft Q-learning has the same expected gradient as entropy-regularized A2C with a specific weighting c = 1τ . Hence, for the usual entropy bonus coefficient setting τ = 0.01, soft Q-learning is implicitly weighting value function loss a lot more than usual A2C setup (c = 100 versus c = 0.5). We have found that such emphasis on value function (c = 100) results in unstable learning for both soft Q-learning and entropy-regularized A2C. Therefore, to make Q-learning exactly match known good hyperparameters used in A2C, we scale gradients that go into advantage stream by 1γ and scale gradients that go into value function stream by c = 0.5.\nWith the same default A2C hyperparameters, learning curves of PG and QL are almost identical in most games (Figure 3), which indicates that the learning dynamics of both update rules are essentially the same even when the gradients are approximated with a small number of samples. Notably, the Q-value Regression method here demonstrates stable learning without the use of target network or schedule."
    }, {
      "heading" : "7 Related Work",
      "text" : "Three recent papers have drawn the connection between policy-based methods and value-based methods, which becomes close with entropy regularization.\n• O’Donoghue et al. [2016] begin with a similar motivation as the current paper: that a possible explanation for Q-learning and SARSA is that their updates are similar to policy gradient updates. They decompose the Q-function into a policy part and a value part, inspired by dueling Q-networks (Wang et al. [2015]):\nQ(s, a) = V (s) + τ(log π(a | s) + τS[π(· | s)]) (87)\nThis form is chosen so that the term multiplying τ has expectation zero under π, which is a property that the true advantage function satisfies: Eπ [Aπ] = 0. Note that our work omits that S term, because it is most natural to define the Q-function to not include the first entropy term. The authors show that taking the gradient of the Bellman error of the above Q-function leads to a result similar to the policy gradient. They then propose an algorithm called PGQ that mixes together the updates from different prior algorithms.\n• Nachum et al. [2017] also discuss the entropy-regularized reinforcement learning setting, and develop an off-policy method that applies in this setting. Their argument (modified to use our notation and KL penalty instead of entropy bonus) is as follows. The advantage function Aπ(s, a) = Qπ(s, a)−Vπ(s) lets us define a multi-step consistency equation, which holds even if the actions were sampled from a different (suboptimal) policy. In the setting of deterministic dynamics, Qπ(st, at) = rt + γVπ(st+1), hence\nn−1∑ t=0 γtAπ(st, at) = n−1∑ t=0 γt(rt + γVπ(st+1)− Vπ(st)) = n−1∑ t=0 γtrt + γ nVπ(sn)− Vπ(s0) (88)\nIf π is the optimal policy (for the discounted, entropy-augmented return), then it is the Boltzmann policy for Qπ, thus\nτ(log π(a | s)− log π(a | s)) = AQπ (s, a) (89)\nThis expression for the advantage can be substituted into Equation (88), giving the consistency equation\nn−1∑ t=0 γtτ(log π(st, at)− log π(st, at)) = n−1∑ t=0 γtrt + γ nVπ(sn)− Vπ(s0), (90)\nwhich holds when π is optimal. The authors define a squared error objective formed from by taking LHS - RHS in Equation (90), and jointly minimize it with respect to the parameters of π and V . The resulting algorithm is a kind of Bellman residual minimization—it optimizes with respect to the future target values, rather than treating them as fixed Scherrer [2010].\n• Haarnoja et al. [2017] work in the same setting of soft Q-learning as the current paper, and they are concerned with tasks with high-dimensional action spaces, where we would like to learn stochastic policies that are multi-modal, and we would like to use Q-functions for which there is no closed-form way of sampling from the Boltzmann distribution π(a | s) ∝ π(a | s) exp(Q(s, a)/τ). Hence, they use a method called Stein Variational Gradient Descent to derive a procedure that jointly updates the Qfunction and a policy π, which approximately samples from the Boltzmann distribution—this resembles variational inference, where one makes use of an approximate posterior distribution."
    }, {
      "heading" : "8 Conclusion",
      "text" : "We study the connection between two of the leading families of RL algorithms used with deep neural networks. In a framework of entropy-regularized RL we show that soft Q-learning is equivalent to a policy gradient method (with value function fitting) in terms of expected gradients (first-order view). In addition, we also analyze how a damped Q-learning method can be interpreted as implementing natural policy gradient (second-order view). Empirically, we show that the entropy regularized formulation considered in our theoretical analysis works in practice on the Atari RL benchmark, and that the equivalence holds in a practically relevant regime."
    } ],
    "references" : [ {
      "title" : "Taming the noise in reinforcement learning via soft updates",
      "author" : [ "Roy Fox", "Ari Pakman", "Naftali Tishby" ],
      "venue" : "arXiv preprint arXiv:1512.08562,",
      "citeRegEx" : "Fox et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Fox et al\\.",
      "year" : 2015
    }, {
      "title" : "Reinforcement learning with deep energy-based policies",
      "author" : [ "Tuomas Haarnoja", "Haoran Tang", "Pieter Abbeel", "Sergey Levine" ],
      "venue" : "arXiv preprint arXiv:1702.08165,",
      "citeRegEx" : "Haarnoja et al\\.,? \\Q2017\\E",
      "shortCiteRegEx" : "Haarnoja et al\\.",
      "year" : 2017
    }, {
      "title" : "A natural policy gradient",
      "author" : [ "Sham Kakade" ],
      "venue" : "Advances in neural information processing systems,",
      "citeRegEx" : "Kakade.,? \\Q2002\\E",
      "shortCiteRegEx" : "Kakade.",
      "year" : 2002
    }, {
      "title" : "Human-level control through deep reinforcement learning",
      "author" : [ "Volodymyr Mnih", "Koray Kavukcuoglu", "David Silver", "Andrei A Rusu", "Joel Veness", "Marc G Bellemare", "Alex Graves", "Martin Riedmiller", "Andreas K Fidjeland", "Georg Ostrovski" ],
      "venue" : "Nature, 518(7540):529–533,",
      "citeRegEx" : "Mnih et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Mnih et al\\.",
      "year" : 2015
    }, {
      "title" : "Asynchronous methods for deep reinforcement learning",
      "author" : [ "Volodymyr Mnih", "Adria Puigdomenech Badia", "Mehdi Mirza", "Alex Graves", "Timothy P Lillicrap", "Tim Harley", "David Silver", "Koray Kavukcuoglu" ],
      "venue" : "arXiv preprint arXiv:1602.01783,",
      "citeRegEx" : "Mnih et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Mnih et al\\.",
      "year" : 2016
    }, {
      "title" : "Bridging the gap between value and policy based reinforcement learning",
      "author" : [ "Ofir Nachum", "Mohammad Norouzi", "Kelvin Xu", "Dale Schuurmans" ],
      "venue" : "arXiv preprint arXiv:1702.08892,",
      "citeRegEx" : "Nachum et al\\.,? \\Q2017\\E",
      "shortCiteRegEx" : "Nachum et al\\.",
      "year" : 2017
    }, {
      "title" : "Pgq: Combining policy gradient and q-learning",
      "author" : [ "Brendan O’Donoghue", "Remi Munos", "Koray Kavukcuoglu", "Volodymyr Mnih" ],
      "venue" : "arXiv preprint arXiv:1611.01626,",
      "citeRegEx" : "O.Donoghue et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "O.Donoghue et al\\.",
      "year" : 2016
    }, {
      "title" : "Should one compute the temporal difference fix point or minimize the bellman residual? the unified oblique projection view",
      "author" : [ "Bruno Scherrer" ],
      "venue" : "arXiv preprint arXiv:1011.4362,",
      "citeRegEx" : "Scherrer.,? \\Q2010\\E",
      "shortCiteRegEx" : "Scherrer.",
      "year" : 2010
    }, {
      "title" : "Gradient estimation using stochastic computation graphs",
      "author" : [ "John Schulman", "Nicolas Heess", "Theophane Weber", "Pieter Abbeel" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Schulman et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Schulman et al\\.",
      "year" : 2015
    }, {
      "title" : "High-dimensional continuous control using generalized advantage estimation",
      "author" : [ "John Schulman", "Philipp Moritz", "Sergey Levine", "Michael Jordan", "Pieter Abbeel" ],
      "venue" : "arXiv preprint arXiv:1506.02438,",
      "citeRegEx" : "Schulman et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Schulman et al\\.",
      "year" : 2015
    }, {
      "title" : "Dueling network architectures for deep reinforcement learning",
      "author" : [ "Ziyu Wang", "Nando de Freitas", "Marc Lanctot" ],
      "venue" : "arXiv preprint arXiv:1511.06581,",
      "citeRegEx" : "Wang et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2015
    }, {
      "title" : "Simple statistical gradient-following algorithms for connectionist reinforcement learning",
      "author" : [ "Ronald J Williams" ],
      "venue" : "Machine learning,",
      "citeRegEx" : "Williams.,? \\Q1992\\E",
      "shortCiteRegEx" : "Williams.",
      "year" : 1992
    }, {
      "title" : "Modeling purposeful adaptive behavior with the principle of maximum causal entropy",
      "author" : [ "Brian D Ziebart" ],
      "venue" : null,
      "citeRegEx" : "Ziebart.,? \\Q2010\\E",
      "shortCiteRegEx" : "Ziebart.",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "Section 4 shows that the soft Q-learning loss gradient can be interpreted as a policy gradient term plus a baseline-error-gradient term, corresponding to policy gradient instantiations such as A3C [Mnih et al., 2016].",
      "startOffset" : 197,
      "endOffset" : 216
    }, {
      "referenceID" : 8,
      "context" : "With an entropy cost added to the returns, the optimal policy has the form π(a | s) ∝ exp(Q(s, a)); hence policy gradient methods solve for the optimal Q-function, up to an additive constant (Ziebart [2010]).",
      "startOffset" : 192,
      "endOffset" : 207
    }, {
      "referenceID" : 3,
      "context" : "O’Donoghue et al. [2016] also discuss the connection between the fixed points and updates of PG and QL methods, though the discussion of fixed points is restricted to the tabular setting, and the discussion comparing updates is informal and shows an approximate equivalence.",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 3,
      "context" : "Altogether, the update matches what is typically done in “actor-critic” policy gradient methods such as A3C, which explains why Mnih et al. [2016] obtained qualitatively similar results from policy gradients and n-step Q-learning.",
      "startOffset" : 128,
      "endOffset" : 147
    }, {
      "referenceID" : 3,
      "context" : "Altogether, the update matches what is typically done in “actor-critic” policy gradient methods such as A3C, which explains why Mnih et al. [2016] obtained qualitatively similar results from policy gradients and n-step Q-learning. Section 2 uses the bandit setting to provide the reader with a simplified version of our main calculation. (The main calculation applies to the MDP setting.) Section 3 discusses the entropy-regularized formulation of RL, which is not original to this work, but is included for the reader’s convenience. Section 4 shows that the soft Q-learning loss gradient can be interpreted as a policy gradient term plus a baseline-error-gradient term, corresponding to policy gradient instantiations such as A3C [Mnih et al., 2016]. Section 5 draws a connection between QL methods that use batch updates or replay-buffers, and natural policy gradient methods. Some previous work on entropy regularized reinforcement learning (e.g., O’Donoghue et al. [2016], Nachum et al.",
      "startOffset" : 128,
      "endOffset" : 976
    }, {
      "referenceID" : 3,
      "context" : "Altogether, the update matches what is typically done in “actor-critic” policy gradient methods such as A3C, which explains why Mnih et al. [2016] obtained qualitatively similar results from policy gradients and n-step Q-learning. Section 2 uses the bandit setting to provide the reader with a simplified version of our main calculation. (The main calculation applies to the MDP setting.) Section 3 discusses the entropy-regularized formulation of RL, which is not original to this work, but is included for the reader’s convenience. Section 4 shows that the soft Q-learning loss gradient can be interpreted as a policy gradient term plus a baseline-error-gradient term, corresponding to policy gradient instantiations such as A3C [Mnih et al., 2016]. Section 5 draws a connection between QL methods that use batch updates or replay-buffers, and natural policy gradient methods. Some previous work on entropy regularized reinforcement learning (e.g., O’Donoghue et al. [2016], Nachum et al. [2017]) uses entropy bonuses, whereas we use a penalty on Kullback-Leibler (KL) divergence, which is a bit more general.",
      "startOffset" : 128,
      "endOffset" : 998
    }, {
      "referenceID" : 9,
      "context" : "We shall consider an entropy-regularized version of the reinforcement learning problem, following various prior work (Ziebart [2010], Fox et al.",
      "startOffset" : 118,
      "endOffset" : 133
    }, {
      "referenceID" : 0,
      "context" : "We shall consider an entropy-regularized version of the reinforcement learning problem, following various prior work (Ziebart [2010], Fox et al. [2015], Haarnoja et al.",
      "startOffset" : 134,
      "endOffset" : 152
    }, {
      "referenceID" : 0,
      "context" : "We shall consider an entropy-regularized version of the reinforcement learning problem, following various prior work (Ziebart [2010], Fox et al. [2015], Haarnoja et al. [2017], Nachum et al.",
      "startOffset" : 134,
      "endOffset" : 176
    }, {
      "referenceID" : 0,
      "context" : "We shall consider an entropy-regularized version of the reinforcement learning problem, following various prior work (Ziebart [2010], Fox et al. [2015], Haarnoja et al. [2017], Nachum et al. [2017]).",
      "startOffset" : 134,
      "endOffset" : 198
    }, {
      "referenceID" : 3,
      "context" : "Following Mnih et al. [2015], modern implementations of Q-learning, and nstep Q-learning (see Mnih et al.",
      "startOffset" : 10,
      "endOffset" : 29
    }, {
      "referenceID" : 3,
      "context" : "Following Mnih et al. [2015], modern implementations of Q-learning, and nstep Q-learning (see Mnih et al. [2016]) update the Q-function incrementally to compute the backup against a fixed target Q-function, which we’ll call Q.",
      "startOffset" : 10,
      "endOffset" : 113
    }, {
      "referenceID" : 9,
      "context" : "(Williams [1992], Mnih et al.",
      "startOffset" : 1,
      "endOffset" : 17
    }, {
      "referenceID" : 3,
      "context" : "(Williams [1992], Mnih et al. [2016]).",
      "startOffset" : 18,
      "endOffset" : 37
    }, {
      "referenceID" : 8,
      "context" : "This result is obtained directly by considering the stochastic computation graph for the loss (Schulman et al. [2015a]), shown in the figure on the right.",
      "startOffset" : 95,
      "endOffset" : 119
    }, {
      "referenceID" : 3,
      "context" : "These approximations can take the form of n-step methods (Mnih et al. [2016]) or TD(λ)-like methods (Schulman et al.",
      "startOffset" : 58,
      "endOffset" : 77
    }, {
      "referenceID" : 3,
      "context" : "These approximations can take the form of n-step methods (Mnih et al. [2016]) or TD(λ)-like methods (Schulman et al. [2015b]), though we will focus on n-step returns here.",
      "startOffset" : 58,
      "endOffset" : 125
    }, {
      "referenceID" : 3,
      "context" : "Effectively, the value function error has a coefficient of τ−1, which is larger than what is typically used in practice (Mnih et al. [2016]).",
      "startOffset" : 121,
      "endOffset" : 140
    }, {
      "referenceID" : 2,
      "context" : "As pointed out by Kakade [2002], the natural gradient step can be computed as the solution to a least squares problem.",
      "startOffset" : 18,
      "endOffset" : 32
    }, {
      "referenceID" : 9,
      "context" : "Though one-step entropy bonuses are used in PG methods for neural network policies (Williams [1992], Mnih et al.",
      "startOffset" : 84,
      "endOffset" : 100
    }, {
      "referenceID" : 3,
      "context" : "Though one-step entropy bonuses are used in PG methods for neural network policies (Williams [1992], Mnih et al. [2016]), how do the entropy-regularized RL versions of policy gradients and Q-learning described in Section 3 perform on challenging RL benchmark problems? How does the “proper” entropy-regularized policy gradient method (with entropy in the returns) compare to the naive one (with one-step entropy bonus)? (Section 6.",
      "startOffset" : 101,
      "endOffset" : 120
    }, {
      "referenceID" : 3,
      "context" : "Though one-step entropy bonuses are used in PG methods for neural network policies (Williams [1992], Mnih et al. [2016]), how do the entropy-regularized RL versions of policy gradients and Q-learning described in Section 3 perform on challenging RL benchmark problems? How does the “proper” entropy-regularized policy gradient method (with entropy in the returns) compare to the naive one (with one-step entropy bonus)? (Section 6.1) 2. How do the entropy-regularized versions of Q-learning (with logsumexp) compare to the standard DQN of Mnih et al. [2015]? (Section 6.",
      "startOffset" : 101,
      "endOffset" : 558
    }, {
      "referenceID" : 3,
      "context" : "We start with a well-tuned (synchronous, deterministic) version of A3C (Mnih et al. [2016]), henceforth called A2C (advantage actor critic), to optimize the entropy-regularized return.",
      "startOffset" : 72,
      "endOffset" : 91
    }, {
      "referenceID" : 10,
      "context" : "The Q-function was represented as: Qθ(s, a) = Vθ(s) + τ log πθ(a | s), which can be seen as a form of dueling architecture with τ log πθ(a | s) being the “advantage stream” (Wang et al. [2015]).",
      "startOffset" : 174,
      "endOffset" : 193
    }, {
      "referenceID" : 5,
      "context" : "• O’Donoghue et al. [2016] begin with a similar motivation as the current paper: that a possible explanation for Q-learning and SARSA is that their updates are similar to policy gradient updates.",
      "startOffset" : 2,
      "endOffset" : 27
    }, {
      "referenceID" : 5,
      "context" : "• O’Donoghue et al. [2016] begin with a similar motivation as the current paper: that a possible explanation for Q-learning and SARSA is that their updates are similar to policy gradient updates. They decompose the Q-function into a policy part and a value part, inspired by dueling Q-networks (Wang et al. [2015]): Q(s, a) = V (s) + τ(log π(a | s) + τS[π(· | s)]) (87) This form is chosen so that the term multiplying τ has expectation zero under π, which is a property that the true advantage function satisfies: Eπ [Aπ] = 0.",
      "startOffset" : 2,
      "endOffset" : 314
    }, {
      "referenceID" : 5,
      "context" : "• Nachum et al. [2017] also discuss the entropy-regularized reinforcement learning setting, and develop an off-policy method that applies in this setting.",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 6,
      "context" : "The resulting algorithm is a kind of Bellman residual minimization—it optimizes with respect to the future target values, rather than treating them as fixed Scherrer [2010]. • Haarnoja et al.",
      "startOffset" : 157,
      "endOffset" : 173
    }, {
      "referenceID" : 1,
      "context" : "• Haarnoja et al. [2017] work in the same setting of soft Q-learning as the current paper, and they are concerned with tasks with high-dimensional action spaces, where we would like to learn stochastic policies that are multi-modal, and we would like to use Q-functions for which there is no closed-form way of sampling from the Boltzmann distribution π(a | s) ∝ π(a | s) exp(Q(s, a)/τ).",
      "startOffset" : 2,
      "endOffset" : 25
    } ],
    "year" : 2017,
    "abstractText" : "Two of the leading approaches for model-free reinforcement learning are policy gradient methods and Q-learning methods. Q-learning methods can be effective and sample-efficient when they work, however, it is not well-understood why they work, since empirically, the Q-values they estimate are very inaccurate. A partial explanation may be that Q-learning methods are secretly implementing policy gradient updates: we show that there is a precise equivalence between Q-learning and policy gradient methods in the setting of entropy-regularized reinforcement learning, that “soft” (entropy-regularized) Q-learning is exactly equivalent to a policy gradient method. We also point out a connection between Q-learning methods and natural policy gradient methods. Experimentally, we explore the entropy-regularized versions of Q-learning and policy gradients, and we find them to perform as well as (or slightly better than) the standard variants on the Atari benchmark. We also show that the equivalence holds in practical settings by constructing a Q-learning method that closely matches the learning dynamics of A3C without using a target network or -greedy exploration schedule.",
    "creator" : "LaTeX with hyperref package"
  }
}