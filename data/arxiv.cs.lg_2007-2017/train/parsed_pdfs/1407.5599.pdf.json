{
  "name" : "1407.5599.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Scalable Kernel Methods via Doubly Stochastic Gradients",
    "authors" : [ "Bo Dai", "Bo Xie", "Niao He", "Yingyu Liang", "Anant Raj", "Maria-Florina Balcan", "Le Song" ],
    "emails" : [ "araj34}@gatech.edu,", "lsong@cc.gatech.edu", "nhe6@gatech.edu", "ninamf@cs.cmu.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "√ t).\nOur approach can readily scale kernel methods up to the regimes which are dominated by neural nets. We show that our method can achieve competitive performance to neural nets in datasets such as 2.3 million energy materials from MolecularSpace, 8 million handwritten digits from MNIST, and 1 million photos from ImageNet using convolution features."
    }, {
      "heading" : "1 Introduction",
      "text" : "The general perception is that kernel methods are not scalable. When it comes to large-scale nonlinear learning problems, the methods of choice so far are neural nets where theoretical understanding remains incomplete. Are kernel methods really not scalable? Or is it simply because we have not tried hard enough, while neural nets have exploited sophisticated design of feature architectures, virtual example generation for dealing with invariance, stochastic gradient descent for efficient training, and GPUs for further speedup?\nA bottleneck in scaling up kernel methods is the storage and computation of the kernel matrix, K, which is usually dense. Storing the matrix requires O(n2) space, and computing it takes O(n2d) operations, where n is the number of data points and d is the dimension. There have been many great attempts to scale up kernel methods, including efforts from numerical linear algebra, functional analysis, and numerical optimization perspectives.\nA common numerical linear algebra approach is to approximate the kernel matrix using low-rank factors, K ≈ A>A, with A ∈ Rr×n and rank r 6 n. This low-rank approximation usually requires O(nr2 + nrd)\nar X\niv :1\n40 7.\n55 99\nv4 [\ncs .L\nG ]\noperations, and then subsequent kernel algorithms can directly operate on A. Many works, such as Greedy basis selection techniques [1], Nyström approximation [2] and incomplete Cholesky decomposition [3], all followed this strategy. In practice, one observes that kernel methods with approximated kernel matrices often result in a few percentage of losses in performance. In fact, without further assumption on the regularity of the kernel matrix, the generalization ability after low-rank approximation is typically of the order O(1/ √ r + 1/ √ n) [4, 5], which implies that the rank needs to be nearly linear in the number of data points! Thus, in order for kernel methods to achieve the best generalization ability, the low-rank approximation based approaches quickly become impractical for big datasets due to their O(n3 + n2d) preprocessing time and O(n2) memory requirement.\nRandom feature approximation is another popular approach for scaling up kernel methods [6, 7]. Instead of approximating the kernel matrix, the method directly approximates the kernel function using explicit feature maps. The advantage of this approach is that the random feature matrix for n data points can be computed in time O(nrd) using O(nr) memory, where r is the number of random features. Subsequent algorithms then only operate on an O(nr) matrix. Similar to low-rank kernel matrix approximation approach, the generalization ability of random feature approach is of the order O(1/ √ r+1/ √ n) [8, 9], which implies that the number of random features also needs to be O(n). Another common drawback of these two approaches is that it is not easy to adapt the solution from a small r to a large r′. Often one is interested in increasing the kernel matrix approximation rank or the number of random features to obtain a better generalization ability. Then special procedures need to be designed to reuse the solution obtained from a small r, which is not straightforward.\nAnother approach that addresses the scalability issue rises from optimization perspective. One general strategy is to solve the dual forms of kernel methods using coordinate or block-coordinate descent (e.g., [10, 11, 12]). By doing so, each iteration of the algorithm only incurs O(nrd) computation and O(nr) memory, where r is the size of the parameter block. A second strategy is to perform functional gradient descent by looking at a batch of data points at a time (e.g., [13, 15]). Thus, the computation and memory requirements are also O(nrd) and O(nr) respectively in each iteration, where r is the batch size. These approaches can easily change to a different r without restarting the optimization and has no loss in generalization ability since they do not approximate the kernel matrix or function. However, a serious drawback of these approaches is that, without further approximation, all support vectors need to be kept for testing, which can be as big as the entire training set! (e.g., kernel ridge regression and non-separable nonlinear classification problems.)\nIn summary, there exists a delicate trade-off between computation, memory and statistics if one wants to scale up kernel methods. Inspired by various previous efforts, we propose a simple yet general strategy to scale up many kernel methods using a novel concept called “doubly stochastic functional gradients”. Our method relies on the fact that most kernel methods can be expressed as convex optimization problems over functions in reproducing kernel Hilbert spaces (RKHS) and solved via functional gradient descent. Our algorithm proceeds by making two unbiased stochastic approximations to the functional gradient, one using random training points and the other one using random features associated with the kernel, and then descending using this noisy functional gradient. The key intuitions behind our algorithm originate from\n(i) the property of stochastic gradient descent algorithm that as long as the stochastic gradient is unbiased, the convergence of the algorithm is guaranteed [16]; and\n(ii) the property of pseudo-random number generators that the random samples can in fact be completely determined by an initial value (a seed).\nWe exploit these properties and enable kernel methods to achieve better balances between computation, memory and statistics. Our method interestingly combines kernel methods, functional analysis, stochastic optimization and algorithmic trick, and it possesses a number of desiderata:\nGenerality and simplicity. Our approach applies to many kernel methods, such as kernel ridge regression, support vector machines, logistic regression, two-sample test, and many different types of kernels, such as shift-invariant kernels, polynomial kernels, general inner product kernels, and so on. The algorithm can be summarized in just a few lines of code (Algorithm 1 and 2). For a different problem and kernel, we just need\nto adapt the loss function and the random feature generator.\nFlexibility. Different from previous uses of random features which typically prefix the number of features and then optimize over the feature weightings, our approach allows the number of random features, and hence the flexibility of the function class, to grow with the number of data points. This allows our method to be applicable to data streaming setting, which is not possible for previous random feature approach, and achieve the full potential of nonparametric methods.\nEfficient computation. The key computation of our method is evaluating the doubly stochastic functional gradient, which involves the generation of the random features with specific random seeds and the evaluation of these random features on the small batch of data points. For iteration t, the computational complexity is O(td).\nSmall memory. The doubly stochasticity also allows us to avoid keeping the support vectors which becomes prohibitive in large-scale streaming setting. Instead, we just need to keep a small program for regenerating the random features, and sample previously used random feature according to pre-specified random seeds. For iteration t, the memory needed is O(t) independent of the dimension of the data.\nTheoretical guarantees. We provide a novel and nontrivial analysis involving Hilbert space martingale and a newly proved recurrence relation, and show that the estimator produced by our algorithm, which might be outside of the RKHS, converges to the optimal RKHS function. More specifically, both in expectation and with high probability, our algorithm can estimate the optimal function in the RKHS in the rate of O(1/t), which are indeed optimal [16], and achieve a generalization bound of O(1/ √ t). The variance of the random features, introduced during our second approximation to the functional gradient, only contributes additively to the constant in the final convergence rate. These results are the first of the kind in kernel method literature, which can be of independent interest.\nStrong empirical performance. Our algorithm can readily scale kernel methods up to the regimes which are previously dominated by neural nets. We show that our method compares favorably to other scalable kernel methods in medium scale datasets, and to neural nets in big datasets such as 8 million handwritten digits from MNIST, 2.3 million materials from MolecularSpace, and 1 million photos from ImageNet using convolution features. Our results suggest that kernel methods, theoretically well-grounded methods, can potentially replace neural nets in many large scale real-world problems where nonparametric estimation are needed.\nIn the remainder, we will first introduce preliminaries on kernel methods and functional gradients. We will then describe our algorithm and provide both theoretical and empirical supports."
    }, {
      "heading" : "2 Duality between Kernels and Random Processes",
      "text" : "Kernel methods owe their name to the use of kernel functions, k(x, x′) : X × X 7→ R, which are symmetric positive definite (PD), meaning that for all n > 1, and x1, . . . , xn ∈ X , and c1, . . . , cn ∈ R, we have∑n i,j=1 cicjk(xi, xj) > 0. There is an intriguing duality between kernels and stochastic processes which will play a crucial role in our later algorithm design. More specifically,\nTheorem 1 (e.g.,[17]; [18]) If k(x, x′) is a PD kernel, then there exists a set Ω, a measure P on Ω, and random feature φω(x) : X 7→ R from L2(Ω,P), such that k(x, x′) = ∫ Ω φω(x)φω(x ′) dP(ω).\nEssentially, the above integral representation relates the kernel function to a random process ω with measure P(ω). Note that the integral representation may not be unique. For instance, the random process can be a Gaussian process on X with the sample function φω(x), and k(x, x′) is simply the covariance function between two point x and x′. If the kernel is also continuous and shift invariant, i.e., k(x, x′) = k(x−x′) for x ∈ Rd, then the integral representation specializes into a form characterized by inverse Fourier transformation (e.g., [19, Theorem 6.6]),\nTheorem 2 (Bochner) A continuous, real-valued, symmetric and shift-invariant function k(x−x′) on Rd is a PD kernel if and only if there is a finite non-negative measure P(ω) on Rd, such that k(x − x′) =\n∫ Rd e iω>(x−x′) dP(ω) = ∫ Rd×[0,2π] 2 cos(ω\n>x+ b) cos(ω>x′ + b) d (P(ω)× P(b)) , where P(b) is a uniform distribution on [0, 2π], and φω(x) = √ 2 cos(ω>x+ b).\nFor Gaussian RBF kernel, k(x − x′) = exp(−‖x − x′‖2/2σ2), this yields a Gaussian distribution P(ω) with density proportional to exp(−σ2‖ω‖2/2); for the Laplace kernel, this yields a Cauchy distribution; and for the Martern kernel, this yields the convolutions of the unit ball [20].\nSimilar representation where the explicit form of φω(x) and P(ω) are known can also be derived for rotation invariant kernel, k(x, x′) = k(〈x, x′〉), using Fourier transformation on sphere [20]. For polynomial kernels, k(x, x′) = (〈x, x′〉+ c)p, a random tensor sketching approach can also be used [21]. Explicit random features have been designed for many other kernels, such as dot product kernel [33], additive/multiplicative class of homogeneous kernels [34], e.g., Hellinger’s, χ2, Jensen-Shannon’s and Intersection kernel, as well as kernels on Abelian semigroups [35]. We summarized these kernels with their explicit features and associated densities in Table 1.\nInstead of finding the random process P(ω) and function φω(x) given a kernel, one can go the reverse direction, and construct kernels from random processes and functions (e.g., [19]).\nTheorem 3 If k(x, x′) = ∫\nΩ φω(x)\n>φω(x ′) dP(ω) for a nonnegative measure P(ω) on Ω and φω(x) : X 7→ Rr,\neach component from L2(Ω,P), then k(x, x′) is a PD kernel.\nFor instance, φω(x) := cos(ω >ψθ(x)+b), where ψθ(x) can be a random convolution of the input x parametrized by θ, or φω(x) = [φω1(x), φω2(x), . . . , φωr (x)], where φω1(x) denote the random feature for kernel k1(x, x ′). The former random features define a hierachical kernel [45], and the latter random features induce a linear combination of multiple kernels. It is worth to note that the Hellinger’s, χ2, Jensen-Shannon’s and Intersection kernels in [34] are special cases of multiple kernels combination. For simplicity, we assume φw(x) ∈ R following, and our algorithm is still applicable to φw(x) ∈ Rr.\nAnother important concept is the reproducing kernel Hilbert space (RKHS). An RKHS H on X is a Hilbert space of functions from X to R. H is an RKHS if and only if there exists a k(x, x′) : X × X 7→ R such that ∀x ∈ X , k(x, ·) ∈ H, and ∀f ∈ H, 〈f(·), k(x, ·)〉H = f(x). If such a k(x, x′) exist, it is unique and it is a PD kernel. A function f ∈ H if and only if ‖f‖2H := 〈f, f〉H < ∞, and its L2 norm is dominated by RKHS norm ‖f‖L2 6 ‖f‖H ."
    }, {
      "heading" : "3 Doubly Stochastic Functional Gradients",
      "text" : "Many kernel methods can be written as convex optimizations over functions in the RKHS and solved using the functional gradient methods [13, 15]. Inspired by these previous works, we will introduce a novel concept called “doubly stochastic functional gradients” to address the scalability issue. Let l(u, y) be a scalar (potentially non-smooth) loss function convex of u ∈ R. Let the subgradient of l(u, y) with respect to u be l′(u, y). Given a PD kernel k(x, x′) and the associated RKHS H, many kernel methods try to find a function f∗ ∈ H which solves the optimization problem\nargmin f∈H\nR(f) := E(x,y)[l(f(x), y)] + ν\n2 ‖f‖2H ⇐⇒ argmin ‖f‖H6B(ν) E(x,y)[l(f(x), y)] (1)\nwhere ν > 0 is a regularization parameter, B(ν) is a non-increasing function of ν, and the data (x, y) follow a distribution P(x, y). The functional gradient ∇R(f) is defined as the linear term in the change of the objective after we perturb f by in the direction of g, i.e.,\nR(f + g) = R(f) + 〈∇R(f), g〉H +O( 2). (2)\nFor instance, applying the above definition, we have ∇f(x) = ∇〈f, k(x, ·)〉H = k(x, ·), and ∇‖f‖ 2 H = ∇〈f, f〉H = 2f . Stochastic functional gradient. Given a data point (x, y) ∼ P(x, y) and f ∈ H, the stochastic functional gradient of E(x,y)[l(f(x), y)] with respect to f ∈ H is ξ(·) := l′(f(x), y)k(x, ·), (3)\nT ab\nle 1:\nS u\nm m\nar y\no f\nke rn\nel s\nin [6\n, 4 6 ,\n3 3 ,\n2 1 ,\n3 4 ,\n3 5 ,\n4 5 ]\na n\nd th\nei r\nex p\nli ci\nt fe\na tu\nre s\nK er\nn el\nk (x ,x ′ )\nφ ω\n(x )\np (ω\n)\nG au\nss ia\nn ex\np (− ‖x − x ′ ‖\n2 2 2 )\nex p\n(− iω > x\n) (2 π\n)− d 2\nex p\n(− ‖ω ‖2 2 2\n)\nL ap\nla ci\nan ex\np (− ‖x − x ′ ‖\n1 )\nex p\n(− iω > x\n) ∏ d i=1\n1 π\n(1 + ω\n2 i )\nC au\nch y\n∏ d i=1 2 1 +\n(x i − x ′ i)\n2 ex\np (− iω > x\n) ex\np (− ‖ω ‖ 1\n)\nM at\nér n\n2 1 − ν Γ (ν\n)\n( √ 2 ν ‖x − x ′ ‖\n2\n`\n) ν K ν ( √ 2\nν ‖x − x ′ ‖\n2\n`\n) ex\np (− iω > x\n) h\n(ν ,d ,`\n)( 2ν `2 +\n4π 2 ‖ω ‖2 2 ) ν+d\n/ 2\nD ot\nP ro\nd u\nct ∑ ∞ n=\n0 a n 〈x ,x ′ 〉n\na n >\n0 √ a N\np N\n+ 1 ∏ N i=1\nω > i x\nP[ N\n= n\n] =\n1 p n +\n1\np (ω j i |N\n= n\n) =\n1 2\nω j i +\n1 2 1 2\n1 − ω j i 2\nP ol\ny n\nom ia\nl (〈 x ,x ′ 〉\n+ c) p\nF F T −\n1 (F F T (C\n1 x\n) .. . F F T (C\np x\n)) C j\n= S j D j D j ∈ R d × d S j ∈ R D × d\nH el\nli n\nge r\n∑ d i= 1\n√ x i x ′ i\n2ω > √ x\n1 2\nω i +\n1 2 1 2\n1 − ω i\n2 , ω i ∈ {−\n1, + 1} χ 2 2 ∑ d i= 1 x i x ′ i x i + x ′ i [ exp (− iω lo g x j )√ x j ] d j=1 se ch (π ω ) In te rs ec ti on ∑ d i= 1 m in (x i, x ′ i) [ exp (− iω lo g x j )√ 2 x j ] d j=1 1 π (1 + 4 ω 2 ) J en se n -S h an n on ∑ d i= 1 K J S (x i, x ′ i) [ exp (− iω lo g x j )√ 2 x j ] d j=1 s e c h (π ω ) lo g 4 (1 + 4 ω 2 ) S k ew ed -χ 2 2 ∏ d i=1 √ x i + c √ x ′ i+ c x i + x ′ i+ 2 c ex p (− iω > lo g (x + c) ) ∏ d i=1 se ch (π ω i) S k ew ed -I n te rs ec ti o n ∏ d i=1 m in ( √ x i + c x ′ i+ c ,√ x ′ i+ c x i + c ) ex p (− iω > lo g (x + c) ) ∏ d i=1 1 π (1 + 4 ω 2 i ) E x p o n en ti a lS em ig ro u p ex p (− β ∑ d i= 1 √ x i + x ′ j) ex p (− ω > x ) ∏ d i=1 β 2 √ π ω − 3 2 i ex p (− β 4 ω i ) R ec ip ro ca lS em ig ro u p ∏ d i=1 λ x i + x ′ i+ λ ex p (− ω > x ) ∏ d i=1 λ ex p (− λ ω i) A rc -C os in e 1 π ‖x ‖n ‖x ′ ‖ n J n (θ ) (ω > x )n m a x (0 ,ω > x ) 2π − d 2 ex p (− ‖ω ‖2 2 2 )\nD j\nis ra\nn d\nom {±\n1 }\nd ia\ngo n\nal m\nat ri\nx a n d\nth e\nco lu\nm n\ns o f S j\na re\nu n\nif o rm\nly se\nle ct\ned fr\no m {e\n1 ,. .. ,e D }. ν\na n\nd `\na re\np o si\nti ve\np a ra\nm et\ner s.\nh (ν ,d ,`\n) =\n2 d π d / 2 Γ\n(ν + d / 2 )(\n2 ν )ν\nΓ (ν\n)` 2 ν\n. K ν\nis a\nm o d\nifi ed\nB es\nse l\nfu n\nct io\nn . K J S\n(x ,x ′ )\n= x 2\nlo g\n2 x\n+ x ′ x +\nx ′ 2\nlo g\n2 x\n+ x ′ x ′\n.\nθ =\nco s−\n1 x > x ′ ‖x ‖‖ x ′ ‖\n, J n (θ\n) =\n(− 1 )n\n(s in θ)\n2 n\n+ 1\n( 1 sin θ ∂ ∂ θ\n) n( π − θ si n θ\n)\nAlgorithm 1: {αi}ti=1 = Train(P(x, y)) Require: P(ω), φω(x), l(f(x), y), ν.\n1: for i = 1, . . . , t do 2: Sample (xi, yi) ∼ P(x, y). 3: Sample ωi ∼ P(ω) with seed i. 4: f(xi) = Predict(xi, {αj}i−1j=1). 5: αi = −γil′(f(xi), yi)φωi(xi). 6: αj = (1− γiν)αj for j = 1, . . . , i− 1. 7: end for\nAlgorithm 2: f(x) = Predict(x, {αi}ti=1) Require: P(ω), φω(x).\n1: Set f(x) = 0. 2: for i = 1, . . . , t do 3: Sample ωi ∼ P(ω) with seed i. 4: f(x) = f(x) + αiφωi(x). 5: end for\nwhich is essentially a single data point approximation to the true functional gradient. Furthermore, for any g ∈ H, we have 〈ξ(·), g〉H = l′(f(x), y)g(x). Inspired by the duality between kernel functions and random processes, we can make an additional approximation to the stochastic functional gradient using a random feature φω(x) sampled according to P(ω). More specifically,\nDoubly stochastic functional gradient. Let ω ∼ P(ω), then the doubly stochastic gradient of E(x,y)[l(f(x), y)] with respect to f ∈ H is\nζ(·) := l′(f(x), y)φω(x)φω(·). (4)\nNote that the stochastic functional gradient ξ(·) is in RKHSH but ζ(·) may be outsideH, since φω(·) may be outside the RKHS. For instance, for the Gaussian RBF kernel, the random feature φω(x) =√\n2 cos(ω>x+b) is outside the RKHS associated with the kernel function.\nHowever, these functional gradients are related by ξ(·) = Eω [ζ(·)], which lead to unbiased estimators of the original functional gradient, i.e.,\nWe emphasize that the source of randomness associated with the random feature is not present in the data, but artificially introduced by us. This is crucial for the development of our scalable algorithm in the next section. Meanwhile, it also creates additional challenges in the analysis of the algorithm which we will deal with carefully."
    }, {
      "heading" : "4 Doubly Stochastic Kernel Machines",
      "text" : "The first key intuition behind our algorithm originates from the property of stochastic gradient descent algorithm that as long as the stochastic gradient is unbiased, the convergence of the algorithm is guaranteed [16]. In our algorithm, we will exploit this property and introduce two sources of randomness, one from data and another artificial, to scale up kernel methods.\nThe second key intuition behind our algorithm is that the random features used in the doubly stochastic functional gradients will be sampled according to pseudo-random number generators, where the sequences of apparently random samples can in fact be completely determined by an initial value (a seed). Although these random samples are not the “true” random sample in the purest sense of the word, however they suffice for our task in practice.\nMore specifically, our algorithm proceeds by making two unbiased stochastic approximation to the functional gradient in each iteration, and then descending using this noisy functional gradient. The overall algorithms for training and prediction is summarized in Algorithm 1 and 2. The training algorithm essentially just performs random feature sampling and doubly stochastic gradient evaluation, and maintains a collection of real number {αi}, which is computationally efficient and memory friendly. A crucial step in the\nalgorithm is to sample the random features with “seed i”. The seeds have to be aligned between training and prediction, and with the corresponding αi obtained from each iteration. The learning rate γt in the algorithm needs to be chosen as O(1/t), as shown by our later analysis to achieve the best rate of convergence. For now, we assume that we have access to the data generating distribution P(x, y). This can be modified to sample uniformly randomly from a fixed dataset, without affecting the algorithm and the later convergence analysis. Let the sampled data and random feature parameters be Dt := {(xi, yi)}ti=1 and ωt := {ωi} t i=1 respectively after t iteration, the function obtained by Algorithm 1 is a simple additive form of the doubly stochastic functional gradients\nft+1(·) = ft(·)− γt(ζt(·) + νft(·)) = ∑t\ni=1 aitζi(·), ∀t > 1, and f1(·) = 0, (7) where ait = −γi ∏t j=i+1(1 − γjν) are deterministic values depending on the step sizes γj(i 6 j 6 t) and regularization parameter ν. This simple form makes it easy for us to analyze its convergence. We note that our algorithm can also take a mini-batch of points and random features at each step, and estimate an empirical covariance for preconditioning to achieve potentially better performance. Our algorithm is general and can be applied to most of the kernel machines which are formulated in the convex optimization (1) in a RKHS H associated with given kernel k(x, x′). We will instantiate the doubly stochastic gradients algorithms for a few commonly used kernel machines for different tasks and loss functions, e.g., regression, classification, quantile regression, novelty detection and estimating divergence functionals/likelihood ratio. Interestingly, the Gaussian process regression, which is a Bayesian model, can also be reformulated as the solution to particular convex optimizations in RKHS, and therefore, be approximated by the proposed algorithm.\nKernel Support Vector Machine (SVM). Hinge loss is used in kernel SVM where l(u, y) = max{0, 1−uy}\nwith y ∈ {−1, 1}. We have l′(u, y) =\n{ 0 if yu > 1\n−y if yu < 1 and the step 5 in Algorithm. 1. becomes\nαi =\n{ 0 if yif(xi) > 1\nγiyiφωi(xi) if yif(xi) < 1 .\nRemark: [14] used squared hinge loss, l(u, y) = 12 max{0, 1− uy} 2, in `2-SVM. With this loss function,\nwe have l′(u, y) =\n{ 0 if yu > 1\nu− y if yu < 1 and the step 5 in Algorithm. 1. becomes\nαi =\n{ 0 if yif(xi) > 1\nγi(yi − f(xi))φωi(xi) if yif(xi) < 1 .\nKernel Logistic Regression. Log loss is used in kernel logistic regression for binary classification where l(u, y) = log(1+exp(−yu)) with y ∈ {−1, 1}. We have l′(u, y) = − y exp(−yu)1+exp(−yu) and the step 5 in Algorithm. 1. becomes\nαi = γiyi exp(−yif(xi))\n1 + exp(−yif(xi)) φωi(xi).\nFor the multi-class kernel logistic regression, the l(u, y) = − ∑C c=1 δc(y)uc + log (∑C c=1 exp(uc) ) where\nC is the number of categories, u ∈ RC×1, y ∈ {1, . . . , C} and δc(y) = 1 only if y = c, otherwise δc(y) = 0. In such scenario, we denote f(xi) = [f 1(xi), . . . , f C(xi)], and therefore, the corresponding α = [α\n1, . . . , αC ]. The update rule for α in Algorithm. 1. is\nαci = γi ( δc(yi)−\nexp(f c(xi))∑C c=1 exp(f c(xi))\n) φωi(xi) ∀c = 1, . . . , C,\nαcj = (1− γiν)αcj ,∀j < i,∀c = 1, . . . , C. Kernel Ridge Regression. Square loss is used in kernel ridge regression where l(u, y) = 12 (u − y) 2. We\nhave l′(u, y) = (u− y) and the step 5 in Algorithm. 1. becomes αi = −γi(f(xi)− yi)φωi(xi). Kernel Robust Regression. Huber’s loss is used for robust regression [22] where\nl(u, y) =\n{ 1 2 (u− y)\n2 if |u− y| 6 1 |u− y| − 12 if |u− y| > 1 .\nWe have l′(u, y) = { (u− y) if |u− y| 6 1 sign(u− y) if |u− y| > 1 and the step 5 in Algorithm. 1. becomes\nαi = { −γi(f(xi)− yi)φωi(xi) if |f(xi)− yi| 6 1 −γi sign(f(xi)− yi)φωi(xi) if |f(xi)− yi| > 1\nKernel Support Vector Regression (SVR). -insensitive loss function is used in kernel SVR where\nl(u, y) = max{0, |u− y|− }. We have l′(u, y) = { 0 if |u− y| 6 sign(u− y) if |u− y| > and the step 5 in Algorithm. 1.\nbecomes\nαi = { 0 if |f(xi)− yi| 6 −γi sign(f(xi)− yi)φωi(xi) if |f(xi)− yi| >\nRemark: Note that if we set = 0, the -intensitive loss function will become absolute deviatin, i.e., l(u, y) = |u− y|. Therefore, we have the updates for kernel least absolute deviatin regression. Kernel Quantile Regression. The loss function for quantile regression is l(u, y) = max{τ(y − u), (1 −\nτ)(u− y)}. We have l′(u, y) = { 1− τ if u > y −τ if u < y and the step 5 in Algorithm. 1. becomes\nαi = { γi(τ − 1)φωi(xi) if f(xi) > yi γiτφωi(xi) if f(xi) < yi .\nKernel Novelty Detection. The loss function l(u, τ) = max{0, τ−u} [23] is proposed for novelty detection. Since τ is also a variable which needs to be optimized, the optimization problem is formulated as\nmin τ∈R,f∈H\nEx[l(f(x), τ)] + ν\n2 ‖f‖2H − ντ,\nand the gradient of l(u, τ) is\n∂l(u, τ)\n∂u =\n{ 0 if u > τ\n−1 if u < τ ,\n∂l(u, τ)\n∂τ =\n{ 0 if u > τ\n1 if u < τ .\nThe step 5 in Algorithm. 1. becomes\nαi = { 0 if f(xi) > τi−1 γiφωi(xi) if f(xi) < τi−1 , τi = { τi−1 + γiν if f(xi) > τi−1 τi−1 − γi(1− ν) if f(xi) < τi−1 .\nKernel Density Ratio Estimation. Based on the variational form of Ali-Silvey divergence, i.e., Ep [ r( qp ) ] , where r : R+ → R is a convex function with r(1) = 0, [24] proposed a nonparametric estimator for the logarithm of the density ratio, log qp , which is the solution of following convex optimization,\nargmin f∈H\nEq[exp(f)] + Ep[r∗(− exp(f))] + ν\n2 ‖f‖2H (8)\nwhere r∗ denotes the Fenchel-Legendre dual of r, r(τ) := supχ χτ − r∗(χ). In Kullback-Leibler (KL) divergence, the rKL(τ) = − log(τ). Its Fenchel-Legendre dual is\nr∗KL(τ) = { ∞ if τ > 0 −1− log(−τ) if τ < 0\nSpecifically, the optimization becomes\nmin f∈H\nR(f) = Ey∼q[exp(f(y))]− Ex∼p[f(x)] + ν\n2 ‖f‖2H = 2Ez,x,y [ δ1(z) exp(f(y))− δ0(z)f(x) ] + ν\n2 ‖f‖2H.\nwhere z ∼ Bernoulli(0.5). Denote l(ux, uy, z) = δ1(z) exp(uy)− δ0(z)ux, we have l′(ux, uy, z) = δ1(z) exp(uy)− δ0(z)\nand the the step 5 in Algorithm. 1. becomes\nαi = −2γi(δ1(zi) exp(f(yi))φωi(yi)− δ0(zi)φωi(xi)), zi ∼ Bernoulli(0.5). In particular, the xi and yi are not sampled in pair, they are sampled independently from P(x) and Q(x) respectively.\n[24] proposed another convex optimization based on rKL(τ) whose solution is a nonparametric estimator for the density ratio. [25] designed rnv(τ) = max(0, ρ − log τ) for novelty detection. Similarly, the doubly stochastic gradients algorithm is also applicable to these loss functions. Gaussian Process Regression. The doubly stochastic gradients can be used for approximating the posterior of Gaussian process regression by reformulating the mean and variance of the predictive distribution as the solutions to the convex optimizations with particular loss functions. Let y = f(x) + where ∼ N (0, σ2) and f(x) ∼ GP(0, k(x, x′)), given the dataset {xi, yi}ni=1, the posterior distribution of the function at the test point x∗ can be derived as\nf∗|X,y, x∗ ∼ N ( k∗> ( K + σ2I )−1 y, k(x∗, x∗)− k∗> ( K + σ2I )−1 k∗ )\n(9)\nwhere K ∈ Rn×n, Kij = K(xi, xj), k∗ = [k(x∗, x1), . . . , k(x∗, xn)]> and I ∈ Rn×n is the identity matrix. Obviously, the posterior mean of the Gaussian process for regression can be thought as the solution to optimization problem (1) with square loss and setting ν = 2σ2. Therefore, the update rule for approximating the posterior mean will be the same as kernel ridge regression.\nTo compute the predictive variance, we need to evaluate the k∗> ( K + σ2I )−1 k∗. Following, we will\nintroduce two different optimizations whose solutions can be used for evaluating the quantity.\n1. Denote φ = [k(x1, ·), . . . , k(xn, ·)], then k∗> ( K + σ2I )−1 k∗ = k(x∗, ·)>φ ( φ>φ+ σ2I )−1 φ>k(x∗, ·)\n= k(x∗, ·)>φφ> ( φφ> + σ2I )−1 k(x∗, ·)\nwhere the second equation based on identity ( φφ> + σ2I ) φ = φ ( φ>φ+ σ2I ) . Therefore, we just need to estimate the operator:\nA = C ( C + σ 2\nn I\n)−1 where C = 1\nn φφ> =\n1\nn n∑ i=1 k(xi, ·)⊗ k(xi, ·). (10)\nWe can express A as the solution to the following convex optimization problem\nmin A R(A) = 1 2n n∑ i=1 ‖k(xi, ·)−Ak(xi, ·)‖2H + σ2 2n ‖A‖2HS\nwhere ‖ · ‖HS is the Hilbert-Schmidt norm of the operator. We can achieve the optimum by ∇R = 0, which is equivalent to Eq. 10.\nBased on this optimization, we approximate the At using ∑t i6j,i=1 θijφωi(·)⊗φωj (·) by doubly stochas-\ntic functional gradients. The update rule for θ is\nθij =\n( 1− σ 2\nn γt\n) θij , ∀i 6 j < t\nθit = −γt t−1∑ j>i θijφω′j (xt)φω′t(xt), ∀i < t\nθtt = γtφωt(xt)φω′t(xt).\nPlease refer to Appendix D for the details of the derivation.\n2. Assume that the testing points, {x∗i }mi=1, are given beforehand, instead of approximating the operator A, we target on functions F ∗ = [f∗1 , . . . , f∗m]> where f∗i (·) = k(·)> ( K + σ2I )−1 k∗i , k(·) =\n[k(x1, ·), . . . , k(x2, ·)] and k∗i = [k(x∗i , x1), . . . , k(x∗i , xn)]>. Estimating f∗i (·) can be accomplished by solving the optimization problem (1) with square loss and setting yj = k(x ∗ i , xj),∀j = 1, . . . , n, ν = 2σ2, leading to the same update rule as kernel ridge regression.\nAfter we obtain these estimators, we can calculate the predictive variance on x∗i by either k(x ∗ i , x ∗ i ) − A(x∗i , x∗i ) or k(x∗i , x∗i )−f∗i (x∗i ). We conduct experiments to justify the novel formulations for approximating both the mean and variance of posterior of Gaussian processes for regression, and the doubly stochastic update rule in Section.(7).\nNote that, to approximate the operator A, doubly stochastic gradient requires O(t2) memory. Although we do not need to save the whole training dataset, which savesO(dt) memory cost, this is still computationally expensive. When the m testing data are given, we estimate m functions and each of them requires O(t) memory cost, the total cost will be O(tm) by the second algorithm."
    }, {
      "heading" : "5 Theoretical Guarantees",
      "text" : "In this section, we will show that, both in expectation and with high probability, our algorithm can estimate the optimal function in the RKHS with rate O(1/t), and achieve a generalization bound of O(1/ √ t). The analysis for our algorithm has a new twist compared to previous analysis of stochastic gradient descent algorithms, since the random feature approximation results in an estimator which is outside the RKHS. Besides the analysis for stochastic functional gradient descent, we need to use martingales and the corresponding concentration inequalities to prove that the sequence of estimators, ft+1, outside the RKHS converge to the optimal function, f∗, in the RKHS. We make the following standard assumptions ahead for later references:\nA. There exists an optimal solution, denoted as f∗, to the problem of our interest (1). B. Loss function `(u, y) : R×R→ R and its first-order derivative is L-Lipschitz continous in terms of the\nfirst argument. C. For any data {(xi, yi)}ti=1 and any trajectory {fi(·)}ti=1, there exists M > 0, such that |`′(fi(xi), yi)| 6\nM . Note in our situation M exists and M < ∞ since we assume bounded domain and the functions ft we generate are always bounded as well. D. There exists κ > 0 and φ > 0, such that k(x, x′) 6 κ, |φω(x)φω(x′)| 6 φ, ∀x, x′ ∈ X , ω ∈ Ω. For example, when k(·, ·) is the Gaussian RBF kernel, we have κ = 1, φ = 2. We now present our main theorems as below. Due to the space restrictions, we will only provide a short sketch of proofs here. The full proofs for the these theorems are given in the Appendix A-C.\nTheorem 4 (Convergence in expectation) When γt = θ t with θ > 0 such that θν ∈ (1, 2) ∪ Z+,\nEDt,ωt [ |ft+1(x)− f∗(x)|2 ] 6\n2C2 + 2κQ21 t , for any x ∈ X\nwhere Q1 = max { ‖f∗‖H , (Q0 + √ Q20 + (2θν − 1)(1 + θν)2θ2κM2)/(2νθ − 1) } , with Q0 = 2 √ 2κ1/2(κ + φ)LMθ2, and C2 = 4(κ+ φ)2M2θ2.\nTheorem 5 (Convergence with high probability) When γt = θ t with θ > 0 such that θν ∈ Z+ and t > θν, for any x ∈ X , we have with probability at least 1− 3δ over (Dt,ωt),\n|ft+1(x)− f∗(x)|2 6 C2 ln(2/δ)\nt +\n2κQ22 ln(2t/δ) ln 2(t)\nt , where C is as above and Q2 = max { ‖f∗‖H , Q0 + √ Q20 + κM 2(1 + θν)2(θ2 + 16θ/ν) } , with Q0 = 4 √ 2κ1/2Mθ(8+ (κ+ φ)θL).\nProof sketch: We focus on the convergence in expectation; the high probability bound can be established in a similar fashion. The main technical difficulty is that ft+1 may not be in the RKHS H. The key of the proof is then to construct an intermediate function ht+1, such that the difference between ft+1 and ht+1 and the difference between ht+1 and f∗ can be bounded. More specifically,\nht+1(·) = ht(·)− γt(ξt(·) + νht(·)) = ∑t\ni=1 aitξi(·), ∀t > 1, and h1(·) = 0, (11)\nwhere ξt(·) = Eωt [ζt(·)]. Then for any x, the error can be decomposed as two terms |ft+1(x)− f∗(x)|2 6 2 |ft+1(x)− ht+1(x)|2︸ ︷︷ ︸\nerror due to random features\n+ 2κ ‖ht+1 − f∗‖2H︸ ︷︷ ︸ error due to random data\nFor the error term due to random features, ht+1 is constructed such that ft+1 − ht+1 is a martingale, and the stepsizes are chosen such that |ait| 6 θt , which allows us to bound the martingale. In other words, the choices of the stepsizes keep ft+1 close to the RKHS. For the error term due to random data, since ht+1 ∈ H, we can now apply the standard arguments for stochastic approximation in the RKHS. Due to the additional randomness, the recursion is slightly more complicated, et+1 6 ( 1− 2νθt ) et + β1 t √ et t + β2 t2 , where et+1 = EDt,ωt [‖ht+1 − f∗‖2H], and β1 and β2 depends on the related parameters. Solving this recursion then leads to a bound for the second error term.\nTheorem 6 (Generalization bound) Let the true risk be Rtrue(f) = E(x,y) [l(f(x), y)]. Then with probability at least 1− 3δ over (Dt,ωt), and C and Q2 defined as previously\nRtrue(ft+1)−Rtrue(f∗) 6 (C √ ln(8 √ et/δ) + √ 2κQ2 √ ln(2t/δ) ln(t))L√\nt .\nProof By the Lipschitz continuity of l(·, y) and Jensen’s Inequality, we have Rtrue(ft+1)−Rtrue(f∗) 6 LEx|ft+1(x)− f∗(x)| 6 L √ Ex|ft+1(x)− f∗(x)|2 = L‖ft+1 − f∗‖2.\nAgain, ‖ft+1 − f∗‖2 can be decomposed as two terms O ( ‖ft+1 − ht+1‖22 ) and O(‖ht+1 − f∗‖2H), which can be bounded similarly as in Theorem 5 (see Corollary 12 in the appendix).\nRemarks. The overall rate of convergence in expectation, which is O(1/t), is indeed optimal. Classical complexity theory (see, e.g. reference in [16]) shows that to obtain -accuracy solution, the number of iterations needed for the stochastic approximation is Ω(1/ ) for strongly convex case and Ω(1/ 2) for general convex case. Different from the classical setting of stochastic approximation, our case imposes not one but two\nsources of randomness/stochasticity in the gradient, which intuitively speaking, might require higher order number of iterations for general convex case. However, the variance of the random features only contributes additively to the constant in the final convergence rate. Therefore, our method is still able to achieve the same rate as in the classical setting. Notice that these bounds are achieved by adopting the classical stochastic gradient algorithm, and they may be further refined with more sophisticated techniques and analysis. For example, techniques for reducing variance of SGD proposed in [37], mini-batch and preconditioning [41, 42] can be used to reduce the constant factors in the bound significantly. Theorem 4 also reveals bounds in L∞ and L2 sense as in Appendix B. The choices of stepsizes γt and the tuning parameters given in these bounds are only for sufficient conditions and simple analysis; other choices can also lead to bounds in the same order."
    }, {
      "heading" : "6 Computation, Memory and Statistics Trade-off",
      "text" : "To investigate computation, memory and statistics trade-off, we will fix the desired L2 error in the function estimation to , i.e., ‖f − f∗‖22 6 , and work out the dependency of other quantities on . These other quantities include the preprocessing time, the number of samples and random features (or rank), the number of iterations of each algorithm, and the computational cost and memory requirement for learning and prediction. We assume that the number of samples, n, needed to achieve the prescribed error is of the order O(1/ ), the same for all methods. Furthermore, we make no other regularity assumption about margin properties or the kernel matrix such as fast spectrum decay. Thus the required number of random feature (or ranks), r, will be of the order O(n) = O(1/ ) [4, 5, 8, 9].\nWe will pick a few representative algorithms for comparison, namely, (i) NORMA [13]: kernel methods trained with stochastic functional gradients; (ii) k-SDCA [12]: kernelized version of stochastic dual coordinate ascend; (iii) r-SDCA: first approximate the kernel function with random features, and then run stochastic dual coordinate ascend; (iv) n-SDCA: first approximate the kernel matrix using Nyström’s method, and then run stochastic dual coordinate ascend; similarly we will combine Pegasos algorithm [26], stochastic block mirror descent (SBMD) [38], and random block coordinate descent (RBCD) [39] with random features and Nyström’s method, and obtain (v) r-Pegasos, (vi) n-Pegasos, (vii) r-SBMD, (viii) n-SBMD, (ix) r-RBCD, and (x) n-RBCD, respectively. The comparisons are summarized below in Table. 21\nFrom Table 2, one can see that our method, r-SDCA, r-Pegasos, r-SBMD and r-RBCD achieve the best dependency on the dimension, d, of the data up to a log factor. However, often one is interested in increasing the number of random features as more data points are observed to obtain a better generalization ability, e.g., in streaming setting. Then special procedures need to be designed for updating the r-SDCA, rPegasos, r-SBMD and r-RBCD solutions, which is not clear how to do easily and efficiently with theoretical\n1We only considered general kernel algorithms in this section. For some specific loss functions, e.g., hinge-loss, there are algorithms proposed to achieve better memory saving with extra training cost, such as support vector reduction technique [40].\nguarantees. As a more refined comparison, our algorithm is also the cheapest in terms of per training iteration computation and memory requirement. We list the computational and memory requirements at a particular iteration t < n for these five algorithms to achieve error in Table 3."
    }, {
      "heading" : "7 Experiments",
      "text" : "We show that our method compares favorably to other scalable kernel methods in medium scale datasets, and neural nets in large scale datasets. Below is a summary of the datasets used. A “yes” for the last column means that virtual examples (random cropping and mirror imaging of the original pictures) are generated for training. K-ridge stands for kernel ridge regression; GPR stands for Gaussian processes regression; K-SVM stands for kernel SVM; K-logistic stands for kernel logistic regression.\nExperiment settings. We first justify the doubly stochastic algorithm for Gaussian processes regression on dataset (1), comparing with NORMA. The dataset is medium size, so that the closed-form for posterior is tractable. For the large-scale datasets (2) — (5), we compare with the first seven algorithms for solving kernel methods discussed in Table 2. For the algorithms based on low rank kernel matrix approximation and random features, i.e., pegasos and SDCA, we set the rank r or number of random features r to be 28. We use the same batch size for both our algorithms and the competitors. We adopted two stopping criteria for different purposes. We first stopped the algorithms when they pass through the entire dataset once (SC1). This stopping criterion is designed for justifying our motivation. By investigating the performances of these algorithms with different levels of random feature approximations but the same number of training samples, we could identify that the bottleneck of the performances of the vanilla methods with explicit feature will be their approximation ability. To further demonstrate the advantages of the proposed algorithm in computational cost, we also conduct experiments on datasets (3) – (5) running the competitors within the same time budget as the proposed algorithm (SC2). We do not count the preprocessing time of Nyström’s method for n-Pegasos and n-SDCA, though it takes substantial amount of time. The algorithms are executed on the machine with AMD 16 2.4GHz Opteron CPUs and 200G memory. It should be noticed that this gives advantage to NORMA and k-SDCA which could save all the data in the memory. For fairness, we also record\nThree models to compare\nr l t r\nThree models to compare\nas many random features as the memory allowed. For datasets (6) — (8), we compare with neural nets for images (“jointly-trained”). In order to directly compare the performance of nonlinear classifiers rather than feature learning abilities, we also use the convolution layers of a trained neural net to extract features, then apply our algorithm and a nonlinear neural net on top to learn classifiers (“fixed”). The structures of these neural nets in Figure 3. For datasets (9) and (10), we compare with the neural net described in [30] and use exactly the same input. In all the experiments, we select the batch size so that for each update, the computation resources can be utilized efficiently."
    }, {
      "heading" : "7.1 Kernel Ridge Regression",
      "text" : "In this section, we compare our approach with alternative algorithms for kernel ridge regression on 2D synthetic dataset. The data are generated by\ny = cos(0.5π‖x‖2) exp(−0.1π‖x‖2) + 0.1e where x ∈ [−5, 5]2 and e ∼ N (0, 1). We use Gaussian RBF kernel with kernel bandwidth σ chosen to be 0.1 times the median of pairwise distances between data points (median trick). The regularization parameter ν is set to be 10−6. The batch size and feature block are set to be 210.\nThe results are shown in Figure 4. In Figure 4(1), we plot the optimal functions generating the data. We justify our proof of the convergence rate in Figure 4(2). The blue dotted line is a convergence rate of 1/t as a guide. f̂t denotes the average solution after t-iteration, i.e., f̂t(x) = 1 t ∑t i=1 fi(x). It could be seen that our algorithm indeed converges in the rate of O(1/t). In Figure 4 (3), we compare the first seven algorithms listed in the Table 2 for solving the kernel ridge regression.\nThe comparison on synthetic dataset demonstrates the advantages of our algorithm clearly. Our algorithm achieves comparable performance with NORMA, which uses full kernel, in similar time but less memory cost. The pegasos and SDCA using 28 random or Nyström features perform worse."
    }, {
      "heading" : "7.2 Gaussian Processes Regression",
      "text" : "As we introduced in Section. (4), the mean and variance of posterior of Gaussian processes for regression problem can be formulated as solutions to some convex optimization problems. We conduct experiments on synthetic dataset for justification. Since the task is computing the posterior, we evaluate the performances by comparing the solutions to the posterior mean and variance, denoted as fgp and σ 2 gp, obtained by closedform (9). We select 211 data from the same model in previous section for training and 210 data for testing, so that the closed-form of posterior is tractable. We use Gaussian RBF kernel with kernel bandwidth σ chosen by median trick. The noise level σ2 is set to be 0.1. The batch size is set to be 64 and feature block is set to be 512.\nWe compared the doubly stochastic algorithm with NORMA. The results are shown in Figure 5. Both the doubly stochastic algorithm and NORMA converge to the posterior, and our algorithm achieves comparable performance with NORMA in approximating both the mean and variance."
    }, {
      "heading" : "7.3 Kernel Support Vector Machine",
      "text" : "We evaluate our algorithm solving kernel SVM on three datasets (3)–(5) comparing with other several algorithms listed in Table 2 using stopping criteria SC1 and SC2.\nAdult. We use Gaussian RBF kernel with kernel bandwidth obtained by median trick. The regularization parameter ν is set to be 1/(100n) where n is the number of training samples. We set the batch size to be 26 and feature block to be 25. After going through the whole dataset one pass, the best error rate is achieved by NORMA and k-SDCA which is 15% while our algorithm achieves comparable result 15.3%. The performances are illustrated in Figure 6(1). Under the same time budget, all the algorithms perform similarly in Figure 6(4). The reason of flat region of r-pegasos, NORMA and the proposed method on this dataset is that Adult dataset is unbalanced. There are about 24% positive samples while 76% negative samples.\nMNIST 8M 8 vs. 6. We first reduce the dimension to 50 by PCA and use Gaussian RBF kernel with kernel bandwidth σ = 9.03 obtained by median trick. The regularization parameter ν is set to be 1/n where n is the number of training samples. We set the batch size to be 210 and feature block to be 28. The results are shown in Figure 6(2) and (5) under SC1 and SC2 respectively. Under both these two stopping criteria, our algorithm achieves the best test error 0.26% using similar training time.\nForest. We use Gaussian RBF kernel with kernel bandwidth obtained by median trick. The regularization parameter ν is set to be 1/n where n is the number of training samples. We set the batch size to be 210 and feature block to be 28. In Figure 6(3), we shows the performances of all algorithms using SC1. NORMA and k-SDCA achieve the best error rate, which is 10%, while our algorithm achieves around 15%, but still much better than the pegasos and SDCA with 28 features. In the same time budget, the proposed algorithm performs better than all the alternatives except NORMA in Figure 6(6).\nAs seen from the performance of pegasos and SDCA on Adult and MNIST, using fewer features does not deteriorate the classification error. This might be because there are cluster structures in these two binary classification datasets. Thus, they prefer low rank approximation rather than full kernel. Different from\nthese two datasets, in the forest dataset, algorithms with full kernel, i.e., NORMA and k-SDCA, achieve best performance. With more random features, our algorithm performs much better than pegasos and SDCA under both SC1 and SC2. Our algorithm is preferable for this scenario, i.e., huge dataset with sophisticated decision boundary. Although utilizing full kernel could achieve better performance, the computation and memory requirement for the kernel on huge dataset are costly. To learn the sophisticated boundary while still considering the computational and memory cost, we need to efficiently approximate the kernel in O( 1 ) with O(n) random features at least. Our algorithm could handle so many random features efficiently in both computation and memory cost, while for pegasos and SDCA such operation is prohibitive."
    }, {
      "heading" : "7.4 Classification Comparisons to Convolution Neural Networks",
      "text" : "We also compare our algorithm with the state-of-the-art neural network. In these experiments, the block size is set to be O(104). Compared to the number of samples, O(108), this block size is reasonable.\nMNIST 8M. In this experiment, we compare to a variant of LeNet-5 [32], where all tanh units are replaced with rectified linear units. We also use more convolution filters and a larger fully connected layer. Specifically, the first two convolutions layers have 16 and 32 filters, respectively, and the fully connected layer contains 128 neurons. We use kernel logistic regression for the task. We extract features from the last max-pooling layer with dimension 1568, and use Gaussian RBF kernel with kernel bandwidth σ equaling to four times the median pairwise distance. The regularization parameter ν is set to be 0.0005.\nThe result is shown in Figure 7(1). As expected, the neural net with pre-learned features is faster to train than the jointly-trained one. However, our method is much faster compared to both methods. In addition, it achieves a lower error rate (0.5%) compared to the 0.6% error provided by the neural nets.\nMolecular property prediction From molecular structure to molecular property\n33\nCIFAR 10. In this experiment, we compare to a neural net with two convolution layers (after contrast normalization and max-pooling layers) and two local layers that achieves 11% test error2 on CIFAR 10 [28]. The features are extracted from the top max-pooling layer from a trained neural net with 2304 dimension. We use kernel logistic regression for this problem. The kernel bandwidth σ for Gaussian RBF kernel is again four times the median pairwise distance. The regularization parameter ν is set to be 0.0005. We also perform a PCA (without centering) to reduce the dimension to 256 before feeding to our method.\nThe result is shown in Figure 7(2). The test error for our method drops significantly faster in the earlier phase, then gradually converges to that achieved by the neural nets. Our method is able to produce the same performance within a much restricted time budget.\nImageNet. In this experiment, we compare our algorithm with the neural nets on the ImageNet 2012 dataset, which contains 1.3 million color images from 1000 classes. Each image is of size 256 × 256, and we randomly crop a 240 × 240 region with random horizontal flipping. The jointly-trained neural net is Alex-net [29]. The 9216 dimension features for our classifier and fixed neural net are from the last pooling layer of the jointly-trained neural net. The kernel bandwidth σ for Gaussian RBF kernel is again four times the median pairwise distance. The regularization parameter ν is set to be 0.0005.\nTest error comparisons are shown in Figure 7(3). Our method achieves a test error of 44.5% by further max-voting of 10 transformations of the test set while the jointly-trained neural net arrives at 42% (without variations in color and illumination). At the same time, fixed neural net can only produce an error rate of 46% with max-voting. There may be some advantages to train the network jointly such that the layers work together to achieve a better performance. Although there is still a gap to the best performance by the jointly-trained neural net, our method comes very close with much faster convergence rate. Moreover, it achieves superior performance than the neural net with pre-learned features, both in accuracy and speed."
    }, {
      "heading" : "7.5 Regression Comparisons to Neural Networks",
      "text" : "We test our algorithm for kernel ridge regression with neural network proposed in [30] on two large-scale real-world regression datasets, (9) and (10) in Table 4. To our best knowledge, this is the first comparison between kernel ridge regression and neural network on the dataset MolecularSpace.\n2The specification is at https://code.google.com/p/cuda-convnet/\nQuantumMachine. In this experiment, we use the same binary representations converted based on random Coulomb matrices as in [30]. We first generate a set of randomly sorted coulomb matrices for each molecule. And then, we break each dimension of the Coulomb matrix apart into steps and convert them to the binary predicates. Predictions are made by taking average of all prediction made on various Coulomb matrices of the same molecule. The procedure is illustrated in Figure. 8. For this experiment, 40 sets of randomly permuted matrices are generated for each training example and 20 for each test example. We use Gaussian kernel with kernel bandwidth σ = 60 obtained by median trick. The batch size is set to be 50000 and the feature block is 211. The total dimension of random features is 220.\nThe results are shown in Figure 7(4). In QuantumMachine dataset, our method achieves Mean Absolute Error (MAE) of 2.97 kcal/mole, outperforming neural nets results, 3.51 kcal/mole. Note that this result is already close to the 1 kcal/mole required for chemical accuracy.\nMolecularSpace. In this experiment, the task is to predict the power conversion efficiency (PCE) of the molecule. This dataset of 2.3 million molecular motifs is obtained from the Clean Energy Project Database. We use the same feature representation as for “QuantumMachine” dataset [30]. We set the kernel bandwidth of Gaussian RBF kernel to be 290 by median trick. The batch size is set to be 25000 and the feature block is 211. The total dimension of random features is 220.\nThe results are shown in Figure 7(5). It can be seen that our method is comparable with neural network on this 2.3 million dataset."
    }, {
      "heading" : "8 Discussion",
      "text" : "Our work contributes towards making kernel methods scalable for large-scale datasets. Specifically, by introducing artificial randomness associated with kernels besides the random data samples, we propose doubly stochastic functional gradient for kernel machines which makes the kernel machines efficient in both computation and memory requirement. Our algorithm successfully reduces the memory requirement of kernel machines from O(dn) to O(n). Meanwhile, we also show that our algorithm achieves the optimal rate of convergence, O(1/t), for strongly convex stochastic optimization. We compare our algorithm on both classification and regression problems with the state-of-the-art neural networks as well as some other competing algorithms for kernel methods on several large-scale datasets. With our efficient algorithm, kernel methods could perform comparable to sophisticated-designed neural network empirically.\nThe theoretical analysis, which provides the rate of convergence independent to the dimension, is also highly non-trivial. It twists martingale techniques and the vanilla analysis for stochastic gradient descent and provides a new perspective for analyzing optimization in infinite-dimensional spaces, which could be of independent interest. It should be pointed out that although we applied the algorithm to many kernel machines even with non-smooth loss functions, our current proof relies on the Lipschitz smoothness of the loss function. Extending the guarantee to non-smooth loss function will be one interesting future work.\nAnother key property of our method is its simplicity and ease of implementation which makes it versatile and easy to be extened in various aspects. It is straightforward to replace the sampling strategy for random features with Fastfood [7] which enjoys the efficient computational cost, or Quasi-Monte Carlo sampling [43], data-dependent sampling [47] which enjoys faster convergence rate with fewer generated features. Meanwhile, by back-propogation trick, we could refine the random features by adapting their weights for better performance [36]."
    }, {
      "heading" : "Acknowledgement",
      "text" : "M.B. is supported in part by NSF grant CCF-1101283, AFOSR grant FA9550-09-1-0538, a Microsoft Faculty Fellowship, and a Raytheon Faculty Fellowship. L.S. is supported in part by NSF IIS-1116886, NSF/NIH BIGDATA 1R01GM108341, NSF CAREER IIS-1350983, and a Raytheon Faculty Fellowship."
    }, {
      "heading" : "A Convergence Rate",
      "text" : "We first provide specific bounds and detailed proofs for the two error terms appeared in Theorem 4 and Theorem 5.\nA.1 Error due to random features\nLemma 7 We have (i) For any x ∈ X , EDt,ωt [|ft+1(x)− ht+1(x)|2] 6 B21,t+1 := 4M2(κ+ φ)2 ∑t i=1 |ait|2.\n(ii) For any x ∈ X , with probability at least 1− δ over (Dt,ωt), |ft+1(x)− ht+1(x)|2 6 B22,t+1 := 2M2(κ+ φ)2 ln ( 2\nδ ) t∑ i=1 |ait|2\nProof Let Vi(x) = Vi(x;Di,ωi) := ait (ζi(x)− ξi(x)). Since Vi(x) is a function of (Di,ωi) and EDi,ωi [ Vi(x)|ωi−1 ] = aitEDi,ωi [ ζi(x)− ξi(x)|ωi−1 ] = aitEDi,ωi−1 [ Eωi [ ζi(x)− ξi(x)|ωi−1 ]] = 0, we have that {Vi(x)} is a martingal difference sequence. Further note that |Vi(x)| 6 ci = 2M(φ+ κ)|ait|.\nThen by Azuma’s Inequality, for any > 0,\nPr Dt,ωt { | t∑ i=1 Vi(x)| > } 6 2 exp { − 2 2∑t i=1 c 2 i } which is equivalent as\nPr Dt,ωt  ( t∑ i=1 Vi(x) )2 > ln(2/δ) t∑ i=1 c2i /2  6 δ. Moreover,\nEDt,ωt ( t∑ i=1 Vi(x) )2 = ∫ ∞ 0 Pr Dt,ωt  ( t∑ i=1 Vi(x) )2 >  d = ∫ ∞ 0 2 exp { − 2 ∑t i=1 c 2 i } d = t∑ i=1 c2i\nSince ft+1(x)− ht+1(x) = ∑t i=1 Vi(x), we immediately obtain the two parts of the lemma.\nLemma 8 Suppose γi = θ i (1 6 i 6 t) and θν ∈ (1, 2) ∪ Z+. Then we have\n(1) |ait| 6 θt . Consequently, ∑t i=1(a i t) 2 6 θ 2 t . (2) ∑t i=1 γi|ait| 6 { θ2(ln(t)+1) t , if θν ∈ [1, 2), θ2\nt , if θν ∈ [2,+∞) ∩ Z+ .\nProof (1) follows by induction on i. |att| 6 θt is trivially true. We have\n|ait| = |ai+1t γi γi+1 (1− νγi+1)| = i+ 1 i |1− νθ i+ 1 | · |ai+1t | = | i+ 1− νθ i | · |ai+1t |.\nWhen νθ ∈ (1, 2), i − 1 < i + 1 − νθ < i for any i > 1, so |ait| < |ai+1t | 6 θt . When νθ ∈ Z+, if i > νθ − 1, then |ait| < |ai+1t | 6 θt ; if i 6 νθ − 1, then |a i t| = 0. For (2), when θν ∈ [1, 2),\nt∑ i=1 γt|ait| = t∑ i=1 θ2 i2 · i+ 1− θν i+ 1 · · · t− θν t 6 t∑ i=1 θ2 i2 · i i+ 1 · · · t− 1 t 6 t∑ i=1 θ2 it 6 θ2(ln(t) + 1) t .\nWhen θν ∈ Z+ and 2 6 θν 6 t, t∑ i=1 γt|ait| = t∑ i=2 θ2 i2 · i+ 1− θν i+ 1 · · · t− θν t 6 t∑ i=1 θ2 i2 · i− 1 i+ 1 · · · t− 2 t 6 t∑ i=2 θ2(i− 1) it(t− 1) 6 θ2 t .\nA.2 Error due to random data\nLemma 9 Assume l′(u, y) is L-Lipschitz continous in terms of u ∈ R. Let f∗ be the optimal solution to our target problem. Then\n(i) If we set γt = θ t with θ such that θν ∈ (1, 2) ∪ Z+, then EDt,ωt [ ‖ht+1 − f∗‖2H ] 6 Q21 t ,\nwhere\nQ1 = max { ‖f∗‖H , Q0 + √ Q20 + (2θν − 1)(1 + θν)2θ2κM2\n2νθ − 1\n} , Q0 = 2 √ 2κ1/2(κ+ φ)LMθ2.\nParticularly, if θν = 1, we have Q1 6 max { ‖f∗‖H , 4 √ 2((κ+ φ)L+ ν) · κ 1/2M ν2 } .\n(ii) If we set γt = θ t with θ such that θν ∈ Z+ and t > θν, then with probability at least 1−2δ over (D t,ωt),\n‖ht+1 − f∗‖2H 6 Q 2 2\nln(2t/δ) ln(t)\nt .\nwhere\nQ2 = max { ‖f∗‖H , Q0 + √ Q20 + κM 2(1 + θν)2(θ2 + 16θ/ν) } , Q0 = 4 √ 2κ1/2Mθ(8 + (κ+ φ)θL).\nParticularly, if θν = 1, we have Q2 6 max { ‖f∗‖H , 8 √ 2((κ+ φ)L+ 9ν) · κ 1/2M ν2 } .\nProof For the sake of simple notations, let us first denote the following three different gradient terms, which are\ngt = ξt + νht = l ′(ft(xt), yt)k(xt, ·) + νht, ĝt = ξ̂t + νht = l ′(ht(xt), yt)k(xt, ·) + νht,\nḡt = EDt [ĝt] = EDt [l′(ht(xt), yt)k(xt, ·)] + νht. Note that by our previous definition, we have ht+1 = ht − γtgt,∀t > 1.\nDenote At = ‖ht − f∗‖2H. Then we have At+1 = ‖ht − f∗ − γtgt‖2H\n= At + γ 2 t ‖gt‖ 2 H − 2γt〈ht − f∗, gt〉H = At + γ 2 t ‖gt‖ 2 H − 2γt〈ht − f∗, ḡt〉H + 2γt〈ht − f∗, ḡt − ĝt〉H + 2γt〈ht − f∗, ĝt − gt〉H\nBecause of the strongly convexity of (1) and optimality condition, we have\n〈ht − f∗, ḡt〉H > ν ‖ht − f∗‖2H\nHence, we have\nAt+1 6 (1− 2γtν)At + γ2t ‖gt‖ 2 H + 2γt〈ht − f∗, ḡt − ĝt〉H + 2γt〈ht − f∗, ĝt − gt〉H,∀t > 1 (12)\nProof for (i): Let us denote Mt = ‖gt‖2H, Nt = 〈ht − f∗, ḡt − ĝt〉H, Rt = 〈ht − f∗, ĝt − gt〉H. We first show that Mt,Nt,Rt are bounded. Specifically, we have for t > 1,\n(1) Mt 6 κM2(1 + νct)2, where ct = √∑t−1 i,j=1 |ait−1| · |a j t−1| for t > 2 and c1 = 0;\n(2) EDt,ωt [Nt] = 0; (3) EDt,ωt [Rt] 6 κ1/2LB1,t √ EDt−1,ωt−1 [At], where B21,t := 4M2(κ+φ)2 ∑t−1 i=1 |ait−1|2 for t > 2 and B1,1 =\n0;\nWe prove these results separately in Lemma 10 below. Let us denote et = EDt−1,ωt−1 [At], given the above bounds, we arrive at the following recursion,\net+1 6 (1− 2γtν)et + κM2γ2t (1 + νct)2 + 2κ1/2LγtB1,t √ et. (13)\nWhen γt = θ/t with θ such that θν ∈ (1, 2) ∪ Z+, from Lemma 8, we have |ait| 6 θt ,∀1 6 i 6 t. Consequently, ct 6 θ and B21,t 6 4M 2(κ + φ) θ 2\nt−1 . Applying these bounds leads to the refined recursion as follows\net+1 6\n( 1− 2νθ\nt\n) et + κM 2 θ 2\nt2 (1 + νθ)2 + 2κ1/2L\nθ\nt\n√ 4M2(κ+ φ)2 θ2\nt− 1 √ et\nthat can be further written as\net+1 6\n( 1− 2νθ\nt\n) et +\nβ1 t √ et t + β2 t2 ,\nwhere β1 = 4 √ 2κ1/2LM(k + φ)θ2 and β2 = κM 2(1 + νθ)2θ2. Invoking Lemma 14 with η = 2θν > 1, we obtain\net 6 Q21 t ,\nwhere Q1 = max { ‖f∗‖H , Q0+ √ Q20+(2θν−1)(1+θν)2θ2κM2 2νθ−1 } , and Q0 = 2 √ 2κ1/2(κ+ φ)LMθ2.\nProof for (ii): Cumulating equations (12) with i = 1, . . . t, we end up with the following inequality At+1 6 ∏t i=1(1− 2γiν)A1 + 2 ∑t i=1 γi ∏t j=i+1(1− 2νγj)〈hi − f∗, ḡi − ĝi〉H\n+2 ∑t i=1 γi ∏t j=i+1(1− 2νγj)〈hi − f∗, ĝi − gi〉H + ∑t i=1 γ 2 i ∏t j=i+1(1− 2νγj) ‖gi‖ 2 H\n(14)\nLet us denote bit = γi ∏t j=i+1(1− 2νγj), 1 6 i 6 t, the above inequality is equivalent as\nAt+1 6 t∏ i=1 (1− 2γiν)A1 + t∑ i=1 γib i tMi + 2 t∑ i=1 bitNi + 2 t∑ i=1 bitRi\nWe first show that\n(4) for any 0 < δ < 1/e and t > 4, with probability 1− δ over (Dt,ωt),∑t i=1 b i tNi 6 2 max { 4κ1/2M √∑t i=1(b i t) 2Ai, maxi |bit| · C0 √ ln(ln(t)/δ) }√ ln(ln(t)/δ),\nwhere C0 = 4 max16i6tMi\nν .\n(5) for any δ > 0, with probability 1− δ over (Dt,ωt),∑t i=1 b i tRi 6 ∑t i=1 b i tκ 1/2LB̂2,i √ Ai,\nwhere B̂22,i = 2M 2(κ+ φ)2 ln ( 2t δ )∑i−1 j=1 |a j i−1|2.\nAgain, the proofs of these results are given separately in Lemma 10. Applying the above bounds leads to the refined recursion as follows,\nAt+1 6 t∏ i=1 (1− 2γiν)A1 + t∑ i=1 γib i tMi + 2 t∑ i=1 bitκ 1/2LB2,i √ Ai\n+4 max 4κ1/2M √√√√ t∑\ni=1\n(bit) 2Ai, max i |bit| · C0\n√ ln(ln(t)/δ) √ln(ln(t)/δ) with probability 1−2δ. When γt = θ/t with θ such that θν ∈ Z+, with similar reasons in Lemma 8, we have |bit| 6 θt , 1 6 i 6 t and also we have ∏t i=1(1− 2γiν) = ∏θν−1 i=1 (1− 2 θν i ) ∏t i=θν+1(1− 2 θν i )(1− 2\nθν θν ) = 0, and∑t\ni=1 γib i t 6\nθ2\nt . Therefore, we can rewrite the above recursion as\nAt+1 6 β1 t\n+ β2 √ ln(2t/δ) · t∑ i=1 √ Ai t √ i + β3 √ ln(ln(t)/δ)\n√∑t i=1Ai\nt + β4 ln(ln(t/δ))\n1 t (15)\nwhere β1 = κM 2(1+νθ)2θ2, β2 = 2 √ 2κ1/2LM(κ+φ)θ2, β3 = 16κ 1/2Mθ, β4 = 16κM 2(1+θν)2θ/ν. Invoking Lemma 15, we obtain\nAt+1 6 Q22 ln(2t/δ) ln 2(t)\nt ,\nwith the specified Q2.\nLemma 10 In this lemma, we prove the inequalities (1)–(5) in Lemma 9.\nProof Given the definitions of Mt,Nt,Rt in Lemma 9, we have (1) Mt 6 κM2(1 + ν √∑t−1 i,j=1 |ait−1| · |a j t−1|)2;\nThis is because Mt = ‖gt‖2H = ‖ξt + νht‖2H 6 (‖ξt‖H + ν‖ht‖H)2. We have ‖ξt‖H = ‖l′(ft(xt), yt)k(xt, ·)‖H 6 κ1/2M, and\n‖ht‖2H = t−1∑ i=1 t−1∑ j=1 ait−1a j t−1l ′(fi(xi), yi)l ′(fj(xj), yj)k(xi, xj)\n6 κM2 t−1∑ i=1 t−1∑ j=1 |ait−1| · |a j t−1|.\n(2) EDt,ωt [Nt] = 0; This is because Nt = 〈ht − f∗, ḡt − ĝt〉H,\nEDt,ωt [Nt] = EDt−1,ωt [ EDt [ 〈ht − f∗, ḡt − ĝt〉H|Dt−1,ωt ]] = EDt−1,ωt [〈ht − f∗,EDt [ḡt − ĝt]〉H] = 0.\n(3) EDt,ωt [Rt] 6 κ1/2LB1,t √ EDt−1,ωt−1 [At], where B21,t := 4M2(κ+ φ)2 ∑t−1 i=1 |ait−1|2;\nThis is because Rt = 〈ht − f∗, ĝt − gt〉H, EDt,ωt [Rt] = EDt,ωt [〈ht − f∗, ĝt − gt〉H]\n= EDt,ωt [〈ht − f∗, [l′(ft(xt), yt)− l′(ht(xt), yt)]k(xt, ·)〉H] 6 EDt,ωt [|l′(ft(xt), yt)− l′(ht(xt), yt)| · ‖k(xt, ·)‖H · ‖ht − f∗‖H] 6 κ1/2L · EDt,ωt [|ft(xt)− ht(xt)| ‖ht − f∗‖H]\n6 κ1/2L √ EDt,ωt |ft(xt)− ht(xt)|2 √ EDt,ωt ‖ht − f∗‖2H\n6 κ1/2LB1,t √ EDt−1,ωt−1 [At]\nwhere the first and third inequalities are due to Cauchy–Schwarz Inequality and the second inequality is due to L-Lipschitz continuity of l′(·, ·) in the first parameter, and the last step is due to Lemma 7 and the definition of At.\n(4) for any 0 < δ < 1/e and t > 4, with probability at least 1− δ over (Dt,ωt),∑t i=1 b i tNi 6 2 max { 4κ1/2M √∑t i=1(b i t) 2Ai, maxi |bit| · C0 √ ln(ln(t)/δ) }√ ln(ln(t)/δ),\nwhere C0 = 4 max16i6tMi\nν . This result follows directly from Lemma 3 in [31]. Let us define di = di(Di,ωi) := bitNi = bit〈hi − f∗, ḡi − ĝi〉H, 1 6 i 6 t, we have\n• {di}ti=1 is martingale difference sequence since EDi,ωi [ Ni|Di−1,ωi−1 ] = 0. • |di| 6 maxi |bit| · C0, with C0 = 4 max16i6tMi\nν , ∀1 6 i 6 t. • V ar(di|Di−1,ωi−1) 6 4κM2|bit|2Ai,∀1 6 i 6 t.\nPlugging in these specific bounds in Lemma 3 in [Alexander et.al., 2012], which is, Pr (∑t i=1 dt > 2 max{2σt, dmax √ ln(1/δ)} √ ln(1/δ) ) 6 ln(t)δ.\nwhere σ2t = ∑t i=1 V ari−1(di) and dmax = max16i6t |di|, we immediately obtain the above inequality as desired.\n(5) for any δ > 0, with probability at least 1− δ over (Dt,ωt),∑t i=1 b i tRi 6 ∑t i=1 |bit|κ1/2LB̂2,i √ Ai,\nwhere B̂22,i = 2M 2(κ+ φ)2 ln ( 2t δ )∑i−1 j=1 |a j i−1|2.\nThis is because, for any 1 6 i 6 t, recall that from analysis in (3), we have Ri 6 κ1/2L|ft(xt)−ht(xt)| · ‖ht − f∗‖H, therefore from Lemma 9,\nPr(bitRi 6 κ1/2L|bit|B̂2,i √ Ai) > Pr(|fi(xi)− hi(xi)|2 6 B̂22,i) > 1− δ/t.\nTaking the sum over i, we therefore get Pr( ∑t i=1 b i tRi 6 ∑t i=1 |bit|κ1/2LB2,i √ Ai) > 1− δ.\nApplying these lemmas immediately gives us Theorem 4 and Theorem 5, which implies pointwise distance between the solution ft+1(·) and f∗(·). Now we prove similar bounds in the sense of L∞ and L2 distance."
    }, {
      "heading" : "B L∞ distance, L2 distance, and generalization bound",
      "text" : "Corollary 11 (L∞ distance) Theorem 4 also implies a bound in L∞ sense, namely,\nEDt,ωt ‖ft+1 − f∗‖2∞ 6 2C2 + 2κQ21\nt . Consequently, for the average solution f̂t+1(·) := 1t ∑t i=1 fi(·), we also have\nEDt,ωt‖f̂t+1 − f∗‖2∞ 6 (2C2 + 2κQ21)(ln(t) + 1)\nt .\nThis is because ‖ft+1 − f∗‖∞ = maxx∈X |ft+1(x)− f∗(x)| = |ft+1(x∗)− f∗(x∗)|, where x∗ ∈ X always exists since X is closed and bounded. Note that the result for average solution can be improved without log factor using more sophisticated analysis (see also reference in [31]).\nCorollary 12 (L2 distance) With the choices of γt in Lemma 9, we have\n(i) EDt,ωt‖ft+1 − f∗‖22 6 2C2+2κQ21 t ,\n(ii) ‖ft+1 − f∗‖22 6 C2 ln(8\n√ et/δ)+2κQ22 ln(2t/δ) ln\n2(t) t , with probability at least 1− 3δ over (D t,ωt).\nProof (i) follows directly from Theorem 4. (ii) can be proved as follows. First, we have ‖ft+1 − f∗‖22 = Ex|ft+1(x)− f∗(x)|2 6 2Ex|ft+1(x)− ht+1(x)|2 + 2κ‖ht+1 − f∗‖H. From Lemma 9, with probability at least 1− 2δ, we have\n‖ht+1 − f∗‖2H 6 Q22 ln(2t/δ) ln 2(t)\nt . (16)\nFrom Lemma 7, for any x ∈ X , we have\nPr Dt,ωt\n{ |ft+1(x)− ht+1(x)|2 > 2(κ+ φ)2M2 ln( 2 )θ 2\nt\n} 6 .\nSince C2 = 4(κ+ φ)2M2θ2, the above inequality can be writen as\nPr Dt,ωt\n{ |ft+1(x)− ht+1(x)|2 > C2 ln( 2 )\n2t\n} 6 .\nwhich leads to\nPr x∼P(x) Pr Dt,ωt\n{ |ft+1(x)− ht+1(x)|2 > C2 ln( 2 )\n2t\n} 6 .\nBy Fubini’s theorem and Markov’s inequality, we have\nPr Dt,ωt\n{ Pr\nx∼P(x)\n{ |ft+1(x)− ht+1(x)|2 > C2 ln( 2 )\n2t\n} >\nδ\n} 6 δ.\nFrom the analysis in Lemma 7, we also have that |ft+1(x) − ht+1(x)| 6 C2. Therefore, with probability at least 1− δ over (Dt,ωt), we have\nEx∼P(x)[|ft+1(x)− ht+1(x)|2] 6 C2 ln( 2 )\n2t (1− δ ) + C2 δ\nLet = δ4t , we have\nEx∼P(x)[|ft+1(x)− ht+1(x)|2] 6 C2\n2t (ln(8t/δ) +\n1 2 ) =\nC2 ln(8 √ et/δ)\n2t . (17)\nSumming up equation (17) and (16), we have\n‖ft+1 − f∗‖22 6 C2 ln(8\n√ et/δ) + 2κQ22 ln(2t/δ) ln 2(t)\nt as desired.\nFrom the bound on L2 distance, we can immediately get the generalization bound. Theorem 6 (Generalization bound) Let the true risk be Rtrue(f) = E(x,y) [l(f(x), y)]. Then with probability at least 1− 3δ over (Dt,ωt), and C and Q2 defined as previously\nRtrue(ft+1)−Rtrue(f∗) 6 (C √ ln(8 √ et/δ) + √ 2κQ2 √ ln(2t/δ) ln(t))L√\nt .\nProof By the Lipschitz continuity of l(·, y) and Jensen’s Inequality, we have Rtrue(ft+1)−Rtrue(f∗) 6 LEx|ft+1(x)− f∗(x)| 6 L √ Ex|ft+1(x)− f∗(x)|2 = L‖ft+1 − f∗‖2.\nThen the theorem follows from Corollary 12."
    }, {
      "heading" : "C Suboptimality",
      "text" : "For comprehensive purposes, we also provide the O(1/t) bound for suboptimality.\nCorollary 13 If we set γt = θ t with θν = 1, then the average solution f̂t+1 := 1 t ∑t i=1 fi satisfies\nR(EDt,ωt [f̂t+1])−R(f∗) 6 Q(ln(t) + 1)\nt .\nwhere Q = (4κM2 + 2 √ 2κ1/2LM(κ+ φ)Q1)/ν, with Q1 defined as in Lemma 9.\nProof From the anallysis in Lemma 9,we have\n〈ht − f∗, ḡt〉H = 1\n2γt At −\n1\n2γt At+1 + γtMt +Nt +Rt\nInvoking strongly convexity of R(f), we have 〈ht−f∗, ḡt〉 > R(ht)−R(f∗)+ ν2‖ht−f∗‖ 2 H. Taking expectaion on both size and use the bounds in last lemma, we have\nEDt,ωt [R(ht)−R(f∗)] 6 ( 1 2γt − ν 2 )et − 1 2γt et+1 + γtκM 2(1 + νct) 2 + κ1/2LB1,t √ et\nAssume γt = θ t with θ = 1 ν , then cumulating the above inequalities leads to\nt∑ i=1 EDt,ωt [R(hi)−R(f∗)] 6 t∑ i=1 γiκM 2(1 + νci) 2 + t∑ i=1 κ1/2LB1,i √ ei\nwhich can be further bounded by t∑ i=1 EDt,ωt [R(hi)−R(f∗)] 6 t∑ i=1 γiκM 2(1 + νci) 2 + t∑ i=1 κ1/2LB1,i √ ei\n6 4κM2\nν t∑ i=1 1 i + 2 √ 2κ1/2LM(κ+ φ) ν t∑ i=1 √ ei i\n6 4κM2\nν (ln(t) + 1) +\n2 √ 2κ1/2LM(κ+ φ)\nν Q1(ln(t) + 1)\n= Q(ln(t) + 1)\nt\nBy convexity, we have EDt,ωt [R(ĥt+1) − R(f∗)] 6 Q(ln(t)+1)t . The corollary then follows from the fact that EDt,ωt [f̂t+1] = EDt,ωt [ĥt+1] and R(EDt,ωt [ĥt+1]) 6 EDt,ωt [R(ĥt+1)].\nC.1 Technical lemma for recursion bounds\nLemma 14 Suppose the sequence {Γt}∞t=1 satisfies Γ1 > 0, and ∀t > 1 Γt+1 6 (\n1− η t\n) Γt + β1\nt √ t\n√ Γt +\nβ2 t2 ,\nwhere η > 1, β1, β2 > 0. Then ∀t > 1,\nΓt 6 R\nt , where R = max\n{ Γ1, R 2 0 } , R0 = β1 + √ β21 + 4(η − 1)β2 2(η − 1) .\nProof The proof follows by induction. When t = 1, it always holds true by the definition of R. Assume the conclusion holds true for t with t > 1, i.e., Γt 6 Rt , then we have\nΓt+1 6 (\n1− η t\n) Γt + β1\nt √ t\n√ Γt +\nβ2 t2\n= R t − ηR− β1\n√ R− β2\nt2 6\nR\nt+ 1 +\nR t(t+ 1) − ηR− β1\n√ R− β2\nt2\n6 R t+ 1 − 1 t2\n[ −R+ ηR− β1 √ R− β2 ] 6 R\nt+ 1 where the last step can be verified as follows.\n(η − 1)R− β1 √ R− β2 = (η − 1) [√ R− β1\n2(η − 1)\n]2 − β 2 1\n4(η − 1) − β2\n> (η − 1) [ R0 −\nβ1 2(η − 1)\n]2 − β 2 1\n4(η − 1) − β2 > 0\nwhere the last step follows from the defintion of R0.\nLemma 15 Suppose the sequence {Γt}∞t=1 satisfies\nΓt+1 6 β1 t\n+ β2 √ ln(2t/δ) · t∑ i=1 √ Γi t √ i + β3 √ ln(ln(t)/δ)\n√∑t i=1 Γi\nt + β4 ln(ln(t/δ))\n1\nt\nwhere β1, β2, β3, β4 > 0 and δ ∈ (0, 1/e). Then ∀1 6 j 6 t(t > 4),\nΓj 6 R ln(2t/δ) ln2(t)\nj , where R = max{Γ1, R20}, R0 = 2β2 + 2\n√ 2β3 + √ (2β2 + 2 √ 2β3)2 + β1 + β4.\nProof The proof follows by induction. When j = 1 it is trivial. Let us assume it holds true for 1 6 j 6 t−1, therefore,\nΓj+1 6 β1 j\n+ β2 √ ln(2j/δ) · j∑ i=1 √ Γi j √ i + β3 √ ln(ln(j)/δ)\n√∑j i=1 Γi\nj + β4 ln(ln(j/δ))\n1\nj\n6 β1 j\n+ β2 √ ln(2j/δ)/j · j∑ i=1\n√ R ln(2t/δ) ln2(t)\ni\n+β3 √ ln(ln(j)/δ)\n√∑j i=1R ln(2t/δ) ln 2(t)/i\nj + β4 ln(ln(j/δ))\n1\nj\n6 β1 j\n+ β2 √ ln(2j/δ)/j √ R ln(2t/δ) ln2(t)(1 + ln(j))\n+β3 √ ln(ln(j)/δ)/j √ R ln(2t/δ) ln2(t) √ ln(j) + 1 + β4 ln(ln(j/δ)) 1\nj\n6 β1 j\n+ 2β2 √ R ln(2t/δ) ln2(t)/j + √ 2β3 √ R ln(2t/δ) ln2(t)/j + β4 ln(2t/δ) 1\nj\n6 (2β2 + √ 2β3) √ R ln(2t/δ) ln2(t)\nj + (β1 + β4 ln(2t/δ))\n1\nj\n6 ln(2t/δ) ln2(t)\nj [(2β2 +\n√ 2β3) √ R+\nβ1 2 + β4 2 )\nSince √ R > 2β2 +2 √ 2β3 + √ (2β2 + 2 √ 2β3)2 + β1 + β4, we have (2β2 +2 √ 2β3) √ R+ β12 + β4 2 6 R/2. Hence, Γj+1 6 R ln(2t/δ) ln2(t)\nj+1 ."
    }, {
      "heading" : "D Doubly Stochastic Gradient Algorithm for Posterior Variance",
      "text" : "Operator in Gaussian Process Regression\nAs we show in Section 4, the estimation of the variance of the predictive distribution of Gaussian process for regression problem could be recast as estimating the operator A defined in (10). We first demonstrate that the operator A is the solution to the following optimization problem\nmin A R(A) = 1 2n n∑ i=1 ‖k(xi, ·)−Ak(xi, ·)‖2H + σ2 2n ‖A‖2HS\nwhere ‖ · ‖HS is the Hilbert-Schmidt norm of the operator. The gradient of R(A) with respect to A is\n∇R(A) = 1 n n∑ i=1 ( (Ak(x, ·)− k(x, ·))⊗ k(x, ·) ) + σ2 n A = A ( C + σ 2 n I ) − C\nSet ∇R(A) = 0, we could obtain the optimal solution, C ( C + σ 2 n I )−1\n, exactly the same as (10). To derive the doubly stochastic gradient update for A, we start with stochastic functional gradient of\nR(A). Given xi ∼ P(x), the stochastic functional gradient of R(A) is ψ(·, ·) = A ( Ĉ + σ 2\nn I\n) − Ĉ\nwhere Ĉ = k(xi, ·)⊗ k(xi, ·) which leads to update At+1 = At − γtψ = ( 1− σ 2\nn γt\n) At − γt ( AtĈt − Ĉt ) . (18)\nWith such update rule, we could show that At+1 = ∑t i=1,j>i β t+1 ij k(xi, ·) ⊗ k(xj , ·) by induction. Let\nA1 = 0, then, A2 = γ1k(x1, ·) ⊗ k(x1, ·). Assume at t-th iteration, At = ∑t−1 i=1,j>i β t ijk(xi, ·) ⊗ k(xj , ·), and notice that\nAtĈt = A>t (·, xt)⊗ k(xt, ·) = t−1∑ i=1 ( t−1∑ j>i βtijk(xj , xt) ) k(xi, ·)⊗ k(xt, ·),\nwe have At+1 = ∑t i=1,j>i β t+1 ij k(xi, ·)⊗ k(xj , ·) where\nβt+1ij =\n( 1− σ 2\nn γt\n) βtij , ∀i 6 j < t\nβt+1it = −γt t∑\nj=1\nβtijk(xj , xt), ∀i < t\nβt+1tt = γt\nRecall\nĈt = Eω[φω(xt)φω(·)]⊗ Eω′ [φω′(xt)φω′(·)] = Eω,ω′ [φω(xt)φω′(xt)φω(·)⊗ φω′(·)], where ω, ω′ are independently sampled from P(ω), we could approximate the Ĉt with random features, Ĉω,ω ′\nt = φωt(xt)φω′t(xt)φωt(·)⊗ φω′t(·). Plug random feature approximation into (18) leads to Ât+1 = ( 1− σ 2\nn γt\n) Ât − γt ( Â>t (·, xt)⊗ φω′t(xt)φω′t(·)− Ĉ ω,ω′ t ) .\nTherefore, inductively, we could approximate At+1 by\nÂt+1 = t∑ i6j θtijφωi(·)⊗ φω′j (·)\nθij =\n( 1− σ 2\nn γt\n) θij , ∀i 6 j < t\nθit = −γt t−1∑ j>i θijφω′j (xt)φω′t(xt), ∀i < t\nθtt = γtφωt(xt)φω′t(xt)."
    } ],
    "references" : [ {
      "title" : "Sparse greedy matrix approximation for machine learning",
      "author" : [ "A.J. Smola", "B. Schölkopf" ],
      "venue" : "In ICML,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2000
    }, {
      "title" : "Using the Nystrom method to speed up kernel machines",
      "author" : [ "C.K.I. Williams", "M. Seeger" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2000
    }, {
      "title" : "Efficient SVM training using low-rank kernel representations",
      "author" : [ "S. Fine", "K. Scheinberg" ],
      "venue" : "JMLR, 2:243–264,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2001
    }, {
      "title" : "On the nystr om method for approximating a gram matrix for improved kernel-based learning",
      "author" : [ "P. Drineas", "M. Mahoney" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2005
    }, {
      "title" : "On the impact of kernel approximation on learning accuracy",
      "author" : [ "Corinna Cortes", "Mehryar Mohri", "Ameet Talwalkar" ],
      "venue" : "In AISTATS,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2010
    }, {
      "title" : "Random features for large-scale kernel machines",
      "author" : [ "A. Rahimi", "B. Recht" ],
      "venue" : null,
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2008
    }, {
      "title" : "Fastfood — computing hilbert space expansions in loglinear time",
      "author" : [ "Q.V. Le", "T. Sarlos", "A.J. Smola" ],
      "venue" : "In ICML,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2013
    }, {
      "title" : "Weighted sums of random kitchen sinks: Replacing minimization with randomization in learning",
      "author" : [ "Ali Rahimi", "Benjamin Recht" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2009
    }, {
      "title" : "Randomized nonlinear component analysis",
      "author" : [ "David Lopez-Paz", "Suvrit Sra", "A.J. Smola", "Zoubin Ghahramani", "Bernhard Schlkopf" ],
      "venue" : "In ICML,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2014
    }, {
      "title" : "Sequential minimal optimization: A fast algorithm for training support vector machines",
      "author" : [ "John C. Platt" ],
      "venue" : "Technical Report MSR-TR-98-14, Microsoft Research,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1998
    }, {
      "title" : "Making large-scale SVM learning practical",
      "author" : [ "T. Joachims" ],
      "venue" : "Advances in Kernel Methods — Support Vector Learning,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1999
    }, {
      "title" : "Stochastic dual coordinate ascent methods for regularized loss",
      "author" : [ "Shai Shalev-Shwartz", "Tong Zhang" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2013
    }, {
      "title" : "Online learning with kernels",
      "author" : [ "J. Kivinen", "A.J. Smola", "R.C. Williamson" ],
      "venue" : "IEEE Transactions on Signal Processing,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2004
    }, {
      "title" : "A modified finite Newton method for fast solution of large scale linear SVMs",
      "author" : [ "S.S. Keerthi", "D. DeCoste" ],
      "venue" : "J. Mach. Learn. Res.,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2005
    }, {
      "title" : "Kernel conjugate gradient for fast kernel machines",
      "author" : [ "N. Ratliff", "J. Bagnell" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2007
    }, {
      "title" : "Robust stochastic approximation approach to stochastic programming",
      "author" : [ "A. Nemirovski", "A. Juditsky", "G. Lan", "A. Shapiro" ],
      "venue" : "SIAM J. on Optimization,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2009
    }, {
      "title" : "Integral representation of pd functions",
      "author" : [ "A. Devinatz" ],
      "venue" : "Trans. AMS,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1953
    }, {
      "title" : "Kernels, associated structures, and generalizations",
      "author" : [ "M. Hein", "O. Bousquet" ],
      "venue" : "Technical Report 127, Max Planck Institute for Biological Cybernetics,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2004
    }, {
      "title" : "Scattered Data Approximation",
      "author" : [ "H. Wendland" ],
      "venue" : null,
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2005
    }, {
      "title" : "Learning with Kernels",
      "author" : [ "Bernhard Schölkopf", "A.J. Smola" ],
      "venue" : null,
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2002
    }, {
      "title" : "Fast and scalable polynomial kernels via explicit feature maps",
      "author" : [ "N. Pham", "R. Pagh" ],
      "venue" : "In KDD. ACM,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2013
    }, {
      "title" : "Predicting time series with support vector machines",
      "author" : [ "K.-R. Müller", "A.J. Smola", "G. Rätsch", "B. Schölkopf", "J. Kohlmorgen", "V. Vapnik" ],
      "venue" : "Artificial Neural Networks ICANN’97,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1997
    }, {
      "title" : "Estimating the support of a high-dimensional distribution",
      "author" : [ "B. Schölkopf", "J. Platt", "J. Shawe-Taylor", "A.J. Smola", "R.C. Williamson" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2001
    }, {
      "title" : "Estimating divergence functionals and the likelihood ratio by penalized convex risk minimization",
      "author" : [ "X.L. Nguyen", "M. Wainwright", "M. Jordan" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2008
    }, {
      "title" : "Relative novelty detection",
      "author" : [ "Alex J Smola", "Le Song", "Choon H Teo" ],
      "venue" : "In International Conference on Artificial Intelligence and Statistics,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2009
    }, {
      "title" : "Pegasos: Primal estimated sub-gradient solver for SVM",
      "author" : [ "Shai Shalev-Shwartz", "Yoram Singer", "Nathan Srebro" ],
      "venue" : "In ICML,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2007
    }, {
      "title" : "Training invariant support vector machines with selective sampling",
      "author" : [ "G. Loosli", "S. Canu", "L. Bottou" ],
      "venue" : "Large Scale Kernel Machines,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2007
    }, {
      "title" : "Learning multiple layers of features from tiny images",
      "author" : [ "A. Krizhevsky" ],
      "venue" : "Technical report, University of Toronto,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2009
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "A. Krizhevsky", "I. Sutskever", "G. Hinton" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2012
    }, {
      "title" : "Learning invariant representations of molecules for atomization energy prediction",
      "author" : [ "Grégoire Montavon", "Katja Hansen", "Siamac Fazli", "Matthias Rupp", "Franziska Biegler", "Andreas Ziehe", "Alexandre Tkatchenko", "Anatole von Lilienfeld", "Klaus-Robert Müller" ],
      "venue" : null,
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2012
    }, {
      "title" : "Making gradient descent optimal for strongly convex stochastic optimization",
      "author" : [ "Alexander Rakhlin", "Ohad Shamir", "Karthik Sridharan" ],
      "venue" : "In ICML,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2012
    }, {
      "title" : "Gradient-based learning applied to document recognition",
      "author" : [ "Y. LeCun", "L. Bottou", "Y. Bengio", "P. Haffner" ],
      "venue" : "Proceedings of the IEEE,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 1998
    }, {
      "title" : "Random feature maps for dot product kernels",
      "author" : [ "Purushottam Kar", "Harish Karnick" ],
      "venue" : "editors, AISTATS-12,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2012
    }, {
      "title" : "Efficient additive kernels via explicit feature maps",
      "author" : [ "Andrea Vedaldi", "Andrew Zisserman" ],
      "venue" : "IEEE Trans. Pattern Anal. Mach. Intell.,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2012
    }, {
      "title" : "Random laplace feature maps for semigroup kernels on histograms",
      "author" : [ "Jiyan Yang", "Vikas Sindhwani", "Quanfu Fan", "Haim Avron", "Michael W. Mahoney" ],
      "venue" : "In CVPR,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2014
    }, {
      "title" : "Accelerating stochastic gradient descent using predictive variance reduction",
      "author" : [ "Rie Johnson", "Tong Zhang" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 2013
    }, {
      "title" : "Stochastic block mirror descent methods for nonsmooth and stochastic optimization",
      "author" : [ "Cong D. Dang", "Guanghui Lan" ],
      "venue" : "Technical report, University of Florida,",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2013
    }, {
      "title" : "Efficiency of coordinate descent methods on huge-scale optimization problems",
      "author" : [ "Yurii Nesterov" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 2012
    }, {
      "title" : "Learning optimally sparse support vector machines",
      "author" : [ "Andrew Cotter", "Shai Shalev-Shwartz", "Nati Srebro" ],
      "venue" : "In Proceedings of the 30th International Conference on Machine Learning,",
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 2013
    }, {
      "title" : "Least squares revisited: Scalable approaches for multi-class prediction",
      "author" : [ "A. Agarwal", "S. Kakade", "N. Karampatziakis", "L. Song", "G. Valiant" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 2014
    }, {
      "title" : "On data preconditioning for regularized loss minimization",
      "author" : [ "Tianbao Yang", "Rong Jin", "Shenghuo Zhu" ],
      "venue" : null,
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 2014
    }, {
      "title" : "Quasi-monte carlo feature maps for shift-invariant kernels",
      "author" : [ "Jiyan Yang", "Vikas Sindhwani", "Haim Avron", "Michael W. Mahoney" ],
      "venue" : "In Proceedings of the 31th International Conference on Machine Learning,",
      "citeRegEx" : "43",
      "shortCiteRegEx" : "43",
      "year" : 2014
    }, {
      "title" : "Learning by stretching deep networks",
      "author" : [ "Gaurav Pandey", "Ambedkar Dukkipati" ],
      "venue" : "In Proceedings of the 31th International Conference on Machine Learning,",
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 2014
    }, {
      "title" : "Kernel methods for deep learning",
      "author" : [ "Youngmin Cho", "Lawrence K. Saul" ],
      "venue" : "Advances in Neural Information Processing Systems",
      "citeRegEx" : "45",
      "shortCiteRegEx" : "45",
      "year" : 2009
    }, {
      "title" : "Gaussian Processes for Machine Learning",
      "author" : [ "C.E. Rasmussen", "C.K.I. Williams" ],
      "venue" : null,
      "citeRegEx" : "46",
      "shortCiteRegEx" : "46",
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Many works, such as Greedy basis selection techniques [1], Nyström approximation [2] and incomplete Cholesky decomposition [3], all followed this strategy.",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 1,
      "context" : "Many works, such as Greedy basis selection techniques [1], Nyström approximation [2] and incomplete Cholesky decomposition [3], all followed this strategy.",
      "startOffset" : 81,
      "endOffset" : 84
    }, {
      "referenceID" : 2,
      "context" : "Many works, such as Greedy basis selection techniques [1], Nyström approximation [2] and incomplete Cholesky decomposition [3], all followed this strategy.",
      "startOffset" : 123,
      "endOffset" : 126
    }, {
      "referenceID" : 3,
      "context" : "In fact, without further assumption on the regularity of the kernel matrix, the generalization ability after low-rank approximation is typically of the order O(1/ √ r + 1/ √ n) [4, 5], which implies that the rank needs to be nearly linear in the number of data points! Thus, in order for kernel methods to achieve the best generalization ability, the low-rank approximation based approaches quickly become impractical for big datasets due to their O(n + nd) preprocessing time and O(n) memory requirement.",
      "startOffset" : 177,
      "endOffset" : 183
    }, {
      "referenceID" : 4,
      "context" : "In fact, without further assumption on the regularity of the kernel matrix, the generalization ability after low-rank approximation is typically of the order O(1/ √ r + 1/ √ n) [4, 5], which implies that the rank needs to be nearly linear in the number of data points! Thus, in order for kernel methods to achieve the best generalization ability, the low-rank approximation based approaches quickly become impractical for big datasets due to their O(n + nd) preprocessing time and O(n) memory requirement.",
      "startOffset" : 177,
      "endOffset" : 183
    }, {
      "referenceID" : 5,
      "context" : "Random feature approximation is another popular approach for scaling up kernel methods [6, 7].",
      "startOffset" : 87,
      "endOffset" : 93
    }, {
      "referenceID" : 6,
      "context" : "Random feature approximation is another popular approach for scaling up kernel methods [6, 7].",
      "startOffset" : 87,
      "endOffset" : 93
    }, {
      "referenceID" : 7,
      "context" : "Similar to low-rank kernel matrix approximation approach, the generalization ability of random feature approach is of the order O(1/ √ r+1/ √ n) [8, 9], which implies that the number of random features also needs to be O(n).",
      "startOffset" : 145,
      "endOffset" : 151
    }, {
      "referenceID" : 8,
      "context" : "Similar to low-rank kernel matrix approximation approach, the generalization ability of random feature approach is of the order O(1/ √ r+1/ √ n) [8, 9], which implies that the number of random features also needs to be O(n).",
      "startOffset" : 145,
      "endOffset" : 151
    }, {
      "referenceID" : 9,
      "context" : ", [10, 11, 12]).",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 10,
      "context" : ", [10, 11, 12]).",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 11,
      "context" : ", [10, 11, 12]).",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 12,
      "context" : ", [13, 15]).",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 14,
      "context" : ", [13, 15]).",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 15,
      "context" : "The key intuitions behind our algorithm originate from (i) the property of stochastic gradient descent algorithm that as long as the stochastic gradient is unbiased, the convergence of the algorithm is guaranteed [16]; and",
      "startOffset" : 213,
      "endOffset" : 217
    }, {
      "referenceID" : 15,
      "context" : "More specifically, both in expectation and with high probability, our algorithm can estimate the optimal function in the RKHS in the rate of O(1/t), which are indeed optimal [16], and achieve a generalization bound of O(1/ √ t).",
      "startOffset" : 174,
      "endOffset" : 178
    }, {
      "referenceID" : 16,
      "context" : ",[17]; [18]) If k(x, x′) is a PD kernel, then there exists a set Ω, a measure P on Ω, and random feature φω(x) : X 7→ R from L2(Ω,P), such that k(x, x′) = ∫ Ω φω(x)φω(x ′) dP(ω).",
      "startOffset" : 1,
      "endOffset" : 5
    }, {
      "referenceID" : 17,
      "context" : ",[17]; [18]) If k(x, x′) is a PD kernel, then there exists a set Ω, a measure P on Ω, and random feature φω(x) : X 7→ R from L2(Ω,P), such that k(x, x′) = ∫ Ω φω(x)φω(x ′) dP(ω).",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 19,
      "context" : "For Gaussian RBF kernel, k(x − x′) = exp(−‖x − x′‖2/2σ2), this yields a Gaussian distribution P(ω) with density proportional to exp(−σ‖ω‖/2); for the Laplace kernel, this yields a Cauchy distribution; and for the Martern kernel, this yields the convolutions of the unit ball [20].",
      "startOffset" : 275,
      "endOffset" : 279
    }, {
      "referenceID" : 19,
      "context" : "Similar representation where the explicit form of φω(x) and P(ω) are known can also be derived for rotation invariant kernel, k(x, x′) = k(〈x, x′〉), using Fourier transformation on sphere [20].",
      "startOffset" : 188,
      "endOffset" : 192
    }, {
      "referenceID" : 20,
      "context" : "For polynomial kernels, k(x, x′) = (〈x, x′〉+ c), a random tensor sketching approach can also be used [21].",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 32,
      "context" : "Explicit random features have been designed for many other kernels, such as dot product kernel [33], additive/multiplicative class of homogeneous kernels [34], e.",
      "startOffset" : 95,
      "endOffset" : 99
    }, {
      "referenceID" : 33,
      "context" : "Explicit random features have been designed for many other kernels, such as dot product kernel [33], additive/multiplicative class of homogeneous kernels [34], e.",
      "startOffset" : 154,
      "endOffset" : 158
    }, {
      "referenceID" : 34,
      "context" : ", Hellinger’s, χ, Jensen-Shannon’s and Intersection kernel, as well as kernels on Abelian semigroups [35].",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 18,
      "context" : ", [19]).",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 43,
      "context" : "The former random features define a hierachical kernel [45], and the latter random features induce a linear combination of multiple kernels.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 33,
      "context" : "It is worth to note that the Hellinger’s, χ, Jensen-Shannon’s and Intersection kernels in [34] are special cases of multiple kernels combination.",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 12,
      "context" : "Many kernel methods can be written as convex optimizations over functions in the RKHS and solved using the functional gradient methods [13, 15].",
      "startOffset" : 135,
      "endOffset" : 143
    }, {
      "referenceID" : 14,
      "context" : "Many kernel methods can be written as convex optimizations over functions in the RKHS and solved using the functional gradient methods [13, 15].",
      "startOffset" : 135,
      "endOffset" : 143
    }, {
      "referenceID" : 5,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 3,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 5,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 2,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 2,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 1,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 0,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 2,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 3,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 2,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 4,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 3,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 4,
      "context" : "T ab le 1 S u m m a y o f ke rn el s in [6 , 4 6 , 3 3 , 2 1 , 3 4 , 3 5 , 4 5 ] a n d th ei r ex p li ci t fe a tu re s",
      "startOffset" : 40,
      "endOffset" : 80
    }, {
      "referenceID" : 15,
      "context" : "The first key intuition behind our algorithm originates from the property of stochastic gradient descent algorithm that as long as the stochastic gradient is unbiased, the convergence of the algorithm is guaranteed [16].",
      "startOffset" : 215,
      "endOffset" : 219
    }, {
      "referenceID" : 13,
      "context" : "Remark: [14] used squared hinge loss, l(u, y) = 12 max{0, 1− uy} , in `2-SVM.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 21,
      "context" : "Huber’s loss is used for robust regression [22] where",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 22,
      "context" : "The loss function l(u, τ) = max{0, τ−u} [23] is proposed for novelty detection.",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 23,
      "context" : ", Ep [ r( q p ) ] , where r : R → R is a convex function with r(1) = 0, [24] proposed a nonparametric estimator for the logarithm of the density ratio, log q p , which is the solution of following convex optimization, argmin f∈H Eq[exp(f)] + Ep[r(− exp(f))] + ν 2 ‖f‖H (8) where r∗ denotes the Fenchel-Legendre dual of r, r(τ) := supχ χτ − r∗(χ).",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 23,
      "context" : "[24] proposed another convex optimization based on rKL(τ) whose solution is a nonparametric estimator for the density ratio.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 24,
      "context" : "[25] designed rnv(τ) = max(0, ρ − log τ) for novelty detection.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 15,
      "context" : "reference in [16]) shows that to obtain -accuracy solution, the number of iterations needed for the stochastic approximation is Ω(1/ ) for strongly convex case and Ω(1/ ) for general convex case.",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 35,
      "context" : "For example, techniques for reducing variance of SGD proposed in [37], mini-batch and preconditioning [41, 42] can be used to reduce the constant factors in the bound significantly.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 39,
      "context" : "For example, techniques for reducing variance of SGD proposed in [37], mini-batch and preconditioning [41, 42] can be used to reduce the constant factors in the bound significantly.",
      "startOffset" : 102,
      "endOffset" : 110
    }, {
      "referenceID" : 40,
      "context" : "For example, techniques for reducing variance of SGD proposed in [37], mini-batch and preconditioning [41, 42] can be used to reduce the constant factors in the bound significantly.",
      "startOffset" : 102,
      "endOffset" : 110
    }, {
      "referenceID" : 3,
      "context" : "Thus the required number of random feature (or ranks), r, will be of the order O(n) = O(1/ ) [4, 5, 8, 9].",
      "startOffset" : 93,
      "endOffset" : 105
    }, {
      "referenceID" : 4,
      "context" : "Thus the required number of random feature (or ranks), r, will be of the order O(n) = O(1/ ) [4, 5, 8, 9].",
      "startOffset" : 93,
      "endOffset" : 105
    }, {
      "referenceID" : 7,
      "context" : "Thus the required number of random feature (or ranks), r, will be of the order O(n) = O(1/ ) [4, 5, 8, 9].",
      "startOffset" : 93,
      "endOffset" : 105
    }, {
      "referenceID" : 8,
      "context" : "Thus the required number of random feature (or ranks), r, will be of the order O(n) = O(1/ ) [4, 5, 8, 9].",
      "startOffset" : 93,
      "endOffset" : 105
    }, {
      "referenceID" : 12,
      "context" : "We will pick a few representative algorithms for comparison, namely, (i) NORMA [13]: kernel methods trained with stochastic functional gradients; (ii) k-SDCA [12]: kernelized version of stochastic dual coordinate ascend; (iii) r-SDCA: first approximate the kernel function with random features, and then run stochastic dual coordinate ascend; (iv) n-SDCA: first approximate the kernel matrix using Nyström’s method, and then run stochastic dual coordinate ascend; similarly we will combine Pegasos algorithm [26], stochastic block mirror descent (SBMD) [38], and random block coordinate descent (RBCD) [39] with random features and Nyström’s method, and obtain (v) r-Pegasos, (vi) n-Pegasos, (vii) r-SBMD, (viii) n-SBMD, (ix) r-RBCD, and (x) n-RBCD, respectively.",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 11,
      "context" : "We will pick a few representative algorithms for comparison, namely, (i) NORMA [13]: kernel methods trained with stochastic functional gradients; (ii) k-SDCA [12]: kernelized version of stochastic dual coordinate ascend; (iii) r-SDCA: first approximate the kernel function with random features, and then run stochastic dual coordinate ascend; (iv) n-SDCA: first approximate the kernel matrix using Nyström’s method, and then run stochastic dual coordinate ascend; similarly we will combine Pegasos algorithm [26], stochastic block mirror descent (SBMD) [38], and random block coordinate descent (RBCD) [39] with random features and Nyström’s method, and obtain (v) r-Pegasos, (vi) n-Pegasos, (vii) r-SBMD, (viii) n-SBMD, (ix) r-RBCD, and (x) n-RBCD, respectively.",
      "startOffset" : 158,
      "endOffset" : 162
    }, {
      "referenceID" : 25,
      "context" : "We will pick a few representative algorithms for comparison, namely, (i) NORMA [13]: kernel methods trained with stochastic functional gradients; (ii) k-SDCA [12]: kernelized version of stochastic dual coordinate ascend; (iii) r-SDCA: first approximate the kernel function with random features, and then run stochastic dual coordinate ascend; (iv) n-SDCA: first approximate the kernel matrix using Nyström’s method, and then run stochastic dual coordinate ascend; similarly we will combine Pegasos algorithm [26], stochastic block mirror descent (SBMD) [38], and random block coordinate descent (RBCD) [39] with random features and Nyström’s method, and obtain (v) r-Pegasos, (vi) n-Pegasos, (vii) r-SBMD, (viii) n-SBMD, (ix) r-RBCD, and (x) n-RBCD, respectively.",
      "startOffset" : 508,
      "endOffset" : 512
    }, {
      "referenceID" : 36,
      "context" : "We will pick a few representative algorithms for comparison, namely, (i) NORMA [13]: kernel methods trained with stochastic functional gradients; (ii) k-SDCA [12]: kernelized version of stochastic dual coordinate ascend; (iii) r-SDCA: first approximate the kernel function with random features, and then run stochastic dual coordinate ascend; (iv) n-SDCA: first approximate the kernel matrix using Nyström’s method, and then run stochastic dual coordinate ascend; similarly we will combine Pegasos algorithm [26], stochastic block mirror descent (SBMD) [38], and random block coordinate descent (RBCD) [39] with random features and Nyström’s method, and obtain (v) r-Pegasos, (vi) n-Pegasos, (vii) r-SBMD, (viii) n-SBMD, (ix) r-RBCD, and (x) n-RBCD, respectively.",
      "startOffset" : 553,
      "endOffset" : 557
    }, {
      "referenceID" : 37,
      "context" : "We will pick a few representative algorithms for comparison, namely, (i) NORMA [13]: kernel methods trained with stochastic functional gradients; (ii) k-SDCA [12]: kernelized version of stochastic dual coordinate ascend; (iii) r-SDCA: first approximate the kernel function with random features, and then run stochastic dual coordinate ascend; (iv) n-SDCA: first approximate the kernel matrix using Nyström’s method, and then run stochastic dual coordinate ascend; similarly we will combine Pegasos algorithm [26], stochastic block mirror descent (SBMD) [38], and random block coordinate descent (RBCD) [39] with random features and Nyström’s method, and obtain (v) r-Pegasos, (vi) n-Pegasos, (vii) r-SBMD, (viii) n-SBMD, (ix) r-RBCD, and (x) n-RBCD, respectively.",
      "startOffset" : 602,
      "endOffset" : 606
    }, {
      "referenceID" : 38,
      "context" : ", hinge-loss, there are algorithms proposed to achieve better memory saving with extra training cost, such as support vector reduction technique [40].",
      "startOffset" : 145,
      "endOffset" : 149
    }, {
      "referenceID" : 12,
      "context" : "3M 2850 [0, 13] no guarantees.",
      "startOffset" : 8,
      "endOffset" : 15
    }, {
      "referenceID" : 29,
      "context" : "For datasets (9) and (10), we compare with the neural net described in [30] and use exactly the same input.",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 31,
      "context" : "In this experiment, we compare to a variant of LeNet-5 [32], where all tanh units are replaced with rectified linear units.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 27,
      "context" : "In this experiment, we compare to a neural net with two convolution layers (after contrast normalization and max-pooling layers) and two local layers that achieves 11% test error on CIFAR 10 [28].",
      "startOffset" : 191,
      "endOffset" : 195
    }, {
      "referenceID" : 28,
      "context" : "The jointly-trained neural net is Alex-net [29].",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 29,
      "context" : "5 Regression Comparisons to Neural Networks We test our algorithm for kernel ridge regression with neural network proposed in [30] on two large-scale real-world regression datasets, (9) and (10) in Table 4.",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 29,
      "context" : "In this experiment, we use the same binary representations converted based on random Coulomb matrices as in [30].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 29,
      "context" : "We use the same feature representation as for “QuantumMachine” dataset [30].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 6,
      "context" : "It is straightforward to replace the sampling strategy for random features with Fastfood [7] which enjoys the efficient computational cost, or Quasi-Monte Carlo sampling [43], data-dependent sampling [47] which enjoys faster convergence rate with fewer generated features.",
      "startOffset" : 89,
      "endOffset" : 92
    }, {
      "referenceID" : 41,
      "context" : "It is straightforward to replace the sampling strategy for random features with Fastfood [7] which enjoys the efficient computational cost, or Quasi-Monte Carlo sampling [43], data-dependent sampling [47] which enjoys faster convergence rate with fewer generated features.",
      "startOffset" : 170,
      "endOffset" : 174
    } ],
    "year" : 2015,
    "abstractText" : "The general perception is that kernel methods are not scalable, and neural nets are the methods of choice for large-scale nonlinear learning problems. Or have we simply not tried hard enough for kernel methods? Here we propose an approach that scales up kernel methods using a novel concept called “doubly stochastic functional gradients”. Our approach relies on the fact that many kernel methods can be expressed as convex optimization problems, and we solve the problems by making two unbiased stochastic approximations to the functional gradient, one using random training points and another using random features associated with the kernel, and then descending using this noisy functional gradient. Our algorithm is simple, does not need to commit to a preset number of random features, and allows the flexibility of the function class to grow as we see more incoming data in the streaming setting. We show that a function learned by this procedure after t iterations converges to the optimal function in the reproducing kernel Hilbert space in rate O(1/t), and achieves a generalization performance of O(1/ √ t). Our approach can readily scale kernel methods up to the regimes which are dominated by neural nets. We show that our method can achieve competitive performance to neural nets in datasets such as 2.3 million energy materials from MolecularSpace, 8 million handwritten digits from MNIST, and 1 million photos from ImageNet using convolution features.",
    "creator" : "LaTeX with hyperref package"
  }
}