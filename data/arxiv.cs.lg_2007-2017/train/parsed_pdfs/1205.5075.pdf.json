{
  "name" : "1205.5075.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Efficient Sparse Group Feature Selection via Nonconvex Optimization",
    "authors" : [ "Shuo Xiang", "Xiaotong Shen", "Jieping Ye" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n20 5.\n50 75\nv1 [\ncs .L\nG ]"
    }, {
      "heading" : "1 Introduction",
      "text" : "During the past decade, sparse feature selection has been extensively investigated, on both optimization algorithms [1] and statistical properties [28, 20, 3]. When the data possesses certain group structure, sparse modeling has been explored in [24, 16, 13] for group feature selection. The group lasso [24] proposes an L2-regularization method for each group, which ultimately yields a group-wisely sparse model. The utility of such a method has been demonstrated in detecting splice sites [23]—an important step in gene finding and theoretically justified in [13]. The sparse group lasso [11] enables to encourage sparsity at the level of both features and groups simultaneously.\nIn the literature, most approaches use convex methods due to globality of the solution and tractable computation. However, this may lead to suboptimal results. Recent studies demonstrate that nonconvex methods, for instance, the truncated L1-penalty [19, 15, 27], may have potential to deliver superior performance than the standard L1-formulation. In addition, [19] suggests that a constrained version of nonconvex regularization is slightly more preferable than its regularization counterpart due to theoretical merits.\nIn this article, we investigate the sparse group feature selection (SGFS) through a constrained nonconvex\nformulation. Ideally, we wish to optimize the following L0-model:\nminimize x\n1 2 ‖Ax− y‖22\nsubject to\np∑\nj=1\nI(|xj | 6= 0) ≤ s1\n|G|∑\nj=1\nI(‖xGj‖2 6= 0) ≤ s2,\n(1)\nwhere A is an n by p data matrix with its columns representing different features. x = (x1, · · · , xp) is partitioned into |G| non-overlapping groups {xGi} and I(·) is the indicator function. The advantage of the L0-model (1) lies in its complete control on two levels of sparsity (s1, s2), which are the numbers of features and groups respectively. However, a problem like (1) is known to be NP-hard [17].\nThis paper develops an efficient nonconvex method, which is a computational surrogate of the L0-method described above and has theoretically guaranteed performance. We contribute in two aspects: (i) statistically, the proposed method retains the merits of the L0 approach (1) in the sense that the oracle estimator can be reconstructed, which leads to consistent feature selection and parameter estimation; (ii) computationally, our efficient optimization tool enables to treat large-scale problems."
    }, {
      "heading" : "2 Nonconvex Formulation and Computation",
      "text" : "One major difficulty of solving (1) comes from nonconvex and discrete constraints, which require enumerating all possible combinations of features and groups to achieve the optimal solution. Therefore we approximate these constraints by their continuous computational surrogates:\nminimize x\n1 2 ‖Ax− y‖22\nsubject to\np∑\nj=1\nJτ (|xj |) ≤ s1,\n|G|∑\ni=1\nJτ (‖xGi‖2) ≤ s2,\n(2)\nwhere Jτ (z) = min(|z|/τ, 1) is a truncated L1-function approximating the L0-function [19, 26], and τ > 0 is a tuning parameter such that Jτ (z) approximates the indicator function I(|z| 6= 0) as τ approaches zero.\nTo solve the nonconvex problem (2), we develop a Difference of Convex (DC) algorithm based on a decomposition of each nonconvex constraint function into a difference of two convex functions; for instance,\np∑\nj=1\nJτ (|xj |) = S1(x)− S2(x),\nwhere\nS1(x) = 1\nτ\np∑\nj=1\n|xj |\nand\nS2(x) = 1\nτ\np∑\nj=1\nmax{|xj | − τ, 0}\nare convex in x. Then each trailing convex function, say S2(x), is replaced by its affine minorant at the previous iteration S1(x)− S2(x̂(m−1))−∇S2(x̂(m−1))T (x− x̂(m−1)), (3) which yields an upper approximation of the constraint function ∑p j=1 Jτ (|xj |) as follows:\n1\nτ\np∑\nj=1\n|xj | · I(|x̂(m−1)j | ≤ τ) + p∑\nj=1\nI(|x̂(m−1)j | > τ) ≤ s1. (4)\nSimilarly, the second nonconvex constraint in (2) can be approximated by\n1\nτ\n|G|∑\nj=1\n‖xGj‖2 · I(‖x̂(m−1)Gj ‖2 ≤ τ) + |G|∑\nj=1\nI(‖x̂(m−1)Gj ‖2 > τ) ≤ s2. (5)\nNote that both (4) and (5) are convex constraints, which result in a convex subproblem as follows:\nminimize x\n1 2 ‖Ax− y‖22\nsubject to 1 τ ‖xT1(x̂(m−1))‖1 ≤ s1 − (p− |T1(x̂(m−1))|)\n1 τ ‖xT3(x̂(m−1))‖G ≤ s2 − (|G| − |T2(x̂(m−1))|),\n(6)\nwhere T1, T2 and T3 are the support sets 1 defined as:\nT1(x) = {i : |xi| ≤ τ} T2(x) = {i : ‖xGi‖2 ≤ τ} T3(x) = {i : xi ∈ xGj , j ∈ T2(x)},\n‖xT1‖1 and ‖xT3‖G denote the corresponding value restricted on T1 and T3 respectively, and ‖x‖G =∑|G| i=1 ‖xGi‖2. Solving (6) would provide us an updated solution, denoted as x̂(m). Such procedure is iterated until the objective value is no longer decreasing, indicating that a local minimizer is achieved. The DC algorithm is summarized in Algorithm 1, from which we can see that efficient computation of (6) is critical to the overall DC routine. We defer detailed discussion of this part to Section 4.\nAlgorithm 1 DC programming for solving (2)\nInput: A, y, s1, s2 Output: solution x to (2) 1: (Initialization) Initialize x̂(0). 2: (Iteration) At iteration m, compute x̂(m) by optimizing (6). 3: (Stopping Criterion) Terminate when the objective function stops decreasing."
    }, {
      "heading" : "3 Theoretical Results",
      "text" : "This section investigates theoretical aspects of the proposed method. More specifically, we demonstrate that the oracle estimator x̂o, the least squares estimator based on the true model, can be reconstructed. As a result, consistent selection as well as optimal parameter estimation can be achieved.\n1Support sets indicate that the elements outside these sets have no effect on the particular items in the constraints of (6).\nFor better presentation, we introduce some notations that would be only utilized in this section. Let C = (Gi1 , · · · , Gik) be the collection of groups that contain nonzero elements. Let AGj = AGj (x) and A = A(x) denote the indices of nonzero elements of x in group Gj and in entire x respectively. Define\nSj,i = {x ∈ S : (AC , C) 6= (AC0 , C0), |A| = j, |C| = i},\nwhere S is the feasible region of (2) and C0 represents the true nonzero groups. The following assumptions are needed for obtaining consistent reconstruction of the oracle estimator:\nAssumption 1 (Separation condition). Define\nCmin(x 0) = inf\nx∈S − log(1 − h2(x,x0)) max(|C0 \\ C|, 1) ,\nthen for some constant c1 > 0,\nCmin(x 0) ≥ c1 log |G|+ log s01 n ,\nwhere\nh(x,x0) = (1 2\n∫ (g1/2(x, y)− g1/2(x0, y))2dµ(y) )1/2\nis the Hellinger-distance for densities with respect to a dominating measure µ.\nAssumption 2 (Complexity of the parameter space). For some constants c0 > 0 and any 0 < t < ε ≤ 1,\nH(t,Fj,i) ≤ c0 max((log(|G|+ s01))2, 1)|Bj,i| log(2ε/t),\nwhere Bj,i = Sj,i ∩ {x ∈ h(x,x0) ≤ 2ε} is a local parameter space and Fj,i = {g1/2(x, y) : x ∈ Bj,i} is a collection of square-root densities. H(·,F) is the bracketing Hellinger metric entropy of space F [14].\nAssumption 3. For some positive constants d1, d2, d3 with d1 > 10,\n− log(1− h2(x,x0)) ≥ −d1 log(1− h2(xτ ,x0))− d3τd2p,\nwhere xτ = (x1I(|x1| ≥ τ), · · · , xpI(|xp| ≥ τ)).\nWith the above assumptions hold, we can conclude the following non-asymptotic probability error bound regarding the reconstruction of the oracle estimator x̂o.\nTheorem 1. Suppose that Assumptions 2 and 3 hold. For a global minimizer of (2) x̂ with (s1, s2) = (s 0 1, s 0 2) and τ ≤ ( (d1−10)Cmin(x0)\nd3d\n)1/d2 , the following result hold:\nP ( x̂ 6= x̂o ) ≤ exp ( − c2nCmin(x0) + 2(log |G|+ log s01) ) .\nMoreover, with Assumption 1 hold, P ( x̂ = x̂o ) → 1 and\nEh2(x̂,xo) = (1 + o(1))max(Eh2(x̂o,x0), s01 n )\nas n→ ∞, |G| → ∞.\nTheorem 1 states that the oracle estimator x̂o can be accurately reconstructed, which in turn yields feature selection consistency as well as the recovery of the performance of the oracle estimator in parameter estimation. Moreover, according to Assumption 1, such conclusion still holds when s01|G| grows in the order of exp(c−11 nCmin) . This is in contrast to existing conclusions on consistent feature selection, where the number of candidate features should be no larger than exp(c∗n) for some c∗ [28]. In this sense, the number\nof candidate features is allowed to be much larger when an additional group structure is incorporated, particularly when each group contains considerable redundant features.\nTo our knowledge, our theory for the grouped selection is the first of this kind. However, it has a root in feature selection. The large deviation approach used here is applicable to derive bounds for feature selection consistency. In such a situation, the result agrees with the necessary condition for feature selection consistency for any method, except for the constants independent of the sample size [19]. In other words, the required conditions are weaker than those for L1-regularization [21]. The use of the Hellinger-distance is mainly to avoid specifying a sub-Gaussian tail of the random error. This means that the result continues to hold even when the error does not have a sub-Gaussian tail."
    }, {
      "heading" : "4 Optimization Procedures",
      "text" : "As mentioned in Section 2, efficient computation of the convex subproblem (6) is of critical importance for the proposed DC algorithm. Note that (6) has an identical form of the constrained sparse group lasso problem:\nminimize x\n1 2 ‖Ax− y‖22\nsubject to ‖x‖1 ≤ s1 ‖x‖G ≤ s2\n(7)\nexcept that x is restricted to the two support sets. As to be shown in Section 4.3, an algorithm for solving (6) can be obtained through only a few modifications on that of (7). Therefore, we first focus on solving (7)."
    }, {
      "heading" : "4.1 Accelerated Gradient Method",
      "text" : "For large-scale problems, the dimensionality of data can be very high, therefore first-order optimization is often preferred. We adapt the well-known accelerated gradient method (AGM) [18, 2], which is commonly used due to its fast convergence rate.\nTo apply AGM to our formulation (7), the crucial step is to solve the following Sparse Group Lasso Projection (SGLP):\nminimize x\n1 2 ‖x− v‖22\nsubject to ‖x‖1 ≤ s1 (C1) ‖x‖G ≤ s2 (C2),\n(8)\nwhich is an Euclidean projection onto a convex set and a special case of (7) when A is the identity. For convenience, let C1 and C2 denote the above two constraints in what follows.\nSince the AGM is a standard framework whose efficiency mainly depends on that of the projection step, we leave the detailed description of AGM in the supplement and introduce the efficient algorithm for this projection step (8)."
    }, {
      "heading" : "4.2 Efficient Projection",
      "text" : "We begin with some special cases of (8). If only C1 exists, (8) becomes the well-known L1-ball projection [9], whose optimal solution is denoted as Ps11 (v), standing for the projection of v onto the L1-ball with radius s1. On the other hand, if only C2 is involved, it becomes the group lasso projection, denoted as Ps2G . Moreover, we say a constraint is active, if and only if an equality holds at the optimal solution x∗; otherwise, it is inactive.\nPreliminary results are summarized in Lemma 1:\nLemma 1. Denote a global minimizer of (8) as x∗. Then the following results hold:\n1. If both C1 and C2 are inactive, then x ∗ = v.\n2. If C1 is the only active constraint, i.e., ‖x∗‖1 = s1, ‖x∗‖G < s2, then x∗ = Ps11 (v) 3. If C2 is the only active constraint, i.e., ‖x∗‖1 < s1, ‖x∗‖G = s2, then x∗ = Ps2G (v)"
    }, {
      "heading" : "4.2.1 Computing x∗ from the optimal dual variables",
      "text" : "Lemma 1 describes a global minimizer when either constraint is inactive. Next we consider the case in which both C1 and C2 are active. By the convex duality theory [6], there exist unique non-negative dual variables λ∗ and η∗ such that x∗ is also the global minimizer of the following regularized problem:\nminimize x\n1 2 ‖x− v‖22 + λ∗‖x‖1 + η∗‖x‖G, (9)\nwhose solution is given by the following Theorem.\nTheorem 2 ([11]). The optimal solution x∗ of (9) is given by\nx∗Gi = max{‖vλ ∗ Gi‖2 − η∗, 0} vλ\n∗ Gi\n‖vλ∗Gi‖2 i = 1, 2, · · · , |G| (10)\nwhere vλ ∗\nGi is computed via soft-thresholding [8] vGi with threshold λ\n∗ as follows:\nvλ ∗ Gi = SGN(vGi) ·max{|vGi | − λ∗, 0},\nwhere SGN(·) is the sign function and all the operations are taken element-wisely.\nTheorem 2 gives an analytical solution of x∗ in an ideal situation when the values of λ∗ and η∗ are given. Unfortunately, this is not the case and the values of λ∗ and η∗ need to be computed directly from (8). Based on Theorem 2, we have the following conclusion characterizing the relations between the dual variables:\nCorollary 1. The following equations hold:\n‖x∗‖1 = |G|∑\ni=1\nmax{‖vλ∗Gi‖2 − η∗, 0} ‖vλ∗Gi‖1 ‖vλ∗Gi‖2 = s1 (11)\n‖x∗‖G = |G|∑\ni=1\nmax{‖vλ∗Gi‖2 − η∗, 0} = s2 . (12)\nSuppose λ∗ is given, then computing η∗ from (12) amounts to solving a median finding problem, which can be done in linear time [9].\nFinally, we treat the case of unknown λ∗ (thus unknown η∗). We propose an efficient bisection approach to compute it."
    }, {
      "heading" : "4.2.2 Computing λ∗: bisection",
      "text" : "Given an initial guess (estimator) of λ∗, says λ̂, one may perform bisection to locate the optimal λ∗, provided that there exists an oracle procedure indicating if the optimal value is greater than λ̂2. This bisection method can estimate λ∗ in logarithm time. Next, we shall design an oracle procedure.\n2An upper bound and a lower bound of λ∗ should be provided in order to perform the bisection. These bounds can be easily derived from the assumption that both C1 and C2 are active.\nLet the triples (x∗, λ∗, η∗) = SGLP(v, s1, s2)\nbe the optimal solution of (8) with both constraints active, i.e., ‖x∗‖1 = s1, ‖x∗‖G = s2, with (λ∗, η∗) be the optimal dual variables. Consider the following two sparse group lasso projections:\n(x, λ, η) = SGLP(v, s1, s2), (x′, λ′, η′) = SGLP(v, s′1, s ′ 2).\nThe following key result holds.\nTheorem 3. If λ ≤ λ′ and s2 = s′2, then s1 ≥ s′1.\nTheorem 3 gives the oracle procedure with its proof presented in the supplement. For a given estimator λ̂, we compute its corresponding η̂ from (12) and then ŝ1 from (11), satisfying (x̂, λ̂, η̂) = SGLP(v, ŝ1, s2). Then ŝ1 is compared with s1. Clearly, by Theorem 3, if ŝ1 ≤ s1, the estimator λ̂ is no less than λ∗. Otherwise, ŝ1 > s1 means λ̂ < λ\n∗. In addition, from (11) we know that ŝ1 is a continuous function of λ̂. Together with the monotonicity given in Theorem 3, a bisection approach can be employed to calculate λ∗. Algorithm 2 gives a detailed description.\n4.3 Solving Restricted version of (7)\nFinally, we modify the above procedures to compute the optimal solution of the restricted problem (6). To apply the accelerated gradient method, we consider the following projection step:\nminimize x\n1 2 ‖x− v‖22\nsubject to ‖xT1‖1 ≤ s1 (C1) ‖xT3‖G ≤ s2 (C2).\n(13)\nOur first observation is: T3(x) ⊂ T1(x), since if an element of x lies in a group whose L2-norm is less than τ , then the absolute value of this element must also be less than τ . Secondly, from the decomposable nature of the objective function, we conclude that:\nx∗j = { vj if j ∈ (T1)c vλ ∗\nj if j ∈ T1\\T3,\nsince there are no constraints on xj if it is outside T1 and involves only the L1-norm constraint if j ∈ T1\\T3. Following routine calculations as in [9], we obtain the following results similar to (11) and (12):\ns1 = ∑\ni∈T2 max{‖vλ∗Gi‖2 − η∗, 0} ‖vλ∗Gi‖1 ‖vλ∗Gi‖2 + ∑ j∈T1\\T3 vλ ∗ j (14)\ns2 = ∑\ni∈T2 max{‖vλ∗Gi‖2 − η∗, 0}. (15)\nBased on (14) and (15), we design a similar bisection approach to compute λ∗ and thus (x∗)T3 , as in Algorithm 2. Details are deferred to the supplement.\nAlgorithm 2 Sparse Group Lasso Projection Algorithm\nInput: v, s1, s2 Output: an optimal solution x to the Sparse Group Projection Problem\nFunction SGLP(v, s1, s2)\n1: if ‖x‖1 ≤ s1 and ‖x‖G ≤ s2 then 2: return v 3: end if 4: xC1 = Ps11 (v) 5: xC2 = Ps2G (v) 6: xC12= bisec(v, s1, s2) 7: if ‖xC1‖G ≤ s2 then 8: return xC1 9: else if ‖xC2‖1 ≤ s1 then\n10: return xC2 11: else 12: return xC12 13: end if\nFunction bisec(v, s1, s2)\n1: Initialize up, low and tol 2: while up− low > tol do 3: λ̂ = (low + up)/2 4: if (12) has a solution η̂ given vλ̂ then\n5: calculate ŝ1 using η̂ and λ̂. 6: if ŝ1 ≤ s1 then 7: up = λ̂ 8: else\n9: low = λ̂ 10: end if 11: else 12: up = λ̂ 13: end if 14: end while 15: λ∗ = up 16: Solve (12) to get η∗ 17: Calculate x∗ from λ∗ and η∗ via (10) 18: return x∗"
    }, {
      "heading" : "5 Significance",
      "text" : "This section is devoted to a brief discussion of advantages of our work statistically and computationally. Moreover, it explains why the proposed method is useful to perform efficient and interpretable feature selection with a given natural group structure.\nInterpretability. The parameters in (2) are highly interpretable in that s1 and s2 are upper bounds of the number of nonzero elements as well as that of groups. This is advantageous, especially in the presence of certain prior knowledge regarding the number of features and/or that of groups. However, such an interpretation vanishes with convex methods such as lasso or sparse group lasso, in which incorporating such prior knowledge often requires repeated trials of different parameters.\nParameter tuning. Typically, tuning parameters for good generalization usually requires considerable amount work due to a large number of choices of parameters. However, tuning in (1) may search through integer values in a bounded range, and can be further simplified when certain prior knowledge is available.\nThis permits more efficient tuning than its regularization counterpart. Based on our limited experience, we note that τ does not need to be tuned precisely as we may fix at some small values.\nPerformance and Computation. Although our model (2) is proposed as a computational surrogate of the ideal L0-method, its performance can also be theoretically guaranteed, i.e., consistent feature selection can be achieved. Moreover, the computation of our model is much more efficient and applicable to large-scale applications."
    }, {
      "heading" : "6 Empirical Evaluation",
      "text" : "This section performs numerical experiments to evaluate the proposed methods in terms of the efficiency and accuracy of sparse group feature selection. Evaluations are conducted on a PC with i7-2600 CPU, 8.0 GB memory and 64-bit Windows operating system."
    }, {
      "heading" : "6.1 Evaluation of Projection Algorithms",
      "text" : "Since the DC programming and the accelerated gradient methods are both standard, the efficiency of the proposed nonconvex formulation (2) depends on the projection step in (8). Therefore, we focus on evaluating the projection algorithms and comparing with two popular projection algorithms: Alternating Direction Multiplier Method (ADMM) [5] and Dykstra’s projection algorithm [7]. We provide a detailed derivation of adapting these two algorithms to our formulation in the supplement.\nTo evaluate the efficiency, we first generate the vector v whose entries are uniformly distributed in [−50, 50] and the dimension of v, denoted as p, is chosen from the set {102, 103, 104, 105, 106}. Next we partition the vector into 10 groups of equal size. Finally, s2 is set to 5 log(p) and s1, the radius of the L1-ball, is computed by √ 10 2 s2 (motivated by the fact that s1 ≤ √ 10s2).\nFor a fair comparison, we run our projection algorithm until converge and record the minimal objective value as f∗. Then we run ADMM and Dykstra’s algorithm until their objective values become close to ours. More specifically, we terminate their iterations as soon as fADMM − f∗ ≤ 10−3 and fDykstra − f∗ ≤ 10−3, where fADMM and fDykstra stand for the objective value of ADMM and Dykstra’s algorithm respectively. Table 1 summarizes the average running time of all three algorithms over 100 replications.\nNext we demonstrate the accuracy of our projection algorithm. Toward this end, the general convex optimization toolbox CVX [12] is chosen as the baseline. Following the same strategy of generating data, we report the distance (computed from the Euclidean norm ‖ · ‖2) between optimal solution of the three projection algorithms and that of the CVX. Note that the projection is strictly convex with a unique global optimal solution.\nFor ADMM and Dykstra’s algorithm, the termination criterion is that the relative difference of the objective values between consecutive iterations is less than a threshold value. Specifically, we terminate the iteration if |f(xk−1)− f(xk)| ≤ 10−7f(xk−1). For our projection algorithm, we set the tol in Algorithm 2 to be 10−7. The results are summarized in Table 2. Powered by second-order optimization algorithms, CVX can\nprovide fast and accurate solution for problems of moderate size but would suffer from great computational burden for large-scale ones. Therefore we only report the results up to 5, 000 dimensions.\nFrom Tables 1 and 2, we note that both ADMM and our algorithm yield more accurate solution than that of Dykstra’s. For projections of moderate size, all three algorithms perform well. However, for large-scale ones, our advantage on efficiency is evident."
    }, {
      "heading" : "6.2 Performance on Synthetic Data",
      "text" : ""
    }, {
      "heading" : "6.2.1 Experimental Setup",
      "text" : "We generate a 60× 100 matrix A, whose entries follow i.i.d standard normal distribution. The 100 features (columns) are partitioned into 10 groups of equal size. The ground truth vector x0 possesses nonzero elements only in 4 of the 10 groups. To further enhance sparsity, in each nonzero group of x0, only t (t ≤ 10) elements are nonzero, where t is uniformly distributed from [1, 5]. Finally y is generated according to Ax0 + z with z following distribution N (0, 0.52), where A and y are divided into training and testing set of equal size.\nWe fit our method to the training set and compare with lasso, group lasso and sparse group lasso. The tuning parameters of the convex methods are selected from {0.01, 0.1, 1, 10}, whereas for our method, the number of nonzero groups is selected from the set {2, 4, 6, 8} and the number of features is chosen from {2s2, 4s2, 6s2, 8s2}. Leave-one-out cross-validation is conducted over the training set for choosing the best tuning parameter for all the methods."
    }, {
      "heading" : "6.2.2 Results and Discussions",
      "text" : "We use following metrics for evaluation:\n• Estimation error: ‖x̂− x0‖22 • Prediction error: ‖Ax̂− ỹ‖22 • Group precision: |T2(x̂) ∩ T2(x0)|/|T2(x̂)|\n• Group recall: |T2(x̂) ∩ T2(x0)|/|T2(x0)|\nwhere x̂ is the estimator obtained from (2) and ỹ is an independent vector following the same distribution as y. The group precision and recall demonstrate the capability of recovering the group structure from data. We report the results in Table 3 and observe that our model generally exhibits better performance. Note that although our model does not provide the best result on the metric of group recall, the group precision of our model is significantly better than the others, illustrating the fact that the three convex methods recover more redundant groups."
    }, {
      "heading" : "6.3 Performance on Real-world Application",
      "text" : "Our method is further evaluated on the application of examining Electroencephalography (EEG) correlates of genetic predisposition to alcoholism [10]. EEG records the brain’s spontaneous electrical activity by measuring the voltage fluctuations over multiple electrodes placed on the scalp. This technology has been widely used in clinical diagnosis, such as coma, brain death and genetic predisposition to alcoholism. In fact, encoded in the EEG data is a certain group structure, since each electrode records the electrical activity of a certain region of the scalp. Identifying and utilizing such spatial information has the potential of increasing stability of a prediction.\nThe training set contains 200 samples of 16384 dimensions, sampled from 64 electrodes placed on subject’s scalps at 256 Hz (3.9-msec epoch) for 1 second. Therefore, the data can naturally be divided into 64 groups of size 256. We apply the lasso, group lasso, sparse group lasso and our method on the training set and adapt the 5-fold cross-validation for selecting tuning parameters. More specifically, for lasso and group lasso, the candidate tuning parameters are specified by 10 parameters3 sampled using the logarithmic scale from the parameter spaces, while for the sparse group lasso, the parameters form a 10 × 10 grid4, sampled from the parameter space in logarithmic scale. For our method, the number of groups is selected from the set: s2 = {30, 40, 50} and s1, the number of features is chosen from the set {50s2, 100s2, 150s2}. The accuracy of classification together with the number of selected features and groups over a test set, which also contains 200 samples, are reported in Table 4. Clearly our method achieves the best performance of classification with the least number of groups. Note that, although lasso’s performance is almost as good as ours with even less features, however, it fails to identify the underlying group structure in the data, as revealed by the fact all 64 groups are selected."
    }, {
      "heading" : "7 Conclusion and Future Work",
      "text" : "This paper expands a nonconvex paradigm into sparse group feature selection. In particular, theoretical properties on the accuracy of selection and parameter estimation are analyzed. In addition, an efficient optimization scheme is developed based on the DC programming, accelerated gradient method and efficient\n3λlasso = logspace(10 −3, 1), λglasso = logspace(10 −2, 1) 4The product space of λlasso × λglasso\nprojection. The efficiency and efficacy of the proposed method are validated on both synthetic data and real-world applications.\nThe proposed method will be further investigated on real-world applications involving the group structure. Moreover, extending the proposed model to multi-modal multi-task learning [25] is another promising direction."
    }, {
      "heading" : "1 Proof of Theorem 1",
      "text" : "The proof uses a large deviation probability inequality of [22] to treat one-sided log-likelihood ratios with constraints.\nLet S = { xτ : ‖xτ‖0 ≤ s01, ‖xτ‖0,G ≤ s02 } , ‖x‖0 = ∑p j=1 I(|xj | 6= 0) is the L0-norm of x, and ‖x‖0,G =∑|G|\nj=1 I(‖xj‖2 6= 0) is the L0-norm over the groups. Now we partition S. Note that for C ⊂ (G1, · · · , G|G|), it can be partitioned into C = (C \\ C0) ∪ (C ∩ C0). Then\nS = s02⋃\ni=0\n⋃\nC∈Bi SAC ,C ,\nwhere SAC ,C = { xτ ∈ S : C(x) = C = (Gi1 , · · · , Gik), ∑ j |AGj | ≤ s01 } , and Bi = {C 6= C0 : |C0 \\ C| = i, |C| ≤ s02}, with |Bi| = ( s02 s02−i )∑i j=0 (|G|−s02 j ) ; i = 0, · · · , s02.\nTo bound the error probability, let L(x) = − 12‖Ax− y‖2 be the likelihood. Note that\n{x̂ 6= x̂o} ⊆ {L(x̂)− L(x̂o) ≥ 0} ⊆ {L(x̂)− L(x0) ≥ 0}.\nThis together with {x̂ 6= x̂o} ⊆ {x̂ ∈ S} implies that\n{x̂ 6= x̂o} ⊆ {L(x̂)− L(x0) ≥ 0} ∩ {x̂ ∈ S}.\nConsequently,\nI ≡ P ( x̂ 6= x̂o )\n≤ P ( L(x̂)− L(x0) ≥ 0; x̂ ∈ S )\n≤ s02∑\ni=1\n∑\nC∈Bi\n∑\nSAC,C\nP ∗ (\nsup x∈SAC,C\n( L(x)− L(x0) ) ≥ 0\n)\n≤ s02∑\ni=1\ns01∑\nj=1\n∑\n|C|=i,|AG|=j P ∗\n( sup{ −log(1−h2(x,x0))≥max(i,1)Cmin(x0)−d3τd2p,x∈SAC,C } ( L(x)− L(x0) ) ≥ 0 ) ,\nwhere P ∗ is the outer measure and the last two inequalities use the fact that SAC ,C ⊆ {x ∈ SAC ,C : max(|C0 \\C|, 1)Cmin(x0) ≤ − log(1−h2(x,x0))} ⊆ {− log(1−h2(x,x0)) ≥ d1 max(i, 1)Cmin(x0)− d3τd2p}, under Assumption 3.\nFor I, we apply Theorem 1 of [22] to bound each term. Towards this end, we verify their entropy condition (3.1) for the local entropy over SAC ,C for |C| = 1, · · · , s02 and |A| = 1, · · · , s01. Under Assumption 2 ε = εn,p = (2c0) 1/2c−14 log(2 1/2/c3) log p( s01 n ) 1/2 satisfies there with respect to ε > 0, that is,\nsup {0≤|A|≤p0}\n∫ 21/2ε\n2−8ε2 H1/2(t/c3,Fji)dt ≤ p1/20 21/2ε log(2/21/2c3) ≤ c4n1/2ε2. (16)\nfor some constant c3 > 0 and c4 > 0, say c3 = 10 and c4 = (2/3)5/2 512 . By Assumption 2, Cmin(x 0) ≥ ε2n,p0,p implies (16), provided that s01 ≥ (2c0)1/2c−14 log(21/2/c3).\nNote that |Bi| = ( s02 s02−i )∑i j=0 (|G|−s02 j ) ≤ (|G|(|G| − s02)i ≤ (|G|2/4)i by the binomial coefficients formula.\nMoreover, ∑s01 j=1 2 jij ≤ is01 , and ∑j1+···+ji=j ( j j1,···ji ) 2j = (2i)j using the Multinomial Theorem. By Theorem 1 of [22], there exists a constant c2 > 0, say c2 = 4 27 1 1926 ,\nI ≤ s02∑\ni=1\n|Bi| s01∑\nj=1\n∑\n(j1,···ji)\n( j\nj1, · · · ji\n) 2j1 · · · 2ji exp ( − c2niCmin(x0) )\n≤ s02∑\ni=1\nexp ( − c2niCmin(x0) + 2i(log |G|+ log s01) )\n≤ exp ( − c2nCmin(x0) + 2(log |G|+ log s01) ) .\nLet G = {x̂ 6= x̂0}. For the risk property, Eh2(x̂,x0) = Eh2(x̂0,x0)+Eh2(x̂,x0)I(G) is upper bounded by\nEh2(x̂,x0) + exp ( − c2nCmin(x0) + 2(log |G|+ log s01) ) = (1 + o(1))Eh2(x̂0,x0),\nusing the fact that h(x̂,x0) ≤ 1. This completes the proof."
    }, {
      "heading" : "2 Proof of Theorem 3",
      "text" : "We utilize an intermediate lemma from [4]:\nLemma 2. Let X be a metric space and U be a normed space. Suppose that for all x ∈ X, the function ψ(x, ·) is differentiable and that ψ(x, Y ) and DY ψ(x, Y ) (the partial derivative of ψ(x, Y ) with respect to Y ) are continuous on X × U . Let Φ be a compact subset of X. Define the optimal value function as φ(Y ) = infx∈Φ ψ(x, Y ). The optimal value function φ(Y ) is directionally differentiable. In addition, if for any Y ∈ U , ψ(·, Y ) has a unique minimizer x(Y ) over Φ, then φ(Y ) is differentiable at Y and the gradient of φ(Y ) is given by φ′(Y ) = DY ψ(x(Y ), Y ).\nProof of Theorem 3. For the proof, an intermediate lemma will be used, with its details given in the Appendix. Since both constraints are active, if (x, λ, η) = SGLP(v, s1, s2), then x and λ are also the optimal solutions to the following problem:\nmaximize λ minimize x∈X\nψ(x, λ) = 1\n2 ‖x− v‖22 + λ(‖x‖1 − s1),\nwhere X = {x : ‖x‖G ≤ s2}. By Lemma 2, φ(λ) = infx∈X ψ(x, λ) is differentiable with the derivative given by ‖x‖1. In addition, as a pointwise infimum of a concave function, so does φ(λ) [6] and its derivative, ‖x‖1, is non-increasing. Therefore s1 = ‖x‖1 is non-decreasing as λ becomes smaller. This completes the proof.\n3 Algorithm for Solving (13)\nWe give a detailed description of algorithm for solving the restricted projection (13) in Algorithm 3.\nAlgorithm 3 Restricted Sparse Group Lasso Projection Algorithm\nInput: v, s1, s2, T1, T3 Output: an optimal solution x to the Restricted Sparse Group Projection Problem (13)\nFunction RSGLP(v, s1, s2, T1, T3)\n1: if ‖xT1‖1 ≤ s1 and ‖xT3‖G ≤ s2 then 2: return v 3: end if 4: x (T1) c\nC1 = v(T1)\nc\n, xT1C1 = P s1 1 (v T1)\n5: x (T3)\nc\nC2 = v(T3)\nc\n, xT3C2 = P s2 G (v T3)\n6: x (T1)\nc\nC12 = v(T1)\nc\n, xT1C12= bisec(v, s1, s2, T1, T3)\n7: if ‖xT3C1‖G ≤ s2 then 8: return xC1 9: else if ‖xT1C2‖1 ≤ s1 then\n10: return xC2 11: else 12: return xC12 13: end if\nFunction bisec(v, s1, s2, T1, T3)\n1: Initialize up, low and tol 2: while up− low > tol do 3: λ̂ = (low + up)/2 4: if (15) has a solution η̂ given vλ̂ then\n5: calculate ŝ1 using η̂ and λ̂. 6: if ŝ1 ≤ s1 then 7: up = λ̂ 8: else\n9: low = λ̂ 10: end if 11: else 12: up = λ̂ 13: end if 14: end while 15: λ∗ = up 16: Solve (15) to get η∗ 17: Calculate (x∗)T1 from λ∗ and η∗. 18: return (x∗)T1"
    }, {
      "heading" : "4 Accelerated Gradient Method",
      "text" : "The AGM procedure is listed in Algorithms 4, in which f(x) is the objective function 12‖Ax − y‖22 with ∇f(x) denotes its gradient at x. In addition, fL,u(x) is the linearization of f(x) at u defined as follows:\nfL,u(x) = f(u) +∇f(u)T (x− u) + L\n2 ‖x− u‖22.\nAlgorithm 4 Accelerated Gradient Method [18, 2] for (7)\nInput: A, y, s1, s2, L0, x0, Output: solution x to (7) 1: Initialize: L0, x1 = x0, α−1 = 0, α0 = 1, t = 0. 2: repeat\n3: t = t+ 1, βt = αt−2−1 αt−1 , ut = xt + βt(xt − xt−1) 4: Line search: Find the smallest L = 2jLt−1 such that\nf(xt+1) ≤ fL,ut(xt+1),\nwhere xt+1 = SGLP(ut − 1L∇f(ut), s1, s2) 5: αt+1 = 1+ √ 1+4α2t 2 , Lt = L. 6: until Converge 7: return xt"
    }, {
      "heading" : "5 ADMM Projection algorithm",
      "text" : "ADMM is widely chosen for its capability of decomposing coupled variables/constraints, which is exactly the case in our projection problem. Before applying ADMM, we transform (8) into an equivalent form as follows:\nminimize x\n1 2 ‖x− v‖22\nsubject to ‖u‖1 ≤ s1 ‖w‖G ≤ s2 u = x,w = x.\nThe augmented Lagrangian is:\nL(x,λ,η) = 1 2 ‖x− v‖22 + λT (u− x) + ηT (w − x)\n+ ρ\n2 (‖u− x‖22 + ‖w − x‖22).\nUtilize the scaled form [5], i.e., let λ = λρ , η = η ρ , we can obtain an equivalent augmented Lagrangian:\nL(x,λ,η) = 1 2 ‖x− v‖22 + ρ 2 (‖x− u− λ‖22 + ‖x−w − η‖22)\n− ρ 2 (‖λ‖22 + ‖η‖22).\nNow we calculate the optimal x, λ and η through alternating minimization. For fixed u and w, the optimal x possesses a closed-form solution:\nx = 1\n1 + 2ρ (v + ρ(u+ λ +w + η)) .\nFor fixed x and u, finding the optimal w is a group lasso projection:\nminimize w\n1 2 ‖w − (x− η)‖22\nsubject to ‖w‖G ≤ s2 (17)\nFor fixed x and w, finding the optimal u amounts to solve an L1-ball projection:\nminimize u\n1 2 ‖u− (x− λ)‖22\nsubject to ‖u‖1 ≤ s1. (18)\nThe update of multipliers is standard as follows:\nλ = λ+ u− x η = η +w − x (19)\nAlgorithm 5 summarizes the above procedure. Note that, the value of the penalty term ρ is fixed in Algorithm 5. However, in our implementation, we increase ρ whenever necessary to obtain faster convergence.\nAlgorithm 5 ADMM [5] for (8)\nInput: v, s1, s2 Output: an optimal solution x to (8) 1: Initialize: x0, u0, w0, λ0, η0, t = 0, ρ > 0 2: repeat\n3: t = t+ 1 4: xt = 1 1+2ρ (v + ρ(ut−1 + λt−1 +wt−1 + ηt−1)) 5: wt = Ps2G (xt − ηt−1) 6: ut = Ps11 (xt − λt−1) 7: λt = λt−1 + ut − xt, ηt = ηt−1 +wt − xt. 8: until Converge 9: return xt"
    }, {
      "heading" : "6 Dykstra’s Algorithm",
      "text" : "Dykstra’s algorithm is a general scheme to compute the projection onto intersections of convex sets. It is carried out by taking Euclidean projections onto each convex set alternatively in a smart way and is guaranteed to converge for least squares objective function [7]. The details of applying Dykstra’s Algorithm to our projection problem are listed in Algorithm 6.\nAlgorithm 6 Dykstra’s Algorithm [7] for (8)\nInput: v, s1, s2 Output: an optimal solution x to (8) 1: Initialize: x0 = v, p0 = 0, q0 = 0, t = 0 2: repeat\n3: t = t+ 1 4: yt−1 = Ps2G (xt−1 + pt−1) 5: pt = xt−1 + pt−1 − yt−1 6: xt = Ps11 (yt−1 + qt−1) 7: qt = yt−1 + qt−1 − xt 8: until Converge 9: return xt"
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "Sparse feature selection has been demonstrated to be effective in handling high-dimensional data.<lb>While promising, most of the existing works use convex methods, which may be suboptimal in terms<lb>of the accuracy of feature selection and parameter estimation. In this paper, we expand a nonconvex<lb>paradigm to sparse group feature selection, which is motivated by applications that require identifying<lb>the underlying group structure and performing feature selection simultaneously. The main contributions<lb>of this article are twofold: (1) statistically, we introduce a nonconvex sparse group feature selection<lb>model which can reconstruct the oracle estimator. Therefore, consistent feature selection and parameter<lb>estimation can be achieved; (2) computationally, we propose an efficient algorithm that is applicable to<lb>large-scale problems. Numerical results suggest that the proposed nonconvex method compares favorably<lb>against its competitors on synthetic data and real-world applications, thus achieving desired goal of<lb>delivering high performance.",
    "creator" : "LaTeX with hyperref package"
  }
}