{
  "name" : "1301.2012.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Error Correction in Learning using SVMs",
    "authors" : [ "Srivatsan Laxman", "Sushil Mittal", "Ramarathnam Venkatesan" ],
    "emails" : [ "slaxman@microsoft.com", "mittal@stat.columbia.edu", "venkie@microsoft.com" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Learning in the presence of noise is notoriously difficult; there are many negative results regarding hardness of learning under adversarial or malicious noise Ben-David et al. (2003); Feldman et al. (2006); Guruswami and Raghavendra (2006); Hastad (1997); Kearns et al. (1994); Long and Servedio (2011), while positive results are mostly known only for the case of random noise or under strong distributional assumptions Blum et al. (1996); Kalai et al. (2008); Sastry et al. (2010); Servedio (2003). Somewhat more encouraging results exist in max-margin settings Buja and Stuetzle (2000); Har-peled et al. (2006); Shalev-Shwartz et al. (2010); Xu et al. (2006) but these methods are computationally prohibitive even for reasonably-sized data.\nIn this paper, we investigate the learning of binary classifiers under adversarial (worstcase) label-noise. We introduce the problem of error-correction in learning, as the task\nar X\niv :1\n30 1.\n20 12\nv1 [\ncs .L\nof correcting the label-errors in training data, D̂, given that the original (clean) data, D, intrinsically satisfies some regularity properties. (Given negative results such as Guruswami and Raghavendra (2006) regarding the hardness of learning better-than-random hyperplanes even from nearly-separable data, some notion of regularity becomes essential). Informally, D is said to be r-regular if SVMs trained on very small random r-subsets of D, make less than θ-fraction errors over all of D. We show that every linearly separable D exhibits some regularity, and that such a D can be recovered from any D̂ with roughly (12−2θ−O(log\n2 r))fraction of errors. The main idea in our analysis is to apply margin-based generalization bounds under a chosen sampling distribution over D and to then adjust the bounds for the noise in D̂. To the best of our knowledge, this is the first positive result that is known about learning classifiers under adversarial label-errors.\nOur algorithm for error-correction, called SubSVMs (Subsample bagging of SVMs) is as follows: Train SVMs on suitably-small, class-balanced, random subsets of D̂ and reclassify every training point using a simple majority vote. We show that class-balanced sampling over D̂ minimizes the worst-case probability of drawing less than any-chosen-number of clean points per class from D̂. The number of worst-case errors that each SVM in the ensemble makes can grow as the squared-log of the subsample-size used, and this leads us to the final error-correction performance of SubSVMs.\nIn experimental work, we first study the error-correction achievable on synthetic linearly separable data. By comparing against performance under uniform sampling (common in standard bagging) we show that class-balanced sampling plays a vital role in errorcorrection. Then we show that error-correction based on SubSVMs leads to better classifiers which outperform regular SVMs on a range of benchmark data sets from the UCI Machine Learning Repository. Our experiments also clearly demonstrate superiority of SubSVMs over regular bagging. We inject high-levels of label-noise in the training data sets (Number of errors was fixed at 75% of the size of the minority class). On previously unseen (clean) test sets, SubSVMs even outperformed SVMs that directly used the full test sets for cross-validation. Subsampling at logarithmic sizes also gives SubSVMs substantial run-time advantages over standard SVMs and regular bagging.\nRelated Work: Several results show that learning under adversarial noise can be NPhard Hastad (1997); Kearns et al. (1994); Feldman et al. (2006); Guruswami and Raghavendra (2006). Better results (polynomial-time algorithms) are known in the context of learning max-margin classifiers from noisy data Har-peled et al. (2006); Shalev-Shwartz et al. (2010); Xu et al. (2006). However, these techniques are computationally prohibitive in practice, e.g., the method proposed in Xu et al. (2006) uses SDP solvers that can become impractical even for a hundred training points. Many boosting algorithms, with convex potential functions, have also been shown vulnerable to random classification noise Long and Servedio (2010).\nIn statistical (rather than adversarial) settings, generalization results for SVMs demonstrate efficient learnability when training and test points are drawn iid from the same (even if noisy) distribution Christianini and Shawe-Taylor (2000). Some works have focused on the ineffectiveness of SVMs in the presence of outliers and for noisy class-imbalanced data (e.g., see Akbani et al. (2004); Trafalis and Gilbert (2005); Nath and Bhattacharyya (2007)), albeit without formal analysis. Recently, large-margin half-spaces were shown to be efficiently learnable under small amounts of malicious noise Long and Servedio (2011).\nSimilarly, Dekel and Shamir (2009) demonstrates learning from multi-teacher data, where a small number of teachers can replace randomly chosen examples arbitrarily. A general framework for distribution-dependent learning in-the-limit was proposed in Caramanis and Mannor (2008); the focus, however, was on establishing informational limits rather than sample complexities. We consider learning under adversarial label-errors given that the original data satisfies some regularity properties. Our error-model is relevant both when the label-errors are inadvertent, whether systematic or random, and when errors are introduced by an adversary explicitly trying to mislead the learning process.\nSeveral studies investigated why (and under what conditions) bagging works by formalizing different notions of stability for predictors and by showing that bagging reduces the variance of unstable predictors (see, e.g., Breiman (1996); Buhlmann and Yu (2002); Elisseeff et al. (2005); Grandvalet (2004)). Experimental bias-variance analysis of random aggregation and bagging of SVMs demonstrated that working with small samples achieves greater reduction in the variance component of error than standard bagging (see Valentini (2004)). In another related work, Brodley and Friedl (1999) presented an experimental study of various methods for identifying mislabeled data. All these studies, including the ones that analyze bagging, restricted attention to distribution-based models, rather than adversarial settings."
    }, {
      "heading" : "2. Error correction problem in learning",
      "text" : "Let D = {(xi, yi) : i = 1, . . . , `} be the set of examples in a binary classification problem; the feature vectors, xi, come from some domain X and the class-labels, yi, take values from {−1,+1}. The proportion of minority class points in D is denoted β, 0 < β ≤ 0.5.\nLet ΨD denote a binary SVM classifier trained on D 1; for x ∈ X , the classifier returns the label ΨD(x) ∈ {−1,+1}. We assume that ΨD is suitable for the given classification task. However, D is not available to train the learning algorithm. Instead, the learner only has access to D̂ = {(xi, ŷi) : i = 1, . . . , `}, which is a label-manipulated version of D2.\nThe adversary is allowed to flip labels of no more than ρβ` examples in D, where ρ is referred to as the error parameter. Since we place no other restrictions on the points the adversary can manipulate, we must have the constraint 0 ≤ ρ < 1 (otherwise, we may be left with no training examples for one class).\nThe error-correction problem is concerned with recovering the original clean data D (or a close approximation of it) from its label-manipulated version D̂. To this end, we will allow some ‘regularity’ assumptions on the original data D, which essentially guarantee that SVMs trained on sufficiently-small random subsets of D can classify the points in D with high accuracy. Regularity is an intrinsic property of the original data, which can manifest and be measured in many ways; one way is to measure the redundancy structure exposed by the quadratic program underlying the max-margin formulation of SVMs.\nDefinition 1 (Data Regularity) Let D∗ be any (discrete) probability distribution over D and let S ∼ D∗, |S| ≥ r, denote a collection of points drawn iid from D∗. For any δ < 0.5 and θ < 0.5, D is said to be r-regular at (δ, θ) if with probability at least 1− δ over choice\n1. ΨS denotes the SVM trained on S, etc. 2. D̂ is also referred to as the corrupted or noisy data.\nof S, the expected error-rate of ΨS does not θ with respect to test examples also drawn iid from D∗.\nWe are interested in regularity at small r, such as at O(log `) or O(log2 `). Data regularity can be thought of as a measure of redundancy needed to admit learning in the presence of adversarial label-noise. This is, in a sense, akin to the redundancy encoded into a message for enabling error-correction in coding theory. Regularity is a simple property that is satisfied by data from which good binary classifiers can be easily learnt, e.g., every linearly separable data set is regular.\nLemma 2 (Separability implies Regularity) Consider any linearly separable D with margin γ. For any fixed δ < 0.5 and θ < 0.5, there exists r ∈ Z+ such that D is r-regular at (δ, θ).\nThe proof makes use of the following 2-norm soft-margin bound from SVM generalization theory Christianini and Shawe-Taylor (2000):\nTheorem 3 (Christianini and Shawe-Taylor, 2000, Theorem 4.22) Consider thresholding real-valued linear functions L with unit weight vectors on an inner product space X and fix γ ∈ R+. There is a constant c, such that for any probability distribution D on X ×{−1,+1} with support in a ball of radius R around the origin, with probability 1 − δ over ` random (training) examples D = {(x1, y1), . . . , (x`, y`)}, any hypothesis f ∈ L has error no more than\nPr (x,y)∼D [f(x) 6= y] ≤ c `\n( R2 + ‖ξ‖22\nγ2 log2 `+ log\n1\nδ\n) (1)\nwhere ξ = (ξ1, . . . , ξ`) is the margin slack vector with respect to f and γ. The entries of ξ are fixed as follows: ξi = max(0, γ − yif(xi)), i = 1, . . . , `.\nSince D is separable with margin γ, every subset of D is also separable with margin at least γ. Thus, the max-margin separator of every subset of D will have margin slack vector ξ = 0 (with respect to the chosen subset). Fixing D = D∗ in Theorem 3, the generalization error of ΨS trained on any S ∼ D∗, |S| = r, is given by\nPr (x,y)∼D∗\n[ΨS(x) 6= y] ≤ c\nr\n( R2\nγ2 log2 r + log\n1\nδ\n) (2)\nLemma 2 follows since the RHS of (2) is O(log2 r/r).\nDefinition 4 (Error-correction in Learning) Given that D and D̂ disagree on no more than ρβ-fraction of labels, and given that D satisfies some regularity properties, the problem of error-correction in learning is to recover a data set D̃ with as few label disagreements with D as possible.\nWe make no assumptions regarding the nature of label-errors (such as if they are statistical or otherwise), or regarding the separate values of error-parameter (ρ) and true fraction of minority-class (β); we are only given that the total fraction of label-errors does not exceed ρβ, 0 ≤ ρ < 1 and 0 < β ≤ 0.5.\nAlgorithm 1 [SubSVMs] Subsampled bagging of SVMs\nInput: Corrupted data D̂ = {(x1, ŷ1), . . . , (x1, ŷ`)}; size, s, of subsample; sampling bias p; number of SVMs J (typically, p = 12 and s = log ` or s = log 2 `) Output: Error-corrected data D̃ = {(x1, ỹ1), . . . , (x1, ỹ`)}\n/∗ Training ∗/ for j = 1 to J do\nDraw random subset Ŝj ∼ DpD̂ of size |Ŝj | = s Train SVM Ψ\nŜj\n/∗ Error-correction ∗/ for i = 1 to ` do\nSet ỹi to the majority label in {ΨŜ1(xi), . . . ,ΨŜJ (xi)} Output D̃ = {(x1, ỹ1), . . . , (x1, ỹ`)}\n3. The SubSVMs algorithm\nWe first define a key ingredient of the SubSVMs algorithm that we refer to as p-biased sampling.\nDefinition 5 (p-biased Sampling) The process of p-biased sampling of D̂ refers to the following two steps, executed in the stated order: (1) choose the minority class3 of D̂ with probability p (or the other class with probability 1 − p) and (2) pick a point uniformly at random from the restriction of D̂ to the chosen class. The corresponding sampling distribution is denoted D\npD̂ and Ŝ ∼ D pD̂ denotes that Ŝ is a random collection of points drawn\niid with respect to D pD̂ .\nThe case of p = 0.5 is referred to as class-balanced sampling of D̂; if β̂ denotes the fraction of minority class points in D̂, the case of p = β̂ is equivalent to uniform sampling over D̂.\nAlgorithm 1 lists the pseudo-code for subsampled bagging of SVMs (SubSVMs). Our analysis (in Secs. 3.1-3.2) reveals two important aspects of SubSVMs:\n• Class-balanced sampling provides optimal protection against worst-case label-errors.\n• The fraction of errors that can be tolerated (ρβ) reduces as the squared-log of samplesize s.\nBased on the above, we use class-balanced sampling (p = 1/2) and choose s to be log ` or log2 `."
    }, {
      "heading" : "3.1 Error correction analysis",
      "text" : "Our analysis uses the margin-based generalization bound for SVMs with respect to a sampling distribution over the original (clean) data D and then adjusts the bound to accommodate the number of label-errors in the corrupted training set D̂.\n3. If both classes of D̂ are of identical size, one of them is arbitrarily fixed as the ‘minority class’.\nConsider the general case of Algorithm 1, where the random subsets Ŝj are drawn iid\nfrom D pD̂ . Let D be linearly separable with margin γ. Consider a set of points Ŝ ∼ D pD̂ . We now need to compute the expected error-rate of Ψ\nŜ with respect to test points drawn\nuniformly from D (This is the main quantity of interest in the error-correction setting). For this, we first compute the expected error-rate when the training and test cases are both drawn iid from D\npD̂ . This is done by using Theorem 3 (Christianini and Shawe-Taylor, 2000,\nTheorem 4.22) with f = Ψ Ŝ and D = D pD̂ (See next paragraph for details). The error-rate can at most become /p∗, where p∗ = min{p, 1 − p}, when considering test cases drawn uniformly from D̂4. Finally, in any uniformly drawn sample from D̂, the expected fraction of label disagreements with respect to the corresponding points in D is ρβ. Hence, the desired expected error-rate of Ψ\nŜ , where Ŝ ∼ D pD̂ but the test points are drawn uniformly\nfrom D, is given by /p∗ + ρβ. We now return to the computation of error-rate when train and test points are both drawn iid from D pD̂ . Whenever Ŝ contains at least r/2 clean points per class, the SVM of the corresponding r-size (clean) subset of Ŝ would make no more than (s− r) mistakes on the rest of Ŝ. Each of these mistakes would be no farther than 2R from either supporting hyperplane. Also, the margin of this SVM would be at least γ (the max-margin achieved on the whole of D). The 2-norm SVM objective has the same form as the error-bound in (1). Hence, we apply Theorem 3 with ‖ξ‖22 = 4R2(s− r) and with margin γ, to obtain the generalization bound, . If η is an upper-bound on the probability that Ŝ contains less than r/2 clean points from either class, then with probability at least (1− η − δ)\nPr (x,y)∼D\npD̂\n[Ψ Ŝ (x) 6= y] ≤ c\ns\n( R2 + 4R2(s− r)\nγ2 log2 s+ log\n1\nδ\n) def = .\nRecall that this error-rate, , over test points drawn from D pD̂ , translates to an error-rate of\n/p∗+ρβ for test points drawn uniformly over D. Thus, the final expression for probability of error of Ψ\nŜ with respect to test points drawn uniformly from D, denoted ϕ, can be\nwritten as follows:\nPr[Ψ Ŝ (x) 6= y] ≤ (1− η − δ)\n[\np∗ + ρβ\n] + η + δ def = ϕ.\nWe use J SVMs based on J random sets such as Ŝ. Thus, if ϕ < 0.5, then (by Hoeffding Inequality Hoeffding (1963)) the probability of a majority vote making a mistake with respect to D cannot exceed exp[−2J(0.5−ϕ)2]. This gives us error-correction (in the sense that D can be correctly recovered from D̂). To enforce the condition ϕ < 0.5, we must have ρβ < 1− /p∗ − [2(1− η − δ)]−1. Finally, if D is r-regular at (δ, θ), then we have\n= c\ns\n( R2\nγ2 log2 s+ log\n1\nδ\n) + c\ns\n( 4R2(s− r)\nγ2 log2 s ) ≤ θ + c\ns\n( 4R2(s− r)\nγ2 log2 s\n) . (3)\nThis leads to our main result about SubSVMs:\n4. See Appendix A for a short proof.\nTheorem 6 (Error-correction) Consider linearly separable D with margin γ and βfraction of minority-class points. Fix δ < 0.5 and let D be r-regular at (δ, θ). Consider D̂ with error-rate ρ and Ŝ ∼ D\npD̂ , |Ŝ| = s. Let Pr[Ŝ contains < r/2 clean points per class] ≤\nη. If the number of label-errors in D̂ is bounded by ρβ < 1− 2θ − [ 1\n2(1− η − δ) + 4R2c(s− r) log2 s γ2s\n] (4)\nwhere R denotes the radius of the ball enclosing the data and c is the constant from Theorem 3, then the probability of error for SubSVMs with respect to points drawn uniformly from D is at most exp [ −2J(0.5− ϕ)2 ] , where ϕ = η + δ + (1 − η − δ) [ /p∗ + ρβ] and p∗ = min{p, 1− p}.\nHence, perfect error-correction is attained for ϕ < 0.5."
    }, {
      "heading" : "3.2 Importance of Class-balanced Sampling",
      "text" : "The bound in (4) has two groups of parameters. In the first group, we have r, δ and θ, which are fixed by the regularity properties of D. In the second group, we have s and η, which are both determined by our sampling strategy. Since η depends on the sampling bias p, we now discuss how to fix p and s for optimal error-correction performance.\nFrom (4) it is clear that, to maximize the number of errors that can be tolerated, we must minimize the quantity in square brackets. The first term inside the brackets is minimized when η is minimum. Fig. 1 provides a graphical depiction of the data corruption process. The optimal value of η typically depends on the direction-of-attack parameter, α, the error parameter ρ, and the true size, β, of the minority class in D. However, neither of these is known to the learner; only an upper-bound on the fraction of label-errors in D̂ is known. So we design our algorithm to limit the impact of worst-case label-errors. Specifically, we choose p = 0.5 since it minimizes η in a manner that is agnostic to the true values of α, ρ and β. We state this formally in Lemma 7 below.\nLemma 7 (Class-balanced Sampling) Fix any r ∈ Z+. Given D with β-fraction of minority-class points and D̂ with at most ρβ-fraction label-errors w.r.t. D, class-balanced\nsampling of D̂ minimizes a worst-case upper-bound on η (probability that the sample drawn contains less than r/2 clean points per class) if the size, s (≥ r), of the sample satisfies\ns ≥ 2r + 4 ( r log 2 + log2 2− log 4 ) 1 2 + log 16− 4 (5)\nThe main intuition behind the proof is that, in the absence of any specific information regarding ρ, β and α, choosing the sampling bias p on either side of 0.5 is vulnerable to one of the attack directions, thereby increasing the worst-case value of η. (See Appendix B for the proof).\nThe second term inside the square brackets of (4) is smallest (and equal to zero) for s = r. However, Lemma 7 shows that this is not optimal for η, since s = r fails the condition in (5). In fact, for smaller s, η may even be maximized at p = 0.5; in general, the minimizer of η will no longer be agnostic to ρ, β and α. However, when s is set to the lower-bound of (5), the second term inside square brackets of (4) becomes O(log2 r). This gives us our next lemma.\nLemma 8 (Subsampled Bagging) Let D be linearly separable and r-regular at (δ, θ) and let D̂ contain at most (ρβ)-fraction of adversarial label-errors. SubSVMs based on classbalanced sampling and with subsample-size, s, set to the lower-bound in (5), can perfectly recover the original D, provided the fraction of label-errors in D̂ is bounded above as follows:\nρβ < 1− 2θ − [\n1\n2(1− η − δ) +O(log2 r)\n] (6)\nSince the above lemma requires s to be set at the lower-bound of (5) it might appear that we are operating on a knife-edge for choosing the subsample size. Luckily, this is not the case, because if the data is regular at r, it would also be regular with same θ for every r′ > r. Hence, we could set s to the lower bound in (5) corresponding to r′ and the above Lemma would still hold, though with O(log2 r′) rather than O(log2 r) inside the square brackets. As a result, the number of worst-case errors allowed reduces for r′ > r and this is the reason why we use subsampled bagging. Typically, we choose s to be log ` or log2 ` (rather than `, which is the usual case in bagging). As long as the data is r-regular for some r < s that satisfies (5) SubSVMs will give us error-correction. As a side-benefit subsampling at logarithmic sizes will give us dramatic run-time advantages over regular SVMs. Our experimental results clearly demonstrate this aspect of SubSVMs."
    }, {
      "heading" : "4. Experiments",
      "text" : "We present experimental results of SubSVMs on simulated, linearly separable data as well as LIBSVM extracts of some UCI data sets5. SVMs are known to perform well on these data sets, so they can play the role of clean data in our experiments.\nOur data corruption process follows Fig. 1. Given ‘clean’ training data D of size ` with minority class of size β`, 0 < β ≤ 0.5, the parameters ρ and α control the corruption. We randomly pick ρβ` points for corruption, of which, α-fraction are picked uniformly at\n5. http://www.csie.ntu.edu.tw/∼cjlin/libsvmtools/datasets\nrandom from the minority class and (1− α)-fraction from the other. By varying the attack direction α, we generated a wide range of corrupted data with different degrees of difficulty for binary classification."
    }, {
      "heading" : "4.1 Synthetic Data Experiments",
      "text" : "In the first experiment, we generated ‘clean’ data sets D comprising of 1000 d-dimensional data points from a mixture of two Gaussian distributions, each with a covariance of 0.1Id and a distance of two units between means. Three values of d were used: 2, 16 and 30. A constant margin of 0.2 units was enforced and misclassified points were manually removed. The value of β was varied between [0.05, 0.5] in steps of 0.05, ρ = 0.75 and α was varied between [0.0, 1.0] in steps of 0.25.\nWe studied the importance of class-balanced sampling in Algorithm 1 (SubSVMs) by comparing two versions of it - one with class-balanced sampling (p = 1/2) and the other with uniform sampling (p = β). For every d, the data corresponding to each [β, α] pair was subjected to 10 random corruptions. Figs. 2a and 2b summarize the results for class-\nbalanced sampling and Figs. 2c and 2d for uniform sampling. As expected, based on Theorem 6, the number of mistakes made decays exponentially with increasing J . Nearperfect error-correction is achieved using p = 1/2 for J as small as 27. For p = β, the worst-case and average-case performances are worse by about 60% and 20%, respectively. This experimentally validates Lemma 7 for using class-balanced sampling in SubSVMs."
    }, {
      "heading" : "4.2 UCI Data Experiments",
      "text" : "We now report the performance of SubSVMs on held-out test data using the LIBSVM UCI extracts. There can be two ways to test this, either the error-corrected training data can be used to retrain a fresh standard SVM or we can just use majority voting over the J SVMs already trained in SubSVMs. In our experiments, both these approaches yielded very similar results. Therefore, we avoid retraining cost and report results using the majority voting method.\nTable 1 shows the data characteristics of the 13 data sets used. The fraction of the minority class, β ranges from 0.03 to 0.48 in training sets and from 0.03 to 0.50 in test sets. Also, the feature dimension varies between 4 to 300. Note that although these data sets are not linearly separable, they are still referred to as ‘clean’ before they are subjected to label-manipulation. For generating different types of attacks, ρ = 0.75 was used while the value of α was varied between [0.0, 1.0] in steps of 0.25. We compare SubSVMs against of four other SVM-based classifiers:\n1. Oracle-SVM: Standard SVM learnt over training data with parameters fixed by crossvalidating directly over clean test set.\n2. Blind-SVM: Standard SVM learnt over training data with parameters fixed based on the best average performance over all test sets. This is similar to Oracle-SVM, except\nthat a single set of parameters is used for all data sets. This helps assess the feasibility of blindly fixing the same set of parameters for all test sets.\n3. Bag-SVM: Regular bagging of SVMs where each SVM in the ensemble is trained on a bootstrap sample of size same as the original data (sampled with replacement). All SVMs use the same set of optimum parameters, which were determined through test set cross-validation of Oracle-SVM.\n4. CV-SVM: Standard SVM with parameters chosen through four-fold cross-validation on the training data. In all the experiments, the results of CV-SVM are averaged over five different random splits of the training data for cross-validation.\nAll cross-validations were performed by varying the penalty parameter C between 1 and 100, ratio of the weights of the two classes W between 0.1 and 10 and the RBF kernel parameter σ2 between 0.1/d and 10/d, where d is the data dimensionality. For SubSVMs, the values of C = 100, w = 1, σ2 = 1/d, s = log2 ` and J = 1000 were fixed for all data sets without performing any sort of cross-validation. All the SVMs were trained under L-2 loss, although similar results were also obtained under L-1 loss.\nNote that Oracle-SVM, Blind-SVM and Bag-SVM use information about test set labels to obtain their corresponding set of optimum parameters for training. This gives them an unfair advantage over CV-SVM and SubSVMs that are both agnostic to test set labels.\nPerformance measure: The UCI data sets exhibit a wide range of class imbalance - a1a–a5a are moderately imbalanced, splice, mushrooms and svmguide1 are class-balanced while w1a–w5a are highly imbalanced. For imbalanced data, high accuracies can be trivially achieved by labeling all points with the majority class label. Since accuracy is ineffective in such settings, we use its skew-insensitive version called Balanced Accuracy6 (BAC) Brodersen et al. (2010). Note that for class-balanced data, BAC reduces to accuracy.\nTable 2 summarizes the results of all the five methods on clean as well as corrupted versions of the data. For every data set, 10 random corruptions were performed w.r.t. the corresponding attack direction α and the averaged results are reported. Winning results, when significantly better than the rest, are highlighted7.\n• SubSVMs is almost always significantly better than all the other methods (by 5% or more) and is never significantly worse. The advantage of SubSVMs is visible in both balanced and imbalanced data; for imbalanced data, the advantage increases for smaller α. This is because the quality of minority-class data falls sharply with α.\n• Oracle-SVM is at least as good as Blind-SVM. This is because Oracle-SVM tunes parameters individually for each test set, while Blind-SVM fixes the same parameters across all test sets.\n• Oracle-SVM, Blind-SVM and Bag-SVM are better than CV-SVM. This is because all three methods cross-validate directly on the test sets.\n6. See Appendix C for details of this measure. 7. Std. devs. were negligible (mostly < 0.02, max 0.06).\n• Bag-SVM’s performance is similar to that of Oracle-SVM. This is consistent with Valentini (2004) that also reported no benefit in bagging SVMs (since SVMs are stable classifiers).\n• CV-SVM is the worst performing method and is often significantly worse than others8. This shows its ineffectiveness under noisy settings.\nSimilar results were also obtained using Skew-Insensitive F-score (SIF) Flach (2003). Results using Area Under the Curve (AUC) and accuracy, their unsuitability for imbalanced data notwithstanding, are reported in Appendix D.\n8. The case of clean, balanced data is the only exception.\nRun-times: Table 3 summarizes training times averaged over different types of attacks. SubSVMs is clearly much faster than all other methods9. While our experiments were based on single-core implementations, SubSVMs can be easily parallelized to handle very large-scale problems."
    }, {
      "heading" : "5. Conclusions",
      "text" : "We present a simple algorithm (SubSVMs) for learning binary classifiers under adversarial label-noise. SubSVMs can efficiently correct a bounded number of adversarial label-errors introduced in linearly separable data. Extensions to handle attribute noise and multi-class settings are important directions for future work. It would also be interesting to explore applicability of SubSVMs for solving large, noisy, real-world problems, where SVMs typically perform poorly.\n9. See Appendix D for more detailed run-times."
    }, {
      "heading" : "Appendix A. Error-rate of ΨŜ w.r.t. samples drawn uniformly from D̂",
      "text" : "Let 1 and 2 be the class conditional error rates for the two classes. Without loss of generality let 2 ≥ 1. In the absence of the knowledge whether 2 is associated with the minority class or the majority class, the overall error rate of Ψ\nŜ w.r.t. samples drawn iid\nfrom D pD̂ is given by\n= max (p 1 + (1− p) 2, (1− p) 1 + p 2) ≤ 2. (7)\nTherefore, if = p 1 + (1− p) 2, then\n2 = − p 1 1− p ≤ 1− p\n(8)\nand if = (1− p) 1 + p 2, then\n2 = − (1− p) 1\np ≤ p . (9)\nTherefore,\n2 < max\n(\n1− p , p\n) =\np∗ (10)\nwhere p∗ = min{p, 1− p}.\nAppendix B. Proof for optimality of class-balanced sampling (p = 0.5)\nConsider a two-class classification problem where the two classes are represented by A and B. Without loss of generality, let A be the minority class containing 0 < β ≤ 0.5 fraction of the points. Let Â and B̂ represent the two classes after one or both the classes are corrupted with adversarial noise. Let ρβ, 0 ≤ ρ < 1 represent the upper limit on the fraction of corrupted points. Therefore, the total number of corrupted points can be written as nc = ρβ`. Further, let α be the fraction of the corrupted points that were originally in class B but were assigned to class A. Therefore, the fraction of the new classes can be given by\n|Â| = β + αρβ − (1− α)ρβ (11)\n|B̂| = 1− β − αρβ + (1− α)ρβ (12)\nMoreover, the fraction of good (clean) and bad (mislabeled) points in both the classes are\n|Âg| = β − (1− α)ρβ (13)\n|Âb| = αρβ (14)\n|B̂g| = 1− β − αρβ (15)\n|B̂b| = (1− α)ρβ (16)\nTherefore, the conditional probability of picking a good or a bad point for both the classes are given by\nP (ag|Â) = |Âg| |Â| = 1− (1− α)ρ 1 + αρ− (1− α)ρ (17)\nP (ab|Â) = |Âb| |Â| = αρ 1 + αρ− (1− α)ρ (18)\nP (bg|B̂) = |B̂g| |B̂| = 1− β − αρβ 1− β − αρβ + (1− α)ρβ (19)\nP (bb|B̂) = |B̂b| |B̂| = (1− α)ρβ 1− β − αρβ + (1− α)ρβ (20)\nAssuming that the probability with which points from classes Â and B̂ are picked is given by P (Â) = p and P (B̂) = 1− p respectively, the probability of picking up a good or a bad point for both the classes are respectively given by P (ag) = P (ag|Â)p, P (ab) = P (ab|Â)p, P (bg) = P (bg|B̂)(1− p) and P (bb) = P (bb|B̂)(1− p).\nThe probability η of not picking r/2 clean points from either class is upper bounded by\nη ≤ r/2−1∑ k=0 ( s k ) (P (ag)) k (1− P (ag))s−k + r/2−1∑ k=0 ( s k ) (P (bg)) k (1− P (bg))s−k . (21)\nFor worst case analysis, we need to maximize η and therefore, minimize both P (ag) and P (bg), which in turn requires minimizing P (ag|Â) and P (bg|B̂) w.r.t. both α and β. Differentiating P (ag|Â) w.r.t α\ndP (ag|Â) dα = ρ(−1 + ρ) (1− ρ+ 2αρ)2 ≤ 0. (22)\nTherefore, arg min\nα P (ag) = 1. (23)\nSimilarly, differentiating P (bg|B̂) w.r.t. α\ndP (bg|B̂) dα = ρβ(1− β(1 + ρ)) (1− β + ρβ − 2αρβ)2 ≥ 0 (24)\nTherefore, arg min\nα P (bg) = 0. (25)\nAlso,\ndP (bg|B̂) dα = −ρ(1− α) (1− β + ρβ − 2αρβ)2 ≤ 0 (26)\nimplying that\narg min β P (bg) =\n1 2 . (27)\nSubstituting α = 1 in P (ag) and α = 0, β = 1/2 in P (bg), we get\nminP (ag) = p\n1 + ρ and minP (bg) = 1− p 1 + ρ . (28)\nTherefore, the worst case bound for (21) can be written as\nη ≤ r/2−1∑ k=0 ( s k )( p 1 + ρ )k ( 1− p 1 + ρ )s−k + r/2−1∑ k=0 ( s k )( 1− p 1 + ρ )k ( 1− 1− p 1 + ρ )s−k . (29)\nApplying Hoeffding bound Hoeffding (1963) individually on each of the two terms\nη ≤ 1 2 exp ( −2 s ( sp 1− ρ − r 2 + 1 )2) + 1 2 exp ( −2 s ( s(1− p) 1 + ρ − r 2 + 1 )2) (30)\nas long as sp1+ρ > r 2 − 1 and s(1−p) 1+ρ > r 2 − 1. The RHS of 30 can be rewritten as\nf = 1\n2 exp −1 2 p− (r−2)(1+ρ)2s( 1+ρ 2 √ s ) 2+ 1 2 exp −1 2 (1− p)− (r−2)(1+ρ)2s( 1+ρ 2 √ s ) 2 (31)\nwhich is simply the sum of two Gaussian with means µ1 = (r−2)(1+ρ) 2s and µ2 = 1− (r−2)(1+ρ) 2s and equal variance σ = 1+ρ 2 √ s . Differentiating the above expression w.r.t. p\ndf dp = −\n2 (\nsp 1+ρ − r 2 + 1 ) exp ( 2 s ( sp 1+ρ − r 2 + 1 )2) (1 + ρ) + 2 ( s(1−p) 1+ρ − r 2 + 1 ) exp ( 2 s ( s(1−p) 1+ρ − r 2 + 1 )2) (1 + ρ) . (32)\nIt can be clearly seen that p = 0.5 is a solution of (32). Also, the sum of two Gaussians can be either unimodal (p = 0.5 is global maximum) or bimodal (p = 0.5 is a minimum) Behboodian (1970). The second order derivative of f w.r.t. p can be written as\nd2f\ndp =\n8 (\nsp 1+ρ − r 2 + 1\n)2 − 2s\nexp ( 2 s ( sp 1+ρ − r 2 + 1 )2) (1 + ρ)2\n+ 8 ( s(1−p) 1+ρ − r 2 + 1 )2 − 2s\nexp ( 2 s ( s(1−p) 1+ρ − r 2 + 1 )2) (1 + ρ)2 . (33)\nTherefore, enforcing a minimum at p = 0.5, we get the condition that\nd2f\ndp ∣∣∣ p=0.5 = 32 ( s 2(1+ρ) − r 2 + 1 )2 exp ( 2 s ( s 2(1+ρ) − r 2 + 1 )2) (1 + ρ)2 − 8s exp ( 2 s ( s 2(1+ρ) − r 2 + 1 )2) (1 + ρ)2 ≥ 0.\n(34) This directly implies that\ns ≥ (ρ+ 1) ( r − 2 + 1\n2 (ρ+ 1)\n( 1 + ( 4r + ρ− 7 ρ+ 1 )1/2)) (35)\nwhich, as expected, is a stronger condition than the one required for imposing the Hoeffding bound at p = 0.5, i.e., s > (1 + ρ)(r − 2). Furthermore, to enforce p = 0.5 to be the global minimum, we impose the condition that the value of f at p = 0.5 is strictly less than that at any of the two extreme points of f (i.e., at p = 1s (1+ρ)(r/2−1) and p = 1− 1 s (1+ρ)(r/2−1)). This gives us an even stronger condition\ns ≥ (ρ+ 1) ( r − 2 + (ρ+ 1) ( log 2 + ( log 2(log 2 + 2r + ρ log 2− 4)\nρ+ 1\n)1/2)) . (36)\nThis is the sufficient condition to guarantee that the worst case probability of selecting less than r/2 clean points per class is minimum at p = 0.5, i.e., when class-balanced sampling is performed over the data."
    }, {
      "heading" : "Appendix C. Details of performance metrics",
      "text" : "For class-imbalanced data sets, very high classification accuracy can be trivially obtained by labeling the entire data with the majority class label. The use of Balanced Accuracy (BAC) for class-imbalanced data sets is prescribed by Brodersen et al. (2010) and can be simply computed as\nBAC = sensitivity + specificity\n2 . (37)\nThe sensitivity and specificity are defined as follows\nsensitivity = tp\ntp+ fn (38)\nspecificity = tn\ntp+ fn (39)\nwhere tp and fp denote the number of true and false positives while tn and fn denote the number of true and false negatives.\nSimilarly, traditional F-score can be trivially maximized for imbalanced data sets by compromising recall for high precision. Therefore, SIF Flach (2003) serves as an alternative to the F-score for imbalanced data sets and is given by\nSIF = 2tpr\ntpr + fpr + 1 (40)\nwhere tpr and fpr are true and false positive rates respectively. Like BAC, SIF also reduces to traditional F-score for class-balanced data sets. Another popular metric for comparison of classification performances is Area Under the ROC Curve (AUC). Although, unlike BAC and SIF, AUC is not a skew-insensitive measure, we also computed AUC measures for all the methods. It is important to mention that SubSVMsis always comparable to that of the other methods w.r.t. AUC. Finally, we note that for the results reported using AUC, we needed to retrain an SVM on the error-corrected data (unlike earlier, when we directly used majority voting on the test data)."
    }, {
      "heading" : "Appendix D. Additional Results",
      "text" : "Tables 4, 5 and 6 present additional results on the UCI data sets under L-2 loss using Skew-Insensitive F-Score (SIF), Area Under the Curve (AUC) and Accuracy, respectively. Table 7 shows detailed run-times corresponding to Table 3 in the paper."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2013,
    "abstractText" : "This paper is concerned with learning binary classifiers under adversarial label-noise. We introduce the problem of error-correction in learning where the goal is to recover the original clean data from a label-manipulated version of it, given (i) no constraints on the adversary other than an upper-bound on the number of errors, and (ii) some regularity properties for the original data. We present a simple and practical error-correction algorithm called SubSVMs that learns individual SVMs on several small-size (log-size), class-balanced, random subsets of the data and then reclassifies the training points using a majority vote. Our analysis reveals the need for the two main ingredients of SubSVMs, namely class-balanced sampling and subsampled bagging. Experimental results on synthetic as well as benchmark UCI data demonstrate the effectiveness of our approach. In addition to noise-tolerance, log-size subsampled bagging also yields significant run-time benefits over standard SVMs.",
    "creator" : "LaTeX with hyperref package"
  }
}