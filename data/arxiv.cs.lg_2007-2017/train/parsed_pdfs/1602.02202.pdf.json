{
  "name" : "1602.02202.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Efficient Second Order Online Learning by Sketching",
    "authors" : [ "Haipeng Luo", "Alekh Agarwal" ],
    "emails" : [ "haipengl@cs.princeton.edu", "alekha@microsoft.com", "nicolo.cesa-bianchi@unimi.it", "jcl@microsoft.com" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Online learning methods are highly successful at rapidly reducing the test error on large, highdimensional datasets. First order methods are particularly attractive in such problems as they typically enjoy computational complexity linear in the input size. However, the convergence of these methods crucially depends on the geometry of the data; for instance, running the same algorithm on a rotated set of examples can return vastly inferior results. See Fig. 1 for an illustration.\nSecond order algorithms such as Online Newton Step [17] have the attractive property of being invariant to linear transformations of the data, but typically require space and update time quadratic in the number of dimensions. Furthermore, the dependence on dimension is not improved even if the examples are sparse. These issues lead to the key question in our work: Can we develop (approximately) second order online learning algorithms with efficient updates? We show that the answer is “yes” by developing efficient sketched second order methods with regret guarantees. Specifically, the three main contributions of this work are:\n1. Invariant learning setting and optimal algorithms (Section 2). The typical online regret minimization setting evaluates against a benchmark that is bounded in some fixed norm (such as the `2-norm), implicitly putting the problem in a nice geometry. However, if all the features are scaled down, it is desirable to compare with accordingly larger weights, which is precluded by an apriori fixed norm bound. We study an invariant learning setting similar to the paper [30] which compares the learner to a benchmark only constrained to generate bounded predictions on the sequence of examples. We show that a variant of the Online Newton Step [17], while quadratic in computation, stays regret-optimal with a nearly matching lower bound in this more general setting.\n2. Improved efficiency via sketching (Section 3). To overcome the quadratic running time, we next develop sketched variants of the Newton update, approximating the second order information using a small number of carefully chosen directions, called a sketch. While the idea of data sketching is widely studied [33], as far as we know our work is the first one to apply it to a general adversarial\n30th Conference on Neural Information Processing Systems (NIPS 2016), Barcelona, Spain.\nar X\niv :1\n60 2.\n02 20\n2v 4\n[ cs\n.L G\n] 1\n7 O\nonline learning setting and provide rigorous regret guarantees. Two different sketching methods are considered: Frequent Directions [11, 20] and Oja’s algorithm [25, 26], both of which allow linear running time per round. For the first method, we prove regret bounds similar to the full second order update whenever the sketch-size is large enough. Our analysis makes it easy to plug in other sketching and online PCA methods (e.g. [10]).\n3. Sparse updates (Section 4). For practical implementation, we further develop sparse versions of these updates with a running time linear in the sparsity of the examples. The main challenge here is that even if examples are sparse, the sketch matrix still quickly becomes dense. These are the first known sparse implementations of the Frequent Directions1 and Oja’s algorithm, and require new sparse eigen computation routines that may be of independent interest.\nEmpirically, we evaluate our algorithm using the sparse Oja sketch (called Oja-SON) against first order methods such as diagonalized ADAGRAD [5, 22] on both ill-conditioned synthetic and a suite of real-world datasets. As Fig. 1 shows for a synthetic problem, we observe substantial performance gains as data conditioning worsens. On the real-world datasets, we find\nimprovements in some instances, while observing no substantial second-order signal in the others.\nRelated work Our online learning setting is closest to the one proposed in [30], which studies scale-invariant algorithms, a special case of the invariance property considered here (see also [28, Section 5]). Computational efficiency, a main concern in this work, is not a problem there since each coordinate is scaled independently. Orabona and Pál [27] study unrelated notions of invariance. Gao et al. [8] study a specific randomized sketching method for a special online learning setting.\nThe L-BFGS algorithm [21] has recently been studied in the stochastic setting2 [2, 23, 24, 31, 32], but has strong assumptions with pessimistic rates in theory and reliance on the use of large mini-batches empirically. Recent works [6, 14, 13, 29] employ sketching in stochastic optimization, but do not provide sparse implementations or extend in an obvious manner to the online setting. The FrankWolfe algorithm [7, 18] is also invariant to linear transformations, but with worse regret bounds [16] without further assumptions and modifications [9].\nNotation Vectors are represented by bold letters (e.g., x, w, . . . ) and matrices by capital letters (e.g., M , A, . . . ). Mi,j denotes the (i, j) entry of matrix M . Id represents the d× d identity matrix, 0m×d represents the m× d matrix of zeroes, and diag{x} represents a diagonal matrix with x on the diagonal. λi(A) denotes the i-th largest eigenvalue of A, ‖w‖A denotes √ w>Aw, |A| is the\ndeterminant of A, TR(A) is the trace of A, 〈A,B〉 denotes ∑ i,j Ai,jBi,j , and A B means that B −A is positive semidefinite. The sign function SGN(a) is 1 if a ≥ 0 and −1 otherwise."
    }, {
      "heading" : "2 Setup and an Optimal Algorithm",
      "text" : "We consider the following setting. On each round t = 1, 2 . . . , T : (1) the adversary first presents an example xt ∈ Rd, (2) the learner chooseswt ∈ Rd and predictsw>t xt, (3) the adversary reveals a loss function ft(w) = `t(w>xt) for some convex, differentiable `t : R→ R+, and (4) the learner suffers loss ft(wt) for this round.\nThe learner’s regret to a comparatorw is defined asRT (w) = ∑T t=1 ft(wt)− ∑T t=1 ft(w). Typical results study RT (w) against all w with a bounded norm in some geometry. For an invariant update, 1Recent work by [12] also studies sparse updates for a more complicated variant of Frequent Directions which is randomized and incurs extra approximation error. 2Stochastic setting assumes that the examples are drawn i.i.d. from a distribution.\nwe relax this requirement and only put bounds on the predictions w>xt. Specifically, for some pre-chosen constant C we define Kt def = { w : |w>xt| ≤ C } . We seek to minimize regret to all comparators that generate bounded predictions on every data point, that is:\nRT = sup w∈K\nRT (w) where K def = T⋂ t=1 Kt = { w : ∀t = 1, 2, . . . T, |w>xt| ≤ C } .\nUnder this setup, if the data are transformed to Mxt for all t and some invertible matrix M ∈ Rd×d, the optimal w∗ simply moves to (M−1)>w∗, which still has bounded predictions but might have significantly larger norm. This relaxation is similar to the comparator set considered in [30].\nWe make two structural assumptions on the loss functions.\nAssumption 1. (Scalar Lipschitz) The loss function `t satisfies |` ′\nt(z)| ≤ L whenever |z| ≤ C. Assumption 2. (Curvature) There exists σt ≥ 0 such that for all u,w ∈ K, ft(w) is lower bounded by ft(u) +∇ft(u)>(w − u) + σt2 ( ∇ft(u)>(u−w) )2 .\nNote that when σt = 0, Assumption 2 merely imposes convexity. More generally, it is satisfied by squared loss ft(w) = (w>xt − yt)2 with σt = 18C2 whenever |w\n>xt| and |yt| are bounded by C, as well as for all exp-concave functions (see [17, Lemma 3]).\nEnlarging the comparator set might result in worse regret. We next show matching upper and lower bounds qualitatively similar to the standard setting, but with an extra unavoidable √ d factor. 3\nTheorem 1. For any online algorithm generatingwt ∈ Rd and all T ≥ d, there exists a sequence of T examples xt ∈ Rd and loss functions `t satisfying Assumptions 1 and 2 (with σt = 0) such that the regret RT is at least CL √ dT/2.\nWe now give an algorithm that matches the lower bound up to logarithmic constants in the worst case but enjoys much smaller regret when σt 6= 0. At round t+ 1 with some invertible matrix At specified later and gradient gt = ∇ft(wt), the algorithm performs the following update before making the prediction on the example xt+1:\nut+1 = wt −A−1t gt, and wt+1 = argmin w∈Kt+1 ‖w − ut+1‖At . (1)\nThe projection onto the set Kt+1 differs from typical norm-based projections as it only enforces boundedness on xt+1 at round t+ 1. Moreover, this projection step can be performed in closed form.\nLemma 1. For any x 6= 0,u ∈ Rd and positive definite matrix A ∈ Rd×d, we have\nargmin w : |w>x|≤C\n‖w − u‖A = u− τC(u\n>x)\nx>A−1x A−1x, where τC(y) = SGN(y) max{|y| − C, 0}.\nIf At is a diagonal matrix, updates similar to those of Ross et al. [30] are recovered. We study a choice of At that is similar to the Online Newton Step (ONS) [17] (though with different projections):\nAt = αId + t∑ s=1 (σs + ηs)gsg > s (2)\nfor some parameters α > 0 and ηt ≥ 0. The regret guarantee of this algorithm is shown below: Theorem 2. Under Assumptions 1 and 2, suppose that σt ≥ σ ≥ 0 for all t, and ηt is non-increasing. Then using the matrices (2) in the updates (1) yields for all w ∈ K,\nRT (w) ≤ α\n2 ‖w‖22 + 2(CL) 2 T∑ t=1 ηt + d 2(σ + ηT ) ln\n( 1 + (σ + ηT ) ∑T t=1 ‖gt‖ 2 2\ndα\n) .\n3In the standard setting where wt and xt are restricted such that ‖wt‖ ≤ D and ‖xt‖ ≤ X , the minimax regret is O(DXL √ T ). This is clearly a special case of our setting with C = DX .\nAlgorithm 1 Sketched Online Newton (SON) Input: Parameters C, α and m.\n1: Initialize u1 = 0d×1. 2: Initialize sketch (S,H)← SketchInit(α,m). 3: for t = 1 to T do 4: Receive example xt. 5: Projection step: compute x̂ = Sxt, γ = τC(u > t xt)\nx>t xt−x̂>Hx̂ and setwt = ut − γ(xt − S>Hx̂).\n6: Predict label yt = w>t xt and suffer loss `t(yt). 7: Compute gradient gt = ` ′ t(yt)xt and the to-sketch vector ĝ = √ σt + ηtgt. 8: (S,H)← SketchUpdate(ĝ). 9: Update weight: ut+1 = wt − 1α (gt − S\n>HSgt). 10: end for\nThe dependence on ‖w‖22 implies that the method is not completely invariant to transformations of the data. This is due to the part αId in At. However, this is not critical since α is fixed and small while the other part of the bound grows to eventually become the dominating term. Moreover, we can even set α = 0 and replace the inverse with the Moore-Penrose pseudoinverse to obtain a truly invariant algorithm, as discussed in Appendix D. We use α > 0 in the remainder for simplicity.\nThe implication of this regret bound is the following: in the worst case where σ = 0, we set ηt = √ d/C2L2t and the bound simplifies to\nRT (w) ≤ α\n2 ‖w‖22 +\nCL\n2\n√ Td ln ( 1 + ∑T t=1 ‖gt‖ 2 2\nαCL √ Td\n) + 4CL √ Td ,\nessentially only losing a logarithmic factor compared to the lower bound in Theorem 1. On the other hand, if σt ≥ σ > 0 for all t, then we set ηt = 0 and the regret simplifies to\nRT (w) ≤ α\n2 ‖w‖22 +\nd\n2σ ln\n( 1 + σ ∑T t=1 ‖gt‖ 2 2\ndα\n) , (3)\nextending the O(d lnT ) results in [17] to the weaker Assumption 2 and a larger comparator set K."
    }, {
      "heading" : "3 Efficiency via Sketching",
      "text" : "Our algorithm so far requires Ω(d2) time and space just as ONS. In this section we show how to achieve regret guarantees nearly as good as the above bounds, while keeping computation within a constant factor of first order methods. Let Gt ∈ Rt×d be a matrix such that the t-th row is ĝ>t where we define ĝt = √ σt + ηtgt to be the to-sketch vector. Our previous choice of At (Eq. (2)) can be written as αId +G>t Gt. The idea of sketching is to maintain an approximation of Gt, denoted by St ∈ Rm×d where m d is a small constant called the sketch size. If m is chosen so that S>t St approximates G > t Gt well, we can redefine At as αId + S>t St for the algorithm.\nTo see why this admits an efficient algorithm, notice that by the Woodbury formula one has A−1t = 1 α ( Id − S>t (αIm + StS>t )−1St ) . With the notation Ht = (αIm + StS>t )\n−1 ∈ Rm×m and γt = τC(u > t+1xt+1)/(x > t+1xt+1 − x>t+1S>t HtStxt+1), update (1) becomes:\nut+1 = wt − 1α ( gt − S>t HtStgt ) , and wt+1 = ut+1 − γt ( xt+1 − S>t HtStxt+1 ) .\nThe operations involving Stgt or Stxt+1 require only O(md) time, while matrix vector products with Ht require onlyO(m2). Altogether, these updates are at most m times more expensive than first order algorithms as long as St and Ht can be maintained efficiently. We call this algorithm Sketched Online Newton (SON) and summarize it in Algorithm 1.\nWe now discuss two sketching techniques to maintain the matrices St and Ht efficiently, each requiring O(md) storage and time linear in d.\nAlgorithm 2 FD-Sketch for FD-SON Internal State: S and H . SketchInit(α,m)\n1: Set S = 0m×d and H = 1αIm. 2: Return (S,H).\nSketchUpdate(ĝ) 1: Insert ĝ into the last row of S. 2: Compute eigendecomposition: V >ΣV = S>S and set S = (Σ− Σm,mIm) 1 2V .\n3: Set H = diag {\n1 α+Σ1,1−Σm,m , · · · , 1 α\n} .\n4: Return (S,H).\nAlgorithm 3 Oja’s Sketch for Oja-SON Internal State: t, Λ, V and H . SketchInit(α,m)\n1: Set t = 0,Λ = 0m×m, H = 1αIm and V to anym×dmatrix with orthonormal rows. 2: Return (0m×d, H).\nSketchUpdate(ĝ) 1: Update t← t+ 1, Λ and V as Eqn. 4. 2: Set S = (tΛ) 1 2V .\n3: Set H = diag {\n1 α+tΛ1,1 , · · · , 1α+tΛm,m }\n. 4: Return (S,H).\nFrequent Directions (FD). Frequent Directions sketch [11, 20] is a deterministic sketching method. It maintains the invariant that the last row of St is always 0. On each round, the vector ĝ > t is inserted into the last row of St−1, then the covariance of the resulting matrix is eigendecomposed into V >t ΣtVt and St is set to (Σt − ρtIm) 1 2Vt where ρt is the smallest eigenvalue. Since the rows of St are orthogonal to each other, Ht is a diagonal matrix and can be maintained efficiently (see Algorithm 2). The sketch update works inO(md) time (see [11] and Appendix F) so the total running time is O(md) per round. We call this combination FD-SON and prove the following regret bound with notation Ωk = ∑d i=k+1 λi(G > TGT ) for any k = 0, . . . ,m− 1. Theorem 3. Under Assumptions 1 and 2, suppose that σt ≥ σ ≥ 0 for all t and ηt is non-increasing. FD-SON ensures that for any w ∈ K and k = 0, . . . ,m− 1, we have\nRT (w) ≤ α\n2 ‖w‖22 + 2(CL) 2 T∑ t=1 ηt + m 2(σ + ηT ) ln ( 1 + TR(S>T ST ) mα ) + mΩk 2(m− k)(σ + ηT )α .\nThe bound depends on the spectral decay Ωk, which essentially is the only extra term compared to the bound in Theorem 2. Similarly to previous discussion, if σt ≥ σ, we get the bound α2 ‖w‖ 2 2 + m 2σ ln ( 1 + TR(S>T ST ) mα ) + mΩk2(m−k)σα . With α tuned well, we pay logarithmic regret for the top m eigenvectors, but a square root regret O( √\nΩk) for remaining directions not controlled by our sketch. This is expected for deterministic sketching which focuses on the dominant part of the spectrum. When α is not tuned we still get sublinear regret as long as Ωk is sublinear.\nOja’s Algorithm. Oja’s algorithm [25, 26] is not usually considered as a sketching algorithm but seems very natural here. This algorithm uses online gradient descent to find eigenvectors and eigenvalues of data in a streaming fashion, with the to-sketch vector ĝt’s as the input. Specifically, let Vt ∈ Rm×d denote the estimated eigenvectors and the diagonal matrix Λt ∈ Rm×m contain the estimated eigenvalues at the end of round t. Oja’s algorithm updates as:\nΛt = (Im − Γt)Λt−1 + Γt diag{Vt−1ĝt} 2 , Vt orth←−− Vt−1 + ΓtVt−1ĝtĝ > t (4)\nwhere Γt ∈ Rm×m is a diagonal matrix with (possibly different) learning rates of order Θ(1/t) on the diagonal, and the “ orth←−−” operator represents an orthonormalizing step.4 The sketch is then St = (tΛt) 1 2Vt. The rows of St are orthogonal and thus Ht is an efficiently maintainable diagonal matrix (see Algorithm 3). We call this combination Oja-SON.\nThe time complexity of Oja’s algorithm is O(m2d) per round due to the orthonormalizing step. To improve the running time to O(md), one can only update the sketch every m rounds (similar to the block power method [15, 19]). The regret guarantee of this algorithm is unclear since existing analysis for Oja’s algorithm is only for the stochastic setting (see e.g. [1, 19]). However, Oja-SON provides good performance experimentally.\n4For simplicity, we assume that Vt−1 + ΓtVt−1ĝtĝ > t is always of full rank so that the orthonormalizing step\ndoes not reduce the dimension of Vt.\nAlgorithm 4 Sparse Sketched Online Newton with Oja’s Algorithm Input: Parameters C, α and m.\n1: Initialize ū = 0d×1 and b = 0m×1. 2: (Λ, F, Z,H)← SketchInit(α,m) (Algorithm 5). 3: for t = 1 to T do 4: Receive example xt. 5: Projection step: compute x̂ = FZxt and γ = τC(ū >xt+b >Zxt)\nx>t xt−(t−1)x̂>ΛHx̂ .\nObtain w̄ = ū− γxt and b← b+ γ(t− 1)F>ΛHx̂ (Equation 6). 6: Predict label yt = w̄>xt + b>Zxt and suffer loss `t(yt). 7: Compute gradient gt = ` ′ t(yt)xt and the to-sketch vector ĝ = √ σt + ηtgt. 8: (Λ, F , Z, H , δ)← SketchUpdate(ĝ) (Algorithm 5). 9: Update weight: ū = w̄ − 1αgt − (δ >b)ĝ and b← b+ 1α tF >ΛHFZgt (Equation 5).\n10: end for"
    }, {
      "heading" : "4 Sparse Implementation",
      "text" : "In many applications, examples (and hence gradients) are sparse in the sense that ‖xt‖0 ≤ s for all t and some small constant s d. Most online first order methods enjoy a per-example running time depending on s instead of d in such settings. Achieving the same for second order methods is more difficult since A−1t gt (or sketched versions) are typically dense even if gt is sparse.\nWe show how to implement our algorithms in sparsity-dependent time, specifically, in O(m2 +ms) for FD-SON and in O(m3 + ms) for Oja-SON. We emphasize that since the sketch would still quickly become a dense matrix even if the examples are sparse, achieving purely sparsity-dependent time is highly non-trivial and may be of independent interest. Due to space limit, below we only briefly mention how to do it for Oja-SON. Similar discussion for the FD sketch can be found in Appendix F. Note that mathematically these updates are equivalent to the non-sparse counterparts and regret guarantees are thus unchanged.\nThere are two ingredients to doing this for Oja-SON: (1) The eigenvectors Vt are represented as Vt = FtZt, where Zt ∈ Rm×d is a sparsely updatable direction (Step 3 in Algorithm 5) and Ft ∈ Rm×m is a matrix such that FtZt is orthonormal. (2) The weightswt are split as w̄t +Z>t−1bt, where bt ∈ Rm maintains the weights on the subspace captured by Vt−1 (same as Zt−1), and w̄t captures the weights on the complementary subspace which are again updated sparsely.\nWe describe the sparse updates for w̄t and bt below with the details for Ft and Zt deferred to Appendix G. Since St = (tΛt) 1 2Vt = (tΛt) 1 2FtZt and wt = w̄t + Z>t−1bt, we know ut+1 is\nwt − ( Id − S>t HtSt )gt α = w̄t − gt α − (Zt − Zt−1)\n>bt︸ ︷︷ ︸ def = ūt+1 +Z>t (bt + 1 αF > t (tΛtHt)FtZtgt︸ ︷︷ ︸ def = b′t+1 ) . (5)\nSince Zt − Zt−1 is sparse by construction and the matrix operations defining b′t+1 scale with m, overall the update can be done in O(m2 +ms). Using the update forwt+1 in terms of ut+1, wt+1 is equal to\nut+1 − γt(Id − S>t HtSt)xt+1 = ūt+1 − γtxt+1︸ ︷︷ ︸ def = w̄t+1 +Z>t (b ′ t+1 + γtF > t (tΛtHt)FtZtxt+1︸ ︷︷ ︸ def = bt+1 ) . (6)\nAgain, it is clear that all the computations scale with s and not d, so both w̄t+1 and bt+1 require only O(m2 +ms) time to maintain. Furthermore, the prediction w>t xt = w̄ > t xt + b > t Zt−1xt can also be computed in O(ms) time. The O(m3) in the overall complexity comes from a Gram-Schmidt step in maintaining Ft (details in Appendix G).\nThe pseudocode is presented in Algorithms 4 and 5 with some details deferred to Appendix G. This is the first sparse implementation of online eigenvector computation to the best of our knowledge.\nAlgorithm 5 Sparse Oja’s Sketch Internal State: t, Λ, F , Z, H and K. SketchInit(α,m)\n1: Set t = 0,Λ = 0m×m, F = K = αH = Im and Z to any m× d matrix with orthonormal rows. 2: Return (Λ, F , Z, H).\nSketchUpdate(ĝ) 1: Update t← t+1. Pick a diagonal stepsize matrix Γt to update Λ← (I−Γt)Λ+Γt diag{FZĝ}2. 2: Set δ = A−1ΓtFZĝ and update K ← K + δĝ>Z> + Zĝδ> + (ĝ>ĝ)δδ>. 3: Update Z ← Z + δĝ>. 4: (L,Q) ← Decompose(F,K) (Algorithm 11), so that LQZ = FZ and QZ is orthogonal. Set F = Q.\n5: Set H ← diag {\n1 α+tΛ1,1 , · · · , 1α+tΛm,m }\n. 6: Return (Λ, F , Z, H , δ)."
    }, {
      "heading" : "5 Experiments",
      "text" : "Preliminary experiments revealed that out of our two sketching options, Oja’s sketch generally has better performance (see Appendix H). For more thorough evaluation, we implemented the sparse version of Oja-SON in Vowpal Wabbit.5 We compare it with ADAGRAD [5, 22] on both synthetic and real-world datasets. Each algorithm takes a stepsize parameter: 1α serves as a stepsize for Oja-SON and a scaling constant on the gradient matrix for ADAGRAD. We try both methods with the parameter set to 2j for j = −3,−2, . . . , 6 and report the best results. We keep the stepsize matrix in Oja-SON fixed as Γt = 1t Im throughout. All methods make one online pass over data minimizing square loss."
    }, {
      "heading" : "5.1 Synthetic Datasets",
      "text" : "To investigate Oja-SON’s performance in the setting it is really designed for, we generated a range of synthetic ill-conditioned datasets as follows. We picked a random Gaussian matrix Z ∼ RT×d (T = 10,000 and d = 100) and a random orthonormal basis V ∈ Rd×d. We chose a specific spectrum λ ∈ Rd where the first d− 10 coordinates are 1 and the rest increase linearly to some fixed condition number parameter κ. We let X = Zdiag{λ} 1 2 V > be our example matrix, and created a binary classification problem with labels y = sign(θ>x), where θ ∈ Rd is a random vector. We generated 20 such datasets with the same Z, V and labels y but different values of κ ∈ {10, 20, . . . , 200}. Note that if the algorithm is truly invariant, it would have the same behavior on these 20 datasets.\nFig. 1 (in Section 1) shows the final progressive error (i.e. fraction of misclassified examples after one pass over data) for ADAGRAD and Oja-SON (with sketch size m = 0, 5, 10) as the condition number increases. As expected, the plot confirms the performance of first order methods such as ADAGRAD degrades when the data is ill-conditioned. The plot also shows that as the sketch size increases,\n5An open source machine learning toolkit available at http://hunch.net/~vw\nOja-SON becomes more accurate: when m = 0 (no sketch at all), Oja-SON is vanilla gradient descent and is worse than ADAGRAD as expected; when m = 5, the accuracy greatly improves; and finally when m = 10, the accuracy of Oja-SON is substantially better and hardly worsens with κ.\nTo further explain the effectiveness of Oja’s algorithm in identifying top eigenvalues and eigenvectors, the plot in Fig. 2 shows the largest relative difference between the true and estimated top 10 eigenvalues as Oja’s algorithm sees more data. This gap drops quickly after seeing just 500 examples."
    }, {
      "heading" : "5.2 Real-world Datasets",
      "text" : "Next we evaluated Oja-SON on 23 benchmark datasets from the UCI and LIBSVM repository (see Appendix H for description of these datasets). Note that some datasets are very high dimensional but very sparse (e.g. for 20news, d ≈ 102, 000 and s ≈ 94), and consequently methods with running time quadratic (such as ONS) or even linear in dimension rather than sparsity are prohibitive.\nIn Fig. 3(a), we show the effect of using sketched second order information, by comparing sketch size m = 0 and m = 10 for Oja-SON (concrete error rates in Appendix H). We observe significant improvements in 5 datasets (acoustic, census, heart, ionosphere, letter), demonstrating the advantage of using second order information. However, we found that Oja-SON was outperformed by ADAGRAD on most datasets, mostly because the diagonal adaptation of ADAGRAD greatly reduces the condition number on these datasets. Moreover, one disadvantage of SON is that for the directions not in the sketch, it is essentially doing vanilla gradient descent. We expect better results using diagonal adaptation as in ADAGRAD in off-sketch directions.\nTo incorporate this high level idea, we performed a simple modification to Oja-SON: upon seeing example xt, we feed D − 12 t xt to our algorithm instead of xt, where Dt ∈ Rd×d is the diagonal part of\nthe matrix ∑t−1 τ=1 gτg > τ .\n6 The intuition is that this diagonal rescaling first homogenizes the scales of all dimensions. Any remaining ill-conditioning is further addressed by the sketching to some degree, while the complementary subspace is no worse-off than with ADAGRAD. We believe this flexibility in picking the right vectors to sketch is an attractive aspect of our sketching-based approach.\nWith this modification, Oja-SON outperforms ADAGRAD on most of the datasets even for m = 0, as shown in Fig. 3(b) (concrete error rates in Appendix H). The improvement on ADAGRAD at m = 0 is surprising but not impossible as the updates are not identical–our update is scale invariant like Ross et al. [30]. However, the diagonal adaptation already greatly reduces the condition number on all datasets except splice (see Fig. 4 in Appendix H for detailed results on this dataset), so little improvement is seen for sketch size m = 10 over m = 0. For several datasets, we verified the accuracy of Oja’s method in computing the top-few eigenvalues (Appendix H), so the lack of difference between sketch sizes is due to the lack of second order information after the diagonal correction.\nThe average running time of our algorithm when m = 10 is about 11 times slower than ADAGRAD, matching expectations. Overall, SON can significantly outperform baselines on ill-conditioned data, while maintaining a practical computational complexity.\nAcknowledgements This work was done when Haipeng Luo and Nicolò Cesa-Bianchi were at Microsoft Research, New York. We thank Lijun Zhang for pointing out our mistake in the regret proof of another sketching method that appeared in an earlier version.\n6D1 is defined as 0.1× Id to avoid division by zero."
    }, {
      "heading" : "A Proof of Theorem 1",
      "text" : "Proof. Assuming T is a multiple of d without loss of generality, we pick xt from the basis vectors {e1, . . . , ed} so that each ei appears T/d times (in an arbitrary order). Note that now K is just a hypercube:\nK = { w : |w>xt| ≤ C, ∀t } = {w : ‖w‖∞ ≤ C} .\nLet ξ1, . . . , ξT be independent Rademacher random variables such that Pr(ξt = +1) = Pr(ξt = −1) = 12 . For a scalar θ, we define loss function\n7 `t(θ) = (ξtL)θ, so that Assumptions 1 and 2 are clearly satisfied with σt = 0. We show that, for any online algorithm,\nE[RT ] = E [ T∑ t=1 `t ( w>t xt ) − inf w∈K T∑ t=1 `t ( w>xt )] ≥ CL √ dT 2\nwhich implies the statement of the theorem. First of all, note that E [ `t ( w>t xt ) ∣∣∣ ξ1, . . . , ξt−1] = 0 for any wt. Hence we have E\n[ T∑ t=1 `t ( w>t xt ) − inf w∈K T∑ t=1 `t ( w>xt )] = E [ sup w∈K T∑ t=1 −`t ( w>xt )] = LE [ sup w∈K w> T∑ t=1 ξtxt ] ,\nwhich, by the construction of xt, is\nCLE [∥∥∥∥∥ T∑ t=1 ξtxt ∥∥∥∥∥ 1 ] = CLdE ∣∣∣∣∣∣ T/d∑ t=1 ξt ∣∣∣∣∣∣  ≥ CLd√ T 2d = CL √ dT 2 ,\nwhere the final bound is due to the Khintchine inequality (see e.g. Lemma 8.2 in [3]). This concludes the proof."
    }, {
      "heading" : "B Projection",
      "text" : "We prove a more general version of Lemma 1 which does not require invertibility of the matrix A here. Lemma 2. For any x 6= 0,u ∈ Rd×1 and positive semidefinite matrix A ∈ Rd×d, we have\nw∗ = argmin w:|w>x|≤C ‖w − u‖A =  u− τC(u >x) x>A†x A†x if x ∈ range(A)\nu− τC(u >x)\nx>(I−A†A)x (I −A †A)x if x /∈ range(A)\nwhere τC(y) = SGN(y) max{|y| − C, 0} and A† is the Moore-Penrose pseudoinverse of A. (Note that when A is rank deficient, this is one of the many possible solutions.)\nProof. First consider the case when x ∈ range(A). If |u>x| ≤ C, then it is trivial thatw∗ = u. We thus assume u>x ≥ C below (the last case u>x ≤ −C is similar). The Lagrangian of the problem is\nL(w, λ1, λ2) = 1\n2 (w − u)>A(w − u) + λ1(w>x− C) + λ2(w>x+ C)\nwhere λ1 ≥ 0 and λ2 ≤ 0 are Lagrangian multipliers. Since w>x cannot be C and −C at the same time, The complementary slackness condition implies that either λ1 = 0 or λ2 = 0. Suppose the latter case is true, then setting the derivative with respect tow to 0, we getw∗ = u−λ1A†x+(I−A†A)z\n7By adding a suitable constant, these losses can always be made nonnegative while leaving the regret unchanged.\nwhere z ∈ Rd×1 can be arbitrary. However, since A(I − A†A) = 0, this part does not affect the objective value at all and we can simply pick z = 0 so that w∗ has a consistent form regardless of whether A is full rank or not. Now plugging w∗ back, we have\nL(w∗, λ1, 0) = − λ1\n2\n2 x>A†x+ λ1(u >x− C)\nwhich is maximized when λ1 = u >x−C x>A†x ≥ 0. Plugging this optimal λ1 into w∗ gives the stated solution. On the other hand, if λ1 = 0 instead, we can proceed similarly and verify that it gives a smaller dual value (0 in fact), proving the previous solution is indeed optimal.\nWe now move on to the case when x /∈ range(A). First of all the stated solution is well defined since x>(I −A†A)x is nonzero in this case. Moreover, direct calculation shows that w∗ is in the valid space: |w∗>x| = |u>x − τC(u>x)| ≤ C, and also it gives the minimal possible distance value ‖w∗ − u‖A = 0, proving the lemma."
    }, {
      "heading" : "C Proof of Theorem 2",
      "text" : "We first prove a general regret bound that holds for any choice of At in update 1:\nut+1 = wt −A−1t gt wt+1 = argmin\nw∈Kt+1 ‖w − ut+1‖At .\nThis bound will also be useful in proving regret guarantees for the sketched versions. Proposition 1. For any sequence of positive definite matrices At and sequence of losses satisfying Assumptions 1 and 2, the regret of updates (1) against any comparator w ∈ K satisfies\n2RT (w) ≤ ‖w‖2A0 + T∑ t=1\ngTt A −1 t gt︸ ︷︷ ︸\n“Gradient Bound”RG\n+ T∑ t=1\n(wt −w)>(At −At−1 − σtgtg>t )(wt −w)︸ ︷︷ ︸ “Diameter Bound”RD\nProof. Since wt+1 is the projection of ut+1 onto Kt+1, by the property of projections (see for example [16, Lemma 8]), the algorithm ensures\n‖wt+1 −w‖2At ≤ ‖ut+1 −w‖ 2 At = ‖wt −w‖2At + g > t A −1 t gt − 2g>t (wt −w)\nfor all w ∈ K ⊆ Kt+1. By the curvature property in Assumption 2, we then have that\n2RT (w) ≤ T∑ t=1 2g>t (wt −w)− σt ( g>t (wt −w) )2 ≤\nT∑ t=1 g>t A −1 t gt + ‖wt −w‖ 2 At − ‖wt+1 −w‖2At − σt ( g>t (wt −w) )2 ≤ ‖w‖2A0 + T∑ t=1 g>t A −1 t gt + (wt −w)>(At −At−1 − σtgtg>t )(wt −w),\nwhich completes the proof.\nProof of Theorem 2. We apply Proposition 1 with the choice: A0 = αId and At = At−1 + (σt + ηt)gtg T t , which gives ‖w‖ 2 A0 = α ‖w‖22 and\nRD = T∑ t=1 ηt(wt −w)>gtg>t (wt −w) ≤ 4(CL)2 T∑ t=1 ηt ,\nwhere the last equality uses the Lipschitz property in Assumption 1 and the boundedness ofw>t xt and w>xt.\nFor the term RG, define Ât = ασ+ηT Id + ∑t s=1 gsg > s . Since σt ≥ σ and ηt is non-increasing, we have Ât 1σ+ηT At, and therefore:\nRG ≤ 1\nσ + ηT T∑ t=1 g>t Â −1 t gt =\n1\nσ + ηT T∑ t=1 〈 Ât − Ât−1, Â−1t 〉 ≤ 1 σ + ηT T∑ t=1 ln |Ât| |Ât−1| = 1 σ + ηT ln |ÂT | |Â0|\n= 1\nσ + ηT d∑ i=1 ln\n1 + (σ + ηT )λi (∑T t=1 gtg > t ) α  ≤ d σ + ηT ln 1 + (σ + ηT )∑di=1 λi (∑T t=1 gtg > t ) dα\n = d\nσ + ηT ln\n( 1 + (σ + ηT ) ∑T t=1 ‖gt‖ 2 2\ndα ) where the second inequality is by the concavity of the function ln |X| (see [17, Lemma 12] for an alternative proof), and the last one is by Jensen’s inequality. This concludes the proof."
    }, {
      "heading" : "D A Truly Invariant Algorithm",
      "text" : "In this section we discuss how to make our adaptive online Newton algorithm truly invariant to invertible linear transformations. To achieve this, we set α = 0 and replace A−1t with the MoorePenrose pseudoinverse A†t : 8\nut+1 = wt −A†tgt, wt+1 = argmin\nw∈Kt+1 ‖w − ut+1‖At .\n(7)\nWhen written in this form, it is not immediately clear that the algorithm has the invariant property. However, one can rewrite the algorithm in a mirror descent form:\nwt+1 = argmin w∈Kt+1 ∥∥∥w −wt +A†tgt∥∥∥2 At\n= argmin w∈Kt+1\n‖w −wt‖2At + 2(w −wt) >AtA † tgt\n= argmin w∈Kt+1\n‖w −wt‖2At + 2w >gt\nwhere we use the fact that gt is in the range of At in the last step. Now suppose all the data xt are transformed to Mxt for some unknown and invertible matrix M , then one can verify that all the weights will be transformed to M−Twt accordingly, ensuring the prediction to remain the same.\nMoreover, the regret bound of this algorithm can be bounded as below. First notice that even when At is rank deficient, the projection step still ensures the following: ‖wt+1 −w‖2At ≤ ‖ut+1 −w‖ 2 At\n, which is proven in [17, Lemma 8]. Therefore, the entire proof of Theorem 2 still holds after replacing A−1t with A † t , giving the regret bound:\n1\n2 T∑ t=1 g>t A † t gt + 2(CL) 2ηt . (8)\nThe key now is to bound the term ∑T t=1 g > t Â † t gt where we define Ât = ∑t s=1 gsg > s . In order to do this, we proceed similarly to the proof of [4, Theorem 4.2] to show that this term is of order O(d2 lnT ) in the worst case.\n8See Appendix B for the closed form of the projection step.\nTheorem 4. Let λ∗ be the minimum among the smallest nonzero eigenvalues of Ât (t = 1, . . . , T ) and r be the rank of ÂT . We have\nT∑ t=1 g>t Â † t gt ≤ r + (1 + r)r 2 ln\n( 1 + 2 ∑T t=1 ‖gt‖ 2 2\n(1 + r)rλ∗\n) .\nProof. First by Cesa-Bianchi et al. [4, Lemma D.1], we have\ng>t Â † t gt =\n{ 1 if gt /∈ range(Ât−1)\n1− det+(Ât−1) det+(Ât) < 1 if gt ∈ range(Ât−1)\nwhere det+(M) denotes the product of the nonzero eigenvalues of matrix M . We thus separate the steps t such that gt ∈ range(Ât−1) from those where gt /∈ range(Ât−1). For each k = 1, . . . , r let Tk be the first time step t in which the rank of At is k (so that T1 = 1). Also let Tr+1 = T + 1 for convenience. With this notation, we have\nT∑ t=1 g>t Â † t gt = r∑ k=1 g>TkÂ†TkgTk + Tk+1−1∑ t=Tk+1 g>t Â † t gt  =\nr∑ k=1 1 + Tk+1−1∑ t=Tk+1 ( 1− det+(Ât−1) det+(Ât) ) = r +\nr∑ k=1 Tk+1−1∑ t=Tk+1\n( 1− det+(Ât−1)\ndet+(Ât)\n)\n≤ r + r∑\nk=1 Tk+1−1∑ t=Tk+1 ln det+(Ât) det+(Ât−1)\n= r + r∑ k=1 ln det+(ÂTk+1−1) det+(ÂTk) .\nFix any k and let λk,1, . . . , λk,k be the nonzero eigenvalues of ÂTk and λk,1 + µk,1, . . . , λk,k + µk,k be the nonzero eigenvalues of ÂTk+1−1. Then\nln det+(ÂTk+1−1)\ndet+(ÂTk) = ln k∏ i=1 λk,i + µk,i λk,i = k∑ i=1 ln ( 1 + µk,i λk,i ) .\nHence, we arrive at T∑ t=1 g>t Â + t gt ≤ r + r∑ k=1 k∑ i=1 ln ( 1 + µk,i λk,i ) .\nTo further bound the latter quantity, we use λ∗ ≤ λk,i and Jensen’s inequality : r∑\nk=1 k∑ i=1 ln ( 1 + µk,i λk,i ) ≤ r∑ k=1 k∑ i=1 ln ( 1 + µk,i λ∗ ) ≤ (1 + r)r\n2 ln\n( 1 + 2 ∑r k=1 ∑k i=1 µk,i\n(1 + r)rλ∗\n) .\nFinally noticing that\nk∑ i=1 µk,i = TR(ÂTk+1−1)− TR(ÂTk) = Tk+1−1∑ t=Tk+1 TR(gtg > t ) = Tk+1−1∑ t=Tk+1 ‖gt‖ 2 2\ncompletes the proof.\nTaken together, Eq. (8) and Theorem 4 lead to the following regret bounds (recall the definitions of λ∗ and r from Theorem 4).\nCorollary 1. If σt = 0 for all t and ηt is set to be 1CL √ d t , then the regret of the algorithm defined by Eq. (7) is at most\nCL\n2\n√ T\nd\n( r + (1 + r)r\n2 ln\n( 1 + 2 ∑T t=1 ‖gt‖ 2 2\n(1 + r)rλ∗\n)) + 4CL √ Td.\nOn the other hand, if σt ≥ σ > 0 for all t and ηt is set to be 0, then the regret is at most\n1\n2σ\n( r + (1 + r)r\n2 ln\n( 1 + 2 ∑T t=1 ‖gt‖ 2 2\n(1 + r)rλ∗\n)) ."
    }, {
      "heading" : "E Proof of Theorem 3",
      "text" : "Proof. We again first apply Proposition 1 (recall the notation RG and RD stated in the proposition). By the construction of the sketch, we have\nAt −At−1 = S>t St − S>t−1St−1 = ĝtĝ > t − ρtV >t Vt ĝtĝ > t .\nIt follows immediately that RD is again at most 4(CL)2 ∑T t=1 ηt. For the term RG, we will apply the\nfollowing guarantee of Frequent Directions (see the proof of Theorem 1.1 of [11]): ∑T t=1 ρt ≤ Ωk m−k . Specifically, since TR(VtA−1t V > t ) ≤ 1αTR(VtV > t ) = m α we have\nRG = T∑ t=1\n1\nσt + ηt\n〈 A−1t , At −At−1 + ρtV >t Vt 〉 ≤ 1 σ + ηT T∑ t=1 (〈 A−1t , At −At−1 + ρtV >t Vt\n〉) = 1\nσ + ηT T∑ t=1 (〈 A−1t , At −At−1 〉 + ρtTR(VtA −1 t V > t ) )\n≤ 1 (σ + ηT ) T∑ t=1 〈 A−1t , At −At−1 〉 + mΩk (m− k)(σ + ηT )α .\nFinally for the term ∑T t=1 〈 A−1t , At −At−1 〉 , we proceed similarly to the proof of Theorem 2:\nT∑ t=1 〈 A−1t , At −At−1 〉 ≤ T∑ t=1 ln |At| |At−1| = ln |AT | |A0| = d∑ i=1 ln ( 1 + λi(S > T ST ) α )\n= m∑ i=1 ln ( 1 + λi(S > T ST ) α ) ≤ m ln ( 1 + TR(S>T ST ) mα ) where the first inequality is by the concavity of the function ln |X|, the second one is by Jensen’s inequality, and the last equality is by the fact that S>T ST is of rank m and thus λi(S > T ST ) = 0 for any i > m. This concludes the proof."
    }, {
      "heading" : "F Sparse updates for FD sketch",
      "text" : "The sparse version of our algorithm with the Frequent Directions option is much more involved. We begin by taking a detour and introducing a fast and epoch-based variant of the Frequent Directions algorithm proposed in [11]. The idea is the following: instead of doing an eigendecomposition immediately after inserting a new ĝ every round, we double the size of the sketch (to 2m), keep up to m recent ĝ’s, do the decomposition only at the end of every m rounds and finally keep the top m\neigenvectors with shrunk eigenvalues. The advantage of this variant is that it can be implemented straightforwardly in O(md) time on average without doing a complicated rank-one SVD update, while still ensuring the exact same guarantee with the only price of doubling the sketch size.\nAlgorithm 6 shows the details of this variant and how we maintain H . The sketch S is always represented by two parts: the top part (DV ) comes from the last eigendecomposition, and the bottom part (G) collects the recent to-sketch vector ĝ’s. Note that within each epoch, the update of H−1 is a rank-two update and thus H can be updated efficiently using Woodbury formula (Lines 3 and 4 of Algorithm 6).\nAlgorithm 6 Frequent Direction Sketch (epoch version) Internal State: τ,D, V,G and H . SketchInit(α,m)\n1: Set τ = 1, D = 0m×m, G = 0m×d, H = 1αI2m and let V be any m× d matrix whose rows are orthonormal. 2: Return (02m×d, H).\nSketchUpdate(ĝ) 1: Insert ĝ into the τ -th row of G. 2: if τ < m then 3: Let e be the 2m× 1 basis vector whose (m+ τ)-th entry is 1 and q = Sĝ − ĝ\n>ĝ 2 e.\n4: Update H ← H − Hqe >H\n1+e>Hq and H ← H − Heq >H 1+q>He\n. 5: Update τ ← τ + 1. 6: else 7: (V,Σ)← ComputeEigenSystem (( DV G )) (Algorithm 7).\n8: Set D to be a diagonal matrix with Di,i = √\nΣi,i − Σm,m, ∀i ∈ [m]. 9: Set H ← diag { 1\nα+D21,1 , · · · , 1α+D2m,m , 1 α , . . . , 1 α\n} .\n10: Set G = 0m×d. 11: Set τ = 1. 12: end if 13: Return (( DV G ) , H ) .\nAlthough we can use any available algorithm that runs in O(m2d) time to do the eigendecomposition (Line 7 in Algorithm 6), we explicitly write down the procedure of reducing this problem to eigendecomposing a small square matrix in Algorithm 7, which will be important for deriving the sparse version of the algorithm. Lemma 3 proves that Algorithm 7 works correctly for finding the top m eigenvector and eigenvalues.\nAlgorithm 7 ComputeEigenSystem(S) Input: S = ( DV G ) . Output: V ′ ∈ Rm×d and diagonal matrix Σ ∈ Rm×m such that the i-th row of V ′ and the i-th entry of the diagonal of Σ are the i-th eigenvector and eigenvalue of S>S respectively.\n1: Compute M = GV >. 2: Decompose G−MV into the form LQ where L ∈ Rm×r, Q is a r × d matrix whose rows are\northonormal and r is the rank of G−MV (e.g. by a Gram-Schmidt process). 3: Compute the top m eigenvectors (U ∈ Rm×(m+r)) and eigenvalues (Σ ∈ Rm×m) of the matrix(\nD2 0m×r 0r×m 0r×r\n) + ( M>\nL>\n) ( M L ).\n4: Return (V ′,Σ) where V ′ = U ( V Q ) .\nLemma 3. The outputs of Algorithm 7 are such that the i-th row of V ′ and the i-th entry of the diagonal of Σ are the i-th eigenvector and eigenvalue of S>S respectively.\nProof. Let W> ∈ Rd×(d−m−r) be an orthonormal basis of the null space of ( V Q ) . By Line 2, we know that GW> = 0 and E = (V > Q> W>) forms an orthonormal basis of Rd. Therefore, we have\nS>S = V >D2V +G>G\n= E  D2 0 00 0 0 0 0 0 E> + EE>G>GEE> = E\n D2 0 00 0 0 0 0 0 +  V G>QG> WG>  (GV > GQ> GW>) E>\n= (V > Q>) (( D2 0 0 0 ) + ( M> L> ) ( M L ) ) ︸ ︷︷ ︸\n=C\n( V Q )\nwhere in the last step we use the fact GQ> = (MV + LQ)Q> = L. Now it is clear that the eigenvalue of C will be the eigenvalue of S>S and the eigenvector of C will be the eigenvector of S>S after left multiplied by matrix (V > Q>), completing the proof.\nWe are now ready to present the sparse version of SON with Frequent Direction sketch (Algorithm 8). The key point is that we represent Vt as FtZt for some Ft ∈ Rm×m and Zt ∈ Rm×d, and the weight vectorwt as w̄t +Z>t−1bt and ensure that the update of Zt and w̄t will always be sparse. To see this,\ndenote the sketch St by ( DtFtZt Gt ) and let Ht,1 and Ht,2 be the top and bottom half of Ht. Now the update rule of ut+1 can be rewritten as\nut+1 = wt − ( Id − S>t HtSt )gt α\n= w̄t + Z > t−1bt −\n1 α gt + 1 α (Z>t F > t Dt, G > t ) ( Ht,1Stgt Ht,2Stgt ) = w̄t + 1\nα (G>t Ht,2Stgt − gt)− (Zt − Zt−1)>bt︸ ︷︷ ︸\nūt+1\n+Z>t (bt + 1\nα F>t DtHt,1Stgt)︸ ︷︷ ︸\nb′t+1\nWe will show that Zt − Zt−1 = ∆tGt for some ∆t ∈ Rm×m shortly, and thus the above update is efficient due to the fact that the rows of Gt are collections of previous sparse vectors ĝ.\nSimilarly, the update of wt+1 can be written as\nwt+1 = ut+1 − γt(xt+1 − S>t HtStxt+1)\n= ūt+1 + Z > t b ′ t+1 − γtxt+1 + γt(Z>t F>t Dt, G>t ) ( Ht,1Stxt+1 Ht,2Stxt+1 ) = ūt+1 + γt(G\n> t Ht,2Stxt+1 − xt+1)︸ ︷︷ ︸\nw̄t+1\n+Z>t (b ′ t+1 + γtF > t DtHt,1Stxt+1)︸ ︷︷ ︸ bt+1 .\nIt is clear that γt can be computed efficiently, and thus the update of wt+1 is also efficient. These updates correspond to Line 6 and 10 of Algorithm 8.\nIt remains to perform the sketch update efficiently. Algorithm 9 is the sparse version of Algorithm 6. The challenging part is to compute eigenvectors and eigenvalues efficiently. Fortunately, in light of Algorithm 7, using the new representation V = FZ one can directly translate the process to Algorithm 10 and find that the eigenvectors can be expressed in the form N1Z +N2G. To see this, first note that Line 1 of both algorithms compute the same matrix M = GV > = GZ>F>. Then Line 2 decomposes the matrix\nG−MV = G−MFZ = ( −MF Im ) ( Z G ) def = PR\nAlgorithm 8 Sparse Sketched Online Newton with Frequent Directions Input: Parameters C, α and m.\n1: Initialize ū = 0d×1, b = 0m×1 and (D,F,Z,G,H)← SketchInit(α,m) (Algorithm 9). 2: Let S denote the matrix ( DFZ G ) throughout the algorithm (without actually computing it).\n3: Let H1 and H2 denote the upper and lower half of H , i.e. H = ( H1 H2 ) . 4: for t = 1 to T do 5: Receive example xt. 6: Projection step: compute x̂ = Sxt and γ = τC(ū >xt+b >Zxt)\nx>t xt−x̂>Hx̂ .\nObtain w̄ = ū+ γ(G>H2x̂− xt) and b← b+ γF>DH1x̂. 7: Predict label yt = w̄>xt + b>Zxt and suffer loss `t(yt). 8: Compute gradient gt = ` ′ t(yt)xt and the to-sketch vector ĝ = √ σt + ηtgt.\n9: (D,F,Z,G,H,∆)← SketchUpdate(ĝ) (Algorithm 9). 10: Update ū = w̄ + 1α (G >H2Sg − g)−G>∆>b and b← b+ 1αF >DH1Sg. 11: end for\nusing Gram-Schmidt into the form LQR such that the rows of QR are orthonormal (that is, QR corresponds toQ in Algorithm 7). While directly applying Gram-Schmidt to PR would takeO(m2d) time, this step can in fact be efficiently implemented by performing Gram-Schmidt to P (instead of PR) in a Banach space where inner product is defined as 〈a, b〉 = a>Kb with\nK = RR> =\n( ZZ> ZG>\nGZ> GG> ) being the Gram matrix of R. Since we can efficiently maintain the Gram matrix of Z (see Line 10 of Algorithm 9) and GZ> and GG> can be computed sparsely, this decomposing step can be done efficiently too. This modified Gram-Schmidt algorithm is presented in Algorithm 11 (which will also be used in sparse Oja’s sketch), where Line 4 is the key difference compared to standard Gram-Schmidt (see Lemma 4 below for a formal proof of correctness).\nLine 3 of Algorithms 7 and 10 are exactly the same. Finally the eigenvectorsU ( V Q ) in Algorithm 7\nnow becomes (with U1, U2, Q1, Q2, N1, N2 defined in Line 4 of Algorithm 10)\nU ( FZ QR ) = (U1, U2) ( FZ QR ) = U1FZ + U2(Q1, Q2) ( Z G ) = (U1FZ + U2Q1)Z + U2Q2G = N1Z +N2G.\nTherefore, having the eigenvectors in the form N1Z +N2G, we can simply update F as N1 and Z as Z +N−11 N2G so that the invariant V = FZ still holds (see Line 11 of Algorithm 9). The update of Z is sparse since G is sparse.\nWe finally summarize the results of this section in the following theorem. Theorem 5. The average running time of Algorithm 8 is O ( m2 + ms ) per round, and the regret bound is exactly the same as the one stated in Theorem 3.\nLemma 4. The output of Algorithm 11 ensures that LQR = PR and the rows of QR are orthonormal.\nProof. It suffices to prove that Algorithm 11 is exactly the same as using the standard Gram-Schmidt to decompose the matrix PR into L and an orthonormal matrix which can be written as QR. First note that when K = In, Algorithm 11 is simply the standard Gram-Schmidt algorithm applied to P . We will thus go through Line 1-10 of Algorithm 11 with P replaced by PR and K by In and show that it leads to the exact same calculations as running Algorithm 11 directly. For clarity, we add “˜” to symbols to distinguish the two cases (so P̃ = PR and K̃ = In). We will inductively prove\nAlgorithm 9 Sparse Frequent Direction Sketch Internal State: τ,D, F, Z,G,H and K. SketchInit(α,m)\n1: Set τ = 1, D = 0m×m, F = K = Im, H = 1αI2m, G = 0m×d, and let Z be any m× d matrix whose rows are orthonormal. 2: Return (D,F,Z,G,H).\nSketchUpdate(ĝ) 1: Insert ĝ into the τ -th row of G. 2: if τ < m then 3: Let e be the 2m× 1 basic vector whose (m+ τ)-th entry is 1 and compute q = Sĝ − ĝ\n>ĝ 2 e.\n4: Update H ← H − Hqe >H\n1+e>Hq and H ← H − Heq >H 1+q>He\n. 5: Set ∆ = 0m×m. 6: Set τ ← τ + 1. 7: else 8: (N1, N2,Σ)← ComputeSparseEigenSystem (( DFZ G ) ,K ) (Algorithm 10).\n9: Compute ∆ = N−11 N2. 10: Update Gram matrix K ← K + ∆GZ> + ZG>∆> + ∆GG>∆>. 11: Update F = N1, Z ← Z + ∆G, and let D be such that Di,i = √ Σi,i − Σm,m, ∀i ∈ [m].\n12: Set H ← diag {\n1 α+D21,1 , · · · , 1α+D2m,m , 1 α , . . . , 1 α\n} .\n13: Set G = 0m×d. 14: Set τ = 1. 15: end if 16: Return (D,F,Z,G,H,∆).\nAlgorithm 10 ComputeSparseEigenSystem(S,K) Input: S = ( DFZ G ) and Gram matrix K = ZZ>. Output: N1, N2 ∈ Rm×m and diagonal matrix Σ ∈ Rm×m such that the i-th row of N1Z +N2G and the i-th entry of the diagonal of Σ are the i-th eigenvector and eigenvalue of the matrix S>S.\n1: Compute M = GZ>F>. 2: (L,Q)← Decompose ( ( −MF Im ) , ( K ZG>\nGZ> GG>\n)) (Algorithm 11).\n3: Let r be the number of columns of L. Compute the top m eigenvectors (U ∈ Rm×(m+r)) and eigenvalues (Σ ∈ Rm×m) of the matrix (\nD2 0m×r 0r×m 0r×r\n) + ( M>\nL>\n) ( M L ).\n4: Set N1 = U1F + U2Q1 and N2 = U2Q2 where U1 and U2 are the first m and last r columns of U respectively, and Q1 and Q2 are the left and right half of Q respectively. 5: Return (N1, N2,Σ).\nthe invariance Q̃ = QR and L̃ = L. The base case Q̃ = QR = 0 and L̃ = L = 0 is trivial. Now assume it holds for iteration i− 1 and consider iteration i. We have\nα̃ = Q̃K̃p̃ = QRR>p = QKp = α,\nβ̃ = p̃− Q̃>α̃ = R>p− (QR)>α = R>(p−Q>α) = R>β,\nc̃ = √ β̃ > K̃β̃ = √ (R>β)>(R>β) = √ β>Kβ = c,\nwhich clearly implies that after execution of Line 5-9, we again have Q̃ = QR and L̃ = L, finishing the induction.\nAlgorithm 11 Decompose(P, K) Input: P ∈ Rm×n, K ∈ Rm×m such that K is the Gram matrix K = RR> for some matrix\nR ∈ Rn×d where n ≥ m, d ≥ m, Output: L ∈ Rm×r and Q ∈ Rr×n such that LQR = PR where r is the rank of PR and the rows\nof QR are orthonormal. 1: Initialize L = 0m×m and Q = 0m×n. 2: for i = 1 to m do 3: Let p> be the i-th row of P .\n4: Compute α = QKp,β = p−Q>α and c = √ β>Kβ.\n5: if c 6= 0 then 6: Insert 1cβ\n> to the i-th row of Q. 7: end if 8: Set the i-th entry of α to be c and insert α to the i-th row of L. 9: end for\n10: Delete the all-zero columns of L and all-zero rows of Q. 11: Return (L,Q)."
    }, {
      "heading" : "G Details for sparse Oja’s algorithm",
      "text" : "We finally provide the missing details for the sparse version of the Oja’s algorithm. Since we already discussed the updates for w̄t and bt in Section 4, we just need to describe how the updates for Ft and Zt work. Recall that the dense Oja’s updates can be written in terms of F and Z as\nΛt = (Im − Γt)Λt−1 + Γt diag{Ft−1Zt−1ĝt} 2\nFtZt orth←−− Ft−1Zt−1 + ΓtFt−1Zt−1ĝtĝ > t = Ft−1(Zt−1 + F −1 t−1ΓtFt−1Zt−1ĝtĝ > t ) .\n(9)\nHere, the update for the eigenvalues is straightforward. For the update of eigenvectors, first we let Zt = Zt−1 + δtĝ > t where δt = F −1 t−1ΓtFt−1Zt−1ĝt (note that under the assumption of Footnote 4, Ft is always invertible). Now it is clear that Zt − Zt−1 is a sparse rank-one matrix and the update of ūt+1 is efficient. Finally it remains to update Ft so that FtZt is the same as orthonormalizing Ft−1Zt, which can in fact be achieved by applying the Gram-Schmidt algorithm to Ft−1 in a Banach space where inner product is defined as 〈a, b〉 = a>Ktb where Kt is the Gram matrix ZtZ>t (see Algorithm 11). Since we can maintain Kt efficiently based on the update of Zt:\nKt = Kt−1 + δtĝ > t Z > t−1 + Zt−1ĝtδ > t + (ĝ > t ĝt)δtδ > t ,\nthe update of Ft can therefore be implemented in O(m3) time."
    }, {
      "heading" : "H Experiment Details",
      "text" : "This section reports some detailed experimental results omitted from Section 5.2. Table 1 includes the description of benchmark datasets; Table 2 reports error rates on relatively small datasets to show that Oja-SON generally has better performance; Table 3 reports concrete error rates for the experiments described in Section 5.2; finally Table 4 shows that Oja’s algorithm estimates the eigenvalues accurately.\nAs mentioned in Section 5.2, we see substantial improvement for the splice dataset when using Oja’s sketch even after the diagonal adaptation. We verify that the condition number for this dataset before and after the diagonal adaptation are very close (682 and 668 respectively), explaining why a large improvement is seen using Oja’s sketch. Fig. 4 shows the decrease of error rates as Oja-SON with different sketch sizes sees more examples. One can see that even with m = 1 Oja-SON already performs very well. This also matches our expectation since there is a huge gap between the top and second eigenvalues of this dataset (50.7 and 0.4 respectively)."
    } ],
    "references" : [ {
      "title" : "The fast convergence of incremental pca",
      "author" : [ "A. Balsubramani", "S. Dasgupta", "Y. Freund" ],
      "venue" : "NIPS,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "A stochastic quasi-newton method for large-scale optimization",
      "author" : [ "R.H. Byrd", "S. Hansen", "J. Nocedal", "Y. Singer" ],
      "venue" : "SIAM Journal on Optimization, 26:1008–1031,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Prediction, Learning, and Games",
      "author" : [ "N. Cesa-Bianchi", "G. Lugosi" ],
      "venue" : "Cambridge University Press,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "A second-order perceptron algorithm",
      "author" : [ "N. Cesa-Bianchi", "A. Conconi", "C. Gentile" ],
      "venue" : "SIAM Journal on Computing, 34(3):640–668,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Adaptive subgradient methods for online learning and stochastic optimization",
      "author" : [ "J. Duchi", "E. Hazan", "Y. Singer" ],
      "venue" : "JMLR, 12:2121–2159,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Convergence rates of sub-sampled newton methods",
      "author" : [ "M.A. Erdogdu", "A. Montanari" ],
      "venue" : "NIPS,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "An algorithm for quadratic programming",
      "author" : [ "M. Frank", "P. Wolfe" ],
      "venue" : "Naval research logistics quarterly, 3 (1-2):95–110,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1956
    }, {
      "title" : "One-pass auc optimization",
      "author" : [ "W. Gao", "R. Jin", "S. Zhu", "Z.-H. Zhou" ],
      "venue" : "ICML,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "A linearly convergent conditional gradient algorithm with applications to online and stochastic optimization",
      "author" : [ "D. Garber", "E. Hazan" ],
      "venue" : "SIAM Journal on Optimization, 26:1493–1528,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Online learning of eigenvectors",
      "author" : [ "D. Garber", "E. Hazan", "T. Ma" ],
      "venue" : "ICML,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Frequent directions: Simple and deterministic matrix sketching",
      "author" : [ "M. Ghashami", "E. Liberty", "J.M. Phillips", "D.P. Woodruff" ],
      "venue" : "SIAM Journal on Computing, 45:1762–1792,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Efficient frequent directions algorithm for sparse matrices",
      "author" : [ "M. Ghashami", "E. Liberty", "J.M. Phillips" ],
      "venue" : "KDD,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Faster sgd using sketched conditioning",
      "author" : [ "A. Gonen", "S. Shalev-Shwartz" ],
      "venue" : "arXiv:1506.02649,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Solving ridge regression using sketched preconditioned svrg",
      "author" : [ "A. Gonen", "F. Orabona", "S. Shalev-Shwartz" ],
      "venue" : "ICML,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "The noisy power method: A meta algorithm with applications",
      "author" : [ "M. Hardt", "E. Price" ],
      "venue" : "NIPS,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Projection-free online learning",
      "author" : [ "E. Hazan", "S. Kale" ],
      "venue" : "ICML,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Logarithmic regret algorithms for online convex optimization",
      "author" : [ "E. Hazan", "A. Agarwal", "S. Kale" ],
      "venue" : "Machine Learning, 69(2-3):169–192,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Revisiting frank-wolfe: Projection-free sparse convex optimization",
      "author" : [ "M. Jaggi" ],
      "venue" : "ICML,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Rivalry of two families of algorithms for memory-restricted streaming pca",
      "author" : [ "C.-L. Li", "H.-T. Lin", "C.-J. Lu" ],
      "venue" : "arXiv:1506.01490,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Simple and deterministic matrix sketching",
      "author" : [ "E. Liberty" ],
      "venue" : "KDD,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "On the limited memory bfgs method for large scale optimization",
      "author" : [ "D.C. Liu", "J. Nocedal" ],
      "venue" : "Mathematical programming, 45(1-3):503–528,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "Adaptive bound optimization for online convex optimization",
      "author" : [ "H.B. McMahan", "M. Streeter" ],
      "venue" : "COLT,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Global convergence of online limited memory bfgs",
      "author" : [ "A. Mokhtari", "A. Ribeiro" ],
      "venue" : "JMLR, 16:3151–3181,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "A linearly-convergent stochastic l-bfgs algorithm",
      "author" : [ "P. Moritz", "R. Nishihara", "M.I. Jordan" ],
      "venue" : "AISTATS,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Simplified neuron model as a principal component analyzer",
      "author" : [ "E. Oja" ],
      "venue" : "Journal of mathematical biology, 15 (3):267–273,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 1982
    }, {
      "title" : "On stochastic approximation of the eigenvectors and eigenvalues of the expectation of a random matrix",
      "author" : [ "E. Oja", "J. Karhunen" ],
      "venue" : "Journal of mathematical analysis and applications, 106(1):69–84,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 1985
    }, {
      "title" : "Scale-free algorithms for online linear optimization",
      "author" : [ "F. Orabona", "D. Pál" ],
      "venue" : "ALT,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "A generalized online mirror descent with applications to classification and regression",
      "author" : [ "F. Orabona", "K. Crammer", "N. Cesa-Bianchi" ],
      "venue" : "Machine Learning, 99(3):411–435,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Newton sketch: A linear-time optimization algorithm with linearquadratic convergence",
      "author" : [ "M. Pilanci", "M.J. Wainwright" ],
      "venue" : "arXiv:1505.02250,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Normalized online learning",
      "author" : [ "S. Ross", "P. Mineiro", "J. Langford" ],
      "venue" : "UAI,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "A stochastic quasi-newton method for online convex optimization",
      "author" : [ "N.N. Schraudolph", "J. Yu", "S. Günter" ],
      "venue" : "AISTATS,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Fast large-scale optimization by unifying stochastic gradient and quasi-newton methods",
      "author" : [ "J. Sohl-Dickstein", "B. Poole", "S. Ganguli" ],
      "venue" : "ICML,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Sketching as a tool for numerical linear algebra",
      "author" : [ "D.P. Woodruff" ],
      "venue" : "Foundations and Trends in Machine Learning, 10(1-2):1–157,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 16,
      "context" : "Second order algorithms such as Online Newton Step [17] have the attractive property of being invariant to linear transformations of the data, but typically require space and update time quadratic in the number of dimensions.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 29,
      "context" : "We study an invariant learning setting similar to the paper [30] which compares the learner to a benchmark only constrained to generate bounded predictions on the sequence of examples.",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 16,
      "context" : "We show that a variant of the Online Newton Step [17], while quadratic in computation, stays regret-optimal with a nearly matching lower bound in this more general setting.",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 32,
      "context" : "While the idea of data sketching is widely studied [33], as far as we know our work is the first one to apply it to a general adversarial",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 10,
      "context" : "Two different sketching methods are considered: Frequent Directions [11, 20] and Oja’s algorithm [25, 26], both of which allow linear running time per round.",
      "startOffset" : 68,
      "endOffset" : 76
    }, {
      "referenceID" : 19,
      "context" : "Two different sketching methods are considered: Frequent Directions [11, 20] and Oja’s algorithm [25, 26], both of which allow linear running time per round.",
      "startOffset" : 68,
      "endOffset" : 76
    }, {
      "referenceID" : 24,
      "context" : "Two different sketching methods are considered: Frequent Directions [11, 20] and Oja’s algorithm [25, 26], both of which allow linear running time per round.",
      "startOffset" : 97,
      "endOffset" : 105
    }, {
      "referenceID" : 25,
      "context" : "Two different sketching methods are considered: Frequent Directions [11, 20] and Oja’s algorithm [25, 26], both of which allow linear running time per round.",
      "startOffset" : 97,
      "endOffset" : 105
    }, {
      "referenceID" : 9,
      "context" : "[10]).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 4,
      "context" : "Empirically, we evaluate our algorithm using the sparse Oja sketch (called Oja-SON) against first order methods such as diagonalized ADAGRAD [5, 22] on both ill-conditioned synthetic and a suite of real-world datasets.",
      "startOffset" : 141,
      "endOffset" : 148
    }, {
      "referenceID" : 21,
      "context" : "Empirically, we evaluate our algorithm using the sparse Oja sketch (called Oja-SON) against first order methods such as diagonalized ADAGRAD [5, 22] on both ill-conditioned synthetic and a suite of real-world datasets.",
      "startOffset" : 141,
      "endOffset" : 148
    }, {
      "referenceID" : 29,
      "context" : "Related work Our online learning setting is closest to the one proposed in [30], which studies scale-invariant algorithms, a special case of the invariance property considered here (see also [28, Section 5]).",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 26,
      "context" : "Orabona and Pál [27] study unrelated notions of invariance.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 7,
      "context" : "[8] study a specific randomized sketching method for a special online learning setting.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 20,
      "context" : "The L-BFGS algorithm [21] has recently been studied in the stochastic setting2 [2, 23, 24, 31, 32], but has strong assumptions with pessimistic rates in theory and reliance on the use of large mini-batches empirically.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 1,
      "context" : "The L-BFGS algorithm [21] has recently been studied in the stochastic setting2 [2, 23, 24, 31, 32], but has strong assumptions with pessimistic rates in theory and reliance on the use of large mini-batches empirically.",
      "startOffset" : 79,
      "endOffset" : 98
    }, {
      "referenceID" : 22,
      "context" : "The L-BFGS algorithm [21] has recently been studied in the stochastic setting2 [2, 23, 24, 31, 32], but has strong assumptions with pessimistic rates in theory and reliance on the use of large mini-batches empirically.",
      "startOffset" : 79,
      "endOffset" : 98
    }, {
      "referenceID" : 23,
      "context" : "The L-BFGS algorithm [21] has recently been studied in the stochastic setting2 [2, 23, 24, 31, 32], but has strong assumptions with pessimistic rates in theory and reliance on the use of large mini-batches empirically.",
      "startOffset" : 79,
      "endOffset" : 98
    }, {
      "referenceID" : 30,
      "context" : "The L-BFGS algorithm [21] has recently been studied in the stochastic setting2 [2, 23, 24, 31, 32], but has strong assumptions with pessimistic rates in theory and reliance on the use of large mini-batches empirically.",
      "startOffset" : 79,
      "endOffset" : 98
    }, {
      "referenceID" : 31,
      "context" : "The L-BFGS algorithm [21] has recently been studied in the stochastic setting2 [2, 23, 24, 31, 32], but has strong assumptions with pessimistic rates in theory and reliance on the use of large mini-batches empirically.",
      "startOffset" : 79,
      "endOffset" : 98
    }, {
      "referenceID" : 5,
      "context" : "Recent works [6, 14, 13, 29] employ sketching in stochastic optimization, but do not provide sparse implementations or extend in an obvious manner to the online setting.",
      "startOffset" : 13,
      "endOffset" : 28
    }, {
      "referenceID" : 13,
      "context" : "Recent works [6, 14, 13, 29] employ sketching in stochastic optimization, but do not provide sparse implementations or extend in an obvious manner to the online setting.",
      "startOffset" : 13,
      "endOffset" : 28
    }, {
      "referenceID" : 12,
      "context" : "Recent works [6, 14, 13, 29] employ sketching in stochastic optimization, but do not provide sparse implementations or extend in an obvious manner to the online setting.",
      "startOffset" : 13,
      "endOffset" : 28
    }, {
      "referenceID" : 28,
      "context" : "Recent works [6, 14, 13, 29] employ sketching in stochastic optimization, but do not provide sparse implementations or extend in an obvious manner to the online setting.",
      "startOffset" : 13,
      "endOffset" : 28
    }, {
      "referenceID" : 6,
      "context" : "The FrankWolfe algorithm [7, 18] is also invariant to linear transformations, but with worse regret bounds [16] without further assumptions and modifications [9].",
      "startOffset" : 25,
      "endOffset" : 32
    }, {
      "referenceID" : 17,
      "context" : "The FrankWolfe algorithm [7, 18] is also invariant to linear transformations, but with worse regret bounds [16] without further assumptions and modifications [9].",
      "startOffset" : 25,
      "endOffset" : 32
    }, {
      "referenceID" : 15,
      "context" : "The FrankWolfe algorithm [7, 18] is also invariant to linear transformations, but with worse regret bounds [16] without further assumptions and modifications [9].",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 8,
      "context" : "The FrankWolfe algorithm [7, 18] is also invariant to linear transformations, but with worse regret bounds [16] without further assumptions and modifications [9].",
      "startOffset" : 158,
      "endOffset" : 161
    }, {
      "referenceID" : 11,
      "context" : "For an invariant update, Recent work by [12] also studies sparse updates for a more complicated variant of Frequent Directions which is randomized and incurs extra approximation error.",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 29,
      "context" : "This relaxation is similar to the comparator set considered in [30].",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 29,
      "context" : "[30] are recovered.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "We study a choice of At that is similar to the Online Newton Step (ONS) [17] (though with different projections):",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 16,
      "context" : "extending the O(d lnT ) results in [17] to the weaker Assumption 2 and a larger comparator set K.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 10,
      "context" : "Frequent Directions sketch [11, 20] is a deterministic sketching method.",
      "startOffset" : 27,
      "endOffset" : 35
    }, {
      "referenceID" : 19,
      "context" : "Frequent Directions sketch [11, 20] is a deterministic sketching method.",
      "startOffset" : 27,
      "endOffset" : 35
    }, {
      "referenceID" : 10,
      "context" : "The sketch update works inO(md) time (see [11] and Appendix F) so the total running time is O(md) per round.",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 24,
      "context" : "Oja’s algorithm [25, 26] is not usually considered as a sketching algorithm but seems very natural here.",
      "startOffset" : 16,
      "endOffset" : 24
    }, {
      "referenceID" : 25,
      "context" : "Oja’s algorithm [25, 26] is not usually considered as a sketching algorithm but seems very natural here.",
      "startOffset" : 16,
      "endOffset" : 24
    }, {
      "referenceID" : 14,
      "context" : "To improve the running time to O(md), one can only update the sketch every m rounds (similar to the block power method [15, 19]).",
      "startOffset" : 119,
      "endOffset" : 127
    }, {
      "referenceID" : 18,
      "context" : "To improve the running time to O(md), one can only update the sketch every m rounds (similar to the block power method [15, 19]).",
      "startOffset" : 119,
      "endOffset" : 127
    }, {
      "referenceID" : 0,
      "context" : "[1, 19]).",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 18,
      "context" : "[1, 19]).",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 4,
      "context" : "5 We compare it with ADAGRAD [5, 22] on both synthetic and real-world datasets.",
      "startOffset" : 29,
      "endOffset" : 36
    }, {
      "referenceID" : 21,
      "context" : "5 We compare it with ADAGRAD [5, 22] on both synthetic and real-world datasets.",
      "startOffset" : 29,
      "endOffset" : 36
    }, {
      "referenceID" : 29,
      "context" : "[30].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "References [1] A.",
      "startOffset" : 11,
      "endOffset" : 14
    }, {
      "referenceID" : 1,
      "context" : "[2] R.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "[3] N.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 3,
      "context" : "[4] N.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5] J.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "[6] M.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "[7] M.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "[8] W.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "[9] D.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 9,
      "context" : "[10] D.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[11] M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "[12] M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "[13] A.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 13,
      "context" : "[14] A.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 14,
      "context" : "[15] M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 15,
      "context" : "[16] E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "[17] E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 17,
      "context" : "[18] M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "[19] C.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "[20] E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "[21] D.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 21,
      "context" : "[22] H.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 22,
      "context" : "[23] A.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "[24] P.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 24,
      "context" : "[25] E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 25,
      "context" : "[26] E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 26,
      "context" : "[27] F.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 27,
      "context" : "[28] F.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 28,
      "context" : "[29] M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 29,
      "context" : "[30] S.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 30,
      "context" : "[31] N.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 31,
      "context" : "[32] J.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 32,
      "context" : "[33] D.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 2,
      "context" : "2 in [3]).",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 10,
      "context" : "1 of [11]): ∑T t=1 ρt ≤ Ωk m−k .",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 10,
      "context" : "We begin by taking a detour and introducing a fast and epoch-based variant of the Frequent Directions algorithm proposed in [11].",
      "startOffset" : 124,
      "endOffset" : 128
    } ],
    "year" : 2017,
    "abstractText" : "We propose Sketched Online Newton (SON), an online second order learning algorithm that enjoys substantially improved regret guarantees for ill-conditioned data. SON is an enhanced version of the Online Newton Step, which, via sketching techniques enjoys a running time linear in the dimension and sketch size. We further develop sparse forms of the sketching methods (such as Oja’s rule), making the computation linear in the sparsity of features. Together, the algorithm eliminates all computational obstacles in previous second order online learning approaches.",
    "creator" : "LaTeX with hyperref package"
  }
}