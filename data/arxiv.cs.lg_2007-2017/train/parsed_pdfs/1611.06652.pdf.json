{
  "name" : "1611.06652.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Scalable Adaptive Stochastic Optimization Using Random Projections",
    "authors" : [ "Gabriel Krummenacher", "Brian McWilliams", "Yannic Kilcher", "Joachim M. Buhmann" ],
    "emails" : [ "gabriel.krummenacher@inf.ethz.ch", "brian@disneyresearch.com", "yannic.kilcher@inf.ethz.ch", "jbuhmann@inf.ethz.ch", "meinshausen@stat.math.ethz.ch" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Recently, adaptive stochastic optimization algorithms have gained popularity for large-scale convex and non-convex optimization problems. Among these, ADAGRAD [10] and its variants [22] have received particular attention and have proven among the most successful algorithms for training deep networks. Although these problems are inherently highly non-convex, recent work has begun to explain the success of such algorithms [3, 5].\nADAGRAD adaptively sets the learning rate for each dimension by means of a time-varying proximal regularizer. The most commonly studied and utilised version considers only a diagonal matrix proximal term. As such it incurs almost no additional computational cost over standard stochastic\n∗Authors contributed equally.\n30th Conference on Neural Information Processing Systems (NIPS 2016), Barcelona, Spain.\nar X\niv :1\n61 1.\n06 65\n2v 1\n[ st\nat .M\ngradient descent (SGD). However, when the data has low effective rank the regret of ADAGRAD may have a much worse dependence on the dimensionality of the problem than its full-matrix variant (which we refer to as ADA-FULL). Such settings are common in high dimensional data where there are many correlations between features and can also be observed in the convolutional layers of neural networks. The computational cost of ADA-FULL is substantially higher than that of ADAGRAD– it requires computing the inverse square root of the matrix of gradient outer products to evaluate the proximal term which grows with the cube of the dimension. As such it is rarely used in practise.\nIn this work we propose two methods that approximate the proximal term used in ADA-FULL drastically reducing computational and storage complexity with little adverse affect on optimization performance. First, in Section 3.1 we develop ADA-LR, a simple approximation using random projections. This procedure reduces the computational complexity of ADA-FULL by a factor of p but retains similar theoretical guarantees. In Section 3.2 we systematically profile the most computationally expensive parts of ADA-LR and introduce further randomized approximations resulting in a truly scalable algorithm, RADAGRAD. In Section 3.3 we outline a simple modification to RADAGRAD– reducing the variance of the stochastic gradients – which greatly improves practical performance. Finally we perform an extensive comparison between the performance of RADAGRAD with several widely used optimization algorithms on a variety of deep learning tasks. For image recognition with convolutional networks and language modeling with recurrent neural networks we find that RADAGRAD and in particular its variance-reduced variant achieves faster convergence."
    }, {
      "heading" : "1.1 Related work",
      "text" : "Motivated by the problem of training deep neural networks, very recently many new adaptive optimization methods have been proposed. Most computationally efficient among these are first order methods similar in spirit to ADAGRAD, which suggest alternative normalization factors [22, 29, 7]. Several authors propose efficient stochastic variants of classical second order methods such as LBFGS [6, 21]. Efficient algorithms exist to update the inverse of the Hessian approximation by applying the matrix-inversion lemma or directly updating the Hessian-vector product using the “double-loop” algorithm but these are not applicable to ADAGRAD style algorithms. In the convex setting these methods can show great theoretical and practical benefit over first order methods but have yet to be extensively applied to training deep networks.\nOn a different note, the growing zoo of variance reduced SGD algorithms [20, 8, 19] has shown vastly superior performance to ADAGRAD-style methods for standard empirical risk minimization and convex optimization. Recent work has aimed to move these methods into the non-convex setting [1]. Notably, [23] combine variance reduction with second order methods.\nMost similar to RADAGRAD are those which propose factorized approximations of second order information. Several methods focus on the natural gradient method [2] which leverages second order information through the Fisher information matrix. [15] approximate the inverse Fisher matrix using a sparse graphical model. [9] use low-rank approximations whereas [27] propose an efficient Kronecker product based factorization. Concurrently with this work, [13] propose a randomized preconditioner for SGD. However, their approach requires access to all of the data at once in order to compute the preconditioning matrix which is impractical for training deep networks. [24] propose a theoretically motivated algorithm similar to ADA-LR and a faster alternative based on Oja’s rule to update the SVD.\nFast random projections. Random projections are low-dimensional embeddings Π : Rp → Rτ which preserve – up to a small distortion – the geometry of a subspace of vectors. We concentrate on the class of structured random projections, among which the Subsampled Randomized Fourier Transform (SRFT) has particularly attractive properties [16]. The SRFT consists of a preconditioning step after which τ columns of the new matrix are subsampled uniformly at random as Π = √ p/τSΘD with the definitions: (i) S ∈ Rτ×p is a subsampling matrix. (ii) D ∈ Rp×p is a diagonal matrix whose entries are drawn independently from {−1, 1}. (iii) Θ ∈ Rp×p is a unitary discrete Fourier tranansform (DFT) matrix. This formulations allows very fast implementations using the fast Fourier transform (FFT), for example using the popular FFTW package2. Applying the FFT to a p−dimensional vector can be achieved in O (p log τ) time. Similar structured random projections\n2http://www.fftw.org/\nhave gained popularity as a way to speed up [25] and robustify [28] large-scale linear regression and for distributed estimation [18, 17]."
    }, {
      "heading" : "1.2 Problem setting",
      "text" : "The problem considered by [10] is online stochastic optimization where the goal is, at each step, to predict a point βt ∈ Rp which achieves low regret with respect to a fixed optimal predictor, βopt, for a sequence of (convex) functions Ft(β). After T rounds, the regret can be defined as R(T ) = ∑T t=1 Ft(βt)− ∑T t=1 Ft(β opt).\nInitially, we will consider functions Ft of the form Ft(β) := ft(β) + ϕ(β) where ft and ϕ are convex loss and regularization functions respectively. Throughout, the vector gt ∈ ∇ft(βt) refers to a particular subgradient of the loss function. Standard first order methods update βt at each step by moving in the opposite direction of gt according to a step-size parameter, η. The ADAGRAD family of algorithms [10] instead use an adaptive learning rate which can be different for each feature. This is controlled using a time-varying proximal term which we briefly review. Defining Gt = ∑t i=1 gig > i and Ht = δIp + (Gt−1 + gtg > t )\n1/2, the ADA-FULL proximal term is given by ψt(β) = 1 2 〈β,Htβ〉.\nClearly when p is large, constructing G and finding its root and inverse at each iteration is impractical. In practice, rather than the full outer product matrix, ADAGRAD uses a proximal function consisting of the diagonal of Gt, ψt(β) = 12 〈 β, ( δIp + diag(Gt)1/2 ) β 〉 . Although the diagonal proximal term is computationally cheaper, it is unable to capture dependencies between coordinates in the gradient terms. Despite this, ADAGRAD has been found to perform very well empirically. One reason for this is modern high-dimensional datasets are typically also very sparse. Under these conditions, coordinates in the gradient are approximately independent."
    }, {
      "heading" : "2 Stochastic optimization in high dimensions",
      "text" : "ADAGRAD has attractive theoretical and empirical properties and adds essentially no overhead above a standard first order method such as SGD. It begs the question, what we might hope to gain by introducing additional computational complexity. In order to motivate our contribution, we first present an analogue of the discussion in [11] focussing on when data is high-dimensional and dense. We argue that if the data has low-rank (rather than sparse) structure ADA-FULL can effectively adapt to the intrinsic dimensionality. We also show in Section 3.1 that ADA-LR has the same property.\nFirst, we review the theoretical properties of ADAGRAD algorithms, borrowing the g1:T,j notation[10].\nProposition 1. ADAGRAD and ADA-FULL achieve the following regret (Corollaries 6 & 11 from [10]) respectively:\nRD(T ) ≤ 2‖βopt‖∞ p∑\nj=1\n‖g1:T,j‖+ δ‖βopt‖1 , RF (T ) ≤ 2‖βopt‖ · tr(G1/2T ) + δ‖βopt‖. (1)\nThe major difference betweenRD(T ) andRF (T ) is the inclusion of the final full-matrix and diagonal proximal term, respectively. Under a sparse data generating distribution ADAGRAD achieves an up-to exponential improvement over SGD which is optimal in a minimax sense [11]. While data sparsity is often observed in practise in high-dimensional datasets (particularly web/text data) many other problems are dense. Furthermore, in practise applying ADAGRAD to dense data results in a learning rate which tends to decay too rapidly. It is therefore natural to ask how dense data affects the performance of ADA-FULL.\nFor illustration, consider when the data points xi are sampled i.i.d. from a Gaussian distribution PX = N (0,Σ). The resulting variable will clearly be dense. A common feature of high dimensional data is low effective rank defined for a matrix Σ as r(Σ) = tr(Σ)/‖Σ‖ ≤ rank(Σ) ≤ p. Low effective rank implies that r p and therefore the eigenvalues of the covariance matrix decay quickly. We will consider distributions parameterised by covariance matrices Σ with eigenvalues λj(Σ) = λ0j −α for j = 1, . . . , p.\nFunctions of the form Ft(β) = Ft(β>xt) have gradients ‖gt‖ ≤ M ‖xt‖. For example, the least squares loss Ft(β>xt) = 12 (yt − β\n>xt)2 has gradient gt = xt(yt − x>t βt) = xtεt, such that ‖εt‖ ≤M . Let us consider the effect of distributions parametrised by Σ on the proximal terms of full, and diagonal ADAGRAD. Plugging X into the proximal terms of (1) and taking expectations with respect to PX we obtain for ADAGRAD and ADA-FULL respectively:\nE p∑\nj=1\n‖g1:T,j‖ ≤ p∑\nj=1\n√√√√M2E T∑\nt=1\nx2t,j ≤ pM √ T , E tr(( T∑\nt=1\ngtg > t ) 1/2) ≤M √ Tλ0 p∑\nj=1\nj−α/2,\n(2)\nwhere the first inequality is from Jensen and the second is from noticing the sum of T squared Gaussian random variables is a χ2 random variable. We can consider the effect of fast-decaying spectrum: for α ≥ 2,∑pj=1 j−α/2 = O (log p) and for α ∈ (1, 2), ∑p j=1 j −α/2 = O ( p1−α/2 ) .\nWhen the data (and thus the gradients) are dense, yet have low effective rank, ADA-FULL is able to adapt to this structure. On the contrary, although ADAGRAD is computationally practical, in the worst case it may have exponentially worse dependence on the data dimension (p compared with log p). In fact, the discrepancy between the regret of ADA-FULL and that of ADAGRAD is analogous to the discrepancy between ADAGRAD and SGD for sparse data.\nAlgorithm 1 ADA-LR\nInput: η > 0, δ ≥ 0, τ 1: for t = 1 . . . T do 2: Receive gt = ∇ft(βt). 3: Gt = Gt−1 + gtg>t 4: Project: G̃t = GtΠ 5: QR = G̃t {QR-decomposition} 6: B = Q>Gt 7: U,Σ,V = B {SVD} 8: 9: 10: βt+1 = βt − ηV(Σ1/2 + δI)−1V>gt 11: end for Output: βT\nAlgorithm 2 RADAGRAD\nInput: η > 0, δ ≥ 0, τ 1: for t = 1 . . . T do 2: Receive gt = ∇ft(βt). 3: Project: g̃t = Πgt 4: G̃t = G̃t−1 + gtg̃>t 5: Qt,Rt← qr_update(Qt−1,Rt−1,gt, g̃t) 6: B = G̃>t Qt 7: U,Σ,W = B {SVD} 8: V = WQ>\n9: γt = η(gt −VV>gt) 10: βt+1 = βt−ηV(Σ1/2+δI)−1V>gt−γt 11: end for Output: βT\n3 Approximating ADA-FULL using random projections\nIt is clear that in certain regimes, ADA-FULL provides stark optimization advantages over ADAGRAD in terms of the dependence on p. However, ADA-FULL requires maintaining a p× p matrix, G and computing its square root and inverse. Therefore, computationally the dependence of ADA-FULL on p scales with the cube which is impractical in high dimensions.\nA naïve approach would be to simply reduce the dimensionality of the gradient vector, g̃t ∈ Rτ = Πgt. ADA-FULL is now directly applicable in this low-dimensional space, returning a solution vector β̃t ∈ Rτ at each iteration. However, for many problems, the original coordinates may have some intrinsic meaning or in the case of deep networks, may be parameters in a model. In which case it is important to return a solution in the original space. Unfortunately in general it is not possible to recover such a solution from β̃t [31].\nInstead, we consider a different approach to maintaining and updating an approximation of the ADAGRAD matrix while retaining the original dimensionality of the parameter updates β and gradients g."
    }, {
      "heading" : "3.1 Randomized low-rank approximation",
      "text" : "As a first approach we approximate the inverse square root of Gt using a fast randomized singular value decomposition (SVD) [16]. We proceed in two stages: First we compute an approximate basis Q for the range of Gt. Then we use Q to compute an approximate SVD of Gt by forming the smaller dimensional matrix B = Q>Gt and then compute the low-rank SVD UΣV> = B. This is faster than computing the SVD of Gt directly if Q has few columns.\nAn approximate basis Q can be computed efficiently by forming the matrix G̃t = GtΠ by means of a structured random projection and then constructing an orthonormal basis for the range of G̃t by QR-decomposition. The randomized SVD allows us to quickly compute the square root and pseudo-inverse of the proximal term Ht by setting H̃−1t = V(Σ\n1/2 + δI)−1V>. We call this approximation ADA-LR and describe the steps in full in Algorithm 1.\nIn practice, using a structured random projection such as the SRFT leads to an approximation of the original matrix, Gt of the following form ∥∥Gt −QQ>Gt ∥∥ ≤ , with high probability [16] where\ndepends on τ , the number of columns of Q; p and the τ th singular value of Gt. Briefly, if the singular values of Gt decay quickly and τ is chosen appropriately, will be small (this is stated more formally in Proposition 2). We leverage this result to derive the following regret bound for ADA-LR (see C.1 for proof).\nProposition 2. Let σk+1 be the kth largest singular value of Gt. Setting the projection dimension as 4 (√ k + √ 8 log(kn) )2 ≤ τ ≤ p and defining = √ 1 + 7p/τ · σk+1. With failure probability at most O ( k−1 ) ADA-LR achieves regret RLR(T ) ≤ 2‖βopt‖tr(G1/2T ) + (2τ √ + δ)‖βopt‖ . Due to the randomized approximation we incur an additional 2τ √ ‖βopt‖ compared with the regret of ADA-FULL (eq. 1). So, under the earlier stated assumption of fast decaying eigenvalues we can use an identical argument as in eq. (2) to similarly obtain a dimension dependence of O (log p+ τ). Approximating the inverse square root decreases the complexity of each iteration from O ( p3 ) to O ( τp2 ) . We summarize the cost of each step in Algorithm 1 and contrast it with the cost of ADA-FULL in Table A.1 in Section A. Even though ADA-LR removes one factor of p form the runtime of ADA-FULL it still needs to store the large matrix Gt. This prevents ADA-LR from being a truly practical algorithm. In the following section we propose a second algorithm which directly stores a low dimensional approximation to Gt that can be updated cheaply. This allows for an improvement in runtime to O ( τ2p ) .\n3.2 RADAGRAD: A faster approximation\nFrom Table A.1, the expensive steps in Algorithm 1 are the update of Gt (line 3), the random projection (line 4) and the projection onto the approximate range of Gt (line 6). In the following we propose RADAGRAD, an algorithm that reduces the complexity to O ( τ2p )\nby only approximately solving some of the expensive steps in ADA-LR while maintaining similar performance in practice.\nTo compute the approximate range Q, we do not need to store the full matrix Gt. Instead we only require the low dimensional matrix G̃t = GtΠ. This matrix can be computed iteratively by setting G̃t ∈ Rp×τ = G̃t−1 + gt(Πgt)>. This directly reduces the cost of the random projection to O (p log τ) since we only project the vector gt instead of the matrix Gt, it also makes the update of G̃t faster and saves storage.\nWe then project G̃t on the approximate range of Gt and use the SVD to compute the inverse square root. Since Gt is symmetric its row and column space are identical so little information is lost by projecting G̃t instead of Gt on the approximate range of Gt.3 The advantage is that we can now compute the SVD in O ( τ3 ) and the matrix-matrix product on line 6 in O ( τ2p ) . See Algorithm 2 for the full procedure.\nThe most expensive steps are now the QR decomposition and the matrix multiplications in steps 6 and 8 (see Algorithm 2 and Table A.1). Since at each iteration we only update the matrix G̃t with\n3This idea is similar to bilinear random projections [14].\nthe rank-one matrix gtg̃>t we can use faster rank-1 QR-updates [12] instead of recomputing the full QR decomposition. To speed up the matrix-matrix product G̃>t Q for very large problems (e.g. backpropagation in convolutional neural networks), a multithreaded BLAS implementation can be used."
    }, {
      "heading" : "3.3 Practical algorithms",
      "text" : "Here we outline several simple modifications to the RADAGRAD algorithm to improve practical performance.\nCorrected update. The random projection step only retains at most τ eigenvalues of Gt. If the assumption of low effective rank does not hold, important information from the p − τ smallest eigenvalues might be discarded. RADAGRAD therefore makes use of the corrected update\nβt+1 = βt − ηV(Σ1/2 + δI)−1V>gt − γt, where γt = η(I−VV>)gt. γt is the projection of the current gradient onto the space orthogonal to the one captured by the random projection of Gt. This ensures that important variation in the gradient which is poorly approximated by the random projection is not completely lost. Consequently, if the data has rank less than τ , ‖γ‖ ≈ 0. This correction only requires quantities which have already been computed but greatly improves practical performance.\nVariance reduction. Variance reduction methods based on SVRG [20] obtain lower-variance gradient estimates by means of computing a “pivot point” over larger batches of data. Recent work has shown improved theoretical and empirical convergence in non-convex problems [1] in particular in combination with ADAGRAD.\nWe modify RADAGRAD to use the variance reduction scheme of SVRG. The full procedure is given in Algorithm 3 in Section B. The majority of the algorithm is as RADAGRAD except for the outer loop which computes the pivot point, µ every epoch which is used to reduce the variance of the stochastic gradient (line 4). The important additional parameter is m, the update frequency for µ. As in [1] we set this to m = 5n. Practically, as is standard practise we initialise RADA-VR by running ADAGRAD for several epochs.\nWe study the empirical behaviour of ADA-LR, RADAGRAD and its variance reduced variant in the next section."
    }, {
      "heading" : "4 Experiments",
      "text" : ""
    }, {
      "heading" : "4.1 Low effective rank data",
      "text" : "We compare the performance of our proposed algorithms against both the diagonal and full-matrix ADAGRAD variants in the idealised setting where the data is dense but has low effective rank. We generate binary classification data with n = 1000 and p = 125. The data is sampled i.i.d. from a Gaussian distribution N (µc,Σ) where Σ has with rapidly decaying eigenvalues λj(Σ) = λ0j\n−α with α = 1.3, λ0 = 30. Each of the two classes has a different mean, µc.\nFor each algorithm learning rates are tuned using cross validation. The results for 5 epochs are averaged over 5 runs with different permutations of the data set and instantiations of the random projection for ADA-LR and RADAGRAD. For the random projection we use an oversampling factor so Π ∈ R(10+τ)×p to ensure accurate recovery of the top τ singular values and then set the values of λ[τ :p] to zero [16].\nFigure 1a shows the mean loss on the training set. The performance of ADA-LR and RADAGRAD match that of ADA-FULL. On the other hand, ADAGRAD converges to the optimum much more slowly. Figure 1b shows the largest eigenvalues (normalized by their sum) of the proximal matrix for each method at the end of training. The spectrum of Gt decays rapidly which is matched by the randomized approximation. This illustrates the dependencies between the coordinates in the gradients and suggests Gt can be well approximated by a low-dimensional matrix which considers these dependencies. On the other hand the spectrum of ADAGRAD (equivalent to the diagonal of G) decays much more slowly. The learning rate, η chosen by RADAGRAD and ADA-FULL are roughly one order of magnitude higher than for ADAGRAD."
    }, {
      "heading" : "4.2 Non-convex optimization in neural networks",
      "text" : "Here we compare RADAGRAD and RADA-VR against ADAGRAD and the combination of ADAGRAD+SVRG on the task of optimizing several different neural network architectures.\nConvolutional Neural Networks. We used modified variants of standard convolutional network architectures for image classification on the MNIST, CIFAR-10 and SVHN datasets. These consist of three 5× 5 convolutional layers generating 32 channels with ReLU non-linearities, each followed by 2× 2 max-pooling. The final layer was a dense softmax layer and the objevtive was to minimize the categorical cross entropy.\nWe used a batch size of 8 and trained the networks without momentum or weight decay, in order to eliminate confounding factors. Instead, we used dropout regularization (p = 0.5) in the dense layers during training. Step sizes were determined by coarsely searching a log scale of possible values and evaluating performance on a validation set. We found RADAGRAD to have a higher impact with convolutional layers than with dense layers, due to the higher correlations between weights. Therefore, for computational reasons, RADAGRAD was only applied on the convolutional layers. The last dense classification layer was trained with ADAGRAD. In this setting ADA-FULL is computationally infeasible. The number of parameters in the convolutional layers is between 50-80k. Simply storing the full G matrix using double precision would require more memory than is available on top-of-the-line GPUs.\nThe results of our experiments can be seen in Figure 2, where we show the objective value during training and the test accuracy. We find that both RADAGRAD variants consistently outperform both ADAGRAD and the combination of ADAGRAD+SVRG on these tasks. In particular combining RADAGRAD with variance reduction results in the largest improvement for training although both RADAGRAD variants quickly converge to very similar values for test accuracy.\nFor all models, the learning rate selected by RADAGRAD is approximately an order of magnitude larger than the one selected by ADAGRAD. This suggests that RADAGRAD can make more aggressive steps than ADAGRAD, which results in the relative success of RADAGRAD over ADAGRAD, especially at the beginning of the experiments.\nWe observed that RADAGRAD performed 5-10× slower than ADAGRAD per iteration. This can be attributed to the lack of GPU-optimized SVD and QR routines. These numbers are comparable with other similar recently proposed techniques [24]. However, due to the faster convergence we found that the overall optimization time of RADAGRAD was lower than for ADAGRAD.\nRecurrent Neural Networks. We trained the strongly-typed variant of the long short-term memory network (T-LSTM, [4]) for language modelling, which consists of the following task: Given a sequence of words from an original text, predict the next word. We used pre-trained GLOVE embedding vectors [30] as input to the T-LSTM layer and a softmax over the vocabulary (10k words) as output. The loss is the mean categorical crossentropy. The memory size of the T-LSTM units was set to 256. We trained and evaluated our network on the Penn Tree-\nbank dataset [26]. We subsampled strings of length 20 from the dataset and asked the network to predict each word in the string, given the words up to that point. Learning rates were selected by searching over a log scale of possible values and measuring performance on a validation set.\nWe compared RADAGRAD with ADAGRAD without variance reduction. The results of this experiment can be seen in Figure 3. During training, we found that RADAGRAD consistently outperforms ADAGRAD: RADAGRAD is able to both quicker reduce the training loss and also reaches a smaller value (5.62 × 10−4 vs. 1.52 × 10−3, a 2.7× reduction in loss). Again, we found that the selected learning rate is an order of magnitude higher for RADAGRAD than for ADAGRAD. RADAGRAD is able to exploit the fact that T-LSTMs perform type-preserving update steps which should preserve any low-rank structure present in the weight matrices. The relative improvement of RADAGRAD over ADAGRAD in training is also reflected in the test loss (1.15 × 10−2 vs. 3.23 × 10−2, a 2.8× reduction)."
    }, {
      "heading" : "5 Discussion",
      "text" : "We have presented ADA-LR and RADAGRAD which approximate the full proximal term of ADAGRAD using fast, structured random projections. ADA-LR enjoys similar regret to ADA-FULL and both methods achieve similar empirical performance at a fraction of the computational cost. Importantly, RADAGRAD can easily be modified to make use of standard improvements such as variance reduction. Using variance reduction in combination in particular has stark benefits for non-convex optimization in convolutional and recurrent neural networks. We observe a marked improvement over widely-used techniques such as ADAGRAD and SVRG, the combination of which has recently been proven to be an excellent choice for non-convex optimization [1].\nFurthermore, we tried to incorporate exponential forgetting schemes similar to RMSPROP and ADAM into the RADAGRAD framework but found that these methods degraded performance. A downside of such methods is that they require additional parameters to control the rate of forgetting.\nOptimization for deep networks has understandably been a very active research area. Recent work has concentrated on either improving estimates of second order information or investigating the effect of variance reduction on the gradient estimates. It is clear from our experimental results that a thorough\nstudy of the combination provides an important avenue for further investigation, particularly where parts of the underlying model might have low effective rank. Acknowledgements. We are grateful to David Balduzzi, Christina Heinze-Deml, Martin Jaggi, Aurelien Lucchi, Nishant Mehta and Cheng Soon Ong for valuable discussions and suggestions."
    }, {
      "heading" : "A Computational Complexity",
      "text" : "B RADA-VR: RADAGRAD with variance reduction.\nAlgorithm 3 RADA-VR\nInput: η > 0, δ ≥ 0, τ , S number of epochs, m iterations per epoch, initial β10 1: for s = 1 . . . S do 2: µ = ∇∑ni=1 fi(βs0) 3: for t = 1 . . .m− 1 do 4: Compute VR gradient: gt = ∇ft(βst )−∇ft(βs0) + µ 5: Project: g̃t = Πgt 6: G̃t = G̃t−1 + gtg̃>t 7: Qt,Rt← qr_update(Qt−1,Rt−1,gt, g̃t) 8: B = G̃>t Q 9: U,Σ,W = B {SVD} 10: V = WQ̃> 11: βst+1 = β s t − ηV(Σ1/2 + δI)−1V>gt − γt 12: end for 13: βs+10 = β s t+1 14: end for Output: βSm"
    }, {
      "heading" : "C Analysis",
      "text" : "C.1 Regret bound for ADA-LR\nThe following proof is based on the proof for Theorem 7 in [10]. The key difference is that instead of having the square root and (pseudo-)inverse of the full matrix Gt : G 1/2 t and S † t we have the approximate square root and inverse based on the randomized SVD [16]): S̃t = (QQ>Gt)1/2 and S̃†t = (QQ\n>Gt)−1/2. Essentially we use the proximal function ψt = 〈x, S̃tx〉 or ψt = 〈x, H̃tx〉 where we set H̃t = δI + S̃t. Here Q is the approximate basis for the range of the matrix Gt [16].\nWe first state the following facts about the relationship between G and G̃−1/2.\nLemma 3. Defining G̃−1/2 = (QQ>G)−1/2 we have\n(I) G̃−1/2G = (G−1(QQ>)G2)1/2 ,\n(II) tr((G−1(QQ>)G2)1/2) = tr(G̃1/2) .\nWe also require the following Lemma which bounds the sequence of proximal terms by the trace of the final G̃−1/2.\nLemma 4 (Based on Lemma 10 in [10]).\nT∑\nt=1\n〈gt, G̃−1/2t gt〉 ≤ 2 T∑\nt=1\n〈gt, G̃−1/2T gt〉 = 2tr(G̃ 1/2 T ). (3)\nWe are now ready to prove Proposition 2.\nProof of Proposition 2. Inspecting Lemma 6:\nR(T ) ≤ 1 η ψT (β opt) + η 2\nT∑\nt=1\n‖f ′t(βt)‖2ψ∗T−1 ,\nwe first bound the term ∑T t=1 ‖f ′t(βt)‖2ψ∗T−1 .\nFrom [10, Proof of Theorem 7] we have that the squared dual norm associated with ψt is\n‖x‖2ψ∗t = 〈x, (δI + (QQ >Gt) 1/2)−1x〉\nand thus it is clear that ‖gt‖2ψ∗t ≤ 〈gt, (QQ >Gt)−1/2gt〉. Lemma 8 shows that ‖gt‖2ψ∗t−1 ≤ 〈gt, S̃tgt〉 as long as δ ≥ ‖gt‖2. Lemma 4 then implies that T∑\nt=1\n‖f ′t(βt)‖2ψ∗T−1 ≤ 2tr(G̃ 1/2 T ).\nWe now bound 2tr(G̃1/2T ) by 2(tr(G 1/2 T ) + τ\n√ ):\ntr(G̃ 1/2 T )− tr(G 1/2 T ) = tr(G̃ 1/2 T −G 1/2 T ) (4)\n=\nτ∑\nj=1\n( λj(G̃ 1/2 T )− λj(G 1/2 T ) ) − p∑\nj=τ+1\nλj(G 1/2 T ) (5)\n≤ τ∑\nj=1\n( λ1(G̃ 1/2 T )− λ1(G 1/2 T ) ) (6)\nsince λj(G̃T ) = 0, ∀j > τ . Now, using the reverse triangle inequality and Theorem 5 we obtain\nτ∑\nj=1\n( λ1(G̃ 1/2 T )− λ1(G 1/2 T ) ) ≤ τ∑\nj=1\n‖G̃1/2T −G 1/2 T ‖2 (7)\n≤ τ∑\nj=1\n√ (8)\n≤ τ√ . (9)\nIt remains to show that ψT (βopt) in Lemma 6 is bounded by ( δ + √ + tr(G 1/2 T ) ) ‖βopt‖2 to get the statement of Theorem 2: ψT (β\nopt) = 〈βopt, δI + (QQ>GT )1/2βopt〉 ≤ ‖βopt‖2‖(QQ>GT )1/2‖2 + δ‖βopt‖2\n≤ ‖βopt‖2 (√ + ‖G1/2T ‖ ) + δ‖βopt‖2 ≤ ‖βopt‖2 (√\n+ tr(G 1/2 T )\n) + δ‖βopt‖2\nwhere we again use the reverse triangle inequality and Theorem 5 as above.\nFinally, plugging this into the statement of Lemma 6 and setting η = ‖βopt‖2 (as in Corollary 11 in [10]) we get the expression for the regret of ADA-LR as stated in Theorem 2.\nC.2 Proofs of supporting results\nProof of Lemma 3. By direct computation we have for (I) G̃−1/2G = (QQ>G)−1/2G\n= ((QQ>G)−1G2)1/2\n= (G−1(QQ>)−1G2)1/2\n= (G−1(QQ>)G2)1/2. and for (II)\ntr((G−1(QQ>)G2)1/2) = tr((Q>GQ)1/2)\n= tr((QQ>G)1/2)\n= tr(G̃1/2).\nProof of Lemma 4. We set up the following proof by induction. In the base case:\n〈g1, G̃−1/21 ,g1〉 = tr(G̃ −1/2 1 g1g > 1 ) = tr(G̃ 1/2 1 ) ≤ 2tr(G̃ 1/2 1 ),\nwhere we have used (II).\nNow, assuming that the lemma is true for T − 1, we get: T∑\nt=1\n〈gt, G̃−1/2t , gt〉 ≤ 2 T∑\nt=1\n〈gt, G̃−1/2T−1 gt〉+ 〈gT , G̃ −1/2 T gT 〉.\nNow using that G̃−1/2T−1 does not depend on t and (II): T−1∑\nt=1\n〈gt, G̃−1/2T−1 gt〉 = tr(G̃ −1/2 T−1 GT−1) = tr(G̃ 1/2 T−1).\nTherefore we get T∑\nt=1\n〈gt, G̃−1/2t gt〉 ≤ 2tr(G̃1/2T−1) + 〈gT , G̃ −1/2 T gT 〉. (10)\nWe can rewrite\ntr(G̃ 1/2 T−1) = tr( ( QT−1Q > T−1GT −QT−1Q>T−1gTg>T )1/2 ) (11)\nNow since range(QT−1) ⊂ range(QT ) and Proposition 8.5 in [16] we can use Lemma 7 with ν = 1 and g = gt to obtain:\n2tr(G̃ 1/2 T−1) + 〈gT , G̃ −1/2 T ,gT 〉 ≤ 2tr(G̃ 1/2 T ) (12)"
    }, {
      "heading" : "D Supporting Results",
      "text" : "Theorem 5 (SRFT approximation error (Theorem 11.2 in [16])). Defining = √\n1 + 7p/τ · σk+1 the following holds with failure probability at most O ( k−1 )\n∥∥Gt −QQ>Gt ∥∥ 2 ≤ , (13)\nwhere σk+1 is the kth largest singular value of Gt, and 4 [√ k + √ 8 log(kn) ]2 ≤ τ ≤ p.\nLemma 6 (Proposition 2 from [10]).\nR(T ) :=\nT∑\nt=1\nft(βt) + ϕ(βt)− ft(βopt)− ϕ(βopt) ≤ 1\nη ψT (β\nopt) + η\n2\nT∑\nt=1\n‖f ′t(βt)‖2ψ∗T−1\nLemma 7 (Lemma 8 from [10]). Let B 0. For any ν such that B− νgg> 0 the following holds\n2tr((B− νgg>)1/2) ≤ 2tr(B1/2)− νtr(B1/2gg>) Lemma 8 (Lemma 9 from [10]). Let δ ≥ ‖g‖2 and A 0, then\n〈g, (δI + A1/2)−1g〉 ≤ 〈g, ((A + gg>)†)1/2g〉"
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "Adaptive stochastic gradient methods such as ADAGRAD have gained popularity in<lb>particular for training deep neural networks. The most commonly used and studied<lb>variant maintains a diagonal matrix approximation to second order information<lb>by accumulating past gradients which are used to tune the step size adaptively. In<lb>certain situations the full-matrix variant of ADAGRAD is expected to attain better<lb>performance, however in high dimensions it is computationally impractical. We<lb>present ADA-LR and RADAGRAD two computationally efficient approximations<lb>to full-matrix ADAGRAD based on randomized dimensionality reduction. They are<lb>able to capture dependencies between features and achieve similar performance to<lb>full-matrix ADAGRAD but at a much smaller computational cost. We show that the<lb>regret of ADA-LR is close to the regret of full-matrix ADAGRAD which can have<lb>an up-to exponentially smaller dependence on the dimension than the diagonal<lb>variant. Empirically, we show that ADA-LR and RADAGRAD perform similarly to<lb>full-matrix ADAGRAD. On the task of training convolutional neural networks as<lb>well as recurrent neural networks, RADAGRAD achieves faster convergence than<lb>diagonal ADAGRAD.",
    "creator" : "LaTeX with hyperref package"
  }
}