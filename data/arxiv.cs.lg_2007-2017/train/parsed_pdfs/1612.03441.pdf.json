{
  "name" : "1612.03441.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Lock-Free Optimization for Non-Convex Problems",
    "authors" : [ "Shen-Yi Zhao", "Gong-Duo Zhang", "Wu-Jun Li" ],
    "emails" : [ "zhanggd}@lamda.nju.edu.cn,", "liwujun@nju.edu.cn" ],
    "sections" : [ {
      "heading" : "Introduction",
      "text" : "Many machine learning models can be formulated as the following optimization problem:\nmin w\n1\nn n∑ i=1 fi(w), (1)\nwhere w is the parameter to learn (optimize), n is the number of training instances, fi(w) is the loss defined on instance i. For example, assuming we are given a set of labeled instances {(xi, yi)|i = 1, 2, . . . , n}, where xi ∈ Rd is the feature vector and yi ∈ {1,−1} is the label of xi, fi(w) can be log(1 + e−yix\nT i w) + λ2 ‖w‖ 2 which is known as the regularized loss in logistic regression (LR). We can also take fi(w) to be max{0, 1− yixTi w}+ λ2 ‖w‖\n2 which is known as the regularized loss in support vector machine (SVM). Here, λ is the regularization hyper-parameter. Moreover, many other machine learning models, including neural networks (Krizhevsky, Sutskever, and Hinton 2012), matrix factorization (Koren, Bell, and Volinsky 2009), and principal component analysis (PCA) (Shamir 2015) and so on, can also be formulated as that in (1).\nWhen the problem in (1) is large-scale, i.e., n is large, researchers have recently proposed stochastic gradient descent (SGD) and its variants like SVRG (Johnson and\nCopyright c© 2017, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nZhang 2013) to solve it. Many works (Roux, Schmidt, and Bach 2012; Shalev-Shwartz and Zhang 2013; Johnson and Zhang 2013) have found that SGD-based methods can achieve promising performance in large-scale learning problems. According to the implementation platforms or systems, existing SGD-based methods can be divided into three categories: sequential SGD (SSGD) methods, parallel SGD (PSGD) methods, and distributed SGD (DSGD) methods. SSGD methods are designed for a single thread on a single machine, PSGD methods are designed for multicore (multi-thread) on a single machine with a shared memory1, and DSGD methods are designed for multiple machines.\nWhen the problem in (1) is convex, the SGD methods, including SSGD (Roux, Schmidt, and Bach 2012; Shalev-Shwartz and Zhang 2013; Johnson and Zhang 2013), PSGD (Recht et al. 2011) and DSGD (Jaggi et al. 2014; Li et al. 2014; Xing et al. 2015; Zhang, Zheng, and Kwok 2016), have achieved very promising empirical performance. Furthermore, good theoretical results about the convergence of the SGD methods are also provided by these existing works.\nIn many real applications, the problems to optimize can be non-convex. For example, the problems for the neural networks are typically non-convex. Because many researchers (Li et al. 2014; Xing et al. 2015) find that the SGD methods can also achieve good empirical results for nonconvex problems, theoretical proof about the convergence of SGD methods for non-convex problems has recently attracted much attention. Some progress has been achieved. For example, the works in (Ghadimi and Lan 2013; Reddi et al. 2016; Li et al. 2016; Allen-Zhu and Hazan 2016; Allen-Zhu and Yuan 2016) have proved the convergence of the sequential SGD and its variants for non-convex problems. There are also some other theoretical results for some particular non-convex problems, like PCA (Shamir 2015; 2016a; 2016b) and matrix factorization (Sa, Re, and Olukotun 2015). But all these works are only for SSGD methods.\nThere have appeared only two works (Lian et al. 2015; Huo and Huang 2016) which propose PSGD methods for non-convex problems with theoretical proof of convergence.\n1In some literatures, PSGD refers to the methods implemented on both multi-core and multi-machine systems. In this paper, PSGD only refers to the methods implemented on multi-core systems with a shared memory.\nar X\niv :1\n61 2.\n03 44\n1v 1\n[ st\nat .M\nL ]\n1 1\nD ec\n2 01\nHowever, the PSGD methods in (Lian et al. 2015) need write-lock or atomic operation for the memory to prove the convergence 2. Similarly, the work in (Huo and Huang 2016) also does not prove the convergence for the lockfree case in our paper. Recent works (Recht et al. 2011; Chaturapruek, Duchi, and Ré 2015; J. Reddi et al. 2015; Zhao and Li 2016) find that lock-free strategy based parallel SGD (LF-PSGD) methods can empirically outperform lockbased PSGD methods for multi-core systems. Although some existing works (Chaturapruek, Duchi, and Ré 2015; Zhao and Li 2016) have proved the convergence of these LFPSGD methods for convex problems, no work has proved the convergence of the LF-PSGD methods for non-convex problems.\nIn this paper, we provide the theoretical proof about the convergence of two representative LF-PSGD methods, Hogwild! (Recht et al. 2011; Chaturapruek, Duchi, and Ré 2015) and AsySVRG (Zhao and Li 2016), for non-convex problems. The contribution of this work can be outlined as follows:\n• Theoretical results show that both Hogwild! and AsySVRG can converge with lock-free strategy for nonconvex problems.\n• Hogwild! gets a convergence rate of O(1/ √ T̃ ) for non-\nconvex problems, where T̃ = p × T is the total iteration number of p threads.\n• AsySVRG gets a convergence rate of O(1/T̃ ) for nonconvex problems.\n• To get an -local optimal solution for AsySVRG, the computation complexity by all threads is O(n 2 3 / ), or\nequivalently the computation complexity of each thread is O(n 2 3\np ). This is faster than traditional parallel gradient decent methods whose computation complexity is O( np ) for each thread.\n• Empirical results also show that both Hogwild! and AsySVRG are convergent on non-convex problems, which successfully verifies our theoretical results."
    }, {
      "heading" : "Preliminary",
      "text" : "We use f(w) to denote the objective function in (1), which means f(w) = 1n ∑n i=1 fi(w). And we use ‖ · ‖ to denote the L2-norm ‖ · ‖2. Assumption 1. The function fi(·) in (1) is smooth, which means that there exists a constant L > 0, ∀a,b,\nfi(b) ≤ fi(a) +∇fi(a)T (b− a) + L\n2 ‖b− a‖2,\nor equivalently\n‖∇fi(b)−∇fi(a)‖ ≤ L‖b− a‖.\n2Although the implementation of AsySG-incon in (Lian et al. 2015) is lock-free, the theoretical analysis about the convergence of AsySG-incon is based on an assumption that no over-writing happens, i.e., the theoretical analysis is not for the lock-free case.\nThis is a common assumption for the convergence analysis of most existing gradient-based methods.\nSince we focus on non-convex problems in this paper, it is difficult to get the global solution of (1) based on the gradient methods. Hence, we use ‖∇f(w)‖2 to measure the convergence instead of f(w)−min\nw f(w).\nHere, we give a Lemma which is useful in the convergence analysis of Hogwild! and AsySVRG.\nLemma 1. Assume B is a positive semi-definite matrix with the largest eigenvalue less than or equal to 1 and the minimum eigenvalue α > 0, we have: ∀x,y,\n−∇f(x)TB∇f(y) ≤ L 2 2 ‖x− y‖2 − α 2 ‖∇f(x)‖2 .\nProof.\nα 2 ‖∇f(x)‖2 −∇f(x)TB∇f(y)\n≤1 2 ∥∥∥B 12∇f(x)∥∥∥2 −∇f(x)TB∇f(y) ≤1 2 ∥∥∥B 12∇f(x)∥∥∥2 −∇f(x)TB∇f(y) + 1 2\n∥∥∥B 12∇f(y)∥∥∥2 = 1\n2 ∥∥∥B 12 (∇f(x)−∇f(y))∥∥∥2 ≤L 2\n2 ‖x− y‖2 ."
    }, {
      "heading" : "Hogwild! for Non-Convex Problems",
      "text" : "The Hogwild! method (Recht et al. 2011) is listed in Algorithm 1. Each thread reads w from the shared memory, computes a stochastic gradient and updates the w in the shared memory. Please note that Hogwild! in (Recht et al. 2011) has several variants with locks or lock-free. Here, we only focus on the lock-free variant of Hogwild!, which means that we do not use any locks, either read-lock or write-lock, for all threads.\nAlgorithm 1 Hogwild! Initialization: p threads, initialize w0, η; For each thread, do: for l = 0, 1, 2, ..., T − 1 do\nRead current w in the shared memory, denoted as ŵ; Randomly pick up an i from {1, . . . , n} and compute the gradient∇fi(ŵ); w← w − η∇fi(ŵ);\nend for\nAs in (Zhao and Li 2016), we can construct an equivalent write sequence {wt}:\nwt+1 = wt − ηBt∇fit(ŵt), (2)\nwhere 0 ≤ t ≤ p×T , Bt is a random diagonal matrix whose diagonal entries are 0 or 1. The Bt is used to denote whether over-writing happens. If the kth diagonal entry of Bt is 0, it means that the kth element in the gradient vector ∇fit(ŵt)\nis overwritten by other threads. Otherwise, that element is not overwritten.\nŵt is read by the thread who computes∇fit(ŵt) and has the following format:\nŵt = wa(t) − η t−1∑ j=a(t) Pt,j−a(t)∇fij (ŵj), (3)\nwhere a(t) means that some old stochastic gradients have been completely written on the w in the shared memory. Pt,j−a(t) is a diagonal matrix whose diagonal entries are 0 or 1, which means ŵt might include parts of new stochastic gradients.\nIn the lock-free strategy, we need the following assumptions to guarantee convergence:\nAssumption 2. a(t) is bounded by: 0 ≤ t− a(t) ≤ τ It means that the old stochastic gradients ∇fi0 , . . . ,∇fit−τ−1 have been completely written on w in the shared memory.\nAssumption 3. We consider the matrix Bt as a random matrix and E[Bt|wt, ŵt] = B 0 with the minimum eigenvalue α > 0.\nAccording to the definition of Bt, it is easy to find Bt,B are positive semi-definite matrices and the largest eigenvalue of B is less than or equal to 1. Assumption 3 means that the probability that over-writing happens is at most 1 − α < 1 for each write step.\nAssumption 4. Bt and it are independent. Since it is the random index selected by each thread while Bt is highly affected by the hardware, the independence assumption is reasonable.\nFor Hogwild!, the following assumption is also necessary:\nAssumption 5. There exists a constant V , ‖∇fi(w)‖ ≤ V, i = 1, . . . , n.\nFor convenience, in this section, we denote\nq(x) = 1\nn n∑ i=1 ‖fi(x)‖2.\nIt is easy to find that Eq(ŵt) = E[‖∇fit(ŵt)‖2] and note that when x is close to some stationary point, q(x) may still be far away from 0. Hence, it is not a variance reduction method and we need to control the variance of the stochastic gradient.\nThe difficulty of the analysis is wt 6= ŵt. Here, we give the following Lemmas 3:\nLemma 2. In Hogwild!, we have Eq(ŵt) ≤ ρEq(ŵt+1) if ρ, η satisfy\n1\n1− η − 9η(τ+1)L 2(ρτ+1−1)\nρ−1\n≤ ρ.\n3The proof of some Lemmas can be found in the supplementary material, which can be downloaded from http://cs.nju. edu.cn/lwj/paper/LFnonConvex_sup.pdf.\nLemma 3. With the condition about ρ, η in Lemma 2, we have\nE‖wt − ŵt‖2 ≤ 4η2τρ(ρτ − 1)\nρ− 1 Eq(ŵt) (4)\nCombining with Assumption 5, we can find that the gap of the write sequence and read sequence can always be bounded by a constant 4η\n2V 2τρ(ρτ−1) ρ−1 .\nTheorem 1. LetA = 2f(w0)α andB = 2V 2( 2τL 2ηρ(ρτ−1) α(ρ−1) +\nL 2α ). If we take the stepsize η = √ A T̃B\n, where T̃ = p × T , we can get the following result:\n1\nT̃ T̃−1∑ t=0 E‖∇f(wt)‖2 ≤ √ AB T̃ .\nProof. According to Assumption 1, we have\nE[f(wt+1)|wt, ŵt] ≤f(wt)− ηE[∇f(wt)TBt∇fit(ŵt)|wt, ŵt]\n+ Lη2\n2 E[‖∇fit(ŵt)‖2|wt, ŵt]\n=f(wt)− η∇f(wt)TB∇f(ŵt)\n+ Lη2\n2 E[‖∇fit(ŵt)‖2|wt, ŵt]\n≤f(wt)− αη\n2 ‖∇f(wt)‖2 +\nL2η\n2 ‖wt − ŵt‖2\n+ Lη2\n2 E[‖∇fit(ŵt)‖2|wt, ŵt],\nwhere the first equality uses Assumption 4, the second inequality uses Lemma 1. Taking expectation on the above inequality, we obtain\nEf(wt+1)\n≤Ef(wt)− αη\n2 E‖∇f(wt)‖2 +\nL2η\n2 E‖wt − ŵt‖2\n+ Lη2V 2\n2\n≤Ef(wt)− αη\n2 E‖∇f(wt)‖2\n+ η2V 2( 2τL2ηρ(ρτ − 1) ρ− 1 + L 2 ),\nwhere the first inequality uses Assumption 5 and second inequality uses Lemma 3. Summing the above inequality from t = 0 to T̃ − 1, we get\nT̃−1∑ t=0 E‖∇f(wt)‖2\n≤ 2 αη f(w0) + 2ηT̃V 2( 2τL2ηρ(ρτ − 1) α(ρ− 1) + L 2α ).\nFor convenience, let A = 2f(w0)α and B = 2V 2( 2τL 2ηρ(ρτ−1) α(ρ−1) + L 2α ), which are two bounded constants.\nIf we take the stepsize η = √\nA T̃B , we get\n1\nT̃ T̃−1∑ t=0 E‖∇f(wt)‖2 ≤ √ AB T̃ .\nHence, our theoretical result shows that Hogwild! with lock-free strategy gets a convergence rate of O(1/ √ T̃ ) for\nnon-convex problems, where T̃ = p×T is the total iteration number of p threads."
    }, {
      "heading" : "AsySVRG for Non-Convex Problems",
      "text" : "The AsySVRG method (Zhao and Li 2016) is listed in Algorithm 2. AsySVRG provides a lock-free parallel strategy for the original sequential SVRG (Johnson and Zhang 2013). Compared with Hogwild!, AsySVRG includes the full gradient to get a variance reduced stochastic gradient, which has been proved to have linear convergence rate on strongly convex problems (Zhao and Li 2016). In this section, we will prove that AsySVRG is also convergent for non-convex problems, and has faster convergence rate than Hogwild! on non-convex problems.\nAlgorithm 2 AsySVRG Initialization: p threads, initialize w0, η; for t = 0, 1, 2, ...T − 1 do\nu0 = wt; All threads parallelly compute the full gradient ∇f(u0) = 1 n ∑n i=1∇fi(u0); u = wt; For each thread, do: for j = 0 to M − 1 do\nRead current value of u, denoted as û, from the shared memory. And randomly pick up an i from {1, . . . , n}; Compute the update vector: v̂ = ∇fi(û) − ∇fi(u0) + ∇f(u0); u← u− ηv̂; end for Take wt+1 to be the current value of u in the shared memory;\nend for\nSimilar to the analysis in the last section, we construct an equivalent write sequence {ut,m} for the tth outer-loop:\nut,0 = wt,\nut,m+1 = ut,m − ηBt,mv̂t,m, (5)\nwhere v̂t,m = ∇fit,m(ût,m) − ∇fit,m(ut,0) + ∇f(ut,0). Bt,m is a diagonal matrix whose diagonal entries are 0 or 1. And ût,m is read by the thread who computes v̂t,m. It has the following format:\nût,m = ut,a(m) − η m−1∑ j=a(m) P (t) m,j−a(m)v̂t,j ,\nwhere P(t)m,j−a(m) is a diagonal matrix whose diagonal entries are 0 or 1. Note that according to (5), ut,M̃ = wt+1\nsince all the stochastic gradients have been written on w at the end of the tth outer-loop. Here, we also need the assumptions: 0 ≤ m − a(m) ≤ τ ; E[Bt,m|ut,m, ût,m] = B 0 with the minimum eigenvalue α > 0; Bt,m and it,m are independent. These assumptions are similar to those in the previous section.\nFor convenience, let pi(x) = ∇fi(x) − ∇fi(ut,0) + ∇f(ut,0), and in this section, we denote\nq(x) = 1\nn n∑ i=1 ‖pi(x)‖2."
    }, {
      "heading" : "It easy to find that Eq(ût,m) = E[‖v̂t,m‖2].",
      "text" : "The difference between Hogwild! and AsySVRG is the stochastic gradient and we have the following Lemmas which lead to fast convergence rate of AsySVRG: Lemma 4. ∀x, we have\nq(x) ≤ 2L2‖x− ut,0‖2 + 2‖∇f(x)‖2. Proof.\nq(x) = 1\nn n∑ i=1 ‖∇fi(x)−∇fi(ut,0) +∇f(ut,0)‖2\n≤ 2 n n∑ i=1 ‖∇fi(x)−∇fi(ut,0) +∇f(ut,0)−∇f(x)‖2\n+ 2‖∇f(x)‖2\n≤ 2 n n∑ i=1 ‖∇fi(x)−∇fi(ut,0)‖2 + 2‖∇f(x)‖2\n≤2L2‖x− ut,0‖2 + 2‖∇f(x)‖2.\nAccording to Lemma 4, we can find that AsySVRG is a variance reduction method for non-convex problems, because when ût,m,ut,0 get close to some stationary point, q(ût,m) gets close to 0. And hence we do not need the bounded gradient assumption for the convergence proof.\nSince ut,m 6= ût,m, the difficulty of convergence analysis lies in the gap between ut,m and ût,m, and the relation between q(ût,m) and q(ut,m). Lemma 5. In AsySVRG, we have Eq(ût,m) < ρEq(ût,m+1) if we choose ρ and η to satisfy that\n1\n1− η − 9η(τ+1)L 2(ρτ+1−1)\nρ−1\n≤ ρ.\nLemma 6. With the condition about ρ, η in Lemma 5, we have\nE‖ut,m − ût,m‖2 ≤ 4η2τρ(ρτ − 1)\nρ− 1 Eq(ût,m). (6)\nLemma 7. With the condition about ρ, η in Lemma 5, we have Eq(ût,m) < ρEq(ut,m).\nCombining Lemma 6 and Lemma 7, we can directly obtain:\nE ‖ût,m − ut,m‖2 ≤ 4η2τρ2(ρτ − 1)\nρ− 1 Eq(ut,m). (7)\nTheorem 2. We define cm = cm+1(1+βη)+2L2η2hm+1, hm = ( ηL2 2 + 2cmη β ) 4τρ2(ρτ−1) ρ−1 +(cmρ+ Lρ 2 ) with c0, β > 0. Furthermore, we choose c0, η, β such that γ = min αη2 − 2cm+1η\nβ − 2η 2hm+1 > 0 and cM̃ = 0, where M̃ = M × p.\nThen we have\n1\nTM̃ T−1∑ t=0 M̃−1∑ m=0 E‖∇f(ut,m)‖2 ≤ Ef(w0)− Ef(wT ) TM̃γ .\nProof. In the tth outer-loop, similar to (Reddi et al. 2016), we define Rt,m as follows\nRt,m = f(ut,m) + cm‖ut,m − ut,0‖2.\nThen ∀β > 0,\nE[‖ut,m+1 − ut,0‖2|ut,m, ût,m] ≤E‖ut,m+1 − ut,m‖2 + ‖ut,m − ut,0‖2\n− 2η(EBt,mv̂t,m)T (ut,m − ut,0) ≤η2E‖v̂t,m‖2 + (1 + βη)‖ut,m − ut,0‖2\n+ η\nβ ‖∇f(ût,m)‖2\n≤η2E‖v̂t,m‖2 + (1 + βη)‖ut,m − ut,0‖2\n+ 2η\nβ (‖∇f(ut,m)‖+ ‖∇f(ût,m)−∇f(ut,m)‖2)\n≤η2E‖v̂t,m‖2 + (1 + βη)‖ut,m − ut,0‖2\n+ 2η\nβ (‖∇f(ut,m)‖2\n+ L2‖ût,m − ut,m‖2), (8)\nwhere the second inequality uses the fact 2ab ≤ βa2 + 1β b 2. Since the objective function is L-smooth, we have\nE[f(ut,m+1)|ut,m, ût,m] ≤− ηE[∇f(ut,m)TBt,m∇fit,m(ût,m)|ut,m, ût,m]\n+ f(ut,m) + Lη2\n2 E[‖v̂t,m‖2|ut,m, ût,m]\n=f(ut,m)− η∇f(ut,m)TB∇f(ût,m)\n+ Lη2\n2 E[‖v̂t,m‖2|ut,m, ût,m]\n≤f(ut,m)− αη\n2 ‖∇f(ut,m)‖2\n+ ηL2\n2 ‖ut,m − ût,m‖2\n+ Lη2\n2 E[‖v̂t,m‖2|ut,m, ût,m], (9)\nwhere the first equality uses the independence of Bt,m, it,m, the second inequality uses Lemma 1. Combining (8) and (9),\nwe have\nERt,m+1 =Ef(ut,m+1) + cm+1‖ut,m+1 − ut,0‖2\n≤Ef(ut,m)− ( αη 2 − 2cm+1η β )E‖∇f(ut,m)‖2\n+ ( ηL2\n2 +\n2cm+1η\nβ )E‖ut,m − ût,m‖2\n+ cm+1(1 + βη)E‖ut,m − ut,0‖2\n+ η2(cm+1 + L\n2 )E‖v̂t,m‖2\n≤Ef(ut,m)− ( αη 2 − 2cm+1η β )E‖∇f(ut,m)‖2\n+ ( ηL2\n2 +\n2cm+1η β ) 4τη2ρ2(ρτ − 1) ρ− 1 Eq(ut,m)\n+ cm+1(1 + βη)E‖ut,m − ut,0‖2\n+ η2(cm+1 + L\n2 )E‖v̂t,m‖2,\nwhere the last inequality uses equation (7). For convenience, we use hm = (ηL 2\n2 + 2cmη β ) 4τρ2(ρτ−1) ρ−1 + ρ(cm + L 2 ). Since E[‖v̂t,m‖ 2] = Eq(ût,m) ≤ ρEq(ut,m), we have ERt,m+1\n≤Ef(ut,m)− ( αη 2 − 2cm+1η β )E‖∇f(ut,m)‖2\n+ cm+1(1 + βη)E‖ut,m − ut,0‖2 + η2hm+1Eq(ut,m) ≤Ef(ut,m) + [cm+1(1 + βη) + 2L 2η2hm+1]E‖ut,m − ut,0‖2\n− (αη 2 − 2cm+1η β − 2η2hm+1)E‖∇f(ut,m)‖2,\nwhere the second inequality uses Lemma 4. Then we can obtain:\n( αη 2 − 2cm+1η β − 2η2hm+1)E‖∇f(um)‖2\n≤ ERm − ERm+1,\nwhere cm = cm+1(1 + βη) + 2L2η2hm+1. We set c0 > 0. It is easy to see that cm > cm+1. We can choose c0, η, β to make cM̃ = 0. Then we have:\nM̃−1∑ m=0 E‖∇f(ut,m)‖2\n≤ ER0 − ERM̃\nγ = Ef(wt)− Ef(wt+1) γ ,\nwhich is equivalent to\n1\nTM̃ T−1∑ t=0 M̃−1∑ m=0 E‖∇f(ut,m)‖2 ≤ Ef(w0)− Ef(wT ) TM̃γ ."
    }, {
      "heading" : "Computation Complexity",
      "text" : "In Theorem 2, we construct a sequence {cm} and need γ > 0. According to the definition of hm, we can write hm as hm = gcm + f , where g = 2ηβ 4τρ2(ρτ−1) ρ−1 + ρ, f = ηL2\n2 4τρ2(ρτ−1) ρ−1 + Lρ 2 are constants.\nFirst, we choose β > η, then both g, f are bounded positive constants. We have\ncm = cm+1(1 + βη + 2L 2η2g) + 2L2η2f.\nLet a = βη + 2L2η2g. Because cM̃ = 0, it is easy to get\nc0 = 2L 2η2f (1 + a)M̃ − 1 a .\nWe take M̃ = b 1ac ≤ 1 a , then we have c0 ≤ 4L2η2f a and\nγ = α 2 (η − 4c0η αβ − 4gc0 α η2 − 4f α η2).\nAs recommended in (Reddi et al. 2016), we can take η = µ/n2/3, β = v/n1/3 with η < β (assuming n is large). Then we can get f = O(1), g = O(1), a = O(1/n). By choosing µ, v to satisfy 16L\n2fµ αv2 < 1 such that 4c0 αβ < 1, it is easy to\nfind that γ = O(1/n2/3) > 0, M̃ = O(n). Hence, to get an -local optimal solution, the computation complexity by all p threads isO(n 2 3 / ), and the computation complexity of each thread is O(n 2 3\np )."
    }, {
      "heading" : "Experiment",
      "text" : "To verify our theoretical results about Hogwild! and AsySVRG, we use a fully-connected neural network to construct a non-convex function. The neural network has one hidden layer with 100 nodes and the sigmoid function is used for the activation function. We use the soft-max output and a L2 regularization for training. The loss function is:\nf(w,b) = − 1 n n∑ i=1 K∑ k=1 1{yi = k} log o(k)i + λ 2 ‖w‖2,\nwhere w is the weights of the neural network, b is the bias, yi is the label of instance xi, o (k) i is the output corresponding to xi, K is the total number of class labels. We use two datasets: connect-4 and MNIST4 to do experiments and λ = 10−3. We initialize w by randomly sampling from a Gaussian distribution with mean being 0 and variance being 0.01, and initialize b = 0. During training, we use a fixed stepsize for both Hogwild! and AsySVRG. The stepsize is chosen from {0.1, 0.05, 0.01, 0.005, 0.001, 0.0005, 0.0001}, and the best is reported. For the iteration number of the inner-loop of AsySVRG, we set M = n/p, where p is the number of threads. The experiments are conducted on a server with 12 Intel cores and 64G memory.\n4https://www.csie.ntu.edu.tw/∼cjlin/libsvmtools/datasets/\nFigure 1 illustrates the convergence property of both Hogwild! and AsySVRG. The x-axis denotes the CPU time, where we set the CPU time that Hogwild! passes through the whole dataset once with one thread as 1 unit. The yaxis denotes the training loss. In this experiment, we run Hogwild! and AsySVRG with 10 threads. Hogwild!-10 and AsySVRG-10 denote the corresponding methods with 10 threads. It is easy to see that both Hogwild! and AsySVRG are convergent. Furthermore, AsySVRG is faster than Hogwild!. This is consistent with our theoretical results in this paper.\nFigure 2 reports the results of Hogwild! and AsySVRG with different numbers of threads, where the number of threads p = 1, 4, 10. We can find that in most cases the two methods will become faster with the increase of threads. The only outlier is the case for Hogwild! on dateset connect-4, Hogwild! using 4 threads is slower than using 1 thread. One possible reason is that we have two CPUs in our server, with 6 cores for each CPU. In the 4-thread case, different threads may be allocated on different CPUs, which will cause extra cost."
    }, {
      "heading" : "Conclusion",
      "text" : "In this paper, we have provided theoretical proof about the convergence of two representative lock-free strategy based parallel SGD methods, Hogwild! and AsySVRG, for nonconvex problems. Empirical results also show that both Hogwild! and AsySVRG are convergent on non-convex problems, which successfully verifies our theoretical results. To the best of our knowledge, this is the first work to prove the convergence of lock-free strategy based parallel SGD methods for non-convex problems."
    }, {
      "heading" : "Acknowledgements",
      "text" : "This work is partially supported by NSFC (No. 61472182) and a fund from Tencent."
    }, {
      "heading" : "Appendix",
      "text" : ""
    }, {
      "heading" : "Proof of Lemma 2",
      "text" : "Proof. First, ∀x,y and r > 0, we have:\n‖∇fi(x)‖2 − ‖∇fi(y)‖2\n≤2∇fi(x)T (∇fi(x)−∇fi(y))\n≤1 r ‖∇fi(x)‖2 + r ‖∇fi(x)−∇fi(y)‖2 = 1\nr ‖∇fi(x)‖2 + r ‖∇fi(x)−∇fi(y)‖2\n≤1 r ‖∇fi(x)‖2 + rL2 ‖x− y‖2 (10)\nIn the above equation, take x = ŵt,y = ŵt+1, we obtain:\n‖∇fi(ŵt)‖2 − ‖∇fi(ŵt+1)‖2\n≤1 r ‖∇fi(ŵt)‖2 + rL2 ‖ŵt − ŵt+1‖2\nAccording to the definition of ŵt, we have\n‖ŵt − ŵt+1‖\n=‖wa(t) − η t−1∑ j=a(t) Pt,j−a(t)∇fij (ŵj)\n− (wa(t+1) − η t∑\nj=a(t+1)\nPt+1,j−a(t+1)∇fij (ŵj))‖\n≤ ∥∥wa(t) −wa(t+1)∥∥ + η\nt−1∑ j=a(t) ∥∥∇fij (ŵj)∥∥+ η t∑ j=a(t+1) ∥∥∇fij (ŵj)∥∥ ≤ a(t+1)−1∑ j=a(t) ‖wj −wj+1‖\n+ η t−1∑ j=a(t) ∥∥∇fij (ŵj)∥∥+ η t∑ j=a(t+1) ∥∥∇fij (ŵj)∥∥ ≤η\na(t+1)−1∑ j=a(t) ∥∥∇fij (ŵj)∥∥ + η\nt−1∑ j=a(t) ∥∥∇fij (ŵj)∥∥+ η t∑ j=a(t+1) ∥∥∇fij (ŵj)∥∥ ≤3η\nt∑ j=t−τ ∥∥∇fij (ŵj)∥∥ . Combining the two above equation, we obtain:\n‖∇fi(ŵt)‖2 − ‖∇fi(ŵt+1)‖2\n≤1 r ‖∇fi(ŵt)‖2 + 9r(τ + 1)L2η2 t∑ j=t−τ ∥∥∇fij (ŵj)∥∥2\nFor any fixed i, we take expectation on the random index ij , we obtain:\n‖∇fi(ŵt)‖2 − ‖∇fi(ŵt+1)‖2\n≤1 r ‖∇fi(ŵt)‖2 + 9r(τ + 1)L2η2 t∑ j=t−τ q(ŵj)\nSumming up i from 1 to n, we obtain: Eq(ŵt)− Eq(ŵt+1)\n≤1 r Eq(ŵt) + 9r(τ + 1)L2η2 t∑ j=t−τ Eq(ŵj)\nNow, we prove the final result by induction and take r = 1η . When t = 0, we have\nEq(ŵ0) ≤ 1\n1− η − 9η(τ + 1)L2 Eq(ŵ1) ≤ ρEq(ŵ1)\nAssuming the result is right for t− 1, then we have Eq(ŵt)− Eq(ŵt+1)\n≤1 r Eq(ŵt) + 9η(τ + 1)L2Eq(ŵj) t∑ j=t−τ ρt−j\nwhich means\nEq(ŵt) ≤ 1\n1− η − 9η(τ+1)L 2(ρτ+1−1)\nρ−1\nEq(ŵt+1) ≤ ρEq(ŵt+1)"
    }, {
      "heading" : "Proof of Lemma 3",
      "text" : "Proof.\n‖wt − ŵt‖\n=‖wt −wa(t) + η t−1∑ j=a(t) Pt,j−a(t)∇fij (ŵj)‖ ≤‖wt −wa(t)‖+ η t−1∑ j=a(t) ‖∇fij (ŵj)‖ ≤ t−1∑ j=a(t) ‖wj −wj+1‖+ η t−1∑ j=a(t) ‖∇fij (ŵj)‖ ≤2η t−1∑ j=a(t) ‖∇fij (ŵj)‖\nThen we get the result\nE‖wt − ŵt‖2 ≤4η2τ t−1∑ j=a(t) E‖∇fij (ŵj)‖2\n=4η2τ t−1∑ j=a(t) Eq(ŵj)\n≤4η 2τρ(ρτ − 1) ρ− 1 Eq(ŵt)\nwhere the last inequality uses Lemma 2 in the appendix."
    }, {
      "heading" : "Proof of Lemma 5",
      "text" : "Proof. First, ∀x,y and r > 0, we have:\n‖pi(x)‖2 − ‖pi(y)‖2\n≤2pi(x)T (pi(x)− pi(y))\n≤1 r ‖pi(x)‖2 + r ‖pi(x)− pi(y)‖2 = 1\nr ‖pi(x)‖2 + r ‖pi(x)− pi(y)‖2\n≤1 r ‖pi(x)‖2 + rL2 ‖x− y‖2 (11)\nIn the above equation, take x = ût,m,y = ût,m+1, we obtain:\n‖pi(ût,m)‖2 − ‖pi(ût,m+1)‖2\n≤1 r ‖pi(ût,m)‖2 + rL2 ‖ût,m − ût,m+1‖2\nFurthermore, we can get\n‖ût,m − ût,m+1‖\n=‖ut,a(m) − η m−1∑ i=a(m) P (t) m,i−a(m)v̂t,i\n− (ut,a(m+1) − η m∑\ni=a(m+1)\nP (t) m+1,i−a(m+1)v̂t,i)‖\n≤ ∥∥ut,a(m) − ut,a(m+1)∥∥+ η m−1∑\ni=a(m)\n‖v̂t,i‖+ η m∑\ni=a(m+1)\n‖v̂t,i‖\n≤ a(m+1)−1∑ i=a(m) ‖ut,i − ut,i+1‖+ η m−1∑ i=a(m) ‖v̂t,i‖+ η m∑ i=a(m+1) ‖v̂t,i‖ ≤η a(m+1)−1∑ i=a(m) ‖v̂t,i‖+ η m−1∑ i=a(m) ‖v̂t,i‖+ η m∑ i=a(m+1) ‖v̂t,i‖\n≤3η m∑\ni=m−τ ‖v̂t,i‖ .\nThen, we take r = 1η have\n‖pi(ût,m)‖2 − ‖pi(ût,m+1)‖2\n≤η ‖pi(ût,m)‖2 + 9η(τ + 1)L2 m∑\nj=m−τ ‖v̂t,j‖2\nFor any fixed i, we can take expectation for both sides of the above inequality and then sum i from 1 to n. Then we can get:\nEq(ût,m)− Eq(ût,m+1)\n≤ηEq(ût,m) + 9η(τ + 1)L2 m∑\nj=m−τ Eq(ût,j)\nHere we use the fact that E[‖v̂t,j‖2|ût,j ] = q(ût,j).\nWe prove our conclusion by induction. For convenience, we use qi to denote Eq(ût,i).\nWhen m = 0, we have\nq0 ≤ 1\n1− η − 9η(τ + 1)L2 q1 ≤ ρq1\nAssuming that ∀m ≤ M0, we have qm−1 ≤ ρqm, then for m =M0, we have\nqm−qm+1 ≤ ηqm + 9η(τ + 1)L2 m∑\nj=m−τ qj\n≤ηqm + 9η(τ + 1)L2qm m∑\nj=m−τ ρm−j\n=ηqm + 9η(τ + 1)L2(ρτ+1 − 1)\nρ− 1 qm\nwhich means that\nqm ≤ 1\n1− η − 9η(τ+1)L 2(ρτ+1−1)\nρ−1\nqm+1 ≤ ρqm+1"
    }, {
      "heading" : "Proof of Lemma 6",
      "text" : "Proof.\n‖ût,m − ut,m‖\n= ∥∥∥∥∥∥ut,a(m) − η m−1∑ j=a(m) P (t) m,j−a(m)v̂t,j − ut,m ∥∥∥∥∥∥ ≤ ∥∥ut,a(m) − ut,m∥∥+ η m−1∑\nj=a(m)\n‖v̂t,j‖\n≤ m−1∑ j=a(m) ‖ut,j − ut,j+1‖+ η m−1∑ j=a(m) ‖v̂t,j‖ ≤η m−1∑ j=a(m) ‖v̂t,j‖+ η m−1∑ j=a(m) ‖v̂t,j‖ ≤2η m−1∑ j=a(m) ‖v̂t,j‖ (12)\nThen we get the result\nE ‖ût,m − ut,m‖2 ≤4η2τ m−1∑ j=a(m) E ‖v̂t,j‖2\n=4η2τ m−1∑ j=a(m) Eq(ût,j)\n≤4η 2τρ(ρτ − 1) ρ− 1 Eq(ût,m)\nwhere the last inequality uses Lemma 5."
    }, {
      "heading" : "Proof of Lemma 7",
      "text" : "Proof. First, for any fixed i, we have\n‖pi(ût,m)‖2 − ‖pi(ut,m)‖2\n≤2pi(x)T (pi(ût,m)− pi(ut,m))\n≤η ‖pi(ût,m)‖2 + 1\nη ‖pi(ût,m)− pi(ut,m)‖2\n=η ‖pi(ût,m)‖2 + 1\nη ‖pi(ût,m)− pi(ut,m)‖2\n≤η ‖pi(ût,m)‖2 + 1\nη L2 ‖ût,m − ut,m‖2 (13)\nTakeing expectation on both sides, using Lemma 6 and then summing up i from 1 to n and we can get\nEq(ût,m)− Eq(ut,m)\n≤ηEq(ût,m) + 4ητL2ρ(ρτ − 1)\nρ− 1 Eq(ût,m)\nwhich means that\nEq(ût,m) ≤ 1\n1− η − 4ητL 2ρ(ρτ−1) ρ−1\nEq(ut,m) < ρEq(ut,m)"
    } ],
    "references" : [ {
      "title" : "Variance reduction for faster non-convex optimization",
      "author" : [ "Z. Allen-Zhu", "E. Hazan" ],
      "venue" : "Proceedings of the 33nd International Conference on Machine Learning.",
      "citeRegEx" : "Allen.Zhu and Hazan,? 2016",
      "shortCiteRegEx" : "Allen.Zhu and Hazan",
      "year" : 2016
    }, {
      "title" : "Improved svrg for nonstrongly-convex or sum-of-non-convex objectives",
      "author" : [ "Z. Allen-Zhu", "Y. Yuan" ],
      "venue" : "Proceedings of the 33nd International Conference on Machine Learning.",
      "citeRegEx" : "Allen.Zhu and Yuan,? 2016",
      "shortCiteRegEx" : "Allen.Zhu and Yuan",
      "year" : 2016
    }, {
      "title" : "Asynchronous stochastic convex optimization: the noise is in the noise and sgd don’t care",
      "author" : [ "S. Chaturapruek", "J.C. Duchi", "C. Ré" ],
      "venue" : "Proceedings of the Advances in Neural Information Processing Systems.",
      "citeRegEx" : "Chaturapruek et al\\.,? 2015",
      "shortCiteRegEx" : "Chaturapruek et al\\.",
      "year" : 2015
    }, {
      "title" : "Stochastic first- and zeroth-order methods for nonconvex stochastic programming",
      "author" : [ "S. Ghadimi", "G. Lan" ],
      "venue" : "SIAM Journal on Optimization 23(4):2341–2368.",
      "citeRegEx" : "Ghadimi and Lan,? 2013",
      "shortCiteRegEx" : "Ghadimi and Lan",
      "year" : 2013
    }, {
      "title" : "Asynchronous stochastic gradient descent with variance reduction for non-convex optimization",
      "author" : [ "Z. Huo", "H. Huang" ],
      "venue" : "CoRR abs/1604.03584.",
      "citeRegEx" : "Huo and Huang,? 2016",
      "shortCiteRegEx" : "Huo and Huang",
      "year" : 2016
    }, {
      "title" : "On variance reduction in stochastic gradient descent and its asynchronous variants",
      "author" : [ "S.J. Reddi", "A. Hefny", "S. Sra", "B. Poczos", "A.J. Smola" ],
      "venue" : "Proceedings of the Advances in Neural Information Processing Systems.",
      "citeRegEx" : "Reddi et al\\.,? 2015",
      "shortCiteRegEx" : "Reddi et al\\.",
      "year" : 2015
    }, {
      "title" : "Communicationefficient distributed dual coordinate ascent",
      "author" : [ "M. Jaggi", "V. Smith", "M. Takac", "J. Terhorst", "S. Krishnan", "T. Hofmann", "M.I. Jordan" ],
      "venue" : "Proceedings of the Advances in Neural Information Processing Systems.",
      "citeRegEx" : "Jaggi et al\\.,? 2014",
      "shortCiteRegEx" : "Jaggi et al\\.",
      "year" : 2014
    }, {
      "title" : "Accelerating stochastic gradient descent using predictive variance reduction",
      "author" : [ "R. Johnson", "T. Zhang" ],
      "venue" : "Proceedings of the Advances in Neural Information Processing Systems.",
      "citeRegEx" : "Johnson and Zhang,? 2013",
      "shortCiteRegEx" : "Johnson and Zhang",
      "year" : 2013
    }, {
      "title" : "Matrix factorization techniques for recommender systems",
      "author" : [ "Y. Koren", "R.M. Bell", "C. Volinsky" ],
      "venue" : "IEEE Computer 42(8):30–37.",
      "citeRegEx" : "Koren et al\\.,? 2009",
      "shortCiteRegEx" : "Koren et al\\.",
      "year" : 2009
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "A. Krizhevsky", "I. Sutskever", "G.E. Hinton" ],
      "venue" : "Proceedings of the Advances in Neural Information Processing Systems.",
      "citeRegEx" : "Krizhevsky et al\\.,? 2012",
      "shortCiteRegEx" : "Krizhevsky et al\\.",
      "year" : 2012
    }, {
      "title" : "Scaling distributed machine learning with the parameter",
      "author" : [ "M. Li", "D.G. Andersen", "J.W. Park", "A.J. Smola", "A. Ahmed", "V. Josifovski", "J. Long", "E.J. Shekita", "B. Su" ],
      "venue" : null,
      "citeRegEx" : "Li et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Li et al\\.",
      "year" : 2014
    }, {
      "title" : "Stochastic variance reduced optimization for nonconvex sparse learning",
      "author" : [ "X. Li", "T. Zhao", "R. Arora", "Han", "J. Haupt" ],
      "venue" : "Proceedings of the 33nd International Conference on Machine Learning.",
      "citeRegEx" : "Li et al\\.,? 2016",
      "shortCiteRegEx" : "Li et al\\.",
      "year" : 2016
    }, {
      "title" : "Asynchronous parallel stochastic gradient for nonconvex optimization",
      "author" : [ "X. Lian", "Y. Huang", "Y. Li", "J. Liu" ],
      "venue" : "Proceedings of the Advances in Neural Information Processing Systems.",
      "citeRegEx" : "Lian et al\\.,? 2015",
      "shortCiteRegEx" : "Lian et al\\.",
      "year" : 2015
    }, {
      "title" : "Hogwild!: A lock-free approach to parallelizing stochastic gradient descent",
      "author" : [ "B. Recht", "C. Re", "S. Wright", "F. Niu" ],
      "venue" : "Proceedings of the Advances in Neural Information Processing Systems.",
      "citeRegEx" : "Recht et al\\.,? 2011",
      "shortCiteRegEx" : "Recht et al\\.",
      "year" : 2011
    }, {
      "title" : "Stochastic variance reduction for nonconvex optimization",
      "author" : [ "S.J. Reddi", "A. Hefny", "S. Sra", "B. Poczos", "Alex." ],
      "venue" : "Proceedings of the 33nd International Conference on Machine Learning.",
      "citeRegEx" : "Reddi et al\\.,? 2016",
      "shortCiteRegEx" : "Reddi et al\\.",
      "year" : 2016
    }, {
      "title" : "A stochastic gradient method with an exponential convergence rate for finite training sets",
      "author" : [ "N.L. Roux", "M.W. Schmidt", "F. Bach" ],
      "venue" : "Proceedings of the Advances in Neural Information Processing Systems.",
      "citeRegEx" : "Roux et al\\.,? 2012",
      "shortCiteRegEx" : "Roux et al\\.",
      "year" : 2012
    }, {
      "title" : "Global convergence of stochastic gradient descent for some non-convex matrix problems",
      "author" : [ "C.D. Sa", "C. Re", "K. Olukotun" ],
      "venue" : "Proceedings of the 32nd International Conference on Machine Learning.",
      "citeRegEx" : "Sa et al\\.,? 2015",
      "shortCiteRegEx" : "Sa et al\\.",
      "year" : 2015
    }, {
      "title" : "Stochastic dual coordinate ascent methods for regularized loss",
      "author" : [ "S. Shalev-Shwartz", "T. Zhang" ],
      "venue" : "Journal of Machine Learning Research 14(1):567–599.",
      "citeRegEx" : "Shalev.Shwartz and Zhang,? 2013",
      "shortCiteRegEx" : "Shalev.Shwartz and Zhang",
      "year" : 2013
    }, {
      "title" : "A stochastic PCA and SVD algorithm with an exponential convergence rate",
      "author" : [ "O. Shamir" ],
      "venue" : "Proceedings of the 32nd International Conference on Machine Learning.",
      "citeRegEx" : "Shamir,? 2015",
      "shortCiteRegEx" : "Shamir",
      "year" : 2015
    }, {
      "title" : "Convergence of stochastic gradient descent for pca",
      "author" : [ "O. Shamir" ],
      "venue" : "Proceedings of the 33nd International Conference on Machine Learning.",
      "citeRegEx" : "Shamir,? 2016a",
      "shortCiteRegEx" : "Shamir",
      "year" : 2016
    }, {
      "title" : "Fast stochastic algorithms for svd and pca: Convergence properties and convexity",
      "author" : [ "O. Shamir" ],
      "venue" : "Proceedings of the 33nd International Conference on Machine Learning.",
      "citeRegEx" : "Shamir,? 2016b",
      "shortCiteRegEx" : "Shamir",
      "year" : 2016
    }, {
      "title" : "Petuum: A new platform for distributed machine learning on big data",
      "author" : [ "E.P. Xing", "Q. Ho", "W. Dai", "J.K. Kim", "J. Wei", "S. Lee", "X. Zheng", "P. Xie", "A. Kumar", "Y. Yu" ],
      "venue" : "Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Min-",
      "citeRegEx" : "Xing et al\\.,? 2015",
      "shortCiteRegEx" : "Xing et al\\.",
      "year" : 2015
    }, {
      "title" : "Asynchronous distributed semi-stochastic gradient optimization",
      "author" : [ "R. Zhang", "S. Zheng", "J.T. Kwok" ],
      "venue" : "Proceedings of the AAAI Conference on Artificial Intelligence.",
      "citeRegEx" : "Zhang et al\\.,? 2016",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2016
    }, {
      "title" : "Fast asynchronous parallel stochastic gradient descent: A lock-free approach with convergence guarantee",
      "author" : [ "Zhao", "S.-Y.", "Li", "W.-J." ],
      "venue" : "Proceedings of the AAAI Conference on Artificial Intelligence.",
      "citeRegEx" : "Zhao et al\\.,? 2016",
      "shortCiteRegEx" : "Zhao et al\\.",
      "year" : 2016
    } ],
    "referenceMentions" : [ {
      "referenceID" : 18,
      "context" : "Moreover, many other machine learning models, including neural networks (Krizhevsky, Sutskever, and Hinton 2012), matrix factorization (Koren, Bell, and Volinsky 2009), and principal component analysis (PCA) (Shamir 2015) and so on, can also be formulated as that in (1).",
      "startOffset" : 208,
      "endOffset" : 221
    }, {
      "referenceID" : 17,
      "context" : "Many works (Roux, Schmidt, and Bach 2012; Shalev-Shwartz and Zhang 2013; Johnson and Zhang 2013) have found that SGD-based methods can achieve promising performance in large-scale learning problems.",
      "startOffset" : 11,
      "endOffset" : 96
    }, {
      "referenceID" : 7,
      "context" : "Many works (Roux, Schmidt, and Bach 2012; Shalev-Shwartz and Zhang 2013; Johnson and Zhang 2013) have found that SGD-based methods can achieve promising performance in large-scale learning problems.",
      "startOffset" : 11,
      "endOffset" : 96
    }, {
      "referenceID" : 17,
      "context" : "When the problem in (1) is convex, the SGD methods, including SSGD (Roux, Schmidt, and Bach 2012; Shalev-Shwartz and Zhang 2013; Johnson and Zhang 2013), PSGD (Recht et al.",
      "startOffset" : 67,
      "endOffset" : 152
    }, {
      "referenceID" : 7,
      "context" : "When the problem in (1) is convex, the SGD methods, including SSGD (Roux, Schmidt, and Bach 2012; Shalev-Shwartz and Zhang 2013; Johnson and Zhang 2013), PSGD (Recht et al.",
      "startOffset" : 67,
      "endOffset" : 152
    }, {
      "referenceID" : 13,
      "context" : "When the problem in (1) is convex, the SGD methods, including SSGD (Roux, Schmidt, and Bach 2012; Shalev-Shwartz and Zhang 2013; Johnson and Zhang 2013), PSGD (Recht et al. 2011) and DSGD (Jaggi et al.",
      "startOffset" : 159,
      "endOffset" : 178
    }, {
      "referenceID" : 6,
      "context" : "2011) and DSGD (Jaggi et al. 2014; Li et al. 2014; Xing et al. 2015; Zhang, Zheng, and Kwok 2016), have achieved very promising empirical performance.",
      "startOffset" : 15,
      "endOffset" : 97
    }, {
      "referenceID" : 10,
      "context" : "2011) and DSGD (Jaggi et al. 2014; Li et al. 2014; Xing et al. 2015; Zhang, Zheng, and Kwok 2016), have achieved very promising empirical performance.",
      "startOffset" : 15,
      "endOffset" : 97
    }, {
      "referenceID" : 21,
      "context" : "2011) and DSGD (Jaggi et al. 2014; Li et al. 2014; Xing et al. 2015; Zhang, Zheng, and Kwok 2016), have achieved very promising empirical performance.",
      "startOffset" : 15,
      "endOffset" : 97
    }, {
      "referenceID" : 10,
      "context" : "Because many researchers (Li et al. 2014; Xing et al. 2015) find that the SGD methods can also achieve good empirical results for nonconvex problems, theoretical proof about the convergence of SGD methods for non-convex problems has recently attracted much attention.",
      "startOffset" : 25,
      "endOffset" : 59
    }, {
      "referenceID" : 21,
      "context" : "Because many researchers (Li et al. 2014; Xing et al. 2015) find that the SGD methods can also achieve good empirical results for nonconvex problems, theoretical proof about the convergence of SGD methods for non-convex problems has recently attracted much attention.",
      "startOffset" : 25,
      "endOffset" : 59
    }, {
      "referenceID" : 3,
      "context" : "For example, the works in (Ghadimi and Lan 2013; Reddi et al. 2016; Li et al. 2016; Allen-Zhu and Hazan 2016; Allen-Zhu and Yuan 2016) have proved the convergence of the sequential SGD and its variants for non-convex problems.",
      "startOffset" : 26,
      "endOffset" : 134
    }, {
      "referenceID" : 14,
      "context" : "For example, the works in (Ghadimi and Lan 2013; Reddi et al. 2016; Li et al. 2016; Allen-Zhu and Hazan 2016; Allen-Zhu and Yuan 2016) have proved the convergence of the sequential SGD and its variants for non-convex problems.",
      "startOffset" : 26,
      "endOffset" : 134
    }, {
      "referenceID" : 11,
      "context" : "For example, the works in (Ghadimi and Lan 2013; Reddi et al. 2016; Li et al. 2016; Allen-Zhu and Hazan 2016; Allen-Zhu and Yuan 2016) have proved the convergence of the sequential SGD and its variants for non-convex problems.",
      "startOffset" : 26,
      "endOffset" : 134
    }, {
      "referenceID" : 0,
      "context" : "For example, the works in (Ghadimi and Lan 2013; Reddi et al. 2016; Li et al. 2016; Allen-Zhu and Hazan 2016; Allen-Zhu and Yuan 2016) have proved the convergence of the sequential SGD and its variants for non-convex problems.",
      "startOffset" : 26,
      "endOffset" : 134
    }, {
      "referenceID" : 1,
      "context" : "For example, the works in (Ghadimi and Lan 2013; Reddi et al. 2016; Li et al. 2016; Allen-Zhu and Hazan 2016; Allen-Zhu and Yuan 2016) have proved the convergence of the sequential SGD and its variants for non-convex problems.",
      "startOffset" : 26,
      "endOffset" : 134
    }, {
      "referenceID" : 18,
      "context" : "There are also some other theoretical results for some particular non-convex problems, like PCA (Shamir 2015; 2016a; 2016b) and matrix factorization (Sa, Re, and Olukotun 2015).",
      "startOffset" : 96,
      "endOffset" : 123
    }, {
      "referenceID" : 12,
      "context" : "There have appeared only two works (Lian et al. 2015; Huo and Huang 2016) which propose PSGD methods for non-convex problems with theoretical proof of convergence.",
      "startOffset" : 35,
      "endOffset" : 73
    }, {
      "referenceID" : 4,
      "context" : "There have appeared only two works (Lian et al. 2015; Huo and Huang 2016) which propose PSGD methods for non-convex problems with theoretical proof of convergence.",
      "startOffset" : 35,
      "endOffset" : 73
    }, {
      "referenceID" : 12,
      "context" : "However, the PSGD methods in (Lian et al. 2015) need write-lock or atomic operation for the memory to prove the convergence 2.",
      "startOffset" : 29,
      "endOffset" : 47
    }, {
      "referenceID" : 4,
      "context" : "Similarly, the work in (Huo and Huang 2016) also does not prove the convergence for the lockfree case in our paper.",
      "startOffset" : 23,
      "endOffset" : 43
    }, {
      "referenceID" : 13,
      "context" : "Recent works (Recht et al. 2011; Chaturapruek, Duchi, and Ré 2015; J. Reddi et al. 2015; Zhao and Li 2016) find that lock-free strategy based parallel SGD (LF-PSGD) methods can empirically outperform lockbased PSGD methods for multi-core systems.",
      "startOffset" : 13,
      "endOffset" : 106
    }, {
      "referenceID" : 13,
      "context" : "In this paper, we provide the theoretical proof about the convergence of two representative LF-PSGD methods, Hogwild! (Recht et al. 2011; Chaturapruek, Duchi, and Ré 2015) and AsySVRG (Zhao and Li 2016), for non-convex problems.",
      "startOffset" : 118,
      "endOffset" : 171
    }, {
      "referenceID" : 12,
      "context" : "Although the implementation of AsySG-incon in (Lian et al. 2015) is lock-free, the theoretical analysis about the convergence of AsySG-incon is based on an assumption that no over-writing happens, i.",
      "startOffset" : 46,
      "endOffset" : 64
    }, {
      "referenceID" : 13,
      "context" : "Hogwild! for Non-Convex Problems The Hogwild! method (Recht et al. 2011) is listed in Algorithm 1.",
      "startOffset" : 53,
      "endOffset" : 72
    }, {
      "referenceID" : 13,
      "context" : "Please note that Hogwild! in (Recht et al. 2011) has several variants with locks or lock-free.",
      "startOffset" : 29,
      "endOffset" : 48
    }, {
      "referenceID" : 7,
      "context" : "AsySVRG provides a lock-free parallel strategy for the original sequential SVRG (Johnson and Zhang 2013).",
      "startOffset" : 80,
      "endOffset" : 104
    }, {
      "referenceID" : 14,
      "context" : "In the t outer-loop, similar to (Reddi et al. 2016), we define Rt,m as follows",
      "startOffset" : 32,
      "endOffset" : 51
    }, {
      "referenceID" : 14,
      "context" : "As recommended in (Reddi et al. 2016), we can take η = μ/n, β = v/n with η < β (assuming n is large).",
      "startOffset" : 18,
      "endOffset" : 37
    } ],
    "year" : 2016,
    "abstractText" : "Stochastic gradient descent (SGD) and its variants have attracted much attention in machine learning due to their efficiency and effectiveness for optimization. To handle largescale problems, researchers have recently proposed several lock-free strategy based parallel SGD (LF-PSGD) methods for multi-core systems. However, existing works have only proved the convergence of these LF-PSGD methods for convex problems. To the best of our knowledge, no work has proved the convergence of the LF-PSGD methods for nonconvex problems. In this paper, we provide the theoretical proof about the convergence of two representative LF-PSGD methods, Hogwild! and AsySVRG, for non-convex problems. Empirical results also show that both Hogwild! and AsySVRG are convergent on non-convex problems, which successfully verifies our theoretical results. Introduction Many machine learning models can be formulated as the following optimization problem:",
    "creator" : "TeX"
  }
}