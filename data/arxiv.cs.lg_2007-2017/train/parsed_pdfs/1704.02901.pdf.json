{
  "name" : "1704.02901.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Dynamic Edge-Conditioned Filters in Convolutional Neural Networks on Graphs",
    "authors" : [ "Martin Simonovsky", "Nikos Komodakis" ],
    "emails" : [ "martin.simonovsky@enpc.fr", "nikos.komodakis@enpc.fr" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Convolutional Neural Networks (CNNs) have gained massive popularity in tasks where the underlying data representation has a grid structure, such as in speech processing and natural language understanding (1D, temporal convolutions), in image classification and segmentation (2D, spatial convolutions), or in video parsing (3D, volumetric convolutions) [22].\nOn the other hand, in many other tasks the data naturally lie on irregular or generally non-Euclidean domains, which can be structured as graphs in many cases. These include problems in 3D modeling, computational chemistry and biology, geospatial analysis, social networks, or natural language semantics and knowledge bases, to name a few. Assuming that the locality, stationarity, and composionality principles of representation hold to at least some level in the data, it is meaningful to consider a hierarchical CNN-like architecture for processing it.\nHowever, a generalization of CNNs from grids to general graphs is not straightforward and has recently become a topic of increased interest. We identify that the current formulations of graph convolution do not exploit edge labels, which results in an overly homogeneous view of local graph neighborhoods, with an effect similar to enforc-\ning rotational invariance of filters in regular convolutions on images. Hence, in this work we propose a convolution operation which can make use of this information channel and show that it leads to an improved graph classification performance.\nThis novel formulation also opens up a broader range of applications; we concentrate here on point clouds specifically. Point clouds have been mostly ignored by deep learning so far, their voxelization being the only trend to the best of our knowledge [26, 19]. To offer a competitive alternative with a different set of advantages and disadvantages, we construct graphs in Euclidean space from point clouds in this work and demonstrate state of the art performance on Sydney dataset of LiDAR scans [9].\nOur contributions are as follows:\n• We formulate a convolution-like operation on graph signals performed in the spatial domain where filter weights are conditioned on edge labels (discrete or continuous) and dynamically generated for each specific input sample. Our networks work on graphs with arbitrary varying structure throughout a dataset.\n• We are the first to apply graph convolutions to point cloud classification. Our method outperforms volumetric approaches and attains the new state of the art performance on Sydney dataset, with the benefit of preserving sparsity and presumably fine details.\n• We reach a competitive level of performance on graph classification benchmark NCI1 [39], outperforming other approaches based on deep learning there."
    }, {
      "heading" : "2. Related Work",
      "text" : "The first formulation of a convolutional network analogy for irregular domains modeled with graphs has been introduced by Bruna et al. [6], who looked into both the spatial and the spectral domain of representation for performing localized filtering.\nar X\niv :1\n70 4.\n02 90\n1v 1\n[ cs\n.C V\n] 1\n0 A\npr 2\n01 7\nSpectral Methods. A mathematically sound definition of convolution operator makes use of the spectral analysis theory, where it corresponds to multiplication of the signal on vertices transformed into the spectral domain by graph Fourier transform. The spatial locality of filters is then given by smoothness of the spectral filters, in case of [6] modeled as B-splines. The transform involves very expensive multiplications with the eigenvector matrix. However, by a parameterization of filters as Chebyshev polynomials of eigenvalues and their approximate evaluation, computationally efficient and localized filtering has been recently achieved by Defferrard et al. [11]. Nevertheless, the filters are still learned in the context of the spectrum of graph Laplacian, which therefore has to be the same for all graphs in a dataset. This means that the graph structure is fixed and only the signal defined on the vertices may differ. This precludes applications on problems where the graph structure varies in the dataset, such as meshes, point clouds, or diverse biochemical datasets.\nTo cover these important cases, we formulate our filtering approach in the spatial domain, where the limited complexity of evaluation and the localization property is provided by construction. The main challenge here is dealing with weight sharing among local neighborhoods [6], as the number of vertices adjacent to a particular vertex varies and their ordering is often not well definable.\nSpatial Methods. Bruna et al. [6] assumed fixed graph structure and did not share any weights among neighborhoods. Several works have independently dealt with this\nproblem. Duvenaud et al. [14] sum the signal over neighboring vertices followed by a weight matrix multiplication, effectively sharing the same weights among all edges. Atwood and Towsley [2] share weights based on the number of hops between two vertices. Kipf and Welling [21] further approximate the spectral method of [11] and weaken the dependency on the Laplacian, but ultimately arrive at center-surround weighting of neighborhoods. None of these methods captures finer structure of the neighborhood and thus does not generalize the standard convolution on grids. In contrast, our method can make use of possible edge labels and is shown to generalize regular convolution (Section 3.2).\nThe approach of Niepert et al. [28] introduces a heuristic for linearizing selected graph neighborhoods so that a conventional 1D CNN can be used. We share their goal of capturing structure in neighborhoods but approach it in a different way. Finally, Graph neural networks [34, 24] propagate features across a graph until (near) convergence and exploit edge labels as one of the sources of information as we do. However, their system is quite different from the current multilayer feed-forward architectures, making the reuse of today’s common building blocks not straightforward.\nCNNs on Point Clouds and Meshes. There has been little work on deep learning on point clouds or meshes. Masci et al. [25] define convolution over patch descriptors around every vertex of a 3D mesh using geodesic distances, formulated in a deep learning architecture. The only way of processing point clouds using deep learning has been to first\nvoxelize them before feeding them to a 3D CNN, be it for classification [26] or segmentation [19] purposes. Instead, we regard point cloud as graphs in Euclidean space in this work."
    }, {
      "heading" : "3. Method",
      "text" : "We propose a method for performing convolutions over local graph neighborhoods exploiting edge labels (Section 3.1) and show it to generalize regular convolutions (Section 3.2). Afterwards, we present deep networks with our convolution operator (Section 3.3) in the case of point clouds (Section 3.4) and general graphs (Section 3.5)."
    }, {
      "heading" : "3.1. Edge-Conditioned Convolution",
      "text" : "Let us consider a directed or undirected graph G = (V,E), where V is a finite set of vertices with |V | = n and E ⊆ V × V is a set of edges with |E| = m. Let l ∈ {0, .., lmax} be the layer index in a feed-forward neural network. We assume the graph is both vertex- and edgelabeled, i.e. there exists function X l : V 7→ Rdl assigning labels (also called signals or features) to each vertex and L : E 7→ Rs assigning labels (also called attributes) to each edge. These functions can be regarded as matrices X l ∈ Rn×dl and L ∈ Rm×s, X0 then being the input signal. A neighborhoodN(i) = {j; (j, i) ∈ E}∪{i} of vertex i is defined to contain all adjacent vertices (predecessors in directed graphs) including i itself (self-loop).\nOur approach computes the filtered signal X l(i) ∈ Rdl at vertex i as a weighted sum of signals X l−1(j) ∈ Rdl−1 in its neighborhood, j ∈ N(i). While such a commutative aggregation solves the problem of undefined vertex ordering and varying neighborhood sizes, it also smooths out any structural information. To retain it, we propose to condition each filtering weight on the respective edge label. To this end, we borrow the idea from Dynamic filter networks [5] and define a filter-generating network F l : Rs 7→ Rdl×dl−1 which given edge label L(j, i) outputs edge-specific weight matrix Θlji ∈ Rdl×dl−1 , see Figure 1.\nThe convolution operation, coined Edge-Conditioned Convolution (ECC), is formalized as follows:\nX l(i) = 1 |N(i)| ∑\nj∈N(i)\nF l(L(j, i);wl)X l−1(j) + bl\n= 1 |N(i)| ∑\nj∈N(i)\nΘljiX l−1(j) + bl\n(1)\nwhere bl ∈ Rdl is a learnable bias and F l is parameterized by learnable network weights wl. For clarity, wl and bl are model parameters updated only during training and Θlji are dynamically generated parameters for an edge label in a particular input graph. The filter-generating network F l can\nbe implemented with any differentiable architecture; we use multi-layer perceptrons in our applications.\nComplexity. Computing X l for all vertices requires at most1 m evaluations of F l and m + n or 2m + n matrixvector multiplications for directed, resp. undirected graphs. Both operations can be carried out efficiently on the GPU in batch-mode."
    }, {
      "heading" : "3.2. Relationship to Existing Formulations",
      "text" : "Our formulation of convolution on graph neighborhoods retains the key properties of the standard convolution on regular grids that are useful in the context of CNNs: weight sharing and locality.\nThe weights in ECC are tied by edge label, which is in contrast to tying them by hop distance from a vertex [2], according to a neighborhood linearization heuristic [28], by being the central vertex or not [21], indiscriminately [14], or not at all [6].\nIn fact, our definition reduces to that of Duvenaud et al. [14] (up to scaling) in the case of uninformative edge labels: ∑ j∈N(i) Θ l jiX l−1(j) = Θl ∑ j∈N(i)X\nl−1(j) if Θlji = Θ\nl ∀(j, i) ∈ E. More importantly, the standard discrete convolution on grids is a special case of ECC, which we demonstrate in 1D for clarity. Consider an ordered set of vertices V forming a path graph (chain). To obtain convolution with a centered kernel of size s, we form E so that each vertex is connected to its s spatially nearest neighbors including self by a directed edge labeled with one-hot encoding of the neighbor’s discrete offset δ, see Figure 2. Taking F l as a singlelayer perceptron without bias, we have F l(L(j, i);wl) = wl(δ), where wl(δ) denotes the respective reshaped column of the parameter matrix wl ∈ R(dl×dl−1)×s. With a slight abuse of notation, we arrive at the equivalence to the standard convolution: X l(i) = ∑ j∈N(i) Θ l jiX\nl−1(j) =∑ δ w\nl(δ)X l−1(i− δ), ignoring the normalization factor of 1/|N(i)| playing a role only at grid boundaries.\nThis shows that ECC can retain the same number of parameteres and computational complexity of the regular convolution in the case of grids. Note that such equivalence is not possible with none of [2, 21, 14] due to their way of weight tying."
    }, {
      "heading" : "3.3. Deep Networks with ECC",
      "text" : "While ECC is in principle applicable to both vertex classification and graph classification tasks, in this paper we restrict ourselves only to the latter one, i.e. predicting a class for the whole input graph. Hence, we follow the common architectural pattern for feed-forward networks of in-\n1If edge labels are represented by s discrete values in a particular graph and s < m, Xl can be evaluated only s-times.\nterlaced convolutions and poolings topped by global pooling and fully-connected layers, see Figure 3 for an illustration. This way, information from the local neighborhoods gets combined over successive layers to gain context (enlarge receptive field). While edge labels are fixed for a particular graph, their (learned) interpretation by the means of filter generating networks may change from layer to layer (weights of F l are not shared among layers). Therefore, the restriction of ECC to 1-hop neighborhoods N(i) is not a constraint, akin to using small 3×3 filters in normal CNNs in exchange for deeper networks, which is known to be beneficial [17].\nWe use batch normalization [20] after each convolution, which was necessary for the learning to converge. Interestingly, we had no success with other feature normalization techniques such as data-dependent initialization [27] or layer normalization [3].\nPooling. While (non-strided) convolutional layers and all point-wise layers do not change the underlying graph and only evolve the signal on vertices, pooling layers are defined to output aggregated signal on the vertices of a new, coarsened graph. Therefore, a pyramid of hmax progressively coarser graphs has to be constructed for each input graph. Let us extend here our notation with an additional superscript h ∈ {0, .., hmax} to distinguish among different graphs G(h) = (V (h), E(h)) in the pyramid when necessary. Each G(h) has also its associated labels L(h) and signal X(h),l. A coarsening typically consists of three steps: subsampling or merging vertices, creating the new edge structure E(h) and labeling L(h) (so-called reduction), and mapping the vertices in the original graph to those in the coarsened one with M (h) : V (h−1) 7→ V (h). We use a different algorithm depending on whether we work with general graphs or graphs in Euclidean space, therefore we postpone discussing the details to the applications. Finally, the pooling layer with index lh aggregatesX(h−1),lh−1 into a lower dimensional X(h),lh based on M (h). See Figure 3 for an example of using the introduced notation.\nDuring coarsening, a small graph may be reduced to several disconnected vertices in its lower resolutions without\nproblems as self-edges are always present. Since the architecture is designed to process graphs with variable n,m, we deal with varying vertex count n(hmax) in the lowest graph resolution by global average/max pooling."
    }, {
      "heading" : "3.4. Application in Point Clouds",
      "text" : "Point clouds are an important 3D data modality arising from many acquisition techniques, such as laser scanning (LiDAR) or multi-view reconstruction. Due to their natural irregularity and sparsity, so far the only way of processing point clouds using deep learning has been to first voxelize them before feeding them to a 3D CNN, be it for classification [26] or segmentation [19] purposes. Such a dense representation is very hardware friendly and simple to handle with the current deep learning frameworks.\nOn the other hand, there are several disadvantages too. First, voxel representation tends to be much more expensive in terms of memory than usually sparse point clouds (we are not aware of any GPU implementation of convolutions on sparse tensors). Second, the necessity to fit them into a fixed size 3D grid brings about discretization artifacts and the loss of metric scale and possibly of details. With this work, we would like to offer a competitive alternative to the mainstream by performing deep learning on point clouds directly. As far as we know, we are the first to demonstrate such a result.\nGraph Construction. Given a point cloud P with its point features XP (such as laser return intensity or color) we build a directed graph G = (V,E) and set up its labels X0 and L as follows. First, we create vertex i ∈ V for every point p ∈ P and assign the respective signal to it by X0(i) = XP (p) (or 0 if there are no featuresXP (p)). Then we connect each vertex i to all vertices j in its spatial neighborhood by a directed edge (j, i). In our experiments with neighborhoods, fixed metric radius ρ worked better than a fixed number of neighbors. The offset δ = pj − pi between the points corresponding to vertices j, i is represented in Cartesian and spherical coordinates as 6D edge label vector L(j, i) = (δx, δy, δz, ||δ||, arccos δz/||δ||, arctan δy/δx).\nGraph Coarsening. For a single input point cloud P , a pyramid of downsampled point clouds P (h) is obtained by the VoxelGrid algorithm [31], which overlays a grid of resolution r(h) over the point cloud and replaces all points within a voxel with their centroid (and thus maintains subvoxel accuracy). Each of the resulting point clouds P (h) is then independently converted into a graphG(h) and labeling L(h) with neighborhood radius ρ(h) as described above. The pooling map M (h) is defined so that each point in P (h−1) is assigned to its spatially nearest point in the subsampled point cloud P (h).\nData Augmentation. In order to reduce overfitting on small datasets, we perform online data augmentation. In particular, we randomly rotate point clouds about their upaxis, jitter their scale, perform mirroring, or delete random points."
    }, {
      "heading" : "3.5. Application in General Graphs",
      "text" : "Many problems can be modeled directly as graphs. In such cases the graph dataset is already given and only the appropriate graph coarsening scheme needs to be chosen. This is by no means trivial and there exists a large body of literature on this problem [32]. Without any concept of spatial localization of vertices, we resort to established graph coarsening algorithms and utilize the multiresolution framework of Shuman et al. [36, 29], which works by repeated downsampling and graph reduction of the input graph. The downsampling step is based on splitting the graph into two components by the sign of the largest eigenvector of the Laplacian. This is followed by Kron reduction [13], which also defines the new edge labeling, enhanced with spectral sparsification of edges [37]. Note that the algorithm regards graphs as unweighted for the purpose of coarsening.\nThis method is attractive for us because of two reasons. Each downsampling step removes approximately half of the vertices, guaranteeing a certain level of pooling strength, and the sparsification step is randomized. The latter property is exploited as a useful data augmentation technique since several different graph pyramids can be generated from a single input graph. This is in spirit similar to the effect of fractional max-pooling [16]. We do not perform\nany other data augmentation."
    }, {
      "heading" : "4. Experiments",
      "text" : "The proposed method is evaluated in point cloud classification (real-world data in Section 4.1 and synthetic in 4.2) and on a standard graph classification benchmark (Section 4.3). In addition, we validate our method and study its properties on MNIST (Section 4.4)."
    }, {
      "heading" : "4.1. Sydney Urban Objects",
      "text" : "This point cloud dataset [9] consists of 588 objects in 14 categories (vehicles, pedestrians, signs, and trees) manually extracted from 360◦ LiDAR scans, see Figure 4. It demonstrates non-ideal sensing conditions with occlusions (holes) and a large variability in viewpoint (single viewpoint). This makes object classification a challenging task.\nFollowing the protocol employed by the dataset authors, we report the mean F1 score weighted by class frequency, as the dataset is imbalanced. This score is further aggregated over four standard training/testing splits.\nNetwork Configuration. Our ECC-network has 7 parametric layers and 4 levels of graph resolution. Its configuration can be described as C(16)-C(32)-MP(0.25,0.5)C(32)-C(32)-MP(0.75,1.5)-C(64)-MP(1.5,1.5)-GAPFC(64)-D(0.2)-FC(14), where C(c) denotes ECC with c output channels followed by affine batch normalization and ReLU activation, MP(r,ρ) stands for max-pooling down to grid resolution of r meters and neighborhood radius of\nρ meters, GAP is global average pooling, FC(c) is fullyconnected layer with c output channels, and D(p) is dropout with probability p. The filter-generating networks F l have configuration FC(16)-FC(32)-FC(dldl−1) with orthogonal weight initialization [33] and ReLUs in between. Input graphs are created with r0 = 0.1 and ρ0 = 0.2 meters to break overly dense point clusters. Networks are trained with SGD and cross-entropy loss for 250 epochs with batch size 32 and learning rate 0.1 step-wise decreasing after 200 and 245 epochs. Vertex signal X0 is scalar laser return intensity (0-255), representing depth.\nResults. Table 1 compares our result (ECC, 78.4) against two methods based on volumetric CNNs evaluated on voxelized occupancy grids of size 32x32x32 (VoxNet [26] 73.0 and ORION [1] 77.8), which we outperform by a small margin and set the new state of the art result on this dataset.\nIn the same table, we also study the dependence on convolution radii ρ: increasing them 1.5× or 2× in all convolutional layers leads to a drop in performance, which would correspond to a preference of using smaller filters in regular CNNs. The average neighborhood size is roughly 10 vertices for our best-performing network. We hypothesize that larger radii smooth out the information in the central vertex. To investigate this, we increased the importance of the self-loop by adding an identity skip-connection (see Appendix E) and retrained the networks. We achieved 77.0, 79.5 (the new state of the art), and 77.4 mean F1 for ECC, ECC 1.5ρ, and ECC 2ρ, respectively. Stronger identity connection allowed for successful integration of a larger context, up to some limit, which indeed suggests that information should be aggregated neither too much nor too little."
    }, {
      "heading" : "4.2. ModelNet",
      "text" : "ModelNet [40] is a large scale collection of object meshes. We evaluate classification performance on its subsets ModelNet10 (3991/908 train/test examples in 10 categories) and ModelNet40 (9843/2468 train/test examples in 40 categories). Synthetic point clouds are created from\nmeshes by uniformly sampling 1000 points on mesh faces according to face area (a simulation of acquisition from multiple viewpoints) and rescaled into a unit sphere.\nNetwork Configuration. Our ECC-network for ModelNet10 has 7 parametric layers and 3 levels of graph resolution with configuration C(16)-C(32)-MP(2.5/32,7.5/32)C(32)-C(32)-MP(7.5/32,22.5/32)-C(64)-GMP-FC(64)D(0.2)-FC(10), GAP being global max pooling. Other definitions and filter-generating networks F l are as in Section 4.1. Input graphs are created with r0 = 1/32 and ρ0 = 2/32 units, mimicking the typical grid resolution of 323 in voxel-based methods. The network is trained with SGD and cross-entropy loss for 175 epochs with batch size 64 and learning rate 0.1 step-wise decreasing after every 50 epochs. There is no vertex signal, i.e. X0 are zero. For ModelNet40, the network is wider (C(24), C(48), C(48), C(48), C(96), FC(64), FC(40)) and is trained for 100 epochs with learning rate decreasing after each 30 epochs.\nResults. Table 2 compares our result to several recent works, based either on volumetric [40, 26, 1, 30] or rendered image representation [38]. Test sets were expanded to include 12 orientations (ECC). We also evaluate voting over orientations (ECC 12 votes), which slightly improves the results likely due to the rotational variance of VoxelGrid algorithm. While not fully reaching the state of the art, we believe our method remains very competitive (90.8%, resp. 87.4% mean instance accuracy). For a fairer comparison, a leading volumetric method should be retrained on voxelized synthetic point clouds."
    }, {
      "heading" : "4.3. Graph Classification",
      "text" : "We evaluate on a graph classification benchmark frequently used in the community, consisting of five datasets: NCI1, NCI109, MUTAG, ENZYMES, and D&D. Their properties can be found in Table 3, indicating the variability in dataset sizes, in graph sizes, and in the availability of labels. Following [35], we perform 10-fold cross-validation\nwith 9 folds for training and 1 for testing and report the average prediction accuracy.\nNCI1 and NCI109 [39] consist of graph representations of chemical compounds screened for activity against nonsmall cell lung cancer and ovarian cancer cell lines, respectively. MUTAG [10] is a dataset of nitro compounds labeled according to whether or not they have a mutagenic effect on a bacterium. ENZYMES [4] contains representations of tertiary structure of 6 classes of enzymes. D&D [12] is a database of protein structures (vertices are amino acids, edges indicate spatial closeness) classified as enzymes and non-enzymes.\nNetwork Configuration. Our ECC-network for NCI1 has 8 parametric layers and 3 levels of graph resolution. Its configuration can be described as C(48)-C(48)-C(48)-MPC(48)-C(64)-MP-C(64)-GAP-FC(64)-D(0.1)-FC(2), where C(c) denotes ECC with c output channels followed by affine batch normalization, ReLU activation and dropout (probability 0.05), MP stands for max-pooling onto a coarser graph, GAP is global average pooling, FC(c) is fullyconnected layer with c output channels, and D(p) is dropout with probability p. The filter-generating networks F l have configuration FC(64)-FC(dldl−1) with orthogonal weight initialization [33] and ReLU in between. Labels are encoded as one-hot vectors (d0 = 37 and s = 4 due to an extra label for self-connections). Networks are trained with SGD and cross-entropy loss for 50 epochs with batch size 64 and learning rate 0.1 step-wise decreasing after 25, 35, and 45 epochs. The dataset is expanded five times by randomized sparsification (Section 3.5). Small deviations from this description for the other four datasets are mentioned in the supplementary.\nBaselines. We compare our method (ECC) to the state of the art Weisfeiler-Lehman graph kernel et al. [35] and to four approaches using deep learning as at least one of their components [2, 28, 41, 8]. Randomized sparsification used during training time can also be exploited at test time, when the network prediction scores (ECC-5-scores)\nor votes (ECC-5-votes) are averaged over 5 runs. To judge the influence of edge labels, we run our method with uniform labels and F l being a single layer FC(dldl−1) without bias2 (ECC no edge labels).\nResults. Table 4 conveys that while there is no clear winning algorithm, our method performs at the level of state of the art for edge-labeled datasets (NCI1, NCI109, MUTAG). The results demonstrate the importance of exploiting edge labels for convolution-based methods, as the performance of DCNN [2] and ECC without edge labels is distinctly worse, justifying the motivation behind this paper. Averaging over random sparsifications at test time improves accuracy by a small amount. Our results on datasets without edge labels (ENZYMES, D&D) are somewhat below the state of the art but still at a reasonable level, though improvement in this case was not the aim of this work. This indicates that further research is needed into the adaptation of CNNs to general graphs. A more detailed discussion for each dataset is available in the supplementary."
    }, {
      "heading" : "4.4. MNIST",
      "text" : "To further validate our method, we applied it to the MNIST classification problem [23], a dataset of 70k greyscale images of handwritten digits represented on a 2D grid of size 28×28. We regard each image I as point cloud\n2Also possible for unlabeled ENZYMES and D&D, since our method uses labels from Kron reduction for all coarsened graphs by default.\nP with points pi = (x, y, 0) and signal X0(i) = I(x, y) representing each pixel, x, y ∈ {0, .., 27}. Edge labeling and graph coarsening is performed as explained in Section 3.4. We are mainly interested in two questions: Is ECC able to reach the standard performance on this classic baseline? What kind of representation does it learn?\nNetwork Configuration. Our ECC-network has 5 parametric layers with configuration C(16)-MP(2,3.4)-C(32)MP(4,6.8)-C(64)-MP(8,30)-C(128)-D(0.5)-FC(10); the notation and filter-generating network being as in Section 4.1. The last convolution has a stride of 30 and thus maps all 4× 4 points to only a single point. Input graphs are created with r0 = 1 and ρ0 = 2.9. This model exactly corresponds to a regular CNN with three convolutions with filters of size 5×5, 3×3, and 3×3 interlaced with max-poolings of size 2×2, finished with two fully connected layers. Networks are trained with SGD and cross-entropy loss for 20 epochs with batch size 64 and learning rate 0.01 step-wise decreasing after 10 and 15 epochs.\nResults. Table 5 proves that our ECC network can achieve the level of quality comparable to the good standard in the community (99.14). This is exactly the same accuracy as reported by Defferrard et al. [11] and better than what is offered by other spectral-based approaches (98.2 [6], 94.96 [15]). Note that we are not aiming at becoming the state of the art on MNIST by this work.\nNext, we investigate the effect of regular grid and irregular mesh. To this end, we discard all black points (X0(i) = 0) from the point clouds, corresponding to 80.9% of data, and retrain the network (ECC sparse input). Exactly the same test performance is obtained (99.14), indicating that our method is very stable with respect to graph structure changing from sample to sample.\nFurthermore, we check the quality of the learned filter generating networks F l. We compare with ECC configured to mimic regular convolution using single-layer filter networks and one-hot encoding of offsets (ECC one-hot), as described in Section 3.2. This configuration reaches 99.37 accuracy, or 0.23 more than ECC, implying that F l are not perfect but still perform very well in learning the proper partitioning of edge labels.\nLast, we explore the generated filters visually for the case of the sparse input ECC. As filters Θ1 ∈ R16×1 are a continuous function of an edge label, we can visualize the change of values in each dimension in 16 images by sampling labels over grids of two resolutions. The coarser one in Figure 5 has integer steps corresponding to the offsets δx, δy ∈ {−2, .., 2}. It shows filters exhibiting the structured patterns typically found in the first layer of CNNs. The finer resolution in Figure 5 (sub-pixel steps of 0.1) reveals that the filters are in fact smooth and do not contain\nany discontinuities apart from the angular artifact due to the 2π periodicity of azimuth. Interestingly, the artifact is not distinct in all filters, suggesting the network may learn to overcome it if necessary."
    }, {
      "heading" : "5. Conclusion",
      "text" : "We have introduced edge-conditioned convolution (ECC), an operation on graph signal performed in the spatial domain where filter weights are conditioned on edge labels and dynamically generated for each specific input sample. We have shown that our formulation generalizes the standard convolution on graphs if edge labels are chosen properly and experimentally validated this assertion on MNIST. We applied our approach to point cloud classification in a novel way, setting a new state of the art performance on Sydney dataset. Furthermore, we have outperformed other deep learning-based approaches on graph classification dataset NCI1.\nIn feature work we would like to treat meshes as graphs rather than point clouds. Moreover, we plan to address the currently higher level of GPU memory consumption in case of large graphs with continuous edge labels, for example by randomized clustering, which could also serve as additional regularization through data augmentation.\nAcknowledgments.\nWe gratefully acknowledge NVIDIA Corporation for the donated GPU used in this research. We are thankful to anonymous reviewers for their feedback."
    }, {
      "heading" : "A. Overview",
      "text" : "In the first part, the appendix provides further discussion of the graph classification results (Section B) and investigates robustness of point cloud classification to noise (Section C). In the second part, we explore several extensions of our ECC formulation, specifically with different edge labeling for point clouds (Section D), with identity connections (Section E), with degree labels (Section F), and with a learned normalization factor (Section G)."
    }, {
      "heading" : "B. Details on Graph Classification Benchmark",
      "text" : "In this section we describe the differences in our network architecture to the one introduced for NCI1 in the main paper and discuss evaluation results for each dataset in detail.\nNCI1. ECC (83.80%) performs distinctly better than convolution methods that are not able to use edge labels (DCNN [2] 62.61%, PSCN [28] 78.59%). Methods not approaching the problem as convolutions on graphs but rather combining deep learning with other techniques are stronger (Deep WL [41] 80.31%, structure2vec [8] 83.72%) but are still outperformed by ECC. While the WeisfeilerLehman graph kernel remains the strongest method (WL [35] 84.55%), it is fair to conclude that ECC, structure2vec, and WL perform at the same level.\nNCI109. We use the same ECC-network configuration and training details as described in Section 4.3 for NCI1, since both datasets are similar. ECC (82.14%) performs distinctly better than DCNN [2] (62.86%), which is not able to use edge labels, and is on par with non-convolutional approaches (Deep WL [41] 80.32%, structure2vec [8] 82.16%, WL [35] 84.49%).\nMUTAG. As MUTAG is a tiny dataset of small graphs, we trained a downsized ECC-network to combat overfitting. Using the notation from Section 4.3, its configuration is C(16)-C(32)-C(48)-MP-C(64)-MP-GAP-FC(64)-D(0.2)FC(2), all other details are as with NCI1. While by numbers ECC (89.44%) outperforms all other approaches except of PSCN [28] (92.63%), we note that all four leading\nmethods (Deep WL [41] 87.44%, structure2vec [8] 88.28%, ECC, PSCN) can be seen to perform equally well due to fluctuations caused by the dataset size. We account the tiny decrease in performance with test-time randomization (88.33%) to the same reason.\nENZYMES. Due to higher complexity of this task we use a wider ECC-network configured as C(64)-C(64)-C(96)MP-C(96)-C(128)-MP-C(128)-C(160)-MP-C(160)-GAPFC(192)-D(0.2)-FC(6) using the notation and other details in Section 4.3. As this dataset is not edge-labeled, we do not expect to obtain the best performance. Indeed, our method (53.50%) performs at the level of Deep WL [41] (53.43%) and is overperformed by WL [35] (59.05%) and structure2vec [8] (61.10%). Note that the gap to the other convolution-based method DCNN [2] (18.10%) is huge and there is an improvement of more than 4 percentage points due to edge labels in coarser graph resolutions from Kron reduction.\nD&D. Due to large graphs in this dataset we designed a ECC-network with more pooling configured as C(48)-C(48)-C(48)-MP-C(48)-MP-C(64)-MP-C(64)-MPC(64)-MP-C(64)-MP-GAP-FC(64)-D(0.2)-FC(2) using the notation and other details in Section 4.3. As this dataset is not edge-labeled, we do not expect to obtain the best performance. Our method (74.10%) is overperformed by the others who evaluated on this dataset (PSCN [28] 77.12%, WL [35] 79.78%, structure2vec [8] 82.22%), though the margin is not very large."
    }, {
      "heading" : "C. Robustness to Noise",
      "text" : "Real-world point clouds contain several kinds of artifacts, such as holes due to occlusions and Gaussian noise due to measurement uncertainty. Figure 6 shows that ECC is highly robust to point removal and can be made robust to additive Gaussian noise by a proper training data augmentation."
    }, {
      "heading" : "D. Edge Labels for Point Clouds",
      "text" : "In Section 3.4 we defined edge labels L(j, i) as the offset δ = pj − pi in Cartesian and spherical coordinates, L(j, i) = (δx, δy, δz, ||δ||, arccos δz/||δ||, arctan δy/δx). Here, we explore the importance of individual elements in the proposed edge labeling and further evaluate labels invariant to rotation about objects’ vertical axis z (IRz). Table 6 conveys that models with isotropic (60.7) or no labels (38.9) perform poorly as expected, while either of the coordinate systems is important. IRz labeling performs comparably or even slightly better than our proposed one. However, we believe this a property of the specific dataset and may not necessarily generalize, an example being MNIST,\nwhere IRz is equivalent to full isotropy and decreases accuracy to 89.9%.\nE. Identity Connections\nThe formulation of ECC in Equation 1 does not treat self-loop edges in a special way. However, the success of residual networks [18] is a strong motivation to consider adding identity skip-connections to our model and encouraging ECC in residual learning. We thus formulate ECCresnet as follows:\nX l(i) = 1 |N(i)| ∑\nj∈N(i)\nΘljiX l−1(j) + bl + id(X l−1(i))\n(2) where id() is an identity mapping if dl = dl−1 and a linear mapping otherwise. The results listed in Table 7 show that with two exceptions (NCI109 and ENZYMES) ECC does not benefit from identity connections in the specific network configurations. The trend may be different for other configurations, e.g. ECC 1.5ρ improved from 76.9 to 79.5 mean F1 score on Sydney due to identity connections as mentioned in Section 4.1.\nF. Vertex Degrees in Edge Labels In the task of graph classification, we used categorical labels (if present) encoded as one-hot vectors for edges in the input graph and scalars computed by Kron reduction for edges in all coarsened graphs.\nHere we investigate making the edge labels more informative by including the degrees of the pair of vertices forming an edge. The degree information is implicitly used by spectral convolution methods, as the degree information is contained in the graph Laplacian, and also appears in the explicit propagation rules [21, 2].\nOur model can be easily extended to make use of this information by simply appending it to the existing edge label vectors. We consider four variants of providing additional degree labels Ldeg(j) and Ldeg(i) about a directed edge (j, i): Ldeg(i) = 1/ √ deg(i), Ldeg(i) =\n1/deg(i), Ldeg(i) = √\ndeg(i), and Ldeg(i) = deg(i), where deg(i) = |N(i)| is the degree of vertex i ∈ V . We use these additional labels in all graph resolutions.\nTable 8 reveals that degree information can improve the results considerably, especially for datasets without given edge labels (by up to 5 percentage points for ENZYMES and up to 2.14 percentage points for D&D). However, no variant of Ldeg(i) can guarantee consistent improvement over all datasets.\nG. Vertex Degrees in Normalization The formulation of ECC in Equation 1 performs normalization by the neighborhood size. Here we explore learning an additional multiplicative factor, conditioned on the\nneighborhood size 1/|N(i)|. To this end, we again make use of Dynamic filter networks [5] and design a factorgenerating network Zl : R 7→ R which given vertex degree deg(i) = |N(i)| outputs a vertex-specific normalization factor. We formulate ECC-Z as follows:\nX l(i) = Zl(|N(i)|;wl) |N(i)| ∑ j∈N(i) ΘljiX l−1(j) + bl (3)\nIn our experiments, the factor-generating networks Zl have configuration FC(32)-FC(1) with orthogonal weight initialization [33] and ReLUs in between.\nThe results in Table 9 show that while being helpful on some datasets (NCI109, ENZYMES, ModelNet10), ECCZ harms the performance on the other ones. Embedding vertex information in labels instead seems to achieve higher performance (Section F)."
    } ],
    "references" : [ {
      "title" : "Orientation-boosted voxel nets for 3d object recognition",
      "author" : [ "N.S. Alvar", "M. Zolfaghari", "T. Brox" ],
      "venue" : "CoRR, abs/1604.03351",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Diffusion-convolutional neural networks",
      "author" : [ "J. Atwood", "D. Towsley" ],
      "venue" : "NIPS",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Layer normalization",
      "author" : [ "L.J. Ba", "R. Kiros", "G.E. Hinton" ],
      "venue" : "CoRR, abs/1607.06450",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Shortest-path kernels on graphs",
      "author" : [ "K.M. Borgwardt", "H. Kriegel" ],
      "venue" : "Proceedings of the 5th IEEE International Conference on Data Mining ",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Dynamic filter networks",
      "author" : [ "B.D. Brabandere", "X. Jia", "T. Tuytelaars", "L.V. Gool" ],
      "venue" : "NIPS",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Spectral networks and locally connected networks on graphs",
      "author" : [ "J. Bruna", "W. Zaremba", "A. Szlam", "Y. LeCun" ],
      "venue" : "CoRR, abs/1312.6203",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Performance of global descriptors for velodyne-based urban object recognition",
      "author" : [ "T. Chen", "B. Dai", "D. Liu", "J. Song" ],
      "venue" : "2014 IEEE Intelligent Vehicles Symposium Proceedings, Dearborn, MI, USA, June 8-11, 2014, pages 667–673",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Discriminative embeddings of latent variable models for structured data",
      "author" : [ "H. Dai", "B. Dai", "L. Song" ],
      "venue" : "ICML",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Unsupervised feature learning for classification of outdoor 3d scans",
      "author" : [ "M. De Deuge", "A. Quadros", "C. Hung", "B. Douillard" ],
      "venue" : "Australasian Conference on Robitics and Automation, volume 2",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "R",
      "author" : [ "A.K. Debnath" ],
      "venue" : "L. Lopez de Compadre, G. Debnath, A. J. Shusterman, and C. Hansch. Structure-activity relationship of mutagenic aromatic and heteroaromatic nitro compounds. correlation with molecular orbital energies and hydrophobicity. Journal of medicinal chemistry, 34(2):786–797",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Convolutional neural networks on graphs with fast localized spectral filtering",
      "author" : [ "M. Defferrard", "X. Bresson", "P. Vandergheynst" ],
      "venue" : "NIPS",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Distinguishing enzyme structures from non-enzymes without alignments",
      "author" : [ "P.D. Dobson", "A.J. Doig" ],
      "venue" : "Journal of molecular biology, 330(4):771–783",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Kron reduction of graphs with applications to electrical networks",
      "author" : [ "F. Dörfler", "F. Bullo" ],
      "venue" : "IEEE Trans. on Circuits and Systems, 60-I(1):150–163",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Convolutional networks on graphs for learning molecular fingerprints",
      "author" : [ "D.K. Duvenaud", "D. Maclaurin", "J. Aguilera-Iparraguirre", "R. Bombarell", "T. Hirzel", "A. Aspuru-Guzik", "R.P. Adams" ],
      "venue" : "NIPS",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Graph based convolutional neural network",
      "author" : [ "M. Edwards", "X. Xie" ],
      "venue" : "BMVC",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Fractional max-pooling",
      "author" : [ "B. Graham" ],
      "venue" : "CoRR, abs/1412.6071",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Convolutional neural networks at constrained time cost",
      "author" : [ "K. He", "J. Sun" ],
      "venue" : "CVPR",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Deep residual learning for image recognition",
      "author" : [ "K. He", "X. Zhang", "S. Ren", "J. Sun" ],
      "venue" : "CVPR",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Point cloud labeling using 3d convolutional neural network",
      "author" : [ "J. Huang", "S. You" ],
      "venue" : "ICPR",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
      "author" : [ "S. Ioffe", "C. Szegedy" ],
      "venue" : "ICML",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Semi-supervised classification with graph convolutional networks",
      "author" : [ "T.N. Kipf", "M. Welling" ],
      "venue" : "CoRR, abs/1609.02907",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Deep learning",
      "author" : [ "Y. LeCun", "Y. Bengio", "G. Hinton" ],
      "venue" : "Nature, 521(7553):436–444",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Gradientbased learning applied to document recognition",
      "author" : [ "Y. LeCun", "L. Bottou", "Y. Bengio", "P. Haffner" ],
      "venue" : "Proceedings of the IEEE, 86(11):2278–2324",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Gated graph sequence neural networks",
      "author" : [ "Y. Li", "D. Tarlow", "M. Brockschmidt", "R.S. Zemel" ],
      "venue" : "ICLR",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Geodesic convolutional neural networks on riemannian manifolds",
      "author" : [ "J. Masci", "D. Boscaini", "M.M. Bronstein", "P. Vandergheynst" ],
      "venue" : "pages 37–45",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Voxnet: A 3d convolutional neural network for real-time object recognition",
      "author" : [ "D. Maturana", "S. Scherer" ],
      "venue" : "IROS",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "All you need is a good init",
      "author" : [ "D. Mishkin", "J. Matas" ],
      "venue" : "ICLR",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Learning convolutional neural networks for graphs",
      "author" : [ "M. Niepert", "M. Ahmed", "K. Kutzkov" ],
      "venue" : "ICML",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "GSPBOX: A toolbox for signal processing on graphs",
      "author" : [ "N. Perraudin", "J. Paratte", "D.I. Shuman", "V. Kalofolias", "P. Vandergheynst", "D.K. Hammond" ],
      "venue" : "CoRR, abs/1408.5781",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Volumetric and multi-view cnns for object classification on 3d data",
      "author" : [ "C.R. Qi", "H. Su", "M. Nießner", "A. Dai", "M. Yan", "L.J. Guibas" ],
      "venue" : "CVPR",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "3d is here: Point cloud library (pcl)",
      "author" : [ "R.B. Rusu", "S. Cousins" ],
      "venue" : "Robotics and Automation (ICRA), 2011 IEEE International Conference on, pages 1–4. IEEE",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Advanced coarsening schemes for graph partitioning",
      "author" : [ "I. Safro", "P. Sanders", "C. Schulz" ],
      "venue" : "ACM Journal of Experimental Algorithmics, 19(1)",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Exact solutions to the nonlinear dynamics of learning in deep linear neural networks",
      "author" : [ "A.M. Saxe", "J.L. McClelland", "S. Ganguli" ],
      "venue" : "ICLR",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "The graph neural network model",
      "author" : [ "F. Scarselli", "M. Gori", "A.C. Tsoi", "M. Hagenbuchner", "G. Monfardini" ],
      "venue" : "IEEE Trans. Neural Networks, 20(1):61–80",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "E",
      "author" : [ "N. Shervashidze", "P. Schweitzer" ],
      "venue" : "J. van Leeuwen, K. Mehlhorn, and K. M. Borgwardt. Weisfeiler-lehman graph kernels. Journal of Machine Learning Research, 12:2539–2561",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "A multiscale pyramid transform for graph signals",
      "author" : [ "D.I. Shuman", "M.J. Faraji", "P. Vandergheynst" ],
      "venue" : "IEEE Trans. Signal Processing, 64(8):2119–2134",
      "citeRegEx" : "36",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Graph sparsification by effective resistances",
      "author" : [ "D.A. Spielman", "N. Srivastava" ],
      "venue" : "SIAM Journal on Computing, 40(6):1913–1926",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Multi-view convolutional neural networks for 3d shape recognition",
      "author" : [ "H. Su", "S. Maji", "E. Kalogerakis", "E.G. Learned-Miller" ],
      "venue" : "ICCV",
      "citeRegEx" : "38",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Comparison of descriptor spaces for chemical compound retrieval and classification",
      "author" : [ "N. Wale", "I.A. Watson", "G. Karypis" ],
      "venue" : "Knowledge and Information Systems, 14(3):347–375",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "and J",
      "author" : [ "Z. Wu", "S. Song", "A. Khosla", "X. Tang" ],
      "venue" : "Xiao. 3d shapenets for 2.5d object recognition and next-best-view prediction. In CVPR",
      "citeRegEx" : "40",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Deep graph kernels",
      "author" : [ "P. Yanardag", "S.V.N. Vishwanathan" ],
      "venue" : "SIGKDD",
      "citeRegEx" : "41",
      "shortCiteRegEx" : null,
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 21,
      "context" : "Convolutional Neural Networks (CNNs) have gained massive popularity in tasks where the underlying data representation has a grid structure, such as in speech processing and natural language understanding (1D, temporal convolutions), in image classification and segmentation (2D, spatial convolutions), or in video parsing (3D, volumetric convolutions) [22].",
      "startOffset" : 352,
      "endOffset" : 356
    }, {
      "referenceID" : 25,
      "context" : "Point clouds have been mostly ignored by deep learning so far, their voxelization being the only trend to the best of our knowledge [26, 19].",
      "startOffset" : 132,
      "endOffset" : 140
    }, {
      "referenceID" : 18,
      "context" : "Point clouds have been mostly ignored by deep learning so far, their voxelization being the only trend to the best of our knowledge [26, 19].",
      "startOffset" : 132,
      "endOffset" : 140
    }, {
      "referenceID" : 8,
      "context" : "To offer a competitive alternative with a different set of advantages and disadvantages, we construct graphs in Euclidean space from point clouds in this work and demonstrate state of the art performance on Sydney dataset of LiDAR scans [9].",
      "startOffset" : 237,
      "endOffset" : 240
    }, {
      "referenceID" : 38,
      "context" : "• We reach a competitive level of performance on graph classification benchmark NCI1 [39], outperforming other approaches based on deep learning there.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 5,
      "context" : "[6], who looked into both the spatial and the spectral domain of representation for performing localized filtering.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "The spatial locality of filters is then given by smoothness of the spectral filters, in case of [6] modeled as B-splines.",
      "startOffset" : 96,
      "endOffset" : 99
    }, {
      "referenceID" : 10,
      "context" : "[11].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 5,
      "context" : "The main challenge here is dealing with weight sharing among local neighborhoods [6], as the number of vertices adjacent to a particular vertex varies and their ordering is often not well definable.",
      "startOffset" : 81,
      "endOffset" : 84
    }, {
      "referenceID" : 5,
      "context" : "[6] assumed fixed graph structure and did not share any weights among neighborhoods.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 13,
      "context" : "[14] sum the signal over neighboring vertices followed by a weight matrix multiplication, effectively sharing the same weights among all edges.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 1,
      "context" : "Atwood and Towsley [2] share weights based on the number of hops between two vertices.",
      "startOffset" : 19,
      "endOffset" : 22
    }, {
      "referenceID" : 20,
      "context" : "Kipf and Welling [21] further approximate the spectral method of [11] and weaken the dependency on the Laplacian, but ultimately arrive at center-surround weighting of neighborhoods.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 10,
      "context" : "Kipf and Welling [21] further approximate the spectral method of [11] and weaken the dependency on the Laplacian, but ultimately arrive at center-surround weighting of neighborhoods.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 27,
      "context" : "[28] introduces a heuristic for linearizing selected graph neighborhoods so that a conventional 1D CNN can be used.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 33,
      "context" : "Finally, Graph neural networks [34, 24] propagate features across a graph until (near) convergence and exploit edge labels as one of the sources of information as we do.",
      "startOffset" : 31,
      "endOffset" : 39
    }, {
      "referenceID" : 23,
      "context" : "Finally, Graph neural networks [34, 24] propagate features across a graph until (near) convergence and exploit edge labels as one of the sources of information as we do.",
      "startOffset" : 31,
      "endOffset" : 39
    }, {
      "referenceID" : 24,
      "context" : "[25] define convolution over patch descriptors around every vertex of a 3D mesh using geodesic distances, formulated in a deep learning architecture.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 25,
      "context" : "voxelize them before feeding them to a 3D CNN, be it for classification [26] or segmentation [19] purposes.",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 18,
      "context" : "voxelize them before feeding them to a 3D CNN, be it for classification [26] or segmentation [19] purposes.",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 4,
      "context" : "To this end, we borrow the idea from Dynamic filter networks [5] and define a filter-generating network F l : R 7→ Rdl×dl−1 which given edge label L(j, i) outputs edge-specific weight matrix Θji ∈ Rdl×dl−1 , see Figure 1.",
      "startOffset" : 61,
      "endOffset" : 64
    }, {
      "referenceID" : 1,
      "context" : "The weights in ECC are tied by edge label, which is in contrast to tying them by hop distance from a vertex [2], according to a neighborhood linearization heuristic [28], by being the central vertex or not [21], indiscriminately [14], or not at all [6].",
      "startOffset" : 108,
      "endOffset" : 111
    }, {
      "referenceID" : 27,
      "context" : "The weights in ECC are tied by edge label, which is in contrast to tying them by hop distance from a vertex [2], according to a neighborhood linearization heuristic [28], by being the central vertex or not [21], indiscriminately [14], or not at all [6].",
      "startOffset" : 165,
      "endOffset" : 169
    }, {
      "referenceID" : 20,
      "context" : "The weights in ECC are tied by edge label, which is in contrast to tying them by hop distance from a vertex [2], according to a neighborhood linearization heuristic [28], by being the central vertex or not [21], indiscriminately [14], or not at all [6].",
      "startOffset" : 206,
      "endOffset" : 210
    }, {
      "referenceID" : 13,
      "context" : "The weights in ECC are tied by edge label, which is in contrast to tying them by hop distance from a vertex [2], according to a neighborhood linearization heuristic [28], by being the central vertex or not [21], indiscriminately [14], or not at all [6].",
      "startOffset" : 229,
      "endOffset" : 233
    }, {
      "referenceID" : 5,
      "context" : "The weights in ECC are tied by edge label, which is in contrast to tying them by hop distance from a vertex [2], according to a neighborhood linearization heuristic [28], by being the central vertex or not [21], indiscriminately [14], or not at all [6].",
      "startOffset" : 249,
      "endOffset" : 252
    }, {
      "referenceID" : 13,
      "context" : "[14] (up to scaling) in the case of uninformative edge labels: ∑ j∈N(i) Θ l jiX l−1(j) = Θ ∑ j∈N(i)X l−1(j) if Θji = Θ l ∀(j, i) ∈ E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 1,
      "context" : "Note that such equivalence is not possible with none of [2, 21, 14] due to their way of weight tying.",
      "startOffset" : 56,
      "endOffset" : 67
    }, {
      "referenceID" : 20,
      "context" : "Note that such equivalence is not possible with none of [2, 21, 14] due to their way of weight tying.",
      "startOffset" : 56,
      "endOffset" : 67
    }, {
      "referenceID" : 13,
      "context" : "Note that such equivalence is not possible with none of [2, 21, 14] due to their way of weight tying.",
      "startOffset" : 56,
      "endOffset" : 67
    }, {
      "referenceID" : 16,
      "context" : "Therefore, the restriction of ECC to 1-hop neighborhoods N(i) is not a constraint, akin to using small 3×3 filters in normal CNNs in exchange for deeper networks, which is known to be beneficial [17].",
      "startOffset" : 195,
      "endOffset" : 199
    }, {
      "referenceID" : 19,
      "context" : "We use batch normalization [20] after each convolution, which was necessary for the learning to converge.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 26,
      "context" : "Interestingly, we had no success with other feature normalization techniques such as data-dependent initialization [27] or layer normalization [3].",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 2,
      "context" : "Interestingly, we had no success with other feature normalization techniques such as data-dependent initialization [27] or layer normalization [3].",
      "startOffset" : 143,
      "endOffset" : 146
    }, {
      "referenceID" : 25,
      "context" : "Due to their natural irregularity and sparsity, so far the only way of processing point clouds using deep learning has been to first voxelize them before feeding them to a 3D CNN, be it for classification [26] or segmentation [19] purposes.",
      "startOffset" : 205,
      "endOffset" : 209
    }, {
      "referenceID" : 18,
      "context" : "Due to their natural irregularity and sparsity, so far the only way of processing point clouds using deep learning has been to first voxelize them before feeding them to a 3D CNN, be it for classification [26] or segmentation [19] purposes.",
      "startOffset" : 226,
      "endOffset" : 230
    }, {
      "referenceID" : 30,
      "context" : "For a single input point cloud P , a pyramid of downsampled point clouds P (h) is obtained by the VoxelGrid algorithm [31], which overlays a grid of resolution r over the point cloud and replaces all points within a voxel with their centroid (and thus maintains subvoxel accuracy).",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 31,
      "context" : "This is by no means trivial and there exists a large body of literature on this problem [32].",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 35,
      "context" : "[36, 29], which works by repeated downsampling and graph reduction of the input graph.",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 28,
      "context" : "[36, 29], which works by repeated downsampling and graph reduction of the input graph.",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 12,
      "context" : "This is followed by Kron reduction [13], which also defines the new edge labeling, enhanced with spectral sparsification of edges [37].",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 36,
      "context" : "This is followed by Kron reduction [13], which also defines the new edge labeling, enhanced with spectral sparsification of edges [37].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 15,
      "context" : "This is in spirit similar to the effect of fractional max-pooling [16].",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 8,
      "context" : "This point cloud dataset [9] consists of 588 objects in 14 categories (vehicles, pedestrians, signs, and trees) manually extracted from 360◦ LiDAR scans, see Figure 4.",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 8,
      "context" : "Triangle+SVM [9] 67.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 6,
      "context" : "1 GFH+SVM [7] 71.",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 25,
      "context" : "0 VoxNet [26] 73.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 0,
      "context" : "0 ORION [1] 77.",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 8,
      "context" : "Mean F1 score weighted by class frequency on Sydney Urban Objects dataset [9].",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 32,
      "context" : "The filter-generating networks F l have configuration FC(16)-FC(32)-FC(dldl−1) with orthogonal weight initialization [33] and ReLUs in between.",
      "startOffset" : 117,
      "endOffset" : 121
    }, {
      "referenceID" : 25,
      "context" : "4) against two methods based on volumetric CNNs evaluated on voxelized occupancy grids of size 32x32x32 (VoxNet [26] 73.",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 0,
      "context" : "0 and ORION [1] 77.",
      "startOffset" : 12,
      "endOffset" : 15
    }, {
      "referenceID" : 39,
      "context" : "ModelNet [40] is a large scale collection of object meshes.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 8,
      "context" : "Illustrative samples of the majority of classes in Sydney Urban Objects dataset, reproduced from [9].",
      "startOffset" : 97,
      "endOffset" : 100
    }, {
      "referenceID" : 39,
      "context" : "Table 2 compares our result to several recent works, based either on volumetric [40, 26, 1, 30] or rendered image representation [38].",
      "startOffset" : 80,
      "endOffset" : 95
    }, {
      "referenceID" : 25,
      "context" : "Table 2 compares our result to several recent works, based either on volumetric [40, 26, 1, 30] or rendered image representation [38].",
      "startOffset" : 80,
      "endOffset" : 95
    }, {
      "referenceID" : 0,
      "context" : "Table 2 compares our result to several recent works, based either on volumetric [40, 26, 1, 30] or rendered image representation [38].",
      "startOffset" : 80,
      "endOffset" : 95
    }, {
      "referenceID" : 29,
      "context" : "Table 2 compares our result to several recent works, based either on volumetric [40, 26, 1, 30] or rendered image representation [38].",
      "startOffset" : 80,
      "endOffset" : 95
    }, {
      "referenceID" : 37,
      "context" : "Table 2 compares our result to several recent works, based either on volumetric [40, 26, 1, 30] or rendered image representation [38].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 34,
      "context" : "Following [35], we perform 10-fold cross-validation",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 39,
      "context" : "3DShapeNets [40] 83.",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 37,
      "context" : "3 MVCNN [38] — 90.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 25,
      "context" : "1 VoxNet [26] 92 83 ORION [1] 93.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 0,
      "context" : "1 VoxNet [26] 92 83 ORION [1] 93.",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 29,
      "context" : "8 — SubvolumeSup [30] — 86.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 39,
      "context" : "mean instance accuracy) on ModelNets [40].",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 38,
      "context" : "NCI1 and NCI109 [39] consist of graph representations of chemical compounds screened for activity against nonsmall cell lung cancer and ovarian cancer cell lines, respectively.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 9,
      "context" : "MUTAG [10] is a dataset of nitro compounds labeled according to whether or not they have a mutagenic effect on a bacterium.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 3,
      "context" : "ENZYMES [4] contains representations of tertiary structure of 6 classes of enzymes.",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 11,
      "context" : "D&D [12] is a database of protein structures (vertices are amino acids, edges indicate spatial closeness) classified as enzymes and non-enzymes.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 32,
      "context" : "The filter-generating networks F l have configuration FC(64)-FC(dldl−1) with orthogonal weight initialization [33] and ReLU in between.",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 34,
      "context" : "[35] and to four approaches using deep learning as at least one of their components [2, 28, 41, 8].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 1,
      "context" : "[35] and to four approaches using deep learning as at least one of their components [2, 28, 41, 8].",
      "startOffset" : 84,
      "endOffset" : 98
    }, {
      "referenceID" : 27,
      "context" : "[35] and to four approaches using deep learning as at least one of their components [2, 28, 41, 8].",
      "startOffset" : 84,
      "endOffset" : 98
    }, {
      "referenceID" : 40,
      "context" : "[35] and to four approaches using deep learning as at least one of their components [2, 28, 41, 8].",
      "startOffset" : 84,
      "endOffset" : 98
    }, {
      "referenceID" : 7,
      "context" : "[35] and to four approaches using deep learning as at least one of their components [2, 28, 41, 8].",
      "startOffset" : 84,
      "endOffset" : 98
    }, {
      "referenceID" : 7,
      "context" : "Characteristics of the graph benchmark datasets, extended from [8].",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 1,
      "context" : "DCNN [2] 62.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 27,
      "context" : "10 — PSCN [28] 78.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 40,
      "context" : "12 Deep WL [41] 80.",
      "startOffset" : 11,
      "endOffset" : 15
    }, {
      "referenceID" : 7,
      "context" : "43 — structure2vec [8] 83.",
      "startOffset" : 19,
      "endOffset" : 22
    }, {
      "referenceID" : 34,
      "context" : "22 WL [35] 84.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 1,
      "context" : "The results demonstrate the importance of exploiting edge labels for convolution-based methods, as the performance of DCNN [2] and ECC without edge labels is distinctly worse, justifying the motivation behind this paper.",
      "startOffset" : 123,
      "endOffset" : 126
    }, {
      "referenceID" : 22,
      "context" : "To further validate our method, we applied it to the MNIST classification problem [23], a dataset of 70k greyscale images of handwritten digits represented on a 2D grid of size 28×28.",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 10,
      "context" : "[11] and better than what is offered by other spectral-based approaches (98.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 5,
      "context" : "2 [6], 94.",
      "startOffset" : 2,
      "endOffset" : 5
    }, {
      "referenceID" : 14,
      "context" : "96 [15]).",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 22,
      "context" : "Accuracy on MNIST dataset [23].",
      "startOffset" : 26,
      "endOffset" : 30
    } ],
    "year" : 2017,
    "abstractText" : "A number of problems can be formulated as prediction on graph-structured data. In this work, we generalize the convolution operator from regular grids to arbitrary graphs while avoiding the spectral domain, which allows us to handle graphs of varying size and connectivity. To move beyond a simple diffusion, filter weights are conditioned on the specific edge labels in the neighborhood of a vertex. Together with the proper choice of graph coarsening, we explore constructing deep neural networks for graph classification. In particular, we demonstrate the generality of our formulation in point cloud classification, where we set the new state of the art, and on a graph classification dataset, where we outperform other deep learning approaches.",
    "creator" : "LaTeX with hyperref package"
  }
}