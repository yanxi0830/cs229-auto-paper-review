{
  "name" : "1206.4618.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Compact Hyperplane Hashing with Bilinear Functions",
    "authors" : [ "Wei Liu", "Jun Wang", "Yadong Mu", "Sanjiv Kumar", "Shih-Fu Chang" ],
    "emails" : [ "wliu@ee.columbia.edu", "muyadong@ee.columbia.edu", "sfchang@ee.columbia.edu", "wangjun@us.ibm.com", "sanjivk@google.com" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Fast approximate nearest neighbor search arises commonly in a variety of domains and applications due to massive growth in data that one is confronted with. An attractive solution to overcome the speed bottleneck that an exhaustive linear scan incurs is the use of algo-\nAppearing in Proceedings of the 29 th International Conference on Machine Learning, Edinburgh, Scotland, UK, 2012. Copyright 2012 by the author(s)/owner(s).\nrithms from the Locality-Sensitive Hashing (LSH) family (Gionis et al., 1999)(Charikar, 2002)(Datar et al., 2004) which use random projections to convert input data into binary hash codes. Although enjoying theoretical guarantees on sub-linear hashing/search time and the accuracy of the returned neighbors, LSHrelated methods typically need long codes and a large number of hash tables to achieve good search accuracy. This may lead to considerable storage overhead and reduced search speed. Hence, in the literature, directly learning data-dependent hash functions to generate compact codes has become popular. Such hashing typically needs a small number of bits per data item and can be designed to work well with a single hash table and constant hashing time. The state-of-thearts include unsupervised hashing (Liu et al., 2011), semi-supervised hashing (Wang et al., 2012), and supervised hashing (Liu et al., 2012).\nMost of the existing hashing methods try to solve the problem of point-to-point nearest neighbor search. Namely, both queries and database items are represented as individual points in some feature space. Considering complex structures of real-world data, other forms of hashing paradigms beyond point-topoint search have also been proposed in the past, e.g., subspace-to-subspace nearest neighbor search (Basri et al., 2011). In this paper, we address a more challenging point-to-hyperplane search problem, where queries come as hyperplanes in Rd, i.e., (d− 1)- dimensional subspaces, and database items are conventional points. Then the search problem is: given a hyperplane query and a database of points, return the points which have minimal distances to the hyperplane. In the literature, not much work has been done on the point-to-hyperplane problem except (Jain et al., 2010) which demonstrated the vital importance of such a problem in making SVM-based active learning feasible on massive data pools.\nActive learning (AL), also known as pool-based active learning, circumvents the high cost of blind labeling by selecting a few samples to label. At each iteration, a typical AL learner seeks the most informative sample from an unlabeled sample pool, so that maximal information gain is achieved after labeling the selected sample. Subsequently, the learning model is re-trained on the incrementally labeled sample set. The classical AL algorithm (Tong & Koller, 2001) used SVMs as learning models. Based on the theory of “version spaces” (Tong & Koller, 2001), it was provably shown that the best sample to select is simply the one closest to the current decision hyperplane if the assumption of symmetric version spaces holds. Unfortunately, the active selection method faces serious computational challenges when applied to gigantic databases. An exhaustive search to find the best sample is usually computationally prohibitive. Thus, fast point-to-hyperplane search is strongly desired to scale up active learning on large real-world data sets.\nRecently, hyperplane hashing schemes were proposed in (Jain et al., 2010) to cope with point-to-hyperplane search. Compared with the brute-force scan through all of the database points, these schemes are significantly more efficient with theoretical guarantees of sub-linear query time and tolerable loss of accuracy for retrieved approximate nearest neighbors. Consequently, when applying hyperplane hashing to the sample selection task for SVM active learning, one can scan orders of magnitude fewer database points to deliver the next active label request, thereby making active learning scalable.\nIn (Jain et al., 2010), two families of randomized hash functions were proved locality-sensitive to the angle between a database point and a hyperplane query; however, long hash bits and plentiful hash tables are required to cater for the theoretical guarantees. Actually, 300 bits and 500 tables were adopted in (Jain et al., 2010) to achieve reasonable performance, which incurs a heavy burden on both computation and storage. To mitigate the above mentioned issues, this paper proposes a compact hyperplane hashing scheme which exploits only a single hash table with several tens of hash bits to tackle point-to-hyperplane search. The thrust of our hashing scheme is to design and learn bilinear hash functions such that nearly parallel input vectors are hashed to the same bits whereas nearly perpendicular input vectors are hashed to different bits. In fact, we first show that even without any learning, the randomized version of the proposed bilinear hashing gives higher near-neighbor collision probability than the existing methods.\nNext, we cast the bilinear projections in a learning framework and show that one can do even better by using learned hash functions. Given a hyperplane query, its normal vector is used as the input and the corresponding hash code is obtained by concatenating the output bits from the learned hash functions. Then, the database points whose codes have the farthest Hamming distances to the query’s code are retrieved. Critically, the retrieved points, called near-to-hyperplane neighbors, maintain small angles to the hyperplane following our learning principle. Experiments conducted on two large data sets up to one million corroborate that our approach enables scalable active learning with good performance. Finally, although in this paper we select SVM active learning as the testbed for hyperplane hashing, we want to highlight that the proposed compact hyperplane hashing is a general method and applicable to a large spectrum of machine learning problems such as minimal tangent distance pursuit and cutting-plane based maximum margin clustering."
    }, {
      "heading" : "2. Problem",
      "text" : "First of all, let us revisit the well-known margin-based AL strategy proposed by (Tong & Koller, 2001). For the convenience of expression, we append each data vector with a 1 and use a linear kernel. Then, the SVM classifier becomes f(x) = w⊤x where vector x ∈ Rd represents a data point and vector w ∈ Rd determines a hyperplane Pw passing through the origin. Fig. 1(a) displays the geometric relationship between w and Pw, where w is the vector normal to the hyperplane Pw. Given a hyperplane query Pw and a database of points X = {xi} n i=1, the active selection criterion prefers the most informative database point x∗ = argminx∈X D(x,Pw) which has the minimum margin to the SVM’s decision boundary Pw. Note that D(x,Pw) = |w ⊤ x|/‖w‖ is the point-to-\nhyperplane distance. To derive provable hyperplane hashing like (Jain et al., 2010), this paper focuses on a slightly modified “distance” |w ⊤ x|\n‖w‖‖x‖ which is the sine\nof the point-to-hyperplane angle\nαx,w = ∣ ∣ ∣ θx,w − π\n2\n∣ ∣ ∣ = sin−1\n|w⊤x|\n‖w‖‖x‖ , (1)\nwhere θx,w ∈ [0, π] is the angle between x and the hyperplane normalw. The angle measure αx,w ∈ [0, π/2] between a database point and a hyperplane query can readily be reflected in hashing.\nAs shown in Fig. 1(b), the goal of hyperplane hashing is to hash a hyperplane query Pw and the informative samples (e.g., x1,x2) with narrow αx,w into the same or nearby hash buckets, meanwhile avoiding to return the uninformative samples (e.g., x3,x4) with wide αx,w. Because αx,w = ∣ ∣θx,w − π 2 ∣\n∣, the point-to-hyperplane search problem can be equivalently transformed to a specific point-to-point search problem where the query is the hyperplane normal w and the desirable nearest neighbor to the raw query Pw is the one whose angle θx,w from w is closest to π/2, i.e., most closely perpendicular to w. This is very different from traditional point-to-point nearest neighbor search which returns the most similar point to the query point. If we regard | cos(θx,w)| = |w⊤x| ‖w‖‖x‖ as a similarity measure between x and w, hyperplane hashing actually seeks for the most dissimilar point x ∗ of | cos(θx∗,w)| → 0 to the query point w. On the contrary, the most similar point such as w or −w is surely uninformative for the active selection criterion, and must be excluded."
    }, {
      "heading" : "3. Randomized Hyperplane Hashing",
      "text" : "In this section, we first briefly review the existing linear function based randomized hashing methods, then propose our bilinearly formed randomized hashing approach, and finally provide theoretic analysis for the proposed bilinear hash function."
    }, {
      "heading" : "3.1. Background – Linear Hash Functions",
      "text" : "Jain et al. (Jain et al., 2010) devised two distinct families of randomized hash functions to attack the hyperplane hashing problem.\nThe first one is Angle-Hyperplane Hash (AH-Hash) A, of which one example is\nhA(z) = {\n[sgn(u⊤z), sgn(v⊤z)], z is a database point [sgn(u⊤z), sgn(−v⊤z)], z is a hyperplane normal\n(2)\nwhere z ∈ Rd represents an input vector, and u and v are both drawn independently from a standard dvariate Gaussian, i.e., u,v ∼ N (0, Id×d). Note that hA is a two-bit hash function which leads to the probability of collision for a hyperplane normal w and a database point x:\nPr [ hA(w) = hA(x) ] = 1\n4 −\nα2 x,w\nπ2 . (3)\nThe probability monotonically decreases as the pointto-hyperplane angle αx,w increases, ensuring anglesensitive hashing.\nThe second is Embedding-Hyperplane Hash (EH-Hash) function family E of which one example is\nhE(z) =\n{ sgn ( U⊤V(zz⊤) )\n, z is a database point sgn ( −U⊤V(zz⊤) ) , z is a hyperplane normal\n(4)\nwhere V(A) returns the vectorial concatenation of matrix A, and U ∼ N (0, Id2×d2). In particular, the EH hash function hE yields hash bits on an embedded space Rd 2\nresulting from vectorizing rank-one matrices zz\n⊤ and −zz⊤. Compared with hA, hE gives a higher probability of collision for a hyperplane normal w and a database point x:\nPr [ hE(w) = hE(x) ] = cos−1 sin2(αx,w)\nπ , (5)\nwhich also bears the angle-sensitive hashing property. However, it is much more expensive to compute than AH-Hash.\nIt is important to note that both AH-Hash and EHHash are essentially linear hashing techniques. On the contrary, in this work we introduce bilinear hash functions which allow nonlinear hashing."
    }, {
      "heading" : "3.2. Bilinear Hash Functions",
      "text" : "We propose a bilinear hash function as follows\nh(z) = sgn(u⊤zz⊤v), (6)\nwhere u,v ∈ Rd are two projection vectors. Our motivation for devising such a bilinear form comes from the following two requirements: 1) h should be invariant to the scale of z, which is motivated by the fact that z and βz (β 6= 0) hold the same point-tohyperplane angle; and 2) h should yield different hash bits for two perpendicular input vectors. The former definitely holds due to the bilinear formulation. We show in Lemma 1 that the latter holds with a constant probability when u,v are drawn independently from the standard normal distribution.\nFor the purpose of hyperplane hashing described above, the pivotal role of bilinear hash functions is to map the query point w (the hyperplane normal) and the desirable most informative point (with θx,w = π/2) to bitwise different hash codes, whereas map w and the undesirable most uninformative point (with θx,w = 0 or π) to identical hash codes. Therefore, hyperplane hashing works by finding the points in X whose codes have the largest Hamming distances to the query code of w."
    }, {
      "heading" : "3.3. Theoretic Analysis",
      "text" : "Based on the bilinear formulation in eq. (6), we define a novel randomized function family Bilinear-Hyperplane Hash (BH-Hash) as:\nB = { hB(z) = sgn(u⊤zz⊤v), i.i.d. u,v ∼ N (0, Id×d) }\n. (7)\nHere we prove several key characteristics of B. Specially, we define hB(Pw) = −h\nB(w) for an easy derivation.\nLemma 1. Given a hyperplane query Pw with the normal vector w ∈ Rd and a database point x ∈ Rd, the probability of collision for Pw and x under h B is\nPr [ hB(Pw) = h B(x) ] = 1\n2 −\n2α2 x,w\nπ2 . (8)\nProof. This probability is equal to the probability of hB(w) 6= hB(x). Because the two random projections u and v are independent,\nPr [ hB(w) 6= hB(x) ] = Pr [ sgn(u⊤w) = sgn(u⊤x) ] ∗\nPr [ sgn(v⊤w) 6= sgn(v⊤x) ] +\nPr [ sgn(u⊤w) 6= sgn(u⊤x) ] Pr [ sgn(v⊤w) = sgn(v⊤x) ] .\nBy exploiting the fact Pr [ sgn(u⊤z) = sgn(u⊤z′) ] =\n1− θz,z′/π from (Goemans & Williamson, 1995),\nPr [ hB(w) 6= hB(x) ]\n=\n(\n1− θx,w π\n)\nθx,w π + θx,w π\n(\n1− θx,w π\n)\n= 1\n2 −\n2(θx,w − π 2 ) 2\nπ2 =\n1 2 −\n2α2 x,w\nπ2 ,\nwhich completes the proof.\nLemma 1 shows that the probability of hB(w) 6= hB(x) is 1/2 for perpendicular w and x that hold θx,w = π/2 (accordingly αx,w = 0). It is important to realize that this collision probability is twice of that from the linear AH hash function hA described in Sec. 3.1.\nTheorem 1. The BH-Hash function family B is (\nr, r(1 + ǫ), 12 − 2r π2 , 1 2 − 2r(1+ǫ) π2\n)\n-sensitive to the dis-\ntance measure D(x,Pw) = α 2 x,w, where r, ǫ > 0.\nProof. Using Lemma 1, for any hB ∈ B, when D(x,Pw) ≤ r we have\nPr [ hB(Pw) = h B(x) ] = 1\n2 −\n2D(x,Pw)\nπ2\n≥ 1\n2 −\n2r π2 = p1. (9)\nLikewise, when D(x,Pw) > r(1 + ǫ) we have\nPr [ hB(Pw) = h B(x) ] < 1\n2 −\n2r(1 + ǫ)\nπ2 = p2. (10)\nThis completes the proof.\nNote that p1, p2 (p1 > p2) depend on 0 ≤ r ≤ π 2/4 and ǫ > 0. We present the following theorem by adapting Theorem 1 in (Gionis et al., 1999) and Theorem 0.1 in the supplementary material of (Jain et al., 2010).\nTheorem 2. Suppose we have a database X of n points. Denote the parameters k = log1/p2 n, ρ = ln p1 ln p2 , and c ≥ 2. Given a hyperplane query Pw, if there exists a database point x∗ such that D(x∗,Pw) ≤ r, then the BH-Hash algorithm is able to return a database point x̂ such that D(x̂,Pw) ≤ r(1+ ǫ) with probability at least 1− 1c − 1 e by using n\nρ hash tables of k hash bits each. The query time is dominated by O(nρ log1/p2 n) evaluations of the hash functions from B and cnρ computations of the pairwise distances D between Pw and the points hashed into the same buckets.\nWe defer the proof to the supplementary material due to the page limit. The query time isO(nρ) (0 < ρ < 1). For each of AH-Hash, EH-Hash and BH-Hash, we plot the collision probability p1 and the query time exponent ρ under ǫ = 3 with varying r in Fig. 2(a) and (b),\nrespectively. At any fixed r, BH-Hash accomplishes the highest probability of collision, which is twice p1 of AH-Hash. Though BH-Hash has slightly bigger ρ than EH-Hash, it has much faster hash function computation, i.e., Θ(2dk), instead of Θ(d2(k + 1)) of EH-Hash per hash table for each query or data point.\nIt is interesting to see that AH-Hash and our proposed BH-Hash have a tight connection in the style of hashing database points. BH-Hash actually performs the XNOR operation over the two bits that AH-Hash outputs, returning a composite single bit. As a relevant reference, the idea of applying the XOR operation over binary bits in constructing hash functions has ever been used in (Li & König, 2010). However, this is only suitable for the limited data type, discrete set, and still falls into point-to-point search."
    }, {
      "heading" : "4. Compact Hyperplane Hashing",
      "text" : "Despite the higher collision probability of the proposed BH-Hash than AH-Hash and EH-Hash, it is still a randomized approach. The use of random projections in hB has two potential issues. (i) The probability of colliding for parallel Pw and x with αx,w = 0 is not too high (only 1/2 according to Lemma 1). (ii) The hashing time is sub-linear O(nρ log1/p2 n) in order to bound the approximation error of the retrieved neighbors, as shown in Theorem 2. AH-Hash and EHHash also suffer from the two issues. Even though these randomized hyperplane hashing methods maintain bounded approximation errors, they require long hash codes and plenty (even hundreds) of hash tables to cater for the accuracy guarantees. Hence, these solutions have tremendous computational and memory costs which limit the practical performance of hyperplane hashing.\nTo this end, we propose a Compact Hyperplane Hashing approach to further enhance the power of bilinear hash functions such that, instead of being random, the projections are learned from the data. Such learning yields compact yet discriminative codes which are used in a single hash table, leading to substantially reduced computational and storage needs.\nWe aim at learning a series of bilinear hash functions {hj} to yield short codes. Note that hj is different from the randomized bilinear hash function hBj , and that we consistently define hj(Pw) = −hj(w). We would like to learn hj such that smaller αx,w results in larger hj(Pw)hj(x). Thus, we make hj(Pw)hj(x) to monotonically decrease as αx,w increases. This is equivalent to the requirement that hj(w)hj(x) monotonically increases with increasing sin(αx,w) = | cos(θx,w)|.\nSuppose k hash functions are learned to produce k-bit codes. We propose a hash function learning approach with the goal that\n∑k j=1 hj(w)hj(x)/k ∝ | cos(θx,w)|.\nFurther, since ∑k\nj=1 hj(w)hj(x)/k ∈ [−1, 1] and | cos(θx,w)| ∈ [0, 1], we specify the learning goal as\n1\nk\nk ∑\nj=1\nhj(w)hj(x) = 2| cos(θx,w)| − 1, (11)\nwhich makes sense since θx,w = π/2, i.e., αx,w = 0, causes hj(w) 6= hj(x) or hj(Pw) = hj(x) for any j ∈ [1 : k]. As such, the proposed learning method achieves explicit collision for parallel Pw and x.\nEnforcing eq. (11) tends to make hj to yield identical hash codes for nearly parallel inputs whereas bitwise different hash codes for nearly perpendicular inputs. At the query time, given a hyperplane query, we first extract its k-bit hash code using the k learned hash functions applied to the hyperplane normal vector. Then, the database points whose codes have the largest Hamming distances to the query’s code are returned. Thus, the returned points, called near-tohyperplane neighbors, maintain small angles to the hyperplane because such points and the hyperplane normal are nearly perpendicular. In our learning setting, k is typically very short, no more than 30, so we can retrieve the desirable near-to-hyperplane neighbors via constant time hashing over a single hash table.\nNow we desribe how we learn k pairs of projections (uj ,vj) k j=1 so as to construct k bilinear hash functions {hj(z) = sgn(u⊤j zz ⊤ vj)}kj=1. Since the hyperplane normal vectors come up only during the query time, we cannot access w during the training stage. Instead, we sample a few database points for learning projections. Without the loss of generality, we assume that the first m (k < m ≪ n) samples saved in the matrix Xm = [x1, · · · ,xm] are used for learning. To capture the pairwise relationships among them, we define a matrix S ∈ Rm×m as\nSii′ =\n\n\n 1, | cos(θxi,xi′ )| ≥ t1 −1, | cos(θxi,xi′ )| ≤ t2 2| cos(θxi,xi′ )| − 1, otherwise\n(12)\nwhere 0 < t2 < t1 < 1 are two thresholds. For any sample x, its k-bit hash code is written as H(x) = [h1(x), · · · , hk(x)], and ∑k j=1 hj(xi)hj(xi′) = H(xi)H ⊤(xi′). By taking advantage of the learning goal given in eq. (11), we formulate a leastsquares style objective function Q to learn Xm’s binary codes as Q = ∥ ∥\n1 kBB ⊤ − S ∥ ∥ 2 F , where B =\n[H⊤(x1), · · · , H ⊤(xm)] ⊤ represents the code matrix\nof Xm and ‖.‖F denotes the Frobenius norm. The thresholds t1, t2 used in eq. (12) have an important role. When two inputs are prone to being parallel so that | cos(θxi,xi′ )| is large enough (≥ t1), minimizing Q drives each bit of their codes to collide, i.e., H(xi)H\n⊤(xi′)/k = 1; when two inputs tend to be perpendicular so that | cos(θxi,xi′ )| is small enough (≤ t2), minimizing Q tries to make their codes bit-by-bit different, i.e., H(xi)H ⊤(xi′)/k = −1.\nWith simple algebra, one can rewrite Q as\nmin (uj ,vj)kj=1\n∥ ∥ ∥ ∥ ∥ ∥ k ∑\nj=1\nbjb ⊤ j − kS\n∥ ∥ ∥ ∥ ∥ ∥ 2\nF\ns.t. bj =\n\n\nsgn ( u ⊤ j x1x ⊤ 1 vj ) · · · · · · sgn (\nu ⊤ j xmx ⊤ mvj\n)\n\n . (13)\nEvery bit vector bj ∈ {1,−1} m in B = [b1, · · · , bk] determines one hash function hj parameterized by one projection pair (uj ,vj). Note that bj ’s are separable in the summation, which inspires a greedy idea for solving bj ’s sequentially. At a time, it only involves solving one bit vector bj(uj ,vj) given the previously solved vectors b∗1, · · · , b ∗ j−1. Let us define a residue matrix Rj−1 = kS− ∑j−1 j′=1 bj′b ⊤ j′ with R0 = kS. Then, bj can be pursued by minimizing the following cost\n∥ ∥bjb ⊤ j −Rj−1 ∥ ∥\n2 F = ( b ⊤ j bj )2 − 2b⊤j Rj−1bj + tr(R 2 j−1)\n=− 2b⊤j Rj−1bj +m 2 + tr(R2j−1) =− 2b⊤j Rj−1bj + const. (14)\nDiscarding the constant term, the final cost is given as\ng(uj ,vj) = −b ⊤ j Rj−1bj . (15)\nNote that g(uj ,vj) is lower-bounded as eq. (14) is always nonnegative. However, minimizing g is not easy because it is neither convex nor smooth. Below we propose an approximate optimization algorithm.\nSince the hardness of minimizing g lies in the sign function, we replace sgn() in bj with the sigmoidshaped function ϕ(x) = 2/(1 + exp(−x)) − 1 which is sufficiently smooth and well approximates sgn(x) when |x| > 6. Subsequently, we propose to optimize a smooth surrogate g̃ of g defined by\ng̃(uj ,vj) = −b̃ ⊤ j Rj−1b̃j , (16)\nwhere the vector\nb̃j =\n\n\nϕ ( u ⊤ j x1x ⊤ 1 vj ) · · · · · · ϕ (\nu ⊤ j xmx ⊤ mvj\n)\n\n . (17)\nWe derive the gradient of g̃ with respect to [u⊤j ,v ⊤ j ] ⊤\n∇g̃ = −\n[\nXmΣjX ⊤ mvj XmΣjX ⊤ muj\n]\n, (18)\nwhere Σj ∈ R m×m is a diagonal matrix whose diagonal elements come from the m-dimensional vector (Rj−1b̃j) ⊙ (1 − b̃j ⊙ b̃j). Here the symbol ⊙ represents the Hadamard product (i.e., elementwise product), and 1 denotes a constant vector with m 1 entries. Since the original cost g in eq. (15) is lower-bounded, its smooth surrogate g̃ in eq. (16) is lower-bounded as well. We are thus able to minimize g̃ using the regular gradient descent technique. Note that the smooth surrogate g̃ is still nonconvex, so it is unrealistic to look for a global minima of g̃. For fast convergence, we adopt a pair of random projections (u0j ,v 0 j ), which were used in hBj , as a warm start and apply Nesterov’s gradient method (Nesterov, 2003) to accelerate the gradient decent procedure. In most cases we attain a locally optimal (u∗j ,v ∗ j ) at which g̃(u ∗ j ,v ∗ j ) is very close to its lower bound.\nThe final optimized bilinear hash functions are given as { hj(z) = sgn ( (u∗j ) ⊤ zz ⊤ v ∗ j )}k j=1 . Although, unlike the randomized hashing, it is not easy to prove their theoretical properties such as the collision probability, they result in a more accurate point-to-hyperplane search than the randomized functions {\nhBj }\n, as demonstrated by the subsequent experiments.\nWith the learned hash functions H = [h1, · · · , hk] in hand, we can implement the proposed compact hyperplane hashing by simply treating a -1 bit as a 0 bit. In the preprocessing stage, each database point x is converted into a k-bit hash code H(x) and stored in a single hash table with k-bit hash keys as entries. To perform search at the query time, given a hyperplane normal w, we 1) extract its hash key H(w) and perform the bitwise NOT operation to get the key H(w); 2) look up H(w) in the hash table for the nearest entries up to a small Hamming distance, obtaining a short list L whose points are retrieved from the found hash buckets; 3) scan the list L and then return the point x∗ = argminx∈L |w ⊤ x|/‖w‖. In fact, searching within a small Hamming ball centered at the flipped code H(w) is equivalent to searching the codes that have largest possible Hamming distances to the code H(w) in the Hamming space."
    }, {
      "heading" : "5. Experiments",
      "text" : ""
    }, {
      "heading" : "5.1. Datasets",
      "text" : "We conduct experiments on two publicly available datasets including the 20 Newsgroups textual corpus\nand the 1.06 million subset, called Tiny-1M, of the 80 million tiny image collection1. The first dataset is the version 22 of 20 Newsgroups. It is comprised of 18,846 documents from 20 newsgroup categories. Each document is represented by a 26,214-dimensional tf-idf feature vector that is ℓ2 normalized. The Tiny1M dataset is a union of CIFAR-103 and one million tiny images sampled from the entire 80M tiny image set. CIFAR-10 is a labeled subset of the 80M tiny image set, consisting of a total of 60,000 color images from ten object categories each of which has 6000 samples. The other 1M images do not have annotated labels. In our experiments, we treat them as the “other” class besides the ten classes appearing in CIFAR-10, since they were sampled as the farthest 1M images to the mean image of CIFAR-10. Each image in Tiny-1M is represented by a 384-dimensional GIST (Oliva & Torralba, 2001) feature vector.\nFor each dataset, we train a linear SVM in the oneversus-all setting with an initially labeled set which contains randomly selected labeled samples from all classes, and then run active sample selection for 300 iterations. The initially labeled set for 20 Newsgroups includes 5 samples per class, while for Tiny-1M includes 50 samples per class. For both datasets, we try 5 random initializations. After each sample selection is made, we add it to the labeled set and re-train the SVM. We use LIBLINEAR4 for running linear SVMs. All our experiments were run on a workstation with a 2.53 GHz Intel Xeon CPU and 48GB RAM."
    }, {
      "heading" : "5.2. Evaluations and Results",
      "text" : "We carry out SVM active learning using the minimummargin based sample selection criterion for which we apply hyperplane hashing techniques to expedite the selection procedure. To validate the actual performance of the discussed hyperplane hashing methods, we compare them with two baselines: random selection where the next label request is randomly made, and exhaustive selection where the margin criterion is evaluated for all currently unlabeled samples. We compare four hashing methods including two randomized linear hashing schemes AH-Hash and EHHash (Jain et al., 2010), the proposed randomized bilinear hashing scheme BH-Hash, and the proposed learning-based bilinear hashing scheme that we call LBH-Hash. Notice that we use the same random projections for AH-Hash, BH-Hash, and the initialization of LBH-Hash to shed light on the effect of bi-\n1http://horatio.cs.nyu.edu/mit/tiny/data/index.html 2http://www.zjucadcg.cn/dengcai/Data/TextData.html 3http://www.cs.toronto.edu/~kriz/cifar.html 4http://www.csie.ntu.edu.tw/~cjlin/liblinear/\nlinear hashing (XNOR two bits). We also follow the dimension-sampling trick in (Jain et al., 2010) to accelerate EH-Hash’s computation. In order to train our proposed LBH-Hash, we randomly sample 500 and 5000 database points from 20 Newsgroups and Tiny-1M, respectively. The two thresholds t1, t2 used for implementing explicit collision are acquired according to the following rule: compute the absolute cosine matrix C between the m sampled points {xi} m i=1 and all data, average the top 5% values among Ci. across xi’s as t1, and average the bottom 5% values as t2.\nSo as to make the hashing methods work under a compact hashing mode for fair comparison, we employ a single hash table with short code length. Concretely, we use 16 hash bits for EH-Hash, BH-Hash, and LBHHash, and 32 bits for AH-Hash because of its dual-bit hashing spirit on 20 Newsgroups. When applying each hashing method in an AL iteration, we perform a hash lookup within Hamming radius 3 in the corresponding hash table and then scan the points in the found hash buckets, resulting in the neighbor near to the current SVM’s decision hyperplane. Likewise, we use 20 bits for EH-Hash, BH-Hash, and LBH-Hash, and 40 bits for AH-Hash on Tiny-1M; the Hamming radius for search is set to 4. It is possible that a method finds all empty hash buckets in the Hamming ball. In that case, we apply random selection as a supplement.\nWe evaluate the performance of four hashing methods in terms of: 1) the average precision (AP) which is computed by ranking the current unlabeled sample set with the current SVM classifier at each AL iteration; 2) the minimum margin (the smallest point-tohyperplane distance |w⊤x|/‖w‖) of the neighbor returned by hyperplane hashing at each AL iteration; 3) the number of queries among a total of 300 for every class that receive nonempty hash lookups. The former two results are averaged over all classes and 5 runs, and the latter is averaged over 5 runs. We report such results in Fig. 3 and Fig. 4, which clearly show that 1) LBH-Hash achieves the highest mean AP (MAP) among all compared hashing methods, and even outperforms exhaustive selection at some AL iterations; 2) LBH-Hash accomplishes the minimum margin closest to that by exhaustive selection; 3) LBH-Hash enjoys almost all nonempty hash lookups (AH-Hash gets almost all empty lookups). The superior performance of LBH-Hash corroborates that the proposed bilinear hash function and the associated learning technique are successful in utilizing the underlying data information to yield compact yet discriminative codes.\nFinally, we report the computational efficiency in Tables 1-3 of the supplementary material, which indicate\nthat LBH-Hash takes comparable preprocessing time as EH-Hash and achieves fast search speed."
    }, {
      "heading" : "6. Conclusions",
      "text" : "We have addressed hyperplane hashing by proposing a specialized bilinear hash function which allows efficient search of points near a hyperplane query. Even when using random projections, the proposed hash function enjoys higher probability of collision than the existing randomized methods. By learning the projections further, we achieve compact yet discriminative codes that permit substantial savings in both storage and time needed during search. Large-scale active learning experiments on two datasets have demonstrated the superior performance of our compact hyperplane hashing approach.\nAcknowledgement: This work is supported in part by a\nFacebook fellowship to the first author."
    }, {
      "heading" : "Basri, R., Hassner, T., and Zelnik-Manor, L. Approximate",
      "text" : "nearest subspace search. TPAMI, 33(2):266–278, 2011.\nCharikar, M. Similarity estimation techniques from rounding algorithms. In Proc. STOC, 2002."
    }, {
      "heading" : "Datar, M., Immorlica, N., Indyk, P., and Mirrokni, V. S.",
      "text" : "Locality-sensitive hashing scheme based on p-stable distributions. In Proc. SoCG, 2004."
    }, {
      "heading" : "Gionis, A., Indyk, P., and Motwani, R. Similarity search",
      "text" : "in high dimensions via hashing. In Proc. VLDB, 1999.\nGoemans, M. X. and Williamson, D. P. Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming. Journal of the ACM, 42(6):1115–1145, 1995."
    }, {
      "heading" : "Jain, P., Vijayanarasimhan, S., and Grauman, K. Hashing",
      "text" : "hyperplane queries to near points with applications to large-scale active learning. In NIPS 23, 2010.\nLi, P. and König, A. C. b-bit minwise hashing. In Proc. WWW, 2010."
    }, {
      "heading" : "Liu, W., Wang, J., Kumar, S., and Chang, S.-F. Hashing",
      "text" : "with graphs. In Proc. ICML, 2011."
    }, {
      "heading" : "Liu, W., Wang, J., Ji, R., Jiang, Y.-G., and Chang, S.-F.",
      "text" : "Supervised hashing with kernels. In Proc. CVPR, 2012.\nNesterov, Y. Introductory Lectures on Convex Optimization: A Basic Course. Kluwer Academic Publishers, 2003.\nOliva, A. and Torralba, A. Modeling the shape of the scene: a holistic representation of the spatial envelope. IJCV, 42(3):145–175, 2001.\nTong, S. and Koller, D. Support vector machine active learning with applications to text classification. JMLR, 2:45–66, 2001."
    }, {
      "heading" : "Wang, J., Kumar, S., and Chang, S.-F. Semi-supervised",
      "text" : "hashing for large scale search. TPAMI, 2012."
    } ],
    "references" : [ {
      "title" : "Similarity estimation techniques from rounding algorithms",
      "author" : [ "M. Charikar" ],
      "venue" : "In Proc. STOC,",
      "citeRegEx" : "Charikar,? \\Q2002\\E",
      "shortCiteRegEx" : "Charikar",
      "year" : 2002
    }, {
      "title" : "Locality-sensitive hashing scheme based on p-stable distributions",
      "author" : [ "M. Datar", "N. Immorlica", "P. Indyk", "V.S. Mirrokni" ],
      "venue" : "In Proc. SoCG,",
      "citeRegEx" : "Datar et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Datar et al\\.",
      "year" : 2004
    }, {
      "title" : "Similarity search in high dimensions via hashing",
      "author" : [ "A. Gionis", "P. Indyk", "R. Motwani" ],
      "venue" : "In Proc. VLDB,",
      "citeRegEx" : "Gionis et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Gionis et al\\.",
      "year" : 1999
    }, {
      "title" : "Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming",
      "author" : [ "M.X. Goemans", "D.P. Williamson" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "Goemans and Williamson,? \\Q1995\\E",
      "shortCiteRegEx" : "Goemans and Williamson",
      "year" : 1995
    }, {
      "title" : "Hashing hyperplane queries to near points with applications to large-scale active learning",
      "author" : [ "P. Jain", "S. Vijayanarasimhan", "K. Grauman" ],
      "venue" : "In NIPS",
      "citeRegEx" : "Jain et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Jain et al\\.",
      "year" : 2010
    }, {
      "title" : "b-bit minwise hashing",
      "author" : [ "P. Li", "A.C. König" ],
      "venue" : "In Proc. WWW,",
      "citeRegEx" : "Li and König,? \\Q2010\\E",
      "shortCiteRegEx" : "Li and König",
      "year" : 2010
    }, {
      "title" : "Hashing with graphs",
      "author" : [ "W. Liu", "J. Wang", "S. Kumar", "Chang", "S.-F" ],
      "venue" : "In Proc. ICML,",
      "citeRegEx" : "Liu et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Liu et al\\.",
      "year" : 2011
    }, {
      "title" : "Supervised hashing with kernels",
      "author" : [ "W. Liu", "J. Wang", "R. Ji", "Jiang", "Y.-G", "Chang", "S.-F" ],
      "venue" : "In Proc. CVPR,",
      "citeRegEx" : "Liu et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Liu et al\\.",
      "year" : 2012
    }, {
      "title" : "Introductory Lectures on Convex Optimization: A Basic Course",
      "author" : [ "Y. Nesterov" ],
      "venue" : "Kluwer Academic Publishers,",
      "citeRegEx" : "Nesterov,? \\Q2003\\E",
      "shortCiteRegEx" : "Nesterov",
      "year" : 2003
    }, {
      "title" : "Modeling the shape of the scene: a holistic representation of the spatial envelope",
      "author" : [ "A. Oliva", "A. Torralba" ],
      "venue" : null,
      "citeRegEx" : "Oliva and Torralba,? \\Q2001\\E",
      "shortCiteRegEx" : "Oliva and Torralba",
      "year" : 2001
    }, {
      "title" : "Support vector machine active learning with applications to text classification",
      "author" : [ "S. Tong", "D. Koller" ],
      "venue" : "JMLR, 2:45–66,",
      "citeRegEx" : "Tong and Koller,? \\Q2001\\E",
      "shortCiteRegEx" : "Tong and Koller",
      "year" : 2001
    }, {
      "title" : "Semi-supervised hashing for large scale search",
      "author" : [ "J. Wang", "S. Kumar", "Chang", "S.-F" ],
      "venue" : null,
      "citeRegEx" : "Wang et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "rithms from the Locality-Sensitive Hashing (LSH) family (Gionis et al., 1999)(Charikar, 2002)(Datar et al.",
      "startOffset" : 56,
      "endOffset" : 77
    }, {
      "referenceID" : 0,
      "context" : ", 1999)(Charikar, 2002)(Datar et al.",
      "startOffset" : 7,
      "endOffset" : 23
    }, {
      "referenceID" : 1,
      "context" : ", 1999)(Charikar, 2002)(Datar et al., 2004) which use random projections to convert input data into binary hash codes.",
      "startOffset" : 23,
      "endOffset" : 43
    }, {
      "referenceID" : 6,
      "context" : "The state-of-thearts include unsupervised hashing (Liu et al., 2011), semi-supervised hashing (Wang et al.",
      "startOffset" : 50,
      "endOffset" : 68
    }, {
      "referenceID" : 11,
      "context" : ", 2011), semi-supervised hashing (Wang et al., 2012), and supervised hashing (Liu et al.",
      "startOffset" : 33,
      "endOffset" : 52
    }, {
      "referenceID" : 7,
      "context" : ", 2012), and supervised hashing (Liu et al., 2012).",
      "startOffset" : 32,
      "endOffset" : 50
    }, {
      "referenceID" : 4,
      "context" : "In the literature, not much work has been done on the point-to-hyperplane problem except (Jain et al., 2010) which demonstrated the vital importance of such a problem in making SVM-based active learning feasible on massive data pools.",
      "startOffset" : 89,
      "endOffset" : 108
    }, {
      "referenceID" : 4,
      "context" : "Recently, hyperplane hashing schemes were proposed in (Jain et al., 2010) to cope with point-to-hyperplane search.",
      "startOffset" : 54,
      "endOffset" : 73
    }, {
      "referenceID" : 4,
      "context" : "In (Jain et al., 2010), two families of randomized hash functions were proved locality-sensitive to the angle between a database point and a hyperplane query; however, long hash bits and plentiful hash tables are required to cater for the theoretical guarantees.",
      "startOffset" : 3,
      "endOffset" : 22
    }, {
      "referenceID" : 4,
      "context" : "Actually, 300 bits and 500 tables were adopted in (Jain et al., 2010) to achieve reasonable performance, which incurs a heavy burden on both computation and storage.",
      "startOffset" : 50,
      "endOffset" : 69
    }, {
      "referenceID" : 4,
      "context" : "To derive provable hyperplane hashing like (Jain et al., 2010), this paper focuses on a slightly modified “distance” |w ⊤ x| ‖w‖‖x‖ which is the sine of the point-to-hyperplane angle",
      "startOffset" : 43,
      "endOffset" : 62
    }, {
      "referenceID" : 4,
      "context" : "(Jain et al., 2010) devised two distinct families of randomized hash functions to attack the hyperplane hashing problem.",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 2,
      "context" : "We present the following theorem by adapting Theorem 1 in (Gionis et al., 1999) and Theorem 0.",
      "startOffset" : 58,
      "endOffset" : 79
    }, {
      "referenceID" : 4,
      "context" : "1 in the supplementary material of (Jain et al., 2010).",
      "startOffset" : 35,
      "endOffset" : 54
    }, {
      "referenceID" : 8,
      "context" : "For fast convergence, we adopt a pair of random projections (uj ,v 0 j ), which were used in hj , as a warm start and apply Nesterov’s gradient method (Nesterov, 2003) to accelerate the gradient decent procedure.",
      "startOffset" : 151,
      "endOffset" : 167
    }, {
      "referenceID" : 4,
      "context" : "We compare four hashing methods including two randomized linear hashing schemes AH-Hash and EHHash (Jain et al., 2010), the proposed randomized bilinear hashing scheme BH-Hash, and the proposed learning-based bilinear hashing scheme that we call LBH-Hash.",
      "startOffset" : 99,
      "endOffset" : 118
    }, {
      "referenceID" : 4,
      "context" : "We also follow the dimension-sampling trick in (Jain et al., 2010) to accelerate EH-Hash’s computation.",
      "startOffset" : 47,
      "endOffset" : 66
    } ],
    "year" : 2012,
    "abstractText" : "Hyperplane hashing aims at rapidly searching nearest points to a hyperplane, and has shown practical impact in scaling up active learning with SVMs. Unfortunately, the existing randomized methods need long hash codes to achieve reasonable search accuracy and thus suffer from reduced search speed and large memory overhead. To this end, this paper proposes a novel hyperplane hashing technique which yields compact hash codes. The key idea is the bilinear form of the proposed hash functions, which leads to higher collision probability than the existing hyperplane hash functions when using random projections. To further increase the performance, we propose a learning based framework in which the bilinear functions are directly learned from the data. This results in short yet discriminative codes, and also boosts the search performance over the random projection based solutions. Large-scale active learning experiments carried out on two datasets with up to one million samples demonstrate the overall superiority of the proposed approach.",
    "creator" : "LaTeX with hyperref package"
  }
}