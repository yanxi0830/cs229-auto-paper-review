{
  "name" : "1605.07723.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Data Programming: Creating Large Training Sets, Quickly",
    "authors" : [ "Alexander Ratner", "Christopher De Sa", "Sen Wu", "Daniel Selsam", "Christopher Ré" ],
    "emails" : [ "ajratner@stanford.edu", "cdesa@stanford.edu", "senwu@stanford.edu", "dselsam@stanford.edu", "chrismre@stanford.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Many of the major machine learning breakthroughs of the last decade have been catalyzed by the release of a new labeled training dataset.1 Supervised learning approaches that use such datasets have increasingly become key building blocks of applications throughout science and industry. This trend has also been fueled by the recent empirical success of automated feature generation approaches, notably deep learning methods such as long short term memory (LSTM) networks [12], which ameliorate the burden of feature engineering given large enough labeled training sets. For many real-world applications, however, large hand-labeled training sets do not exist, and are prohibitively expensive to create due to requirements that labelers be experts in the application domain. Furthermore, applications’ needs often change, necessitating new or modified training sets.\nTo help reduce the cost of training set creation, we propose data programming, a paradigm for the programmatic creation of training datasets. Data programming extends the idea of distant supervision, in which an external knowledge base is mapped onto an input dataset to generate training examples [20]. In data programming, users provide a set of heuristic labeling functions, which are user-defined programs that each provide a label for some subset of the data, and collectively generate a large but noisy training set. These labeling functions can be more general than distant supervision mappings—they can use external knowledge bases (as in distant supervision), model an individual annotator’s labels (as in crowdsourcing), or leverage a combination of domain-specific patterns and dictionaries—and thus may have widely varying error rates, may overlap, and may conflict on certain data points. To address this, we model the labeling functions as a generative process, which lets us automatically denoise the resulting training set by learning the accuracies of the labeling functions along with their correlation structure. In turn, we use this model of the training set to optimize a stochastic version of the loss function of the discriminative model that we desire to train. We show that, given certain conditions on the labeling functions, our method achieves the same asymptotic scaling as supervised learning methods,\n1 http://www.spacemachine.net/views/2016/3/datasets-over-algorithms\nar X\niv :1\n60 5.\n07 72\n3v 1\n[ st\nat .M\nL ]\n2 5\nM ay\nbut that our scaling depends on the amount of unlabeled data—using only a fixed number of labeling functions, which is small relative to the training set size.\nData programming is in part motivated by the challenges that users faced when applying prior programmatic supervision approaches, and is intended to be a new software engineering paradigm for the creation and management of training sets. For example, consider the scenario when two labeling functions of differing quality and scope overlap and possibly conflict on certain training examples; in prior approaches the user would have to decide which one to use, or how to somehow integrate the signal from both. In data programming, we accomplish this automatically by learning a model of the training set that includes both labeling functions. Additionally, users are often aware of, or able to induce, dependencies between their labeling functions. In data programming, users can provide a dependency graph to indicate, for example, that two labeling functions are similar, or that one “fixes” or “reinforces” another. We describe cases in which we can learn the strength of these dependencies, and for which our generalization is again asymptotically identical to the supervised case.\nOne further motivation for our method is driven by the observation that users often struggle with selecting features for their models, which is a traditional development bottleneck given fixed-size training sets. However, initial feedback from users suggests that writing labeling functions in the framework of data programming may be easier. While the impact of a feature on end performance is dependent on the training set and on statistical characteristics of the model, a labeling function has a simple and intuitive optimality criterion: that it labels data correctly. Motivated by this, we explore whether we can flip the traditional machine learning development process on its head, having users instead focus on generating training sets large enough to support automatically-generated features.\nSummary of Contributions and Outline Our first contribution is the data programming framework, in which users can implicitly describe a rich generative model for a training set in a more flexible and general way than in previous approaches. In Section 3, we first explore a simple model in which labeling functions are conditionally independent. We show here that under certain conditions, the sample complexity is nearly the same as in the labeled case. In Section 4, we extend our results to more sophisticated data programming models, generalizing related results in crowdsourcing [15]. In Section 5, we validate our approach experimentally on large real-world text relation extraction tasks in genomics, pharmacogenomics and news domains, where we show an average 2.34 point F1 score improvement over a baseline programmatic supervision approach—including what would have been a new competition-winning score for the 2014 TAC-KBP Slot Filling competition. Using LSTM-generated features, we would have placed second in this competition, achieving a 5.98 point F1 score gain over a state-of-the-art LSTM baseline trained on hand-labeled data [30]. Additionally, we describe promising feedback from a usability study with a group of bioinformatics users."
    }, {
      "heading" : "2 Related Work",
      "text" : "Our work builds on many previous approaches in machine learning. Distant supervision is one preceding paradigm for programmatically creating training sets. The canonical example is relation extraction from text, wherein a knowledge base of known relations is heuristically mapped to label a set of mentions in an input corpus as ground truth examples [7, 20]. Basic extensions group these mapped examples by the particular textual pattern w that they occur with, and cast the problem as a multiple instance learning one [13, 23]. Other extensions actually model the accuracy of this pattern w using a discriminative feature-based model [25], or generative models such as hierarchical topic models [1, 24, 29]. Like our approach, these latter methods model a generative process of training set creation, however in a proscribed way that is not based on user input as in our approach. There is also a wealth of examples where additional heuristic patterns used to label training data are collected from unlabeled data [6] or directly from users [19, 27], in a similar manner to our approach, but without a framework to deal with the fact that said labels are explicitly noisy.\nCrowdsourcing is widely used for various machine learning tasks [11, 16]. Of particular relevance to our problem setting is the theoretical question of how to model the accuracy of various experts without ground truth available, classically raised in the context of crowdsourcing [9]. More recent results provide formal guarantees even in the absence of labeled data using various approaches [3, 8, 14, 15, 22, 31]. Our model can capture the model described in crowdsourcing, and can be equivalent in the independent case (Sec. 3). However, in addition to generalizing beyond getting inputs solely from human annotators, we also model user-supplied dependencies between the “labelers” in our model, which is not natural within the context of crowdsourcing. Additionally, while crowdsourcing results focus on\nthe regime of a large number of labelers each labeling a small subset of the data, we consider a small set of labeling functions each labeling a large portion of the dataset.\nCo-training is a classic procedure for effectively utilizing both a small amount of labeled data and a large amount of unlabeled data by selecting two conditionally independent views of the data [4]. In addition to not needing a set of labeled data, and allowing for more than two views (labeling functions in our case), our approach allows explicit modeling of dependencies between views, for example allowing observed issues with dependencies between views to be explicitly modeled [17].\nBoosting is a well known procedure for combining the output of many “weak” classifiers to create a strong classifier in a supervised setting [26]. Recently, boosting-like methods have been proposed which leverage unlabeled data in addition to labeled data, which is also used to set constraints on the accuracies of the individual classifiers being ensembled [2]. This is similar in spirit to our approach, except that labeled data is not explicitly necessary in ours, and richer dependency structures between our “heuristic” classifiers (labeling functions) are supported.\nThe general case of learning with noisy labels is treated both in classical [18] and more recent contexts [21]. It has also been studied specifically in the context of label-noise robust logistic regression [5]. We consider the more general scenario where multiple noisy labeling functions can conflict and have dependencies."
    }, {
      "heading" : "3 The Data Programming Paradigm",
      "text" : "In many applications, we would like to use machine learning, but we face the following challenges: (i) hand-labeled training data is not available, and is prohibitively expensive to obtain in sufficient quantities as it requires expensive domain experts; (ii) related external knowledge bases are either unavailable or insufficiently specific, precluding a traditional distant supervision or co-training approach; (iii) application specifications are in flux, changing the model we ultimately wish to learn.\nIn such a setting, we would like a simple, scalable and adaptable approach for supervising a model applicable to our problem. More specifically, we would ideally like our approach to achieve expected loss with high probability, given O(1) inputs of some sort from a domain-expert user, rather than the traditional Õ( −2) hand-labeled training examples required by most supervised methods (where Õ notation hides logarithmic factors). To this end, we propose data programming, a paradigm for the programmatic creation of training sets, which enables domain-experts to more rapidly train machine learning systems and has the potential for this type of scaling of expected loss. In data programming, rather than manually labeling each example, users instead describe the processes by which these points could be labeled by providing a set of heuristic rules called labeling functions.\nIn the remainder of this paper, we focus on a binary classification task in which we have a distribution π over object and class pairs (x, y) ∈ X × {−1, 1}, and we are concerned with minimizing the logistic loss under a linear model given some features,\nl(w) = E(x,y)∼π [ log(1 + exp(−wT f (x)y)) ] ,\nwhere without loss of generality, we assume that ‖ f (x)‖ ≤ 1. Then, a labeling function λi : X 7→ {−1, 0, 1} is a user-defined function that encodes some domain heuristic, which provides a (non-zero) label for some subset of the objects. As part of a data programming specification, a user provides some m labeling functions, which we denote in vectorized form as λ : X 7→ {−1, 0, 1}m.\nExample 3.1. To gain intuition about labeling functions, we describe a simple text relation extraction example. In Figure 1, we consider the task of classifying co-occurring gene and disease mentions as either expressing a causal relation or not. For example, given the sentence “Gene A causes disease B”, the object x = (A, B) has true class y = 1. To construct a training set, the user writes three labeling functions (Figure 1a). In λ1, an external structured knowledge base is used to label a few objects with relatively high accuracy, and is equivalent to a traditional distant supervision rule (see Sec. 2). λ2 uses a purely heuristic approach to label a much larger number of examples with lower accuracy. Finally, λ3 is a “hybrid” labeling function, which leverages both an external knowledge base and a heuristic filter.\nA labeling function need not have perfect accuracy or recall; rather, it represents a pattern that the user wishes to impart to their model and that is easier to encode as a labeling function than as a set of hand-labeled examples. As illustrated in Ex. 3.1, labeling function can be based on external knowledge bases, libraries or ontologies, could be purely a heuristic pattern, or some hybrid of these types; we see evidence for the existence of such diversity in our experiments (Section 5). The use of labeling functions is also strictly more general than manual annotations, as a manual annotation can always be directly encoded by a labeling function. Importantly, labeling functions can overlap, conflict, and even have dependencies which users can provide as part of the data programming specification (see Section 4); our approach provides a simple framework for these inputs.\nIndependent Labeling Functions We first describe a model in which the labeling functions label independently, given the true label class. Under this model, each labeling function λi has some probability βi of labeling an object and then some probability αi of labeling the object correctly; for simplicity we also assume here that each class has probability 0.5. This model has distribution\nµα,β(Λ,Y) = 1 2 m∏ i=1 ( βiαi1{Λi=Y} + βi(1 − αi)1{Λi=−Y} + (1 − βi)1{Λi=0} ) , (1)\nwhere Λ ∈ {−1, 0, 1}m contains the labels output by the labeling functions, and Y ∈ {−1, 1} is the predicted class. If we allow the parameters α ∈ Rm and β ∈ Rm to vary, (1) specifies a family of generative models. In order to expose the scaling of the expected loss as the size of the unlabeled dataset changes, we will assume here that 0.3 ≤ βi ≤ 0.5 and 0.8 ≤ αi ≤ 0.9. We note that while these arbitrary constraints can be changed, they are roughly consistent with our applied experience, where users tend to write high-accuracy and high-coverage labeling functions.\nOur first goal will be to learn which parameters (α, β) are most consistent with our observations—our unlabeled training set—using maximum likelihood estimation. To do this for a particular training set S ⊂ X, we will solve the problem\n(α̂, β̂) = arg max α,β ∑ x∈S log P(Λ,Y)∼µα,β (Λ = λ(x)) . (2)\nIn other words, we are maximizing the probability that the observed labels produced on our training examples occur under the generative model in (1). In our experiments, we use stochastic gradient descent to solve this problem; since this is a standard technique, we defer its analysis to the appendix.\nNoise-Aware Empirical Loss Given that our parameter learning phase has successfully found some α̂ and β̂ that accurately describe the training set, we can now proceed to estimate the parameter w which minimizes the expected risk of a linear model over our feature mapping f , given α̂, β̂. To do so, we define the noise-aware empirical risk Lα̂,β̂ with regularization parameter ρ, and compute the noise-aware empirical risk minimizer\nŵ = arg min w Lα̂,β̂(w; S ) = arg minw 1 |S | ∑ x∈S E(Λ,Y)∼µα̂,β̂ [ log ( 1 + e−w T f (x)Y )∣∣∣∣Λ = λ(x)] + ρ ‖w‖2 (3)\nThis is a logistic regression problem, so it can be solved using stochastic gradient descent as well. We can in fact prove that stochastic gradient descent running on (2) and (3) is guaranteed to produce accurate estimates, under conditions which we describe now. First, the problem distribution π needs to be accurately modeled by some distribution µ in the family that we are trying to learn. That is, for some α∗ and β∗,\n∀Λ ∈ {−1, 0, 1}m,Y ∈ {−1, 1}, P(x,y)∼π∗ (λ(x) = Λ, y = Y) = µα∗,β∗ (Λ,Y). (4)\nSecond, given an example (x, y) ∼ π∗, the class label y must be independent of the features f (x) given the labels λ(x). That is, (x, y) ∼ π∗ ⇒ y ⊥ f (x) | λ(x). (5) This assumption encodes the idea that the labeling functions, while they may be arbitrarily dependent on the features, provide sufficient information to accurately identify the class. Third, we assume that the algorithm used to solve (3) has bounded generalization risk such that for some parameter χ,\nEŵ [ ES [ Lα̂,β̂(ŵ; T ) ] −min\nw ES\n[ Lα̂,β̂(w; S ) ]] ≤ χ. (6)\nUnder these conditions, we make the following statement about the accuracy of our estimates, which is a simplified version of a theorem that is detailed in the appendix.\nTheorem 1. Suppose that we run data programming, solving the problems in (2) and (3) using stochastic gradient descent to produce (α̂, β̂) and ŵ. Suppose further that our setup satisfies the conditions (4), (5), and (6), and suppose that m ≥ 2000. Then for any > 0, if the number of labeling functions m and the size of the input dataset S are large enough that\n|S | ≥ 356 2 log ( m 3 ) then our expected parameter error and generalization risk can be bounded by\nE [ ‖α̂ − α∗‖2 ] ≤ m 2 E [∥∥∥β̂ − β∗∥∥∥2] ≤ m 2 E [l(ŵ) −min w l(w) ] ≤ χ + 27ρ .\nWe select m ≥ 2000 to simplify the statement of the theorem and give the reader a feel for how scales with respect to |S |. The full theorem with scaling in each parameter (and for arbitrary m) is presented in the appendix.\nThis result establishes that to achieve both expected loss and parameter estimate error , it suffices to have only m = O(1) labeling functions and |S | = Õ( −2) training examples, which is the same asymptotic scaling exhibited by methods that use labeled data. This means that data programming achieves the same learning rate as methods that use labeled data, while requiring asymptotically less work from its users, who need to specify O(1) labeling functions rather than manually label Õ( −2) examples. In contrast, in the crowdsourcing setting [15], the number of workers m tends to infinity while here it is constant while the dataset grows. These results provide some explanation of why our experimental results suggest that a small number of rules with a large unlabeled training set can be effective at even complex natural language processing tasks."
    }, {
      "heading" : "4 Handling Dependencies",
      "text" : "In our experience with data programming, we have found that users often write labeling functions that have clear dependencies among them. As more labeling functions are added as the system is developed, an implicit dependency structure arises naturally amongst the labeling functions: modeling these dependencies can in some cases improve accuracy. We describe a method by which the user can specify this dependency knowledge as a dependency graph, and show how the system can use it to produce better parameter estimates.\nLabel Function Dependency Graph To support the injection of dependency information into the model, we augment the data programming specification with a label function dependency graph, G ⊂ D × {1, . . . ,m} × {1, . . . ,m}, which is an undirected graph over the labeling functions, each of the edges of which is associated with a dependency type from a class of dependenciesD appropriate to the domain. From our experience with practitioners, we identified four commonly-occurring types of dependencies as illustrative examples: similar, fixing, reinforcing, and exclusive (see Figure 2).\nFor example, suppose that we have two functions λ1 and λ2, and λ2 typically labels only when (i) λ1 also labels, (ii) λ1 and λ2 disagree in their labeling, and (iii) λ2 is actually correct. We call this a fixing dependency, since λ2 fixes mistakes made by λ1. If λ1 and λ2 were to typically agree rather than disagree, this would be a reinforcing dependency, since λ2 reinforces the truth proclaimed by λ1.\nModeling Dependencies The presence of dependency information means that we can no longer model our labels using the simple Bayesian network in (1). Instead, we model our distribution as a factor graph. This standard technique lets us describe the family of generative distributions in terms of a known factor function h : {−1, 0, 1}m×{−1, 1} 7→ {−1, 0, 1}M (in which each entry hi represents a factor), and an unknown parameter θ ∈ RM as\nµθ(Λ,Y) = Z−1θ exp(θ T h(Λ,Y)),\nwhere Zθ is the partition function which ensures that µ is a distribution. Next, we will describe how we define h using information from the dependency graph.\nTo construct h, we will start with some base factors, which we inherit from (1), and then augment them with additional factors representing dependencies. For all i ∈ {1, . . . ,m}, we let\nh0(Λ,Y) = Y, hi(Λ,Y) = ΛiY, hm+i(Λ,Y) = Λi, h2m+i(Λ,Y) = Λ2i Y, h3m+i(Λ,Y) = Λ 2 i .\nThese factors alone are sufficient to describe any distribution for which the labels are mutually independent, given the class: this includes the independent family in (1).\nWe now proceed by adding additional factors to h, which model the dependencies encoded in G. For each dependency edge (d, i, j), we add one or more factors to h as follows. For a near-duplicate dependency on (i, j), we add a single factor hι(Λ,Y) = 1{Λi = Λ j}, which increases our prior probability that the labels will agree. For a fixing dependency, we add two factors, hι(Λ,Y) = −1{Λi = 0 ∧Λ j , 0} and hι+1(Λ,Y) = 1{Λi = −Y ∧Λ j = Y}, which encode the idea that λ j labels only when λi does, and that λ j fixes errors made by λi. The factors for a reinforcing dependency are the same, except that hι+1(Λ,Y) = 1{Λi = Y ∧Λ j = Y}. Finally, for an exclusive dependency, we have a single factor hι(Λ,Y) = −1{Λi , 0 ∧ Λ j , 0}.\nLearning with Dependencies We can again solve a maximum likelihood problem like (2) to learn the parameter θ̂. Using the results, we can continue on to find the noise-aware empirical loss minimizer by solving the problem in (3). In order to solve these problems in the dependent case, we typically invoke stochastic gradient descent, using Gibbs sampling to sample from the distributions used in the gradient update. Under conditions similar to those in Section 3, we can again provide a bound the accuracy of these results. We define these conditions now. First, there must be some set Θ ⊂ RM that we know our parameter lies in. This is analogous to the assumptions on αi and βi we made in Section 3, and we can state the following analog of (4):\n∃θ∗ ∈ Θ s.t. ∀(Λ,Y) ∈ {−1, 0, 1}m × {−1, 1}, P(x,y)∼π∗ (λ(x) = Λ, y = Y) = µθ∗ (Λ,Y). (7)\nSecond, for any θ ∈ Θ, it must be possible to accurately learn θ from full (i.e. labeled) samples of µθ. More specifically, there exists an unbiased estimator θ̂(T ) that is a function of some dataset T of independent samples from µθ such that, for some c > 0 and for all θ ∈ Θ,\nCov ( θ̂(T ) ) (2c |T |)−1I. (8)\nThird, for any two feasible models θ1 and θ2 ∈ Θ, E(Λ1,Y1)∼µθ1 [ Var(Λ2,Y2)∼µθ2 (Y2|Λ1 = Λ2) ] ≤ cM−1. (9)\nThat is, we’ll usually be reasonably sure in our guess for the value of Y , even if we guess using distribution µθ2 while the the labeling functions were actually sampled from (the possibly totally different) µθ1 . We can now prove the following result about the accuracy of our estimates.\nTheorem 2. Suppose that we run stochastic gradient descent to produce θ̂ and ŵ, and that our setup satisfies the conditions (5)-(9). Then for any > 0, if the input dataset S is large enough that\n|S | ≥ 2 c2 2\nlog ( 2 ‖θ0 − θ∗‖2 ) ,\nthen our expected parameter error and generalization risk can be bounded by E [∥∥∥θ̂ − θ∗∥∥∥2] ≤ M 2 E [l(ŵ) −min\nw l(w)\n] ≤ χ + c\n2ρ .\nAs in the independent case, this shows that we need only |S | = Õ( −2) unlabeled training examples to achieve error O( ), which is the same asymptotic scaling as supervised learning methods. This suggests that while we pay a computational penalty for richer dependency structures, we are no less statistically efficient. In the appendix, we provide more details, including an explicit description of the algorithm and the step size used to achieve this result."
    }, {
      "heading" : "5 Experiments",
      "text" : "We seek to experimentally validate three claims about our approach. Our first claim is that data programming can be an effective paradigm for building high quality machine learning systems, and we test this across three real-world text relation extraction applications. Our second claim is that data programming can be used successfully in conjunction with automatic feature generation methods, such as LSTM models. Finally, our third claim is that data programming is an intuitive and productive framework for application domain-expert users, and we report on our initial experiences with a group of bioinformatics researchers.\nRelation Mention Extraction Tasks In the relation mention extraction task, our objects are relation mention candidates x = (e1, e2), which are pairs of entity mentions e1, e2 in unstructured text, and our goal is to learn a model that classifies each candidate as either a true textual assertion of the relation R(e1, e2) or not. We examine a news application from the 2014 TAC-KBP Slot Filling challenge2, where we extract relations between real-world entities from articles; a clinical genomics application, where we extract causal relations between genetic mutations and phenotypes from the scientific literature; and a pharmacogenomics application where we extract interactions between genes, also from the scientific literature.\nFor each application, we or our collaborators originally built a system where a ground truth training set was programmatically generated by ordering the labeling functions as a sequence of if-then-return statements, and for each candidate, taking the first label emitted by this script as the training label. We refer to this as the if-then-return (ITR) approach, and note that it often required significant domain expert development time to tune (weeks or more). For this set of experiments, we then used the same labeling function sets within the framework of data programming. In Table 1, we see that we achieve consistent improvements: on average by 2.34 points in F1 score, including what would have been a winning score on the 2014 TAC-KBP challenge [28].\nWe observed these performance gains across applications with very different labeling function sets. We describe the labeling function summary statistics—coverage is the percentage of objects that had at least one label, overlap is the percentage of objects with more than one label, and conflict is the percentage of objects with conflicting labels—and see in Table 2 that even in scenarios where m is small, and conflict and overlap is relatively less common, we still realize performance gains.\n2http://www.nist.gov/tac/2014/KBP/\nAdditionally, on a disease mention extraction task (see Usability Study), which was written from scratch within the data programming paradigm, we allowed developers to supply dependencies of the basic types outlined in Sec. 4, and report a 2.3 point F1 score boost from incorporating this dependency information, which we believe illustrates the potential of further pursuing this approach of providing dependency structure.\nAutomatically-generated Features We additionally compare both hand-tuned and automatically-generated features, where the latter are learned via an LSTM recurrent neural network (RNN) [12]. Conventional wisdom states that deep learning methods such as RNNs are prone to overfitting, thus rendering them ineffective over distantly-supervised training sets. In our experiments, however, we find that training them with the data programming may be effective, reporting a 9.79 point boost to precision and a 3.12 point F1 score improvement on the benchmark 2014 TAC-KBP (News) relation extraction task, over the baseline if-then-return approach. Additionally for comparison, our approach is a 5.98 point F1 score improvement over a state-of-the-art LSTM approach applied to the TAC-KBP task which was trained on hand-labeled data [30].\nUsability Study One of our hopes is that a non-ML-expert user will be more productive iterating on labeling functions than on features. To test this, we arranged a hackathon involving a handful of bioinformatics researchers. Their goal was to build a disease tagging system, a common and important challenge in the bioinformatics domain [10]. However, the hackathon did not have access to a labeled training set, and no feature engineering was performed. The entire effort was restricted to iterative labeling function development and the setup of candidates to be classified. In under eight hours, they had a dataset that was within 10 points of F1 of the supervised baseline; the gap was mainly due to recall issue in the candidate extraction phase. This suggests data programming may be a promising way to build high quality extractors, quickly."
    }, {
      "heading" : "6 Conclusion and Future Work",
      "text" : "We introduced data programming, a new approach to generating large labeled training sets. We demonstrate that our approach can be used with automatic feature generation techniques to achieve high quality results. For some relation extraction tasks, we provided anecdotal evidence that our methods may be easier for domain expert users to build on. We hope to explore the limits of our approach on more sophisticated machine learning tasks, notably in imaging and structured prediction.\nAcknowledgements Thanks to Theodoros Rekatsinas, Manas Joglekar, Henry Ehrenberg, Jason Fries, Percy Liang, the many helpful and intrepid DeepDive and DDLite users, and many others for their helpful conversations and feedback.\nWe gratefully acknowledge the support of the Defense Advanced Research Projects Agency (DARPA)SIMPLEX program under No. N66001-15-C-4043, the National Science Foundation (NSF) CAREER Award under No. IIS1353606, the Office of Naval Research (ONR) under awards No. N000141210041 and No. N000141310129, the Sloan Research Fellowship, the Moore Foundation, Toshiba, and Intel. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA, NSF, ONR, or the U.S. government."
    }, {
      "heading" : "A General Theoretical Results",
      "text" : "In this section, we will state the full form of the theoretical results we alluded to in the body of the paper. First, we restate, in long form, our setup and assumptions.\nWe assume that, for some function h : {−1, 0, 1}m × {−1, 1} 7→ {−1, 0, 1}M of sufficient statistics, we are concerned with learning distributions, over the set Ω = {−1, 0, 1}m × {−1, 1}, of the form\nπθ(Λ,Y) = 1 Zθ exp(θT h(Λ,Y)), (10)\nwhere θ ∈ RM is a parameter, and Zθ is the partition function that makes this a distribution. We assume that we are given, i.e. can derive from the data programming specification, some set Θ of feasible parameters. This set must have the following two properties.\nFirst, for any θ ∈ Θ, learning the parameter θ from (full) samples from πθ is possible, at least in some sense. More specifically, there exists an unbiased estimator θ̂ that is a function of some number D samples from πθ (and is unbiased for all θ ∈ Θ) such that, for all θ ∈ Θ and for some c > 0,\nCov ( θ̂ ) I\n2cD . (11)\nSecond, for any θ1, θ2 ∈ Θ, E(λ2,y2)∼πθ2 [ Var(λ1,y1)∼πθ1 (y1|λ1 = λ2) ] ≤ c\nM . (12)\nThat is, we’ll always be reasonably certain in our guess for the value of y, even if we are totally wrong about the true parameter θ.\nOn the other hand, we are also concerned with a distribution π∗ which ranges over the set X× {−1, 1}, and represents the distribution of training and test examples we are using to learn. These objects are associated with a labeling function λ : X 7→ {−1, 0, 1}m and a feature function f : X 7→ Rn. We make three assumptions about this distribution. First, we assume that, given (x, y) ∼ π∗, the class label y is independent of the features f (x) given the labels λ(x). That is,\n(x, y) ∼ π∗ ⇒ y ⊥ f (x) | λ(x). (13)\nSecond, we assume that we can describe the relationship between λ(x) and y in terms of our family in (10) above. That is, for some parameter θ∗ ∈ Θ,\nP(x,y)∼π∗ (λ(x) = Λ, y = Y) = πθ∗ (Λ,Y). (14)\nThird, we assume that the features themselves are bounded; for all x ∈ X,\n‖ f (x)‖ ≤ 1. (15)\nOur goal is twofold. First, we want to recover some estimate θ̂ of the true parameter θ∗. Second, we want to produce a parameter ŵ that minimizes the regularized logistic loss\nl(w) = E(x,y)∼π∗ [ log(1 + exp(−wT f (x)y)) ] + ρ ‖w‖2 .\nWe actually accomplish this by minimizing a noise-aware loss function, given our recovered parameter θ̂, lθ̂(w) = E(x̄,ȳ)∼π∗ [ E(Λ,Y)∼πθ̂ [ log(1 + exp(−wT f (x̄)Y)) ∣∣∣Λ = λ(x̄)]] + ρ ‖w‖2 . In fact we can’t even minimize this; rather, we will be minimizing the empirical noise-aware loss function, which is only this in expectation. Since the analysis of logistic regression is not itself interesting, we assume that we are able to run some algorithm that produces an estimate ŵ which satisfies, for some χ > 0,\nE [ lθ̂(ŵ) −minw lθ̂(w) ∣∣∣∣∣θ̂] ≤ χ. (16) The algorithm chosen can be anything, but in practice, we use stochastic gradient descent.\nWe learn θ̂ and ŵ by running the following algorithm. Under these assumptions, we are able to prove the following theorem about the behavior of Algorithm 1.\nAlgorithm 1 Data Programming Require: Step size η, dataset S ⊂ X, and initial parameter θ0 ∈ Θ. θ → θ0 for all x ∈ S do\nIndependently sample (Λ,Y) from πθ, and (Λ̄, Ȳ) from πθ conditionally given Λ = λ(x). θ ← θ + η(h(Λ,Y) − h(Λ̄, Ȳ)). θ = PΘ(θ) . Here, PΘ denotes orthogonal projection onto Θ.\nend for Compute ŵ using the algorithm described in (15) return (θ, ŵ).\nTheorem A.1. Suppose that we run Algorithm 1 on a data programming specification that satisfies conditions (11), (12), (13), (14), (15), and (16). Suppose further that, for some parameter > 0, we use step size\nη = c 2\n4\nand our dataset is of a size that satisfies\n|S | = 2 c2 2\nlog ( 2 ‖θ0 − θ∗‖2 ) .\nThen, we can bound the expected parameter error with E [∥∥∥θ̂ − θ∗∥∥∥2] ≤ 2M\nand the expected risk with\nE [ l(ŵ) −min\nw l(w)\n] ≤ χ + c\n2ρ .\nThis theorem’s conclusions and assumptions can readily be seen to be identical to those of Theorem 2 in the main body of the paper, except that they apply to the slightly more general case of arbitrary h, rather than h of the explicit form described in the body. Therefore, in order to prove Theorem 2, it suffices to prove Theorem A.1, which we will do in Section C."
    }, {
      "heading" : "B Theoretical Results for Independent Model",
      "text" : "For the independent model, we can obtain a more specific version of Theorem A.1. In the independent model, the variables are, as before, Λ ∈ {−1, 0, 1}m and Y ∈ {−1, 1}. The sufficient statistics are ΛiY and Λ2i .\nTo produce results that make intuitive sense, we also define the alternate parameterization\nPπ (Λi|Y) =  βi 1+γi 2 Λi = Y (1 − βi) Λ = 0 βi 1−γi 2 Λi = −Y .\nIn comparison to the parameters used in the body of the paper, we have\nαi = 1 + γi\n2 .\nNow, we are concerned with models that are feasible. For a model to be feasible (i.e. for θ ∈ Θ), we require that it satisfy, for some constants γmin > 0, γmax > 0, and βmin,\nγmin ≤ γi ≤ γmax βmin ≤ βi ≤ 1 2 .\nFor 0 ≤ β ≤ 1 and −1 ≤ γ ≤ 1. For this model, we can prove the following corollary to Theorem A.1\nCorollary B.1. Suppose that we run Algorithm 1 on an independent data programming specification that satisfies conditions (13), (14), (15), and (16). Furthermore, assume that the number of labeling functions we use satisfies\nm ≥ 9.34 artanh(γmax) (γβ)minγ2min\nlog (\n24m βmin\n) .\nSuppose further that, for some parameter > 0, we use step size\nη = βmin\n2\n16\nand our dataset is of a size that satisfies\n|S | = 32 β2min 2 log\n( 2 ‖θ0 − θ∗‖2 ) .\nThen, we can bound the expected parameter error with E [∥∥∥θ̂ − θ∗∥∥∥2] ≤ 2M\nand the expected risk with\nE [ l(ŵ) −min\nw l(w)\n] ≤ χ + βmin\n8ρ .\nWe can see that if, as stated in the body of the paper, βi ≥ 0.3 and 0.8 ≤ αi ≤ 0.9 (which is equivalent to 0.6 ≤ γi ≤ 0.8), then\n2000 ≥ 1896.13 = 9.34 artanh(0.8) 0.3 · 0.63 log\n( 24 · 2000\n0.3\n) .\nThis means that, as stated in the paper, m = 2000 is sufficient for this corollary to hold with\n|S | = 32 0.32 · 2 log\n( 2m(artanh(0.8) − artanh(0.6))2 ) =\n356 2 log ( m 3 ) .\nThus, proving Corollary B.1 is sufficient to prove Theorem 1 from the body of the paper. We will prove Corollary B.1 in Section E"
    }, {
      "heading" : "C Proof of Theorem A.1",
      "text" : "First, we state some lemmas that will be useful in the proof to come.\nLemma D.1. Given a family of maximum-entropy distributions\nπθ(x) = 1 Zθ exp(θT h(x)),\nfor some function of sufficient statistics h : Ω 7→ RM , if we let J : RM 7→ R be the maximum log-likelihood objective for some event A ⊆ Ω, J(θ) = log Px∼πθ (x ∈ A) , then its gradient is ∇J(θ) = Ex∼πθ [h(x)|x ∈ A] − Ex∼πθ [h(x)] and its Hessian is\n∇2J(θ) = Covx∼πθ (h(x)|x ∈ A) − Covx∼πθ (h(x)) .\nLemma D.2. Suppose that we are looking at a distribution from a data programming label model. That is, our maximum-entropy distribution can now be written in terms of two variables, the labeling function values λ ∈ {−1, 0, 1} and the class y ∈ {−1, 1}, as\nπθ(λ, y) = 1 Zθ exp(θT h(λ, y)),\nwhere we assume without loss of generality that for some M, h(λ, y) ∈ RM and ‖h(λ, y)‖∞ ≤ 1. If we let J : RM 7→ R be the maximum expected log-likelihood objective, under another distribution π∗, for the event associated with the observed labeling function values λ,\nJ(θ) = E(λ∗,y∗)∼π∗ [ log P(λ,y)∼πθ (λ = λ ∗) ] ,\nthen its Hessian can be bounded with ∇2J(θ) MIE(λ∗,y∗)∼π∗ [ Var(λ,y)∼πθ (y|λ = λ∗) ] − I(θ),\nwhere I(θ) is the Fisher information.\nLemma D.3. Suppose that we are looking at a data programming distribution, as described in the text of Lemma D.2. Suppose further that we are concerned with some feasible set of parameters Θ ⊂ RM , such that the any model with parameters in this space satisfies the following two conditions.\nFirst, for any θ ∈ Θ, learning the parameter θ from (full) samples from πθ is possible, at least in some sense. More specifically, there exists an unbiased estimator θ̂ that is a function of some number D samples from πθ (and is unbiased for all θ ∈ Θ) such that, for all θ ∈ Θ and for some c > 0,\nCov ( θ̂ ) I\n2cD .\nSecond, for any θ, θ∗ ∈ Θ, E(λ∗,y∗)∼π∗ [ Var(λ,y)∼πθ (y|λ = λ∗) ] ≤ c\nM .\nThat is, we’ll always be reasonably certain in our guess for the value of y, even if we are totally wrong about the true parameter θ∗.\nUnder these conditions, the function J is strongly concave on Θ with parameter of strong convexity c.\nLemma D.4. Suppose that we are looking at a data programming maximum likelihood estimation problem, as described in the text of Lemma D.2. Suppose further that the objective function J is strongly concave with parameter c > 0.\nIf we run stochastic gradient descent on objective J, using unbiased samples from a true distribution πθ∗ , where θ∗ ∈ Θ, then if we use step size\nη = c 2\n4 and run (using a fresh sample at each iteration) for T steps, where\nT = 2\nc2 2 log\n( 2 ‖θ0 − θ∗‖2 ) then we can bound the expected parameter estimation error with\nE [∥∥∥θ̂ − θ∗∥∥∥2] ≤ 2M.\nLemma D.5. Assume in our model that, without loss of generality, ‖ f (x)‖ ≤ 1 for all x, and that in our true model π∗, the class y is independent of the features f (x) given the labels λ(x).\nSuppose that we now want to solve the expected loss minimization problem wherein we minimize the objective l(w) = E(x,y)∼π∗ [ log(1 + exp(−wT f (x)y)) ] + ρ ‖w‖2 .\nWe actually accomplish this by minimizing our noise-aware loss function, given our chosen parameter θ̂, lθ̂(w) = E(x̄,ȳ)∼π∗ [ E(Λ,Y)∼πθ̂ [ log(1 + exp(−wT f (x̄)Y)) ∣∣∣Λ = λ(x̄)]] + ρ ‖w‖2 .\nIn fact we can’t even minimize this; rather, we will be minimizing the empirical noise-aware loss function, which is only this in expectation. Suppose that doing so produces an estimate ŵ which satisfies, for some χ > 0,\nE [ lθ̂(ŵ) −minw lθ̂(w) ∣∣∣∣∣θ̂] ≤ χ. (Here, the expectation is taken with respect to only the random variable ŵ.) Then, we can bound the expected risk with\nE [ l(ŵ) −min\nw l(w)\n] ≤ χ + c\n2ρ .\nNow, we restate and prove our main theorem.\nTheorem A.1. Suppose that we run Algorithm 1 on a data programming specification that satisfies conditions (11), (12), (13), (14), (15), and (16). Suppose further that, for some parameter > 0, we use step size\nη = c 2\n4 and our dataset is of a size that satisfies\n|S | = 2 c2 2\nlog ( 2 ‖θ0 − θ∗‖2 ) .\nThen, we can bound the expected parameter error with E [∥∥∥θ̂ − θ∗∥∥∥2] ≤ 2M\nand the expected risk with\nE [ l(ŵ) −min\nw l(w)\n] ≤ χ + c\n2ρ .\nProof. The bounds on the expected parameter estimation error follow directly from Lemma D.4, and the remainder of the theorem follows directly from Lemma D.5."
    }, {
      "heading" : "D Proofs of Lemmas",
      "text" : "Lemma D.1. Given a family of maximum-entropy distributions\nπθ(x) = 1 Zθ exp(θT h(x)),\nfor some function of sufficient statistics h : Ω 7→ RM , if we let J : RM 7→ R be the maximum log-likelihood objective for some event A ⊆ Ω, J(θ) = log Px∼πθ (x ∈ A) , then its gradient is ∇J(θ) = Ex∼πθ [h(x)|x ∈ A] − Ex∼πθ [h(x)] and its Hessian is ∇2J(θ) = Covx∼πθ (h(x)|x ∈ A) − Covx∼πθ (h(x)) . Proof. For the gradient,\n∇J(θ) = ∇ log Pπθ (A) = ∇ log (∑\nx∈A exp(θT h(x))∑ x∈Ω exp(θT h(x)) ) = ∇ log\n∑ x∈A exp(θT h(x))  − ∇ log ∑ x∈Ω exp(θT h(x))  = ∑ x∈A h(x) exp(θT h(x))∑\nx∈A exp(θT h(x)) −\n∑ x∈Ω h(x) exp(θT h(x))∑\nx∈Ω exp(θT h(x)) = Ex∼πθ [h(x)|x ∈ A] − Ex∼πθ [h(x)] .\nAnd for the Hessian, ∇2J(θ) = ∇ ∑\nx∈A h(x) exp(θT h(x))∑ x∈A exp(θT h(x))\n− ∇ ∑\nx∈Ω h(x) exp(θT h(x))∑ x∈Ω exp(θT h(x))\n= ∑ x∈A h(x)h(x)T exp(θT h(x))∑\nx∈A exp(θT h(x)) −\n(∑ x∈A h(x) exp(θT h(x)) ) (∑ x∈A h(x) exp(θT h(x)) )T(∑ x∈A exp(θT h(x))\n)2 −  ∑ x∈Ω h(x)h(x)T exp(θT h(x))∑ x∈Ω exp(θT h(x)) − (∑ x∈Ω h(x) exp(θT h(x)) ) (∑ x∈Ω h(x) exp(θT h(x)) )T(∑ x∈Ω exp(θT h(x)) )2 \n= Ex∼πθ [ h(x)h(x)T ∣∣∣x ∈ A] − Ex∼πθ [h(x)|x ∈ A] Ex∼πθ [h(x)|x ∈ A]T − ( Ex∼πθ [ h(x)h(x)T ] − Ex∼πθ [h(x)] Ex∼πθ [h(x)]T\n) = Covx∼πθ (h(x)|x ∈ A) − Covx∼πθ (h(x)) .\nLemma D.2. Suppose that we are looking at a distribution from a data programming label model. That is, our maximum-entropy distribution can now be written in terms of two variables, the labeling function values λ ∈ {−1, 0, 1} and the class y ∈ {−1, 1}, as\nπθ(λ, y) = 1 Zθ exp(θT h(λ, y)),\nwhere we assume without loss of generality that for some M, h(λ, y) ∈ RM and ‖h(λ, y)‖∞ ≤ 1. If we let J : RM 7→ R be the maximum expected log-likelihood objective, under another distribution π∗, for the event associated with the observed labeling function values λ,\nJ(θ) = E(λ∗,y∗)∼π∗ [ log P(λ,y)∼πθ (λ = λ ∗) ] ,\nthen its Hessian can be bounded with ∇2J(θ) MIE(λ∗,y∗)∼π∗ [ Var(λ,y)∼πθ (y|λ = λ∗) ] − I(θ),\nwhere I(θ) is the Fisher information. Proof. From the result of Lemma D.1, we have that\n∇2J(θ) = E(λ∗,y∗)∼π∗ [ Cov(λ,y)∼πθ (h(λ, y)|λ = λ∗) ] − Cov(λ,y)∼πθ (h(λ, y)) . (17)\nWe start byu defining h0(λ) and h1(λ) such that\nh(λ, y) = h(λ, 1) 1 + y 2 + h(λ,−1)1 − y 2 = h(λ, 1) + h(λ,−1) 2 + y h(λ, 1) − h(λ,−1) 2 = h0(λ) + yh1(λ).\nThis allows us to reduce (17) to ∇2J(θ) = E(λ∗,y∗)∼π∗ [ h1(λ∗)h1(λ∗)T Var(λ,y)∼πθ (y|λ = λ∗) ] − Cov(λ,y)∼πθ (h(λ, y)) .\nOn the other hand, the Fisher information of this model at θ is I(θ) = E [(∇θ log πθ(x))2]\n= E (∇θ log ( exp(θT h(x))∑\nz∈Ω exp(θT h(z)) ))2 = E  ∇θ log (exp(θT h(x))) − ∇θ log ∑ z∈Ω exp(θT h(z))  2\n = E\n(h(x) − ∑z∈Ω h(z) exp(θT h(z))∑ z∈Ω exp(θT h(z)) )2 = E [ (h(x) − E [h(z)])2\n] = Cov (h(x)) .\nTherefore, we can write the second derivative of J as ∇2J(θ) = E(λ∗,y∗)∼π∗ [ h1(λ∗)h1(λ∗)T Var(λ,y)∼πθ (y|λ = λ∗) ] − I(θ).\nIf we apply the fact that h1(λ∗)h1(λ∗)T I ‖h1(λ∗)‖2 MI ‖h1(λ∗)‖2∞ MI,\nthen we can reduce this to ∇2J(θ) MIE(λ∗,y∗)∼π∗ [ Var(λ,y)∼πθ (y|λ = λ∗) ] − I(θ).\nThis is the desired result.\nLemma D.3. Suppose that we are looking at a data programming distribution, as described in the text of Lemma D.2. Suppose further that we are concerned with some feasible set of parameters Θ ⊂ RM , such that the any model with parameters in this space satisfies the following two conditions.\nFirst, for any θ ∈ Θ, learning the parameter θ from (full) samples from πθ is possible, at least in some sense. More specifically, there exists an unbiased estimator θ̂ that is a function of some number D samples from πθ (and is unbiased for all θ ∈ Θ) such that, for all θ ∈ Θ and for some c > 0,\nCov ( θ̂ ) I\n2cD .\nSecond, for any θ, θ∗ ∈ Θ, E(λ∗,y∗)∼π∗ [ Var(λ,y)∼πθ (y|λ = λ∗) ] ≤ c\nM .\nThat is, we’ll always be reasonably certain in our guess for the value of y, even if we are totally wrong about the true parameter θ∗.\nUnder these conditions, the function J is strongly concave on Θ with parameter of strong convexity c.\nProof. From the Cramér-Rao bound, we know in general that the variance of any unbiased estimator is bounded by the reciprocal of the Fisher information Cov ( θ̂ ) (I(θ))−1 .\nSince for the estimator described in the lemma statement, we have D independent samples from the distribution, it follows that the Fisher information of this experiment is D times the Fisher information of a single sample. Combining this with the bound in the lemma statement on the covariance, we get\nI 2cD\nCov ( θ̂ ) (DI(θ))−1 .\nIt follows that I(θ) 2cI.\nOn the other hand, also from the lemma statement, we can conclude that MIE(λ∗,y∗)∼π∗ [ Var(λ,y)∼πθ (y|λ = λ∗) ] cI.\nTherefore, for all θ ∈ Θ, ∇2J(θ) MIE(λ∗,y∗)∼π∗ [ Var(λ,y)∼πθ (y|λ = λ∗) ] − I(θ) −cI.\nThis implies that J is strongly concave over Θ, with constant c, as desired.\nLemma D.4. Suppose that we are looking at a data programming maximum likelihood estimation problem, as described in the text of Lemma D.2. Suppose further that the objective function J is strongly concave with parameter c > 0.\nIf we run stochastic gradient descent on objective J, using unbiased samples from a true distribution πθ∗ , where θ∗ ∈ Θ, then if we use step size\nη = c 2\n4\nand run (using a fresh sample at each iteration) for T steps, where\nT = 2\nc2 2 log\n( 2 ‖θ0 − θ∗‖2 ) then we can bound the expected parameter estimation error with\nE [∥∥∥θ̂ − θ∗∥∥∥2] ≤ 2M.\nProof. First, we note that, in the proof to follow, we can ignore the projection onto the feasible set Θ, since this projection always takes us closer to the optimum θ∗.\nIf we track the expected distance to the optimum θ∗, then at the next timestep,\n‖θt+1 − θ∗‖2 = ‖θt − θ∗‖2 + 2γ(θt − θ∗)∇J̃(θt) + γ2 ∥∥∥∇J̃t(θt)∥∥∥2 .\nSince we can write our stochastic samples in the form\n∇J̃t(θt) = h(λt, yt) − h(λ̄t, ȳt),\nfor some samples λt, yt, λ̄t, and ȳt, we can conclude that∥∥∥∇J̃t(θt)∥∥∥2 ≤ M ∥∥∥∇J̃t(θt)∥∥∥2∞ ≤ 4M. Therefore, taking the expected value conditioned on the filtration,\nE [ ‖θt+1 − θ∗‖2 ∣∣∣Ft] = ‖θt − θ∗‖2 + 2γ(θt − θ∗)∇J(θt) + 4γ2M. Since J is strongly concave, (θt − θ∗)∇J(θt) ≤ −c ‖θt − θ∗‖2 ; and so,\nE [ ‖θt+1 − θ∗‖2 ∣∣∣Ft] ≤ (1 − 2γc) ‖θt − θ∗‖2 + 4γ2M. If we take the full expectation and subtract the fixed point from both sides,\nE [ ‖θt+1 − θ∗‖2 ] − 2γM\nc ≤ (1 − 2γc)E\n[ ‖θt − θ∗‖2 ] + 4γ2M − 2γM\nc = (1 − 2γc)\n( E [ ‖θt − θ∗‖2 ] − 2γM\nc\n) .\nTherefore,\nE [ ‖θt − θ∗‖2 ] − 2γM\nc ≤ (1 − 2γc)t\n( ‖θ0 − θ∗‖2 −\n2γM c\n) ,\nand so E [ ‖θt − θ∗‖2 ] ≤ exp(−2γct) ‖θ0 − θ∗‖2 +\n2γM c .\nIn order to ensure that E [ ‖θt − θ∗‖2 ] ≤ 2,\nit therefore suffices to pick\nγ = c 2\n4M and\nt = 2M c2 2\nlog ( 2 ‖θ0 − θ∗‖2 ) .\nSubstituting 2 → 2M produces the desired result.\nLemma D.5. Assume in our model that, without loss of generality, ‖ f (x)‖ ≤ 1 for all x, and that in our true model π∗, the class y is independent of the features f (x) given the labels λ(x).\nSuppose that we now want to solve the expected loss minimization problem wherein we minimize the objective l(w) = E(x,y)∼π∗ [ log(1 + exp(−wT f (x)y)) ] + ρ ‖w‖2 .\nWe actually accomplish this by minimizing our noise-aware loss function, given our chosen parameter θ̂, lθ̂(w) = E(x̄,ȳ)∼π∗ [ E(Λ,Y)∼πθ̂ [ log(1 + exp(−wT f (x̄)Y)) ∣∣∣Λ = λ(x̄)]] + ρ ‖w‖2 . In fact we can’t even minimize this; rather, we will be minimizing the empirical noise-aware loss function, which is only this in expectation. Suppose that doing so produces an estimate ŵ which satisfies, for some χ > 0,\nE [ lθ̂(ŵ) −minw lθ̂(w) ∣∣∣∣∣θ̂] ≤ χ. (Here, the expectation is taken with respect to only the random variable ŵ.) Then, we can bound the expected risk with\nE [ l(ŵ) −min\nw l(w)\n] ≤ χ + c\n2ρ .\nProof. (To simplify the symbols in this proof, we freely use θ when we mean θ̂.) The loss function we want to minimize is, in expectation,\nl(w) = E(x,y)∼π∗ [ log(1 + exp(−wT f (x)y)) ] + ρ ‖w‖2 .\nBy the law of total expectation, l(w) = E(x̄,ȳ)∼π∗ [ E(x,y)∼π∗ [ log(1 + exp(−wT f (x̄)y)) ∣∣∣x = x̄]] + ρ ‖w‖2 , and by our conditional independence assumption,\nl(w) = E(x̄,ȳ)∼π∗ [ E(x,y)∼π∗ [ log(1 + exp(−wT f (x̄)y)) ∣∣∣λ(x) = λ(x̄)]] + ρ ‖w‖2 . Since we know from our assumptions that, for the optimum parameter θ∗,\nP(x,y)∼π∗ (λ(x) = Λ, y = Y) = P(λ,y)∼πθ∗ (λ = Λ, y = Y) ,\nwe can rewrite this as l(w) = E(x̄,ȳ)∼π∗ [ E(Λ,Y)∼πθ∗ [ log(1 + exp(−wT f (x̄)Y)) ∣∣∣Λ = λ(x̄)]] + ρ ‖w‖2 . On the other hand, if we are minimizing the model we got from the previous step, we will be actually minimizing\nlθ(w) = E(x̄,ȳ)∼π∗ [ E(Λ,Y)∼πθ [ log(1 + exp(−wT f (x̄)Y)) ∣∣∣Λ = λ(x̄)]] + ρ ‖w‖2 . We can reduce this further by noticing that\nE(Λ,Y)∼πθ [ log(1 + exp(−wT f (x̄)Y)) ∣∣∣Λ = λ(x̄)] = E(Λ,Y)∼πθ [ log(1 + exp(−wT f (x̄)))1 + Y\n2 + log(1 + exp(wT f (x̄))) 1 − Y 2 ∣∣∣∣∣Λ = λ(x̄)] =\nlog(1 + exp(−wT f (x̄))) + log(1 + exp(wT f (x̄))) 2\n+ log(1 + exp(−wT f (x̄))) − log(1 + exp(wT f (x̄)))\n2 E(Λ,Y)∼πθ [Y |Λ = λ(x̄)]\n= log(1 + exp(−wT f (x̄))) + log(1 + exp(wT f (x̄)))\n2\n− w T f (x̄)\n2 E(Λ,Y)∼πθ [Y |Λ = λ(x̄)] .\nIt follows that the difference between the loss functions will be |l(w) − lθ(w)| = ∣∣∣∣∣∣E(x̄,ȳ)∼π∗ [ wT f (x̄) 2 ( E(Λ,Y)∼πθ [Y |Λ = λ(x̄)] − E(Λ,Y)∼πθ∗ [Y |Λ = λ(x̄)] )]∣∣∣∣∣∣ . Now, we can compute that\n∇θE(Λ,Y)∼πθ [Y |Λ = λ] = ∇θ exp(θT h(λ, 1)) − exp(θT h(λ,−1)) exp(θT h(λ, 1)) + exp(θT h(λ,−1))\n= ∇θ exp(θT h1(λ)) − exp(−θT h1(λ)) exp(θT h1(λ)) + exp(θT h1(λ)) = ∇θ tanh(θT h1(λ)) = h1(λ) ( 1 − tanh2(θT h1(λ))\n) = h1(λ)Var(Λ,Y)∼πθ (Y |Λ = λ) .\nIt follows by the mean value theorem that for some ψ, a linear combination of θ and θ∗,\n|l(w) − lθ(w)| = ∣∣∣∣∣∣E(x̄,ȳ)∼π∗ [ wT f (x̄) 2 (θ − θ∗)T h1(λ)Var(Λ,Y)∼πψ (Y |Λ = λ) ]∣∣∣∣∣∣ . Since Θ is convex, clearly ψ ∈ Θ. From our assumption on the bound of the variance, we can conclude that\nE(x̄,ȳ)∼π∗ [ Var(Λ,Y)∼πψ (Y |Λ = λ) ] ≤ c\nM .\nBy the Cauchy-Schwarz inequality,\n|l(w) − lθ(w)| ≤ 1 2 ∣∣∣∣E(x̄,ȳ)∼π∗ [‖w‖ ‖ f (x̄)‖ ‖θ − θ∗‖ ‖h1(λ)‖Var(Λ,Y)∼πψ (Y |Λ = λ)]∣∣∣∣ . Since (by assumption) ‖ f (x)‖ ≤ 1 and ‖h1(λ)‖ ≤ √ M,\n|l(w) − lθ(w)| ≤ ‖w‖ ‖θ − θ∗‖\n√ M\n2 ∣∣∣∣E(x̄,ȳ)∼π∗ [Var(Λ,Y)∼πψ (Y |Λ = λ)]∣∣∣∣ ≤ ‖w‖ ‖θ − θ ∗‖ √\nM 2 · c M\n= c ‖w‖ ‖θ − θ∗‖\n2 √ M .\nNow, for any w that could conceivably be a solution, it must be the case that\n‖w‖ ≤ 1 2ρ ,\nsince otherwise the regularization term would be too large Therefore, for any possible solution w,\n|l(w) − lθ(w)| ≤ c ‖θ − θ∗‖ 4ρ √ M .\nNow, we apply the assumption that we are able to solve the empirical problem, producing an estimate ŵ that satisfies\nE [ lθ(ŵ) − lθ(w∗θ) ] ≤ χ, where w∗θ is the true solution to\nw∗θ = arg minw lθ(w).\nTherefore,\nE [ l(ŵ) − l(w∗)] = E [lθ(ŵ) − lθ(w∗θ) + lθ(w∗θ) − lθ(ŵ) + l(ŵ) − l(w∗)]\n≤ χ + E [lθ(w∗) − lθ(ŵ) + l(ŵ) − l(w∗)] ≤ χ + E [|lθ(w∗) − l(w∗)| + |lθ(ŵ) − l(ŵ)|] ≤ χ + E\nc ‖θ − θ∗‖ 2ρ √ M  = χ + c\n2ρ √ M E [‖θ − θ∗‖] ≤ χ + c\n2ρ √ M\n√ E [ ‖θ − θ∗‖2 ] .\nWe can now bound this using the result of Lemma D.4, which results in\nE [ l(ŵ) − l(w∗)] ≤ χ + c\n2ρ √ M\n√ M 2\n= χ + c 2ρ .\nThis is the desired result."
    }, {
      "heading" : "E Proofs of Results for the Independent Model",
      "text" : "To restate, in the independent model, the variables are, as before, Λ ∈ {−1, 0, 1}m and Y ∈ {−1, 1}. The sufficient statistics are ΛiY and Λ2i . That is, for expanded parameter θ = (ψ, φ),\nπθ(Λ,Y) = 1 Z exp(ψT ΛY + φT Λ2).\nThis can be combined with the simple assumption that P (Y) = 12 to complete a whole distribution. Using this, we can prove the following simple result about the moments of the sufficient statistics.\nLemma E.1. The expected values and covariances of the sufficient statistics are, for all i , j,\nE [ΛiY] = βiγi E [ Λ2i ] = βi\nVar (ΛiY) = βi − β2i γ2i Var ( Λ2i ) = βi − β2i\nCov ( ΛiY,Λ jY ) = 0\nCov ( Λ2i ,Λ 2 j ) = 0\nCov ( ΛiY,Λ2j ) = 0.\nWe also prove the following basic lemma that relates ψi to γi.\nLemma E.2. It holds that γi = tanh(ψi).\nWe also make the following claim about feasible models.\nLemma E.3. For any feasible model, it will be the case that, for any other feasible parameter vector ψ̂,\nP ( ψ̂T ΛY ≤ m\n2 γmin(γβ)min\n) ≤ exp − m(γβ)minγ2min9.34 artanh(γmax)  .\nWe can also prove the following simple result about the conditional covariances\nLemma E.4. The covariances of the sufficient statistics, conditioned on Λ, are for all i , j, Cov ( ΛiY,Λ jY ∣∣∣Λ) = ΛiΛ j sech2(ψT Λ) Cov ( Λ2i ,Λ 2 j\n∣∣∣Λ) = 0. We can combine these two results to bound the expected variance of these conditional statistics.\nLemma E.5. If θ and θ∗ are two feasible models, then for any u,\nEθ∗ [Varθ (Y |Λ)] ≤ 3 exp − mβ2minγ3min8 artanh(γmax)  . We can now proceed to restate and prove the main corollary of Theorem A.1 that applies in the independent case.\nCorollary B.1. Suppose that we run Algorithm 1 on an independent data programming specification that satisfies conditions (13), (14), (15), and (16). Furthermore, assume that the number of labeling functions we use satisfies\nm ≥ 9.34 artanh(γmax) (γβ)minγ2min\nlog (\n24m βmin\n) .\nSuppose further that, for some parameter > 0, we use step size\nη = βmin\n2\n16\nand our dataset is of a size that satisfies\n|S | = 32 β2min 2 log\n( 2 ‖θ0 − θ∗‖2 ) .\nThen, we can bound the expected parameter error with E [∥∥∥θ̂ − θ∗∥∥∥2] ≤ 2M\nand the expected risk with\nE [ l(ŵ) −min\nw l(w)\n] ≤ χ + βmin\n8ρ .\nProof. In order to apply Theorem A.1, we have to verify all its conditions hold in the independent case. First, we notice that (11) is used only to bound the covariance of the sufficient statistics. From Lemma E.1, we know that these can be bounded by βi − β2i γ2i ≥ βmin 2 . It follows that we can choose\nc = βmin\n4 ,\nand we can consider (11) satisfied, for the purposes of applying the theorem. Second, to verify (12), we can use Lemma E.5. For this to work, we need\n3 exp − m(γβ)minγ2min9.34 artanh(γmax)  ≤ cM = βmin8m . This happens whenever the number of labeling functions satisfies\nm ≥ 9.34 artanh(γmax) (γβ)minγ2min\nlog (\n24m βmin\n) .\nThe remaining assumptions, (13), (14), (15), and (16), are satisfied directly by the assumptions of this corollary. So, we can apply Theorem A.1, which produces the desired result."
    }, {
      "heading" : "F Proofs of Independent Model Lemmas",
      "text" : "Lemma E.1. The expected values and covariances of the sufficient statistics are, for all i , j,\nE [ΛiY] = βiγi E [ Λ2i ] = βi\nVar (ΛiY) = βi − β2i γ2i Var ( Λ2i ) = βi − β2i\nCov ( ΛiY,Λ jY ) = 0\nCov ( Λ2i ,Λ 2 j ) = 0\nCov ( ΛiY,Λ2j ) = 0.\nProof. We prove each of the statements in turn. For the first statement,\nE [ΛiY] = P (Λi = Y) − P (Λi = −Y)\n= βi 1 + γi\n2 − βi 1 − γi 2\n= βiγi.\nFor the second statement,\nE [ Λ2i ] = P (Λ = Y) + P (Λ = −Y)\n= βi 1 + γi\n2 + βi 1 − γi 2\n= βi.\nFor the remaining statements, we derive the second moments; converting these to an expression of the covariance is trivial. For the third statement, E [ (ΛiY)2 ] = E [ Λ2i Y 2 ] = E [ Λ2i ] = βi.\nFor the fourth statement, E [ (Λ2i ) 2 ] = E [ Λ4i ] = E [ Λ2i ] = βi.\nFor subsequent statements, we first derive that\nE [ΛiY |Y] = βi 1 + γi\n2 − βi 1 − γi 2 = βiγi\nand E [ Λ2i ∣∣∣Y] = βi 1 + γi2 + βi 1 − γi2 = βi. Now, for the fifth statement,\nE [ (ΛiY)(Λ jY) ] = E [ E [ΛiY |Y] E [ Λ jY ∣∣∣Y]] = βiγiβ jγ j. For the sixth statement,\nE [ (Λ2i )(Λ 2 j ) ] = E [ E [ Λ2i ∣∣∣Y] E [Λ2i ∣∣∣Y]] = βiβ j. Finally, for the seventh statement,\nE [ (ΛiY)(Λ2j ) ] = E [ E [ΛiY |Y] E [ Λ2i ∣∣∣Y]] = βiγiβ j. This completes the proof.\nLemma E.2. It holds that γi = tanh(ψi).\nProof. From the definitions,\nβi = exp(ψi + φi) + exp(−ψi + φi)\nexp(ψi + φi) + exp(−ψi + φi) + 1 and\nβiγi = exp(ψi + φi) − exp(−ψi + φi)\nexp(ψi + φi) + exp(−ψi + φi) + 1 .\nTherefore,\nγi = exp(ψi + φi) − exp(−ψi + φi) exp(ψi + φi) + exp(−ψi + φi) = tanh(ψi),\nwhich is the desired result.\nLemma E.3. For any feasible model, it will be the case that, for any other feasible parameter vector ψ̂,\nP ( ψ̂T ΛY ≤ m\n2 γmin(γβ)min\n) ≤ exp − m(γβ)minγ2min9.34 artanh(γmax)  .\nProof. We start by noticing that\nψ̂T ΛY = m∑\ni=1\nψ̂iΛiY.\nSince in this model, all the ΛiY are independent of each other, we can bound this sum using a concentration bound. First, we note that ∣∣∣ψ̂iΛiY ∣∣∣ ≤ ψ̂i. Second, we note that\nE [ ψ̂iΛiY ] = ψ̂iβiγi\nand Var ( ψ̂iΛiY ) = ψ̂2i ( βi − β2i γ2i ) but ∣∣∣ψ̂iΛiY ∣∣∣ ≤ ψ̂i ≤ artanh(γmax) , ψ̂max because, for feasible models, by definition\nγmin ≤ artanh(γmin) ≤ ψ̂i ≤ artanh(γmax).\nTherefore, applying Bernstein’s inequality gives us, for any t, P  m∑\ni=1\nψ̂iΛiY − m∑\ni=1 ψ̂iβiγi ≤ −t  ≤ exp − 3t26 ∑mi=1 ψ̂2i γiβiγi + 2ψ̂maxt  . It follows that, if we let\nt = 1 2 m∑ i=1 ψ̂iβiγi,\nthen we get\nP  m∑\ni=1\nψ̂iΛiY − m∑\ni=1\nψ̂iβiγi ≤ −t  ≤ exp − 3 ( 1 2 ∑m i=1 ψ̂iβiγi )2 6 ∑m\ni=1 ψ̂ 2 i γiβiγi + 2ψ̂max ( 1 2 ∑m i=1 ψ̂iβiγi ) \n≤ exp ( −\n3 ∑m\ni=1 ψ̂iβiγi\n24γmaxψ̂max + 4ψ̂max ) ≤ exp ( −3m(1 − γmax)\n28ψ̂max\n)\n≤ exp − 3 (∑m i=1 ψ̂iβiγi )2 24 ∑m\ni=1 ψ̂ 2 i βi + 4ψ̂max (∑m i=1 ψ̂iβiγi\n) \n≤ exp − 3γmin (∑m i=1 ψ̂iβi ) (∑m i=1 ψ̂iβiγi ) 24ψ̂max ∑m i=1 ψ̂iβi + 4ψ̂max (∑m i=1 ψ̂iβi )  ≤ exp −3γmin (∑m i=1 ψ̂iβiγi )\n28ψ̂max  ≤ exp\n−mγ2min(γβ)min 9.34ψ̂max  . This is the desired expression.\nLemma E.4. The covariances of the sufficient statistics, conditioned on Λ, are for all i , j, Cov ( ΛiY,Λ jY ∣∣∣Λ) = ΛiΛ j sech2(ψT Λ) Cov ( Λ2i ,Λ 2 j\n∣∣∣Λ) = 0. Proof. The second result is obvious, so it suffices to prove only the first result. Clearly,\nCov ( ΛiY,Λ jY ∣∣∣Λ) = ΛiΛ jVar (Y |Λ) = ΛiΛ j (1 − E [Y |Λ]2) . Plugging into the distribution formula lets us conclude that\nE [Y |Λ] = exp(ψ T Λ + φT Λ2) − exp(−ψT Λ + φT Λ2)\nexp(ψT Λ + φT Λ2) + exp(−ψT Λ + φT Λ2) = tanh 2(ψT Λ),\nand so Cov ( ΛiY,Λ jY ∣∣∣Λ) = ΛiΛ j (1 − tanh2(ψT Λ)) = ΛiΛ j sech2(ψT Λ), which is the desired result.\nLemma E.5. If θ and θ∗ are two feasible models, then for any u,\nEθ∗ [Varθ (Y |Λ)] ≤ 3 exp − mβ2minγ3min8 artanh(γmax)  . Proof. First, we note that, by the result of Lemma E.4,\nVarθ (Y |Λ) = sech2(ψT Λ).\nTherefore, Eθ∗ [Varθ (Y |Λ)] = Eθ∗ [ sech2(ψT Λ) ] .\nApplying Lemma E.3, we can bound this with\nEθ∗ [ Varθ ( uT ΛY ∣∣∣Λ)] ≤ sech2 (m2 (γβ)minγ2min ) + exp − m(γβ)minγ2min9.34 artanh(γmax)  ≤ 2 exp (−m2 (γβ)minγ2min ) + exp − m(γβ)minγ2min9.34 artanh(γmax)\n ≤ 3 exp\n− m(γβ)minγ2min9.34 artanh(γmax)  .\nThis is the desired expression."
    }, {
      "heading" : "G Additional Experimental Details",
      "text" : "G.1 Synthetic Experiments In Fig. 3(a-b), we ran synthetic experiments with labeling functions having constant coverage β = 0.1, and accuracy drawn from α ∼ Uniform(µα − 0.25, µα + 0.25) where µα = 0.75 in the above plots. In both cases we used 1000 normally-drawn features having mean correlation with the true label class of 0.5.\nIn this case we compare data programming (DP-Pipelined) against two baselines. First, we compare against an if-then-return setup where the ordering is optimal (ITR-Oracle). Second, we compare against simple majority vote (MV).\nIn Fig. 3(c), we show an experiment where we add dependent labeling functions to a set of mind = 50 independent labeling functions, and either provided this dependency structure (LDM-Aware) or did not (Independent). In this case, the independent labeling functions had the same configurations as in (a-b), and the dependent labeling functions corresponded to “fixes” or “reinforces”-type dependent labeling functions."
    } ],
    "references" : [ {
      "title" : "Pattern learning for relation extraction with a hierarchical topic model",
      "author" : [ "E. Alfonseca", "K. Filippova", "J.-Y. Delort", "G. Garrido" ],
      "venue" : "Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics: Short Papers-Volume 2, pages 54–59. Association for Computational Linguistics,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Scalable semi-supervised aggregation of classifiers",
      "author" : [ "A. Balsubramani", "Y. Freund" ],
      "venue" : "Advances in Neural Information Processing Systems, pages 1351–1359,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Consistency of weighted majority votes",
      "author" : [ "D. Berend", "A. Kontorovich" ],
      "venue" : "Z. Ghahramani, M. Welling, C. Cortes, N. D. Lawrence, and K. Q. Weinberger, editors, Advances in Neural Information Processing Systems 27, pages 3446–3454. Curran Associates, Inc.,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Combining labeled and unlabeled data with co-training",
      "author" : [ "A. Blum", "T. Mitchell" ],
      "venue" : "Proceedings of the eleventh annual conference on Computational learning theory, pages 92–100. ACM,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Label-noise robust logistic regression and its applications",
      "author" : [ "J. Bootkrajang", "A. Kabán" ],
      "venue" : "Machine Learning and Knowledge Discovery in Databases, pages 143–158. Springer,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Learning to extract relations from the web using minimal supervision",
      "author" : [ "R. Bunescu", "R. Mooney" ],
      "venue" : "Annual meeting-association for Computational Linguistics, volume 45, page 576,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Constructing biological knowledge bases by extracting information from text sources",
      "author" : [ "M. Craven", "J. Kumlien" ],
      "venue" : "In ISMB,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1999
    }, {
      "title" : "Aggregating crowdsourced binary ratings",
      "author" : [ "N. Dalvi", "A. Dasgupta", "R. Kumar", "V. Rastogi" ],
      "venue" : "Proceedings of the 22Nd International Conference on World Wide Web, WWW ’13, pages 285–294,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Maximum likelihood estimation of observer error-rates using the em algorithm",
      "author" : [ "A.P. Dawid", "A.M. Skene" ],
      "venue" : "Applied statistics, pages 20–28,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "An improved corpus of disease mentions in pubmed citations",
      "author" : [ "R.I. Doğan", "Z. Lu" ],
      "venue" : "Proceedings of the 2012 workshop on biomedical natural language processing, pages 91–99. Association for Computational Linguistics,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Harnessing the crowdsourcing power of social media for disaster relief",
      "author" : [ "H. Gao", "G. Barbier", "R. Goolsby", "D. Zeng" ],
      "venue" : "Technical report, DTIC Document,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Long short-term memory",
      "author" : [ "S. Hochreiter", "J. Schmidhuber" ],
      "venue" : "Neural computation, 9(8):1735–1780,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Knowledge-based weak supervision for information extraction of overlapping relations",
      "author" : [ "R. Hoffmann", "C. Zhang", "X. Ling", "L. Zettlemoyer", "D.S. Weld" ],
      "venue" : "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies-Volume 1, pages 541–550. Association for Computational Linguistics,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Comprehensive and reliable crowd assessment algorithms",
      "author" : [ "M. Joglekar", "H. Garcia-Molina", "A. Parameswaran" ],
      "venue" : "Data Engineering (ICDE), 2015 IEEE 31st International Conference on, pages 195–206. IEEE,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Iterative learning for reliable crowdsourcing systems",
      "author" : [ "D.R. Karger", "S. Oh", "D. Shah" ],
      "venue" : "Advances in neural information processing systems, pages 1953–1961,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Visual genome: Connecting language and vision using crowdsourced dense image annotations",
      "author" : [ "R. Krishna", "Y. Zhu", "O. Groth", "J. Johnson", "K. Hata", "J. Kravitz", "S. Chen", "Y. Kalantidis", "L.-J. Li", "D.A. Shamma" ],
      "venue" : "arXiv preprint arXiv:1602.07332,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2016
    }, {
      "title" : "Multi-relational learning, text mining, and semi-supervised learning for functional genomics",
      "author" : [ "M.-A. Krogel", "T. Scheffer" ],
      "venue" : "Machine Learning, 57(1-2):61–81,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Learning with an unreliable teacher",
      "author" : [ "G. Lugosi" ],
      "venue" : "Pattern Recognition, 25(1):79 – 87,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1992
    }, {
      "title" : "Large-scale extraction of gene interactions from full-text literature using deepdive",
      "author" : [ "E.K. Mallory", "C. Zhang", "C. Ré", "R.B. Altman" ],
      "venue" : "Bioinformatics,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Distant supervision for relation extraction without labeled data",
      "author" : [ "M. Mintz", "S. Bills", "R. Snow", "D. Jurafsky" ],
      "venue" : "Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP: Volume 2 - Volume 2, pages 1003–1011,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Learning with noisy labels",
      "author" : [ "N. Natarajan", "I.S. Dhillon", "P.K. Ravikumar", "A. Tewari" ],
      "venue" : "C. J. C. Burges, L. Bottou, M. Welling, Z. Ghahramani, and K. Q. Weinberger, editors, Advances in Neural Information Processing Systems 26, pages 1196–1204. Curran Associates, Inc.,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Ranking and combining multiple predictors without labeled data",
      "author" : [ "F. Parisi", "F. Strino", "B. Nadler", "Y. Kluger" ],
      "venue" : "Proceedings of the National Academy of Sciences, 111(4):1253–1258,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Modeling relations and their mentions without labeled text",
      "author" : [ "S. Riedel", "L. Yao", "A. McCallum" ],
      "venue" : "Machine Learning and Knowledge Discovery in Databases, pages 148–163. Springer,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Combining generative and discriminative model scores for distant supervision",
      "author" : [ "B. Roth", "D. Klakow" ],
      "venue" : "EMNLP, pages 24–29,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Feature-based models for improving the quality of noisy training data for relation extraction",
      "author" : [ "B. Roth", "D. Klakow" ],
      "venue" : "Proceedings of the 22nd ACM international conference on Conference on information & knowledge management, pages 1181–1184. ACM,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Boosting: Foundations and algorithms",
      "author" : [ "R.E. Schapire", "Y. Freund" ],
      "venue" : "MIT press,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Incremental knowledge base construction using deepdive",
      "author" : [ "J. Shin", "S. Wu", "F. Wang", "C. De Sa", "C. Zhang", "C. Ré" ],
      "venue" : "Proceedings of the VLDB Endowment, 8(11):1310–1321,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Overview of the english slot filling track at the tac2014 knowledge base population evaluation",
      "author" : [ "M. Surdeanu", "H. Ji" ],
      "venue" : "Proc. Text Analysis Conference (TAC2014),",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Reducing wrong labels in distant supervision for relation extraction",
      "author" : [ "S. Takamatsu", "I. Sato", "H. Nakagawa" ],
      "venue" : "Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics: Long Papers-Volume 1, pages 721–729. Association for Computational Linguistics,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Multilingual relation extraction using compositional universal schema",
      "author" : [ "P. Verga", "D. Belanger", "E. Strubell", "B. Roth", "A. McCallum" ],
      "venue" : "arXiv preprint arXiv:1511.06396,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Spectral methods meet em: A provably optimal algorithm for crowdsourcing",
      "author" : [ "Y. Zhang", "X. Chen", "D. Zhou", "M.I. Jordan" ],
      "venue" : "Advances in Neural Information Processing Systems 27, pages 1260–1268.",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 11,
      "context" : "This trend has also been fueled by the recent empirical success of automated feature generation approaches, notably deep learning methods such as long short term memory (LSTM) networks [12], which ameliorate the burden of feature engineering given large enough labeled training sets.",
      "startOffset" : 185,
      "endOffset" : 189
    }, {
      "referenceID" : 19,
      "context" : "Data programming extends the idea of distant supervision, in which an external knowledge base is mapped onto an input dataset to generate training examples [20].",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 14,
      "context" : "In Section 4, we extend our results to more sophisticated data programming models, generalizing related results in crowdsourcing [15].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 29,
      "context" : "98 point F1 score gain over a state-of-the-art LSTM baseline trained on hand-labeled data [30].",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 6,
      "context" : "The canonical example is relation extraction from text, wherein a knowledge base of known relations is heuristically mapped to label a set of mentions in an input corpus as ground truth examples [7, 20].",
      "startOffset" : 195,
      "endOffset" : 202
    }, {
      "referenceID" : 19,
      "context" : "The canonical example is relation extraction from text, wherein a knowledge base of known relations is heuristically mapped to label a set of mentions in an input corpus as ground truth examples [7, 20].",
      "startOffset" : 195,
      "endOffset" : 202
    }, {
      "referenceID" : 12,
      "context" : "Basic extensions group these mapped examples by the particular textual pattern w that they occur with, and cast the problem as a multiple instance learning one [13, 23].",
      "startOffset" : 160,
      "endOffset" : 168
    }, {
      "referenceID" : 22,
      "context" : "Basic extensions group these mapped examples by the particular textual pattern w that they occur with, and cast the problem as a multiple instance learning one [13, 23].",
      "startOffset" : 160,
      "endOffset" : 168
    }, {
      "referenceID" : 24,
      "context" : "Other extensions actually model the accuracy of this pattern w using a discriminative feature-based model [25], or generative models such as hierarchical topic models [1, 24, 29].",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 0,
      "context" : "Other extensions actually model the accuracy of this pattern w using a discriminative feature-based model [25], or generative models such as hierarchical topic models [1, 24, 29].",
      "startOffset" : 167,
      "endOffset" : 178
    }, {
      "referenceID" : 23,
      "context" : "Other extensions actually model the accuracy of this pattern w using a discriminative feature-based model [25], or generative models such as hierarchical topic models [1, 24, 29].",
      "startOffset" : 167,
      "endOffset" : 178
    }, {
      "referenceID" : 28,
      "context" : "Other extensions actually model the accuracy of this pattern w using a discriminative feature-based model [25], or generative models such as hierarchical topic models [1, 24, 29].",
      "startOffset" : 167,
      "endOffset" : 178
    }, {
      "referenceID" : 5,
      "context" : "There is also a wealth of examples where additional heuristic patterns used to label training data are collected from unlabeled data [6] or directly from users [19, 27], in a similar manner to our approach, but without a framework to deal with the fact that said labels are explicitly noisy.",
      "startOffset" : 133,
      "endOffset" : 136
    }, {
      "referenceID" : 18,
      "context" : "There is also a wealth of examples where additional heuristic patterns used to label training data are collected from unlabeled data [6] or directly from users [19, 27], in a similar manner to our approach, but without a framework to deal with the fact that said labels are explicitly noisy.",
      "startOffset" : 160,
      "endOffset" : 168
    }, {
      "referenceID" : 26,
      "context" : "There is also a wealth of examples where additional heuristic patterns used to label training data are collected from unlabeled data [6] or directly from users [19, 27], in a similar manner to our approach, but without a framework to deal with the fact that said labels are explicitly noisy.",
      "startOffset" : 160,
      "endOffset" : 168
    }, {
      "referenceID" : 10,
      "context" : "Crowdsourcing is widely used for various machine learning tasks [11, 16].",
      "startOffset" : 64,
      "endOffset" : 72
    }, {
      "referenceID" : 15,
      "context" : "Crowdsourcing is widely used for various machine learning tasks [11, 16].",
      "startOffset" : 64,
      "endOffset" : 72
    }, {
      "referenceID" : 8,
      "context" : "Of particular relevance to our problem setting is the theoretical question of how to model the accuracy of various experts without ground truth available, classically raised in the context of crowdsourcing [9].",
      "startOffset" : 206,
      "endOffset" : 209
    }, {
      "referenceID" : 2,
      "context" : "More recent results provide formal guarantees even in the absence of labeled data using various approaches [3, 8, 14, 15, 22, 31].",
      "startOffset" : 107,
      "endOffset" : 129
    }, {
      "referenceID" : 7,
      "context" : "More recent results provide formal guarantees even in the absence of labeled data using various approaches [3, 8, 14, 15, 22, 31].",
      "startOffset" : 107,
      "endOffset" : 129
    }, {
      "referenceID" : 13,
      "context" : "More recent results provide formal guarantees even in the absence of labeled data using various approaches [3, 8, 14, 15, 22, 31].",
      "startOffset" : 107,
      "endOffset" : 129
    }, {
      "referenceID" : 14,
      "context" : "More recent results provide formal guarantees even in the absence of labeled data using various approaches [3, 8, 14, 15, 22, 31].",
      "startOffset" : 107,
      "endOffset" : 129
    }, {
      "referenceID" : 21,
      "context" : "More recent results provide formal guarantees even in the absence of labeled data using various approaches [3, 8, 14, 15, 22, 31].",
      "startOffset" : 107,
      "endOffset" : 129
    }, {
      "referenceID" : 30,
      "context" : "More recent results provide formal guarantees even in the absence of labeled data using various approaches [3, 8, 14, 15, 22, 31].",
      "startOffset" : 107,
      "endOffset" : 129
    }, {
      "referenceID" : 3,
      "context" : "Co-training is a classic procedure for effectively utilizing both a small amount of labeled data and a large amount of unlabeled data by selecting two conditionally independent views of the data [4].",
      "startOffset" : 195,
      "endOffset" : 198
    }, {
      "referenceID" : 16,
      "context" : "In addition to not needing a set of labeled data, and allowing for more than two views (labeling functions in our case), our approach allows explicit modeling of dependencies between views, for example allowing observed issues with dependencies between views to be explicitly modeled [17].",
      "startOffset" : 284,
      "endOffset" : 288
    }, {
      "referenceID" : 25,
      "context" : "Boosting is a well known procedure for combining the output of many “weak” classifiers to create a strong classifier in a supervised setting [26].",
      "startOffset" : 141,
      "endOffset" : 145
    }, {
      "referenceID" : 1,
      "context" : "Recently, boosting-like methods have been proposed which leverage unlabeled data in addition to labeled data, which is also used to set constraints on the accuracies of the individual classifiers being ensembled [2].",
      "startOffset" : 212,
      "endOffset" : 215
    }, {
      "referenceID" : 17,
      "context" : "The general case of learning with noisy labels is treated both in classical [18] and more recent contexts [21].",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 20,
      "context" : "The general case of learning with noisy labels is treated both in classical [18] and more recent contexts [21].",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 4,
      "context" : "It has also been studied specifically in the context of label-noise robust logistic regression [5].",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 14,
      "context" : "In contrast, in the crowdsourcing setting [15], the number of workers m tends to infinity while here it is constant while the dataset grows.",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 27,
      "context" : "34 points in F1 score, including what would have been a winning score on the 2014 TAC-KBP challenge [28].",
      "startOffset" : 100,
      "endOffset" : 104
    }, {
      "referenceID" : 11,
      "context" : "Automatically-generated Features We additionally compare both hand-tuned and automatically-generated features, where the latter are learned via an LSTM recurrent neural network (RNN) [12].",
      "startOffset" : 183,
      "endOffset" : 187
    }, {
      "referenceID" : 29,
      "context" : "98 point F1 score improvement over a state-of-the-art LSTM approach applied to the TAC-KBP task which was trained on hand-labeled data [30].",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 9,
      "context" : "Their goal was to build a disease tagging system, a common and important challenge in the bioinformatics domain [10].",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 0,
      "context" : "References [1] E.",
      "startOffset" : 11,
      "endOffset" : 14
    }, {
      "referenceID" : 1,
      "context" : "[2] A.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "[3] D.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 3,
      "context" : "[4] A.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5] J.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "[6] R.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "[7] M.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "[8] N.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "[9] A.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 9,
      "context" : "[10] R.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[11] H.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "[12] S.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "[13] R.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 13,
      "context" : "[14] M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 14,
      "context" : "[15] D.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 15,
      "context" : "[16] R.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "[17] M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 17,
      "context" : "[18] G.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "[19] E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "[20] M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "[21] N.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 21,
      "context" : "[22] F.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 22,
      "context" : "[23] S.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "[24] B.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 24,
      "context" : "[25] B.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 25,
      "context" : "[26] R.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 26,
      "context" : "[27] J.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 27,
      "context" : "[28] M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 28,
      "context" : "[29] S.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 29,
      "context" : "[30] P.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 30,
      "context" : "[31] Y.",
      "startOffset" : 0,
      "endOffset" : 4
    } ],
    "year" : 2016,
    "abstractText" : "Large labeled training sets are the critical building blocks of supervised learning methods and are key enablers of deep learning techniques. For some applications, creating labeled training sets is the most time-consuming and expensive part of applying machine learning. We therefore propose a paradigm for the programmatic creation of training sets called data programming in which users provide a set of labeling functions, which are programs that heuristically label large subsets of data points, albeit noisily. By viewing these labeling functions as implicitly describing a generative model for this noise, we show that we can recover the parameters of this model to “denoise” the training set. Then, we show how to modify a discriminative loss function to make it noise-aware. We demonstrate our method over a range of discriminative models including logistic regression and LSTMs. We establish theoretically that we can recover the parameters of these generative models in a handful of settings. Experimentally, on the 2014 TAC-KBP relation extraction challenge, we show that data programming would have obtained a winning score, and also show that applying data programming to an LSTM model leads to a TAC-KBP score almost 6 F1 points over a supervised LSTM baseline (and into second place in the competition). Additionally, in initial user studies we observed that data programming may be an easier way to create machine learning models for non-experts.",
    "creator" : "LaTeX with hyperref package"
  }
}