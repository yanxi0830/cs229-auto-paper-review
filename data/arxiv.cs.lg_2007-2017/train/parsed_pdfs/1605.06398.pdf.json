{
  "name" : "1605.06398.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 5.\n06 39\n8v 1\n[ cs\n.L G\n] 2"
    }, {
      "heading" : "1 Introduction",
      "text" : "When using optimization in machine learning, leveraging the natural separability of the objective functions has led to many algorithmic advances; the most common example is the separability as a sum of individual loss terms corresponding to individual observations, which leads to stochastic gradient descent techniques. Several lines of work have shown that the plain Robbins-Monro algorithm could be accelerated for strongly-convex finite sums, e.g., SAG [1], SDCA [2], SVRG [3], SAGA [4]. However, these only apply to separable objective functions.\nIn order to tackle non-separable losses or regularizers, we consider the saddle-point problem:\nmin x∈Rd max y∈Rn K(x, y) +M(x, y), (1)\nwhere the functions K and M are “convex-concave”, that is, convex with respect to the first variable, and concave with respect to the second variable, with M potentially non-smooth but “simple” (e.g., for which the proximal operator is easy to compute), and K smooth. These problems occur naturally within convex optimization through Lagrange or Fenchel duality [5]; for example the bilinear saddlepoint problem minx∈Rd maxy∈Rn f(x) + y\n⊤Kx− g(y) corresponds to a supervised learning problem with design matrix K, a loss function g∗ (the Fenchel conjugate of g) and a regularizer f .\nWe assume that the function K may be split into a potentially large number of components. Many problems in machine learning exhibit that structure in the saddle-point formulation, but not in the associated convex minimization and concave maximization problems (see examples in Section 2.1).\nLike for convex minimization, gradient-based techniques that are blind to this separable structure need to access all the components at every iteration. We show that algorithms such as SVRG [3] and SAGA [4] may be readily extended to the saddle-point problem. While the algorithmic extension is straightforward, it comes with challenges and opportunities. We make the following contributions:\n– We provide the first convergence analysis for these algorithms for saddle-point problems, which differs significantly from the associated convex minimization set-up. In particular, we use in Section 6 the interpretation of saddle-point problems as finding the zeros of a monotone operator, and only use the monotonicity properties to show linear convergence of our algorithms, thus showing that they extend beyond saddle-point problems, e.g., to variational inequalities [6, 7].\n– We show that the saddle-point formulation (a) allows two different notions of splits, in terms of functions, or in terms of partial derivatives, (b) does need splits into convex-concave terms (as opposed to convex minimization), and (c) that non-uniform sampling is key to an efficient algorithm, both in theory and practice (see experiments in Section 7).\n– We show in Section 5 that these incremental algorithms can be easily accelerated using a simple extension of the “catalyst” framework of [8], thus leading to an algorithm which is always superior to accelerated batch algorithms."
    }, {
      "heading" : "2 Composite Decomposable Saddle-Point Problems",
      "text" : "We consider the saddle-point problem defined in Eq. (1), with the following assumptions:\n(A) M is strongly (λ, γ)-convex-concave, that is, the function (x, y) 7→ M(x, y) − λ2 ‖x‖2 + γ 2 ‖y‖2 is\nconvex-concave. Moreover, we assume that we may compute the proximal operator of M , i.e., for any (x′, y′) ∈ Rn+d:\nproxσM (x ′, y′) = arg min\nx∈Rd max y∈Rn\nσM(x, y) + λ2 ‖x− x′‖2 − γ 2‖y − y′‖2. (2)\nThe values of λ and γ lead to the definition of a weighted Euclidean norm on Rn+d defined as Ω(x, y)2 = λ‖x‖2 + γ‖y‖2, with dual norm defined through Ω∗(x, y)2 = λ−1‖x‖2 + γ−1‖y‖2. Dealing with the two different scaling factors λ and γ is crucial for good performance, as these may be very different, depending on the many arbitrary ways to set-up a saddle-point problem.\n(B) K is convex-concave and has Lipschitz-continuous gradients; it is natural to quantify this by considering the gradient operator B : Rn+d → Rn+d defined as B(x, y) = (∂xK(x, y),−∂yK(x, y)) ∈ R\nn+d and to consider L = supΩ(x−x′,y−y′)=1 Ω ∗(B(x, y) −B(x′, y′)). The quantity L represents\nthe condition number of the problem.\n(C) The vector-valued function B(x, y) = (∂xK(x, y),−∂yK(x, y)) ∈ Rn+d may be split into a family of vector-valued functions as B = ∑\ni∈I Bi, where the only constraint is that each Bi is Lipschitzcontinuous (with constant Li). There is no need to assume the existence of Ki : R\nn+d → R such that Bi = (∂xKi,−∂yKi). We will also consider splits which are adapted to the saddle-point nature of the problem, that is, of the form B(x, y) = ( ∑\nk∈K B x k (x, y),\n∑ j∈J B y j (x, y)\n)\n, which is a subcase of the above with\nI = J × K, Bjk(x, y) = (pjBxk (x, y), qkB y j (x, y)), for p and q sequences that sum to one. This substructure, which we refer to as “factored”, will only make a difference when storing the values of these operators in Section 4 for our SAGA algorithm.\nGiven assumptions (A)-(B), the saddle-point problem in Eq. (1) has a unique solution (x∗, y∗) such that K(x∗, y)+M(x∗, y) 6 K(x∗, y∗)+M(x∗, y∗) 6 K(x, y∗)+M(x, y∗), for all (x, y); moreover minx∈Rd maxy∈Rn K(x, y) +M(x, y) = maxy∈Rn minx∈Rd K(x, y) +M(x, y) (see, e.g., [9, 5]).\nThe main generic examples for the functions K(x, y) and M(x, y) are:\n– Bilinear saddle-point problems: K(x, y) = y⊤Kx for a matrix1 K ∈ Rn×d, for which the vector-valued function B(x, y) is linear, i.e., B(x, y) = (K⊤y,−Kx). Then L = ‖K‖op/ √ γλ,\nwhere ‖K‖op is the largest singular value of K. There are two natural potential splits with I = {1, . . . , n}×{1, . . . , k}, with B = ∑nj=1 ∑d k=1 Bjk: (a) the split into individual elements Bjk(x, y) = Kjk(yj ,−xk), where every element is the gradient operator of a bi-linear function, and (b) the “factored” split into rows/columns Bjk(x, y) = (qkyjK ⊤ j· ,−pjxkK·k), where Kj· and K·k are the j-th row and k-th column of K, p and q are any set of vectors summing to one, and every element is not the gradient operator of any function. These splits correspond to several “sketches” of the matrix K [10], adapted to subsampling of K, but other sketches could be considered.\n– Separable functions: M(x, y) = f(x) − g(y) where f is any λ-strongly-convex and g is γstrongly convex, for which the proximal operators proxσf (x ′) = argminx∈Rd σf(x) + λ 2 ‖x − x′‖2\nand proxσg (y ′) = argmaxy∈Rd −σg(y) − γ2‖y − y′‖2 are easy to compute. In this situation, proxσM (x ′, y′) = (proxσf (x ′), proxσg (y ′)). Following the usual set-up of composite optimization [11], no smoothness assumption is made on M and hence on f or g."
    }, {
      "heading" : "2.1 Examples in machine learning",
      "text" : "Many learning problems are formulated as convex optimization problems, and hence by duality as saddle-point problems. We now give examples where our new algorithms are particularly adapted.\nSupervised learning with non-separable losses or regularizers. For regularized linear supervised learning, with n d-dimensional observations put in a design matrix K ∈ Rn×d, the predictions are parameterized by a vector x ∈ Rd and lead to a vector of predictions Kx ∈ Rn. Given a loss function defined through its Fenchel conjugate g∗ from Rn to R, and a regularizer f(x), we obtain exactly a bi-linear saddle-point problem. When the loss g∗ or the regularizer f is separable, i.e., a sum of functions of individual variables, we may apply existing fast gradient-techniques [1, 3, 4] to the primal problem minx∈Rd g\n∗(Kx) + f(x) or the dual problem maxy∈Rn −g(y)− f∗(K⊤y), as well as methods dedicated to separable saddle-point problems [12]. When the loss g∗ and the regularizer f are not separable (but have a simple proximal operator), our new fast algorithms are the only ones that can be applied from the class of large-scale linearly convergent algorithms.\nNon-separable losses may occur when (a) predicting by affine functions of the inputs and not penalizing the constant terms (in this case defining the loss functions as the minimum over the constant term, which becomes non-separable) or (b) using structured output prediction methods that lead to convex surrogates to the area under the ROC curve (AUC) or other precision/recall quantities [13, 14, 15]. These come often with efficient proximal operators (see Section 7 for an example).\nNon-separable regularizers with available efficient proximal operators are numerous, such as groupednorms with potentially overlapping groups, norms based on submodular functions, or total variation (see [16] and references therein, and an example in Section 7).\nRobust optimization. The framework of robust optimization [17] aims at optimizing an objective function with uncertain data. Given that the aim is then to minimize the maximal value of the objective function given the uncertainty, this leads naturally to saddle-point problems.\n1We identify here a matrix with the associated bilinear function.\nConvex relaxation of unsupervised learning. Unsupervised learning leads to convex relaxations which often exhibit structures naturally amenable to saddle-point problems, e.g, for discriminative clustering [18] or matrix factorization [19]."
    }, {
      "heading" : "2.2 Existing batch algorithms",
      "text" : "In this section, we review existing algorithms aimed at solving the composite saddle-point problem in Eq. (1), without using the sum-structure. Note that it is often possible to apply batch algorithms for the associated primal or dual problems (which are not separable in general).\nForward-backward (FB) algorithm. The main iteration is\n(xt, yt) = prox σ M\n[ (xt−1, yt−1)− σ (1/λ 0 0 1/γ ) B(xt−1, yt−1) ]\n= proxσM ( xt−1 − σλ−1∂xK(xt−1, yt−1), yt−1 + σγ−1∂yK(xt−1, yt−1)). Intuitively, the algorithm aims at simultaneously minimizing with respect to x while maximizing with respect to y (when M(x, y) is the sum of isotropic quadratic terms and indicator functions, we get simultaneous projected gradient descent). This algorithm is known not to converge in general [9], but is linearly convergent for strongly-convex-concave problems, when σ = 1/L2, with the rate (1 − 1/(1 + L2))t [20] (see simple proof in Appendix B.1). This is the one we are going to adapt to stochastic variance reduction.\nWhenM(x, y) = f(x)−g(y), we obtain the two parallel updates xt = proxσf ( xt−1−λ−1σ∂xK(xt−1, yt−1 )) and yt = prox σ g ( yt−1+γ−1σ∂yK(xt−1, yt−1 )) , which can de done serially by replacing the second one by yt = prox σ g ( yt−1 + γ−1σ∂yK(xt, yt−1 ))\n. This is often referred to as the Arrow-Hurwicz method (see [21] and references therein).\nExtragradient algorithm. When M is not assumed to be strongly convex-concave, the forwardbackward algorithm may not be convergent. The extragradient algorithm performs two updates at each iteration (see, e.g., [22, 23]), and is then convergent. It is convergent for our problem with a similar worst-case convergence rate [23], but is more robust to step-size selection.\nAccelerated forward-backward algorithm. The forward-backward algorithm may be accelerated by a simple extrapolation step, similar to Nesterov’s acceleration for convex minimization [24]. The algorithm from [21], which only applies to bilinear functions K, and which we extend from separable M to our more general set-up in Appendix B.2, has the following iteration:\n(xt, yt) = prox σ M\n[ (xt−1, yt−1)− σ (1/λ 0 0 1/γ ) B(xt−1 + θ(xt−1 − xt−2), yt−1 + θ(yt−1 − yt−2)) ] .\nWith σ = 1/(2L) and θ = L/(L+ 1), we get an improved convergence rate, where (1−1/(1 + L2))t is replaced by (1− 1/(1 + 2L))t. This is always a strong improvement when L is large (ill-conditioned problems), as illustrated in Section 7. Note that our acceleration technique in Section 5 may be extended to get a similar rate for the batch set-up for non-linear K."
    }, {
      "heading" : "2.3 Existing stochastic algorithms",
      "text" : "Forward-backward algorithms have been studied with added noise [25], leading to a convergence rate in O(1/t) after t iterations for strongly-convex-concave problems. In our setting, we replace B(x, y) in our algorithm with 1πiBi(x, y), where i ∈ I is sampled from the probability vector (πi)i. We have EBi(x, y) = B(x, y); the main iteration is then\n(xt, yt) = prox σt M\n[ (xt−1, yt−1)− σt (1/λ 0 0 1/γ ) 1 πit Bit(xt−1, yt−1) ] ,\nwith it selected independently at random in I with probability vector π. In Appendix C, we show that using σt = 2/(t+1+8L̄(π)\n2) leads to a convergence rate in O(1/t), where L̄(π) is a smoothness constant explicited below. For saddle-point problems, it leads to the complexities shown in Table 1. Like for convex minimization, it is fast early on but the performance levels off. Such schemes are typically used in sublinear algorithms [26]."
    }, {
      "heading" : "2.4 Sampling probabilities, convergence rates and running-time complexities",
      "text" : "In order to characterize running-times, we denote by T (A) the complexity of computing A(x, y) for any operator A and (x, y) ∈ Rn+d, while we denote by Tprox(M) the complexity of computing proxσM (x, y). In our motivating example of bilinear functions K(x, y), we assume that Tprox(M) takes times proportional to n+ d and getting a single element of K is O(1).\nIn order to characterize the convergence rate, we need the Lipschitz-constant L defined earlier as well as a smoothness constant adapted to our sampling schemes:\nL̄(π)2 = sup(x,y,x′,y′) ∑ i∈I 1 πi Ω∗(Bi(x, y)− Bi(x′, y′))2 such that Ω(x− x′, y − y′)2 6 1.\nWe always have the bounds L2 6 L̄(π)2 6 maxi∈I L2i × ∑ i∈I 1 πi . However, in structured situations (like in bilinear saddle-point problems), we get much improved bounds, as described below. Bi-linear saddle-point. The constant L is equal to ‖K‖op/ √ λγ, and we will consider as well the Frobenius norm ‖K‖F defined through ‖K‖2F = ∑ j,k K 2 jk, and the norm ‖K‖max defined as ‖K‖2max = max{supj(KK⊤) 1/2 jj , supk(K ⊤K)1/2kk }. Among the norms above, we always have:\n‖K‖max 6 ‖K‖op 6 ‖K‖F 6 √ max{n, d}‖K‖max 6 √ max{n, d}‖K‖op, (3)\nwhich allows to show below that some algorithms have better bounds than others.\nThere are several schemes to choose the probabilities πjk (individual splits) and πjk = pjqk (factored splits). For the factored formulation where we select random rows and columns, we consider the nonuniform schemes pj = (KK ⊤)jj/‖K‖2F and qk = (K⊤K)kk/‖K‖2F , leading to L̄(π) 6 ‖K‖F/ √ λγ, or uniform, leading to L̄(π) 6 √ max{n, d}‖K‖max/ √ λγ. For the individual formulation where we select random elements, we consider πjk = K 2 jk/‖K‖2F , leading to L̄(π) 6 √ max{n, d}‖K‖F/ √ λγ,\nor uniform, leading to L̄(π) 6 √ nd‖K‖max/ √ λγ (in these situations, it is important to select several elements simultaneously, which our analysis supports).\nWe characterize convergence with the quantity ε = Ω(x − x∗, y − y∗)2/Ω(x0 − x∗, y0 − y∗)2, where (x0, y0) is the initialization of our algorithms (typically (0, 0) for bilinear saddle-points). In Table 1 we give a summary of the complexity of all algorithms discussed in this paper: we recover the same type of speed-ups as for convex minimization. A few points are worth mentioning:\n– Given the bounds between the various norms on K in Eq. (3), SAGA/SVRG with non-uniform sampling always has convergence bounds superior to SAGA/SVRG with uniform sampling, which is always superior to batch forward-backward. Note however, that in practice, SAGA/SVRG with uniform sampling may be inferior to accelerated batch method (see Section 7).\n– Accelerated SVRG with non-uniform sampling is the most efficient method, which is confirmed in our experiments."
    }, {
      "heading" : "3 SVRG: Stochastic Variance Reduction for Saddle Points",
      "text" : "Following [3, 27], we consider a stochastic-variance reduced estimation of the finite sum B(x, y) = ∑\ni∈I Bi(x, y). This is achieved by assuming that we have an iterate (x̃, ỹ) with a known value of B(x̃, ỹ), and we consider the estimate of B(x, y):\nB(x̃, ỹ) + 1πiBi(x, y)− 1 πi Bi(x̃, ỹ),\nwhich has the correct expectation when i is sampled from I with probability π, but with a reduced variance. Since we need to refresh (x̃, ỹ) regularly, the algorithm works in epochs (we allow to sample m elements per updates, i.e., a mini-batch of size m), with an algorithm that shares the same structure than SVRG for convex minimization; see Algorithm 1. Note that we provide an explicit number of iterations per epoch, proportional to (L2 + 3L̄2/m). We have the following theorem, shown in Appendix D.1 (see also a dicussion of the proof in Section 6).\nTheorem 1 Assume (A)-(B)-(C). After v epochs of Algorithm 2, we have:\nE [ Ω(xv − x∗, yv − y∗)2 ] 6 (3/4)vΩ(x0 − x∗, y0 − y∗)2.\nThe computational complexity to reach precision ε is proportional to [ T (B)+(mL2+L̄2)maxi∈I T (Bi)+ (1+L2+ L̄2/m)Tprox(M) ]\nlog 1ε . Note that by taking m large, we can alleviate the complexity of the proximal operator proxM if too large. Moreover, if L\n2 is too expensive to compute, we may replace it by L̄2 but with a worse complexity bound.\nBilinear saddle-point problems. When using a mini-batch size m = 1 with the factored updates, or m = n + d for the individual updates, we get the same complexities proportional to [nd + max{n, d}‖K‖2F/(λγ)] log(1/ε) for non-uniform sampling, which improve significantly over (nonaccelerated) batch methods (see Table 1)."
    }, {
      "heading" : "4 SAGA: Online Stochastic Variance Reduction for Saddle",
      "text" : "Points\nFollowing [4], we consider a stochastic-variance reduced estimation of B(x, y) = ∑\ni∈I Bi(x, y). This\nis achieved by assuming that we store values gi = Bi(x old(i), yold(i)) for an old iterate (xold(i), yold(i)),\nAlgorithm 1 SVRG: Stochastic Variance Reduction for Saddle Points\nInput: Functions (Ki)i, M , probabilities (πi)i, smoothness L̄(π) and L, iterate (x, y) number of epochs v, number of updates per iteration (mini-batch size) m\nSet σ = [ L2 + 3L̄2/m ]−1 for u = 1 to v do Initialize (x̃, ỹ) = (x, y) and compute B(x̃, ỹ) for k = 1 to log 4× (L2 + 3L̄2/m) do Sample i1, . . . , im ∈ I from the probability vector (πi)i with replacement (x, y) ← proxσM [ (x, y)− σ (1/λ 0 0 1/γ )( B(x̃, ỹ) + 1m ∑m k=1 { 1 πik Bik(x, y)− 1πik Bik(x̃, ỹ) })]\nend for end for\nOutput: Approximate solution (x, y)\nand we consider the estimate of B(x, y):\n∑\nj∈I g j + 1πiBi(x, y)− 1 πi gi,\nwhich has the correct expectation when i is sampled from I with probability π. At every iteration, we also refresh the operator values gi ∈ Rn+d, for the same index i or with a new index i sampled uniformly at random. This leads to Algorithm 2, and we have the following theorem showing linear convergence, proved in Appendix D.2. Note that for bi-linear saddle-points, the initialization at (0, 0) has zero cost (which is not possible for convex minimization).\nTheorem 2 Assume (A)-(B)-(C). After t iterations of Algorithm 2 (with the option of resampling when using non-uniform sampling), we have:\nE [ Ω(xt − x∗, yt − y∗)2 ] 6 2 ( 1− (max{ 3|I|2m , 1 + L 2 µ2 + 3 L̄2 mµ2 })−1 )t Ω(x0 − x∗, y0 − y∗)2.\nResampling or re-using the same gradients. For the bound above to be valid for non-uniform sampling, like for convex minimization [28], we need to resample m operators after we make the iterate update. In our experiments, following [28], we considered a mixture of uniform and nonuniform sampling, without a resampling step.\nSAGA vs. SVRG. The difference between the two algorithms is the same as for convex minimization (see, e.g., [29] and references therein), that is SVRG has no storage, but works in epochs and requires slightly more accesses to the oracles, while SAGA is a pure online method with fewer parameters but requires some storage (for bi-linear saddle-point problems, we only need to store O(n+d) elements for the factored splits, while we need O(dn) for the individual splits). Overall they have the same running-time complexity for individual splits; for factored splits, see Appendix D.4.\nFactored splits. When using factored splits, we need to store the two parts of the operator values separately and update them independently, leading in Theorem 2 to replacing |I| by max{|J|, |K|}."
    }, {
      "heading" : "5 Acceleration",
      "text" : "Following the “catalyst” framework of [8], we consider a sequence of saddle-point problems with added regularization; namely, given (x̄, ȳ), we use SVRG to solve approximately\nmin x∈Rd max y∈Rn\nK(x, y) +M(x, y) + λτ2 ‖x− x̄‖2 − γτ 2 ‖y − ȳ‖2, (4)\nAlgorithm 2 SAGA: Online Stochastic Variance Reduction for Saddle Points\nInput: Functions (Ki)i, M , probabilities (πi)i, smoothness L̄(π) and L, iterate (x, y) number of iterations t, number of updates per iteration (mini-batch size) m\nSet σ = [ max{ 3|I|2m − 1, L2 + 3 L̄ 2 m } ]−1 Initialize gi = Bi(x, y) for all i ∈ I and G = ∑ i∈I g i for u = 1 to t do Sample i1, . . . , im ∈ I from the probability vector (πi)i with replacement Compute hk = Bik(x, y) for k ∈ {1, . . . ,m} (x, y) ← proxσM [ (x, y)− σ (1/λ 0 0 1/γ )( G+ 1m ∑m k=1 { 1 πik hk − 1πik g ik })]\n(optional) Sample i1, . . . , im ∈ I uniformly with replacement (optional) Compute hk = Bik(x, y) for k ∈ {1, . . . ,m} Replace G ← G−∑mk=1{gik − hk} and gik ← hk for k ∈ {1, . . . ,m}\nend for Output: Approximate solution (x, y)\nfor well-chosen τ and (x̄, ȳ). The main iteration of the algorithm differs from the original SVRG by the presence of the iterate (x̄, ȳ) and different step-sizes (see details in Appendix D.3). The complexity to get an approximate solution of Eq. (4) (forgetting the complexity of the proximal operator and for a single update), up to logarithmic terms, is proportional, to T (B) + L̄2(1 + τ)−2 maxi∈I T (Bi).\nThe key difference with the convex optimization set-up is that the analysis is simpler, without the need for Nesterov acceleration machinery [24] to define a good value of (x̄, ȳ); indeed, the solution of Eq. (4) is one iteration of the proximal-point algorithm, which is known to converge linearly [30] with rate (1+τ−1)−1 = (1− 11+τ ). Thus the overall complexity is up to logarithmic terms equal to T (B)(1+ τ) + L̄2(1 + τ)−1 maxi∈I T (Bi). The trade-off in τ is optimal for 1 + τ = L̄ √ maxi∈I T (Bi)/T (B), showing that there is a potential acceleration when L̄ √\nmaxi∈I T (Bi)/T (B) > 1, leading to a com-\nplexity L̄ √\nT (B)maxi∈I T (Bi).\nSince the SVRG algorithm already works in epochs, this leads to a simple modification where every log(1 + τ) epochs, we change the values of (x̄, ȳ). See Algorithm 3 in Appendix D.3. Moreover, we can adaptively update (x̄, ȳ) more aggressively to speed-up the algorithm.\nThe following theorem gives the convergence rate of the method (see proof in Appendix D.3). With the value of τ defined above (corresponding to τ = max {\n0, ‖K‖F√ λγ √ max{n−1, d−1} − 1 } for bilinear\nproblems), we get the complexity L̄ √\nT (B)maxi∈I T (Bi), up to the logarithmic term log(1+τ). For bilinear problems, this provides a significant acceleration, as shown in Table 1.\nTheorem 3 Assume (A)-(B)-(C). After v epochs of Algorithm 3, we have, for any positive τ :\nE [ Ω(xv − x∗, yv − y∗)2 ] 6 ( 1− 1τ+1 )v Ω(x0 − x∗, y0 − y∗)2.\nWhile we provide a proof only for SVRG, the same scheme should work for SAGA. Moreover, the same idea also applies to the batch setting (by simply considering |I| = 1, i.e., a single function), leading to an acceleration, but now valid for all functions K (not only bilinear)."
    }, {
      "heading" : "6 Extension to Monotone Operators",
      "text" : "In this paper, we have chosen to focus on saddle-point problems because of their ubiquity in machine learning. However, it turns out that our algorithm, and, more importantly, our analysis extend to all set-valued monotone operators [9, 31]. We thus consider a maximal strongly-monotone operator A on a Euclidean space E, as well as a finite family of Lipschitz-continuous (not necessarily monotone) operators Bi, i ∈ I, with B = ∑\ni∈I Bi monotone. Our algorithm then finds the zeros of A + ∑\ni∈I Bi = A+B, from the knowledge of the resolvent (“backward”) operator (I +σA) −1 (for a well chosen σ > 0) and the forward operators Bi, i ∈ I. There several interesting examples (on which our algorithms apply):\n– Saddle-point problems: We assume for simplicity that λ = γ = µ (this can be achieved by a simple change of variable). If we denote B(x, y) = (∂xK(x, y),−∂yK(x, y)) and the multi-valued operator A(x, y) = (∂xM(x, y),−∂yM(x, y)), then the proximal operator proxσM may be written as (µI + σA)−1(µx, µy), and we recover exactly our framework from Section 2.\n– Convex minimization: A = ∂g and Bi = ∂fi for a strongly-convex function g and smooth functions fi: we recover proximal-SVRG [27] and SAGA [4], to minimize minz∈E g(z)+ ∑\ni∈I fi(z). However, this is a situation where the operators Bi have an extra property called co-coercivity [7], which we are not using because it is not satisfied for saddle-point problems. The extension of SAGA and SVRG to monotone operators was proposed earlier by [32], but only co-coercive operators are considered, and thus only convex minimization is considered (with important extensions beyond plain SAGA and SVRG), while our analysis covers a much broader set of problems. In particular, the step-sizes obtained with co-coercivity lead to divergence in the general setting.\nBecause we do not use co-coercivity, applying our results directly to convex minimization, we would get slower rates, while, as shown in Section 2.1, they can be easily cast as a saddle-point problem if the proximal operators of the functions fi are known, and we then get the same rates than existing fast techniques which are dedicated to this problem [1, 2, 3, 4].\n– Variational inequality problems, which are notably common in game theory (see, e.g., [6])."
    }, {
      "heading" : "7 Experiments",
      "text" : "We consider binary classification problems with design matrix K and label vector in {−1, 1}n, a nonseparable strongly-convex regularizer with an efficient proximal operator (the sum of the squared norm λ‖x‖2/2 and the clustering-inducing term ∑i6=j |xi−xj |, for which the proximal operator may be computed in O(n log n) by isotonic regression [33]) and a non-separable smooth loss (a surrogate to the area under the ROC curve, defined as proportional to ∑\ni+∈I+ ∑ i−∈I−(1 − yi + yj) 2, where\nI+/I− are sets with positive/negative labels, for a vector of prediction y, for which an efficient proximal operator may be computed as well, see Appendix E).\nOur upper-bounds depend on the ratio ‖K‖2F/(λγ) where λ is the regularization strength and γ ≈ n in our setting where we minimize an average risk. Setting λ = λ0 = ‖K‖2F/n2 corresponds to a regularization proportional to the average squared radius of the data divided by 1/n which is standard in this setting [1]. We also experiment with smaller regularization (i.e., λ/λ0 = 10\n−1), to make the problem more ill-conditioned (it turns out that the corresponding testing losses are sometimes slightly better). We consider two datasets, sido (n = 10142, d = 4932, non-separable losses and regularizers presented above) and rcv1 (n = 20242, d = 47236, separable losses and regularizer described in Appendix F, so that we can compare with SAGA run in the primal). We report below the squared distance to optimizers which appears in our bounds, as a function of the number of passes on the data (for more details and experiments with primal-dual gaps and testing losses, see Appendix F). Unless otherwise specified, we always use non-uniform sampling.\n0 100 200 300 400 500\n10 −5\n10 0\nsido − distance to optimizers − λ/λ 0 =1.00\nfb−acc fb−sto saga saga (unif) svrg svrg−acc fba−primal\n0 100 200 300 400 500 10\n−5\n10 0\nsido − distance to optimizers − λ/λ 0 =0.10\nfb−acc fb−sto saga saga (unif) svrg svrg−acc fba−primal\n0 100 200 300 400 500 10\n−15\n10 −10\n10 −5\n10 0\nrcv1 − distance to optimizers − λ/λ 0 =1.00\nfb−acc fb−sto saga saga (unif) svrg svrg−acc fba−primal saga−primal\nWe see that uniform sampling for SAGA does not improve on batch methods, SAGA and accelerated SVRG improve significantly over the existing methods, with a stronger gain for the accelerated version for ill-conditioned problems (middle vs. left plot). On the right plot, we compare to primal methods on a separable loss, showing that primal methods (here “fba-primal”, which is Nesterov acceleration) that do not use separability (and can thus be applied in all cases) are inferior, while SAGA run on the primal remains faster (but cannot be applied for non-separable losses)."
    }, {
      "heading" : "8 Conclusion",
      "text" : "We proposed the first linearly convergent incremental gradient algorithms for saddle-point problems, which improve both in theory and practice over existing batch or stochastic algorithms. While we currently need to know the strong convexity-concavity constants, we plan to explore in future work adaptivity to these constants like already obtained for convex minimization [4], paving the way to an analysis without strong convexity-concavity."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We would like to thank Simon Lacoste-Julien and Jalal Fadili for fruitful discussions related to saddle-point problems and monotone operators."
    }, {
      "heading" : "A Formalization through Monotone Operators",
      "text" : "Throughout the proofs, we will consider only maximal monotone operators on a Euclidean space E, that is A is assumed to be a µ-strongly monotone (corresponding to M for saddle-points) and potentially set-valued, while B is monotone and L-Lipschitz-continuous with respect to the Euclidean norm (and hence single-valued). For an introduction to monotone operators, see [9, 31].\nFor simplicity, in this appendix, we will only consider a single-valued operator A (noting that the proof extends to any set-valued operator A), and we will mostly focus here on the monotonicity properties (noting that the “maximal” can be treated rigorously [9], in particular to ensure that the resolvent operator is defined everywhere). An operator is monotone if and only if for all (z, z′), (A(z)−A(z′))⊤(z − z′) > 0. The most basic example is the subdifferential of a convex function. In this paper, we focus on saddle-point problems.\nApplication to saddle-point problems. For the saddle-point problems defined in Section 2 of the main paper, where we have z = (x, y), we need to make a change of variable because of the two potentially different scaling factors λ and γ. We consider the operators\nB(x, y) = (λ−1/2∂xK(λ −1/2x, γ−1/2y),−γ−1/2∂yK(λ−1/2x, γ−1/2y)) A(x, y) = (λ−1/2∂xM(λ −1/2x, γ−1/2y),−γ−1/2∂yM(λ−1/2x, γ−1/2y)).\nThe solutions of A(x, y) + B(x, y) = 0 are exactly the solutions of the problem in Eq. (1), rescaled by λ1/2 and γ1/2. Moreover, the operator A is 1-monotone, i.e., for any z, z′, we have (A(z) − A(z′))⊤(z − z′) > ‖z− z′‖2. Finally, our definition of the smoothness constants for B and Bi in the main paper, exactly leads to a Lipschitz-constant of L with respect to the natural Euclidean norm (a similar result holds for the constant L̄(π) defined later). Moreover, convergence results in the Euclidean norm here transfer to convergence results in the norm Ω defined in the main paper. Note that because of our proofs through operators, it is not easily possible to get bounds on the primal and dual gaps.\nProperties of monotone operators and resolvents. Given a maximal monotone operator A, we may define its resolvent operator as z′ = (I + σA)−1(z), which is defined as finding z′ such that z′ + σA(z′) = z. When A is the operator associated to the saddle-point function M as described above, then the resolvent operator is exactly the proximal operator of M defined in Eq. (2) of the main paper. Note that care has to be taken with the scaling factors λ and γ.\nWe will use the following properties (on top of Lipschitz-continuity) [9, 31]:\n– Monotonicity property: for any (z, z′), (B(z)−B(z′), z − z′) > 0.\n– Contractivity of the resolvent operator for A µ-strongly-monotone: for any (z, z′), ‖(I+σA)−1(z)− (I + σA)−1(z′)‖ 6 (1 + σµ)−1‖z − z′‖.\n– Firm non-expansiveness of the resolvent: for any (z, z′), ‖(I + σA)−1(z) − (I + σA)−1(z′)‖2 6 (1 + σµ)−1(z − z′)⊤ ( (I + σA)−1(z)− (I + σA)−1(z′) ) .\nMoreover, given our strong-monotonicity assumption, A+B has a unique zero z∗ ∈ E. Finally in order to characterize the running-times, we will consider the complexity Tfw(B) of computing the operator B and the complexity Tbw(A) to compute the resolvent of A. For saddle-point problems, these correspond to T (B) and Tprox(M) from the main paper."
    }, {
      "heading" : "B Proof for Deterministic Algorithms",
      "text" : "All proofs in this section will follow the same principle, by showing that at every step of our algorithms, a certain function (a “Lyapunov” function) is contracted by a factor strictly less than one. For the forward-backward algorithm, this will be the distance to optimum ‖zt − z∗‖2; while for the accelerated version, it will be different.\nB.1 Forward-backward algorithm\nWe consider the iteration zt = (I + σA) −1(zt−1 − σB(zt−1)), with B being monotone L-Lipschitzcontinuous and A being µ-strongly monotone. The optimum z∗ (i.e., the zero of A+B) is invariant by this iteration. Note that this is the analysis of [20] and that we could improve by putting some of the strong-monotonicity in the operator B rather than in A.\nWe have:\n‖zt − z∗‖2\n6 1\n(1 + σµ)2 ‖zt−1 − z∗ − σ(B(zt−1)−B(z∗))‖2 by contractivity of the resolvent,\n= 1\n(1 + σµ)2\n[ ‖zt−1 − z∗‖2 − 2σ(zt−1 − z∗)⊤(B(zt−1)−B(z∗)) + σ2‖B(zt−1)−B(z∗)‖2 ]\n6 1\n(1 + σµ)2 (1 + σ2L2)‖zt−1 − z∗‖2 by monotonicity of and Lipschitz-continuity of B,\n6\n( 1 + σ2L2\n(1 + σµ)2\n)t\n‖z0 − z∗‖2, by applying the recursion t times.\nThus we get linear (i.e., geometric) convergence as soon as 1 + σ2L2 < (1 + σµ)2. If we consider η = σµ1+σµ ∈ [0, 1), and the rate above becomes equal to:\n1 + σ2L2\n(1 + σµ)2 = (1− η)2 + η2L\n2\nµ2 = 1− 2η + η2(1 + L\n2\nµ2 ),\nthus the algorithm converges if η < 2 1+L 2\nµ2\n, and with η = 1 1+L 2\nµ2\nwhich corresponds to σ = 1µ η 1−η = µ L2 ,\nwe get a linear convergence rate with constant 1− η = L2µ2+L2 .\nThus the complexity to reach the precision ε×‖z0− z∗‖2 in squared distance to optimum ‖zt− z∗‖2 is equal to ( 1 + L 2\nµ2 ) [ Tfw(B) + Tbw(A) ] log 1ε .\nNote that we obtain a slow convergence when applied to convex minimization, because we are not using any co-coercivity of B, which would lead to a rate (1− µ/L) [7]. Indeed, co-coercivity means that ‖B(z)−B(z′)‖2 6 L(B(z)−B(z′))⊤(z−z′), and this allows to replace above the term 1+σ2L2 by 1 if σ 6 2/L, leading to linear convergence rate with constant (1 + µ/L)−2 ≈ 1− 2µ/L.\nB.2 Accelerated forward-backward algorithm\nWe consider the iteration zt = (I+σA) −1(zt−1−σB[zt−1+θ(zt−1−zt−2)]), with B being monotone L-Lipschitz-continuous and linear, and A being µ-strongly monotone. Note that this is an extension of the analysis of [21] to take into account the general monotone operator situation. Again z∗ is a fixed-point of the iteration.\nUsing the firm non-expansiveness of the resolvent operator, we get, with η = σµ1+σµ , and then using the linearity of B:\n‖zt − z∗‖2 6 1 1 + σµ (zt − z∗)⊤ [ zt−1 − z∗ − σB[zt−1 − z∗ + θ(zt−1 − zt−2)] ]\n= (zt − z∗)⊤ [ (1 − η)(zt−1 − z∗)− η\nµ B[zt−1 − z∗ + θ(zt−1 − zt−2)]\n]\n= −1− η 2 ‖zt − zt−1‖2 + 1− η 2 ‖zt − z∗‖2 + 1− η 2 ‖zt−1 − z∗‖2\n− η µ (zt − z∗)⊤B[zt−1 − z∗ + θ(zt−1 − zt−2)]\n= −1− η 2 ‖zt − zt−1‖2 + 1− η 2 ‖zt − z∗‖2 + 1− η 2 ‖zt−1 − z∗‖2\n− η µ (zt − z∗)⊤B(zt−1 − z∗)− θ η µ (zt − z∗)⊤B(zt−1 − zt−2),\nby regrouping terms. By using the Lipschitz-continuity of B, we get:\n‖zt − z∗‖2\n6 −1− η 2 ‖zt − zt−1‖2 + 1− η 2 ‖zt − z∗‖2 + 1− η 2 ‖zt−1 − z∗‖2 − η µ (zt − z∗)⊤B(zt−1 − zt)\n−θ η µ (zt−1 − z∗)⊤B(zt−2 − zt−1) + θ η µ L‖zt − zt−1‖‖zt−1 − zt−2‖\n6 −1− η 2 ‖zt − zt−1‖2 + 1− η 2 ‖zt − z∗‖2 + 1− η 2 ‖zt−1 − z∗‖2 − η µ (zt − z∗)⊤B(zt−1 − zt)\n−θ η µ (zt−1 − z∗)⊤B(zt−2 − zt−1) + θL 2 η µ [ α−1‖zt − zt−1‖2 + α‖zt−1 − zt−2‖2 ] ,\nwith a constant α > 0 to be determined later. This leads to, with θ = 1−η1+η , and by regrouping terms:\n1 + η\n2 ‖zt − z∗‖2 + (1− η 2 − θηL 2µ α−1 ) ‖zt − zt−1‖2 − η(zt − z∗)⊤B(zt−1 − zt)\n6 1− η 2 ‖zt−1 − z∗‖2 + (αηθL 2µ ) ‖zt−1 − zt−2‖2 − θ η µ (zt−1 − z∗)⊤B(zt−2 − zt−1)\n6 θ\n[\n1 + η\n2 ‖zt−1 − z∗‖2 +\n(ηαL\n2µ\n) ‖zt−1 − zt−2‖2 − η µ (zt−1 − z∗)⊤B(zt−2 − zt−1)\n]\n.\nWe get a Lyapunov function L : (z, z′) 7→ 1+η2 ‖z − z∗‖2 + ( 1−η 2 − θηL 2µ α −1 ) ‖z − z′‖2 − η(z − z∗)⊤B(z′ − z), such that L(zt, zt−1) converges to zero geometrically, if αηLµ 6 1− η − ηθL µ α −1 and (\n1 + η −ηL/µ ηL/µ 1− η − ηθLµ−1α−1\n)\n< 0. By setting η = 11+2L/µ , and thus θ = 1−η 1+η = 1 1+µ/L , σ =\n1 µ η 1−η = 1 2L , and α = 1, we get the desired first property and the fact that the matrix above is greater\nthan\n(\n1/2 0 0 0\n)\n, which allows us to get a linear rate of convergence for ‖zt − z∗‖2 6 2L(zt, zt−1)."
    }, {
      "heading" : "C Proof for Existing Stochastic Algorithms",
      "text" : "We follow [25], but with a specific step-size that leads to a simple result, which also applies to nonuniform sampling from a finite pool. We consider the iteration zt = (I + σtA)\n−1(zt−1 − σt(Bzt−1 + Ctzt−1)), with B being monotone L-Lipschitz-continuous and A being µ-strongly monotone, and Ct a random operator (not necessarily monotone) such that ECt(z) = 0 for all z. We assume that all random operators Ct are independent, and we denote by Ft the σ-field generated by C1, . . . , Ct, i.e., the information up to time t.\nWe have with Lip(Ct) the Lipschitz-constant of Ct:\n‖zt − z∗‖2 6 1\n(1 + σtµ)2 ‖zt−1 − z∗ − σt(B(zt−1)−B(z∗))− σtCt(zt−1)‖2\nby contractivity of the resolvent,\n= 1\n(1 + σtµ)2\n[\n‖zt−1 − z∗‖2 − 2σt(zt−1 − z∗)⊤(B(zt−1)−B(z∗))\n+σ2t ‖B(zt−1)−B(z∗) + Ct(zt−1)‖2 + 2σt(Ct(zt−1))⊤(zt−1 − z∗) ] .\nBy taking conditional expectations, we get:\nE ( ‖zt − z∗‖2 ∣ ∣Ft−1 ) 6 1\n(1 + σtµ)2 [ (1 + σ2tL 2)‖zt−1 − z∗‖2 + σ2tE(‖Ct(zt−1)‖2|Ft−1) ]\nby monotonicity and Lipschitz-continuity of B,\n6 1\n(1 + σtµ)2 [ (1 + σ2tL 2)‖zt−1 − z∗‖2 + 2σ2tE(‖Ct(z∗)‖2|Ft−1)\n+2σ2t ‖zt−1 − z∗‖2E( sup ‖z−z′‖=1 ‖Ct(z)− Ct(z′)‖2|Ft−1) ]\n= 1\n(1 + σtµ)2 [ (1 + σ2tL 2)‖zt−1 − z∗‖2 + 2σ2tE(‖Ct(z∗)‖2|Ft−1)\n+2σ2t ‖zt−1 − z∗‖2E(Lip(Ct)2|Ft−1) ]\n= 1\n(1 + σtµ)2 [ (1 + σ2tL 2 + 2σ2tE(Lip(Ct) 2|Ft−1))‖zt−1 − z∗‖2 + 2σ2tE(‖Ct(z∗)‖2|Ft−1) ] .\nBy denoting ηt = σtµ 1+σtµ ∈ [0, 1), we get\nE‖zt − z∗‖2 6 ( 1− 2ηt + η2t + 2η2t L2\nµ2 + 2η2t\n1\nµ2 E(Lip(Ct)\n2|Ft−1) ) ‖zt−1 − z∗‖2 + 2 η2t µ2 E(‖Ctz∗‖2|Ft−1) ] .\nBy selecting ηt = 2\n(t+1)+4L 2\nµ2 + 4 µ2 E(Lip(Ct)2|Ft−1)\n= 2t+1+A , with A = 4 L2 µ2 + 4 µ2E(Lip(Ct) 2|Ft−1), we get:\nE‖zt − z∗‖2 6 (1 − ηt)E‖zt−1 − z∗‖2 + 2 η2t µ2 E(‖Ctz∗‖2) ]\n= t− 1 +A t+ 1 +A E‖zt−1 − z∗‖2 + 8 (t+ 1 +A)2 1 µ2 E(‖Ctz∗‖2)\n6 A(1 +A)\n(t+ 1 +A)(t+A) ‖z0 − z∗‖2 +\n8\nµ2\nt ∑\nu=1\n(u+A)(u + 1 +A)\n(t+ 1 +A)(t+A)\n1\n(u + 1 +A)2 E(‖Cuz∗‖2)\nby expanding the recursion t times,\n6 A(1 +A)\n(t+ 1 +A)(t+A) ‖z0 − z∗‖2 +\n8\nµ2\nt ∑\nu=1\n1\n(t+ 1+ A)(t+A) E(‖Cuz∗‖2)\n6 (1 +A)2\n(t+A)2 ‖z0 − z∗‖2 +\n8\nµ2(t+A) sup u∈{1,...,t} E(‖Cuz∗‖2).\nThe overall convergence rate is in O(1/t) and the constant depends on the noise in the operator values at the optimum. Note that initial conditions are forgotten at a rate O(1/t2).\nApplication to sampling from a finite family. When sampling from |I| operators Bi, i ∈ I, and selecting it with probability vector π, then we have E(Lip(Ct)\n2|Ft−1) 6 L̄(π)2 = L̄2 defined as sup‖z−z′‖61 √ ∑ i∈I 1 πi ‖Bi(z)−Bi(z′)‖2. Thus, we can take the step-size 2\nt+1+4L 2+L̄2\nµ2\n, and thus\nσt = 2/µ\nt+1+4L 2+L̄2\nµ2\n. Moreover, if L is unknown (or hard to compute), we can take L̄ instead.\nWe may further bound: E(‖Cuz∗‖2) 6 2E(‖Cuz0‖2) + 2E(Lip(Ct)2)‖z0 − z∗‖2, and thus, if we start from an initial point z0 such that Cuz0 = 0, which is always possible for bi-linear problems, we get an overall bound of (taking L = L̄ for simplicity)\n( (1 + 8L̄2/µ2)2\n(t+ 8L̄2/µ2)2 +\n16L̄2/µ2\nt+ 8L̄2/µ2\n) ‖z0 − z∗‖2 6 1 + 24L̄2/µ2\nt+ 8L̄2/µ2 ‖z0 − z∗‖2.\nWe thus get an overall O(1/t) convergence rate."
    }, {
      "heading" : "D Proof for New Stochastic Algorithms",
      "text" : "We also consider the monotone operator set-up, since this is the only assumption that we use. We follow the proof of the corresponding convex minimization algorithms, with key differences which we highlight below. In particular, (a) we do not use function values, and (b) we use shorter step-sizes to tackle the lack of co-coercivity.\nD.1 SVRG: Stochastic-Variance reduced saddle-point problems (Theorem 1)\nWe only analyze a single epoch starting from the reference estimate z̃, and show that the expected squared distance to optimum is shrunk by a factor of 3/4 if the number of iterations per epoch is well-chosen. The epoch is started with z0 = z̃.\nWe denote by Ft−1 the information up to time t − 1. We consider sampling it1, . . . , itm ∈ I with replacement at time t. By using the contractivity of the resolvent operator of A, and the fact that z∗ = (I + σA)−1(z∗ − σB(z∗)), we get:\n‖zt − z∗‖2 6 1\n(1 + σµ)2\n∥ ∥ ∥ zt−1 − z∗ − σ[B(z̃)−B(z∗) + 1\nm\nm ∑\nk=1\n1\nπitk (Bitk (zt−1)−Bitk (z̃))]\n∥ ∥ ∥ 2\n= 1\n(1 + σµ)2\n∥ ∥ ∥ zt−1 − z∗\n−σ[B(zt−1)−B(z∗) + 1\nm\nm ∑\nk=1\n1\nπitk (Bitk (zt−1)−Bitk(z̃))− (B(zt−1)−B(z̃))]\n∥ ∥ ∥ 2 .\nExpanding the squared norm, taking conditional expectations with E( 1πitk Bitk|Ft−1) = B, and using the independence of it1, . . . , itm, we get:\nE [ ‖zt − z∗‖2|Ft−1 ]\n6 1\n(1 + σµ)2 ( ‖zt−1 − z∗‖2 − 2σ(zt−1 − z∗)⊤(B(zt−1)−B(z∗)) + σ2‖B(zt−1)−B(z∗)‖2 )\n+ 1\nm E\n[ 1\n(1 + σµ)2\n∥ ∥ ∥ 1\nπit (Bit(zt−1)−Bit(z̃))− (B(zt−1)−B(z̃))\n∥ ∥ ∥ 2∣ ∣ ∣ Ft−1 ] .\nUsing the monotonicity of B and the Lipschitz-continuity of B (like in Appendix B.1) , we get the bound\n1 + σ2L2 (1 + σµ)2 ‖zt−1 − z∗‖2 + 1 m E [ 1 (1 + σµ)2 ∥ ∥ 1 πit (Bit(zt−1)−Bit(z̃))− (B(zt−1)−B(z̃)) ∥ ∥ 2∣ ∣Ft−1 ] .\nWe denote by L̄2 the quantity L̄2 = supz,z′∈E 1 ‖z−z′‖2 ∑ i∈I 1 πi ‖Bi(z)−Bi(z′)‖2. We then have (using the fact that a variance is less than the second-order moment):\nE\n[\n∥ ∥\n1\nπit (Bit(zt−1)−Bit(z̃))− (B(zt−1)− B(z̃))\n∥ ∥ 2∣ ∣Ft−1\n]\n6 E\n[\n∥ ∥\n1\nπit (Bit(zt−1)−Bit(z̃))\n∥ ∥ 2∣ ∣Ft−1\n]\n,\nwhich is less than L̄2‖zt−1 − z̃‖2 because we sample i from π. This leads to\nE [ ‖zt − z∗‖2|Ft−1 ] 6 1 + σ2L2\n(1 + σµ)2 ‖zt−1 − z∗‖2 +\n1 (1 + σµ)2 L̄2 m ‖zt−1 − z̃‖2\n6\n( 1− 2η + η2 + η2L 2\nµ2 +\n(1 + a)η2 µ2 L̄2 m ) ‖zt−1 − z∗‖2\n+ (1 + a−1)η2 µ2 L̄2 m ‖z̃ − z∗‖2,\nwith η = σµ1+σµ ∈ [0, 1) and a > 0 to be determined later. Assuming that η ( 1 + L 2 µ2 + (1+a) µ2 L̄2 m ) 6 1, and taking full expectations, this leads to:\nE‖zt − z∗‖2 6 (1− η)E‖zt−1 − z∗‖2 + (1 + a−1)η2 µ2 L̄2 m ‖z̃ − z∗‖2,\nthat is we get a shrinking of the expected distance to optimum with additional noise that depends on the distance to optimum of the reference point z̃. The difference with the convex minimization set-up of [27] is that the proof is more direct, and we get a shrinkage directly on the iterates (we\nhave no choice for monotone operators), without the need to do averaging of the iterates. Moreover, we never use any monotonicity of the operators Bi, thus allowing any type of splits (as long as the sum B is monotone).\nThen, using the fact that z0 = z̃, and expanding the recursion:\nE‖zt − z∗‖2 6 (1 − η)t‖z0 − z∗‖2 + (\nt−1 ∑\nu=0\n(1 − η)u ) (1 + a−1)η2 µ2 L̄2 m ‖z̃ − z∗‖2\n6\n( (1 − η)t + (1 + a −1)η µ2 L̄2 m ) ‖z̃ − z∗‖2.\nIf we take a = 2, η = 1∣ ∣1+L2+3L̄2/(mµ2) , which corresponds to σ = 1µ η 1−η = µ ∣\n∣L2+ 3 m\nL̄2 and t =\nlog 4/η = log 4 × (1 + L2µ2 + 3 L̄ 2 mµ2 ), we obtain a bound of 3/4, that is, after t step in an epoch, we obtain E‖zt − z∗‖2 6 34‖z̃ − z∗‖2, which is the desired result.\nIn terms of running-time, we therefore need a time proportional to T (B)+ ( 1+L 2 µ2 +3 L̄2 mµ2 )( mmaxi T (Bi)+ Tprox(A) ) , times log 1ε to reach precision ε. Note that if L2 is too expensive to compute (because it is a global constant), we may replace it by L̄2 and get a worse bound (but still a valid algorithm).\nD.2 SAGA: Online stochastic-variance reduced saddle-point problems (Theorem 2)\nThe proof follows closely the one of SVRG above. Following the same arguments, we get, by contractivity of the resolvent operator:\n‖zt − z∗‖2 6 1\n(1 + σµ)2\n∥ ∥ ∥ zt−1 − z∗ − σ[ ∑\ni∈I git−1 −B(z∗) +\n1\nm\nm ∑\nk=1\n1\nπitk (Bitk(zt−1)− gitkt−1)]\n∥ ∥ ∥ 2\n= 1\n(1 + σµ)2\n∥ ∥ ∥ zt−1 − z∗ − σ[B(zt−1)−B(z∗)\n+ 1\nm\nm ∑\nk=1\n1\nπitk (Bitk(zt−1)− gitkt−1)− (B(zt−1)−\n∑ i∈I git−1)]\n∥ ∥ ∥ 2 .\nThen, using independence, monotonicity and Lipschitz-continuity of B, we get (note that we never use any monotonicity of Bi), like in the proof of Theorem 1:\nE [ ‖zt − z∗‖2|Ft−1 ] 6 1 + σ2L2\n(1 + σµ)2 ‖zt−1 − z∗‖2\n+ 1\nm E\n[ 1\n(1 + σµ)2 ∥ ∥\n1\nπit (Bit(zt−1)− gitt−1)− (B(zt−1)−\n∑ i∈I git−1) ∥ ∥ 2∣ ∣Ft−1\n]\n6 1 + σ2L2\n(1 + σµ)2 ‖zt−1 − z∗‖2 +\n1\nm\n1\n(1 + σµ)2\n(\n∑\ni∈I\n1\nπi ‖Bi(zt−1)− git−1‖2\n)\n6\n( 1− 2η + η2 + η2L 2\nµ2 +\n(1 + a)η2 µ2 L̄2 m ) ‖zt−1 − z∗‖2\n+ (1 + a−1)η2\nµ2m\n(\n∑\ni∈I\n1\nπi ‖Bi(z∗)− git−1‖2\n)\n,\nwith η = σµ1+σµ . Assuming η ( 1 + L 2 µ2 + (1+a) µ2 L̄2 m ) 6 1, we get\nE [ ‖zt − z∗‖2|Ft−1 ] 6 (1− η)‖zt−1 − z∗‖2 + (1 + a−1)η2\nµ2m\n(\n∑\ni∈I\n1 πi ‖Bi(z∗)− git−1‖2 ) .\nLike in the SVRG proof above, we get a contraction of the distance to optimum, with now an added noise that depends on the difference between our stored operator values and the operator values at the global optimum. We thus need to control this distance by adding the proper factors to a Lyapunov function. Note that we never use any monotonicity of the operators Bi, thus allowing any type of splits (as long as the sum B is monotone).\nWe assume that we update (at most m because we are sampling with replacement and we may sample the same gradient twice) “gradients” git uniformly at random (when we consider uniform sampling, we can reuse the same gradients as dependence does not impact the bound), by replacing them by git = Bi(zt−1). Thus:\nE\n(\n∑\ni∈I\n1\nπi ‖Bi(z∗)− git‖2\n∣ ∣ ∣ Ft−1 )\n= E ( ∑\ni selected\n1\nπi ‖Bi(z∗)−Bi(zt−1)‖2 +\n∑\ni non selected\n1\nπi ‖Bi(z∗)− git−1‖2\n∣ ∣ ∣ Ft−1 )\n=E ( ∑\ni selected\n1\nπi\n( ‖Bi(z∗)− Bi(zt−1)‖2 − ‖Bi(z∗)− git−1‖2 ) + ∑\ni∈I\n1\nπi ‖Bi(z∗)− git−1‖2\n∣ ∣ ∣ Ft−1 ) .\nSince we sample uniformly with replacement, the marginal probabilities of selecting an element i is equal to ρ = 1− (1− 1|I| )m. We thus get\nE\n(\n∑\ni∈I\n1\nπi ‖Bi(z∗)− git‖2\n∣ ∣ ∣ Ft−1 ) 6 (1− ρ) ∑\ni∈I\n1\nπi ‖Bi(z∗)− git−1‖2 + ρ\n∑\ni∈I\n1 πi ‖Bi(z∗)−Bi(zt−1)‖2\n6 (1− ρ) ∑\ni∈I\n1\nπi ‖Bi(z∗)− git−1‖2 + ρL̄2‖zt−1 − z∗‖2.\nTherefore, overall, we have, for a scalar b > 0 to be chosen later:\nE\n(\n‖zt − z∗‖2 + b ∑\ni∈I\n1 πi ‖Bi(z∗)− git‖2\n∣ ∣ ∣ Ft−1 )\n6\n( 1− 2η + η2 + η2L 2\nµ2 +\n(1 + a)η2 µ2 L̄2 m + bρL̄2 ) ‖zt−1 − z∗‖2\n+b ( 1− ρ+ b−1 (1 + a −1)η2\nmµ2\n)\n∑\ni∈I\n1\nπi ‖Bi(z∗)− git−1‖2.\nIf we take a = 2, η = 1 max{ 3|I|\n2m ,1+L\n2\nµ2 +3 L̄\n2 mµ2 } , which corresponds to σ = 1µ η 1−η = µ ∣ ∣max{ 3|I| 2m −1,L2 µ2 +3 L̄ 2 mµ2 } ,\nwith bρL̄2 = 3η4 , then we get the bound (using η 6 1/(L̄ 2/(3m))):\n(1− η 4 )‖zt−1 − z∗‖2 + (1− ρ 3 ) ∑\ni∈I\n1\nπi ‖Bi(z∗)− git−1‖2,\nwhich shows that the function (z, g) 7→ ‖z − z∗‖2 + b ∑ i∈I 1 πi ‖Bi(z∗) − gi‖2 is a good Lyapunov function for the problem that shrinks geometrically in expectation (it resembles the one from convex minimization, but without the need for function values).\nFinally, since we assume that m 6 |I|, we have ρ = 1− (1 − 1/|I|)m > 1− exp(−m/|I|) > m/(2|I|). This leads to, after t iterations\nE‖zt − z∗‖2 6 (1−min{ η 4 , m 6|I|}) t [ ‖z0 − z∗‖2 + 3η 4ρL̄2 ∑\ni∈I\n1\nπi ‖Bi(z∗)−Bi(z0)‖2\n]\n.\nWe have η 6 2m/(3|I|) and 3η/(4ρ) 6 34 2m3|I| 2|I| m 6 1, leading to\nE‖zt − z∗‖2 6 2(1− η\n4 )t‖z0 − z∗‖2,\nwhich is the desired result.\nNote that we get the same overall running-time complexity than for SVRG.\nFactored splits. Note that when applying to saddle-points with factored splits, we need to use a Lyapunov function that considers these splits. The only difference is to treat separately the two parts of the vectors, leading to replacing everywhere |I| by max{|J|, |K|}.\nD.3 Acceleration\nWe also consider in this section a proof based on monotone operators. We first give the algorithm for saddle-point problems.\nAlgorithms for saddle-point problems. At each iteration, we need solve the problem in Eq. (4) of the main paper, with the SVRG algorithm applied to K̃(x, y) = K(x, y)− λτx⊤x̄ + γτy⊤ȳ, and M̃(x, y) = M(x, y)+ λτ2 ‖x‖2− γτ 2 ‖y‖2. These functions lead to constants λ̃ = λ(1+ τ), γ̃ = γ(1+ τ) and L̃ = L/(1 + τ), σ̃ = σ(1 + τ)2. We thus get the iteration, for a single selected operator,\n(x, y) ← proxσ̃ M̃\n[ (x, y)− σ̃ (1/λ̃ 0 0 1/γ̃ )( B̃(x̃, ỹ) + { 1 πi B̃i(x, y)− 1 πi B̃i(x̃, ỹ) })] .\nA short calculation shows that proxσ̃ M̃ (x, y) = prox σ(1+τ)/(1+στ(1+τ)) M ((x, y)/(1+στ(1+ τ))), leading to the update (with σ the step-size from the regular SVRG algorithm in Section 3):\n(x, y) ← proxσ̃ M̃\n[ (x, y) + στ(1 + τ)(x̄, ȳ)− σ(1 + τ) (1/λ 0 0 1/γ )( B(x̃, ỹ) + { 1 πi B̃i(x, y)− 1 πi B̃i(x̃, ỹ) })] .\nThis leads to Algorithm 3, where differences with the SVRG algorithm, e.g., Algorithm 1, are highlighted in red. Given the value of τ , the estimate (x̄, ȳ) is updated every log(1 + τ) epochs of SVRG. While this leads to a provably better convergence rate, in practice, this causes the algorithm to waste time solving with too high precision the modified problem. We have used the simple heuristic of changing (x̄, ȳ) one epoch after the primal-dual gap has been reduced from the previous change of (x̄, ȳ).\nProof of Theorem 3 using monotone operators. We consider τ > 0, and we consider the following algorithm, which is the transposition of the algorithm presented above. We consider a mini-batch m = 1 for simplicity. We consider a set of SVRG epochs, where z̄ remains fixed. These epochs are initialized by z̃ = z̄.\nFor each SVRG epoch, given z and z̃, and starting from z = z̃, we run t iterations of:\nz ← (I + σ(τI +A))−1 ( z − σ[Bz̃ + 1 πi (Biz −Biz̃)− τ z̄] ) ,\nAlgorithm 3 Accelerated Stochastic Variance Reduction for Saddle Points\nInput: Functions (Ki)i, M , probabilities (πi)i, smoothness L̄(π) and L, iterate (x, y) number of epochs v, number of updates per iteration m, acceleration factor τ\nSet σ = [ L2 + 3L̄2/m ]−1\nand (x̄, ȳ) = (x, y) for u = 1 to v do If u = 0 mod ⌈2 + 2 log(1 + τ)/(log 4/3)⌉, set (x̄, ȳ) = (x̃, ỹ) Initialize (x̃, ỹ) = (x, y) and compute B(x̃, ỹ) for k = 1 to log 4× (L2 + 3L̄2/m)(1 + τ)2 do Sample i1, . . . , im ∈ I from probability vector (πi)i with replacement z ← (x, y)+στ(1 + τ)(x̄, ȳ)− σ(1 + τ)\n(1/λ 0 0 1/γ )( B(x̃, ỹ) + { 1 πi B̃i(x, y)− 1πi B̃i(x̃, ỹ) })\n(x, y) ← proxσ(1+τ)/(1+στ(1+τ))M (z/(1 + στ(1 + τ))) end for\nend for Output: Approximate solution (x, y)\nand then update z̃ as z at the end of the SVRG epoch. It corresponds exactly to running the SVRG algorithm to find (τI+A+B)−1(τ z̄) approximately, we know from the proof of Theorem 1 that after log 4 ( 1+ L 2\nµ2(1+τ)2 + L2 µ2(1+τ)2 ) iterations, we have an iterate z such that E‖z−(τI+A+B)−1(τ z̄)‖2 6 3 4E‖z̃− (τI +A+B)−1(τ z̄)‖2. Thus, if we run s epochs where we update z̃ (but not z̄) at each start of epoch, we get an iterate z such that E‖z−(τI+A+B)−1(τ z̄)‖2 6 (34 )sE‖z̄−(τI+A+B)−1(τ z̄)‖2, and thus\nE‖z − (τI +A+B)−1(τ z̄)‖2 6 (3\n4\n)s\nE‖z̄ − (τI +A+B)−1(τ z̄)‖2\n= (3\n4\n)s\nE‖z̄ − z∗ − (τI +A+B)−1(τ z̄) + (τI +A+B)−1(τz∗)‖2\nusing z∗ = (τI +A+B) −1(τz∗),\n= (3\n4\n)s\nE‖z̄ − z∗ − (I + τ−1(A+B))−1(z̄) + (I + τ−1(A+B))−1(z∗)‖2.\nWe may now use the fact that for any multi-valued maximal monotone operator C, I − (I +C)−1 = (I + C−1)−1, which shows that I − (I + C)−1 is 1-Lipschitz-continuous. Thus\nE‖z − (τI +A+B)−1(τ z̄)‖2 6 (3\n4\n)s\nE‖z̄ − z∗‖2.\nThis implies, by Minkowski’s inequality,\n(E‖z − z∗‖2)1/2 6 (E‖z − (τI +A+B)−1(τ z̄)‖2)1/2 + (E‖(τI +A+B)−1(τ z̄)− z∗‖2)1/2\n6\n(3\n4\n)s/2\n(E‖z̄ − z∗‖2)1/2 + (E‖(τI +A+B)−1(τ z̄)− (τI +A+B)−1(τz∗)‖2)1/2\n= (3\n4\n)s/2\n(E‖z̄ − z∗‖2)1/2 + (E‖(I + τ−1(A+B))−1(z̄)− (I + τ−1(A+B))−1(z∗)‖2)1/2\n6\n(3\n4\n)s/2\n(E‖z̄ − z∗‖2)1/2 + 1\n1 + τ−1µ (E‖z̄ − z∗‖2)1/2\n= (3\n4\n)s/2 (E‖z̄ − z∗‖2)1/2 + τ\nτ + µ (E‖z̄ − z∗‖2)1/2,\nusing the fact that the contractivity of resolvents of strongly monotone operators. Thus after s = 2 + 2 log(1+ τ µ )\nlog 4 3\n, we get a decrease by (1− µτ+µ ), and thus the desired result.\nD.4 Factored splits and bi-linear models\nIn the table below, we report the running-time complexity for the factored splits which we used in simulations. Note that SAGA and SVRG then have different bounds. Moreover, all these schemes are adapted when n is close to d. For n much different from d, one could imagine to (a) either complete with zeros or (b) to regroup the data in the larger dimension so that we get as many blocks as for the lower dimension."
    }, {
      "heading" : "E Surrogate to Area Under the ROC Curve",
      "text" : "We consider the following loss function on Rn, given a vector of positive and negative labels, which corresponds to a convex surrogate to the number of misclassified pairs [13, 14]:\nℓ(u) = 1\n2n+n−\n∑\ni+∈I+\n∑\ni−∈I− (1 − ui− + ui+)2\n= 1\n2n+n−\n∑\ni+∈I+\n∑\ni−∈I−\n{\n1 + u2i− + u 2 i+ − 2ui− + 2ui+ − 2ui−ui+\n}\n= 1\n2 +\n1\nn+\n∑\ni+∈I+ ui+ −\n1\nn−\n∑\ni−∈I− ui− +\n1\n2n−\n∑\ni−∈I− u2i− +\n1\n2n+\n∑\ni+∈I+ u2i+ −\n1\nn+n−\n∑\ni+∈I+\n∑\ni−∈I− ui−ui+\n= 1\n2 +\n1\nn+ e⊤+u−\n1\nn− e⊤−u+\n1 2 u⊤Diag( 1 n+ e+ + 1 n− e−)u−\n1\n2n+n− u⊤(e+e ⊤ − + e−e ⊤ +)u\n= 1 2 − a⊤u+ 1 2 u⊤Au,\nwith e+ ∈ Rn the indicator vector of I+ and e− ∈ Rn the indicator vector of I−. We have A = Diag( 1n+ e+ + 1 n− e−) − 1n+n− [ e+e ⊤ − + e−e ⊤ + ]\nand a = e+/n+ − e−/n−. A short calculation shows that the largest eigenvalue of A is 1M = 1 n+ + 1n− . We consider the function h(u) = 12u ⊤Au. It is (1/M)-smooth, its Fenchel conjugate is equal to\n1 2 v⊤A−1v,\nand our function g will be equal to v 7→ 12v⊤A−1v − M2 ‖v‖2. Given that 1 is a singular vector of A, g(v) is finite only when v⊤1n = 0.\nWe need to be able to compute g(v), i.e., solve the system A−1v, and to compute the the proximal operator\nmin v\n1 2 ‖v − v0‖2 + σg(v) = min v 1 2 ‖v − v0‖2 + σ 2 v⊤(A−1 −MI)v,\nwhich leads to to the system: (A−1 − MI + σ−1I)v = σ−1v0, which is equivalent to: (I − MA + σ−1A)v = σ−1Av0 We thus need to compute efficiently Aw, and (I + κA)−1w with κ > −M . We have I + κA = Diag((1 + κ/n+)e+ + (1 + κ/n−)e−)− κ\nn+n−\n[ e+e ⊤ − + e−e ⊤ + ]\n= Diag((1 + κ/n+)e+ + (1 + κ/n−)e−) 1/2\n[ I − κ n+n− ([ 1 √ 1 + κ/n+ e+ ][ 1 √ 1 + κ/n− e− ]⊤ − [ 1 √ 1 + κ/n− e− ][ 1 √ 1 + κ/n+ e+ ]⊤)] Diag((1 + κ/n+)e+ + (1 + κ/n−)e−) 1/2\n= D1/2(I − αu+u⊤− − αu−u⊤+)D1/2, with u⊤+u− = 0 and u+ = e+√ n+ , u− = e−√ n− of norm 1 and D = Diag((1 + κ/n+)e+ + (1 + κ/n−)e−). We have:\nI − αu+u⊤− − αu−u⊤+ = I − u+u⊤+ − u−u⊤− + (u+, u−) ( 1 −α −α 1 ) (u+, u−) ⊤\n(I − αu+u⊤− − αu−u⊤+)−1 = I − u+u⊤+ − u−u⊤− + 1 1− α2 (u+, u−) ( 1 α α 1 ) (u+, u−) ⊤\n= I + (1/(1− α2)− 1)u+u⊤+ + (1/(1− α2)− 1)u−u⊤− + α 1− α2 (u+u ⊤ − + u−u ⊤ +) = I + (1/(1− α2)− 1) 1 n+ e+e ⊤ + + (1/(1− α2)− 1) 1 n− e−e ⊤ −\n+ α 1− α2 1 √ n+n− (e+e ⊤ − + e−e ⊤ +).\nWe have here α = κn+n−\n√\nn+ 1+κ/n+\n√\nn− 1+κ/n− . Thus\n(I + κA)−1 = D−1/2 [ I − u+u⊤+ − u−u⊤− + 1 1− α2 (u+, u−) ( 1 α α 1 ) (u+, u−) ⊤]D−1/2,\nwhich can be done in O(n).\nMoreover, we have\nA = Diag((1/n+)e+ + (1/n−)e−) 1/2\n[ I − 1 n+n− ([√ n+e+ ][√ n−e− ]⊤ − [√ n−e− ][√ n+e+ ]⊤)] Diag((1/n+)e+ + (1/n−)e−) 1/2\n= D1/2(I − u+u⊤− − u−u⊤+)D1/2\nwith u⊤+u− = 0 and u+, u− of norm 1. Thus we have\nI − u+u⊤− − u−u⊤+ = I − u+u⊤+ − u−u⊤− + (u+, u−) ( 1 −1 −1 1 ) (u+, u−) ⊤\n(I − u+u⊤− − u−u⊤+)−1 = I − u+u⊤+ − u−u⊤− + 1\n0 (u+, u−) (1 1 1 1 ) (u+, u−) ⊤.\nThus, if v⊤1n = 0, we get:\nv⊤A−1v = v⊤ Diag(n+e+ + n−e−)v − (v⊤e+)2 − (v⊤e−)2,\nwhich has running-time complexity O(n).\nOptimization problem. With a regularizer f(x) + λ2 ‖x‖2, we obtain the problem:\nmin x∈Rd\nλ 2 ‖x‖2 + f(x) + 1 2 − a⊤Kx+ 1 2 (Kx)⊤A(Kx)\nmin x∈Rd max y∈Rn\nλ 2 ‖x‖2 + f(x) + 1 2 − a⊤Kx+ y⊤Kx− M 2 ‖y‖2 − 1 2 y⊤(A−1 −MI)y,\nwith g(y) = 12y ⊤(A−1 −MI)y."
    }, {
      "heading" : "F Additional Experimental Results",
      "text" : "We complement the results of the main paper in several ways: (a) by providing all test losses, the distance to optimum Ω(x− x∗, y− y∗) in log-scale, as well as the primal-dual gaps in log-scale, as a function of the number of passes on the data. We consider the three machine learning settings:\n– Figure 1: sido dataset, AUC loss and cluster norm (plus squared-norm) regularizer (both non separable).\n– Figure 2: sido dataset, square loss and ℓ1-norm (plus squared-norm) regularizer (both separable).\n– Figure 3: rcv1 dataset, square loss and ℓ1-norm (plus squared-norm) regularizer (both separable).\nWe consider the following methods in all cases (all methods are run with the step-sizes proposed in their respective convergence analysis):\n– fb-acc: accelerated forward-backward saddle-point method from Section 2.2,\n– fb-sto: stochastic forward-backward saddle-point method from Section 2.3,\n– saga: our new algorithm from Section 4, with non-uniform sampling, and sampling of a single row and column per iteration,\n– saga (unif): our new algorithm from Section 4, with uniform sampling, and sampling of a single row and column per iteration,\n– svrg: our new algorithm from Section 3, with non-uniform sampling, and sampling of a single row and column per iteration,\n– svrg-acc: our new accelerated algorithm from Section 3, with non-uniform sampling, and sampling of a single row and column per iteration,\n– fba-primal: accelerated proximal method [11], which can be applied to the primal version of our problem (which is the sum of a smooth term and a strongly convex term).\nMoreover, for the separable cases, we add:\n– saga-primal: SAGA with non-uniform sampling [28], which can only be run with separable losses.\nWe can make the following observations:\n– Non-uniform sampling is key to good performance.\n– The distance to optimum (left plots) exhibits a clear linear convergence behavior (which is predicted by our analysis), which is not the case for the primal-dual gap, which does converge, but more erratically. It would be interesting to provide bounds for these as well.\n– When λ decreases (bottom plots, more ill-conditioned problems), the gains of accelerated methods with respect to non-accelerated ones are unsurprisingly larger. Note that for two out of three settings, the final test loss is smaller for the smaller regularization, and non-accelerated methods need more passes on the data to reach good testing losses.\n– Primal methods which are not using separability (here “fba-primal”) can be run on all instances, but are not competitive. Note that in some situations, they achieve early on good performances (e.g., Figure 2), before getting caught up by stochastic-variance-reduced saddle-point techniques (note also that since these are not primal-dual methods, we compute dual candidates through the gradient of the smooth loss functions, which is potentially disadvantageous).\n– Primal methods that use separability (here “saga-primal”) cannot be run on non-separable problems, but when they can run, they are still significantly faster than our saddle-point techniques. We believe that this is partly due to adaptivity to strong convexity (the convergence bounds for the two sets of techniques are the same for this problem)."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "<lb>We consider convex-concave saddle-point problems where the objective functions may be split<lb>in many components, and extend recent stochastic variance reduction methods (such as SVRG<lb>or SAGA) to provide the first large-scale linearly convergent algorithms for this class of problems<lb>which is common in machine learning. While the algorithmic extension is straightforward, it<lb>comes with challenges and opportunities: (a) the convex minimization analysis does not apply<lb>and we use the notion of monotone operators to prove convergence, showing in particular that<lb>the same algorithm applies to a larger class of problems, such as variational inequalities, (b)<lb>there are two notions of splits, in terms of functions, or in terms of partial derivatives, (c) the<lb>split does need to be done with convex-concave terms, (d) non-uniform sampling is key to an<lb>efficient algorithm, both in theory and practice, and (e) these incremental algorithms can be<lb>easily accelerated using a simple extension of the “catalyst” framework, leading to an algorithm<lb>which is always superior to accelerated batch algorithms.",
    "creator" : "LaTeX with hyperref package"
  }
}