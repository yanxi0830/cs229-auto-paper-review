{
  "name" : "1705.08272.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Matching neural paths: transfer from recognition to correspondence search",
    "authors" : [ "Nikolay Savinov", "Lubor Ladicky", "Marc Pollefeys" ],
    "emails" : [ "nikolay.savinov@inf.ethz.ch", "lubor.ladicky@inf.ethz.ch", "marc.pollefeys@inf.ethz.ch" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Many machine learning tasks require finding per-part correspondences between objects. In this work we focus on low-level correspondences — a highly ambiguous matching problem. We propose to use a hierarchical semantic representation of the objects, coming from a convolutional neural network, to solve this ambiguity. Training it for low-level correspondence prediction directly might not be an option in some domains where the ground-truth correspondences are hard to obtain. We show how transfer from recognition can be used to avoid such training. Our idea is to mark parts as “matching” if their features are close to each other at all the levels of convolutional feature hierarchy (neural paths). Although the overall number of such paths is exponential in the number of layers, we propose a polynomial algorithm for aggregating all of them in a single backward pass. The empirical validation is done on the task of stereo correspondence and demonstrates that we achieve competitive results among the methods which do not use labeled target domain data."
    }, {
      "heading" : "1 Introduction",
      "text" : "Finding per-part correspondences between objects is a long-standing problem in machine learning. The level at which correspondences are established can go as low as pixels for images or millisecond timestamps for sound signals. Typically, it is highly ambiguous to match at such a low level: a pixel or a timestamp just does not contain enough information to be discriminative and many false positives will follow. A hierarchical semantic representation could help to solve the ambiguity: we could choose the low-level match which also matches at the higher levels. For example, a car contains a wheel which contains a bolt. If we want to check if this bolt matches the bolt in another view of the car, we should check if the wheel and the car match as well.\nOne possible hierarchical semantic representation could be computed by a convolutional neural network. The features in such a network are composed in a hierarchical manner: the lower-level features are used to compute higher-level features by applying convolutions, max-poolings and nonlinear activation functions on them. Nevertheless, training such a convolutional neural network for correspondence prediction directly might not be an option in some domains where the ground-truth correspondences are hard and expensive to obtain. This raises the question of scalability of such approaches and motivates the search for methods which do not require training correspondence data.\nTo address the training data problem, we could transfer the knowledge from the source domain where the labels are present to the target domain where no labels or few labeled data are present. The most common form of transfer is from classification tasks. Its promise is two-fold. First, classification labels are one of the easiest to obtain as it is a natural task for humans. This allows to create huge recognition datasets like Imagenet [17]. Second, the features from the low to mid-levels have been shown to transfer well to a variety of tasks [21], [2], [14].\nar X\niv :1\n70 5.\n08 27\n2v 2\n[ cs\n.C V\n] 2\n4 M\nay 2\nAlthough there has been a huge progress in transfer from classification to detection [6], [16], [18], [15], segmentation [11], [1] and other semantic reasoning tasks like single-image depth prediction [3], the transfer to correspondence search has been limited [12], [9], [7].\nWe propose a general solution to unsupervised transfer from recognition to correspondence search at the lowest level (pixels, sound millisecond timestamps). Our approach is to match paths of activations coming from a convolutional neural network, applied on two objects to be matched. More precisely, to establish matching on the lowest level, we require the features to match at all different levels of convolutional feature hierarchy. Those different-level features form paths. One such path would consist of neural activations reachable from the lowest-level feature to the highest-level feature in the network topology (in other words, the lowest level feature lies in the receptive field of the highest level). Since every lowest-level feature belongs to many paths, we do voting based on all of them.\nAlthough the overall number of such paths is exponential in the number of layers and thus infeasible to compute naively, we prove that the voting is possible in polynomial time in a single backward pass through the network. The algorithm is based on dynamic programming and is similar to the backward pass for gradient computation in the neural network.\nEmpirical validation is done on the task of stereo correspondence on two datasets: KITTI 2012 [5] and KITTI 2015 [13]. We quantitatively show that our method is competitive among the methods which do not require labeled target domain data. We also qualitatively show that even dramatic changes in low-level structure can be handled reasonably by our method due to the robustness of the recognition hierarchy: we apply different style transfers [4] to corresponding images in KITTI 2015 and still successfully find correspondences."
    }, {
      "heading" : "2 Notation",
      "text" : "Our method is generally applicable to the cases where the input data has a multi-dimensional grid topology layout. We will assume input objects o to be from the set of B-dimensional grids Φ ⊂ RB and run convolutional neural networks on those grids. The per-layer activations from those networks will be contained in the set of (B + 1)-dimensional grids Ψ ⊂ RB+1. Both the input data and the activations will be indexed by a (B + 1)-dimensional vector x = (x, y, . . . , c) ∈ NB+1, where x is a column index, y is a row index, etc., and c ∈ {1, . . . , C} is the channel index (we will assume C = 1 for the input data, which is a non-restrictive assumption as we will explain later).\nWe will search for correspondences between those grids, thus our goal will be to estimate shifts d ∈ D ⊂ ZB+1 for all elements in the grid. The choice of the shift set D is task-dependent. For example, for sound B = 1 and only 1D shifts can be considered. For images, B = 2 and D could be a set of 1D shifts (usually called a stereo task) or a set of 2D shifts (usually called an optical flow task).\nIn this work, we will be dealing with convolutional neural network architectures, consisting of convolutions, max-poolings and non-linear activation functions (one example of such an architecture is a VGG-net [19], if we omit softmax which we will not use for the transfer). We assume every convolutional layer to be followed by a non-linear activation function throughout the paper and will not specify those functions explicitly.\nThe computational graph of these architectures is a directed acyclic graph G = {A,E}, where A = {a1, . . . , a|A|} is a set of nodes, corresponding to neuron activations (|A| denotes the size of this set), and E = {e1, . . . , e|E|} is a set of arcs, corresponding to computational dependencies (|E| denotes the size of this set). Each arc is represented as a tuple (ai, aj), where ai is the input (origin), aj is the output (endpoint). The node set consists of disjoint layers A = ⋃L `=0A`. The arcs are only allowed to go from the previous layer to the next one.\nWe will use the notation A`(x) for the node in `-th layer at position x; in(x`) for the set of origins x`−1 of arcs, entering layer ` at position x` of the reference object; x`+1 ∈ out(x`) for the set of endpoints of arcs, exiting layer ` at position x` of the reference object. Let f` ∈ F = {maxpool, conv} be the mathematic operator which corresponds to forward computation in layer ` as a ← f`(in(a)), a ∈ A` (with a slight abuse of notation, we use a for both the nodes in the computational graph and the activation values which are computed in those nodes).\nInput\nConvolution\nMax-pooling\nConvolution\nMax-pooling\nk1(d) = 3 k1(d) = 3 k1(d) = 2\nk0(d) = 3 k0(d) = 3 k0(d) = 2\nk2(d) = 1 k2(d) = 1 k2(d) = 1\nk3(d) = 1 k3(d) = 1 k3(d) = 1\nk4(d) = 0 k4(d) = 0 k4(d) = 0\nReference G Searched G′ Shifts\nFigure 1: Four siamese paths are shown. Two of them (red) have the same origin and support the hypothesis of the shift d = 3 for this origin. The other two (green and pink) have different origins and support hypotheses d = 3 and d = 2 for their respective origins."
    }, {
      "heading" : "3 Correspondence via path matching",
      "text" : "We will consider two objects, reference o ∈ Φ and searched o′ ∈ Φ, for which we want to find correspondences. After applying a CNN on them, we get graphs G and G′ of activations. The goal is to establish correspondences between the input-data layers A0 and A′0. That is, every cell A0(x) in the reference object o ∈ Φ has a certain shift d ∈ D in the searched object o′ ∈ Φ, and we want to estimate d.\nHere comes the cornerstone idea of our method: we establish the matching of A0(x) with A′0(x− d) for a shift d if there is a pair of “parallel” paths (we call this pair a siamese path), originating at those nodes and ending at the last layers AL, A′L, which match. This pair of paths must have the same spatial shift with respect to each other at all layers, up to subsampling, and go through the same feature channels with respect to each other. We take the subsampling into account by per-layer functions\nk`(d) = γ`(k`−1(d)), ` = 1, . . . , L, γ`(d̃) =\n⌊ d̃\nq`\n⌋ , k0(d) = d, (1)\nwhere k`(d) is how the zero-layer shift d transforms at layer `, q` is the `-th layer spatial subsampling factor (note that rounding and division on vectors is done element-wise). Then a siamese path P can be represented as\nP = (p, p′), p = (A0(x P 0 ), . . . , AL(x P L )), p ′ = (A′0(x P 0 − k0(d)), . . . , A′L(xPL − kL(d)))\n(2)\nwhere xP0 = x and x P ` denotes the position at which the path P intersects layer ` of the reference activation graph. Such paths are illustrated in Fig. 1. The logic is simple: matching in a siamese path means that the recognition hierarchy detects the same features at different perception levels with the same shifts (up to subsampling) with respect to the currently estimated position x, which allows for a confident prediction of match. The fact that a siamese path is “matched” can be established by computing the matching function (high if it matches, low if not)\nM(P ) = L⊙ `=0 m`(A`(x P ` ), A ′ `(x P ` − k`(d))) (3)\nwhere m`(·, ·) is a matching function for individual neurons (prefers them both to be similar and non-zero at the same time) and is a logical-and-like operator. Both will be discussed later. Since we want to estimate the shift for a node A0(x), we will consider all possible shifts and vote for each of them. Let us denote a set of siamese paths, starting at A`(x) and A′`(x− d) and ending at the last layer, as P`(x,d).\nFor every shift d ∈ D we introduce U(x,d) as the log-likelihood of the event that d is the correct shift, i.e. A0(x) matches A′0(x− d). To collect the evidence from all possible paths, we “sum up” the matching functions for all individual paths, leading to\nU(x,d) = ⊕\nP∈P0(x,d) M(P ) = ⊕ P∈P0(x,d) L⊙ `=0 m`(A`(x P ` ), A ′ `(x P ` − k`(d))) (4)\nwhere the sum-like operator ⊕ will be discussed later. The distribution U(x,d) can be used to either obtain the solution as d∗(x) = arg maxd∈D U(x,d) or to post-process the distribution with any kind of spatial smoothing optimization and then again take the best-cost solution.\nThe obvious obstacle to using the distribution U(x,d) is that Observation 1. If K is the minimal number of activation channels in all the layers of the network and L is the number of layers, the number of paths, considered in the computation of U(x,d) for a single originating node, is Ω(KL) — at least exponential in the number of layers.\nIn practice, it is infeasible to compute U(x,d) naively. In this work, we prove that it is possible to compute U(x,d) in O(|A|+ |E|) — thus linear in the number of layers — using the algorithm which will be introduced in the next section."
    }, {
      "heading" : "4 Linear-time backward algorithm",
      "text" : "Theorem 1. For any m`(·, ·), any ⊕ and which are associative with each other, i.e. a (b⊕ c) = a b⊕ a c, we can compute U(x,d) for all x and d in O(|A|+ |E|).\nProof Since there is associativity, we can use a dynamic programming approach similar to the one developed for gradient backpropagation.\nFirst, let us introduce subsampling functions k`s(d) = γs(k ` s−1(d)), k ` `(d) = d, s ≥ `. Note that k0s = ks as introduced in Eq. 1.\nThen, let us introduce auxiliary variables U`(x`,d) for each layer ` = 0, . . . , L, which have the same definition as U(x,d) except for the fact that the paths, considered in them, start from the later layer `:\nU`(x`,d) = ⊕\nP∈P`(x`,d) M(P ) = ⊕ P∈P`(x`,d) L⊙ s=` ms(As(x P s ), A ′ s(x P s − k`s(d))). (5)\nNote that U(x,d) = U0(x,d). The idea is to iteratively recompute U`(x`,d) based on known U`+1(x`+1, γ`(d)) for all x`+1. Eventually, we will get to the desired U0(x,d).\nThe first step is to notice that all the paths share the same prefix and write it out explicitly:\nU`(x`,d) = ⊕\nP∈P`(x`,d)\nL⊙ s=` ms(As(x P s ), A ′ s(x P s − k`s(d)))\n= ⊕\nP∈P`(x`,d) m`(A`(x`), A\n′ `(x` − d))\n[ L⊙\ns=`+1\nms(As(x P s ), A ′ s(x P s − k`s(d)))\n] .\n(6)\nNow, we want to pull the prefix m`(A`(x`), A′`(x` − d)) out of the “sum”. For that purpose, we will need the set of endpoints out(x`), introduced in the notation in Section 2. The “sum” can be re-written in terms of those endpoints as\nU`(x`,d) = ⊕\nx`+1∈out(x`) P∈P`+1(x`+1,γ`+1(d))\nm`(A`(x`), A ′ `(x` − d))\n[ L⊙\ns=`+1\nms(As(x P s ), A ′ s(x P s − k`s(d)))\n] .\n(7)\nAlgorithm 1 Backward pass 1: procedure BACKWARD(G, G′) 2: for AL(xL) ∈ AL do 3: for d ∈ kL(D) do 4: UL(xL,d)← mL(AL(xL), A′L(xL − d)), . Initialize the last layer. 5: end for 6: end for 7: for ` = L-1, ..., 0 do 8: for A`(x`) ∈ A` do 9: for d ∈ k`(D) do 10: S ← 0, 11: for x`+1 ∈ out(x`) do 12: S ← S ⊕ U`+1(x`+1, γ`+1(d)), 13: end for 14: U`(x`,d)← m`(A`(x`), A′`(x` − d)) S, 15: end for 16: end for 17: end for 18: return U0 . Return the distribution for the first layer. 19: end procedure\nThe last step is to use the associativity of the operator pair⊕ and to pull the prefix out of the “sum”:\nU`(x`,d) = m`(A`(x`), A ′ `(x` − d))\n⊕ x`+1∈out(x`)\nP∈P`+1(x`+1,γ`+1(d))\nL⊙ s=`+1 ms(As(x P s ), A ′ s(x P s − k`s(d)))\n= m`(A`(x`), A ′ `(x` − d)) ⊕ x`+1∈out(x`) U`+1(x`+1, γ`+1(d)). (8)\nThe detailed procedure is listed in Algorithm 1. We use the notation k`(D) for the set of subsampled shifts which is the result of applying function k` to every element of the set of initial shifts D."
    }, {
      "heading" : "5 Choice of neuron matching function m and operators ⊕,",
      "text" : "For the convolutional layers, we use the matching function\nmconv(w, v) = { 0 if w = 0, v = 0, min(w,v) max(w,v) otherwise.\n(9)\nFor the max-pooling layers, the computational graph can be truncated to just one active connection (as only one element influences higher-level features). Moreover, max-pooling does not create any additional features, only passes/subsamples the existing ones. Thus it does not make sense to take into account the pre-activations for those layers as they are the same as activations (up to subsampling). For these reasons, we use\nmmaxpool(w, v) = δ(w = arg maxNw) ∧ δ(v = arg maxNv), (10) where Nw is the neighborhood of max-pooling covering node w, δ(·) is the indicator function (1 if the condition holds, 0 otherwise).\nIn this paper, we use sum as ⊕ and product as . Another possible choice would be max for ⊕ and min or product for — theoretically, those combinations satisfy the conditions in Theorem 1. Nevertheless, we found sum/product combination working better than others. This could be explained by the fact that max as ⊕ would be taken over a huge set of paths which is not robust in practice."
    }, {
      "heading" : "6 Experiments",
      "text" : "We validate our approach in the field of computer vision as our method requires a convolutional neural network trained on a large recognition dataset. Out of the vision correspondence tasks, we\nchose stereo matching to validate our method. For this task, the input data dimensionality is B = 2 and the shift set is represented by horizontal shifts D = {(0, 0, 0), . . . , (Dmax, 0, 0)}. We always convert images to grayscale before running CNNs, following the observation by [24] that color does not help.\nFor pre-trained recognition CNN, we chose the VGG-16 network [19]. This network is summarized in Table 1. We will further refer to layer indexes from this table. It is important to mention that we have not used the whole range of layers in our experiments. In particular, we usually started from layer 2 and finished at layer 8. As such, it is still necessary to consider multi-channel input. To extend our algorithm to this case, we create a virtual input layer with C = 1 and virtual per-pixel arcs to all the real input channels. While starting from a later layer is an empirical observation which improves the results for our method, the advantage of finishing at an earlier layer was discovered by other researchers as well [4] (starting from some layer, the network activations stop being related to individual pixels). We will thus abbreviate our methods as “ours(s, t)” where “s” is the starting layer and “t” is the last layer."
    }, {
      "heading" : "6.1 Experimental setup",
      "text" : "For the stereo matching, we chose the largest available datasets KITTI 2012 and KITTI 2015. All image pairs in these datasets are rectified, so correspondences can be searched in the same row. For each training pair, the ground-truth shift is measured densely per-pixel. This ground truth was obtained by projecting the point cloud from LIDAR on the reference image. The quality measure is the percentage Errt of pixels whose predicted shift error is bigger than a threshold of t pixels. We considered a range of thresholds t = 1, . . . , 5, while the main benchmark measure is Err3. This measure is only computed for the pixels which are visible in both images from the stereo pair.\nFor comparison with the baselines, we used the setup proposed in [24] — the seminal work which introduced deep learning for stereo matching and which currently stays one of the best methods on the KITTI datasets. [24] is an extensive study which has a representative comparison of learning-based and non-learning-based methods under the same setup and open-source code [23] for this setup. The whole pipeline works as follows. First, we obtain the raw scores U(x,d) from Algorithm 1 for the shifts up to Dmax = 228. Then we normalize the scores U(x, ·) per-pixel by dividing them over the maximal score, thus turning them into the range [0, 1], suitable for running the post-processing code [23]. Finally, we run the post-processing code with exactly the same parameters as the original method [24] and measure the quality on the same 40 validation images."
    }, {
      "heading" : "6.2 Baselines",
      "text" : "We have two kinds of baselines in our evaluation: those coming from [24] and our simpler versions of deep feature transfer similar to [12], which do not consider paths.\nThe first group of baselines from [24] are the following: the sum of absolute differences “sad”, the census transform “cens” [22], the normalized cross-correlation “ncc”. We also included the learning-based methods “fst” and “acrt” [24] for completeness, although they use training data to learn features while our method does not.\nFor the second group of baselines, we stack up the activation volumes for the given layer range and up-sample the layer volumes if they have reduced resolution. Then we compute normalized cross-correlation of the stacked features. Those baselines are denoted “corr(s, t)” where “s” is the starting layer, “t” is the last layer. Note that we correlate the features before applying ReLU following what [24] does for the last layer. Thus we use the input to the ReLU inside the layers.\nAll the methods, including ours, undergo the same post-processing pipeline. This pipeline consists of semi-global matching [8], left-right consistency check, sub-pixel enhancement by fitting a quadratic curve, median and bilateral filtering. We refer the reader to [24] for the full description. While the first group of baselines was tuned by [24] and we take the results from that paper, we had to tune the post-processing hyper-parameters of the second group of baselines to obtain the best results."
    }, {
      "heading" : "6.3 KITTI 2012",
      "text" : "The dataset consists of 194 training image pairs and 195 test image pairs. The reflective surfaces like windshields were excluded from the ground truth.\nThe results in Table 2 show that our method “ours(2, 8)” performs better compared to the baselines. At the same time, its performance is lower than learning-based methods from [24]. The main promise of our method is scalability: while we test it on a task where huge effort was invested into collecting the training data, there are other important tasks without such extensive datasets."
    }, {
      "heading" : "6.4 Ablation study on KITTI 2012",
      "text" : "The goal of this section is to understand how important is the deep hierarchy of features versus one or few layers. We compared the following setups: “ours(2, 2)” uses only the second layer, “ours(2, 3)” uses only the range from layer 2 to layer 3, “central(2, 8)” considers the full range of layers but only with central arcs in the convolutions (connecting same pixel positions between activations) taken into account in the backward pass, “ours(2, 8)” is the full method. The result in Table 3 shows that it is profitable to use the full hierarchy both in terms of depth and coverage of the receptive field."
    }, {
      "heading" : "6.5 KITTI 2015",
      "text" : "The stereo dataset consists of 200 training image pairs and 200 test image pairs. The main difference to KITTI 2012 is that the images are colored and the reflective surfaces are present in the evaluation.\nSimilar conclusions to KITTI 2012 can be drawn from experimental results: our method provides a reasonable transfer, being inferior only to learning-based methods — see Table 4. We show our depth map results in Fig. 2."
    }, {
      "heading" : "6.6 Style transfer experiment on KITTI 2015",
      "text" : "The goal of this experiment is to show the robustness of recognition hierarchy for the transfer to correspondence search — something we advocated in the introduction as the advantage of our approach. We apply the style transfer method [4], implemented in the Prisma app. We ran different style transfers on the left and right images. While now very different at the pixel level, the higher level descriptions of the images remain the same which allows to successfully run our method. The qualitative results show the robustness of our path-based method in Fig. 3 (see also Fig. 2 for visual comparison to normal data)."
    }, {
      "heading" : "7 Conclusion",
      "text" : "In this work, we have presented a method for transfer from recognition to correspondence search at the lowest level. For that, we re-use activation paths from deep convolutional neural networks and propose an efficient polynomial algorithm to aggregate an exponential number of such paths. The empirical results on the stereo matching task show that our method is competitive among methods which do not use labeled data from the target domain. It would be interesting to apply this technique to sound, which should become possible once a high-quality deep convolutional model becomes accessible to the public (e.g., [20])."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "Many machine learning tasks require finding per-part correspondences between<lb>objects. In this work we focus on low-level correspondences — a highly ambiguous<lb>matching problem. We propose to use a hierarchical semantic representation of<lb>the objects, coming from a convolutional neural network, to solve this ambiguity.<lb>Training it for low-level correspondence prediction directly might not be an option<lb>in some domains where the ground-truth correspondences are hard to obtain. We<lb>show how transfer from recognition can be used to avoid such training. Our idea is<lb>to mark parts as “matching” if their features are close to each other at all the levels<lb>of convolutional feature hierarchy (neural paths). Although the overall number<lb>of such paths is exponential in the number of layers, we propose a polynomial<lb>algorithm for aggregating all of them in a single backward pass. The empirical<lb>validation is done on the task of stereo correspondence and demonstrates that we<lb>achieve competitive results among the methods which do not use labeled target<lb>domain data.",
    "creator" : "LaTeX with hyperref package"
  }
}