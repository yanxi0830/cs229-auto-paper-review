{
  "name" : "1605.06265.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "End-to-End Kernel Learning with Supervised Convolutional Kernel Networks",
    "authors" : [ "Julien Mairal" ],
    "emails" : [ "julien.mairal@inria.fr" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "In the past years, deep neural networks such as convolutional or recurrent ones have become highly popular for solving various prediction problems, notably in computer vision and natural language processing. Conceptually close to approaches that were developed several decades ago (see, [13]), they greatly benefit from the large amounts of labeled data that have been available recently, allowing to learn huge numbers of model parameters without worrying too much about overfitting. Among other reasons explaining their success, the engineering effort of the deep learning community and various methodological improvements have made it possible to learn in a day on a GPU complex models that would have required weeks of computations on a traditional CPU (see, e.g., [10, 12, 23]).\nBefore the resurgence of neural networks, non-parametric models based on positive definite kernels were one of the most dominant topics in machine learning [22]. These approaches are still widely used today because of several attractive features. Kernel methods are indeed versatile; as long as a positive definite kernel is specified for the type of data considered—e.g., vectors, sequences, graphs, or sets—a large class of machine learning algorithms originally defined for linear models may be used. These include supervised formulations such as support vector machines and unsupervised ones such as principal or canonical component analysis, or K-means and spectral clustering. The problem of data representation is thus decoupled from that of learning theory and algorithms. Kernel methods also admit natural mechanisms to control the learning capacity and reduce overfitting [22].\nOn the other hand, traditional kernel methods suffer from several drawbacks. The first one is their computational complexity, which grows quadratically with the sample size due to the computation of the Gram matrix. Fortunately, significant progress has been achieved to solve the scalability issue,\n∗This work was supported by a grant from ANR (MACARON project ANR-14-CE23-0003- 01) and from the MSR-Inria joint centre.\nar X\niv :1\n60 5.\n06 26\n5v 1\n[ st\nat .M\nL ]\n2 0\nM ay\n2 01\neither by exploiting low-rank approximations of the kernel matrix [28, 31], or with random sampling techniques for shift-invariant kernels [21]. The second disadvantage is more critical; by decoupling learning and data representation, kernel methods seem by nature incompatible with end-to-end learning—that is, the representation of data adapted to the task at hand, which is the cornerstone of deep neural networks and one of the main reason of their success. The main objective of this paper is precisely to tackle this issue in the context of image representations.\nSpecifically, we proceed by generalizing convolutional kernel networks [18]. Similar to hierarchical kernel descriptors [3], local image neighborhoods are represented as points in a reproducing kernel Hilbert space via the kernel trick. Then, hierarchical representations are built via kernel compositions, producing a sequence of “feature maps” akin to convolutional neural networks, but of infinite dimension. To make the image model computationally tractable, convolutional kernel networks provide an approximation scheme that can be interpreted as a particular type of convolutional neural network learned without supervision. So far, it has obtained competitive results for tasks such as image retrieval [20], where it is not clear yet how to use supervised information in practice.\nTo perform end-to-end learning given labeled data, we use a simple but effective principle consisting of learning discriminative subspaces in RKHSs, where we project data. We implement this idea in the context of convolutional kernel networks, where linear subspaces, one per layer, are jointly optimized by minimizing a supervised loss function. The formulation turns out to be a new type of convolutional neural network with a non-standard parametrization. In addition to its interpretation in terms of learning subspaces, the network admits two interesting properties: (i) like any kernel machine, the network comes with a regularization function, the norm in the RKHS; (ii) even though our work focuses on supervised problems, learning the network without supervision—meaning learning the subspaces—may be achieved efficiently with classical kernel approximation techniques [28, 31].\nTo demonstrate the effectiveness of our approach in various contexts, we consider image classification benchmarks such as CIFAR-10 [12] and SVHN [19], which are often used to evaluate deep neural networks; then, we adapt our model to perform super-resolution from a single image, which is a challenging inverse problem. On the SVHN and CIFAR-10 datasets, our classification accuracy is competitive, with about 2% and 10% error rates, respectively, without model averaging or data augmentation. For image up-scaling, our achievement is more impressive since we outperform the state of the art, which was based on classical convolutional neural networks [7, 8].\nWe believe that these results are highly promising. Our image model achieves reasonable accuracy for classification, and achieves better performance than existing approaches for an important image processing problem, paving the way to many other applications. Moreover, our results are also subject to improvements. We have indeed not made any significant engineering effort to optimize our implementation yet; in particular, we did not use GPUs but only CPUs, which has limited our ability to exhaustively explore model hyper-parameters and evaluate the performance of large networks. We also did not investigate classical regularization/optimization techniques such as Dropout [12], batch normalization [11], or recent advances allowing to train very deep networks [10, 23]. We believe that these directions are interesting, and therefore we will consider them in future work. In the meantime, our current CPU implementation will be made available as an open-source software package.\nRelated Deep and Shallow Kernel Machines. One of our goals is to make a bridge between kernel methods and deep networks, and ideally reach the best of both worlds. Given the potentially attractive features of such a combination, several attempts have been made in the past to unify these two schools of thought. A first proof of concept was introduced in [5] with the arc-cosine kernel, which admits an integral representation that can be interpreted as a one-layer neural network with random weights and infinite number of rectified linear units. Besides, a multilayer kernel may be obtained by kernel compositions [5]. Then, hierarchical kernel descriptors [3] and convolutional kernel networks [18] extend a similar idea in the context of images leading to unsupervised representations [18].\nMultiple kernel learning [24] is also related to our work since is it is probably one of the first attempts to introduce supervision in the kernel design. It provides techniques to select a combination of kernels from a pre-defined collection, and typically requires to have already “good” kernels in the collection to perform well. More related to our work, the backpropagation algorithm for the Fisher kernel introduced in [25] learns the parameters of a Gaussian mixture model with supervision. In comparison, our approach does not require a probabilistic model and learns parameters at several layers. Finally, we note that a concurrent effort to ours is conducted in the Bayesian community with deep Gaussian processes [6], complementing the Frequentist approach that we follow in our paper."
    }, {
      "heading" : "2 Learning Hierarchies of Subspaces with Convolutional Kernel Networks",
      "text" : "In this section, we present the principles of convolutional kernel networks and a few generalizations and improvements of the original approach of [18]. Essentially, the model builds upon four ideas that are detailed below and that are illustrated in Figure 1 for a model with a single layer.\nIdea 1: use the kernel trick to represent local image neighborhoods in a RKHS. Given a set X , a positive definite kernel K : X ×X → R implicitly defines a Hilbert spaceH, called reproducing kernel Hilbert space (RKHS), along with a mapping ϕ : X → H. This embedding is such that the kernel value K(x,x′) corresponds to the inner product 〈ϕ(x), ϕ(x′)〉H. Called “kernel trick”, this approach can be used to obtain nonlinear representations of local image patches [3, 18].\nMore precisely, consider an image I0 : Ω0 → Rp0 , where p0 is the number of channels, e.g., p0 = 3 for RGB, and Ω0 ⊂ [0, 1]2 is a set of pixel coordinates, typically a two-dimensional grid. Given two image patches x,x′ of size e0 × e0, represented as vectors in Rp0e 2 0 , we define a kernel K1 as\nK1(x,x ′) = ‖x‖ ‖x′‖κ1 (〈 x ‖x‖ , x′ ‖x′‖ 〉) if x,x′ 6= 0 and 0 otherwise, (1)\nwhere ‖.‖ and 〈., .〉 denote the usual Euclidean norm and inner-product, respectively, and κ1(〈., .〉) is a dot-product kernel on the sphere. Specifically, κ1 should be smooth and its Taylor expansion have non-negative coefficients to ensure positive definiteness [22]. For example, the arc-cosine [5] or the Gaussian (RBF) kernels may be used: given two vectors y,y′ with unit `2-norm, choose for instance\nκ1(〈y,y′〉) = eα1(〈y,y ′〉−1) = e− α1 2 ‖y−y′‖22 . (2)\nThen, we have implicitly defined the RKHSH1 associated to K1 and a mapping ϕ1 : Rp0e 2 0 → H1.\nIdea 2: project onto a finite-dimensional subspace of the RKHS with convolution layers. The representation of patches in a RKHS requires finite-dimensional approximations to be computationally manageable. The original model of [18] does that by exploiting an integral form of the RBF kernel. Specifically, given two patches x and x′, convolutional kernel networks provide two vectors ψ1(x), ψ1(x\n′) in Rp1 such that the kernel value 〈ϕ1(x), ϕ1(x′)〉H1 is close to the Euclidean inner product 〈ψ1(x), ψ1(x′)〉. After applying this transformation to all overlapping patches of the input image I0, a spatial map M1 : Ω0 → Rp1 may be obtained such that for all z in Ω0, M1(z) = ψ1(xz), where xz is the e0 × e0 patch from I0 centered at pixel location z.2 With the approximation scheme of [18], M1 can be interpreted as the output feature map of a one-layer convolutional neural network.\nA drawback of [18] is that data points ϕ1(x1), ϕ1(x2), . . . are approximated by vectors that do not live in the RKHSH1. This issue can be solved by using variants of the Nÿstrom method [28], which consists of projecting data onto a subspace of H1 with finite dimension p1. For this task, we have adapted the algorithm of [31], which is fast and effective: we build a database of n patches x1, . . . ,xn randomly extracted from various images and normalized to have unit `2-norm, and perform a spherical K-means algorithm to obtain p1 centroids z1, . . . , zp1 with unit `2-norm. Then, a new patch x is approximated by its projection onto the p1-dimensional subspace F1 =Span(ϕ(z1), . . . , ϕ(zp1)). The projection of ϕ1(x) onto F1 admits a natural parametrization ψ1(x) in Rp1 such that the kernel value 〈ProjF1 [ϕ1(x)],ProjF1 [ϕ1(x′)]〉H1 for two patches x, x′ is exactly the inner-product 〈ψ1(x), ψ1(x′)〉. The explicit formula is classical (see [28, 31] and Appendix A, which is available with all subsequent appendices in the supplementary material), leading to\nψ1(x) := ‖x‖κ1(Z>Z)−1/2κ1 ( Z> x\n‖x‖\n) if x 6= 0 and 0 otherwise, (3)\nwhere we have introduced the matrix Z = [z1, . . . , zp1 ], and, by an abuse of notation, the function κ1 is applied pointwise to its arguments. With this choice of function ψ1, the spatial mapM1 : Ω0 → Rp1 introduced above can be obtained by (i) computing the quantities Z>x for all patches x of the image I (spatial convolution after mirroring the filters zj); (ii) contrast-normalization involving the norm ‖x‖; (iii) applying the pointwise non-linear function κ1; (iv) applying the linear transform κ1(Z>Z)−1/2 at every pixel location (which may be seen as 1× 1 spatial convolution); (v) multiplying by the norm ‖x‖ making ψ homogeneous. In other words, we obtain a particular convolutional neural network, with non-standard parametrization. Note that learning requires only performing a K-means algorithm and computing the p1 × p1 matrix κ1(Z>Z)−1/2; therefore, the training procedure is very fast.\n2To simplify, we use zero-padding when patches are close to the image boundaries, but this is optional.\nIdea 3: linear pooling inF1 is equivalent to linear pooling on the finite-dimensional mapM1. The previous steps transform an image I0 : Ω0 → Rp0 into a map M1 : Ω0 → Rp1 , where each vector M1(z) in Rp1 encodes a point in F1 representing information of a local image neighborhood centered at location z. Then, convolutional kernel networks involve a pooling step to gain invariance to small shifts, leading to another finite-dimensional map I1 : Ω1 → Rp1 with smaller resolution:\nI1(z) = ∑ z′∈Ω0 M1(z ′)e−β1‖z ′−z‖22 . (4)\nThe Gaussian weight can be interpreted as an anti-aliasing filter for downsampling the map M1 and β1 is set according to the desired subsampling factor (see [18]), which does not need to be integer. This operation is performed on the finite-dimensional map M1, but it is equivalent to pooling the corresponding points in F1. Since F1 is a linear subspace, the vectors I1(z) in Rp1 can indeed be interpreted as points of F1 as well. Note that the linear pooling step was originally motivated in [18] as an approximation scheme for a match kernel, but this point of view is not critically important.\nIdea 4: build a multilayer image representation by stacking and composing kernels. By following the first three principles described above, the input image I0 : Ω0 → Rp0 is transformed into another one I1 : Ω1 → Rp1 . It is then straightforward to apply again the same procedure to obtain another map I2 : Ω2 → Rp2 , then I3 : Ω3 → Rp3 , etc. By going up in the hierarchy, the vectors Ik(z) in Rpk represent larger and larger image neighborhoods (aka. receptive fields) with more invariance gained by the pooling layers, akin to classical convolutional neural networks.\nThe multilayer scheme produces a sequence of maps (Ik)k≥0, where each vector Ik(z) encodes a point—say fk(z)—in the linear subspace Fk ofHk. Thus, the method implicitly represents an image at layer k as a spatial map fk : Ωk → Hk. Moreover, given two vectors Ik(z), I ′k(z′) that encode fk(z), f ′ k(z ′) in Fk, the inner-product 〈Ik(z), I ′k(z′)〉 is equal to 〈fk(z), f ′k(z′)〉Hk . Then, a patch of size ek × ek from Ik can be mapped to a point in the Cartesian product spaceHek×ekk endowed with its natural inner-product; finally, the kernel Kk+1 defined on patches of Ik can be seen as a kernel on image neighborhoods of the input image I0 involving a hierarchical composition of kernel maps."
    }, {
      "heading" : "3 End-to-End Kernel Learning",
      "text" : "In the previous section, we have described a variant of convolutional kernel networks where linear subspaces are learned at every layer. This is achieved without supervision by a K-means algorithm leading to small projection residuals. It is thus natural to introduce also a discriminative approach."
    }, {
      "heading" : "3.1 Backpropagation Rules for Convolutional Kernel Networks",
      "text" : "We now consider a prediction task, where we are given a training set of images I10 , I 2 0 , . . . , I n 0 with respective scalar labels y1, . . . , yn living either in {−1; +1} for binary classification and R for regression. For simplicity, we only present these two settings here, but extensions to multiclass classification and multivariate regression are straightforward. We also assume that we are given a smooth convex loss function L : R× R→ R that measures the fit of a prediction to the true label y. Given a positive definite kernel K on images, the classical empirical risk minimization formulation consists of finding a prediction function in the RKHSH associated to K by minimizing the objective\nmin f∈H\n1\nn n∑ i=1 L(yi, f(I i 0)) + λ 2 ‖f‖2H, (5)\nwhere the parameter λ controls the smoothness of the prediction function f with respect to the geometry induced by the kernel, hence regularizing and reducing overfitting [22]. After training a convolutional kernel network with k layers, such a positive definite kernel may be defined as\nKZ(I0, I ′ 0) = ∑ z∈Ωk 〈fk(z), f ′k(z)〉Hk = ∑ z∈Ωk 〈Ik(z), I ′k(z)〉, (6)\nwhere Ik, I ′k are the k-th finite-dimensional feature maps of I0, I ′ 0, respectively, and fk, f ′ k the corresponding maps in Ωk → Hk, which have been defined in the previous section. The kernel is also indexed by Z , which represents the network parameters—that is, the subspaces F1, . . . ,Fk, or equivalently the set of filters Z1, . . . ,Zk from Eq. (3). Then, formulation (5) becomes equivalent to\nmin W∈Rpk×|Ωk|\n1\nn n∑ i=1 L(yi, 〈W, Iik〉) + λ 2 ‖W‖2F, (7)\nwhere ‖.‖F is the Frobenius norm that extends the Euclidean norm to matrices, and, with an abuse of notation, the maps Iik are seen as matrices in Rpk×|Ωk|. Then, the supervised convolutional kernel network formulation consists of jointly minimizing (7) with respect to W in Rpk×|Ωk| and with respect to the set of filters Z1, . . . ,Zk, whose columns are constrained to be on the sphere.\nComputing the derivative with respect to the filters Z1, . . . ,Zk. Since we consider a smooth loss function L, e.g., logistic, squared hinge, or square loss, optimizing (7) with respect to W can be achieved with any gradient-based method. Moreover, when L is convex, we may also use fast dedicated solvers, (see, e.g., [16], and references therein). Optimizing with respect to the filters Zj , j = 1, . . . , k is more involved because of the lack of convexity. Yet, the objective function is differentiable, and there is hope to find a “good” stationary point by using classical stochastic optimization techniques that have been successful for training deep networks.\nFor that, we need to compute the gradient by using the chain rule—also called “backpropagation” [13]. We instantiate this rule in the next lemma, which we have found useful to simplify the calculation.\nLemma 1 (Simple lemma about backpropagration.) Consider an image I0 represented here as a matrix in Rp0×|Ω0|, associated to a label y in R and call IZk the k-th feature map obtained by encoding I0 with the network parameters Z . Then, consider a perturbation E = {ε1, . . . , εk} of the set of filters Z . Assume that we have for all j ≥ 0,\nIZ+Ej = I Z j + ∆I Z,E j + o(‖E‖), (8)\nwhere ‖E‖ is equal to∑kl=1 ‖εl‖F, and ∆IZ,Ej is a matrix in Rpj×|Ωj | such that for all matrices U of the same size, 〈∆IZ,Ej ,U〉 = 〈εj , gj(U)〉+ 〈∆IZ,Ej−1 , hj(U)〉, (9) where the inner-product is the Frobenius’s one and gj , hj are linear functions. Then,\n∇ZjL(y, 〈W, IZk 〉) = L′(y, 〈W, IZk 〉) gj(hj+1(. . . hk(W)), (10) where L′ denote the derivative of the smooth function L with respect to its second argument.\nThe proof of this lemma is straightforward and follows from the definition of the Fréchet derivative. Nevertheless, it is useful to describe the closed form of the gradient in the next proposition.\nProposition 1 (Gradient of the loss with respect to the the filters Z1, . . . ,Zk.) Consider the quantities introduced in Lemma 1, but denote IZj by Ij for simplicity. By construction, we have for all j ≥ 1,\nIj = Ajκj(Z > j Ej(Ij−1)S −1 j )SjPj , (11)\nwhere Ij is seen as a matrix in Rpj×|Ωj |; Ej is the linear operator that extracts all overlapping ej−1 × ej−1 patches from a map such that Ej(Ij−1) is a matrix of size pj−1e2j−1 × |Ωj−1|; Sj is a diagonal matrix whose diagonal entries carry the `2-norm of the columns of Ej(Ij−1); Aj is short for κj(Z>j Zj)\n−1/2; and Pj is a matrix of size |Ωj−1|× |Ωj | performing the linear pooling operation. Then, the gradient of the loss with respect to the filters Zj , j = 1, . . . , k is given by (10) with\ngj(U) = Ej(Ij−1)B > j −\n1 2 Zj ( κ′j(Z > j Zj) (Cj + C>j ) ) hj(U) = E ? j ( ZjBj + Ej(Ij−1) ( S−2j ( M>j UP > j −Ej(Ij−1)>ZjBj ))) ,\n(12)\nwhere U is any matrix of the same size as Ij , Mj = Ajκj(Z>j Ej(Ij−1)S −1 j )Sj is the j-th feature map before the pooling step, is the Hadamart (elementwise) product, E?j is the adjoint of Ej , and Bj = κ ′ j ( Z>j Ej(Ij−1)S −1 j ) ( AjUP > j ) and Cj = A 1/2 j IjU >A3/2j . (13)\nThe proof is presented in Appendix B. Most quantities above admit physical interpretations: multiplication by Pj performs downsampling; multiplication by P>j performs upsampling; multiplication of Ej(Ij−1) on the right by S−1j performs `2-normalization of the columns; Z > j Ej(Ij−1) can be seen as a spatial convolution of the map Ij−1 by the filters Zj ; finally, E?j “combines” a set of patches into a spatial map by adding to each pixel location the respective patch contributions.\nComputing the gradient requires a forward pass to obtain the maps Ij through (11) and a backward pass that composes the functions gj , hj as in (10). The complexity of the forward step is dominated by the convolutions Z>j Ej(Ij−1), as in convolutional neural networks. The cost of the backward pass is the same as the forward one up to a constant factor. Assuming pj≤|Ωj−1|, which is typical for lower layers that require more computation than upper ones, the most expensive cost is due to Ej(Ij−1)B>j and ZjBj which is the same as Z > j Ej(Ij−1). We also pre-compute A 1/2 j and A 3/2 j by eigenvalue decompositions, whose cost is negligible when performed only once per minibatch. Off-diagonal elements of M>j UP > j −Ej(Ij−1)>ZjBj are also not computed since they are set to zero after elementwise multiplication with a diagonal matrix. In practice, we also replace Aj by (κj(Z > j Zj) + εI)\n−1/2 with ε= 0.001, which corresponds to performing a regularized projection onto Fj (see Appendix A). Finally, a small offset of 0.00001 is added to the diagonal entries of Sj .\nOptimizing hyper-parameters for RBF kernels. When using the kernel (2), the objective is differentiable with respect to the hyper-parameters αj . When large amounts of training data are available and overfitting is not a issue, optimizing the training loss by taking gradient steps with respect to these parameters seems appropriate instead of using a canonical parameter value. Otherwise, more involved techniques may be needed [4]; we plan to investigate such strategies in future work."
    }, {
      "heading" : "3.2 Optimization and Practical Heuristics",
      "text" : "The backpropagation rules of the previous section have set up the stage for using a stochastic gradient descent method (SGD). We now present a few strategies to accelerate it in our context.\nHybrid convex/non-convex optimization. Recently, many incremental optimization techniques have been proposed for solving convex optimization problems of the form (7) when n is large but finite (see [16] and references therein). These methods usually provide a great speed-up over the stochastic gradient descent algorithm without suffering from the burden of choosing a learning rate. The price to pay is that they rely on convexity, and they require storing into memory the full training set. For solving (7) with fixed network parameters Z , it means storing the n maps Iik, which is often reasonable if we do not use data augmentation. To partially leverage these fast algorithms for our non-convex problem, we have adopted a minimization scheme that alternates between two steps: (i) fix Z , then make a forward pass on the data to compute the n maps Iik and minimize the convex problem (7) with respect to W using the accelerated MISO algorithm [16]; (ii) fix W, then make one pass of a projected stochastic gradient algorithm to update the k set of filters Zj . The set of network parameters Z is initialized with the unsupervised learning method described in Section 2.\nPreconditioning on the sphere. The kernels κj are defined on the sphere; therefore, it is natural to constrain the filters—that is, the columns of the matrices Zj—to have unit `2-norm. As a result, a classical stochastic gradient descent algorithm updates at iteration t each filter z as follows z← Proj‖.‖2=1[z−ηt∇zLt], where∇zLt is an estimate of the gradient computed on a minibatch and ηt is a learning rate. In practice, we found that convergence could be accelerated by preconditioning, which consists of optimizing after a change of variable to reduce the correlation of gradient entries. For unconstrained optimization, this heuristic involves choosing a symmetric positive definite matrix Q and replacing the update direction ∇zLt by Q∇zLt, or, equivalently, performing the change of variable z = Q1/2z′ and optimizing over z′. When constraints are present, the case is not as simple since Q∇zLt may not be a descent direction. Fortunately, it is possible to exploit the manifold structure of the constraint set (here, the sphere) to perform an appropriate update [1]. Concretely, (i) we choose a matrix Q per layer that is equal to the inverse covariance matrix of the patches from the same layer computed after the initialization of the network parameters. (ii) We perform stochastic gradient descent steps on the sphere manifold after the change of variable z = Q1/2z′, leading to the update z← Proj‖.‖2=1[z− ηt(I− (1/z>Qz)Qzz>)Q∇zLt]. Because this heuristic is not a critical component, but simply an improvement of SGD, we relegate mathematical details in Appendix C.\nAutomatic learning rate tuning. Choosing the right learning rate in stochastic optimization is still an important issue despite the large amount of work existing on the topic, see, e.g., [13] and references therein. In our paper, we use the following basic heuristic: the initial learning rate ηt is chosen “large enough”; then, the training loss is evaluated after each update of the weights W. When the training loss increases between two epochs, we simply divide the learning rate by two, and perform “back-tracking” by replacing the current network parameters by the previous ones.\nActive-set heuristic. For classification tasks, “easy” samples have often negligible contribution to the gradient (see, e.g., [13]). For instance, for the squared hinge loss L(y, ŷ) = max(0, 1− yŷ)2, the gradient vanishes when the margin yŷ is greater than one. This motivates the following heuristic: we consider a set of active samples, initially all of them, and remove a sample from the active set as soon as we obtain zero when computing its gradient. In the subsequent optimization steps, only active samples are considered, and after each epoch, we randomly reactivate 10% of the inactive ones."
    }, {
      "heading" : "4 Experiments",
      "text" : "We now present two image-related tasks. We start with classification, where we obtain reasonably competitive accuracy and then move to super-resolution, where we achieve state-of-the-art results. All experiments were conducted on 8-core and 10-core 2.4GHz Intel CPUs using C++ and Matlab."
    }, {
      "heading" : "4.1 Image Classification on “Deep Learning” Benchmarks",
      "text" : "We consider the datasets CIFAR-10 [12] and SVHN [19], which contain 32 × 32 images from 10 classes. CIFAR-10 is medium-sized with 50 000 training samples and 10 000 test ones. SVHN is larger with 604 388 training examples and 26 032 test ones. We evaluate the performance of a 9-layer network, designed with few hyper-parameters: for each layer, we learn 512 filters and choose the RBF kernels κj defined in (2) with initial parameters αj=1/(0.52). Layers 1, 3, 5, 7, 9 use 3×3 patches and a subsampling pooling factor of √ 2 except for layer 9 where the factor is 3; Layers 2, 4, 6, 8 use simply 1× 1 patches and no subsampling. For CIFAR-10, the parameters αj are kept fixed during training, and for SVHN, they are updated in the same way as the filters. We use the squared hinge loss in a one vs all setting to perform multi-class classification (with shared filters Z between classes). The input of the network is pre-processed with the local whitening procedure described in [20]. We use the optimization heuristics from the previous section, notably the automatic learning rate scheme, and a gradient momentum with parameter 0.9, following [12]. The regularization parameter λ and the number of epochs are set by first running the algorithm on a 80/20 validation split of the training set. λ is chosen near the canonical parameter λ = 1/n, in the range 2i/n, with i = −4, . . . , 4, and the number of epochs is at most 100. The initial learning rate is 10 with a minibatch size of 128.\nWe present our results in Table 1 along with the performance achieved by a few recent methods without data augmentation or model voting/averaging. In this context, the best published results are obtained by the generalized pooling scheme of [14]. We achieve about 2% test error on SVHN and about 10% on CIFAR-10, which positions our method as a reasonably “competitive” one, in the same\nballpark as the deeply supervised nets of [15] or network in network of [17]. We believe that these results demonstrate that our supervised kernel machine is a promising proof of concept. For the future, we are planning to use GPUs, in order to explore more architectures, conduct experiments on larger datasets such as ILSVRC, and evaluate various data augmentation/model combination schemes."
    }, {
      "heading" : "4.2 Image Super-Resolution from a Single Image",
      "text" : "Image up-scaling is a challenging problem, where convolutional neural networks have obtained significant success [7, 8, 27]. Here, we follow [8] and replace traditional convolutional neural networks by our supervised kernel machine. Specifically, RGB images are converted to the YCbCr color space and the upscaling method is applied to the luminance channel only to make the comparison possible with previous work. Then, the problem is formulated as a multivariate regression one. We build a database of 200 000 patches of size 32× 32 randomly extracted from the BSD500 dataset [2] after removing image 302003.jpg, which overlaps with one of the test images. 16× 16 versions of the patches are build using the Matlab function imresize, and upscaled back to 32× 32 by using bicubic interpolation; then, the goal is to predict high-resolution images from blurry bicubic interpolations.\nThe blurry estimates are processed by a 9-layer network, with 3× 3 patches and 128 filters at every layer without linear pooling and zero-padding. Pixel values are predicted with a linear model applied to the 128-dimensional vectors present at every pixel location of the last layer, and we use the square loss to measure the fit. The optimization procedure and the kernels κj are identical to the ones used for processing the SVHN dataset in the classification task. The pipeline also includes a pre-processing step, where we remove from input images a local mean component obtained by convolving the images with a 5× 5 averaging box filter; the mean component is added back after up-scaling. For the evaluation, we consider three datasets: Set5 and Set14 are standard for super-resolution; Kodim is the Kodak Image database, available at http://r0k.us/graphics/kodak/, which contains high-quality images with no compression or demoisaicing artefacts. The evaluation procedure follows [7, 8, 26, 27] by using the code from the author’s web page. We present quantitative results in Table 2. For x3 upscaling, we simply used twice our model learned for x2 upscaling, followed by a 3/4 downsampling. This is clearly suboptimal since our model is not trained to up-scale by a factor 3, but this naive approach still outperforms other baselines [7, 8, 27] that are trained end-to-end. Note that [27] also proposes a data augmentation scheme at test time that slightly improves their results. In Appendix D, we also present a visual comparison between our approach and [8], whose pipeline is the closest to ours, up to the use of a supervised kernel machine instead of CNNs."
    }, {
      "heading" : "5 Conclusion",
      "text" : "In this paper, we have made a significant step to close the gap in performance between deep neural networks and kernel methods. We have extended convolutional kernel networks to perform end-to-end learning, resulting in better results and truly deep representations, whereas the original convolutional kernel networks used three layers at most. We also believe that the subspace learning interpretation of our network has some interest and opens new perspectives, which we have not investigated yet, such as models based on union of subspaces, spectral approaches, or projections on random subspaces."
    }, {
      "heading" : "A Orthogonal Projection on the Finite-Dimensional Subspace F1",
      "text" : "First, we remark that the kernel K1 is homogeneous such that for every patch x and scalar γ > 0,\nϕ1(γx) = γϕ1(x).\nThus, we may assume x to have unit `2-norm without loss of generality and perform the projection on F1 = Span(ϕ(z1), . . . , ϕ(zp1)) of the normalized patch, before applying the inverse rescaling. Then, let us denote by fx the orthogonal projection of a patch x with unit `2-norm defined as\nfx := arg min f∈F1\n‖ϕ1(x)− f‖2H1 ,\nwhich is equivalent to\nfx := p1∑ j=1 α?jϕ1(zj) with α ? ∈ arg min α∈Rp1 ∥∥∥∥∥∥ϕ1(x)− p1∑ j=1 αjϕ1(zj) ∥∥∥∥∥∥ 2\nH1\n.\nAfter short calculation, we obtain\nfx = p1∑ j=1 α?jϕ1(zj) with α ? ∈ arg min α∈Rp1 [ 1− 2α>κ1(z>x) +α>κ1(Z>Z)α ] ,\nsince the vectors zj provided by the spherical K-means algorithm have unit `2-norm. Assuming κ1(Z\n>Z) to be invertible, we haveα? = κ1(Z>Z)−1κ1(Z>x). After projection, normalized patches x, x′ may be parametrized by α? = κ1(Z>Z)−1κ1(Z>x) and α′? = κ1(Z>Z)−1κ1(Z>x′), and then, we have 〈fx, fx′〉H1 = α?>κ1(Z>Z)α′? = 〈ψ1(x), ψ1(x′)〉, which is the desired result.\nWhen κ1(Z>Z) is not invertible or simply badly conditioned, it is also common to use instead\nψ1(x) = ( κ1(Z >Z) + εI )−1/2 κ1(Z >x),\nwhere ε > 0 is a small regularization that improves the condition number of κ1(Z>Z). Such a modification can be interpreted as performing a slightly regularized projection onto the finitedimensional subspace F1."
    }, {
      "heading" : "B Computation of the Gradient with Respect to the Filters",
      "text" : "To compute the gradient of the loss function, we use Lemma 1 and start by analyzing the effect of perturbing every quantity involved in (11) such that we may obtain the desired relations (8) and (9). Before proceeding, we recall the definition of the set Z + E = {Z1 + ε1, . . . ,Zk + εk} and the precise definition of the Landau notation o(‖E‖), which we use in (8). Here, it simply means a quantity that is negligible in front of the norm ‖E‖ = ∑kj=1 ‖εj‖F—that is,\nlim E→0 ∥∥∥IZ+Ej − IZj −∆IZ,Ej ∥∥∥F ‖E‖ = 0.\nThen, we start by initializing a recursion: IZ0 is unaffected by the perturbation and thus ∆I Z,E 0 = 0. Consider now an index j > 0 and assume that (8) holds for j − 1 with ∆IZ,Ej−1 = O(‖E‖). First, we remark that\nEj(I Z+E j−1 ) = Ej(I Z j−1) + Ej(∆I Z,E j−1) + o(‖E‖).\nThen, the diagonal matrix Sj becomes after perturbation\nSj + S −1 j ( Ej(I Z j−1) >Ej(∆I Z,E j−1) ) ︸ ︷︷ ︸\n∆Sj\n+o(‖E‖).\nThe inverse diagonal matrix S−1j becomes\nS−1j −S−3j ( Ej(I Z j−1) >Ej(∆I Z,E j−1) ) ︸ ︷︷ ︸\n∆S−1j\n+o(‖E‖),\nand the matrix Aj becomes\nκj ( (Zj+εj) >(Zj+εj) )− 12 = κj(Z>j Zj+ε>j Zj+Z>j εj + o(‖εj‖F)))− 12\n= ( κj ( Z>j Zj ) +κ′j ( Z>j Zj ) ( Z>j εj+ε > j Zj ) +o(‖E‖) )− 12 = A\n1 2 j ( I+Aj ( κ′j ( Z>j Zj ) ( Z>j εj+ε > j Zj )) Aj+o(‖E‖) )−1/2 A 1 2 j\n= Aj − 1\n2 A\n3 2 j ( κ′j ( Z>j Zj ) ( Z>j εj+ε > j Zj )) A\n3 2 j︸ ︷︷ ︸\n∆Aj\n+o(‖E‖),\nwhere we have used the relation (I + Q)−1/2 = I − 12Q + o(‖Q‖F). Note that the quantities ∆Aj ,∆Sj ,∆S −1 j that we have introduced are all O(‖E‖). Then, by replacing the quantities Aj ,Sj ,S −1 j , Ij−1 by their perturbed versions in the definition of Ij given in (11), we obtain that IZ+Ej is equal to\n(Aj+∆Aj)κj ( (Zj+εj) > ( Ej(I Z j−1)+Ej(∆I Z,E j−1) ) (S−1j +∆S −1 j ) ) (Sj+∆Sj)Pj+o(‖E‖).\nThen, after short calculation, we obtain the desired relation IZ+Ej = I Z+E j + ∆I Z,E j + o(‖E‖) with\n∆IZ,Ej =∆Ajκj(Z > j Ej(I Z j−1)S −1 j )SjPj + Aj ( κ′j(Z > j Ej(I Z j−1)S −1 j ) (ε>j Ej(IZj−1)) ) Pj\n+ Aj ( κ′j(Z > j Ej(I Z j−1)S −1 j ) (Z>j Ej(∆IZ,Ej−1)) ) Pj\n+ Aj ( κ′j(Z > j Ej(I Z j−1)S −1 j ) (Z>j Ej(IZj−1)∆S−1j Sj) ) Pj + Ajκj(Z > j Ej(I Z j−1)S −1 j )∆SjPj .\nFirst, we remark that ∆IZ,Ej = O(‖E‖), which is one of the induction hypothesis we need. Then, after plugging in the values of ∆Aj ,∆Sj ,∆S−1j , and with further simplification, we obtain\n∆IZ,Ej = − 1\n2 A\n3 2 j ( κ′j ( Z>j Zj ) ( Z>j εj + ε > j Zj )) A 1 2 j I Z j\n+ Aj ( κ′j(Z > j Ej(I Z j−1)S −1 j ) ( ε>j Ej(I Z j−1) )) Pj\n+ Aj ( κ′j(Z > j Ej(I Z j−1)S −1 j ) ( Z>j Ej(∆I Z,E j−1) )) Pj\n−Aj ( κ′j(Z > j Ej(I Z j−1)S −1 j ) ( Z>j Ej(I Z j−1) ( S−2j ( Ej(I Z j−1) >Ej(∆I Z,E j−1) )))) Pj\n+MZj ( S−2j ( Ej(I Z j−1) >Ej(∆I Z,E j−1) )) Pj ,\nwhere MZj is the j-th feature map of I0 before the j-th linear pooling step—that is, I Z j = M Z j Pj . We now see that ∆IZ,Ej is linear in εj and ∆I Z,E j−1 , which guarantees that there exist two linear functions gj , hj that satisfy (9). More precisely, we want for all matrix U of the same size as ∆I Z,E j\n〈εj , gj(U)〉 = 〈 −1\n2 A\n3 2 j ( κ′j ( Z>j Zj ) ( Z>j εj + ε > j Zj )) A 1 2 j I Z j ,U 〉 + 〈 Aj ( κ′j(Z > j Ej(I Z j−1)S −1 j ) ( ε>j Ej(I Z j−1) )) Pj ,U 〉 ,\nand 〈∆IZ,Ej−1 , hj(U)〉 = 〈 Aj ( κ′j(Z > j Ej(I Z j−1)S −1 j ) ( Z>j Ej(∆I Z,E j−1) )) Pj ,U 〉 − 〈 Aj ( κ′j(Z > j Ej(I Z j−1)S −1 j ) ( Z>j Ej(I Z j−1) ( S−2j ( Ej(I Z j−1) >Ej(∆I Z,E j−1) )))) Pj ,U\n〉 + 〈 MZj ( S−2j ( Ej(I Z j−1) >Ej(∆I Z,E j−1) )) Pj ,U 〉 .\nThen, it is easy to obtain the form of gj , hj given in (12), by using in the right order the following elementary calculus rules: (i) 〈UV,W〉 = 〈U,WV>〉 = 〈V,U>W〉, (ii) 〈U,V〉 = 〈U>,V>〉, (iii) 〈U V,W〉 = 〈U,V W〉 for any matrices U,V,W of appropriate sizes, and also (iv) 〈Ej(U),V〉 = 〈U,E?j (V)〉, by definition of the adjoint operator. We conclude by induction."
    }, {
      "heading" : "C Preconditioning Heuristic on the Sphere",
      "text" : "In this section, we present a preconditioning heuristic for optimizing over the sphere Sp−1, inspired by second-order (Newton) optimization techniques on smooth manifolds [1]. Following [1], we will consider gradient descent steps on the manifold. A fundamental operation is thus the projection operator Pz onto the tangent space at a point z. This operator is defined for the sphere by\nPz[u] = (I− zz>)u, for any vector u in Rp. Another important operator is the Euclidean projection on Sp−1, which was denoted by Proj‖.‖2=1 in previous parts of the paper.\nGradient descent on the sphere Sp−1 is equivalent to the projected gradient descent in Rp. When optimizing on a manifold, the natural descent direction is the projected gradient Pz∇L(z). In the case of the sphere, a gradient step on the manifold is equivalent to a classical projected gradient descent step in Rp with particular step size:\nProj‖.‖2=1[z− ηPz[∇L(z)]] = Proj‖.‖2=1 [ z− η ( I− zz> ) ∇L(z) ] = Proj‖.‖2=1 [( 1 + ηz>∇L(z) ) z− η∇L(z)\n] = Proj‖.‖2=1 [ z− η 1 + ηz>∇L(z)∇L(z) ] ."
    }, {
      "heading" : "In Rp with no constraint, pre-conditioning is equivalent to performing a change of variable.",
      "text" : "For unconstrained optimization in Rp, faster convergence is usually achieved when one has access to an estimate of the inverse of the Hessian ∇2L(z)—assuming twice differentiability—and using the descent direction (∇2L(z))−1∇L(z) instead of ∇L(z); then, we obtain a Newton method. When the exact Hessian is not available, or too costly to compute and/or invert, it is however common to use instead a constant estimate of the inverse Hessian, denoted here by Q, which we call pre-conditioning matrix. Finding an appropriate matrix Q is difficult in general, but for learning linear models, a typical choice is to use the inverse covariance matrix of the data (or one approximation). In that case, the preconditioned gradient descent step consists of the update z− ηQ∇L(z). Such a matrix Q is defined similarly in the context of convolutional kernel networks, as explained in the main part of the paper. A useful interpretation of preconditioning is to see it as optimizing after a change of variable. Define indeed the objective\nL̃(w) = L(Q1/2w).\nThen, minimizing L̃ is equivalent to minimizing L with respect to z, with the relation z = Q1/2w. Moreover, when there is no constraint on z and w, the regular gradient descent algorithm on L̃ is equivalent to the preconditioned gradient descent on L:\nw← w − η∇L̃(w)⇐⇒ w← w − ηQ1/2∇L(Q1/2w) ⇐⇒ z← z− ηQ∇L(z) with z = Q1/2w.\nWe remark that the Hessian ∇2L̃(w) is equal to Q1/2∇2L(Q1/2w)Q1/2, which is equal to identity when Q coincides with the inverse Hessian of L. In general, this is of course not the case, but the hope is to obtain a Hessian∇2L̃ that is better conditioned than∇2L, thus resulting in faster convergence.\nPreconditioning on a smooth manifold requires some care. Unfortunately, using second-order information (or simply a pre-conditioning matrix) when optimizing over a constraint set or over a smooth manifold is not as simple as optimizing in Rp since the quantities Q∇L(z), Pz[Q∇L(z)],QPz[∇L(z)] may not be feasible descent directions. However, the point of view that sees pre-conditioning as a change of variable will give us the right direction to follow.\nOptimizing L on Sp−1 is in fact equivalent to optimizing L̃ on the smooth manifold S̃p−1 = { w ∈ Rp : ‖Q1/2w‖2 = 1 } ,\nwhich represents an ellipsoid. The tangent plane at a point w of S̃p−1 being defined by the normal vector Qw/‖Qw‖2, it is then possible to introduce the projection operator P̃w on the tangent space:\nP̃w[u] =\n( I− Qww\n>Q w>Q2w\n) u.\nThen, we may define the gradient descent step rule on S̃p−1 as\nw← ProjS̃p−1 [ w − ηP̃w [ ∇L̃(w) ]] = ProjS̃p−1 [ w − η ( I− Qww >Q w>Q2w ) Q1/2∇L(Q1/2w) ] .\nWith the change of variable z = Q1/2w, this is equivalent to z← Proj‖.‖2=1 [ z− η ( I− Qzz >\nz>Qz\n) Q∇L(z) ] .\nThis is exactly the update rule we have chosen in our paper, as a heuristic in a stochastic setting."
    }, {
      "heading" : "D Additional Results for Image Super-Resolution",
      "text" : "We present a quantitative comparison in Table 3 using the structural similarity index measure (SSIM), which is known to better reflect the quality perceived by humans than the PSNR; it is commonly used to evaluate the quality of super-resolution methods, see [8, 26, 27]. Then, we present a visual comparison between several approaches in Figures 2, 3, and 4. We focus notably on the classical convolutional neural network of [8] since our pipeline essentially differs in the use of our supervised kernel machine instead of convolutional neural networks. After subjective evaluation, we observe that both methods perform equally well in textured areas. However, our approach recovers better thin high-frequency details, such as the eyelash of the baby in the first image. By zooming on various parts, it is easy to notice similar differences in other images. We also observed a few ghosting artefacts near object boundaries with the method of [8], which is not the case with our approach."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "In this paper, we propose a new image representation based on a multilayer kernel<lb>machine that performs end-to-end learning. Unlike traditional kernel methods,<lb>where the kernel is handcrafted or adapted to data in an unsupervised manner, we<lb>learn how to shape the kernel for a supervised prediction problem. We proceed by<lb>generalizing convolutional kernel networks, which originally provide unsupervised<lb>image representations, and we derive backpropagation rules to optimize model<lb>parameters. As a result, we obtain a new type of convolutional neural network with<lb>the following properties: (i) at each layer, learning filters is equivalent to optimizing<lb>a linear subspace in a reproducing kernel Hilbert space (RKHS), where we project<lb>data; (ii) the network may be learned with supervision or without; (iii) the model<lb>comes with a natural regularization function (the norm in the RKHS). We show that<lb>our method achieves reasonably competitive performance on some standard “deep<lb>learning” image classification datasets such as CIFAR-10 and SVHN, and also<lb>state-of-the-art results for image super-resolution, demonstrating the applicability<lb>of our approach to a large variety of image-related tasks.",
    "creator" : "LaTeX with hyperref package"
  }
}