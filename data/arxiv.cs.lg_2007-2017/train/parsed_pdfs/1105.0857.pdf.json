{
  "name" : "1105.0857.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ "foster@wharton.upenn.edu", "skakade@wharton.upenn.edu", "rsalakhu@mit.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n10 5.\n08 57\nv1 [\ncs .L\nG ]"
    }, {
      "heading" : "1 Introduction",
      "text" : "The generalization ability of most modern machine learning algorithms are predicated on the assumption that the distribution over training examples (roughly) matches the distribution over the test data. There is growing literature studying settings where this implicit assumption fails to hold — often referred to as domain adaptation or transfer learning. This problem is central in fields such as speech recognition [19], computational biology [20], natural language processing [5, 8, 12], and web search [6, 11].\nWe examine how severe this problem can be, even on one of the most conventional benchmark datasets, the MNIST digits dataset. Here, state-of-the-art algorithms reliably obtain classification error rates below 1%, when recognizing one digit vs. the other digits. Consider a natural modification of this setting where we train a model to recognize the digit “2” vs. the other even digits. If we learn to recognize a “2” accurately (vs. only even digits), then we may hope that our classifier will robustly recognize a “2” against new odd digits. Unfortunately, this is far from being true: a logistic regression algorithm, trained on this dataset and achieving a (true) test error rate of about 0.5% (against even digits), jumps to 35% error rate when tested vs. odd digits, a startling 7000% increase in error. While the present work uses deep belief network features [13], trained on unlabeled data, this situation is generic across many other common training methods we have tried: SVMs with various kernels and logistic/linear regression with various feature choices (where error rates increase from hundreds to thousands of percent depending on the details of the experiment).\nWe elucidate this overfitting issue by examining how various “area under the ROC curves” change as we greedily add more features. Here, we train our model to recognize the digit “2” vs. eight other\ndigits, and test recognition of a “2” vs. the remaining digit (with balanced distributions where a “2” appears half the time in both the training and test distributions). The first four plots in Figure 1 show the test performance using the area under the ROC metric on the training distribution (the dashed red curve) and on the test distribution (the solid red curve) vs. the number of features we have greedily added. Note two striking effects: 1) how rapidly the test performance plummets; 2) more troubling, how quickly the test performance for the training and test distributions diverge. In particular, note that the true generalization performance on the source training distribution is not at all reflective of the true generalization performance on the target test distribution, even after adding just a few features: a classic example of overfitting. The final plot shows the average of the training and test performance, averaged over which digit is held out, and cycling through digits.\nOverfitting is to be expected, because this experiment violates the learning theoretic preconditions for successful generalization. Furthermore, for this particular experiment, we could argue that a generative approach is more robust: if we have a model for generating a “2”, then it should be good for recognition in diverse settings. While the generative framework is promising, particularly for generating predictive features, it is often difficult to specify good generative models.\nIn this work, we assume a distribution over domains, and that our training sample consists of a small number of sample domains independently drawn from the distribution over domains and where we have access to many samples in each domain. The goal in our setting is to perform well on new domains sampled from this distribution. For example, in the previous experiments, we can consider that we have eight sample (known) domains in our training set, where domains are of the form “2 vs. 0”, “2 vs. 1”, “2 vs. 3”, etc. This is much like the standard supervised learning model, except that sampled “points” are now “domains”. The challenge is that we desire to avoid overfitting with an extremely small number of domains, or few “samples”, compared to standard supervised learning paradigms, that assume hundreds to millions of samples.\nThe problem of domain adaptation is more general than this particular formulation, where our focus is on how to do well on a new random domain. There are numerous different aspects of the domain adaptation problem that have been studied. For example, assumptions considered are: when the classes are “imbalanced” (e.g. when Pr[Y |D] could vary with the domain D); “covariate shift” [4] where Pr[X |D] varies with the domain D, while Pr[Y |X,D] is not a function of the domain; under a change of representation, the joint distributions of Pr[(X,Y )|D] is more similar [5, 21, 12, 14, 16]; settings where one desires mixtures of predictors which adapt to each domain [9]. A detailed discussion of these models is beyond the scope of this paper (see [17] for a more comprehensive review.). There is also a growing body of theoretical work on this problem, including [15, 2, 7, 1] that concentrates on either characterizing the degradation that can occur due to distributional shift (e.g. [2]) or robustly training using biased sampling, such as the sample selection bias work of [7].\nOur work differs in that we assume a distribution over domains, and our focus is on generalization on new domains. One interesting application of this work is on learning similarity functions. For example, we may desire to learn a similarity function for objects, where objects of the same label have high similarity, in manner so as to be able to utilize this similarity function to recognize new objects, not present in our training set; a problem known as “zero-shot” learning.\nOur Contributions: Our analysis focuses on the issue of overfitting, and we borrow the idea from small sample statistics that a certain empirical variance should be utilized when deciding whether or not an effect is significant, namely, that an added feature will decrease our error. We do this using\nT -statistics. The key idea is that we can estimate the weight of each feature on each training domain separately. Indeed, if this weight varies wildly over the training source domains, then even though this feature may be useful on all our source domains, its potential for generalization to new domains may be poor. We show that our data-dependent version of feature selection robustly enjoys the usual feature selection properties, i.e. we can select many more features than domains, particularly if certain data-dependent variances are low, under relatively weak assumptions.\nThe contributions of this work are as follows:\n• Using small sample statistics, namely that of T -tests, we provide a more robust procedure to add features, which takes into account data-dependent properties.\n• Using the theory of large deviations for self-normalized sums, we show that we can robustly add many more feature than domains (exponentially more), utilizing certain empirical variances.\n• We empirically demonstrate that we control for overfitting using an alternative greedy procedure for feature addition, based on the T -statistic. In particular, we show that these ideas can be utilized towards the theory of “zero-shot learning”."
    }, {
      "heading" : "2 Setting",
      "text" : "A key idea in our setting is that we consider a distribution over domains, which we denote by Pr[D] (it is possible that there may be an infinite number of domains). Conditioned on a domain D = d, the distribution over input/output pairs is Pr[(X,Y )|D = d], where our inputs are X ∈ Rp. As is standard, these inputs could represent a high dimensional feature space. The goal is to find a weight vector which minimizes the squared error, averaged over both instances and over the domains. More precisely, the error we want to minimize is:\nL(w) = EDEX,Y [(Y − w ·X)2|D]\nwhere the inner and outer expectations are over (X,Y ) and D, respectively.\nOur training set consists of a set of n known domains {d1, d2, . . . dn}, where each domain is sampled independently. In practice, while n is small, we often have a large number of samples in each domain, so that the second order statistics can be estimated accurately on each training domain. As a natural abstraction, we assume that for each domain d in our training set, we have knowledge of both E[XY |D = d] and E[XX⊤|D = d]. For our theoretical analysis, we also assume the joint input covariance matrix E[XX⊤] is known, as it can be estimated accurately with unlabeled data. This permits a cleaner exposition in terms of unbiased estimation, although this distinction is relatively minor in practice."
    }, {
      "heading" : "3 Feature Selection and Small Sample Statistics",
      "text" : "Our goal is to avoid overfitting while adding features: we desire confidence that our added feature actually improves the error on new domains. The naive greedy method is to add features which maximally decreases our training set error, which, as we have shown in the Introduction, can perform remarkably poorly. Instead, we provide a theory which more sharply characterizes when adding a feature actually improves our performance."
    }, {
      "heading" : "3.1 Adding a Single Feature",
      "text" : "We first investigate the question of whether or not a single feature improves the null prediction of always saying 0. It is natural to base our theory using unbiased estimates, as we often have the most robust statistical tests for these estimates.\nConsider a feature Xi, which is normalized so that E[X2i ] = 1. The optimal weight on this feature is w∗i = E[XiY ]. Furthermore, any weight wi on Xi has regret:\nL(wi)− L(w∗i ) = (wi − E[XiY ])2\nHence, with respect to adding just one feature, our task is to find a feature Xi and weight vector wi such that we have confidence that wi is closer to E[XiY ] than 0 is (as weight 0 corresponds to the null\nprediction). The natural unbiased estimate for w∗i is simply:\nµ̂i = 1\nn\nn∑\nk=1\nE[XiY |dk]\nThe Central Limit Theorem implies that µ̂i should be close to E[XiY ] on the order of O( σ(XiY )√\nn ),\nwhere σ(XiY ) is the standard deviation. A key idea in small sample statistics is to take into account the empirical variance. Here, when determining if Xi is useful, we seek to consider the (unbiased) variance estimate:\nσ̂2i = 1\nn− 1\nn∑\nk=1\n(E[XiY |dk]− µ̂i)2\nand the issue is how to utilize this estimate rather than the true variance.\nIn our domain adaptation setting, it may be the case that this covariance for certain “robust” features E[XiY ] is more consistently correlated with the target — it is these features that we seek to add. By contrast, “large” sample analysis typically involves only using an upper bound on the standard deviation σ(XiY ), along with tail bounds such as the Bernstein bound [3], to get estimates on the deviation between µ̂i and its mean. However, crucially, as σ(XiY ) could vary greatly with our feature Xi, we desire a sharper estimate which takes into account the empirical variance, σ̂2i .\nIf µ̂i followed a normal distribution, then this question reduces to a Student’s T -test. Here, the T statistic is:\nTi = µ̂i\nσ̂i/ √ n\nWhile we do not expect the µ̂i to actually follow a normal distribution, there is a rather large literature showing that the T -test is robust (see for example [10]). We now demonstrate this point under a milder assumption, that µ̂i is symmetric (where the source of randomness is from a random domain). Equivalently, this is an assumption that the covariances E[XiY |d] are symmetric about their mean (i.e. both E[XiY |d]−E[XiY ] and −(E[XiY |d]−E[XiY ]) have the same distribution, where d is the source of randomness). The following theorem assumes no moment conditions on Xi or Y (not even upper bounds). It shows that we can accurately test an exponential number of features with high confidence. This bound has similar behavior to the T -distribution (for fixed n) as we scale the number of features.\nTheorem 1. Assume the random vector E[XY |d] − E[XY ] is symmetric (where d is random). Let δ > 0. Suppose F is a set of features whose size satisfies |F| ≤ δ2e n\n8 (e.g. it is of size at most exponential in n). Then for all Xi in F , we have with probability greater than 1− δ:\n|µ̂i − E[XiY ]| ≤ σ̂i√ n\n√ 4 log\n2|F| δ\nwhere no moment bounds on X and Y are assumed, aside from existence of E[XY |d] and E[XY ].\nThe proof of this theorem is in the appendix. The key is that this theorem shows that the empirical variance can be taken into account when searching through a large feature set. In fact, asymptotically, as implied by the Central Limit Theorem, the only improvement possible is that the constant of 4 would become a 2.\nThe proof (provided in the Appendix) of this bound is significantly more subtle than the standard “Bernstein”-like bounds, since the T -statistic has much “thicker” tails. Our proof is based on the following bound for “self-normalized” sums, which, to our knowledge, has not been utilized in the machine learning literature.\nTheorem 2. (See Theorem 2.15 in [10]) Assume Z1, . . . Zn are independent, mean 0, symmetric random variables. For all t > 0, the following bound on the self-normalized sum holds:\nPr\n[ ( ∑n\ni=1Zi) 2\n∑n i=1Z 2 i > t\n] ≤ exp ( − t 2 )\nwhere no moment bounds on Zi are assumed, aside from its mean existing.\nFor completeness, we add the proof of this theorem in appendix. It is based on a simple symmetrization argument along with Hoeffding’s tail inequality. Note that the above bound is not quite a large deviation bound for a T -statistic, as the denominator uses ∑n i=1Z 2 i , while a T -statistic would have a term of the\nform ∑n i=1(Zi − Ẑ)2, where Ẑ is the empirical estimate of the mean, ∑n\ni=1Zi/n. This subtlety leads to the condition in Theorem 1 that the size of F is at most exponential in n."
    }, {
      "heading" : "3.2 Subset Selection",
      "text" : "Merely searching for the lowest error solution over all subsets of, say, size q is prone to overfitting. Instead, we seek to take into account the empirical variance when searching over subsets of features. We now provide a data-dependent bound showing that the empirical variance can be utilized for a much sharper bound. In the next subsection, we discuss a greedy method for this search.\nGiven some set of features S of size q, let X̃1 . . . X̃q be an orthonormal basis for this subspace (e.g. E[X̃iX̃j ] is 0 if i 6= j and 1 if i = j. Note that we can put S into this basis as we have assumed knowledge of E[XX⊤]). The best weight vector for this subspace is again the covariance [µS ]i = E[X̃iY ]. Define the (unbiased) empirical means and variances as follows:\n[µ̂S ]i = 1\nn\nn∑\nk=1\nE[X̃iY |dk],\n[σ̂S ] 2 i =\n1\nn− 1\nn∑\nk=1\n(E[X̃iY |dk]− [µ̂S ]i)2\nWe take µ̂S as the estimate of the weight vector on this subspace. We now provide our data dependent generalization bound, in terms of an appropriate empirical variance. In particular, we are interested in a generalization bound for all subsets of size q out of a feature set of size p. Corollary 3. Assume the random vector E[XY |d]−E[XY ] is symmetric. Let δ > 0. Assume that our set of features F is of size p, and that qpq ≤ δ2e n 8 . For all subsets S ⊂ F of size q, we have:\nL(µ̂S)− L(µS) ≤ ( ∑\ni∈S [σ̂S ]\n2 i\n) 8q log p+ log(2/δ)\nn\nThis bound is analogous to the usual bounds for regression where instead of the sum empirical variance, we have the true variance (which is usually assumed to be constant in idealized Gaussian noise regression model1). Crucially, the bound shows that we can robustly utilize the empirical variance when doing our estimation. The implications of this are that we can design a much sharper procedure for testing if a feature improves performance."
    }, {
      "heading" : "3.3 Practice: The T-Greedy Algorithm",
      "text" : "In practice, the natural methodology is to “greedily” choose a feature instead of searching all subsets, which usually consists of finding the feature which decreases the error the most. Instead, we introduce the T -greedy algorithm, a “stagewise” procedure for adding the feature which has the highest T -statistic (e.g. the goal is to add a feature in which we have the most confidence that the true error will be improved).\nThere are a variety of greedy regression procedures, such as “stepwise”,“stagewise”, etc. We now present a stagewise variant by considering covariances with our residual error (Y − w · X). Suppose that our current weight vector is w (on our current set of features). For each feature Xi, we compute the empirical mean and variance:\nµ̂i = 1\nn\nn∑\nk=1\nE[Xi(Y − w ·X)|dk],\nσ̂2i = 1\nn− 1\nn∑\nk=1\n(E[Xi(Y − w ·X)|dk]− µ̂i)2\n1For the usual model, where Y = βX + η where η is Gaussian noise with variance σ2. The risk bound above is just σ2 q log p\nn , which is improved by a factor of q. We conjecture if we made the further assumption that the\nrandom vector E[XiY |d]− E[XiY ] is spherically symmetric, then the factor of q can be removed.\nNote that with a finite number samples in each domain, we would simply use the empirical estimates instead. Now we just add the feature with the highest T -statistic, e.g. add the feature:\ni⋆ = argmax i Ti\nwhere Ti = µ̂i σ̂i/ √ n . Now our update to the weight on this feature is simply:\nwi⋆ ← wi⋆ + µ̂i\nÊ[X2i ] , Ê[X2i ] =\n1\nn\nn∑\nk=1\nE[X2i |dk]\nObserve that this is actually a biased estimate of the optimal weight on this added feature. Technically, our theory is only applicable to using unbiased estimates, where we would have E[X2i ] in the denominator. This is a minor distinction in practice, and with unlabeled data we could essentially run the unbiased version. We should point out that stepwise variants are also possible."
    }, {
      "heading" : "4 Experimental Results",
      "text" : "We now present results on the MNIST and CIFAR image datasets. The MNIST digit dataset contains 60,000 training and 10,000 test images of ten handwritten digits (0 to 9), with 28×28 pixels. In all experiments, we use 10,000 digits (1,000 per class) for training and 10,000 digits for testing. Instead of using raw pixel values, each image was represented by 2000 real-valued features, that were extracted using a deep belief network [13].\nWe also present results on the more challenging CIFAR image dataset [18], that contains images of 10 object categories, including airplane, car, bird, cat, dog, deer, truck, deer, frog, and horse. As with the MNIST dataset, we use 10,000 images (1,000 per class) for training and 10,000 images for testing. Each image was also represented by 2000 real-valued features, that were extracted using a deep belief network [18]. We note that extreme variability in scale, viewpoint, illumination, and cluttered background, makes object recognition task for this dataset difficult.\nIn all experiments, we report the area under ROC (AUROC) metric of two different algorithms, that we refer to as the greedy and our proposed T-greedy algorithm. The greedy algorithm chooses the next feature which decreases the squared loss the most on the training set. The T-greedy algorithm, on the other hand, chooses a feature with the largest T-statistic. For both methods, we report both generalization error on our training or ’source’ domains as well as generalization error on test or ’target’ domains. We do not focus on the issue of stopping but rather on robustness. There are a variety of methods for stopping which we mention in the Discussion section."
    }, {
      "heading" : "4.1 MNIST (2 vs. other)",
      "text" : "In our first experiment, shown as the leftmost plot in Fig. 2, we tested the ability of the proposed algorithm to generalize to a new target domain: recognizing the digit ’2’ vs. the new, previously unseen digit ’9’. To this end, we created eight source domains: {’2’ vs. ’0’},..., {’2’ vs. ’8’}, where each domain contained a balanced set of 2000 labeled training examples2. Our new target domain (as the test set) {’2’ vs. ’9’} also contained a balanced set of 2000 examples.\n2Remember, our key assumption is that the sampled domains are independent and that the source domains are known.\nFig. 2, the leftmost plot, displays an evolution of the area under ROC (AUROC) metric for both greedy (red curves) and T -greedy (blue curves) algorithms. Note that an area of 0.5 corresponds to a random classifier, shown on the graph as a horizontal line. The dashed curves correspond to generalization or ’test’ performance on the source domains, whereas the solid curves display performance on the target domain. Observe that after adding a few features, test performance of the greedy algorithm on the new target domain (red solid curve) rapidly decreases. Test error on the source domains, however, keeps improving, clearly demonstrating that no overfitting on the source domains is occurring. Hence, for the greedy algorithm, the true error on the source and target domains rapidly diverge.\nThis is in sharp contrast to the performance of the T -greedy algorithm. Even though performance of the T -greedy algorithm on the source domains (blue dashed curve) is slightly worse (as expected as it is not as aggressively striving for source error minimization), the true AUROC on the source and target domains diverges less rapidly — in particular, these curves start close together. Fig. 2 further shows results for different source/target splits. We consistently observe that as we add few features, the T -greedy algorithm overfits much less on the target domain. This consistency is also seen in left most plot of Fig. 4, that displays results averaged over all splits of the source and target domains.\nThe rightmost plot of Fig. 2 also shows the T -statistic of the added feature to the model of both algorithms. We only show one such figure since they all look similar.\nWe formulate the similarity learning problem in our regression setting as follows. Given two feature vectors corresponding to two images φ(X1) and φ(X2), we consider a linear regression function:\ny = sgn( ∑\ni\nwiφi(X 1)φi(X 2)),\nwhere we set y = 1 if two images have the same label (positive example), and y = −1 if two images have different labels (negative example).\nFig. 3, top row, displays results on learning a similarity function for MNIST digits. In particular, consider learning a similarity function on all the digits, but with digit ’9’ excluded. Similar to the previous experiment, we constructed nine source domains (corresponding to digits 0 through 8). Each domain contained 1000 positive and 1000 negative examples, where negative examples were randomly sampled from the remaining digits in the source domain. Our target domain contained 1000 positive examples of newly observed images of ’9’ and 1000 negative examples, randomly sampled from images of 0-to-8."
    }, {
      "heading" : "4.2 Learning similarity function",
      "text" : "We now consider a more demanding task of learning a similarity function between two images. A good similarity function can provide insight into how high-dimensional data is organized and can sig-\nnificantly improve the performance of many machine learning algorithms that are based on computing similarity metric. Our goal is to learn a similarity function that can not only work well for objects that are part of the training set, but also works well for new objects that we may have never seen before: a widely studied problem known as a “zero-shot” learning.\nFig. 3, top leftmost plot, shows that the generalization error of the greedy algorithm on the source and target domains rapidly diverge. The T -greedy, on the other hand, is able to select up to 25 reliable features that help us generalize well to the new target domain. Fig. 3 further displays performance results when generalizing a similarity function to different target domains. Again, the rightmost plot shows the value of the added T -statistic for one of these plots.\nFinally, we experimented with learning a similarity function for more challenging image CIFAR dataset. Similar to the results on the MNIST dataset, Fig. 3, bottom row, shows that the T -greedy algorithm is able to consistently pick up to 50 robust features that are useful for transfer to a new domain (note the difference in scale on the x-axis, which now goes to 300 features). The greedy algorithm, however, barely improves upon making random predictions.\nWe have focused attention on the individual domains to help drive home how variable each domain is from the others. But, it is sometimes hard to see the signal amongst all this noise, so we also provide averaged versions of the AUROC curves (Fig. 4). The T -greedy algorithm is able to pick up many more robust features and overfits far less on the target domain (difference in blue-dashed and blue-solid curves). The greedy algorithm’s test error diverges after adding only a handful of features. Almost immediately we see a big gap in the error on the source and target domains (difference in red-dashed and red-solid curves)."
    }, {
      "heading" : "5 Discussion",
      "text" : "All experiments demonstrate that the T -greedy algorithm has better correspondence between training AUROC and testing AUROC. The curves start out with the training and the testing AUROC curves with about the same value. This is particularly striking in the averaged curves, shown in Fig. 4. So by looking only at the training curves one can get a good estimate of the generalization performance. As expected, eventually overfitting occurs, since the training AUROC continues to improve whereas the testing AUROC decreases. However, even then it is possible to get a handle on using our method (e.g. when to stop). One option is to simply keep yet another domain held out for cross-validation and cycle through. Alternatively, we can use properties of the T-statistic to get a handle on when to stop (e.g. when the T -statistics is behaving like chance). Here, Bonferoni can also be used as a heuristic to decide how many variables to use. Again, this is made easier by the fact that the curves are close.\nWe also observe that the variability between domains is much greater than the variability within any given domain (Figs. 2, 3, and 4 all show this variability). Classical statistics assumes that each error is independent (if just merged across all the domains), but we see from plots that each domain behaves idiosyncratically. Sometimes they overfit after a few variables, sometimes they continue to improve. This means that using more observations from the domains we have already studied is not informative of how we will extrapolate to new domains. Such small sample sizes were the original motivation for Gosset to come up with his Student’s T-statistic. Note that we do not have many degrees of freedom but we can still obtain as much information out of the data we have. What we see from our analysis and experiments is that this information can still be substantial.\nAcknowledgments RS is supported by NSERC, and NTT Communication Sciences Laboratory."
    }, {
      "heading" : "A Appendix",
      "text" : "First, let us prove Theorem 2 (also, see Theorem 2.15 in [10]).\nProof. (of Theorem 2). Let ǫi be Rademacher random variables (e.g. independent random variables which take values uniformly in {−1, 1}). Since each Zi is symmetric, we have that the distribution of Zi is identical to the distribution of ǫiZi. Hence, we have that:\nPr\n[ ( ∑n\ni=1Zi) 2\n∑n i=1Z 2 i > t\n] = Pr [ ( ∑n i=1ǫiZi) 2\n∑n i=1Z 2 i > t\n]\nNow we bound this latter quantity for every realization of Zi. Consider a fixed set of values z1, . . . zn (some realization of Z1, . . . Zn). For these fixed values, let us now bound the probability:\nPr\n[ ( ∑n\ni=1ǫizi) 2\n∑n i=1z 2 i > t\n] = Pr   ( n∑\ni=1\nǫizi\n)2 > t n∑\ni=1\nz2i\n \n= Pr   ∣∣∣∣∣ n∑\ni=1\nǫizi ∣∣∣∣∣ > √√√√t n∑\ni=1\nz2i\n \n≤ 2 exp ( − t ∑n i=1z 2 i\n2 ∑n\ni=1z 2 i\n)\n= 2 exp(−t/2) where the second to last step is by Hoeffding’s inequality (where the only randomness is due to the ǫi). To see this, note that we are adding the independent variables ǫizi which are mean 0 and bounded in magnitude by zi.\nNow we prove Theorem 1.\nProof. (of Theorem 1) For symmetric, mean 0, independent Zi, define:\nµ̂ = 1\nn\nn∑\ni=1\nZi, σ̂ 2 =\n1\nn− 1\nn∑\ni=1\n(Zi − µ̂)2\nThe T -statistic is then defined as:\nT = µ̂\nσ̂/ √ n\nDefine the related quantity:\nT̃ = µ̂\n( 1 n ∑n i=1Z 2 i )1/2 / √ n\nand note that: ( ∑n\ni=1Zi) 2\n∑n i=1Z 2 i = T̃ 2\nAlso, one can show that T̃ 2 = nn−1 T 2\n1+ T 2\nn−1\n. Hence, using the bound on self-normalized sums,\nPr[T 2 ≥ t2] = Pr [ T̃ 2 ≥ n\nn− 1 t2 1 + t 2\nn−1\n]\n≤ 2 exp ( −1 2 n n− 1 t2 1 + t 2\nn−1\n)\n≤ 2 exp ( −1 2\nt2\n1 + t 2\nn−1\n)\nNow let us choose t = √ 4 log 2|F|δ . By assumption on the size of F , we have that t2 ≤ n/2, and so\nt2\nn−1 ≤ n2(n−1) ≤ 1 (since n ≥ 2). Hence,\nPr [ T 2 ≥ 4 log 2|F|\nδ\n] ≤ 2 exp ( −1 2 t2 2 ) = δ\n|F| Our result now follows by the union bound (over all |F| features).\nOur corollary now follows:\nProof. (of Corollary 3) For any subset, the regret is: ∑\ni∈S (µ̂i − E[X̃iY ])2\nNow note that there are no more than pq possible subsets. Also, each subset comes with its own basis. So let us demand confidence on all qpq possible basis elements. So we use Theorem 1 with a set of size qpq features (note that the log of the size of this set is bounded by 2q log p). Our theorem now follows by summing over the errors."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2011,
    "abstractText" : "We study the prevalent problem when a test distribution differs from the training dis-<lb>tribution. We consider a setting where our training set consists of a small number of<lb>sample domains, but where we have many samples in each domain. Our goal is to<lb>generalize to a new domain. For example, we may want to learn a similarity function<lb>using only certain classes of objects, but we desire that this similarity function be<lb>applicable to object classes not present in our training sample (e.g. we might seek to<lb>learn that “dogs are similar to dogs” even though images of dogs were absent from our<lb>training set). Our theoretical analysis shows that we can select many more features<lb>than domains while avoiding overfitting by utilizing data-dependent variance proper-<lb>ties. We present a greedy feature selection algorithm based on using T -statistics. Our<lb>experiments validate this theory showing that our T -statistic based greedy feature<lb>selection is more robust at avoiding overfitting than the classical greedy procedure.",
    "creator" : "LaTeX with hyperref package"
  }
}