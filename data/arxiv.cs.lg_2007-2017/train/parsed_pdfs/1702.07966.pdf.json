{
  "name" : "1702.07966.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Globally Optimal Gradient Descent for a ConvNet with Gaussian Inputs",
    "authors" : [ "Alon Brutzkus", "Amir Globerson" ],
    "emails" : [ "alonbrutzkus@mail.tau.ac.il", "gamir@cs.tau.ac.il" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Deep neural networks have achieved state-of-the-art performance on many machine learning tasks in areas such as natural language processing (Wu et al., 2016), computer vision (Krizhevsky et al., 2012) and speech recognition (Hinton et al., 2012). Training of such networks is often successfully performed by minimizing a high-dimensional non-convex objective function, using simple first-order methods such as stochastic gradient descent.\nNonetheless, the success of deep learning from an optimization perspective is poorly understood theoretically. Current results are mostly pessimistic, suggesting that even training a 3-node neural network is NP-hard (Blum & Rivest, 1993), and that the objective function of a single neuron can admit exponentially many local minima (Auer et al., 1996; Safran & Shamir, 2016). There have been recent attempts to bridge this gap between theory and practice. Several works focus on the geometric properties of loss functions that neural networks attempt to minimize. For some simplified architectures, such as linear activations, it can be shown that there are no bad local minima (Kawaguchi, 2016). Extension of these results to the non-linear case currently requires very strong independence assumptions (Kawaguchi, 2016).\nSince gradient descent is the main “work-horse” of deep learning it is of key interest to understand its convergence properties. However, there are no results showing that gradient descent is globally optimal for non-linear models, except for the case of many hidden neurons (Andoni et al., 2014) and non-linear activation functions that are not widely used in practice (Zhang et al., 2017).1 Here we provide the first such result for a neural architecture that has two very common components: namely a ReLU activation function and a convolution layer.\nThe architecture considered in the current paper is shown in Figure 1. We refer to these models as no-overlap networks. A no-overlap network can be viewed as a simple convolution layer with non overlapping filters, followed by a ReLU activation function, and then average pooling. Formally, let w ∈ Rm denote the filter coefficient, and assume the input x is in Rd. Define k = m/d and assume for simplicity that k is integral. Partition x into k non-overlapping parts and denote x[i] the ith part.\n1See more related work in Section 2.\nar X\niv :1\n70 2.\n07 96\n6v 1\n[ cs\n.L G\n] 2\n6 Fe\nb 20\n17\nFinally, define σ to be the ReLU activation function, namely σ (z) = max{0, z}. Then the output of the network in Figure 1 is given by:\nf(x;w) = 1\nk ∑ i σ (w · x[i]) (1)\nWe note that such architectures have been used in several works (Lin et al., 2013; Milletari et al., 2016), but we view them as important firstly because they capture key properties of general convolutional networks.\nWe address the realizable case, where training data is generated from a function as in Eq. 1 with weight vector w∗. Training data is then generated by sampling n training points x1, . . . ,xn from a distribution D, and assigning them labels using y = f(x;w∗). The learning problem is then to find a w that minimizes the squared loss. In other words, solve the optimization problem:\nmin w\n1\nn ∑ i (f(xi;w)− yi)2 (2)\nIn the limit n→∞, this is equivalent to minimizing the population risk: `(w) = Ex∼D [ (f(x;w)− f(x;w∗))2 ] (3)\nLike several recent works (Hardt et al., 2016; Hardt & Ma, 2016) we focus on minimizing the population risk, leaving the finite sample case to future work. We believe the population risk captures the key characteristics of the problem, since the large data regime is the one of interest.\nOur key results are as follows:\n• Worst Case Hardness: Despite the simplicity of No-Overlap Networks, we show that learning them is in fact hard if D is unconstrained. Specifically, in Section 4, we show that learning No-Overlap Networks is NP complete via a reduction from a variant of the set splitting problem.\n• Distribution Dependent Tractability: When D corresponds to independent Gaussian variables with µ = 0, σ2 = 1, we show in Section 5 that No-Overlap Networks can be learned in polynomial time using gradient descent.\nThe above two results nicely demonstrate the gap between worst-case intractability and tractability under assumptions on the data. We provide an empirical demonstration of this in Section 6 where gradient descent is shown to succeed on the Gaussian case and fail for a different distribution.\nTo further understand the role of overlap in the network, we consider networks that do have overlap between the filters. In Section 7.1 we show that in this case, even under Gaussian distributed inputs, there will be non-optimal local minima. Thus, gradient descent will no longer be optimal in the overlap case. In Section 7.2 we show empirically that these local optima may be overcome in practice by using gradient descent with multiple restarts.\nTaken together, our results are the first to demonstrate distribution dependent optimality of gradient descent for learning a neural architecture with a convolutional like architecture and a ReLU activation function."
    }, {
      "heading" : "2 Related Work",
      "text" : "Hardness of learning neural networks has been demonstrated for many different settings. For example, (Blum & Rivest, 1993) show that learning a neural network with one hidden layer with a sign activation function is NP-hard in the realizable case. (Livni et al., 2014) extend this to other activation functions and bounded norm optimization. Hardness can also be shown for improper learning under certain cryptographic assumptions (e.g., see Daniely et al., 2014; Klivans, 2008; Livni et al., 2014). Note that these hardness results do not hold for the regression and tied parameter setting that we consider.\nDue to the above hardness results, it is clear that the success of deep-learning can only be explained by making additional assumptions about the data generating distribution. The classic algorithm by (Baum, 1990) shows that intersection of halfspaces (i.e., a specific instance of a one hidden layer network) is PAC learnable under any symmetric distribution. This was later extended in (Klivans et al., 2009) to log-concave distributions.\nThe above works do not consider gradient descent as the optimization method, leaving open the question of which assumptions can lead to global optimality of gradient descent. Such results have been hard to obtain, and we survey some recent ones below. One instance when gradient descent can succeed is when there are enough hidden units such that random initialization of the first layer can lead to zero error even if only the second layer is trained. Such over-specified networks have been considered in (Andoni et al., 2014; Livni et al., 2014) and it was shown that gradient descent can globally learn them in some cases (Andoni et al., 2014). However, the assumption of over-specification is very restrictive and limits generalization. In contrast, we show convergence of gradient descent to a global optimum for any network size and consider convolutional neural networks with shared parameters. Another interesting case is linear dynamical systems, where (Hardt et al., 2016) show that under independence assumptions maximum likelihood is quasi-concave and hence solvable with gradient ascent.\nRecent work by (Mei et al., 2016) shows that regression with a single neuron and certain non-linear activation functions, can be learned with gradient descent for sub-Gaussian inputs. We note that their architecture is significantly simpler than ours, in that it uses a single neuron. In fact, their regression problem can also be solved via methods for generalized linear models such as (Kakade et al., 2011).\n(Shamir, 2016) recently showed that there is a limit to what distribution dependent results can achieve. Namely, it was shown that for large enough one-hidden layer networks, no distributional assumptions can make gradient descent tractable. Importantly, the construction in (Shamir, 2016) does not use parameter tying and thus is not applicable to the architecture we study here.\nSeveral works have focused on understanding the loss surface of neural network objectives, but without direct algorithmic implications. (Kawaguchi, 2016) show that linear neural networks do not suffer from bad local minima. (Hardt & Ma, 2016) consider objectives of linear residual networks and prove that there are no critical points other than the global optimum. (Soudry & Carmon, 2016) show that in the objective of over-parameterized neural networks with dropout-like noise, all differentiable local minima are global. Other works (Safran & Shamir, 2016; Haeffele & Vidal, 2015) give similar results for over-specified networks. All of these results are purely geometric and do not have direct implications on convergence of optimization algorithms. In a different approach, (Janzamin et al., 2015), suggest alternatives to gradient-based methods for learning neural networks. However, these algorithms are not widely used in practice. Finally, (Choromanska et al., 2015) use spin glass models to argue that, under certain generative modelling and architectural constraints, local minima are likely to have low loss values.\nThe theory of non-convex optimization is closely related to the theory of neural networks. Recently, there has been substantial progress in proving convergence guarantees of simple first-order methods in various machine learning problems, that don’t correspond to typical neural nets. These include for example matrix completion (Ge et al., 2016) and tensor decompositions (Ge et al., 2015).\nFinally, recent work by (Zhang et al., 2016) shows that neural nets can perfectly fit random labelings of the data. Understanding this from an optimization perspective is largely an open problem."
    }, {
      "heading" : "3 Preliminaries",
      "text" : "We use bold-faced letters for vectors and capital letters for matrices. The ith row of a matrix A is denoted by ai.\nIn our analysis in Section 5 and Section 7.1 we assume that the input feature x ∈ Rd is a vector of IID Gaussian random variables with zero mean and variance one.2 Denote this distribution by G. We consider networks with one hidden layer, and k hidden units. Our main focus will be on No-Overlap Networks, but we begin with a more general one-hidden-layer neural network with a fully-connected layer parameterized by W ∈ Rk,d followed by average pooling. The network output is then:\nf(x;W ) = 1\nk ∑ i σ (wi · x) (4)\nwhere σ () is the pointwise ReLU function. We consider the realizable setting where there exists a true W ∗ using which the training data is generated. The population risk (see Eq. 3) is then:\n`(W ) = EG [ (f(x;W )− f(x;W ∗))2 ] , (5)\nAs we show next, `(W ) can be considerably simplified. First, define:\ng(u,v) = EG [σ (u · x)σ (v · x)] (6)\nSimple algebra then shows that:\n`(W ) = 1\nk2 ∑ i,j [ g(wi,wj)− 2g(wi,w∗j ) + g(w∗i ,w∗j ) ] (7)\nThe next Lemma from (Cho & Saul, 2009) shows that g(u,v) has a simple form.\nLemma 3.1 ((Cho & Saul, 2009), Section 2). Assume x ∈ Rd is a vector where the entries are IID Gaussian random variables with mean 0 and variance 1. Given u,v ∈ Rd denote by θu,v the angle between u and v. Then:\ng(u,v) = 1\n2π ‖u‖ ‖v‖\n( sin θu,v + ( π − θu,v ) cos θu,v ) The gradient of g with respect to u also turns out to have a simple form, as stated in the lemma\nbelow. The proof is deferred to the Appendix A.\nLemma 3.2. Let g be as defined in Eq. 6. Then g is differentiable at all points u 6= 0 and\n∂g(u,v)\n∂u =\n1 2π ‖v‖ u ‖u‖ sin θu,v + 1 2π\n( π − θu,v ) v\nWe conclude by special-casing the results above to No-Overlap Networks. In this case, the entire model is specified by a single filter vector w ∈ Rm. The rows wi are mostly zeros, except for the indices ((i − 1)m + 1, . . . , im) which take the values of w. Namely, wi = ( 0(i−1)m,w,0d−im ) where 0l ∈ Rl is a zero vector. The same holds for the vectors w∗i with a weight vector w∗. This simplifies the loss considerably, since for all i: g(wi,wi) = 1 2 ‖w‖ 2 , and for all i 6= j: g(wi,wj) = 12π ‖w‖ 2 and g(wi,w ∗ j ) = 1 2π ‖w‖ ‖w\n∗‖. Thus the loss `(w) for No-Overlap Networks yields (up to additive factors in w∗):\nl(w) = 1\nk2\n[ γ‖w‖2 − 2kg(w,w∗)− 2β ‖w‖ ‖w∗‖ ] (8)\nwhere β = k 2−k 2π and γ = β + k 2 .\n2The variance per variable can be arbitrary. We choose one for simplicity.\n4 Learning No-Overlap Networks is NP-Complete\nThe No-Overlap Networks architecture is a simplified convolutional layer with average pooling. However, as we show here, learning it is still a hard problem. This will motivate our exploration of distribution dependent results in Section 5.\nRecall that our focus is on minimizing the squared error in Eq. 3. For this section, we do not make any assumptions on D. Thus D can be a distribution with uniform mass on training points x1, . . . ,xn, recovering the empirical risk in Eq. 2. We know that `(w) in Eq. 3 can be minimized by setting w = w∗ and the corresponding squared loss `(w) will be zero. However, we of course do not know w∗, and the question is how difficult is it to minimize `(w). In what follows we show that this is hard. Namely, it is an NP-complete problem to find a w that comes 0 close to the minimum of `(w), for some constant 0.\nWe begin by defining the Set-Splitting-by-k-Sets problem, which is a variant of the classic SetSplitting problem (Garey & Johnson, 1990). After establishing the hardness of Set-Splitting-by-k-Sets, we will provide a reduction from it to learning No-Overlap Networks.\nDefinition 1. The Set-Splitting-by-k-Sets decision problem is defined as follows: Given a finite set S of d elements and a collection C of at most (k − 1)d subsets Cj of S, do there exist disjoint sets S1, S2, ..., Sk such that ⋃ i Si = S and for all j and i, Cj 6⊆ Si?\nFor k = 2 and without the upper bound on |C| this is known as the Set-Splitting decision problem which is NP-complete (Garey & Johnson, 1990). Next, we show that Set-Splitting-by-k-Sets is NPcomplete. The proof is via a reduction from 3SAT and induction, and is provided in Appendix B.\nProposition 4.1. Set-Splitting-by-k-Sets is NP-complete for all k ≥ 2.\nWe next formulate the No-Overlap Networks optimization problem.\nDefinition 2. The k-Non-Overlap-Opt problem is defined as follows. The input is a distribution DX,Y over input-output pairs x, y where x ∈ Rd. If the input is realizable by a no-overlap network with k hidden neurons, then the output is a vector w such that:\nEDX,Y [ (f(x;w)− y))2 ] < 1\n4k5d (9)\nOtherwise an arbitrary weight vector is returned.\nThe above problem returns a w that minimizes the population-risk up to 14k5d accuracy. It is thus easier than minimizing the risk to an arbitrary precision (see Section 5, Theorem 5.2).\nWe prove the following theorem, which uses some ideas from (Blum & Rivest, 1993), but introduces additional constructions needed for the no overlap case.\nTheorem 4.2. For all the k ≥ 2, the k-Non-Overlap-Opt problem is NP-complete.\nProof. We will show a reduction from Set-Splitting-by-k-sets to k-Non-Overlap-Opt. Assume a given instance of the Set-Splitting-by-k-sets problem with a set S and collection of subsets C. Denote S = {1, 2, ..., d} and |C| ≤ (k − 1)d. Let 0d ∈ Rd be the all zeros vector. For a vector v ∈ Rd, define the vector di(v) ∈ Rkd to be the concatenation of i − 1 vectors 0d, followed by v and k − i vectors 0d, and let d(v) = (d1(v),d2(v), ...,dk(v)) ∈ Rk\n2d. We next define a training set for k-Non-Overlap-Opt. For each element i ∈ S define an input vector xi = d(ei), where ei is the standard basis of Rd. Assign the label yi = 1k to this input. In addition, for each subset Cj ∈ C define the vector xd+j = d( ∑ i∈Cj ei) and label yd+j = 0. Thus we have |S| + |C| inputs in Rk2d. Let DX,Y be a uniform distribution over the training set points (i.e., each point with probability at least 1kd since |C| ≤ (k − 1)d).\nWe will now show that the given instance of Set-Splitting-by-k-sets has a solution (i.e., there exist splitting sets) if and only if k-Non-Overlap-Opt returns a weight vector with low risk. First, assume\nthere exist splitting sets S1, ..., Sk. For each 1 ≤ l ≤ k define the vector aSl ∈ Rd such that for all i ∈ Sl, aSli = 1 and a Sl i = −d otherwise. Define a No-Overlap Network with k2d inputs and weight vector w = (aS1 ,aS2 , ...,aSk) ∈ Rkd. Then for all 1 ≤ i ≤ d we have:\nf(xi;w) =\n∑k l=1 σ((a Sl)Tei)\nk =\n1 k = yi (10)\nand for all j:\nf(xd+j ;w) =\n∑k l=1 σ((a Sl)T ( ∑ i∈Cj ei))\nk = 0 = yd+j (11)\nwhere the last equality follows since for all l and j, Cj 6⊆ Sl. Therefore there exists a w for which the error in Eq. 9 is zero and k-Non-Overlap-Opt will return a weight vector with low risk.\nConversely, assume that k-Non-Overlap-Opt returned a w ∈ Rkd with risk less than 14k5d on DX,Y above. Denote by w = (w1,w2, ...,wk), where wl ∈ Rd. We will show that this implies that there exist k splitting sets. For all x′, y′ in the training set it holds that:3\n(f(x′;w)− y′)2\nkd ≤ EDX,Y [(f(x;w)− y)2] <\n1\n4k5d\nThis implies that for all i and j,\n|f(d(ei);w)− 1 k | < 1 2k2 , |f(d( ∑ i∈Cj ei);w)| < 1 2k2 (12)\nDefine sets Sl = {i | wTl ei > 12k} for 1 ≤ l ≤ k and WLOG assume they are disjoint by arbitrarily assigning points that belong to more than one set, to one of the sets they belong to. We will next show that these Sl are splitting. Namely, it holds that ⋃ l Sl = S and no subset Cj is a subset of some Sl.\nSince f(d(ei);w) = ∑k l=1 σ(w T l ei) k > 1 k − 1 2k2 > 1 2k for all i, it follows that for each i ∈ S there\nexists 1 ≤ l ≤ k such that wTl ei > 12k . Therefore, by the definition of Sl we deduce that ⋃ l Sl = S. To show the second property, assume by contradiction that for some j and m, Cj ⊆ Sm. Then\nwTm( ∑ i∈Cj ei) > |Cj | 2k , which implies that f(d( ∑ i∈Cj ei);w) = ∑k l=1 σ(w T l ( ∑ i∈Cj ei)) k > |Cj | 2k2 ≥ 1 2k2 , a contradiction. This concludes our proof.\nTo conclude, we have shown that No-Overlap Networks are hard to learn if one does not make any assumptions about the training data. In fact we have shown that finding a w with loss at most\n1 4k5d is hard. In the next section, we show that certain distributional assumptions make the problem tractable.\n5 No-Overlap Networks can be Learned for Gaussian Inputs\nIn this section we assume that the input features x are generated via a Gaussian distribution G, as in Section 3. We will show that in this case, gradient descent will converge with high probability to the global optimum of `(w) (Eq. 8) in polynomial time.\nIn order to analyze convergence of gradient descent on `, we need a characterization of all the critical and non-differentiable points. We show that ` has a non-differentiable point and a degenerate saddle point.4 Therefore, recent methods for showing global convergence of gradient-based optimizers\n3The LHS is true because for a non-negative random variable X, E[X] ≥ p(x)x for all x, and in our case p(x) ≥ 1 kd\n. 4A saddle point is degenerate if the Hessian at the point has only non-negative eigenvalues and at least one zero\neigenvalue.\non non-convex objectives (Lee et al., 2016; Ge et al., 2015) cannot be used in our case, because they assume all saddles are strict 5 and the objective function is continuously differentiable everywhere.\nThe characterization is given in the following lemma. The proof relies on the fact that `(w) depends only on ‖w‖,‖w∗‖ and θw,w∗ , and therefore w.l.o.g. it can be assumed that w∗ lies on one of the axes. Then by a symmetry argument, in order to prove properties of the gradient and the Hessian, it suffices to calculate partial derivatives with respect to at most three variables.\nLemma 5.1. Let `(w) be defined as in Eq. 8. Then the following holds:\n1. `(w) is differentiable if and only if w 6= 0.\n2. For k > 1, `(w) has three critical points:\n(a) A local maximum at w = 0.\n(b) A unique global minimum at w = w∗.\n(c) A degenerate saddle point at w = −( k 2−k k2+(π−1)k )w ∗.\nFor k = 1, w = 0 is not a local maximum and the unique global minimum w∗ is the only differentiable critical point.\nWe next consider a simple gradient descent update rule for minimizing `(w) and analyze its convergence. Let λ > 0 denote the step size. Then the update at iteration t is simply:\nwt+1 = wt − λ∇`(wt) (13)\nOur main result, stated formally below, is that the above update is guaranteed to converge to an accurate solution after O( 1 2 ) iterations. We note that the dependence of the convergence rate on is similar to standard results on convergence of gradient descent to stationary points (e.g., see discussion in Allen-Zhu & Hazan, 2016).\nTheorem 5.2. Assume ‖w∗‖ = 1.6 For any δ > 0 and 0 < < δ sinπδk , there exists 0 < λ < 1 7 such that with probability at least 1−δ, gradient descent initialized randomly from the unit sphere with learning rate λ will get to a point w such that `(w) ≤ O( ) 8 in O( 1 2 ) iterations.\nThe complete proof is provided in Appendix C. Here we provide a high level overview. In particular, we first explain why gradient descent will stay away from the two bad points mentioned in Lemma 5.1.\nFirst we note that the gradient of `(w) at wt is given by:\n∇`(wt) = −c1(wt,w∗)wt − c2(wt,w∗)w∗ , (14)\nwhere c1 and c2 are two functions such that c1 ≥ −1 and c2 ≥ 0. Thus the gradient is a sum of a vector in the direction of wt and a vector in the direction of w ∗. At iteration t+ 1 we have:\nwt+1 = (1 + λc1(wt,w ∗))wt + λc2(wt,w ∗)w∗ (15)\nIt follows that for λ < 1 the angle between wt and w ∗ will decrease in each iteration. Therefore, if w0 has an angle with w ∗ that is not π, we will never converge to the saddle point in Lemma 5.1.\nNext, assuming ‖w0‖ > 0 and that the angle between w0 and w∗ is at most (1−δ)π (which occurs with probability 1 − δ), it can be shown that the norm of wt is always bounded away from zero by\n5A saddle point is strict if the Hessian at the point has at least one negative eigenvalue. 6Assumed for simplicity, otherwise ‖w∗‖ is a constant factor. 7λ can be found explicitly. 8O(·) hides a linear factor in d.\na constant M = Ω̃(1).9 The proof is quite technical and follows from the fact that w = 0 is a local maximum.10\nThe fact that wt stays away from the problematic points allows us to show that `(w) has a Lipschitz continuous gradient on the line between wt and wt+1, with constant L = Õ(1).\n9 By standard optimization analysis (Nesterov, 2004) it follows that after T = O( 1 2 ) iterations we will have ‖∇l(wt)‖ ≤ O( ) for some 0 ≤ t ≤ T . This in turn can be used to show that wt is O( √ )-close to w∗. Finally, since `(w) ≤ d‖w −w∗‖2, it follows that wt approximates the global minimum to within O( ) accuracy.\nTheorem 5.2 implies that gradient descent converges to a point w such that `(w) ≤ 1d2 in time O(poly(d)) where d is the input dimension.11 The following corollary thus follows.\nCorollary 5.3. Gradient descent solves the k-Non-Overlap-Opt problem under the Gaussian assumption on D with high probability and in polynomial time."
    }, {
      "heading" : "6 Empirical Illustration of Tractability Gap",
      "text" : "The results in the previous sections showed that No-Overlap Networks optimization is hard in the general case, but tractable for Gaussian inputs. Here we empirically demonstrate both the easy and hard cases. The training data for the two cases will be generated by using the same w∗ but different distributions over x.\nTo generate the “hard” case, we begin with a set splitting problem. In particular, we consider a set S with 40 elements and a collection C of 760 subsets of S, each of size 20. We choose Cj such that there exists subsets S1,S2 that split the subsets Cj . We use the reduction in Section 4 to convert this into a No-Overlap Networks optimization problem. This results in a training set of size 800.\nSince we know the w∗ that solves the set splitting problem, we can use it to label data from a different distribution. Motivated by Section 5 we use a Gaussian distribution G as defined earlier and generate a training set of the same size (namely 800) and labels given by the no-overlap network with weight w∗.\nFor these two learning problems we used AdaGrad (Duchi et al., 2011) to optimize the empirical risk (plain gradient descent also converges, but AdaGrad requires less tuning of step size). For both datasets we used a random normal initializer and for each we chose the best performing learning rate schedule. The training error for each setting as a function of the number of epochs is shown in Figure 2. It is clear that in the non-Gaussian case, AdaGrad gets trapped at a sub-optimal point, whereas the Gaussian case is solved optimally.12 In the Gaussian case AdaGrad converged to w∗. Therefore, given the Gaussian dataset we were able to recover the true weight vector w∗, whereas given the data constructed via the reduction we were not, even though\nboth datasets were of the same size. We conclude that these empirical findings are in line with our theoretical results.\n9Ω̃ and Õ hide factors of ‖w∗‖, θw0,w∗ , k and δ. 10The proof holds even for k = 1 where w = 0 is not a local maximum. 11Note that the complexity of a gradient descent iteration is polynomial in d. 12We note that the value of 0.06 attained by the non-Gaussian case is quite high, since the zero weight vector in this\ncase has loss of order 0.1."
    }, {
      "heading" : "7 Networks with Overlapping Filters",
      "text" : "Thus far we showed that the non-overlapping case becomes tractable under Gaussian inputs. A natural question is then what happens when overlaps are allowed (namely, the stride is smaller than the filter size). Will gradient descent still find a global optimum? Here we show that this is in fact not the case, and that with probability greater than 14 gradient descent will get stuck in a sub-optimal region. In Section 7.1 we analyze this setting for a two dimensional example and provide bounds on the level of suboptimality. In Section 7.2 we report on an empirical study of optimization for networks with overlapping filters. Our results suggest that by restarting gradient descent a constant number of times, it will converge to the global minimum with high probability. Complete proofs of the results are provided in Appendix D."
    }, {
      "heading" : "7.1 Suboptimality of Gradient Descent for R2",
      "text" : "We consider an instance where there are k = d − 1 neurons and matrices W,W ∗ ∈ Rk×d correspond to an overlapping filter of size 2 with stride 1, i.e., for all 1 ≤ i ≤ k wi = (0i−1,w,0d−i−1), w∗i = (0i−1,w\n∗,0d−i−1) where 0l = (0, 0, ..., 0) ∈ Rl, w = (w1, w2) is a vector of 2 parameters and w∗ = (−w∗, w∗) ∈ R2, w∗ > 0. Define the following vectors wr = (w1, w2, 0), wl = (0, w1, w2), w∗r = (−w∗, w∗, 0), w∗l = (0,−w∗, w∗) and denote by θw,v the angle between two vectors w and v.\nOne might wonder why the analysis of the overlapping case should be any different than the nonoverlapping case. However, even for a filter of size two, as above, the loss function and consequently the gradient, are more complex in the overlapping case. Indeed, the loss function in this case is given by:\n`(w) = α(‖w‖2 + ‖w∗‖2)− βg(w,w∗) + (β − 2)(g(wr,wl)− g(wl,w∗r) − g(wr,w∗l ) + g(w∗r ,w∗l ))− γ ‖w‖ ‖w∗‖\n(16)\nwhere α = 1k2 ( k 2 + k2−3k+2 2π ) , β = 2k and γ = k 2−3k+2 π .\nCompared to the objective in Eq. 8 which depends only on ‖w‖, ‖w‖ and θw,w∗ , we see that the objective in Eq. 16 has new terms such as g(wr,w ∗ l ) which has a more complicated dependence on the weight vectors w∗ and w. This does not only have implications on the analysis, but also on the geometric properties of the loss function and the dynamics of gradient descent. In particular, in Figure 3 we see that the objective has a large sub-optimal region which is not the case when the filters are non-overlapping.\nAs in the previous section we consider gradient descent updates as in Eq. 13. The following Proposition shows that if w is initialized in the interior of the fourth quadrant of R2, then it will stay there for all remaining iterations.\nThe proof is a straightforward inspection of the components of the gradient, and is provided in the supplementary.\nProposition 7.1. For any λ ∈ (0, 13 ), if wt is in the interior of the fourth quadrant of R 2 then so is wt+1.\nNote that in our example the global optimum w∗ is in the second quadrant (it’s easy to show that it is also unique). Hence, if initialized at the fourth quadrant, gradient descent will remain in a sub-optimal region. The sub-optimality can be clearly seen in Figure 3. In the proposition below we formalize this observation by giving a tight lower bound on the values of `(w) for w in the fourth quadrant. Specifically, we show that the sub-optimality scales with O( 1k2 ). The proof idea is to express all angles between all the vectors that appear in Eq. 16 via a single angle parameter θ between w in the fourth quadrant and the positive x-axis. Then it is possible to prove the relatively simpler one dimensional inequality that depends on θ.\nProposition 7.2. Let h(k) = k 2−3k+2 π + √ 3(k−1) π + 2(k−1) 3 , then for all w in the fourth quadrant l(w) ≥ 2h(k)+1k2(2h(k)+2)‖w ∗‖2 and this lower bound is attained by w̃ = − h(k)h(k)+1w ∗.\nThe above two propositions result in the following characterization of the sub-optimality of gradient descent for w ∈ R2 and overlapping filters.\nTheorem 7.3. Define h(k) as in Proposition 7.2. Then with probability ≥ 14 , a randomly initialized gradient descent with learning rate λ ∈ (0, 13 ) will get stuck in a sub-optimal region, where each point in this region has loss at least 2h(k)+1k2(2h(k)+2)‖w ∗‖2 and this bound is tight."
    }, {
      "heading" : "7.2 Empirical study of Gradient Descent for m > 2",
      "text" : "In Section 7.1 we showed that already for m = 2, networks with w ∈ Rm and filter overlaps exhibit more complex behavior than those without overlap. This leaves open the question of what happens in the general case under the Gaussian assumption, for various values of d,m and overlaps. We leave the theoretical analysis of this question to future work, but here report on empirical findings that hint at what the solution should look like.\nWe experimented with a range of d,m and overlap values (see Appendix E for details of the experimental setup). For each value of d, m and overlap we sampled 90 values of w∗ from various uniform input distributions with different supports and several pre-defined deterministic values. This resulted in more than 1200 different sampled w∗. For each such w∗ we ran gradient descent multiple times, each initialized randomly from a different w0. Using the results from these runs, we could estimate the probability of sampling a w0 that would converge to the unique global minimum. Viewed differently, this is the probability mass of the basin of attraction of the global optimum. We note that the uniqueness of the global minimum follows easily from equating the population risk (Eq. 3) to 0 and the full proof is deferred to Appendix F.\nOur results are that across all values of d,m, overlap and w∗, the probability mass of the basin of attraction is at least 117 . The practical implication is that multiple restarts of gradient descent (in this case a few dozen) will find the global optimum with high probability. We leave formal analysis of this intriguing fact for future work."
    }, {
      "heading" : "8 Discussion",
      "text" : "The key theoretical question in deep learning is why it succeeds in finding good models despite the non-convexity of the training loss. It is clear that an answer must characterize specific settings where deep learning provably works. Despite considerable recent effort, such a case has not been shown. Here we provide the first analysis of a non-linear architecture where gradient descent is globally optimal, for a certain input distribution, namely Gaussian. Thus our specific characterization is both in terms of architecture (no-overlap networks, single hidden layer, and average pooling) and input distribution. We show that learning in no-overlap architectures is hard, so that some input distribution restriction is necessary for tractability. Note however, that it is certainly possible that other, non-Gaussian, distributions also result in tractability. Some candidates would be sub-Gaussian and log-concave distributions.\nOur derivation addressed the population risk, which for the Gaussian case can be calculated in closed form. In practice, one minimizes an empirical risk. Our experiments in Section 6 suggest that optimizing the empirical risk in the Gaussian case is tractable. It would be interesting to prove this formally. It is likely that measure concentration results can be used to get similar results to those we had for the population risk (e.g., see Mei et al., 2016; Xu et al., 2016, for use of such tools).\nConvolution layers are among the basic building block of neural networks. Our work is among the first to analyze optimization for these. The architecture we study is similar in structure to convolutional networks, in the sense of using parameter tying and pooling. However, most standard convolutional layers have overlap and use max pooling. In Section 7 we provide initial results for the case of overlap, showing there is hope for proving optimality for gradient descent with random restarts. Analyzing max pooling would be very interesting and is left for future work.\nFinally, we note that distribution dependent tractability has been shown for intersection of halfspaces (Klivans et al., 2009), which is a non-convolutional architecture. However, these results do not use gradient descent. It would be very interesting to use our techniques to try and understand gradient descent for the population risk in these settings."
    }, {
      "heading" : "A Proof of Lemma 3.2",
      "text" : "First assume that θu,v 6= 0, π . Then by straightforward calculation we have\n∂g ∂ui = 1 2π ‖v‖ ui ‖u‖\n(√ 1− ( u · v ‖u‖ ‖v‖ )2 + ( π − arccos ( u · v ‖u‖ ‖v‖ )) u · v ‖u‖ ‖v‖ )\n+ 1\n2π ‖u‖ ‖v‖\n(( − u·v ‖u‖‖v‖√\n1− (\nu·v ‖u‖‖v‖\n)2 )( vi ‖u‖ ‖v‖ − ui ‖u‖2 u · v ‖u‖ ‖v‖ )\n+ ( u·v ‖u‖‖v‖√\n1− (\nu·v ‖u‖‖v‖\n)2 ( vi ‖u‖ ‖v‖ − ui ‖u‖2 u · v ‖u‖ ‖v‖ ))\n+ ( π − arccos ( u · v ‖u‖ ‖v‖ ))( vi ‖u‖ ‖v‖ − ui ‖u‖2 u · v ‖u‖ ‖v‖ ))\n= 1 2π ‖v‖ ui ‖u‖\n(√ 1− ( u · v ‖u‖ ‖v‖ )2 + ( π − arccos ( u · v ‖u‖ ‖v‖ )) u · v ‖u‖ ‖v‖ )\n+ 1\n2π ‖u‖ ‖v‖\n( π − arccos ( u · v ‖u‖ ‖v‖ ))( vi ‖u‖ ‖v‖ − ui ‖u‖2 u · v ‖u‖ ‖v‖ ))\n= 1 2π ‖v‖ ui ‖u‖\n√ 1− ( u · v ‖u‖ ‖v‖ )2 + 1 2π ( π − arccos ( u · v ‖u‖ ‖v‖ )) vi\n= 1 2π ‖v‖ ui ‖u‖ sin θu,v + 1 2π\n( π − θu,v ) vi\n(17)\nHence,\n∂g ∂u = 1 2π ‖v‖ u ‖u‖ sin θu,v + 1 2π\n( π − θu,v ) v (18)\nNow we assume that u is parallel to v. We first show that g is differentiable in this case. Without loss of generality we can assume that u and v lie on the u1 axis. This follows since g is a function of ‖u‖, ‖v‖ and θu,v and therefore g(·,v) has a directional derivative in direction d at u if and only if g(·, Rv) has a directional derivative in direction Rd at Ru where R is a rotation matrix. Hence g(·,v) is differentiable at u if and only if g(·, Rv) is differentiable at Ru. Furthermore, if v and u are on the u1 axis, then by symmetry the partial derivatives with respect to other axes at u are all equal, hence we only need to consider the partial derivative with respect to the u1 and u2 axes.\nLet v = (1, 0, ..., 0) and u = (u, 0, ..., 0) where u 6= 0. In order to show differentiability, we will prove that g(u,v) has continuous partial derivatives at u (by equality (18) the partial derivatives are clearly continuous at points that are not on the u1 axis. Define u = (u, , 0, ..., 0). Then\n∂g\n∂u2 (u,v) = lim →0\n1 2π ‖u ‖ ‖v‖ ( sin θu ,v + ( π − θu ,v ) cos θu ,v ) − g(u,v)\nBy L’hopital’s rule and the calculation of equality (18) we get\n∂g\n∂u2 (u,v) = lim →0\n1\n2π ‖v‖ ‖u ‖ sin θ = 0\nFurthermore, by equality (18) we see that limu′→u ∂g ∂u2 (u′,v) = 0 since limu′→u sin θu′,v = 0.\nFor a fixed θu,v equal to 0 or π, ∂g ∂u1 (u,v) is the same as ∂g∂‖u‖ (u,v). Hence,\n∂g\n∂u1 (u,v) =\n1\n2π ‖v‖\n( sin θu,v + ( π − θu,v ) cos θu,v ) = { 1 2 if u > 0 0 if u < 0\nand the partial derivative is continuous since\nlim u′→u\n∂g\n∂u1 (u′,v) = { 1 2 if u > 0 0 if u < 0\nFinally, we see that for the case where u and v are parallel, the values we got for the partial derivatives coincide with equation Eq. 18. This concludes the proof."
    }, {
      "heading" : "B Proof of Proposition 4.1",
      "text" : "We will prove the claim by induction on k. For the base case we will show that Set-Splitting-by-2-Sets is NP-complete. We will prove this via a reduction from a variant of the 3-SAT problem with the restriction of equal number of variables and clauses, which we denote Equal-3SAT. We will first prove that Equal-3SAT is NP-complete.\nLemma B.1. Equal-3SAT is NP-complete.\nProof. This can be shown via a reduction from 3SAT. Given a formula φ with n variables and m clauses we can increase n −m by 1 by adding a new clause of the form (x ∨ y) for new variables x and y. Furthermore, we can decrease n−m by 1 by adding two new identical clauses of the form (z) for a new variable z. In each case the formula with the new clause(s) is satisfiable if and only if φ is. Therefore given a formula φ we can construct a new formula ψ with equal number of variables and clauses such that φ is satisfiable if and only if ψ is.\nWe will now give a reduction from Equal-3SAT to Set-Splitting-by-2-Sets.\nLemma B.2. Set-Splitting-by-2-Sets is NP-complete.\nProof. The following reduction is exactly the reduction from 3SAT to Splitting-Sets and we include it here for completeness. Let φ be a formula with set of variables V and equal number of variables and clauses. We construct the sets S and C as follows. Define\nS = {x̄ | x ∈ V } ∪ V ∪ {n}\nwhere x̄ is the negation of variable x and n is a new variable not in V . For each clause c with set of variables or negations of variables Vc that appear in the clause (for example, if c = (x̄ ∨ y) then Vc = {x̄, y}) construct a set Sc = Vc ∪ {n}. Furthermore, for each variable x ∈ V construct a set Sx = {x, x̄}. Let C be the family of subsets Sc and Sx for all clauses c and x ∈ V . Note that |C|≤ |S| which is required by the definition of Set-Splitting-by-2-Sets.\nAssume that φ is satisfiable and let A be the satisfying assignment. Define S1 = {x|A(x) = true}∪{x̄|A(x) = false} and S2 = {x|A(x) = false}∪{x̄|A(x) = true}∪{n}. Note that S1∪S2 = S. Assume by contradiction that there exists a set T ∈ C such that T ⊆ S1 or T ⊆ S2. If T ⊆ S1 then T is not a set Sc for some clause c because n /∈ S1. However, by the construction of S1 a variable and its negation cannot be in S1. Hence T ⊆ S1 is impossible. If T ⊆ S2 then as in the previous claim T cannot be a set Sx for a variable x. Hence T = Sc for some clause c. However, this implies that A(c) = false, a contradiction.\nConversely, assume there exists splitting sets S1 and S2 and w.l.o.g. n ∈ S1. We note that it follows that no variable x and its negation x̄ are both contained in one of the sets S1 or S2. Define the following assignment A for φ. For all x ∈ V if x ∈ S1 let A(x) = false, otherwise let A(x) = true. Note that A is a well defined assignment. Assume by contradiction that there is a clause c in φ which is not satisfiable. Since S2 splits Sc it follows that there exists a variable x such that it or its negation x̄ are in S2 (recall that n ∈ S1). If x ∈ S2 then A(x) = true and if x̄ ∈ S2 then A(x̄) = true since x ∈ S1. In both cases c is satisfiable, a contradiction.\nThis proves the base case. We will now prove the induction step by giving a reduction from SetSplitting-by-k-Sets to Set-Splitting-by-(k+1)-Sets. Given S = {1, 2, ..., d} and C = {Cj}j such that |C| ≤ (k − 1)d, define S′ = {1, 2, ..., d + 1} and C′ = C ∪{Dj}j where Dj = {j, d + 1} for all 1 ≤ j ≤ d. Note that |C′| ≤ kd < k(d + 1). Assume that there are S1, ..., Sk that split the sets in C. Then if we define Sk+1 = {d+ 1}, it follows that ⋃k+1 i=1 Si = S and S1, ..., Sk, Sk+1 are disjoint and split the sets in C′. Conversely, assume that S1, ..., Sk, Sk+1 split the sets in C′. Let w.l.o.g. Sk+1 be the set that contains d+ 1. Then for all 1 ≤ j ≤ d we have Dj 6⊆ Sk+1. It follows that for all 1 ≤ j ≤ d, j /∈ Sk+1, or equivalently, Sk+1 = {d+ 1}. Hence, ⋃k i=1 Si = S and S1, ..., Sk are disjoint and split the sets in C, as desired."
    }, {
      "heading" : "C Missing Proofs for Section 5",
      "text" : "C.1 Proof of Lemma 5.1\n1. For w 6= 0, the claim follows from Lemma 3.2. As in the proof of Lemma 3.2 we can assume w.l.o.g. that w = (0, 0, ..., 0) and w∗ = (1, 0, ..., 0). Let f(w,w∗) = 2kg(w,w∗) + (k2 − k)‖w‖‖w\n∗‖ π . It suffices to show that ∂f ∂u2 (w,w∗) does not exist. Indeed, let w = (0, , 0, ..., 0) then by L’hopital’s rule\nlim →0+\nf(w ,w ∗)− f(w,w∗)\n= lim →0+\nk π ‖w∗‖ | | sin θw ,w∗ + (k 2 − k)‖w ∗‖ π = k π + k2 − k π\nand\nlim →0−\nf(w ,w ∗)− f(w,w∗)\n= lim →0−\nk π ‖w∗‖ | | sin θw ,w∗ − (k2 − k) ‖w∗‖ π = −k π − k 2 − k π\nHence the left and right partial derivatives with respect to variable u2 are not equal, and thus ∂f ∂u2 (w,w∗) does not exist.\n2. We first show that w = 0 is a local maximum if and only if k > 1. Indeed, by considering the loss function as a function of the variable x = ‖w‖, for any fixed angle θw,w∗ we get a quadratic function of the form `(x) = ax2 − bx, where a > 0 and b ≥ 0. Since f(θ) = sin θ + (π − θ) cos θ is a non-negative function for 0 ≤ θ ≤ π and f(θ) = 0 if and only if θ = π, it follows that b = 0 if and only if k = 1 and θw,w∗ = π. Therefore if k > 1, then for all fixed angles θw,w∗ , the minimum of `(x) is attained at x > 0, which implies that w = 0 is a local maximum. If k = 1 and θw,w∗ = π the minimum of `(x) is attained at x = 0, and thus w = 0 is not a local maximum in this case.\nWe will now find the other critical points of `. By Lemma 3.2 we get\n∇`(w) = 1 k2\n[( k +\nk2 − k π\n) w − k\nπ ‖w∗‖ w ‖w‖ sin θw,w∗ − k π\n( π − θw,w∗ ) w∗ − k\n2 − k π ‖w∗‖ w ‖w‖\n]\n= 1\nk2\n[( k +\nk2 − k π − k ‖w ∗‖ π ‖w‖ sin θw,w∗ − k2 − k π ‖w∗‖ ‖w‖\n) w − k\nπ\n( π − θw,w∗ ) w∗ ] (19)\nand assume it vanishes.\nDenote θ , θw,w∗ . If θ = 0 then let w = αw∗ for some α > 0. It follows that\nk + k2 − k π − k 2 − k π 1 α − k α = 0\nor equivalently α = 1, and thus w = w∗.\nIf θ = π then ‖w‖ = k 2−k k2+(π−1)k ‖w ∗‖ and thus w = −( k 2−k k2+(π−1)k )w ∗. By setting θ = π in the loss function, one can see that w = −( k 2−k\nk2+(π−1)k )w ∗ is a one-dimensional local minimum, whereas\nby fixing ‖w‖ and decreasing θ, the loss function decreases. It follows that w = −( k 2−k k2+(π−1)k )w ∗ is a saddle point. If θ 6= 0, π then w and w∗ are linearly independent and thus kπ ( π − θ ) = 0 which is a contradiction. It remains to show that u = −γ(k)w∗ where γ(k) = k 2−k\nk2+(π−1)k is a degenerate saddle point. We\nwill show that the Hessian at u denoted by ∇2`(u), has only nonnegative eigenvalues and at least one zero eigenvalue. Let ˜̀(w) , `(w, Rw∗), where the second entry denotes the ground truth weight vector and R is a rotation matrix. Denote by fd1,d2 the second directional derivative of a function f in directions d1 and d2. Similarly to the proof of Lemma 3.2, since ` depends only on ‖w‖, ‖w∗‖ and θw,w∗ , we notice that\n`d1,d2(w) = ˜̀ Rd1,Rd2(Rw)\nor equivalently\ndT1∇2`(w)d2 = (Rd1)T∇2 ˜̀(Rw)Rd2 = dT1 RT∇2 ˜̀(Rw)Rd2\nfor any w and directions d1 and d2. It follows that\n∇2`(w) = RT∇2 ˜̀(Rw)R\nfor all w. Since R is an orthogonal matrix, we have that ∇2`(w) and ∇2 ˜̀(Rw) are similar matrices and thus have the same eigenvalues. Therefore, we can w.l.o.g. rotate w∗ such that it will be on the w1 axis.\nBy symmetry we have\n∂`\n∂w1∂wi (u) =\n∂`\n∂w1∂wj (u),\n∂`\n∂wi∂w1 (u) =\n∂`\n∂wj∂w1 (u)\nand ∂`\n∂w2i (u) =\n∂`\n∂w2j (u),\n∂`\n∂wi∂wj (u) =\n∂`\n∂ws∂wt (u)\nfor i 6= j, s 6= t such that i, j, s, t 6= 1. It follows that we only need to consider second partial derivatives with respect to 3 axes w1,w2 and w3. Denote u = (−γ(k), , 0, ..., 0) and w∗ = (1, 0, ..., 0) and β(k) = k\n2−k π and note that γ(k) = β(k) β(k)+k . Then by equation Eq. 19 we have\n∂`\n∂w22 (u) = lim →0\n∇`(u )x −∇`(u)x\n= lim →0\n1 k2\n[( k + β(k) ) − kπ ‖w ∗‖ ‖u ‖ sin θu ,w∗ − β(k) ‖w ∗‖ ‖u ‖ ]\n= 1 k2 ( k + β(k)− β(k) γ(k) ) = 0\n(20)\nFurthermore,\n∂`\n∂w1∂w2 (u) = lim →0\n∇`(u )y −∇`(u)y\n= lim →0\n1 k2\n[ − ( k + β(k) ) γ(k) + kπ ‖w ∗‖ γ(k)‖u ‖ sin θu ,w∗ + β(k) ‖w ∗‖ γ(k)‖u ‖ − k π (π − θu ,w∗) ]\n(21)\nwhere θu ,w∗ = arccos( −γ(k)√ 2+γ2(k) ).\nBy L’Hopital’s rule we have\n∂`\n∂w1∂w2 (u) = lim →0 −γ(k) sin θu ,w ∗ πk‖u ‖3 + γ(k) cos θu ,w∗\n∂θu ,w∗\n∂w2 πk ‖u ‖ − β(k)γ(k) ‖u ‖3 +\n∂θu ,w∗\n∂w2 πk\n= 1\nπk lim →0\n∂θu ,w∗\n∂w2\n(γ(k) cos θu ,w∗ ‖u ‖ + 1 ) (22)\nSince ∂θu ,w∗\n∂w2 (u ) = − 1 | |√\n2+γ2(k)\nγ(k)\n( 2 + γ2(k)) 3 2 = − γ(k) ( 2 + γ2(k))| |\nit follows that\n∣∣∣∣ ∂`∂w1∂w2 (u) ∣∣∣∣ = 1πk lim →0 ∣∣∣∣∂θu ,w∗∂w2 ∣∣∣∣ ∣∣∣∣γ(k) cos θu ,w∗‖u ‖ + 1 ∣∣∣∣ ≤ 1 γ(k)πk lim →0 ∣∣∣∣γ(k) cos θu ,w∗‖u ‖ + 1 ∣∣∣∣ = 0 (23)\nand thus ∂`∂w1∂w2 (u) = 0. Taking derivatives of the gradient with respect to w1 is easier because the expressions in Eq. 19 that depend on θw,w∗ and w ‖w‖ are constant. Therefore,\n∂`\n∂w21 (u) =\nk + β(k)\nk2\nand ∂`\n∂w2∂w1 (u) = 0\nFinally let ũ = (0,−γ(k), , 0, ..., 0) then it is easy to see that\n∂`\n∂w2∂w3 (u) = lim →0\n∇`(ũ )w2 −∇`(u)w2\n= 0\n. Therefore, overall we see that ∇2`(u) is a diagonal matrix with zeros and k+β(k)k2 > 0 on the diagonal, which proves our claim.\nC.2 Proof of Theorem 5.2\nFor the following lemmas let wt+1 = wt − λ∇`(wt), θt be the angle between wt and w∗ (t ≥ 0) and define λ̃ = α(k)λ where α(k) = 1k + k2−k πk2 . Note that α(k) ≤ 1 for all k ≥ 1 The following lemma shows that for λ < 1, the angle between wt and w ∗ decreases in each iteration.\nLemma C.1. If 0 < θt < π and λ < 1 then θt+1 < θt.\nProof. This follows from the fact that adding\n− λ k2\n( k +\nk2 − k π − k ‖w ∗‖ π ‖wt‖ sin θt − k2 − k π ‖w∗‖ ‖wt‖\n) wt\nto wt does not change θt for λ < 1, since k+ k\n2−k π\nk2 ≤ 1 for k ≥ 1. In addition, adding λ πk\n( π − θ ) w∗\ndecreases θt.\nWe will need the following two lemmas to establish a lower bound on ‖wt‖.\nLemma C.2. If π2 < θt < π then ‖wt+1‖ ≥ sin θt sin θt+1 min{‖wt‖ , ‖w ∗‖ sin θt α(k)π }.\nProof. Let\nut = wt − λ\nk2\n( k +\nk2 − k π − k ‖w ∗‖ π ‖wt‖ sin θt − k2 − k π ‖w∗‖ ‖wt‖\n) wt\nNotice that if ‖wt‖ ≤ ‖w ∗‖ sin θt α(k)π then\n‖ut‖ = (1− λ̃) ‖wt‖+ λ ‖w∗‖ πk sin θt + λ(k2 − k) ‖w∗‖ πk2\n≥ (1− λ̃) ‖wt‖+ λk ‖w∗‖ sin θt πk2 + λ(k2 − k) ‖w∗‖ sin θt πk2 = (1− λ̃) ‖wt‖+ λ̃ ‖w∗‖ sin θt\nα(k)π ≥ ‖wt‖\n(24)\nSimilarly, if ‖wt‖ ≥ ‖w ∗‖ sin θt α(k)π then ‖ut‖ ≥ ‖w∗‖ sin θt α(k)π . Furthermore, by a simple geometric ob-\nservation we see that ‖wt+1‖ cos(θt+1 − π2 ) = ‖ut‖ cos(θt − π 2 ) if θt+1 > π 2 and ‖wt+1‖ cos( π 2 − θt+1) = ‖ut‖ cos(θt − π2 ) if θt+1 ≤ π 2 . This is equivalent to ‖wt+1‖ = sin θt sin θt+1\n‖ut‖. It follows that ‖wt+1‖ ≥ sin θtsin θt+1 min{‖wt‖ , ‖w∗‖ sin θt α(k)π } as desired.\nLemma C.3. If 0 < θt ≤ π2 and 0 < λ < 1 2 then ‖wt+1‖ ≥ min{‖wt‖ , ‖w∗‖ 8 }\nProof. First assume that k ≥ 2. Let ut be as in Lemma C.2, then\n‖ut‖ ≥ (1− λ̃) ‖wt‖+ λ̃(k2 − k) ‖w∗‖\nα(k)πk2\nIt follows that if ‖wt‖ ≥ (k 2−k)‖w∗‖ α(k)πk2 ≥ ‖w∗‖ 2π then ‖ut‖ ≥ ‖w∗‖ 2π . Otherwise if ‖wt‖ ≤ (k2−k)‖w∗‖ α(k)πk2 then ‖ut‖ ≥ ‖wt‖. Since wt+1 = ut + λπk ( π − θ ) w∗ and 0 < θt ≤ π2 we have ‖wt+1‖ ≥ ‖ut‖ ≥ min{‖w ∗‖\n2π , ‖wt‖}. Now let k = 1. Note that in this case λ̃ = λ. First assume that θt < π 3 . If ‖wt‖ ≥ ‖w∗‖ 4 then,\nusing the same notation as in Lemma C.2, ‖ut‖ ≥ (1 − λ) ‖wt‖ + λ‖w ∗‖ sin θt π ≥ ‖wt‖ 2 ≥ ‖w∗‖ 8 . Since wt+1 = ut + λ π ( π − θt ) w∗ and 0 < θt ≤ π2 we have ‖wt+1‖ ≥ ‖ut‖ ≥ ‖w∗‖ 8 . If ‖wt‖ < ‖w∗‖ 4 then by the facts 0 < θt ≤ π2 and cos θt > 1 2 we get\n‖wt+1‖2 = ‖ut‖2 + 2 ‖ut‖ ∥∥∥∥λπ(π − θt)w∗ ∥∥∥∥ cos θt + ∥∥∥∥λπ(π − θt)w∗ ∥∥∥∥2\n≥ (1− λ)2 ‖wt‖2 + (1− λ)λ\n2 ‖wt‖ ‖w∗‖+\nλ2\n4 ‖w∗‖2\n≥ (1− λ)2 ‖wt‖2 + 2(1− λ)λ ‖wt‖2 + 4λ2 ‖wt‖2 = (1 + 3λ2) ‖wt‖2 ≥ ‖wt‖2\n(25)\nFinally, assume θt ≥ π3 . As in the proof of Lemma C.2, if ‖wt‖ ≥ ‖w∗‖ sin θt π ≥ √ 3 2 ‖w∗‖ π then\n‖wt+1‖ ≥ ‖ut‖ ≥ √ 3 2 ‖w∗‖ π . Otherwise, if ‖wt‖ < ‖w∗‖ sin θt π then ‖wt+1‖ ≥ ‖ut‖ ≥ ‖wt‖. This concludes our proof.\nWe can now show that in each iteration ‖wt‖ is bounded away from 0 by a constant.\nProposition C.4. Assume GD is initialized at w0 such that θ0 6= π and runs for T iterations with learning rate 0 < λ < 12 . Then for all 0 ≤ t ≤ T ,\n‖wt‖ ≥ min{‖w0‖ sin θ0, ‖w∗‖ sin2 θ0 α(k)π , ‖w∗‖ 8 }\nProof. Let θ0 > θ1 > ... > θT (by Lemma C.1). Let i be the last index such that θi > π 2 (if such i does not exist let i = −1). Since sin θj > sin θ0 for all 0 ≤ j ≤ i, by applying Lemma C.2 at most j + 1 times we have\n‖wj+1‖ ≥ min{‖w0‖ sin θ0, ‖w∗‖ sin2 θ0\nα(k)π }\nfor all 0 ≤ j ≤ i. Finally, by Lemma C.3 and the fact that θj ≤ π2 for all i < j ≤ T , we get\n‖wj‖ ≥ min{‖wi+1‖ , ‖w∗‖\n8 }\nfor all i+ 1 < j ≤ T , from which the claim follows.\nThe following lemma shows that ∇` is Lipschitz continuous at points that are bounded away from 0.\nLemma C.5. Assume ‖w1‖ , ‖w2‖ ≥M , w1,w2 and w∗ are on the same two dimensional half-plane defined by w∗, then\n‖∇`(w1)−∇`(w2)‖ ≤ L ‖w1 −w2‖\nfor L = 1 + 3‖w ∗‖\nM .\nProof. Recall that by equality Eq. 18,\n∂g ∂w (w,w∗) = 1 2π ‖w∗‖ w ‖w‖ sin θw,w∗ + 1 2π\n( π − θw,w∗ ) w∗\nLet θ1 and θ2 be the angles between w1,w ∗ and w2,w ∗, respectively. By the inequality x0 sin xsin x0 ≥ x for 0 ≤ x ≤ x0 < π and since |θ1−θ2|2 ≤ π 2 we have\n|θ1 − θ2| 2 ≤ π sin |θ1−θ2|2 2\nFurthermore ‖w1 −w2‖ is minimized (for fixed angles θ1 and θ2) when ‖w1‖ = ‖w2‖ = M and is equal to 2M sin |θ1−θ2|2 . Thus, under our assumptions we have,\n|θ1 − θ2| 2 ≤ π sin |θ1−θ2|2 2 ≤ π ‖w1 −w2‖ 4M\nThus we get ∥∥∥∥ 12π(π − θ1)w∗ − 12π(π − θ2)w∗ ∥∥∥∥ ≤ ‖w∗‖4M ‖w1 −w2‖\nFor the first summand, we will first find the parameterization of a two dimensional vector of length sin θ where θ is the angle between the vector and the positive x axis. Denote this vector by (a, b), then the following holds\na2 + b2 = sin2 θ\nand b\na = tan θ\nThe solution to these equations is (a, b) = ( sin 2θ2 , sin 2 θ). Hence (here we use the fact that w1,w2 are on the same half-plane)∥∥∥∥ 12π ‖w∗‖ w1‖w1‖ sin θ1 − 12π ‖w∗‖ w2‖w2‖ sin θ2 ∥∥∥∥ = 12π ‖w∗‖ √( sin 2θ1 2 − sin 2θ2 2 )2 + ( sin2 θ1 − sin2 θ2 )2\n≤ 1 2π ‖w∗‖\n√ (θ1 − θ2)2 + 4(θ1 − θ2)2\n≤ √ 5\nπ ‖w∗‖ π ‖w1 −w2‖ 4M\n= √ 5 ‖w∗‖ 4M\n‖w1 −w2‖ (26)\nwhere the first inequality follows from the fact that | sinx−sin y| ≤ |x−y| and the second inequality from previous results. In conclusion, we have∥∥∥∥ ∂g∂w (w1,w∗)− ∂g∂w (w2,w∗)\n∥∥∥∥ ≤ (√5 + 1) ‖w∗‖4M ‖w1 −w2‖ Similarly, in order to show that the function f(w) = w‖w‖ is Lipschitz continuous, we parameterize the unit vector by (cos θ, sin θ) where θ is the angle between the vector and the positive x axis. We now obtain ∥∥∥∥ w1‖w1‖ − w2‖w2‖\n∥∥∥∥ = √(cos θ1 − cos θ2)2 + (sin θ1 − sin θ2)2 ≤ √ 2(θ1 − θ2)2\n≤ π ‖w1 −w2‖√ 2M\n(27)\nNow we can conclude that\n‖∇`(w1)−∇`(w2)‖ ≤ (1 k + k2 − k πk2 ) ‖w1 −w2‖+ 2 k ∥∥∥∥ ∂g∂w (w1,w∗)− ∂g∂w (w2,w∗) ∥∥∥∥\n+ ( (k2 − k) ‖w∗‖\nπk2\n)∥∥∥∥ w1‖w1‖ − w2‖w2‖ ∥∥∥∥\n≤ (1 k + k2 − k πk2 + (k2 − k) ‖w∗‖√ 2Mk2 + ( √ 5 + 1) ‖w∗‖ 2Mk ) ‖w1 −w2‖ ≤ 1 + ‖w ∗‖√\n2M +\n( √\n5 + 1) ‖w∗‖ 2M\n≤ 1 + 3 ‖w ∗‖\nM\n(28)\nGiven that ` is Lipschitz continuous we can now follow standard optimization analysis ((Nesterov, 2004)) to show that limt→∞ ‖∇`(wt)‖ = 0.\nProposition C.6. Assume GD is initialized at w0 such that θ0 6= π and runs with a constant learning rate 0 < λ < min{ 2L , 1 2} where L = Õ(1). Then for all T\nT∑ t=0 ‖∇`(wt)‖2 ≤ 1 λ(1− λ2L) `(w0)\nProof. We will need the following lemma\nLemma C.7. Let f : Rn → R be a continuously differentiable function on a set D ⊆ Rn and x, y ∈ D such that for all 0 ≤ τ ≤ 1, x + τ(y − x) ∈ D and ‖∇f(x+ τ(y − x))−∇f(x)‖ ≤ L ‖x− y‖. Then we have\n|f(y)− f(x)− 〈∇f(x), y − x〉| ≤ L 2 ‖x− y‖2\nProof. The proof exactly follows the proof of Lemma 1.2.3 in (Nesterov, 2004) and note that the proof only requires Lipschitz continuity of the gradient on the set S = {x+ τ(y − x) | 0 ≤ τ ≤ 1} and that S ⊆ D.\nBy Proposition C.4, for all t, ‖wt‖ ≥M ′ where\nM ′ = min{‖w0‖ sin θ0, ‖w∗‖ sin2 θ0 α(k)π , ‖w∗‖ 8 }\n. Furthermore, by a simple geometric observation we have\nmin 0≤τ≤1,‖w1‖,‖w2‖≥M ′,arccos (\nw1·w2 ‖w1‖‖w2‖\n) =θ ‖τw1 + (1− τ)w2‖ = M ′ cos θ 2\n. It follows by Lemma C.5 that for any t and x1,x2 ∈ St , {wt + τ(wt+1 −wt) | 0 ≤ τ ≤ 1},\n‖∇`(x1)−∇`(x2)‖ ≤ L ‖x1 − x2‖\nwhere L = 1 + 3‖w ∗‖\nM and M = M ′ cos θ02 (Note that cos θt−θt+1 2 ≥ cos θ0 2 for all t by Lemma C.1).\nHence by Lemma C.7, for any t we have\n`(wt+1) ≤ `(wt) + 〈∇`(wt),wt+1 −wt〉+ L\n2 ‖wt+1 −wt‖2\n= `(wt)− λ(1− λ\n2 L) ‖∇`(wt)‖2\n(29)\nwhich implies that\nT∑ t=0 ‖∇`(wt)‖2 ≤ 1 λ(1− λ2L) ( `(w0)− `(wT ) ) ≤ 1 λ(1− λ2L) `(w0)\nWe are now ready to prove the theorem.\nProof of Theorem 5.2. First, we observe that for a randomly initialized point w0, 0 ≤ θ0 ≤ π(1− δ) with probability 1−δ. Hence by Proposition C.6 we have for L = 1+ 3‖w\n∗‖ M where M = min{sin(π(1−\nδ)), sin 2(π(1−δ)) α(k)π , 1 8} cos( π(1−δ) 2 ) and α(k) = k + k2−k π , and for λ = 1 L (we assume w.l.o.g. that L > 2),\nT∑ t=0 ‖∇`(wt)‖2 ≤ 1 λ(1− λ2L) `(w0) = 2L`(w0) ≤ 4L k2 (k 2 + k2 − k 2π ) Therefore,\nmin 0≤t≤T\n{‖∇`(wt)‖2} ≤ 4L k2\n( k 2 + k2−k 2π ) T\nIt follows that gradient descent reaches a point wt such that ‖∇`(wt)‖ < after T iterations where\nT >\n( 4L k2 ( k 2 + k2−k 2π ))2 2\nWe will now show that if ‖∇`(wt)‖ < then wt is O( √ )-close to the global minimum w∗. First note that if π2 ≤ θt ≤ π(1−δ) then a vector of the form v = αw ∗+βw where α ≥ 0 is of minimal norm equal to α sin(π− θt) ‖w∗‖ when it is perpendicular to w. Since the gradient is a vector of this form, we have ‖∇`(wt)‖ > πδ‖w ∗‖ sinπδ πk ≥ δ sinπδ k ≥ . Hence, from now on we assume that 0 ≤ θt < π 2 .\nSimilarly to the previous argument, we have\n> ‖∇`(wt)‖ > ‖w∗‖ (π − π2 ) sin θt\nπk ≥ sin θt 2k\nHence, θt < arcsin(2k ) = O( ). It follows by the triangle inequality that\nk2 > k2 ‖∇`(wt)‖ = ∥∥∥∥∥ ( k + k2 − k π − k ‖w ∗‖ π ‖wt‖ sin θt − k2 − k π ‖w∗‖ ‖wt‖ ) wt − k(π − θt) π w∗ ∥∥∥∥∥ ≥ ∥∥∥∥∥ ( k + k2 − k π − k 2 − k π ‖w∗‖ ‖wt‖ ) wt − kw∗\n∥∥∥∥∥− k ‖w∗‖π sin θt − kθt ‖w∗‖π ≥ ∥∥∥∥∥ ( k + k2 − k π − k 2 − k π ‖w∗‖ ‖wt‖ ) wt − k ‖w∗‖ ‖wt‖ wt\n∥∥∥∥∥ − ∥∥∥∥kw∗ − k ‖w∗‖‖wt‖ wt\n∥∥∥∥− k ‖w∗‖π sin θt − kθt ‖w∗‖π ≥ ( k +\nk2 − k π\n) | ‖wt‖ − ‖w∗‖ | − k ‖w∗‖ θt −\nk ‖w∗‖ π sin θt − kθt ‖w∗‖ π\n(30)\nwhere the last inequality follows since the arc of a circle is larger than its corresponding segment. Therefore we get | ‖wt‖ − ‖w∗‖ | < O( ). By the bounds on θt and | ‖wt‖ − ‖w∗‖ | and the\ninequality cosx ≥ 1− x for x ≥ 0, we can give an upper bound on ‖wt −w∗‖:\n‖wt −w∗‖2 = ‖wt‖2 − 2 ‖wt‖ ‖w∗‖ cos θt + ‖w∗‖2\n= ‖wt‖ (‖wt‖ − ‖w∗‖ cos θt) + ‖w∗‖ (‖w∗‖ − ‖wt‖ cos θt) ≤ (‖w∗‖+O( ))(O( ) + θt ‖w∗‖) + ‖w∗‖ (O( 2) + θt ‖w∗‖) = O( )\n(31)\nFinally, to prove the claim it suffices to show that `(w) ≤ d‖w −w∗‖2. Denote the input vector x = (x1,x2, ...,xk) where xi ∈ Rm for all 1 ≤ i ≤ k. Then we get\n`(w) = Ex [∑k i=1 σ(w Txi) k − ∑k i=1 σ(w ∗Txi) k ]2 ≤ Ex [∑k i=1 |σ(wTxi)− σ(w∗\nTxi)| k ]2 ≤ Ex [∑k i=1 |wTxi −w∗\nTxi| k ]2 ≤ Ex [∑k i=1 ‖w −w∗‖ ‖xi‖\nk ]2 ≤ ‖w −w∗‖2Ex‖x‖2 = d‖w −w∗‖2\n(32)\nwhere the second inequality follows from Lipschitz continuity of σ, the third inequality from the Cauchy-Schwarz inequality and the last equality since ‖x‖2 follows a chi-squared distribution with d degrees of freedom."
    }, {
      "heading" : "D Missing Proofs for Section 7.1",
      "text" : "D.1 Proof of Proposition 7.1\nDefine wp = (w2, w1), w ∗ p1 = (0,−w ∗) and w∗p2 = (w ∗, 0). We first prove the following lemma.\nLemma D.1. Let l be defined as in Eq. 16. Then\n∇l(w) = 1 k2\n[( k +\nk2 − 3k + 2 π\n) w +\n2(k − 1) sin θwr,wl π w\n+ (k − 1)(π − θwr,wl)\nπ wp − (k2 − 3k + 2) ‖w∗‖ π ‖w‖ w\n− k ‖w ∗‖ sin θw,w∗ π ‖w‖ w − k(π − θw,w ∗) π w∗ − (k − 1) sin θwl,w∗r ‖w\n∗‖ π ‖w‖ w − (k − 1)(π − θwl,w∗r ) π w∗p2\n− (k − 1) sin θwr,w∗l ‖w ∗‖ π ‖w‖ w − (k − 1)(π − θwr,w∗l ) π w∗p1\n]\nProof. The gradient does not follow immediately from Lemma 3.2 because the loss has expressions with of the function g but with different dependencies on the parameters in w. We will only calculate ∂g(wr,wl)\n∂w , the other expressions are calculated in the same manner. Recall that\ng(wr,wl) = 1\n2π ‖w‖2(sin θwr,wl + (π − θwr,wl) cos θwr,wl)\nIt follows that\n∂g(wr,wl)\n∂w =\n1 π (sin θwr,wl + (π − θwr,wl) cos θwr,wl)w + 1 2π ‖w‖2(π − θwr,wl) ∂ cos θwr,wl ∂w\n(33)\nLet w = (w1, w2) then cos θwr,wl = w1w2 w21+w 2 2 . Then,\n∂ cos θwr,wl ∂w1 = w2(w\n2 1 + w 2 2)− 2w21w2 (w21 + w 2 2) 2 = w2 ‖w‖2 − 2w1 cos θwr,wl ‖w‖2\nand ∂ cos θwr,wl\n∂w2 = w1(w\n2 1 + w 2 2)− 2w22w1 (w21 + w 2 2) 2 = w1 ‖w‖2 − 2w2 cos θwr,wl ‖w‖2\nor equivalently ∂ cos θwr,wl ∂w = wp ‖w‖2 − 2w cos θwr,wl ‖w‖2 . It follows that\n∂g(wr,wl)\n∂w =\nsin θwr,wlw\nπ + (π − θwl,wr ) 2π wp\nWe will prove that wt+1 6= 0 and that it is in the interior of the fourth quadrant. Denote w = wt and ∇l(w) = 1k2 ( B1(w) +B2(w) +B3(w) ) where\nB1(w) = ( k +\nk2 − 3k + 2 π\n) w +\n2(k − 1) sin θwr,wl π w − (k 2 − 3k + 2) ‖w∗‖ π ‖A‖ w\n− k ‖w ∗‖ sin θw,w∗ π ‖w‖ w − (k − 1) sin θwl,w∗r ‖w ∗‖ π ‖w‖ w − (k − 1) sin θwr,w∗l ‖w ∗‖ π ‖w‖ w\nB2(w) = (k − 1)(π − θwr,wl)\nπ wp\n(34)\nand\nB3(w) = − k(π − θw,w∗)\nπ w∗ − (k − 1)(π − θwl,w∗r ) π w∗p2 − (k − 1)(π − θwr,w∗l ) π w∗p1\n(35)\nLet w = (w,−mw) for w,m ≥ 0. Straightforward calculation shows that cos θwl,w∗r = 1√\n2(1+m2)\nand cos θwr,w∗l = m√ 2(m2+1) . Hence π4 ≤ θwl,w∗r , θwr,w∗l ≤ π 2 . Since w is in the fourth quadrant we also have 3π4 ≤ θw,w∗ ≤ π. Therefore, adding −λB3(w) can only increase ‖w‖. This follows since in the worst case (the least possible increase of ‖w‖)\n−B3(w) = k\n4 w∗ + k − 1 2 w∗p2 + k − 1 2 w∗p1 = ( k − 2 4 w∗,−k − 2 4 w∗)\nwhich is in the fourth quadrant for k ≥ 2. In addition, since −wp is in the fourth quadrant then adding −λB2(w) increases ‖w‖.\nIf ‖w‖ < ‖w ∗‖\n16 then −B1(w) points in the direction of w since in this case −B1(w) = αw where\nα ≥ (k2 − 3k + 2\nπ + (k − 1) π − k − 1 8π − k 2 − 3k + 2 16π − k 16\n) ‖w∗‖ > 0\nfor k ≥ 2. If −B1(w) points in the direction of −w then by the assumption that λ ∈ (0, 13 ) we have ‖λB1(w)‖ < ‖w‖. Thus we can conclude that wt+1 6= 0.\nNow, let w = (w1, w2), θt be the angle between w = wt and the positive x axis and first assume that w1 > −w2. In this case −B3(w) least increases (or even most decreases) θt when\n−B3(w) = k\n4 w∗ + 3(k − 1) 4 w∗p2 + k − 1 2 w∗p1 = (2k − 3 4 w∗, 2− k 4 w∗ )\nwhich is a vector in the fourth quadrant for k ≥ 2. Otherwise, −B3(w) is a vector in the fourth quadrant as well. Note that we used the facts π4 ≤ θwl,w∗r , θwr,w∗l ≤ π 2 and 3π 4 ≤ θw,w∗ ≤ π. Since −λB1(w) does not change θt and −λB2(w) increases θt but never to an angle greater than or equal to π2 , it follows that 0 < θt+1 < π 2 .\nIf w1 ≤ −w2 then by defining all angles with respect to the negative y axis, we get the same argument as before. This shows that wt+1 is in the interior of the fourth quadrant, which concludes our proof.\nD.2 Proof of Proposition 7.2\nWe will need the following auxiliary lemmas. Lemma D.2. Let w be in the fourth quadrant, then g(wl,wr) ≥ 12π (√ 3 2 − π 6 ) ‖w‖2.\nProof. First note that the function s(θ) = sin θ+ (π− θ) cos θ is decreasing as a function of θ ∈ [0, π]. Let w = (w,−mw) for w,m ≥ 0. Straightforward calculation shows that cos θwl,wr = − mm2+1 . As a function of m ∈ [0,∞), cos θwl,wr is minimized for m = 1 with value − 12 , i.e., when θ(wl,wr) = 2π 3\nand this is the largest angle possible. Thus g(wl,wr) ≥ 12π s( 2π 3 ) ) ‖w‖2 = 12π (√ 3 2 − π 6 ) ‖w‖2.\nLemma D.3. Let f(θ) = 2k ( sin( 3π\n4 + θ) + (\nπ 4 − θ) cos(3π 4 + θ) ) + ( 2k − 2 )(√ 1− cos θ 2\n2 + (π − arccos cos θ√ 2 ) cos θ√ 2\n) + ( 2k − 2 )(√ 1− sin θ 2\n2 + (π − arccos sin θ√ 2 ) sin θ√ 2 ) (36)\n, then in the interval θ ∈ [0, π4 ], f(θ) is maximized at θ = π 4 for all k ≥ 2.\nProof. We will maximize the function f(θ)2(k−1) = k k−1f1(θ) + f2(θ) + f3(θ) where f1(θ), f2(θ), f3(θ) correspond to the three summands in the expression of f(θ). Since for h(x) = √ 1− x2 + (π − arccos(x))x we have h′(x) = π − arccos(x), it follows that f ′2(θ) = −(π − arccos cos θ√2 ) sin θ√ 2 , f ′3(θ) = (π − arccos sin θ√2 ) cos θ√ 2 and f ′1(θ) = −(π4 − θ) sin( 3π 4 + θ). It therefore suffices to show that\nd1(θ) := (π − arccos sin θ√ 2 ) cos θ√ 2 − (π − arccos cos θ√ 2 ) sin θ√ 2 − k k − 1 ( π 4 − θ) sin(3π 4 + θ) ≥ 0\nfor θ ∈ [0, π4 ]. By applying the inequalities arccos(x) ≤ π2 − x for x ∈ [0, 1] and arccos(x) ≥ π 2 − x − 1 10 for x ∈ [ 12 , 1√ 2 ] we get d1(θ) ≥ d2(θ) where\nd2(θ) = (π\n2 + sin θ√ 2 )cos θ√ 2 − (π 2 + cos θ√ 2 + 1 10 ) sin θ√ 2 − k k − 1 ( π 4 − θ) sin(3π 4 + θ)\n= π\n2 √ 2 cos θ − ( π 2 √ 2 + 1 10 √ 2 ) sin θ − k k − 1 ( π 4 − θ) sin(3π 4 + θ)\n(37)\nWe notice that d2(0) ≥ 0 and d2( 34 ) ≥ 0 for all k ≥ 2. In addition,\nd′2(θ) = − π\n2 √ 2 sin θ − ( π 2 √ 2 + 1 10 √ 2 ) cos θ + k k − 1 sin( 3π 4 + θ)− k k − 1 ( π 4 − θ) cos(3π 4 + θ)\nand d′2(0) > 0 for all k ≥ 2. It follows that in order to show that d2(θ) ≥ 0 for θ ∈ [0, 34 ] and k ≥ 2, it suffices to show that d′′2(θ) ≤ 0 for θ ∈ [0, 34 ] and k ≥ 2. Indeed,\nd′′2(θ) = − π\n2 √ 2 cos θ + ( π 2 √ 2 + 1 10 √ 2 ) sin θ + 2k k − 1 cos( 3π 4 + θ) + k k − 1 ( π 4 − θ) sin(3π 4 + θ)\n≤ ( 1\n10 √ 2 +\nk k − 1 π 4\n) max{sin θ, sin(3π\n4 + θ)}+ 2k k − 1 cos( 3π 4 + θ) ≤ 0\n(38)\nfor all θ ∈ [0, 34 ] and k ≥ 2. Note that the first inequality follows since cos θ ≥ sin θ and the second since cos( 3π4 +θ) ≥ max{sin θ, sin( 3π 4 +θ)}, both for θ ∈ [0, 3 4 ]. This shows that d1(θ) ≥ 0 for θ ∈ [0, 3 4 ].\nNow assume that θ ∈ [ 34 , π 4 ]. Since d1( 3 4 ) ≥ 0 and d1( π 4 ) ≥ 0, it suffices to prove that d ′ 1(θ) ≤ 0 for\nθ ∈ [ 34 , π 4 ]. Indeed, for all θ ∈ [ 3 4 , π 4 ]\nd′1(θ) = −(π − arccos cos θ√ 2 ) cos θ√ 2 − (π − arccos sin θ√ 2 ) sin θ√ 2\n+ cos2 θ 2 √ 1− sin2 θ2 +\nsin2 θ 2 √ 1− cos2 θ2 + k k − 1 sin( 3π 4 + θ)− k k − 1 ( π 4 − θ) cos(3π 4 + θ)\n≤ −(π − arccos cos(π4 )√ 2 ) cos(π4 )√ 2 − (π − arccos sin( 34 )√ 2 ) sin( 34 )√ 2 + cos2( 34 )\n2 √ 1− sin 2(π4 )\n2\n+ sin2(π4 )\n2 √ 1− cos 2( 34 )\n2\n+ 2 sin( 3π\n4 +\n3 4 )− 2(π 4 − 3 4 ) cos( 3π 4 + 3 4 ) < 0\n(39)\nWe conclude that d1(θ) ≥ 0 for all θ ∈ [0, π4 ] as desired.\nProof of Proposition 7.2. First assume that w1 ≥ −w2. Let θ be the angle between w and the positive x axis. Then cos θ = w1‖w‖ and tan θ = − w2 w1 . Therefore we get\ncos θwl,w∗r = w1\n‖w‖ √ 2 = cos θ√ 2\nand\ncos θwr,w∗l = −w2 ‖w‖ √ 2 = cos θ tan θ√ 2 = sin θ√ 2\nWe can rewrite `(w) as\n`(w) = 1\nk2\n[ k2 − 3k + 2\n2π (‖w‖ − ‖w∗‖)2 + k 2 ‖w‖2 + 2(k − 1)g(wr,wl)\n− ‖w‖ ‖w ∗‖\n2π\n( 2k ( sin( 3π\n4 + θ) + (\nπ 4 − θ) cos(3π 4 + θ) )) + ( 2k − 2 )(√ 1− cos θ 2\n2 + (π − arccos cos θ√ 2 ) cos θ√ 2\n) + ( 2k − 2 )(√ 1− sin θ 2\n2 + (π − arccos sin θ√ 2 ) sin θ√ 2 )) + k\n2 ‖w∗‖2 + 2(k − 1)g(w∗r ,w∗l ) ] (40)\nHence by Lemma D.2 and Lemma D.3 we can lower bound `(w) as follows\n`(w) ≥ 1 k2\n[ k2 − 3k + 2\n2π (‖w‖ − ‖w∗‖)2 + k 2 ‖w‖2 + k − 1 π (√3 2 − π 6 ) ‖w‖2\n− (k − 1) ‖w‖ ‖w ∗‖\nπ\n(√ 3 + 2π\n3\n) + k\n2 ‖w∗‖2 + k − 1 π (√3 2 − π 6 ) ‖w∗‖2 ] (41) By setting ‖w‖ = α ‖w∗‖ we get\n`(w) ‖w∗‖2 ≥ 1 k2\n[ k2 − 3k + 2\n2π (α− 1)2 + k 2 α2 + k − 1 π (√3 2 − π 6 ) α2\n− (k − 1) π\n(√ 3 + 2π\n3\n) α+ k\n2 + k − 1 π (√3 2 − π 6\n)] (42)\nSolving for α that minimizes the latter expression we obtain\nα∗ = k2−3k+2 π + (k−1) π\n(√ 3 + 2π3 ) k + k\n2−3k+2 π + 2(k−1) π ( √ 3 2 − π 6\n) = h(k) h(k) + 1\nPlugging α∗ back to the inequality we get\n`(w) ≥ 1 k2 (h(k) + 1 2 (α∗)2 − h(k)α∗ + h(k) + 1 2 ) ‖w∗‖2 = 2h(k) + 1 k2(2h(k) + 2) ‖w∗‖2\nand for w̃ = −α∗w∗ it holds that `(w̃) = 2h(k)+1k2(2h(k)+2)‖w ∗‖2.\nFinally, assume w1 ≤ −w2. In this case, let θ be the angle between w and the negative y axis. Then cos θ = −w2‖w‖ and tan θ = − w1 w2 . Therefore\ncos θwl,w∗r = w1\n‖w‖ √ 2 = cos θ tan θ√ 2 = sin θ√ 2\nand\ncos θwr,w∗l = −w2 ‖w‖ √ 2 = cos θ√ 2\nNotice that from now on we get the same analysis as in the case where w1 ≥ −w2, where we switch between expressions with wl,w ∗ r and expressions with wr,w ∗ l . This concludes our proof."
    }, {
      "heading" : "E Experimental Setup for Section 7.2",
      "text" : "In our experiments we estimated the probability of convergence to the global minimum of a randomly initialized gradient descent for many different ground truths w∗ of a convolutional neural network with overlapping filters. For each value of number of hidden neurons, filter size, stride length and ground truth distribution we randomly selected 30 different ground truths w∗ with respect to the given distribution. We tested with all combinations of values given in Table 1.\nFurthermore, for each combination of values of number of hidden neurons, filter size and stride length we tested with deterministic ground truths: ground truth with all entries equal to 1, all entries equal to -1 and with entries that form an increasing sequence from -1 to 1, -2 to 0 and 0 to 2 or decreasing sequence from 1 to -1, 0 to -2 and 2 to 0.\nFor each ground truth, we ran gradient descent 20 times and for each run we recorded whether it reached a point very close to the unique global minimum or it repeatedly (5000 consecutive iterations) incurred very low gradient values and stayed away from the global minimum. We then calculated the empirical probability p̂ = #times reached global minimum20 . To compute the one-sided confidence interval we used the Wilson method ((Brown et al., 2001)) which gives a lower bound\np̂+ z2α 2n + zα √ p̂(1−p̂) n + z2α 4k2\n1 + z2α n\n(43)\nwhere zα is the Z-score with α = 0.05 and in our experiments n = 20. Note that we initialized gradient descent inside a large hypercube such that outside the hypercube the gradient does not vanish (this can be easily proved after writing out the gradient for each setting).\nFor all ground truths we got p̂ ≥ 0.15, i.e., for each ground truth we reached the global minimum at least 3 times. Hence the confidence interval lower bound Eq. 43 is greater than 117 in all settings. This suggests that with a few dozen repeated runs of a randomly initialized gradient descent, with high probability it will converge to the global minimum."
    }, {
      "heading" : "F Uniqueness of Global Minimum in the Population Risk",
      "text" : "Without loss of generality we assume that the filter is of size 2 and the stride is 1. The proof of the general case follows the same lines. Assume that `(w) = 0 and denote w = (w1, w2), w ∗ = (w∗1 , w ∗ 2). Recall that `(w) = EG [ (f(x;W )− f(x;W ∗))2 ] where f(x;W ) = 1k ∑ i σ (wi · x) and for all 1 ≤ i ≤ k wi = (0i−1,w,0d−i−1). By equating `(w) to 0 we get that (f(x;W )− f(x;W ∗))2 = 0 almost surely. Since (f(x;W ) − f(x;W ∗))2 is a continuous function it follows that f(x;W ) − f(x;W ∗) = 0 for all x. In particular this is true for x1 = (x, 0, 0, ..., 0), x ∈ R. Thus σ (xw1) = σ (xw∗1) for all x ∈ R which implies that w1 = w ∗ 1 . The equality holds also for x2 = (0, x, 0, ..., 0), x ∈ R which implies that σ (xw2)+σ (xw1) = σ (xw ∗ 2)+σ (xw ∗ 1) for all x ∈ R. By the previous result, we get σ (xw2) = σ (xw∗2) for all x ∈ R and thus w2 = w∗2 . We proved that w = w∗ and therefore w∗ is the unique global minimum."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "Deep learning models are often successfully trained using gradient descent, despite the worst<lb>case hardness of the underlying non-convex optimization problem. The key question is then under<lb>what conditions can one prove that optimization will succeed. Here we provide a strong result<lb>of this kind. We consider a neural net with one hidden layer and a convolutional structure with<lb>no overlap and a ReLU activation function. For this architecture we show that learning is NP-<lb>complete in the general case, but that when the input distribution is Gaussian, gradient descent<lb>converges to the global optimum in polynomial time. To the best of our knowledge, this is the<lb>first global optimality guarantee of gradient descent on a convolutional neural network with ReLU<lb>activations.",
    "creator" : "LaTeX with hyperref package"
  }
}