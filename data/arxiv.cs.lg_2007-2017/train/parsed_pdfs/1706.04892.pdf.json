{
  "name" : "1706.04892.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Second-Order Kernel Online Convex Optimization with Adaptive Sketching",
    "authors" : [ "Daniele Calandriello", "Alessandro Lazaric", "Michal Valko" ],
    "emails" : [ "<daniele.calandriello@inria.fr>." ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 6.\n04 89\n2v 1\n[ st\nat .M\nL ]\n1 5\nJu n\n20 17\nframework combining the expressiveness of nonparametric kernel models with the regret guarantees of online learning. First-order KOCO methods such as functional gradient descent require onlyO(t) time and space per iteration, and, when the only information on the losses is their con-\nvexity, achieve a minimax optimal O( √ T ) regret. Nonetheless, many common losses in kernel problems, such as squared loss, logistic loss, and squared hinge loss posses stronger curvature that can be exploited. In this case, second-order KOCOmethods achieveO(log(Det(K))) regret, which we show scales as O(deff logT ), where deff is the effective dimension of the problem and is usually much smaller than O( √ T ). The main drawback of second-order methods is their much higher O(t2) space and time complexity. In this paper, we introduce kernel online Newton step (KONS), a new second-order KOCOmethod that also achievesO(deff logT ) regret. To address the computational complexity of second-order methods, we introduce a new matrix sketching algorithm for the kernel matrixKt, and show that for a chosen parameter γ ≤ 1 our Sketched-KONS reduces the space and time complexity by a factor of γ2 toO(t2γ2) space and time per iteration, while incurring only 1/γ times more regret."
    }, {
      "heading" : "1. Introduction",
      "text" : "Online convex optimization (OCO) (Zinkevich, 2003) models the problem of convex optimization over Rd as a game over t ∈ {1, . . . , T } time steps between an adversary and the player. In its linear version, that we refer to as linearOCO (LOCO), the adversary chooses a sequence of arbitrary convex losses ℓt and points xt, and a player chooses weightswt and predicts x T twt. The goal of the player is to\n1SequeL team, INRIA Lille - Nord Europe. Correspondence to: Daniele Calandriello <daniele.calandriello@inria.fr>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nminimize the regret, defined as the difference between the losses of the predictions obtained using the weights played by the player and the best fixed weight in hindsight given all points and losses.\nGradient descent. For this setting, Zinkevich (2003) showed that simple gradient descent (GD), combined with a smart choice for the stepsize ηt of the gradient updates, achieves a O( √ dT ) regret with a O(d) space and time cost per iteration. When the only assumption on the losses is simple convexity, this upper bound matches the corresponding lower bound (Luo et al., 2016), thus making first-order methods (e.g.,GD) essentially unimprovable in a minimax sense. Nonetheless, when the losses have additional curvature properties, Hazan et al. (2006) show that online Newton step (ONS), an adaptive method that exploits second-order (second derivative) information on the losses, can achieve a logarithmic regret O(d log T ). The downside of this adaptive method is the largerO(d2) space and per-step time complexity, since second-order updates require to construct, store, and invert Ht, a preconditioner matrix related to the Hessian of the losses used to correct the first-order updates.\nKernel gradient descent. For linear models, such as the ones considered in LOCO, a simple way to create more expressive models is to map them in some high-dimensional space, the feature space, and then use the kernel trick (Schölkopf & Smola, 2001) to avoid explicitly computing their high-dimensional representation. Mapping to a larger space allows the algorithm to better fit the losses chosen by the adversary and reduce its cumulative loss. As a drawback, the Kernel OCO (KOCO) problem1 is fundamentally harder than LOCO, due to 1) the fact that an infinite parametrization makes regret bounds scaling with the dimension d meaningless and 2) the size of the model, and therefore time and space complexities, scales with t itself, making these methods even less performant than LOCO algorithms. Kernel extensions of LOCO algorithms have been proposed for KOCO, such as functional GD (e.g., NORMA, Kivinen et al., 2004) which\nachieves a O( √ T ) regret with a O(t) space and time cost per iteration. For second-order methods, the Second-\n1This setting is often referred to as online kernel learning or kernel-based online learning in the literature.\nOrder Perceptron (Cesa-Bianchi et al., 2005) or NAROW (Orabona & Crammer, 2010) for generic curved losses and Recursive Kernel Least Squares (Zhdanov & Kalnishkan, 2010) or Kernel AAR (Gammerman et al., 2004) for the specific case of ℓ2 losses provide bounds that scale with the log-determinant of the kernel-matrix. As we show, this quantity is closely related to the effective dimension dTeff of the of the points xt, and scales as O(dTeff logT ), playing a similar role as the O(d log T ) bound from LOCO. Approximate GD. To trade off between computational complexity ( smaller than O(d2) ) and improved regret (close to O(d log T )), several methods try approximate second-order updates, replacing Ht with an approximate H̃t that can be efficiently stored and inverted. AdaGrad (Duchi et al., 2011) and ADAM (Kingma & Ba, 2015) reweight the gradient updates on a per-coordinate basis using a diagonal H̃t, but these methods ultimately only improve the regret dependency on d and leave the√ T component unchanged. Sketched-ONS, by Luo et al. (2016), uses matrix sketching to approximateHt with a rrank sketch H̃t, that can be efficiently stored and updated in O(dr2) time and space, close to the O(d) complexity of diagonal approximations. More importantly, SketchedONS achieves a much smaller regret compared to diagonal approximations: When the true Ht is of low-rank r, it recovers a O(r logT ) regret bound logarithmic in T . Unfortunately, due to the sketch approximation, a new term appears in the bound that scales with the spectra ofHt, and in some cases can grow much larger thanO(log T ). Approximate kernel GD. Existing approximate GD methods for KOCO focus only on first-order updates, trying to reduce the O(t) per-step complexity. Budgeted methods, such as Budgeted-GD (Wang et al., 2012) and budgeted variants of the perceptron (Cavallanti et al., 2007; Dekel et al., 2008; Orabona et al., 2008) explicitly limit the size of the model, using some destructive budget maintenance procedure (e.g., removal, projection) to constrain the natural model growth over time. Alternatively, functional approximation methods in the primal (Lu et al., 2016) or dual (Le et al., 2016) use non-linear embedding techniques, such as random feature expansion (Le et al., 2013), to reduce the KOCO problem to a LOCO problem and solve\nit efficiently. Unfortunately, to guarantee O( √ T ) regret using less than O(t) space and time per round w.h.p., all of these methods require additional assumptions, such as points xt coming from a distribution or strong convexity on the losses. Moreover, as approximate first-order meth-\nods, they can at most hope to match the O( √ T ) regret of exact GD, and among second-order kernel methods, no approximation scheme has been proposed that can provably maintain the same O(log T ) regret as exact GD. In addition, approximatingHt is harder for KOCO, since we cannot directly access the matrix representation of Ht in the\nfeature-space, making diagonal approximation impossible, and low-rank sketching harder.\nContributions In this paper, we introduce Kernel-ONS, an extension to KOCO of the ONS algorithm. As a secondorder method, KONS achieves a O(dteff logT ) regret on a variety of curved losses, and runs in O(t2) time and space. To alleviate the computational complexity, we propose SKETCHED-KONS, the first approximate secondorder KOCO methods, that approximates the kernel matrix with a low-rank sketch. To compute this sketch we propose a new online kernel dictionary learning, kernel online row sampling, based on ridge leverage scores. By adaptively increasing the size of its sketch, SKETCHED-KONS provides a favorable regret-performance trade-off, where for a given factor γ ≤ 1, we can increase the regret by a linear 1/γ factor to O(dteff log(T )/γ) while obtaining a quadratic γ2 improvement in runtime, thereby achieving O(t2γ2) space and time cost per iteration."
    }, {
      "heading" : "2. Background",
      "text" : "In this section, we introduce linear algebra and RKHS notation, and formally state the OCO problem in an RKHS (Schölkopf & Smola, 2001).\nNotation. We use upper-case bold letters A for matrices, lower-case bold letters a for vectors, lower-case letters a for scalars. We denote by [A]ij and [a]i the (i, j) element of a matrix and i-th element of a vector respectively. We denote by IT ∈ RT×T , the identity matrix of dimension T and byDiag(a) ∈ RT×T , the diagonal matrix with the vector a ∈ RT on the diagonal. We use eT,i ∈ RT to denote the indicator vector of dimension T for element i. When the dimension of I and ei is clear from the context, we omit the T . We also indicate with I the identity operator. We use A B to indicate that A − B is a positive semi-definite (PSD) matrix. With ‖ · ‖we indicate the operator ℓ2-norm. Finally, the set of integers between 1 and T is denoted by [T ] := {1, . . . , T }. Kernels. Given an arbitrary input space X and a positive definite kernel functionK : X×X → R, we indicate the reproducing kernel Hilbert space (RKHS) associated with K asH. We choose to represent our Hilbert spaceH as a feature space where, given K, we can find an associated feature map ϕ : X → H, such that K(x,x′) can be expressed as an inner product K(x,x′) = 〈ϕ(x), ϕ(x′)〉\nH . With a\nslight abuse of notation, we represent our feature space as an high-dimensional vector space, or in other words H ⊆ RD , where D is very large or potentially infinite. With this notation, we can write the inner product simply as K(x,x′) = ϕ(x)Tϕ(x′), and for any function fw ∈ H, we can represent it as a (potentially infinite) set of weights w such that fw(x) = ϕ(x) Tw. Given points {xi}ti=1, we\nshorten ϕ(xi) = φi and define the feature matrix Φt = [φ1, . . . ,φt] ∈ RD×t. Finally, to denote the inner product between two arbitrary subsets a and b of columns of ΦT we use Ka,b = Φ T aΦb. With this notation, we can write the empirical kernel matrix as Kt = K[t],[t] = Φ T tΦt, the vector with all the similarities between a new point and the old ones as k[t−1],t = Φ T t−1φt, and the kernel evaluated at a specific point as kt,t = φ T tφt. Throughout the rest of the paper, we assume that K is normalized and φTtφt = 1. Kernelized online convex optimization. In the general OCO framework with linear prediction, the optimization process is a gamewhere at each time step t ∈ [T ] the player 1 receives an input xt ∈ X from the adversary, 2 predicts ŷt = fwt(xt) = ϕ(xt) Twt = φ T twt,\n3 incurs loss ℓt(ŷt), with ℓt a convex and differentiable function chosen by the adversary,\n4 observes the derivative ġt = ℓ ′ t(ŷt).\nSince the player uses a linear combination φTtwt to compute ŷt, having observed ġt, we can compute the gradient,\ngt = ∇ℓt(ŷt) = ġt∇(φTtwt−1) = ġtφt.\nAfter t timesteps, we indicate with Dt = {xi}ti=1, the dataset containing the points observed so far. In the rest of the paper we consider the problem of kernelized OCO (KOCO) where H is arbitrary and potentially nonparametric. We refer to the special parametric case H = R d and φt = xt as linear OCO (LOCO).\nIn OCO, the goal is to design an algorithm that returns a solution that performs almost as well as the best-in-class, thus we must first define our comparison class. We define the feasible set as St = {w : |φTtw| ≤ C} and S = ∩Tt=1St. This comparison class contains all functions fw whose output is contained (clipped) in the interval [−C,C] on all points x1, . . . , xT . Unlike the often used constraint on ‖w‖H (Hazan et al., 2006; Zhu & Xu, 2015), comparing against clipped functions (Luo et al., 2016; Gammerman et al., 2004; Zhdanov & Kalnishkan, 2010) has a clear interpretation even when passing from R d toH. Moreover, S is invariant to linear transformations of H and suitable for practical problems where it is often easier to choose a reasonable interval for the predictions ŷt rather than a bound on the norm of a (possibly noninterpretable) parametrization w. We can now define the regret as\nRT (w) = ∑T\nt=1 ℓt(φ\nT twt)− ℓt(φTtw)\nand denote with RT = RT (w ∗), the regret w.r.t.w∗ = argminw∈S ∑T t=1 ℓt(φ T\ntw), i.e., the best fixed function in S. We work with the following assumptions on the losses.\nAlgorithm 1 One-shot KONS\nInput: Feasible parameter C, stepsizes ηt, regulariz. α 1: Initializew0 = 0,g0 = 0, b0 = 0,A0 = αI 2: for t = {1, . . . , T } do 3: receive xt 4: compute bs as in Lem. 2 5: compute ut = A −1 t−1( ∑t−1 s=0 bsgs)\n6: compute yt = ϕ(xt) Tut 7: predict ŷt = ϕ(xt) Twt = yt − h(yt) 8: observe gt, updateAt = At−1 + ηtgtg T\nt\n9: end for\nAssumption 1. The loss function ℓt satisfies |ℓ′t(y)| ≤ L whenever y ≤ C. Note that this is equivalent to assuming Lipschitzness of the the loss w.r.t. y and it is weaker than assuming something on the norm of the gradient ‖gt‖, since ‖gt‖ = |ġt|‖φt‖. Assumption 2. There exists σt ≥ 0 such that for all u,w ∈ S , lt(w) = ℓt(φTtw) is lower-bounded by\nlt(w) ≥ lt(u) +∇lt(u)T(w−u) + σt 2 (∇lt(u)T(w−u))2.\nThis condition is weaker than strong convexity and it is satisfied by all exp-concave losses (Hazan et al., 2006). For example, the squared loss lt(w) = (yt − xTtw)2 is not strongly convex but satisfies Asm. 2 with σt = 1/(8C\n2) whenw ∈ S."
    }, {
      "heading" : "3. Kernelized Online Newton Step",
      "text" : "The online Newton step algorithm, originally introduced by Hazan et al. (2006), is a projected gradient descent that uses the following update rules\nut = wt−1 −A−1t−1gt−1, wt = Π At−1\nSt (ut),\nwhere Π At−1 St (ut) = argminw∈St ‖ut − w‖At−1 is an oblique projection on a set St with matrix At−1. If St is the set of vectors with bounded prediction in [−C,C] as by Luo et al. (2016), then the projection reduces to\nwt = Π At−1 St (ut) = ut −\nh(φTtut)\nφTtA −1 t−1φt\nA−1t−1φt, (1)\nwhere h(z) = sign(z)max{|z| − C, 0} computes how much z is above or below the interval [−C,C]. When At = I/ηt, ONS is equivalent to vanilla projected gradient descent, which in LOCO achieves O( √ dT ) regret (Zinkevich, 2003). In the same setting, Hazan et al. (2006) shows that choosing At = ∑t s=1 ηsgsg T\ns + αI makes ONS an efficient reformulation of follow the approximate\nleader (FTAL). While traditional follow-the-leader algorithms play the weight wt = argminw∈St ∑t−1\ns=1 lt(w), FTAL replaces the loss lt with a convex approximation using Asm. 2, and plays the minimizer of the surrogate function. As a result, under Asm. 1-2 and when σt ≥ σ > 0, FTAL achieves a logarithmic O(d log T ) regret. FTAL’s solution path can be computed in O(d2) time using ONS updates, and further speedups were proposed by Luo et al. (2016) using matrix sketching.\nUnfortunately, in KOCO, vectors φt and weights wt cannot be explicitly represented, and most of the quantities used in vanilla ONS (Eq. 1) cannot be directly computed. Instead, we derive a closed form alternative (Alg. 1) that can be computed in practice. Using a rescaled variant of our feature vectors φt, φt = ġt √ ηtφt = √ ηtgt and Φt = [φ1, . . . ,φt], we can rewrite At = ΦtΦ T t + αI and Φ T\ntΦt = Kt, where the empirical kernel matrix Kt is computed using the rescaled kernel K(xi,xj) = ġi √ ηiġj √ ηjK(xi,xj) instead of the original K, or equivalently Kt = DtKtDt with Dt = Diag({ġi√ηi}ti=1) the rescaling diagonal matrix. We begin by noting that\nŷt = φ T twt = φ T t ( ut − h(φTtut)\nφTtA −1 t−1φt\nA−1t−1φt\n)\n= φTtut − h(φTtut) φTtA\n−1 t−1φt\nφTtA −1 t−1φt\n= yt − h(yt).\nAs a consequence, if we can find a way to compute yt, then we can obtain ŷt without explicitly computingwt. Before that, we first derive a non-recursive formulation of ut.\nLemma 1. In Alg. 1 we introduce\nbi = [bt]i = ġi √ ηi ( ŷi − h(yi)\nφ T iA −1 i−1φi\n) − 1√\nηi\nand compute ut as\nut = A −1 t−1Φt−1bt−1.\nThen, ut is equal to the same quantity in Eq. 1 and the sequence of predictions ŷt is the same in both algorithms.\nWhile the definition of bt and ut still requires performing operations in the (possibly infinitely dimensional) feature space, in the following we show that bt and the prediction yt can be conveniently computed using only inner products.\nLemma 2. All the components bi = [bt]i of the vector introduced in Lem. 1 can be computed as\nġi √ ηi ( ŷi −\nαh(yi)\nki,i − k T [i−1],i(Ki−1 + αI) −1k[i−1],i\n− 1 ηi\n) .\nThen, we can compute\nyt = 1\nα kT[t−1],tDt−1(bt−1 − (Kt−1 + αI)−1Kt−1bt−1).\nSince Alg. 1 is equivalent to ONS (Eq. 1), existing regret bounds for ONS directly applies to its kernelized version.\nProposition 1 (Luo et al., 2016). For any sequence of losses ℓt satisfying Asm. 1-2, the regret RT of Alg. 1 is bounded by RT ≤ α‖w∗‖2 +RG +RD with\nRG := T∑\nt=1\ngTtA −1 t gt =\nT∑\nt=1\nφ T t (ΦtΦ T t + αI) −1φt/ηt\nRD :=\nT∑\nt=1\n(wt −w∗)T(At −At−1−σtgtgTt )(wt −w∗)\n=\nT∑\nt=1\n(ηt − σt)ġ2t (φTt (wt −w∗))2.\nIn the d-dimensional LOCO, choosing a decreasing stepsize ηt = √ d/(C2L2t) allows ONS to achieve a\nO(CL √ dT ) regret for the cases where σt = 0. When σt ≥ σ > 0 (e.g., when the functions are exp-concave) we can set ηt = σt and improve the regret toO(d log(T )). Unfortunately, these quantities hold little meaning for KOCO\nwithD-dimensional features, since aO( √ D) regret can be very large or even infinite. On the other hand, we expect the regret of KONS to depend on quantities that are more strictly related to the kernelKt and its complexity. Definition 1. Given a kernel function K, a set of points Dt = {xi}ti=1 and a parameter α > 0, we define the αridge leverage scores (RLS) of point i as\nτt,i=e T t,iK T t (Kt+αI) –1et,i=φ T i (ΦtΦ T t +αI) –1φi, (2)\nand the effective dimension of Dt as\ndteff(α) =\nt∑\ni=1\nτt,i = Tr ( Kt(Kt + αIt) −1 ) . (3)\nIn general, leverage scores have been used to measure the correlation between a point i w.r.t. the other t − 1 points, and therefore how essential it is in characterizing the dataset (Alaoui & Mahoney, 2015). As an example, if φi is completely orthogonal to the other points, τt,i = φ T i (φiφ T i + αI) −1φi ≤ 1/(1 + α) and its RLS is maximized, while in the case where all the points xi are identical, τt,i = φ T i (tφiφ T i +αI) −1φi ≤ 1/(t+α) and its RLS is minimal. While the previous definition is provided for a generic kernel functionK, we can easily instantiate it on K and obtain the definition of τ t,i. By recalling the first regret term in the decomposition of Prop. 1, we notice that\nRG =\nT∑\nt=1\nφ T t (ΦtΦ T t + αI) −1φt/ηt =\nT∑\nt=1\nτ t,t/ηt,\nwhich reveals a deep connection between the regret of KONS and the cumulative sum of the RLS. In other words, the RLS capture how much the adversary can increase the regret by picking orthogonal directions that have not been seen before. While in LOCO, this can happen at most d times (hence the dependency on d in the final regret, which is mitigated by a suitable choice of ηt), in KOCO, RG can grow linearly with time, since large H can have infinite near-orthogonal directions. Nonetheless, the actual growth rate is now directly related to the complexity of the sequence of points chosen by the adversary and the kernel function K. While the effective dimension dteff(α) is related to the capacity of the RKHS H on the points in Dt and it has been shown to characterize the generalization error in batch linear regression (Rudi et al., 2015), we see that RG is rather related to the online effective dimension d t onl(α) = ∑\ni τ i,i. Nonetheless, we show that the two quantities are also strictly related to each other. Lemma 3. For any datasetDT , any α > 0 we have\nd T onl(α) := T∑\nt=1\nτ t,t ≤ log(Det(KT /α+ I))\n≤ dTeff(α)(1 + log(‖KT ‖/α+ 1)).\nWe first notice that in the first inequality we relate d T\nonl(α) to the log-determinant of the kernel matrixKT . This quantity appears in a large number of works on online linear prediction (Cesa-Bianchi et al., 2005; Srinivas et al., 2010) where they were connected to the maximal mutual information gain in Gaussian processes. Finally, the second inequality shows that in general the complexity of online learning is only a factor logT (in the worst case) away from the complexity of batch learning. At this point, we can generalize the regret bounds of LOCO to KOCO.\nTheorem 1. For any sequence of losses ℓt satisfying Asm. 1-2, let σ = mint σt. If ηt ≥ σ ≥ 0 for all t and α ≤ √ T , the regret of Alg. 1 is upper-bounded as\nRT ≤ α‖w∗‖2 + dTonl(α)/ηT + 4C2L2 T∑\nt=1\n(ηt − σ).\nIn particular, if for all t we have σt ≥ σ > 0, setting ηt = σ we obtain\nRT ≤ α‖w∗‖2 + 2dTeff ( α/(σL2) ) log(2σL2T ) σ ,\notherwise, σ = 0 and setting ηt = 1/(LC √ t) we obtain\nRT ≤ α‖w∗‖2 + 4LC √ TdTeff(α/L 2) log(2L2T ).\nComparison to LOCO algorithms. We first notice that the effective dimension dTeff(α) can be seen as a soft rank\nAlgorithm 2 Kernel Online Row Sampling (KORS)\nInput: Regularization α, accuracy ε, budget β 1: Initialize I0 = ∅ 2: for t = {0, . . . , T − 1} do 3: receive φt 4: construct temporary dictionary It := It−1 ∪ (t, 1) 5: compute p̃t = min{βτ̃t,t, 1} using It and Eq. 4 6: draw zt ∼ B(p̃t) and if zt = 1, add (t, 1/p̃t) to It 7: end for\nforKT and that it is smaller than the rank r for any α. 2 For exp-concave functions (i.e., σ > 0), we slightly improve over the bound of Luo et al. (2016) from O(d logT ) down to O(dTeff(α) log T ) ≤ O(r logT ), where r is the (unknown) rank of the dataset. Furthermore, when σ=0, setting ηt = √ 1/(L2C2t) gives us a regret O( √ TdTeff(α))≤\nO( √ Tr), which is potentially much smaller thanO( √ Td). Furthermore, if an oracle provided us in advance with dTeff(α), setting ηt = √ dTeff(α)/(L 2C2t) gives a regret O( √ dTeff(α)T ) ≤ O( √ rT ).\nComparison to KOCO algorithms. Simple functional gradient descent (e.g., NORMA, Kivinen et al., 2004)\nachieves a O( √ T ) regret when properly tuned (Zhu & Xu, 2015), regardless of the loss function. For the special case of squared loss, Zhdanov & Kalnishkan (2010) show that Kernel Ridge Regression achieves the same O(log(Det(KT /α+ I))) regret as achieved by KONS for general exp-concave losses."
    }, {
      "heading" : "4. Kernel Online Row Sampling",
      "text" : "Although KONS achieves a low regret, storing and inverting the K matrix requires O(t2) space and O(t3) time, which becomes quickly unfeasible as t grows. To improve space and time efficiency, we replace Kt with an accurate low-rank approximation K̃t, constructed using a carefully chosen dictionary It of points from Dt. We extend the online row sampling (ORS) algorithm of Cohen et al. (2016) to the kernel setting and obtain Kernel-ORS (Alg. 2). There are two main obstacles to overcome in the adaptation of ORS: From an algorithmic perspective we need to find a computable estimator for the RLS, since φt cannot be accessed directly, while from an analysis perspective we must prove that our space and time complexity does not scale with the dimension of φt (as Cohen et al. 2016), as it can potentially be infinite.\nWe define a dictionary It as a collection of (index, weight) tuples (i, 1/p̃i) and the associated selection matrix St ∈\n2This can be easily seen as dTeff(α) = ∑ t λt/(λt +α), where\nλt are the eigenvalues of KT .\nR t×t as a diagonal matrix with 1/ √ p̃i for all i ∈ It and 0 elsewhere. We also introduceAItt = ΦtStS T tΦ T\nt+αI as an approximation of At constructed using the dictionary It. At each time step, KORS temporarily adds t with weight 1 to the dictionary It−1 and constructs the temporary dictionary It,∗ and the corresponding selection matrix St,∗ and approximation A It,∗\nt . This augmented dictionary can be\neffectively used to compute the RLS estimator,\nτ̃t,i = (1 + ε)φt ( A It,∗ t )−1 φt (4) = 1+εα ( kt,t − k T [t],tSt,∗(S T t,∗KtSt,∗ + αI) −1STt,∗k[t],t ) .\nWhile we introduced a similar estimator before (Calandriello et al., 2017), here we modified it so that τ̃t,i is an overestimate of the actual τ t,i. Note that all rows and columns for which St,∗ is zero (all points outside the temporary dictionary It,∗) do not influence the estimator, so they can be excluded from the computation. As a consequence, denoting by |It,∗| the size of the dictionary, τ̃t,i can be efficiently computed in O(|It,∗|2) space and O(|It,∗|2) time (using an incremental update of Eq. 4). After computing the RLS, KORS randomly chooses whether to include a point in the dictionary using a coin-flip with probability p̃t = min{βτ̃t,t, 1} and weight 1/p̃t, where β is a parameter. The following theorem gives us at each step guarantees on the accuracy of the approximate matrices AItt and of estimates τ̃t,t, as well as on the size |It| of the dictionary. Theorem 2. Given parameters 0 < ε ≤ 1, 0 < α, 0 < δ < 1, let ρ = 1+ε1−ε and run Algorithm 2 with β ≥ 3 log(T/δ)/ε2. Then w.p. 1− δ, for all steps t ∈ [T ],\n(1) (1− ε)At AItt (1 + ε)At. (2) The dictionary’s size |It| = ∑t s=1 zs is bounded by\nt∑\ns=1\nzs ≤ 3 t∑\ns=1\np̃s ≤ dtonl(α) 3ρβ\nε2 ≤ dteff(α)\n6ρ log2 ( 2T δ )\nε2 .\n(3) Satisfies τt,t ≤ τ̃t,t ≤ ρτt,t.\nMoreover, the algorithm runs in O(dteff(α)2 log4(T )) space, and Õ(dteff(α)2) time per iteration.\nThe most interesting aspect of this result is that the dictionary It generated by KORS allows to accurately approximate the At = ΦtΦ T\nt + αI matrix up to a small (1 ± ε) multiplicative factor with a small time and space complexity, which makes it a natural candidate to sketch KONS."
    }, {
      "heading" : "5. Sketched ONS",
      "text" : "Building on KORS, we now introduce a sketched variant of KONS that can efficiently trade off between computational\nAlgorithm 3 SKETCHED-KONS\nInput: Feasible parameter C, stepsizes ηt, regulariz. α 1: Initializew0 = 0,g0 = 0, b0 = 0, Ã0 = αI 2: Initialize independent run of KORS\n3: for t = {1, . . . , T } do 4: receive xt 5: compute ũt = Ã −1 t−1( ∑t−1 s=0 b̃sgs) 6: compute y̆t = ϕ(xt) Tũt 7: predict ỹt = ϕ(xt) Tw̃t = y̆t − h(y̆t), observe gt\n8: compute τ̃t,t using KORS (Eq. 4) 9: compute p̃t = max{min{βτ̃t,t, 1}, γ} 10: draw zt ∼ B(p̃t) 11: update Ãt = Ãt−1 + ηtztgtg T\nt\n12: end for\nperformance and regret. Alg. 3 runs KORS as a black-box estimating RLS τ̃t, that are then used to sketch the original matrix At with a matrix Ãt = ∑t s=1 ηtztgtg T t , where at each step we add the current gradient gtg T t only if the coin flip zt succeeded. Unlike KORS, the elements added to Ãt are not weighted, and the probabilities p̃t used for the coins zt are chosen as the maximum between τ̃t,t, and a parameter 0 ≤ γ ≤ 1. Let Rt be the unweighted counterpart of St, that is [Rt]i,j = 0 if [St]i,j = 0 and [Rt]i,j = 1 if [St]i,j 6= 0. Then we can efficiently compute the coefficients b̃t and predictions ỹt as follows.\nLemma 4. LetEt = R T tKtRt+αI be an auxiliary matrix, then all the components b̃i = [b̃t]i used in Alg. 3 can be computed as\nġi √ ηi ( ỹi −\nαh(y̆i)\nki,i − k T [i−1],iRi−1E −1 i−1Ri−1k[i−1],i\n− 1 ηi\n) .\nThen we can compute\ny̆t = 1\nα\n( kT[t−1],tDt−1bt−1\n− kT[t−1],tDt−1Rt−1E−1t−1Rt−1Kt−1bt−1 ) .\nNote that since the columns in Rt are selected without weights, (RTtKtRt + αI) −1 can be updated efficiently using block inverse updates, and only when Ãt changes. While the specific reason for choosing the unweighted sketch Ãt instead of the weighted version A It t used in KORS is discussed further in Sect. 6, the following corollary shows that Ãt is as accurate as A It t in approximating At up to the smallest sampling probability p̃ γ t . Corollary 1. Let p̃γmin = min T t=1 p̃ γ t . Then w.h.p., we have\n(1− ε)p̃minAt p̃minAItt Ãt.\nWe can now state the main result of this section. Since for SKETCHED-KONS we are interested not only in regret\nminimization, but also in space and time complexity, we do not consider the case σ = 0, because when the function does not have any curvature, standard GD already achieves\nthe optimal regret of O( √ T ) (Zhu & Xu, 2015) while requiring onlyO(t) space and time per iteration. Theorem 3. For any sequence of losses ℓt satisfying Asm. 1-2, let σ = mint σt and τmin = min T t=1 τ t,t. When\nηt ≥ σ > 0 for all t, α ≤ √ T , β ≥ 3 log(T/δ)/ε2, if we set ηt = σ then w.p. 1− δ the regret of Alg. 3 satisfies\nR̃T ≤ α‖w∗‖2 + 2 dTeff\n( α/(σL2) ) log(2σL2T )\nσmax{γ, βτmin} , (5)\nand the algorithm runs in O(dteff(α)2 + t2γ2) time and O(dteff(α)2 + t2γ2) space complexity for each iteration t.\nProof sketch: Given these guarantees, we need to bound RG and RD . Bounding RD is straightforward, since by construction SKETCHED-KONS adds at most ηtgtg T\nt\nto Ãt at each step. To bound RG instead, we must take into account that an unweighted Ãt = ΦtRtR T tΦ T t + αI can be up to p̃min distant from the weighted ΦtStS T tΦ T t for which we have guarantees. Hence the max{γ, βτmin} term appearing at the denominator."
    }, {
      "heading" : "6. Discussion",
      "text" : "Regret guarantees. From Eq. 5 we can see that when τmin is not too small, setting γ = 0 we recover the guarantees of exact KONS. Since usually we do not know τmin, we can choose to set γ > 0, and as long as γ ≥ 1/ polylogT , we preserve a (poly)-logarithmic regret.\nComputational speedup. The time required to compute k[t−1],t, kt,t, and k T\n[t−1],tDt−1bt−1 gives a minimumO(t) per-step complexity. Note thatKt−1bt−1 can also be computed incrementally in O(t) time. Denoting the size of the dictionary at time t as Bt = Õ(deff(α)t + tγ), computing [b̃t]i and k T [t−1],tDt−1Rt−1E −1 t−1Rt−1Kt−1bt−1 requires an additionalO(B2t ) time. When γ ≤ dteff(α)/t, each iteration takes O(dteff(α)2) to compute τ̃t,t incrementally using KORS, O(dteff(α)2) time to update Ã−1t and O(dteff(α)2) time to compute [bt]t. When γ > d t eff(α)/t, each iteration still takes O(dteff(α)2) to compute τ̃t,t using KORS and O(t2γ2) time to update the inverse and compute [bt]t. Therefore, in the case when τmin is not too small, our runtime is of the order O(dteff(α)2 + t), which is almost as small as the O(t) runtime of GD but with the advantage of a second-order method logarithmic regret. Moreover, when τmin is small and we set a large γ, we can trade off a 1/γ increase in regret for a γ2 decrease in space and time complexity when compared to exact KONS (e.g., setting γ = 1/10 would correspond to a tenfold increase in regret, but a hundred-fold reduction in computational complexity).\nAsymptotic behavior. Notice however, that space and time complexity, grow roughly with a term Ω(tmints=1 p̃s) ∼ Ω(tmax{γ, βτmin}), so if this quantity does not decrease over time, the computational cost of SKETCHED-KONS will remain large and close to exact KONS. This is to be expected, since SKETCHED-KONS must always keep an accurate sketch in order to guarantee a logarithmic regret bound. Note that Luo et al. (2016) took an opposite approach for LOCO, where they keep a fixed-size sketch but possibly pay in regret, if this fixed size happens to be too small. Since a non-logarithmic regret is achievable simply running vanilla GD, we rather opted for an adaptive sketch at the cost of space and time complexity. In batch optimization, where ℓt does not change over time, another possibility is to stop updating the solution once τmin becomes too small. When Hs is the Hessian of ℓ in ws, then the quantity gTtH −1 t gt, in the context of Newton’s method, is called Newton decrement and it corresponds up to constant factors to τmin. Since a stopping condition based on Newton’s decrement is directly related to the near-optimality of the current wt (Nesterov & Nemirovskii, 1994), stopping when τmin is small also provides guarantees about the quality of the solution.\nSampling distribution. Note that although γ > 0 means that all columns have a small uniform chance of being selected for inclusion in Ãt, this is not equivalent to uniformly sampling columns. It is rather a combination of a RLS-based sampling to ensure that columns important to reconstruct At are selected and a threshold on the probabilities to avoid too much variance in the estimator.\nBiased estimator and results in expectation. The random approximation Ãt is biased, since E[ΦtRtR T tΦ T t ] = Φt Diag({τ t,t})Φ T t 6= ΦtΦ T t . Another option would be to use a weighted and unbiased Ã′t = ∑t s=1 ηszs/p̃sgsg T s approximation, used in KORS and a common choice in matrix approximation methods, see e.g., Alaoui & Mahoney, 2015. Due to its unbiasedness, this variant would automatically achieve the same logarithmic regret as exact KONS in expectation (similar to the result obtained by Luo et al., 2016, using Gaussian random projection in LOCO). While any unbiased estimator, e.g., uniform sampling of gt, would achieve this result, RLS-based sampling already provides strong reconstruction guarantees sufficient to bound RG. Nonetheless, the weights 1/p̃s may cause large variations in Ãt over consecutive steps, thus leading to a large regret RD in high probability.\nLimitations of dictionary learning approaches and open problems. From the discussion above, it appears that a weighted, unbiased dictionary may not achieve highprobability logarithmic guarantee because of the high variance coming from sampling. On the other hand, if we want to recover the regret guarantee, we may have to pay for it\nwith a large dictionary. This may actually be due to the analysis, the algorithm, or the setting. An important property of the dictionary learning approach used in KORS is that it can only add but not remove columns and potentially re-weight them. Notice that in the batch setting (Alaoui & Mahoney, 2015; Calandriello et al., 2017), the sampling of columns does not cause any issue and we can have strong learning guarantees in high probability with a small dictionary. Alternative sketching methods such as Frequent Directions (FD, Ghashami et al., 2016a) do create new atoms as learning progresses. By restricting to composing dictionaries from existing columns, we only have the degree of freedom of the weights of the columns. If we set the weights to have an unbiased estimate, we achieve an accurate RG but suffer a huge regret in RD. On the other hand, we can store the columns unweighted to have small RD but large RG. This could be potentially fixed if we knew how to remove less important columns from dictionary to gain some slack in RD.\nWe illustrate this problem with following simple scenario. The adversary always presents to the learner the same point x (with associated φ), but for the loss it alternates between ℓ2t(wt) = (C − φTwt)2 on even steps and ℓ2t+1(wt) = (−C − φTwt)2 on odd steps. Then, σt = σ = 1/(8C2), and we have a gradient that always points in the same φ direction, but switches sign at each step. The optimal solution in hindsight is asymptoticallyw = 0 and let this be also our starting point w0. We also set ηt = σ, since this is what ONS would do, and α = 1 for simplicity.\nFor this scenario, we can compute several useful quantities in closed form, in particular, RG and RD,\nRG ≤\nT∑\nt=1\nġ2t∑ t\ns=1 ġ2sσ + α\n≤\nT∑\nt=1\nC2\nC2σt+ α ≤ O(log T ),\nRD = ∑t\ns=1 (ηt − σ)(w\nT tgt) 2 = 0.\nNote that although the matrixAt is rank 1 at each time step, vanilla ONS does not take advantage of this easy data, and would store it all with a O(t2) space in KOCO. As for the sketched versions of ONS, sketching using FD (Luo et al., 2016) would adapt to this situation, and only store a single copy of gt = g, achieving the desired regret with a much smaller space. Notice that in this example, the losses ℓt are effectively strongly convex, and even basic gradient descent with a stepsize ηt = 1/t would achieve logarithmic regret (Zhu & Xu, 2015) with even smaller space. On the other hand, we show how the dictionary-based sketching has difficulties in minimizing the regret bound from Prop. 1 in our simple scenario. In particular, consider an arbitrary (possibly randomized) algorithm that is allowed only to reweight atoms in the dictionary and not to create new ones (as FD). In our example, this translates to choosing a schedule of weights ws\nand set Ãt = ∑t s=1 wsφsφs = Wtφφ with total weight\nW = WT = ∑T\ns=1 ws and space complexity equal to the number of non-zero weights B = |{ws 6= 0}|. We can show that there is no schedule for this specific class of algorithms with good performance due to the following three conflicting goals.\n(1) To mantain RG small, ∑t\ns=1 ws should be as large as possible, as early as possible.\n(2) To mantain RD small, we should choose weights wt > 1 as few times as possible, since we accumulate max{wt − 1, 0} regret every time.\n(3) To mantain the space complexity small, we should\nchoose only a few wt 6= 0. To enforce goal (3), we must choose a schedule with no more than B non-zero entries. Given the budget B, to satisfy goal (2) we should use all the B budget in order to exploit as much as possible the max{wt − 1, 0} in RD, or in other words we should use exactly B non-zero weights, and none of these should be smaller than 1. Finally, to minimize RG we should raise the sum ∑t\ns=1 ws as quickly as possible, settling on a schedule where w1 = W − B and ws = 1 for all the otherB weights. It easy to see that if we want logarithmic RG, W needs to grow as T , but doing so with a logarithmic B would make RD = T − B = Ω(T ). Similarly, keeping W = B in order to reduce RD would increase RG. In particular notice, that the issue does not go away even if we know the RLS perfectly, because the same reasoning applies. This simple example suggests that dictionary-based sketching methods, which are very successful in batch scenarios, may actually fail in achieving logarithmic regret in online optimization.\nThis argument raises the question on how to design alternative sketching methods for the second-order KOCO. A first approach, discussed above, is to reduce the dictionary size dropping columns that become less important later in the process, without allowing the adversary to take advantage of this forgetting factor. Another possibility is to deviate from the ONS approach and RD + RG regret decomposition. Finally, as our counterexample in the simple scenario hints, creating new atoms (either through projection or merging) allows for better adaptivity, as shown by FD (Ghashami et al., 2016a) based methods in LOCO. However, the kernelization of FD does not appear to be straighforward. The most recent step in this direction (in particular, for kernel PCA) is only able to deal with finite feature expansions (Ghashami et al., 2016b) and therefore its application to kernels is limited.\nAcknowledgements The research presented was supported by\nFrench Ministry of Higher Education and Research, Nord-\nPas-de-Calais Regional Council and French National Research Agency projects ExTra-Learn (n.ANR-14-CE24-0010-01) and\nBoB (n.ANR-16-CE23-0003)"
    }, {
      "heading" : "A. Preliminary results",
      "text" : "We begin with a generic linear algebra identity that is be used throughout our paper. Proposition 2. For anyX ∈ Rn×m matrix and α > 0,\nXXT(XXT + αI)−1 = X(XTX+ αI)−1XT\nand\n(XXT + αI)−1 = 1\nα αI(XXT + αI)−1\n= 1\nα (XXT −XXT + αI)(XXT + αI)−1\n= 1\nα (I−XXT(XXT + αI)−1)\n= 1\nα (I−X(XTX+ αI)−1XT).\nProposition 3. For any matrix or linear operatorX, if a selection matrix S satisfies\n‖(XXT + αI)−1/2(XXT −XSSTXT)(XXT + αI)−1/2‖ ≤ ε,\nwe have\n(1− ε)XtXTt − εαI XtStSTtXTt (1 + ε)XtXTt + εαI.\nProposition 4. LetKt = UΛU T andΦt = VΣU T, then\n‖(ΦtΦTt + αI)−1/2Φt(I− SsSTs)ΦTt (ΦtΦTt + αI)−1/2‖ = ‖(ΣΣT + αI)−1/2ΣUT(I− SsSTs)UΣT(ΣΣT + αI)−1/2‖ = ‖(Λ+ αI)−1/2Λ1/2UT(I− SsSTs)U(Λ1/2)T(Λ+ αI)−1/2‖ = ‖(Kt + αI)−1/2K1/2t (I− SsSTs)K1/2t (Kt + αI)−1/2‖.\nWe also use the following concentration inequality for martingales. Proposition 5 (Tropp, 2011, Thm. 1.2). Consider a matrix martingale {Yk : k = 0, 1, 2, . . .} whose values are selfadjoint matrices with dimension d and let {Xk : k = 1, 2, 3, . . .} be the difference sequence. Assume that the difference sequence is uniformly bounded in the sense that\n‖Xk‖2 ≤ R almost surely for k = 1, 2, 3, . . . .\nDefine the predictable quadratic variation process of the martingale as\nWk :=\nk∑\nj=1\nE [ X2j ∣∣∣ {Xs}j−1s=0 ] , for k = 1, 2, 3, . . . .\nThen, for all ε ≥ 0 and σ2 > 0,\nP ( ∃k ≥ 0 : ‖Yk‖2 ≥ ε ∩ ‖Wk‖ ≤ σ2 ) ≤ 2d · exp { − ε 2/2\nσ2 +Rε/3\n} .\nProposition 6 (Calandriello et al., 2017, App.D.4). Let {zs}ts=1 be independent Bernoulli random variables, each with success probability ps, and denote their sum as d = ∑t s=1 ps ≥ 1. Then,3\nP\n( t∑\ns=1\nzs ≥ 3d ) ≤ exp{−3d(3d− (log(3d) + 1))} ≤ exp{−2d}\n3This is a simple variant of Chernoff bound where the Bernoulli random variables are not identically distributed."
    }, {
      "heading" : "B. Proofs for Section 3",
      "text" : "Proof of Lem. 1. We begin by applying the definition of ut+1 and collecting A −1 t , which can always be done since, for α > 0,At is invertible,\nut+1 = wt −A−1t gt = A−1t (Atwt − gt). We focus now on the last term and use the definition ofAt,\nAtwt − gt = At−1wt + ηtgtgTtwt − gt = At−1ut −At−1rt + ( √ ηtg T twt − 1/ √ ηt)φt.\nLooking at At−1rt and using the assumption ġt 6= 0,\nAt−1rt = h(φTtut)\nφTtA −1 t−1φt\nAt−1A −1 t−1φt\n= h(φTtut)\nφTtA −1 t−1φt ġ2t ηt ġ2t ηt φt\n= ġt √ ηth(φ T tut)\nφ T tA −1 t−1φt\nφt.\nPutting together all three terms, and using the fact that gTtwt = ġtφtwt = ġtŷt and denoting bt = [bt]t we have\nut+1 = A −1 t (Atwt − gt)\n= A−1t (At−1ut + btφt) = A−1t (At−1(wt−1 −A−1t−1gt−1) + btφt) = A−1t (At−1wt−1 − gt−1 + btφt) = A−1t (At−2wt−2 − gt−2 + bt−1φt−1 + btφt) = A−1t (A0w0 + ∑t\ns=1 bsφs).\nProof of Lem. 2. Throughout this proof, we make use of the linear algebra identity from Prop. 2. We begin with the reformulation of [bt]t. In particular, the only term that we need to reformulate is\nφtA −1 t−1φt = φt(Φt−1Φ\nT t−1 + αI) −1φt\n= 1\nα φt(I−Φt−1(Φ\nT t−1Φt−1 + αI) −1Φ T t−1)φt\n= 1\nα (φ\nT tφt − φ T tΦt−1(Φ T t−1Φt−1 + αI) −1Φ T t−1φt)\n= 1\nα (kt,t − k\nT [t−1],t(Kt−1 + αI) −1k[t−1],t).\nFor yt, we have\nyt = φ T tut = φ T tA −1 t−1Φt−1bt−1\n= φTt (Φt−1Φ T t−1 + αI) −1Φt−1bt−1 = 1\nα φTt (I−Φt−1(Φ\nT t−1Φt−1 + αI) −1Φ T t−1)Φt−1bt−1\n= 1\nα φTtΦt−1Dt−1(bt−1 − (Kt−1 + αI)−1Kt−1bt−1)\n= 1\nα kT[t−1],tDt−1(bt−1 − (Kt−1 + αI)−1Kt−1bt−1).\nProof of Lem. 3. We prove the lemma for a generic kernel K and kernel matrix KT . Then, Lem. 3 simply follows by applying the proof to K andKT . From the definition of τt,t we have\nT∑\nt=1\nτt,t = T∑\nt=1\nφTt (ΦtΦ T t + αI) −1φt =\nT∑\nt=1\n(φTt / √ α) (ΦtΦ T t /α+ I) −1 (φt/ √ α) ≤ log(Det(ΦTΦTT /α+ I)),\nwhere the last passage is proved by Hazan et al. (2006). Using Sylvester’s determinant identity,\nDet(ΦTΦ T T /α+ I) = Det(Φ T TΦT /α+ I) =\nT∏\nt=1\n(λt/α+ 1),\nwhere λt are the eigenvalues ofΦ T TΦT = KT . Then,\nT∑\nt=1\nτt,t ≤ log (∏T\nt=1 (λt/α+ 1)\n) =\n∑T t=1 log(λt/α+ 1).\nWe can decompose this as\nT∑\nt=1\nlog(λt/α+ 1) =\nT∑\nt=1\nlog(λt/α+ 1)\n( λt/α+ 1\nλt/α+ 1\n)\n=\nT∑\nt=1\nlog(λt/α+ 1) λt/α\nλt/α+ 1 +\nT∑\nt=1\nlog(λt/α+ 1)\nλt/α+ 1\n≤ log(‖KT ‖/α+ 1) T∑\nt=1\nλt λt + α +\nT∑\nt=1\nlog(λt/α+ 1)\nλt/α+ 1\n≤ log(‖KT ‖/α+ 1)dTeff(α) + T∑\nt=1\n(λt/α+ 1)− 1 λt/α+ 1\n= log(‖KT ‖/α+ 1)dTeff(α) + dTeff(α),\nwhere the first inequality is due to ‖KT‖ ≥ λt for all t and the monotonicity of log(·), and the second inequality is due to log(x) ≤ x− 1.\nProof of Thm 1. We need to bound RT (w ∗), and we use Prop. 1. For RD nothing changes from the parametric case, and we use Asm. 1 and the definition of the set S to bound\nRD = ∑T\nt=1 (ηt − σt)ġ2t (φTt (wt −w))2 ≤ ∑T t=1 (ηt − σ)L2(|φTtwt|+ |φTtw|)2 ≤ 4L2C2 ∑T t=1 (ηt − σ).\nFor RG, we reformulate\n∑T t=1 gTtA −1 t gt = ∑T t=1 ηt ηt gTtA −1 t gt = ∑T t=1 1 ηt φ T tA −1 t φt\n≤ 1 ηT ∑T t=1 φ T tA −1 t φt = 1 ηT ∑T t=1 τ t,t = donl(α)/ηT ≤ d T eff(α) ηT (1 + log(‖KT ‖/α+ 1)),\nwhere d T\neff(α) andKT are computed using the rescaled kernel K. Let us remind ourselves the definitionD = Diag ( {ġt√ηt}Tt=1 ) . Since ηt 6= 0 and ġt 6= 0 for all t, D is invertible and we have λmin(D −2) = minTt=1 1/(ġ 2 t ηt) ≥ 1/(L2η1). For simplicity, we assume η1 = σ, leaving the case η1 = 1/1 = 1 as a\nspecial case. We derive\nd T\neff(α) = Tr(KT (KT + αI) −1)\n= Tr(DKTD(DKTD+ αDD −2D)−1) = Tr(DKTDD −1(KT + αD −2)−1D−1) = Tr(KT I(KT + αD −2)−1D−1D) = Tr(KT (KT + αD −2)−1) ≤ Tr(KT (KT + αλmin(D−2)I)−1) ≤ Tr ( KT ( KT + α σL2 I )−1) = dTeff ( α/(σL2) ) .\nSimilarly,\nlog(‖KT ‖/α+ 1) ≤ log(Tr(KT )/α+ 1) ≤ log(σL2 Tr(Kt)/α+ 1) ≤ log(σL2T/α+ 1) ≤ log(2σL2T/α),\nsince Tr(Kt) = ∑T t=1 kt,t = ∑T t=1 φ T tφt ≤ ∑T t=1 1 = T ."
    }, {
      "heading" : "C. Proofs for Section 4",
      "text" : "Proof of Thm. 2. We derive the proof for a generic K with its induced φt = ϕ(xt) and Kt. Then, SKETCHED-KONS (Alg. 3) applies this proof to the rescaled φt andKt. Our goal is to prove that Alg. 2 generates accurate and small dictionaries at all time steps t ∈ [T ]. More formally, a dictionary Is is ε-accurate w.r.t.Dt when\n‖(ΦtΦTt + αI)−1/2Φt(I− SsSTs)ΦTt (ΦtΦTt + αI)−1/2‖ = ‖(Kt + αI)−1/2K1/2t (I− SsSTs)K1/2t (Kt + αI)−1/2‖ ≤ ε,\nwhere we used Prop. 4 to move from feature to primal space.\nWe also introduce the projection operators,\nvt,i :=((Kt + αI) −1Kt) 1/2et,i\nPt :=(Kt + αI) −1/2K 1/2 t K 1/2 t (Kt + αI)\n−1/2 = t∑\ns=1\nvt,sv T t,s = VtV T t\nP̃t :=(Kt + αI) −1/2K 1/2 t StS T tK 1/2 t (Kt + αI) −1/2 =\nt∑\ns=1\nzt p̃t vt,sv T t,s = VtStS T tV T t ,\nwhere the zt variables are the {0, 1} random variables sampled by Alg. 2. Note that with this notation we have\n‖vt,ivTt,i‖ = ‖((Kt + αI)−1Kt)1/2et,ieTt,i(Kt(Kt + αI)−1)1/2‖ = eTt,i((Kt + αI) −1Kt) 1/2(Kt(Kt + αI) −1)1/2et,i = e T t,i(Kt + αI) −1Ktet,i = τt,i.\nWe can now formalize the event “some of the guarantees of Alg. 2 do not hold” and bound the probability of this event. In particular, let\nYt := P̃t −Pt = t∑\ns=1\n( zt p̃t − 1 ) vt,sv T t,s.\nWe want to show\nP ( ∃t ∈ [T ] : ‖Yt‖ ≥ ε︸ ︷︷ ︸\nAt\n∪ ∑t\ns=1 zt ≥ 3βdtonl(α) ︸ ︷︷ ︸ Bt\n) ≤ δ,\nwhere event At refers to the case when the intermediate dictionary It fails to accurately approximate Kt at some step t ∈ [T ] and event Bt considers the case when the memory requirement is not met (i.e., too many columns are kept in a dictionary It at a certain time t ∈ [T ]). Step 1: Splitting the problem. We can conveniently decompose the previous joint (negative) event into two separate conditions as\nP\n( T⋃\nt=1\n( At ∪Bt )) = P\n({ T⋃\nt=1\nAt\n}) + P ({ T⋃\nt=1\nBt\n}) − P ({ T⋃\nt=1\nAt\n} ∩ { T⋃\nt=1\nBt\n})\n= P\n({ T⋃\nt=1\nAt\n}) + P   { T⋃\nt=1\nBt\n} ∩ { T⋃\nt=1\nAt\n}∁  = P ({ T⋃\nt=1\nAt\n}) + P ({ T⋃\nt=1\nBt\n} ∩ { T⋂\nt=1\nA∁t\n})\n= P\n({ T⋃\nt=1\nAt\n}) + P ( T⋃\nt=1\n{ Bt ∩ { T⋂\nt′=1\nA∁t′\n}}) .\nApplying this reformulation and a union bound, we obtain\nP ( ∃t ∈ [T ] : ‖Yt‖ ≥ ε ∪ ∑t s=1 zt ≥ 3βdtonl(α) )\n≤ T∑\nt=1\nP (‖Yt‖ ≥ ε) + T∑\nt=1\nP\n( t∑\ns=1\nzs ≥ 3βdtonl(α) ∩ {∀ t′ ∈ {1, . . . , t} : ‖Yt‖ ≤ ε} ) .\nTo conclude the proof, we show in Step 2 and 3, that each of the failure events happens with probability less than δ2T . Step 2: Bounding the accuracy. We first point out that dealing with Yt is not trivial since the process {Yt}Tt=1 is composed by matrices of different size, that cannot be directly compared. Denote with Sts the matrix constructed by (1) taking Ss and adding t− s rows of zeros to its bottom to extend it, and (2) adding t− s indicator columns et,i for all i > s. We begin by reformulatingYt as a random processY t 0,Y t 1, . . . ,Y t t with differencesX t s defined as\nXts = ( zs p̃s − 1 ) vt,sv T t,s, Y t k = k∑\ns=1\nXts =\nk∑\ns=1\n( zs p̃s − 1 ) vt,sv T t,s = Vt(S t k(S t k) T − I)VTt .\nWe introduce the freezing probabilities\nps = p̃s · I{‖Yts−1‖ < ε}+ 1 · I{‖Yts−1‖ ≥ ε}\nand the associated process Y t\ns based on the coin flips zs performed using ps instead of the original p̃s as in Alg. 2. In other words, this process is such that if at any time s− 1 the accuracy condition is not met, then for all steps from s on the algorithm stops updating the dictionary. We also defineYt = Y t t. Then we have\nP (‖Yt‖ ≥ ε) ≤ P ( ‖Yt‖ ≥ ε ) ,\nso we can simply bound the latter to bound the former. To show the usefulness of the freezing process, consider the step s where the process froze, or more formally define s as the step where ‖Yts‖ < ε and ‖Yts+1‖ ≥ ε. Then for all s ≤ s, we can combine Prop. 3, the definition ofVt, and the guarantee that ‖Yts‖ < ε to obtain\nΦsSsS T sΦs ΦtSts(Sts)TΦt ΦtΦTt + ε(ΦtΦTt + γI),\nwhere in the first inequality we used the fact that Sts is simply obtained by bordering Ss. Applying the definition of p̃s, when p̃s < 1 we have\nps = p̃s = βτ̃s,s = β(1 + ε)φ T s(ΦsSsS T sΦ T s + γI) −1φs\n≥ β(1 + ε)φTs(ΦsΦTs + ε(ΦtΦTt + γI) + γI)−1φs = β(1 + ε) 1\n1 + ε φTs(ΦtΦ T t + γI) −1φs,= βτt,s,\nwhich shows that our estimates of RLS are upper bounds on the true values.\nFrom this point onwards we focus on a specific t, and omit the index fromY t s,X t s and vt,s. We can now verify thatYs is a martingale, by showing that Xs is zero mean. Denote with Fk = {Xs}ks=1 the filtration of the process. When ps = 1, either because βp̃s ≥ 1 or because the process is frozen, we have Xs = 0 and the condition is satisfied. Otherwise, we have\nE [ Xs ∣∣ Fs−1 ] = E [( zs ps − 1 ) vsv T s ∣∣∣∣ Fs−1 ] = ( E [zs | Fs−1] ps − 1 ) vsv T s = ( ps ps − 1 ) vsv T s = 0,\nwhere we use the fact that ps is fixed conditioned on Fs−1 and its the (conditional) expectation of zs. Since Yt is a martingale, we can use Prop. 5. First, we find R. Again, when ps = 1 we haveXs = 0 and R ≥ 0. Otherwise,\n∥∥∥∥ ( zs ps − 1 ) vsv T s ∥∥∥∥ ≤ ∣∣∣∣ ( zs ps − 1 )∣∣∣∣ ‖vsvTs‖ ≤ 1 ps τt,s ≤ τt,s βτt,s = 1 β := R.\nFor the total variation, we expand\nWt :=\nt∑\ns=1\nE [ X 2\ns\n∣∣∣ Fs−1 ] = t∑\ns=1\nE [( zs ps − 1 )2 ∣∣∣∣∣ Fs−1 ] vsv T svsv T s\n=\nt∑\ns=1\n( E [ z2s p2s ∣∣∣∣ Fs−1 ] − E [ 2 zs ps ∣∣∣∣ Fs−1 ] + 1 ) vsv T svsv T s\n=\nt∑\ns=1\n( E [ zs\np2s\n∣∣∣∣ Fs−1 ] − 1 ) vsv T svsv T s = t∑\ns=1\n( E [ zs\np2s\n∣∣∣∣ Fs−1 ] − 1 ) vsv T svsv T s\n= t∑\ns=1\n( 1\nps − 1\n) vsv T svsv T s = t∑\ns=1\n( vTsvs\nps − vTsvs\n) vsv T s = t∑\ns=1\n( τt,s ps − τt,s ) vsv T s ,\nwhere we used the fact that z2s = zs and E[zs|Fs−1] = ps. We can now bound this quantity as\n∥∥Wt ∥∥ = ∥∥∥∥∥ t∑\ns=1\nE [ X 2\ns ∣∣∣ Fs−1 ]∥∥∥∥∥ = ∥∥∥∥∥ t∑\ns=1\n( τt,s ps − τt,s ) vsv T s ∥∥∥∥∥ ≤ ∥∥∥∥∥ t∑\ns=1\nτt,s ps vsv T s ∥∥∥∥∥ ≤ ∥∥∥∥∥ t∑\ns=1\nτt,s βτt,s vsv T s ∥∥∥∥∥\n= 1\nβ ∥∥∥∥∥ t∑\ns=1\nvsv T\ns ∥∥∥∥∥ = 1 β ‖VtVTt ‖ = 1 β ‖Pt‖ ≤ 1 β := σ2.\nTherefore, if we let σ2 = 1/β and R = 1/β, we have P (‖Yt‖ ≥ ε) ≤ P ( ‖Yt‖ ≥ ε ) = P ( ‖Yt‖ ≥ ε ∩ ‖Yt‖ ≤ σ2 ) + P ( ‖Yt‖ ≥ ε ∩ ‖Yt‖ ≥ σ2 )\n≤ P ( ‖Yt‖ ≥ ε ∩ ‖Yt‖ ≤ σ2 ) + P ( ‖Yt‖ ≥ σ2 ) ≤ 2t exp { −ε 2\n2 1 1 β (1 + ε/3)\n} + 0 ≤ 2t exp { −ε 2β\n3\n} ·\nStep 3: Bounding the space. We want to show that\nP\n( t∑\ns=1\nzs ≥ 3βdtonl(α) ∩ {∀ t′ ∈ {1, . . . , t} : ‖Yt‖ ≤ ε} ) .\nAssume, without loss of generality, that for all s ∈ [t] we have βτs,s ≤ 1, and introduce the independent Bernoulli random variables ẑs ∼ B(βτs,s). Thanks to the intersection with the event {∀ t′ ∈ {1, . . . , t} : ‖Yt‖ ≤ ε}, we know that all dictionaries Is are ε-accurate, and therefore for all s we have p̃s ≤ βτ̃s,s ≤ βτs,s. Thus ẑs stochastically dominates zs and we have\nP\n( t∑\ns=1\nzs ≥ 3βdtonl(α) ∩ {∀ t′ ∈ {1, . . . , t} : ‖Yt‖ ≤ ε} ) ≤ P ( t∑\ns=1\nẑs ≥ 3βdtonl(α) ) .\nApplying Prop. 6 to ∑t s=1 ẑs and knowing that ∑t s=1 pt = ∑t s=1 βτs,s = βd t onl(α), we have\nP\n( t∑\ns=1\nẑs ≥ 3βdtonl(α) ) ≤ exp{−3βdtonl(α)(3βdtonl(α) − (log(3βdtonl(α)) + 1))} ≤ exp{−2βdtonl(α)}.\nAssuming dtonl(α) ≥ 1, we have that exp{−2βdtonl(α)} ≤ exp{−2β} ≤ exp{− log((T/δ)2)} ≤ δ2/T 2 ≤ δ/(2T ) as long as 2δ ≤ 2 ≤ T ."
    }, {
      "heading" : "D. Proofs for Section 5",
      "text" : "Proof of Lemma 4. Through this proof, we make use of the linear algebra identity from Prop. 2. We begin with the refor-\nmulation of b̃i = [b̃t]i. In particular, the only term that we need to reformulate is\nφtÃ −1 t−1φt = φt(Φt−1Rt−1R T t−1Φ T t−1 + αI) −1φt\n= 1\nα φt(I−Φt−1Rt−1(RTt−1Φ\nT t−1Φt−1Rt−1 + αI) −1RTt−1Φ T t−1)φt\n= 1\nα (φ\nT tφt − φ T tΦt−1Rt−1(R T t−1Φ T t−1Φt−1Rt−1 + αI) −1RTt−1Φ T t−1φt)\n= 1\nα (kt,t − k\nT [t−1],tRt−1(R T t−1Kt−1Rt−1 + αI) −1RTt−1k[t−1],t).\nFor y̆t, we have\ny̆t = φ T t ũt = φ T t Ã −1 t−1Φt−1b̃t−1\n= φTt (Φt−1Rt−1R T t−1Φ T t−1 + αI) −1Φt−1b̃t−1 = 1\nα φTt\n( I−Φt−1Rt−1(RTt−1Φ T t−1Φt−1Rt−1 + αI) −1RTt−1Φ T t−1 ) Φt−1b̃t−1\n= 1\nα φTtΦt−1Dt−1\n( b̃t−1 −Rt−1(RTt−1Kt−1Rt−1 + αI)−1RTt−1Kt−1b̃t−1 )\n= 1\nα kT[t−1],tDt−1\n( b̃t−1 −Rt−1(RTt−1Kt−1Rt−1 + αI)−1RTt−1Kt−1b̃t−1 ) .\nProof of Theorem 3. Since the only thing that changed is the formulation of the At matrix, the bound from Prop. 1 still applies. In particular, we have that the regret R̃T of Alg. 3 is bounded as\nR̃(w) ≤α‖w‖2 A0\n+ ∑T\nt=1 gTt Ã −1 t gt + ∑T t=1 (wt −w)T(Ãt − Ãt−1 − σtgtgTt )(wt −w).\nFrom Thm. 2, we have that KORS succeeds with high probability. In particular, using the guarantees of the ε-accuracy (1), we can bound for the case ηt = σ as\ngTt Ã −1 t gt = ηt ηt gTt (ΦtRtR T tΦ T t + αI) −1gt = 1 ηt φ T t (ΦtRtR T tΦ T t + αI) −1φt\n= 1\nηt p̃min p̃min φ T t (ΦtRtR T tΦ T t + αI) −1φt = 1 ηt 1 p̃min φ T t\n( 1\np̃min ΦtRtR\nT tΦ T t + αI )−1 φt\n≤ 1 ηt 1 p̃min φ T t\n( ΦtStS T tΦ T t + αI )−1 φt\n≤ 1 p̃minηt φ T t ((1− ε)ΦtΦ T t − εαI+ αI)−1φt = 1\n(1− ε)σp̃min φ\nT t (ΦtΦ T t + αI) −1φt = τ t,t (1− ε)σp̃min ,\nwhere in the first inequality we used the fact that the weight matrix St contains weights such that 1/ √ p̃min ≥ 1/ √ p̃t, in the second inequality we used the ε-accuracy, and finally, we used ηt = σ and the definition of τ t,t. Therefore,\nRG = ∑T\nt=1 gTt Ã −1 t gt ≤\n1 (1− ε)σp̃min ∑T t=1 τ t,t ≤\ndonl(α)\n(1− ε)σmax{βτmin, γ} ·\nTo bound RD, we have\n∑T t=1 (wt −w)T(Ãt − Ãt−1 − σtgtgTt )(wt −w) = ∑T t=1 (wt −w)T (ηtztgtgTt − σtgtgTt ) (wt −w)\n≤ ∑T\nt=1 (σ − σt)(gTt (wt −w))2 ≤ 0."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "<lb>Kernel online convex optimization (KOCO) is a<lb>framework combining the expressiveness of non-<lb>parametric kernel models with the regret guaran-<lb>tees of online learning. First-order KOCO meth-<lb>ods such as functional gradient descent require<lb>onlyO(t) time and space per iteration, and, when<lb>the only information on the losses is their con-<lb>vexity, achieve a minimax optimal O(<lb>√<lb>T ) re-<lb>gret. Nonetheless, many common losses in ker-<lb>nel problems, such as squared loss, logistic loss,<lb>and squared hinge loss posses stronger curvature<lb>that can be exploited. In this case, second-order<lb>KOCOmethods achieveO(log(Det(K))) regret,<lb>which we show scales as<lb>O(deff logT ), where<lb>deff is the effective dimension of the problem and<lb>is usually much smaller than O(<lb>√<lb>T ). The main<lb>drawback of second-order methods is their much<lb>higher O(t2) space and time complexity. In this<lb>paper, we introduce kernel online Newton step<lb>(KONS), a new second-order KOCOmethod that<lb>also<lb>achievesO(deff logT ) regret. To address the<lb>computational complexity of second-order meth-<lb>ods, we introduce a new matrix sketching algo-<lb>rithm for the kernel matrixKt, and show that for<lb>a chosen parameter γ ≤ 1 our Sketched-KONS<lb>reduces the space and time complexity by a fac-<lb>tor of γ toO(t2γ2) space and time per iteration,<lb>while incurring only 1/γ times more regret.",
    "creator" : "LaTeX with hyperref package"
  }
}