{
  "name" : "1502.02322.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Rademacher Observations, Private Data, and Boosting",
    "authors" : [ "Richard Nock", "Giorgio Patrini" ],
    "emails" : [ "richard.nock@nicta.com.au", "giorgio.patrini@anu.edu.au", "arik.friedman@nicta.com.au" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "This paper deals with the following fundamental question:\nWhat information is sufficient for learning, and what guarantees can it bring that regular data cannot ?\nBy “regular”, we mean the usual inputs provided to a learner. In our context of batch supervised learning, this is a training set of examples, each of which is an observation with a class, and learning means inducing in reduced time an accurate function from observations to classes, a classifier. It turns out that we do not need the detail of classes to learn a classifier (linear or kernelized): an aggregate, whose size is the dimension of the observation space, is minimally sufficient, the mean operator [24].\nar X\niv :1\n50 2.\n02 32\n2v 2\n[ cs\n.L G\nBut do we need examples ? This perhaps surprising and non-trivial question is becoming crucial now that the nature of stored and processed signals intelligence data is heavily debated in the public sphere [19, 28]. In the context of machine learning (ML), the objective of being accurate is more and more frequently subsumed by more complex goals, sometimes involving challenging tradeoffs in which accuracy does not ultimately appear in the topmost requirements. Privacy is one such crucial goal [10, 14, 15]. There are various models to capture the privacy requirement, such as secure multi-party computation and differential privacy (DP, [12]). The former usually relies on cryptographic protocols, which can be heavy even for bare classification and simple algorithms [4]. The latter usually relies on the power of randomization to ensure that any “local” change cannot be spotted from the output delivered [13, 12]. In a ML setting, randomization can be performed at various stages, from the examples to the output of a classifier. We focus on the upstream stage of the process, i.e. the input to the learner, which grants the benefits that all subsequent stages also comply with differential privacy. Randomization has its power: it also has its limits in this case, as it may significantly degrade the performance of learners.\nThe way we address this problem starts from a surprising observation, whose relevance to supervised ML goes beyond learning with private data: learning a linear (or kernelized) classifier over examples throughout the minimization of the expected logistic loss is equivalent to learning the same classifier by minimizing an exponential loss over a complete set of transformed data that we call Rademacher observations, rados. Each rado is the sum of edge vectors over examples (edge = observation × label). We also show that efficient learning from all rados may also be achieved when carried out over subsets of all possible rados.\nThis is our first contribution, and we expect it to be useful in several other areas of supervised learning. In the context of learning with private data, our other contributions can be summarized as showing how rados may yield new privacy guarantees — not limited to differential privacy — while authorising boosting-compliant rates for learning. More precisely, our second contribution is to propose a rado-based learning algorithm, which has boosting-compliant convergence rates over the logistic loss computed over the examples. Thus, we learn an accurate classifier over rados, and the same classifier is accurate over examples as well.\nThe fact that efficient learning may be achieved through subset of rados is interesting because it opens the problem of designing this particular subset to address domain-specific requirements that add to the ML accuracy requirement. Among our other contributions, we provide one important design example, showing how to build differentially private mechanisms for rado delivery, such as when protecting specific sensitive features in data. Experiments confirm in this case that learning from differentially private rados may still be competitive with learning from examples. We provide another design which pairs to our rado-based boosting algorithm, with the crucial property that when examples have been DP-protected by the popular Gaussian mechanism [12], the joint pair (rado delivery design, boosting algorithm) may achieve convergence rates comparable to the noisefree setting with high probability, even over strong DP protection regimes. Our last contribution is to show that rados may protect the privacy of the original examples not only in the DP framework, but also from several algebraic, geometric and even computational-complexity theoretic standpoints.\nThe remainder of this paper is organized as follows. Section §2 presents Rademacher observations, shows the equivalence between learning from examples and learning from rados, and how learning from subsets of rados may be sufficient for efficient learning; §3 presents our rado-based boosting algorithm, and §4 presents experiments with this algorithm; §5 presents our results in DP models, §6 presents related experiments; §7 provides results on the hardness of reconstructing examples from rados from algebraic, geometric and computational standpoints. To keep a readable paper, proofs and additional experiments are given in two separate appendices available in Section\n10 (proofs) and Section 11 (experiments)."
    }, {
      "heading" : "2 Rados and supervised learning",
      "text" : "Let [n] = {1, 2, ..., n}. We are given a set of m examples S .= {(xi, yi), i ∈ [m]}, where xi ∈ X ⊆ Rd is an observation and yi ∈ {−1, 1} is a label, or class. X is the domain. A linear classifier θ ∈ Θ for some fixed Θ ⊆ Rd gives a label to x ∈ X equal to the sign of θ>x ∈ R. Our results can be lifted to kernels (at least with finite dimension feature maps) following standard arguments [26]. We let Σm . = {−1, 1}m.\nDefinition 1 For any σ ∈ Σm, the Rademacher observation πσ with signature σ is πσ .= (1/2) ·∑ i(σi + yi)xi.\nThe simplest way to randomly sample rados is to pick σ as i.i.d. Rademacher variables, hence the name. Reference to S is implicit in the definition of πσ. A Rademacher observation sums edge vectors (the terms yixi), over the subset of examples for which yi = σi. When σ = y is the vector of classes, πσ = mµS is m times the mean operator [26, 24]. When σ = −y, we get the null vector πσ = 0. A popular approach to learn θ over S is to minimize the surrogate risk Flog (S,θ) built from the logistic loss (logloss):\nFlog (S,θ) . = 1\nm ∑ i log ( 1 + exp ( −yiθ>xi )) . (1)\nWe define the exponential rado-risk F rexp(S,θ,U), computed on any U ⊆ Σm with cardinal |U| = n, as:\nF rexp(S,θ,U) .\n= 1\nn ∑ σ∈U exp ( −θ>πσ ) . (2)\nIt turns out that Flog = g(F r exp) for some continuous strictly increasing g; hence, minimizing one criterion is equivalent to minimizing the other and vice versa. This is stated formally in the following Lemma.\nLemma 2 The following holds true, for any θ and S:\nFlog(S,θ) = log(2) + 1\nm logF rexp(S,θ,Σm) . (3)\n(Proof in the Appendix, Subsection 10.1). Lemma 2 shows that learning with examples via the minimization of Flog (S,θ), and learning with all rados via the minimization of F r exp(S,θ,Σm), are essentially equivalent tasks. Since the cardinal |Σm| = 2m is exponential, it is unrealistic, even on moderate-size samples, to pick that latter option. This raises however a very interesting question: if we replace Σm by subset U of size 2m,what does the relationship between examples and rados in eq. (3) become? We answer this question under the setting that:\n(i) instead of Σm, we consider a predefined Σr ⊆ Σm;\n(ii) instead of considering U = Σr, we sample uniformly i.i.d. U ∼ Σr for n ≥ 1 rados.\nWhile (ii) is directly targeted at reducing the number of rados, (i) is an upper-level strategic design to tackle additional constraints, such as differential privacy. We now need following definition of the logistic rado-risk :\nF rlog (S,θ,U) .\n= log(2) + 1\nm logF rexp(S,θ,U) , (4)\nfor any U ⊆ Σm, so that Flog (S,θ) = F rlog (S,θ,Σm). We also define the open ball B(0, r) . = {x ∈ Rd : ‖x‖2 < r}.\nTheorem 3 Assume Θ ⊆ B(0, rθ), for some rθ > 0. Let:\n% . = supθ′∈Θ maxπσ∈Σr exp(−θ′>πσ)\nF rexp(S,θ,Σr) ,\n%′ .= F rexp(S,θ,Σr)\nF rexp(S,θ,Σm) ,\nwhere Σr follows (i) above. Then ∀η > 0, there is probability ≥ 1−η over the sampling of U in (ii) above that:\nFlog (S,θ) ≤ F rlog(S,θ,U) +Q− 1\nm · log\n( 1− q√\nn\n) , (5)\nwith\nq = Ω ( % · √ rθ max\nΣr ‖πσ‖2 + d log\n2en\nd + log\n1\nη\n) (6)\nand Q . = −(1/m) · log %′ satisfies Q = 0 if Σr = Σm and\nQ ≤ rθ ( ‖∇θF rlog (S,θ,Σm) ‖2 + πr ) (7)\notherwise, letting πr . = ‖Eσ∼Σr(1/m) · πσ‖2. Furthermore, ∀0 ≤ β < 1/2, if m is sufficiently large, then letting π∗r . = maxΣr ‖(1/m) · πσ‖2, ineq. (5) becomes:\nFlog (S,θ) ≤ F rlog(S,θ,U) +Q\n+O\n( % mβ · √ rθπ∗r n + d nm log 2en dη ) . (8)\n(Proof in the Appendix, Subsection 10.2) Theorem 3 does not depend on the algorithm that learns θ. The right-hand side of ineq. (5) shows two penalties. Q arises from the choice of Σr and is therefore structural. Regardless of Σr, when the classifier is reasonably accurate over all rados and expected examples edges in Σr average to a ball of reduced radius, the upperbound on Q in ineq. (7) can be very small. The other penalty, which depends on q, is statistical and comes from the sampling in Σr. Theorem 3 shows that when Σr = Σm, even when n m, the minimization of F rlog (S,θ,U) may still bring, with high probability, guarantees on the minimization of Flog (S,θ). Thus, a lightweight optimization procedure over a small number of rados may bring guarantees on the minimization of the expected logloss over examples for the same classifier. The following Section exhibits one such algorithm.\nAlgorithm 1 Rado boosting (RadoBoost)\nInput set of rados Sr . = {π1,π2, ...,πn}; T ∈ N∗; Step 1 : let θ0 ← 0, w0 ← (1/n)1 ; Step 2 : for t = 1, 2, ..., T\nStep 2.1 : [d] 3 ι(t)← wfi(Sr,wt); Step 2.2 : let\nrt ← 1\nπ∗ι(t) n∑ j=1 wtjπjι(t) ; (9)\nαt ← 1\n2π∗ι(t) log 1 + rt 1− rt ; (10)\nStep 2.3 : for j = 1, 2, ..., n\nw(t+1)j ← wtj · 1− rtπjι(t)π∗ι(t) 1− r2t  ; (11) Return θT defined by θTk . = ∑ t:ι(t)=k αt , ∀k ∈ [d];"
    }, {
      "heading" : "3 Boosting using rados",
      "text" : "Algorithm 1 provides a boosting algorithm, RadoBoost, that learns from a set of Rademacher observations Sr . = {π1,π2, ...,πn}. Their (unknown) Rademacher assignments are denoted U .= {σ1,σ2, ...,σn} ⊆ Σm. These rados have been computed from some sample S, unknown to RadoBoost. In the statement of the algorithm, πjk denotes coordinate k of πj , and π∗k . = maxj |πjk|. More generally, the coordinates of some vector z ∈ Rd are denoted z1, z2, ..., zd. Step 2.1 gets a feature index ι(t) from a weak feature index oracle, wfi. In its general form, wfi returns a feature index maximizing |rt| in (9). The weight update was preferred to AdaBoost’s because rados can have large feature values and the weight update prevents numerical precision errors that could otherwise occur using AdaBoost’s exponential weight update. We now prove a key Lemma on RadoBoost, namely the fast convergence of the exponential rado-risk F rexp(S,θ,U) under a weak learning assumption (WLA). We shall then obtain the convergence of the logistic rado-risk (4), and, via Theorem 3, the convergence with high probability of Flog (S,θ).\n(WLA) ∃γ > 0 such that ∀t ≥ 1, the feature returned by wfi in Step 2.2 (9) satisfies |rt| ≥ γ.\nLemma 4 Suppose the (WLA) holds. Then after T rounds of boosting in RadoBoost, the following upperbound holds on the exponential rado-loss of θT :\nF rexp(S,θT ,U) ≤ exp ( −Tγ2/2 ) . (12)\n(Proof in the Appendix, Subsection 10.3) We now consider Theorem 3 with Σr = Σm, and therefore Q = 0. Blending Lemma 4 and Theorem 3 using (4) yields that, under the (WLA), we may observe with high probability (again, fixing Σr = Σm, so Q = 0 in Theorem 3):\nFlog (S,θT ) ≤ log(2)− Tγ2\n2m +Q′ , (13)\nwhere Q′ is the rightmost term in ineq. (5) or ineq. (8). So provided n 2m is sufficiently large, minimizing the exponential rado-risk over a subset of rados brings a classifier whose average logloss on the whole set of examples may decrease at rate Ω(γ2/m) under a weak learning assumption made over rados only. This rate competes with those for direct approaches to boosting the logloss [23], and we now show that our weak learning assumption is also essentially equivalent to the one done in boosting over examples [27]. Let us rewrite rt(w) as the normalized edge in (9), making explicit the dependence in the current rado weights. Let\nrext (w̃) .\n= 1\nx∗ι(t) m∑ i=1 wixiι(t) (14)\nbe the normalized edges for the same feature ι(t) as the one picked in step 2.1 of RadoBoost, but computed over examples using some weight vector w̃ ∈ Pm; here, Pm is the m-dim probability simplex and x∗ι(t) . = maxi |xik|.\nLemma 5 ∀wt ∈ Pn, ∀γ > 0, there exists w̃ ∈ Pm and γex > 0 such that |rt(wt)| ≥ γ iff |rext (w̃)| ≥ γex.\n(Proof in the Appendix, Subsection 10.4) The proof of the Lemma gives clues to explain why the presence of outlier feature values may favor RadoBoost."
    }, {
      "heading" : "4 Basic experiments with RadoBoost",
      "text" : "We have compared RadoBoost to its main contender, AdaBoost [27], using the same weak learner; in AdaBoost, it returns a feature maximizing |rt| as in eq. (14). In these basic experi-\nments, we have deliberately not optimized the set of rados in which we sample U for RadoBoost; hence, we have Σr = Σm.\nWe have performed comparisons with 10 folds stratified cross-validation (CV) on 16 domains of the UCI repository [2] of varying size. For space considerations, Table 1 presents the results. Each algorithm was ran for a total number of T = 1000 iterations; furthermore, the classifier kept for testing is the one minimizing the empirical risk throughout the T iterations; in doing so, we also assessed the early convergence of algorithms. We fixed n = min{1000, train fold size/2}. Table 1 displays that RadoBoost compares favourably to AdaBoost, and furthermore it tends to be all the better as m and d increase. On some domains like Hardware and Twitter, the difference is impressive and clearly in favor of RadoBoost. As discussed for Lemma 5, we could interpret these comparatively very poor performances of AdaBoost as the consequence of outlier features that can trick AdaBoost in picking the wrong sign in the leveraging coefficient αt for a large number of iterations if we use real-valued classifiers (see column 100σ in Table 1). This drawback can be easily corrected (Cf Appendix, Subsection 11.1) by enforcing minimal |rt| values. This significantly improves AdaBoost on Hardware and Twitter. The improvements observed on RadoBoost are even more favorable."
    }, {
      "heading" : "5 Rados and differential privacy",
      "text" : "We now discuss the delivery of rados to comply with several DP constraints and their eventual impact on boosting. We thus adress both levels (i+ii) of rado delivery in §2. Our general model is the standard DP model [12]. Intuitively, an algorithm is DP compliant if for any two neighboring datasets, it assigns similar probability to any possible output O. In other words, any particular record has only limited influence on the probability of any given output of the algorithm, and therefore the output discloses very little information about any particular record in the input. Formally, a randomized algorithm A is ( , δ)-differentially-private [11] for some , δ > 0 iff:\nPA[O|S] ≤ exp( ) · PA[O|S′] + δ,∀S ≈ S′, O, (15)\nwhere the probability is over the coin tosses of A. This model is very strong, especially when δ = 0, and in the context of ML, maintaining high accuracy in strong DP regimes is generally\nAlgorithm 2 Feature-wise DP-compliant rados (DP-Feat)\nInput set of examples S, sensitive feature j∗ ∈ [d], number of rados n, differential privacy parameter > 0; Step 1 : let β ← 1/(1 + exp( /2)) ∈ [0, 1/2); Step 2 : sample σ1,σ2, ...,σn i.i.d. (uniform) in Σ β,j∗ m ; Return set of rados {πσ : σ sampled in Step 2};\na tricky tradeoff [10]. Because rados are an intermediate step between training sample S and a rado-based learner, there are two ways to design rados with respect to the DP framework: crafting DP-compliant rados from unprotected examples, or crafting rados from DP-compliant examples with the aim to improve the performance of the rado-based learner (Figure 5.2). These scenarii can be reduced to the design of Σr."
    }, {
      "heading" : "5.1 A feature-wise DP mechanism for rados",
      "text" : "In this Subsection, we consider a relaxation of differential-privacy, namely feature-wise differential privacy, where the differential privacy requirement applies to j∗-neighboring datasets: we say that two samples S, S′ are j∗-neighbors, noted S ≈j∗ S′, if they are the same except for the value of the jth∗ ∈ [d] observation feature of some example. We further assume that the feature is boolean. For example, we may have a medical database containing a column representing the HIV status of a doctor’s patients (1 row = a patient), and we do not wish that changing a single patient HIV status significantly changes the density of that feature’s values in rados. This setting would also be very useful in genetic applications to hide in rados gene disorders that affect one or few genes. Feature-wise DP is analogous to the concept of α-label privacy [7], where differential privacy is guaranteed with respect to the label. Algorithm A in ineq. (15) is given in Algorithm 2. It relies on the following subset Σr . = Σβ,j∗m ⊆ Σm:\nΣβ,j∗m . = { σ ∈ Σm : πσj∗ ∈ [ |{i : yixij∗ = +1}| − m\n2 ±∆β\n]} , (16)\nwith ∆β . = (m/2) − β(m + 1). The key feature of this mechanism is that it does not alter the examples in the sense that DP-compliant rados belong to the set of cardinal 2m that can be generated from S. Usual data-centered DP mechanisms would rather alter data, e.g. via noise injection [15]. Algorithm 2 exploits the fact that it is the tails of feature j∗ that leak sensitive information about the feature in rados (see Figure 2). The following Theorem is stated so as we can pick small δ, typically δ 1/m. Other variants are possible that bring different tradeoffs between and δ.\nTheorem 6 Assume is chosen so that = o(1) but = Ω(1/m). In this case, DP-Feat maintains (n · , n · δ)-differential privacy on feature j∗ for some δ > 0 such that · δ = O(m−5/2).\n(Proof in the Appendix, Subsection 10.5) We have implemented Step 2 in Algorithm DP-Feat in the simplest way, using a simple Rademacher rejection sampling where each σj is picked i.i.d. as σj ∼ Σm until σj ∈ Σβ,j∗m . The following Theorem shows its algorithmic efficiency.\nTheorem 7 For any η > 0, let n∗η . = η(1− exp(2β − 1))/(4β), and let nR denote the total number of rados sampled in Σm until n rados are found in Σ β,j∗ m . Then for any η > 0, there is probability ≥ 1− η that\nnR ≤ n · { 1 if n ≤ n∗η⌈ 1\nmDBE(1−β‖1/2) log n n∗η\n⌉ otherwise ,\nwhere DBE is the bit-entropy divergence: DBE(p‖q) = p log(p/q) + (1− p) log((1− p)/(1− q)), for p, q ∈ (0, 1).\n(Proof in the Appendix, Subsection 10.6) Remark that replacing Σm by Σr = Σ β,j∗ m would not necessarily impair the boosting convergence of RadoBoost trained from rados samples from DPFeat (Lemma 4). The only systematic change would be in ineq. (13) where we would have to integrate the structural penalty Q from Theorem 3 to further upperbound Flog (S,θT ). In this case, the upperbound in (7) reveals that at least when the mean operator in Σβ,j∗m has small norm — which may be the case even when some examples in S have large norm — and the gradient penalty is small, then Q may be small as well.\nWe end up with several important remarks, whose formal statements and proofs are left out due to space constraints. First, the tail truncation design exploited in DP-Feat can be fairly simply generalized in two directions, to handle (a) real-valued features, and/or (b) several sensitive features instead of one. Second, we can do DP-compliant design of rado delivery beyond featurewise privacy, e.g. to protect “rado-wide” quantities like norms."
    }, {
      "heading" : "5.2 Boosting from DP-compliant examples via rados",
      "text" : "We now show how to craft rados from DP-compliant examples so as to approximately keep the convergence rates of RadoBoost. More precisely, since edge vectors are sufficient to learn (eq. 1), we assume that edge vectors are DP-compliant (neighbor samples, S ≈ S′, would differ on one edge vector). A gold standard to protect data in the DP framework is to convolute data with noise. One popular mechanism is the Gaussian mechanism [12, 16], which convolutes data with independent Gaussian random variables N(0, ς2I), whose standard deviation ς depends on the DP requirement ( , δ). Strong DP regimes are tricky to handle for learning algorithms. For example, the approximation factor ρ of the singular vectors under DP noise of the noisy power method roughly behaves as ρ = Ω(ς/∆) [16] (Corollary 1.1) where ∆ = O(d) is a difference between two\nsingular values. When ς is small, this is a very good bound. When the DP requirement blows up, the bound remains relevant if d increases, which may be hard to achieve in practice — it is easier in general to increase m than d, which requires to compute new features for past examples.\nWe consider ineq. (15) with neighbors I and I ′ being two sets of m edge vectors differing by one edge vector, and O is a noisified set of m edge vectors generated through the Gaussian mechanism [12] (Appendix A). We show the following non-trivial result: provided we design another particular Σr, the convergence rate of RadoBoost, as measured over non-noisy rados, essentially survives noise injection in the edge vectors through the Gaussian mechanism, even under strong noise regimes, as long as m is large enough. The intuition is straightforward: we build rados summing a large number of edge vectors only (this is the design of Σr), so that the i.i.d. noise component gets sufficiently concentrated for the algorithm to be able to learn almost as fast as in the noise-free setting. We emphasize the non-trivial fact that convergence rate is measured over the non-noisy rados, which of course RadoBoost does not see. The result is of independent interest in the boosting framework, since it makes use of a particular weak learner (wfi), which we call prudential, which picks features with |rt| (9) upperbounded.\nWe start by renormalizing coefficients αt (eq. (10)) in RadoBoost by a parameter κ ≥ 1 given as input, so that we now have αt ← (1/(2κπ∗ι(t))) log((1 + rt)/(1− rt)) in Step 2.2. It is not hard\nto check that the convergence rate of RadoBoost now becomes, prior to applying the (WLA)\nF rlog(S,θT ,U) ≤ log(2)− 1\n2κm ∑ t r2t . (17)\nWe say that wfi is λp-prudential for λp > 0 iff it selects at each iteration a feature such that |rt| ≤ λp. Edges vectors have been DP-protected as yi(xi + xri ), with xri ∼ N(0, ς2I) (for i ∈ [m]). Let mσ . = |{i : σi = yi}| denote the support of a rado, and (m∗ > 0 fixed):\nΣr = Σ m∗ m . = {σ ∈ Σm : mσ = m∗} . (18)\nTheorem 8 ∀U ⊆ Σr, ∀τ > 0, if √ m∗ = Ω (ς ln(1/τ)), then ∃λp > 0 such that RadoBoost having access to a λp-prudential weak learner returns after T iteration a classifier θT which meets with probability ≥ 1− τ:\nF rlog(S,θT ,U) ≤ log(2)− 1\n4κm ∑ t r2t . (19)\nThe proof, in the Appendix (Subsection 10.7), details parameters and dependencies hidden in the statement. The use of a prudential weak learner is rather intuitive in a noisy setting since αt blows up when |rt| is close to 1. Theorem 8 essentially yield that a sufficiently large support for rados is enough to keep with high probability the convergence rate of RadoBoost within noise-free regime. Of course, the weak learner is prudential, which implies bounded |rt| < 1, and furthermore the leveraging coefficients αt are normalized, which implies smaller margins. Still, Theorem 8 is a good theoretical argument to rely on rados when learning from DP-compliant edge vectors."
    }, {
      "heading" : "6 Experiments on differential privacy",
      "text" : "Table 2 presents a subset of the experiments carried out with RadoBoost and AdaBoost in the contexts of Subsections 5.1 and 5.2 (see Section 11 for all additional experiments). Unless otherwise stated, experimental settings (cross validation, number of rados for learning, etc.) are the same as in Section 4.\nIn a first set of experiments, we have assessed the impact on learning of the feature-wise DP mechanism: on each tested domain, we have selected at random a binary feature, and then used Algorithm DP-Feat to protect the feature for different values of DP parameter , in a range that covers usual DP experiments [18] (Table 1). The main conclusion that can be drawn from the experiments is that learning from DP-compliant rados can compete with learning from random rados, and even learning from examples (AdaBoost), even for rather small .\nWe then have assessed the impact on learning of examples that have been protected using the Gaussian mechanism [12], with or without rados, with or without a prudential weak learner for boosting, and with or without using a fixed support for rado computation. The Appendix provides extensive results for all domains but the largest ones (Twitter, SuSy, Higgs). In the central column (and Tables 4 through 7 in the Appendix), computing the differences between RadoBoost’s error and AdaBoost’s reveals that, on domains where it is beaten by AdaBoost when there is no noise, RadoBoost almost always rapidly become competitive with AdaBoost as noise increases. Hence, RadoBoost is a good contender from the boosting family to learn from differentially private (or noisy) data. Second, using a prudential weak learner which picks the median feature (instead of the\nmore efficient weak learner that picks the best as in Section 4) can have RadoBoost with fixed support rados compete or beat RadoBoost with plain random rados, at least for small noise levels (see Transfusion and Magic in the right column of Table 2). Replacing the median-prudential weak learner by a strong learner can actually degrade RadoBoost’s results (see the Appendix, Tables 10 and 11). These two observations advocate in favor of the theory developed in Subsection 5.2. Finally, using rados with fixed support instead of plain random rados (Section 4) can significantly improve the performances of RadoBoost (see the Appendix, Tables 10 and 11)."
    }, {
      "heading" : "7 From rados to examples: hardness results",
      "text" : "The problem we address here is how we can recover examples from rados, and when we cannot recover examples from rados. This last setting is particularly useful from the privacy standpoint, as this may save us costly obfuscation techniques that impede ML tasks [4]."
    }, {
      "heading" : "7.1 Algebraic and geometric hardness",
      "text" : "For any m ∈ N∗, we define matrix Gm ∈ {0, 1}m×2m as:\nGm . =\n[ 0>2m−1 1 > 2m−1\nGm−1 Gm−1\n] (20)\nif m > 1, and G1 . = [0 1] otherwise (zd denotes a vector in Rd). Each column of Gm is the binary indicator vector for the edge vectors considered in a rado. Hereafter, we let E ∈ Rd×m the matrix of columnwise edge vectors from S, Π ∈ Rd×n the columnwise rado matrix and U ∈ {0, 1}2m×n in which each column gives the index of a rado computed in Sr. By construction, we have:\nΠ = EGmU , (21)\nand so we have the following elementary results for the (non) reconstruction of E (proof omitted).\nLemma 9 (a) when recoverable, edge-vectors satisfy: E = ΠU>G>m(GmUU >G>m) −1; (b) when U, Π, m are known but n < m, there is not a single solution to eq. (21) in general.\nLemma 9 states that even when U, Π and m are known, elementary constraints on rados can make the recovery of edge vectors hard — notice that such constraints are met in our experiments with RadoBoost in Sections 4 and 6.\nBut this represents a lot of unnecessary knowledge to learn from rados: RadoBoost just needs Π to learn. We now explore the guarantees that providing this sole information brings in terms of (not) reconstructing E. ∀M ∈ Ra×b, we let C(M) denote the set of column vectors, and for any C ⊆ Rd, we let C ⊕ .= ∪z∈CB(z, ). We define the Hausdorff distance, DH(E,E′), between E and E′:\nDH(E,E ′)\n. = inf{ : C(E) ⊆ C(E′)⊕ ∧ C(E′) ⊆ C(E)⊕ } .\nThe following Lemma shows that if the only information known is Π, then there exist samples that bring the same set of rados C(Π) as the unknown E but who are at distance proportional to the “width” of the domain at hand.\nLemma 10 For any Π ∈ Rd×n, suppose eq. (21) holds, for some unknowns m > 0, E ∈ Rd×m, U ∈ {0, 1}2m×n. Suppose C(E) ⊂ B(0, R) for some R > 0. Then there exists E′ ∈ Rd×(m+1), U′ ∈ {0, 1}2m+1×n such that\nC(E′) ⊂ B(0, R) and Π = E′Gm+1U′ , (22)\nbut\nDH(E,E ′) = Ω ( R log d√ d logm ) (23)\nif m ≥ 2d, and DH(E,E′) = Ω(R/ √ d) otherwise.\n(Proof in the Appendix, Subsection 10.8) Hence, without any more knowledge, leaks, approximations or assumptions on the domain at hand, the recovery of E pays in the worst case a price proportional to the radius of the smallest enclosing B(0, .) ball for the unknown set of examples. We emphasize that this inapproximability result does not rely on the computational power at hand."
    }, {
      "heading" : "7.2 Computational hardness",
      "text" : "In this Subsection, we investigate two important problems in the recovery of examples. The first problem addresses whether we can approximately recover sparse examples from a given set of rados, that is, roughly, solve (21) with a sparsity constraint on examples. The first Lemma we give is related to the hardness of solving underdetermined linear systems for sparse solutions [9]. The sparsity constraint can be embedded in the compressed sensing framework [8] to yield finer hardness and approximability results, which is beyond the scope of our paper. We define problem “Sparse-Approximation” as:\n(Instance) : set of rados Sr = {π1,π2, ...,πn}, m ∈ N∗, r, ` ∈ R+, ‖.‖p, Lp-norm for p ∈ R+;\n(Question) : Does there exist set S . = {(xi, yi), i ∈ [m]} and set U .= {σ1,σ2, ...,σn} ∈ {−1, 1}m such that:\n‖xi‖p ≤ ` , ∀i ∈ [m] , (Sparse examples) ‖πj − πσj‖p ≤ r , ∀j ∈ [n] . (Rado approximation)\nLemma 11 Sparse-Approximation is NP-Hard.\n(Proof in the Appendix, Subsection 10.9) In the context of rados, the second problem we address has very large privacy applications. Suppose entity A© has a huge database of people (e.g. clients), and obtains a set of rados emitted by another entity B©. An important question that A© may ask is whether the rados observed can be approximately constructed by its database, for example to figure out which of its clients are also its competitors’. We define this as problem “Probe-SampleSubsumption”:\n(Instance) : set of examples S, set of rados Sr = {π1,π2, ...,πn}, m ∈ N∗, p, r ∈ R+.\n(Question) : Does there exist S′ .= {(xi, yi), i ∈ [m]} ⊆ S and set U .= {σ1,σ2, ...,σn} ∈ {−1, 1}m such that:\n‖πj − πσj‖p ≤ r , ∀j ∈ [n] . (Rado approximation)\nLemma 12 Probe-Sample-Subsumption is NP-Hard.\n(Proof in the Appendix, Subsection 10.10) This worst-case result calls for interesting domain-specific qualifications, such as in genetics where the privacy of raw data, i.e. individual genomes, can be compromised by genome-wise statistics [17, 21]."
    }, {
      "heading" : "8 Conclusion",
      "text" : "We have introduced novel quantities that are sufficient for efficient learning, Rademacher observations. The fact that a subset of these can replace traditional examples for efficient learning opens interesting problems on how to craft these subsets to cope with additional constraints. We have illustrated these constraints in the field of efficient learning from privacy-compliant data, from various standpoints that include differential privacy as well as algebaric, geometric and computational considerations. In that last case, results rely on NP-Hardness, and thus go beyond the “hardness” of factoring integers on which rely some popular cryptographic techniques [4]. Finally, rados are cryptography-compliant: homomorphic encryption schemes can be used to compute rados in the encrypted domain from encrypted edge vectors or examples — rado computation can thus be easily distributed in secure multiparty computation applications."
    }, {
      "heading" : "9 Acknowledgments",
      "text" : "The authors are indebted to Tiberio Caétano for early discussions that brought the idea of Rademacher observations and their use in privacy related applications. Thanks are also due to Stephen Hardy and Hugh Durrant-Whyte for many stimulating discussions and feedback on the subject. NICTA is funded by the Australian Government through the Department of Communications and the Australian Research Council through the ICT Center of Excellence Program."
    }, {
      "heading" : "10 Appendix — Proofs",
      "text" : "To simplify the proofs, we define the following quantity:\nπ̃σ . = ∑ i σixi , ∀σ ∈ Σm . (24)\nso that each rado can be defined as: πσ = (1/2) · (π̃σ + π̃y). We recall that y is the label vector."
    }, {
      "heading" : "10.1 Proof of Lemma 2",
      "text" : "We have\nFlog (S,θ) . = 1\nm ∑ i log ( 1 + exp ( −yiθ>xi ))\n= 1\nm ∑ i log  ∑ y∈{−1,1} exp ( 1 2 · yθ>xi )− 1 m · 1 2 · θ>π̃y (25)\n= 1\nm log ∑ σ∈Σm exp ( 1 2 · θ>π̃σ ) − 1 m · 1 2 · θ>π̃y\n= 1\nm log ∑ σ∈Σm exp ( 1 2 · θ>π̃σ ) + 1 m · log exp ( −1 2 · θ>π̃y ) = 1\nm log ∑ σ∈Σm exp ( 1 2 · θ>(π̃σ − π̃y) ) = 1\nm log ∑ σ∈Σm exp ( −1 2 · θ>(π̃σ + π̃y) ) (26)\n= log(2) + 1\nm log\n1\n2m ∑ σ∈Σm exp ( −1 2 · θ>(π̃σ + π̃y) ) = log(2) + 1\nm log\n1\n2m ∑ σ∈Σm exp ( −θ>πσ ) = log(2) + 1\nm logF rexp(S,θ,Σm) .\nWe refer to ([24]) (Lemma 1) for the proof of 25. Eq. (26) holds because Σm is closed by negation."
    }, {
      "heading" : "10.2 Proof of Theorem 3",
      "text" : "Let us suppose that our set of rados U satisfies:\nU ⊆ Σr ⊆ Σm , (27)\nwhere Σr is a fixed reference subset of Σm. We shall use the shorthand EU [f(U)] to denote uniform i.i.d. sampling of U in Σr. Furthermore, we also let for short\n` .\n= sup θ∈Θ max πσ∈Σr\nexp(−θ>πσ) . (28)\nThe proof relies on basic knowledge of VC theory and the “symmetrization trick”, which can be found e.g. in ([6]). Plugging eq. (28) into the proof of the symmetrization Lemma (Lemma 2 in ([6])) yields the following symmetrization Lemma for the exponential rado-loss. Notice that the assumption is the same as in Lemma 2 in ([6]).\nLemma 13 For any fixed sample S, for any t such that nt2 ≥ 2, the following holds over the Rademacher sampling of σ in Σm:\nP [\nsup θ∈Θ\n(EU [ F rexp(S,θ, U) ] − F rexp(S,θ,U)) ≥ t ] ≤ 2`2 · P\n[ sup θ∈Θ (F rexp(S,θ,U)− F rexp(S,θ,U′)) ≥ t 2 ] ,\nwhere U,U′ are two size-n i.i.d. samples.\nConsider U,U′ ⊆ Σr, each of cardinal n and differing from one assignment only. Then it follows, for any θ ∈ Θ and from ineq. (29):\n|F rexp(S,θ,U)− F rexp(S,θ,U′)| ≤ 2`\nn . (29)\nApplying the independent bounded differences inequality ([20]), we get, for any θ ∈ Θ and t > 0:\nP [ EU [ F rexp(S,θ, U) ] − F rexp(S,θ,U) ≥ t\n4\n] ≤ exp ( − nt 2\n16`2\n) . (30)\nLetting Π(n) denote the growth function for linear separators computed over rados, we still have the upperbound\nΠ(n) ≤ ( en\nd+ 1\n)d+1 . (31)\nWe thus get, for any θ ∈ Θ: P [\nsup θ∈Θ\n(EU [ F rexp(S,θ, U) ] − F rexp(S,θ,U)) ≥ t ] ≤ 2`2 · P\n[ sup θ∈Θ (F rexp(S,θ,U)− F rexp(S,θ,U′)) ≥ t 2 ] (32)\n≤ 2Π(2n)`2 · P [ F rexp(S,θ,U)− F rexp(S,θ,U′) ≥ t\n2\n] (33)\n≤ 4Π(2n)`2 · P [ EU [ F rexp(S,θ, U) ] − F rexp(S,θ,U) ≥ t\n4\n] (34)\n≤ 4Π(2n)`2 · exp ( − nt 2\n16`2\n) (35)\n≤ 4 ( 2en\nd+ 1\n)d+1 `2 · exp ( − nt 2\n16`2\n) . (36)\nIneq. (32) follows from Lemma 13, ineq. (33) follows from standard VC arguments (see e.g. ([6]), Section 4), ineq. (34) follows from the observation that event a−b ≥ u implies (a−c ≥ u/2)∨(b−c ≥ u/2), ineq. (35) follows from (30), and finally ineq (36) follows from ineq. (31). Picking\nt = t∗ . = 16` · √ 1\nn log `+\nd n log 2en d + 1 n log 1 η (37)\nyields that the right hand-side of ineq. (36) is not more than η, for any η > 0. So with probability ≥ 1−η, any classifier θ ∈ Θ will enjoy EU [ F rexp(S,θ, U) ] ≤ F rexp(S,θ,U) + t∗, and so we shall have:\nF rlog(S,θ,U)\n. = log(2) +\n1\nm · logF rexp(S,θ,U)\n≥ log(2) + 1 m · log\n( EU [ F rexp(S,θ, U) ] − t∗ ) = log(2) + 1\nm · log\n( EU [ F rexp(S,θ, U) ]) + 1\nm · log\n( 1− 16% · √ 1\nn log `+\nd n log 2en d + 1 n log 1 η\n) (38)\n= log(2) + 1\nm · logF rexp(S,θ,Σm) +\n1\nm · log\nF rexp(S,θ,Σr) F rexp(S,θ,Σm)\n+ 1\nm · log\n( 1− 16% · √ 1\nn log `+\nd n log 2en d + 1 n log 1 η\n)\n= Flog (S,θ) + 1\nm · log\nF rexp(S,θ,Σr) F rexp(S,θ,Σm)\n+ 1\nm · log\n( 1− 16% · √ 1\nn log `+\nd n log 2en d + 1 n log 1 η\n) . (39)\nIn eq. (38), we use the fact that % = `/EU [ F rexp(S,θ, U) ] and EU [ F rexp(S,θ, U) ] = F rexp(S,θ,Σr). Hence, reordering the expression yields that with probability ≥ 1 − η, the final classifier θ will\nsatisfy:\nFlog (S,θ) ≤ F rlog(S,θ,U)− 1\nm · log\nF rexp(S,θ,Σr) F rexp(S,θ,Σm)\n− log ( 1− 16 · %√ n · √ log `+ d log 2en d + log 1 η ) . (40)\nThere remains to use the fact that ` ≤ exp(rθ maxΣr ‖πσ‖2) to complete the proof of ineq. (5) in Theorem 3. To prove ineq. (8), let us call 1 − z the quantity inside the log in ineq. (40). We clearly have to have 0 ≤ z < 1, and so for any value of z and for any 0 ≤ α < 1, there exists a value m∗ > 0 such that\nm1−α ≥ 1 z log 1 1− z (≥ 0) , (41)\nfor any m ≥ m∗. In this case, we get after reordering, since 1− z′ ≤ exp z′,\n1− z mα ≤ exp ( − z mα ) ≤ exp ( 1\nm log(1− z)\n) , (42)\nand so, taking logs and using ineq. (39), we obtain that for any 0 ≤ β < 1/2, there exists m∗ > 0 such that for any m ≥ m∗:\nFlog (S,θ) ≤ F rlog(S,θ,U)− 1\nm · log\nF rexp(S,θ,Σr) F rexp(S,θ,Σm)\n− log ( 1− 16 · % mβ · √ rθ n ·max Σr ∥∥∥∥ 1m · πσ ∥∥∥∥\n2\n+ d\nnm log\n2en\nd +\n1\nnm log\n1\nη\n) . (43)\nCalling 1− z′ the quantity inside the log, there remains to use log(1− z′) ≥ −Kz′ for some K > 0 when z′ is sufficiently close to 0 (hence, m sufficiently large again). This proves ineq. (8) and completes the proof of Theorem 3. Remark that provided n is sufficiently large, the right hand-side of ineq (41) admits the following equivalent:\n1 z log 1 1− z ∼ 1 + z 2 , (44)\nwith z = Ω(1/ √ n) (omitting the dependences in the other parameters). Hence, ineq (41) can be ensured as long as m is large enough with respect to rθ, maxΣr ‖(1/m) · πσ‖2 (which cannot exceed the maximum norm of an observation in S), d and log(1/η).\nSo, when we apply this last result to RadoBoost, it says that for a large enough sample, we can indeed pick an n sufficiently large but small compared to m so that we shall observe with high probability a decay rate of the expected logistic loss computed over S, E[Flog (S,θT )], of order Ω(γ2/m) (expectation is measured with respect to the sampling of U).\nWe are now left with proving ineq. (7), and so we study:\n−Q = 1 m · log\n( 1 |Σr| ∑ σ′∈Σr exp(−θ>πσ′)\n1 |Σm| ∑ σ∈Σm exp(−θ>πσ)\n)\n= 1\nm · log\n( |Σm| ∑ σ′∈Σr exp(−θ>πσ′)\n|Σr| ∑ σ∈Σm exp(−θ>πσ)\n)\n= 1\nm · log\n(∑ σ∈Σm ∑ σ′∈Σr exp(−θ>πσ′)∑\nσ′∈Σr ∑ σ∈Σm exp(−θ>πσ)\n)\n= 1\nm · log\n(∑ σ′∈Σr ∑ σ∈Σm exp(−θ>πσ) · exp(−θ>(πσ′ − πσ))∑\nσ′∈Σr ∑ σ∈Σm exp(−θ>πσ) ) = 1\nm · log\n( E(σ,σ′)∼D [ exp(−θ>(πσ′ − πσ)) ]) ,\nwith D(σ,σ′) ∝ exp(−θ>πσ). Jensen’s inequality yields:\n−Q ≥ 1 m · E(σ,σ′)∼D\n[ −θ>(πσ′ − πσ) ] = 1\nm · E(σ,σ′)∼D\n[ θ>πσ ] − 1 m · E(σ,σ′)∼D [ θ>πσ′ ] . (45)\nWe now remark that E(σ,σ′)∼D [ θ>πσ′ ] = ∑ σ′∈Σr ∑ σ∈Σm exp(−θ>πσ) · θ>πσ′∑\nσ′∈Σr ∑ σ∈Σm exp(−θ>πσ)\n= θ> ((∑ σ′∈Σr πσ′ ) · (∑ σ∈Σm exp(−θ>πσ) )∑\nσ′∈Σr ∑ σ∈Σm exp(−θ>πσ) ) = θ>Eσ∼Σr [πσ] , (46)\nand furthermore\n1\nm · E(σ,σ′)∼D\n[ θ>πσ ] = 1 m · ∑ σ′∈Σr ∑ σ∈Σm exp(−θ>πσ) · θ>πσ∑ σ′∈Σr ∑ σ∈Σm exp(−θ>πσ)\n= 1 m · ∑ σ∈Σm exp(−θ>πσ) · θ>πσ∑\nσ∈Σm exp(−θ>πσ) = θ> ( 1 m · ∑ σ∈Σm exp(−θ>πσ) · πσ∑ σ∈Σm exp(−θ>πσ) ) = θ>∇θ 1\nm · logF rexp (S,θ,Σm)\n= θ>∇θF rlog (S,θ,Σm) . (47)\nAssembling eqs (46) and (47), we get from ineq. (45): Q ≤ rθ ∥∥∥∥∇θF rlog (S,θ,Σm)− Eσ∼Σr [ 1m · πσ ]∥∥∥∥ 2\n≤ rθ ( ‖∇θF rlog (S,θ,Σm) ‖2 + ∥∥∥∥Eσ∼Σr [ 1m · πσ ]∥∥∥∥\n2\n) ,\nas claimed."
    }, {
      "heading" : "10.3 Proof of Lemma 4",
      "text" : "Theorem 1 in ([22]) immediately yields\n1 n exp\n( −θ>T πj ) ≤ T∏ t=1 √ 1− r2t · w(T+1)j ,∀j ∈ [n] . (48)\nSince 1>wT+1 = 1, summing over j ∈ [n] yields:\nF rexp(S,θT ,U) ≤ T∏ t=1 √ 1− r2t\n≤ exp ( −1\n2 ∑ t r2t\n) .\nUsing the (WLA), this yields ineq. (12)."
    }, {
      "heading" : "10.4 Proof of Lemma 5",
      "text" : "Fix for short k = ι(t). We rewrite rt(wt) as a function of the examples:\nrt(wt) = 1\nπ∗k n∑ j=1 wtjπjk\n= 1\nπ∗k n∑ j=1 ∑ i:σji=yi wtjyixik\n= 1\nx∗k m∑ i=1 x∗k π∗k · ∑\nj:σji=yi\nwtj  yixik . (49) Define w̃ ∈ Pm such that\nw̃i . = 1 W̃ · x∗k π∗k · ∑\nj:σji=yi\nwtj ,∀i ∈ [m] , (50)\nwith\nW̃ . = x∗k π∗k · m∑ i=1 ∑ j:σji=yi wtj\n= x∗k π∗k · n∑ j=1 wtj |{i : σji = yi}| (51)\nthe normalization coefficient. Because wt ∈ Pn, x∗k > 0 and π∗k > 0, it comes that indeed w̃ ∈ Pm, and W̃ > 0 (unless Sr is reduced to the null rado). We thus have |rt(wt)| ≥ γ iff\n|rext (w̃)| ≥ γ\nW̃ . (52)\nThis proves the statement of the Lemma. Remark that\nx∗k π∗k ≤ W̃ ≤ x∗k(\nπ∗k maxj |{i:σji=yi}|\n) , (53)\nso if we assume the weak learning assumption holds for the examples, |rext (w̃)| ≥ γex > 0, then the weak learning assumption over rados always holds for\nγ = x∗k π∗k · γex , (54)\nand may holds for a value γ which can be as large as\nγ = x∗k( π∗k\nmaxj |{i:σji=yi}| ) · γex . (55) These two bounds are data dependent (but they depend on data only), and whenever they are significant outlier values for feature k, i.e. x∗k is achieved by few examples and all others have feature value of significantly smaller order, then the available γ can be significantly larger than γex. Compared to the cases where no such outliers would exist, we thus may expect significantly better results for RadoBoost."
    }, {
      "heading" : "10.5 Proof of Theorem 6",
      "text" : "To ease notations hereafter, we consider wlog that d = 1 and so j∗ = 1. We also drop index notation j∗ in related notations (so Σ β,j∗ m becomes Σ β m).\nWe let S and S′ denote two j-neighbors, so that S ≈j S′ holds and they differ by the value of one (boolean) feature. Algorithm DP-Feat selects uniformly at random the rados in sets\nΣβm(S) . = {σ ∈ Σm : πσ ∈ I(S)} , (56) Σβm(S ′) .= { σ ∈ Σm : πσ ∈ I(S′) } , (57)\nwith\nI(S) .= {−(m−m(+)) + β(m+ 1) ≤ z ≤ m(+)− β(m+ 1)} , (58) I(S′) .= {−(m−m(+)) + β(m+ 1) + ζ ≤ z ≤ m(+)− β(m+ 1) + ζ} , (59)\nsince m′(+) = m(+) + ζ for some ζ ∈ {−1, 0, 1}. To relate the sizes of these two sets, we first compute the size of {σ : πσ = r|S}, for r ∈ Z. Assuming first r ≥ 0, we have:\n|{σ : πσ = r|S}| = min{m(+)−r,m−m(+)}∑\ni=0\n( m(+)\ni+ r\n)( m−m(+)\ni\n) . (60)\nIf r < 0, then similarly:\n|{σ : πσ = r|S}| = min{m(+),m−m(+)+r}∑\ni=0\n( m(+)\ni )( m−m(+) i− r ) , (61)\nwhich is the same expression as (60) with the substitutions r 7→ −r, m(+) 7→ m−m(+), m−m(+) 7→ m(+), so we have only to analyse the case r ≥ 0. If m(+)−r > m−m(+), we have by Vandermonde identity:\n|{σ : πσ = r|S}| = m−m(+)∑ i=0 ( m(+) m(+)− i− r )( m−m(+) i ) = ( m\nm(+)− r\n) . (62)\nIf m(+)− r ≤ m−m(+), then it is not hard to show that Vandermonde identity still brings (62). We thus have\n|Σβm(S)| = m(+)−β(m+1)∑\nr=−(m−m(+))+β(m+1)\n( m\nm(+)− r\n)\n=\n( m\nβ(m+ 1)\n) + m(+)−β(m+1)∑ r=−(m−m(+))+β(m+1)+1 ( m m(+)− r )\n= m− β(m+ 1) + 1 β(m+ 1) · (\nm\nβ(m+ 1)− 1\n) + m(+)−β(m+1)∑ r=−(m−m(+))+β(m+1)+1 ( m m(+)− r )\n=\n( 1 β − 1 ) · (\nm\nβ(m+ 1)− 1\n) + m(+)−β(m+1)∑ r=−(m−m(+))+β(m+1)+1 ( m m(+)− r )\n≥ (\nm\nβ(m+ 1)− 1\n) + m(+)−β(m+1)∑ r=−(m−m(+))+β(m+1)+1 ( m m(+)− r )\n= m(+)−β(m+1)+1∑ r=−(m−m(+))+β(m+1)+1 ( m m(+)− r )\n= m(+)−β(m+1)+1∑ r=−(m−m(+))+β(m+1)+1 m(+) + 1− r m−m(+) + r · ( m (m(+) + 1)− r ) (63)\n≥ m(+)−β(m+1)+1∑\nr=−(m−m(+))+β(m+1)+1\nβ(m+ 1) m− β(m+ 1) + 1 · (\nm\n(m(+) + 1)− r\n) (64)\n=\n( 1 β − 1 )−1 m(+)−β(m+1)+1∑\nr=−(m−m(+))+β(m+1)+1\n( m\n(m(+) + 1)− r\n) (65)\n=\n( 1 β − 1 )−1 · |Σβm(S′)| (66)\nif ζ = 1, and\n|Σβm(S)| = m(+)−β(m+1)∑\nr=−(m−m(+))+β(m+1)\n( m\nm(+)− r\n)\n=\n( m\nβ(m+ 1)\n) + m(+)−β(m+1)−1∑ r=−(m−m(+))+β(m+1) ( m m(+)− r )\n= m− β(m+ 1) + 1 β(m+ 1) · (\nm\nβ(m+ 1)− 1\n) + m(+)−β(m+1)−1∑ r=−(m−m(+))+β(m+1) ( m m(+)− r )\n=\n( 1 β − 1 ) · (\nm\nβ(m+ 1)− 1\n) + m(+)−β(m+1)−1∑ r=−(m−m(+))+β(m+1) ( m m(+)− r )\n≥ (\nm\nβ(m+ 1)− 1\n) + m(+)−β(m+1)−1∑ r=−(m−m(+))+β(m+1) ( m m(+)− r )\n= m(+)−β(m+1)−1∑ r=−(m−m(+))+β(m+1)−1 ( m m(+)− r )\n≥ ( 1 β − 1 )−1 · |Σβm(S′)| (67)\nif ζ = −1. The last inequality follows from the same chain of inequalities as in eqs. (63 – 66). We now bound the ratio of probabilities for the rado being equal to r, for both sets:\nP σ∼Σβm(S) [πσ = r|S]\nP σ∼Σβm(S′) [πσ = r|S ′] = |Σβm(S′)| |Σβm(S)|\n· ( m m(+)−r )( m\nm(+)+ζ−r )\n≤ ( 1 β − 1 ) · ( m m(+)−r )( m m(+)+ζ−r )\n=\n( 1 β − 1 ) · (m(+) + ζ − r)!(m−m(+)− ζ + r)! (m(+)− r)!(m−m(+) + r)! (68)\n=\n( 1 β − 1 ) ·  m(+)+1−r m−m(+)+r if ζ = 1 1 if ζ = 0 m−m(+)+1+r\nm(+)−r if ζ = −1 ≤ ( 1 β − 1 )2 . (69)\nThe last inequality comes from eq. (58) which guarantees r ≥ −(m−m(+)) + β(m+ 1), and so m(+) + 1− r m−m(+) + r ≤ 1 β − 1 , (70)\nand furthermore eq. (58) also guarantees r ≤ m(+)− β(m+ 1), and so m−m(+) + 1 + r\nm(+)− r ≤ 1 β − 1 (71)\nas well. We finally get from ineq. (69):\nP σ∼Σβm(S) [πσ = r|S]\nP σ∼Σβm(S′) [πσ = r|S\n′] ≤ exp( ) , (72)\nwhich holds for any r ∈ Σβm(S) ∩ Σβm(S′). Notice however that the symmetric difference of these two sets is not empty. To finish the proof, we need to take into account this symmetric difference. This is the data-dependent step in DP-Feat which may leak information about one feature and disclose its content, through the use of eq. (58). To see this, if we assume that one possesses all the data but the unknown feature value for one person, and knows how rados are computed using DP-Feat, then by observing the output πσ,j∗ , he may guess the unknown value, as depicted by Figure 3. Let us denote A this event. When returning one rado from Σβm(.), if we consider without loss of generality a uniform distribution over examples, then, referring to the notations of Figure 3, we have:\nP[A] = P[A|S]P[S] + P[A|S′]P[S′] (73) < P[A|S] + P[A|S′] . (74)\nIf A occurs in S, then it is for r = m(+)− (m− β(m+ 1)) in Figure 3. We get from eq. (62): P[A|S] = ( m m−β(m+1) ) ∑m−β(m+1)\nr=β(m+1) ( m r ) = ( m β(m+1) ) ∑m−β(m+1)\nr=β(m+1) ( m r ) , (75) and we obtain following the same reasoning, using the fact that m(+) increases by one in S′,\nP[A|S′] = ( m β(m+1) ) ∑m−β(m+1)\nr=β(m+1) ( m r ) . (76) The probability of hitting the symmetric difference of Σβm(S) ∩ Σβm(S′) is taken into account considering δ = P[A] in the ( , δ)-differentially private release of one rado. We get:\nδ < 2 ( m β(m+1) ) ∑m−β(m+1)\nr=β(m+1) ( m r ) . (77) The interplay between and δ can be appreciated throughout the use of the following properties:\nβ(m+1)−1∑ r=0 ( m r ) ≤ 2m·H(u) , (78)(\nm\nm/2\n) <\n1√ m · 2m , (79)\nwe have used\nH(z) . = −z log2 z − (1− z) log2(1− z) ,\nu . = β − 1− β m .\nWe get\nδ < 2√ m · 1 1− 2m·(H(u)−1) (80)\nBecause H(u) is concave, it satisfies (fixing ′ .= /2 for short):\nH(u) ≤ H(β) + (u− β)H ′(β)\n= H(β)− 1− β m log2 1− β β\n= H(β)− (1− β) ′\nm\n= 1 log 2 · ( log(1 + exp( ′))− ( 1 + 1 m ) · ′ exp ′ 1 + exp ′ ) . = f( ′) . (81)\nWe have:\n1 1− 2m·(f( ′)−1) ∼0 1 2m2 log2(2) ′ +\n( 1\n2 − 1 4m2 log3(2)\n) +O( ′) . (82)\nSo, assuming ′ = o(1), there exists m′ > 0 and a constant K > 0 such that for any m > m′,\nδ < K · 1 m 5 2 . (83)\nFinally, we get that when = Ω(1/m), ( , δ)-differential privacy can be ensured on the delivery of n = 1 rado as long as · δ = O(m−5/2). Taking into account the fact that rados are generated independently and using Theorem 3.16 in [12] concludes the proof of Theorem 6 for arbitrary n.\nTo finish the proof, we remark that Σβm(.) 6= ∅. Indeed, since m ≥ 1, β < m/(m + 1); furthermore, as long as m > 2, provided we also have\n1 + 2β 1− 2β = O(m) ,\nwe shall have I(S) ∩ Z 6= ∅. This can easily be ensured if\n1\n+ = O(m) , (84)\ni.e., provided = o(1), = Ω(1/m)."
    }, {
      "heading" : "10.6 Proof of Theorem 7",
      "text" : "We keep the same notations as in the proof of Theorem 6. The Rademacher rejection sampling of σ has a probability to reject a single rado bounded by (a fraction of) the tail of the Binomial, as\nindeed\nPσ∼Σm [σ 6∈ Σβm|S] = 1\n2m · ∑ r<−(m−mk(+))+β(m+1)∨r>mk(+)−β(m+1) ( m m(+)− r )\n= 1 2m · −(m−mk(+))+β(m+1)−1∑\nr=−(m−mk(+))\n( m\nm(+)− r\n) + 1\n2m · m(+)∑ r=mk(+)−β(m+1)+1 ( m m(+)− r )\n= 1\n2m · m∑ r=m−β(m+1)+1 ( m r ) + 1 2m · β(m+1)−1∑ r=0 ( m r )\n= 2 · 1 2m · m∑ r=m−β(m+1)+1 ( m r )\n= 2 · 1 2m · m∑ r=(1−β)(m+1) m+ 1− r m+ 1 · ( m+ 1 r )\n≤ 2β · 1 2m · m∑ r=(1−β)(m+1) ( m+ 1 r )\n≤ 2β · 1 2m · m+1∑ r=(1−β)(m+1) ( m+ 1 r )\n= 4β · m+1∑\nr=(1−β)(m+1)\n( m+ 1\nr\n) · ( 1\n2\n)m+1−r · ( 1\n2 )r ≤ 4β exp (−(m+ 1) ·DBE(1− β‖1/2)) , (85)27\nwhere DBE is the bit-entropy divergence ([3]):\nDBE(p‖q) = p log p q + (1− p) log 1− p 1− q . (86)\nThe last equation follows e.g. from Theorem 2 in ([1]). So the probability p that there exists a rado, among the n generated, that was rejected at least Tr times for some Tr ≥ 1 satisfies\np ≤ 4nβ ∞∑ t=Tr exp (−(m+ 1) · t ·DBE(1− β‖1/2))\n= 4nβ · exp (−(m+ 1) · Tr ·DBE(1− β‖1/2)) · ∞∑ t=0 exp (−(m+ 1) · t ·DBE(1− β‖1/2))(87)\nWe now use the facts that (i) m ≥ (1 + 2β)/(1 − 2β) (Step 2 in Algorithm DP-Feat), and (ii) function\nf(z) . = 2\n1− 2z · (log(2) + (1− z) log(1− z) + z log z) (88)\nis convex over [0, 1/2) and has limit tangent 1− 2z in z = 1/2, so\nexp (−(m+ 1) ·DBE(1− β‖1/2)) ≤ exp ( − 2 1− 2β · (log(2) + (1− β) log(1− β) + β log β) )\n≤ exp(2β − 1) (< 1) ,\nand it comes\n∞∑ t=0 exp (−(m+ 1) · t ·DBE(1− β‖1/2)) ≤ 1 1− exp(2β − 1) , (89)\nand so\np ≤ 4nβ 1− exp(2β − 1) · exp (−(m+ 1) · Tr ·DBE(1− β‖1/2)) (90)\nSo, if n, β,η are such that\nn ≤ η(1− exp(2β − 1)) 4β , (91)\nthen there is probability ≥ 1 − η that no rado was rejected. Otherwise, with probability ≥ 1 − η, each rado among the n was rejected no more than\nT ∗r = ⌈\n1\nmDBE(1− β‖1/2) log\n4βn\nη(1− exp(2β − 1))\n⌉ (92)\ntimes. There remains to multiply this bound by the number of rados to get an upperbound on the number of iterations of Rademacher rejection sampling, and we obtain eq. (17). This finishes the proof of Theorem 7.\nRemarks: the actual dependence of eq. (92) on β is such that unless is extremely close to 01, in which case the requirement on differential privacy is the strongest, T ∗r does not actually blow up. To see this, let us define\nf(β) . = 1\nDBE(1− β‖1/2) log\n4β\n1− exp(2β − 1) . (93)\nFigure 4 displays f(β) over different ranges. One sees that when = 0.1, provided m/ log n is in the order of thousands and n e, then T ∗r is in fact of the order log(1/η), which may be quite small indeed."
    }, {
      "heading" : "10.7 Proof of Theorem 8",
      "text" : "Let us first remark that the DP-protection of vector edges by computing noisified example set\nS+ . = {(x+i , yi) . = (xi + x r i , yi), i ∈ [m]} , (94)\nwhere xri ∼ N(0, ς2I), is equivalent to noisifying edges because label y ∈ {−1, 1} and the pdf of the Gaussian mechanism is invariant by multiplication by y.\nThe key quantity to prove the Theorem is, for any noisified rado π+j . = (1/2) ·∑i (σji + yi)x+i , the support mj . = |{i : σji = yi}| of the rado. We also renormalize the leveraging coefficient in RadoBoost, replacing eq. (10) in RadoBoost pseudocode by:\nαt ← 1\n2κπ∗ι(t) log 1 + rt 1− rt , (95)\nfor some fixed κ ≥ 1.\n1Recall that β = 1/(1 + exp( /2)) in Step 1 of Algorithm DP-Feat.\nWe now embark in the proof of Theorem 8. Lemma 2 in ([22]) yields\nexp ( −θ>T πj ) = exp ( −θ>T π+j ) · exp\n( 1\n2 · θ>T ∑ i (σji + yi)x r i\n)\n≤ (\nT∏ t=1 √ 1− r2t · nw(T+1)j\n) 1 κ · exp ( 1\n2 · θ>T ∑ i (σji + yi)x r i\n) ,∀j ∈ [n] .(96)\nAveraging over j ∈ [n] yields:\nF rexp(S,θT ,U) ≤ ( T∏ t=1 √ 1− r2t ) 1 κ · n∑ j=1 n 1 κ −1w 1 κ (T+1)j · exp ( 1 2 · θ>T ∑ i (σji + yi)x r i )\n≤ exp ( − 1\n2κ ∑ t r2t ) ︸ ︷︷ ︸\nA\n· n∑ j=1\nw̃(T+1)j · exp ( 1\n2 · θ>T ∑ i (σji + yi)x r i ) ︸ ︷︷ ︸\nB\n, (97)\nwith w̃(T+1)j . = n 1 κ −1w\n1 κ\n(T+1)j . The right-hand side of ineq. (97) multiplies two separate quantities, A which quantifies the performances of θT in RadoBoost on the set of noisy rados on which it was trained, and B which is an expectation, computed over wT , of the agreements between θT and the noisy part of the rados. When rados are noise-free and κ ≥ 1, we have xri = 0, ∀i and\nn∑ j=1 w̃(T+1)j = n 1 κ · 1 n n∑ j=1 w 1 κ (T+1)j\n≤ n 1κ ·  1 n n∑ j=1 w(T+1)j  1κ = n 1 κ · n− 1k = 1 (98)\nbecause of the concavity of x1/κ, and so we return to the noise-free rado boosting bound with “penalty 1/κ” for renormalizing the leveraging coefficients in RadoBoost (this proves ineq. (17)). Assuming θT output by RadoBoost, we obtain, ∀S,U such that support of all n rados is of the same size, i.e. mj = m∗,∀j ∈ [n],\nF rlog(S,θT ,U)\n= log(2) + 1\nm logF rexp(S,θT ,U)\n≤ log(2)− 1 2κm ∑ t r2t + 1 m · log n∑ j=1\nw̃(T+1)j · exp ( 1\n2 · θ>T ∑ i (σji + yi)x r i\n)\n≤ log(2)− 1 2κm ∑ t r2t + m∗ m · log n∑ j=1\nw̃(T+1)j · exp ( 1\n2m∗ · θ>T ∑ i (σji + yi)x r i\n)\n= log(2)− 1 2κm ∑ t\nr2t︸ ︷︷ ︸ . =C\n+ m∗ m · log n∑ j=1\nw̃(T+1)j · exp (\nς√ m∗ · θ>T ∑ i σji + yi 2ς √ m∗ xri ) ︸ ︷︷ ︸\n. =D\n. (99)\nWe now study a sufficient condition for C − D to be Ω((1/m)∑t r2t ) with high probability over the noise mechanism, thereby ensuring a convergence rate over non-noisy rados that shall comply with the noise-free bounds of ineq. (13), up to the hidden factors. This shall be achieved through several Lemmata.\nLemma 14 With probability ≥ 1− τ over the noise mechanism we shall have:∥∥∥∥∥∑ i σji + yi 2ς √ m∗ xri ∥∥∥∥∥ 2 ≤ √ 2 log (n τ ) , ∀j ∈ [n] . (100)\nProof The Sudakov-Tsirelson inequality ([5], Theorem 5.6) states that if x ∼ N(0, Id) and f(x) : Rd → R is L-Lipschitz, then\nP [f(x)− E[f(x)] ≥ t] ≤ exp ( − t 2\n2L2\n) . (101)\nSince function f(x) . = ‖x‖2 is 1-Lipschitz by the triangle inequality and ∑\ni σji+yi 2ς √ m∗ xri is a standard\nGaussian random because the xri are sampled independently, ineq. (101) yields that we shall have simultaneously over the randomized part of the rados, with probability ≥ 1− τ,∥∥∥∥∥∑\ni\nσji + yi 2ς √ m∗ xri ∥∥∥∥∥ 2 ≤ √ 2 log (n τ ) ,∀j ∈ [n],\nwhich proves the Lemma.\nLemma 15 Assume θT ∈ B(0, rθ) for some rθ > 0. Then with probability ≥ 1− τ over the noise mechanism we shall have\nD ≤ ςrθ m\n√ 2m∗ log (n τ ) . (102)\nProof We use Lemma 14. Cauchy-Schwartz inequality implies\nθ>T ∑ i σji + yi 2ς √ m∗ xri ≤ ‖θT ‖2 · ∥∥∥∥∥∑ i σji + yi 2ς √ m∗ xri ∥∥∥∥∥ 2\n≤ rθ √ 2 log (n τ ) ,∀j ∈ [n] . (103)\nWe thus get in this case\nD ≤ ςrθ m\n√ 2m∗ log (n τ ) + m∗ m · log n∑ j=1 w̃(T+1)j\n≤ ςrθ m\n√ 2m∗ log (n τ ) . (104)\nbecause of ineq. (98).\nWe now prove a specific rθ > 0 which makes use of the concentration of the randomized part of rados in Lemma 14.\nLemma 16 Suppose there exists µ > µ′ > 0 such that it simultaneously holds:\nµ ≤ mink maxj |πjk| m∗ , (105)\nµ′ ≤ µ− ς √ 1 m∗ log (n τ ) , (106)\nwhere πjk = (1/2) ∑ i(σji + yi)xik is the non-noisy part of rado π + j . Assume the existence of ρ > 0 such that the weak learner wfi in RadoBoost is λp-prudential for\nλp = 1− 2√\n1− ρκµ′m∗ . (107)\nThen probability ≥ 1− τ over the noise mechanism we shall have ‖θT ‖2 ≤ (1− ρ) ∑ t r2t . (108)\nRemarks: notice that ineq. (105) is equivalent to saying that each coordinate k has at east one non-zero entry in the noise-free part of the rados. Unless coordinate k is zero for all examples — in which case we can just discard this feature —, this assumption is easy to satisfy. Proof We have\n‖θT ‖2 − ∑ t r2t = ∑ t\n1\n4κ2π2∗ι(t) log2 1 + rt 1− rt − r2t . (109)\nAssuming the existence of z > 0 such that 2κπ∗ι(t) ≥ z,∀t, and using the fact that\nlog2 1 + x 1− x ≤ 4x2 (1− |x|)2 , ∀x ∈ (0, 1) , (110)\nwe shall have ∑ t\n1\n4κ2π2∗ι(t) log2 1 + rt 1− rt − r2t ≤ ∑ t 1 z2 log2 1 + rt 1− rt − r2t\n≤ ∑ t 1 z2 · 4r 2 t (1− |rt|)2 − r2t\n= ∑ t r2t ( 4− z2(1− |rt|)2 z2(1− |rt|)2 ) ≤ −ρ\n∑ t r2t , (111)\nas long as\n|rt| ≤ 1− 2√\n1− ρz , ∀t , (112)\nwhere ρ ∈ (0, 1). Since π∗ι(t) ≥ mink maxj |π+jk|, we can fix z∗ = 2κmink maxk |π+jk|, but recall that π+jk sums a random Gaussian part and a non random part. Ineq. (100) tells us that with high probability, the magnitude of the random part will satisfy∑\ni\n(σji + yi)x r i ≤ ς √ 2m∗ log (n τ ) ,∀j ∈ [n] . (113)\nThus, we shall have in this case, using ineqs. (105, 106) and given Lemma 14:\nmin k\nmax |π+jk| ≥ ( µ− ς √ 1 m∗ log (n τ )) ·m∗\n≥ µ′m∗ ,\nand we get the statement of the Lemma.\nWe now return to ineq. (99), and use Lemmata 14, 15 and 16, and obtain that with probability ≥ 1− τ, a sufficiently prudential weak learner shall imply:\nF rlog(S,θT ,U)\n≤ log(2)− 1 2κm ∑ t r2t + m∗ m · log n∑ j=1\nw̃(T+1)j · exp (\nς√ m∗ · θ>T ∑ i σji + yi 2ς √ m∗ xri\n)\n≤ log(2)− 1 m · ( 1 2κ − (1− ρ) · ς √ 2m∗ log (n τ )) ︸ ︷︷ ︸\n. =E\n∑ t r2t . (114)\nWe want E ≥ 1/(4κ). Equivalently, we want\n1− ρ ≤ 1 4κς √ 2m∗ log ( n τ ) , (115) and for the prudential weak learner to exist, we also need\n1− ρ > 4 κ2µ′2m2∗ . (116)\nAssuming ineqs (105) and (106), we thus get that if\nκ ≥ 4ς µ′2m 3 2∗\n√ 2 log (n τ ) , (117)\nthen there exists a prudential weak learner for which, with probability ≥ 1 − τ over the noise mechanism, we shall have after T rounds of boosting of RadoBoost, using the prudential weak learner and renormalizing the leveraging coefficients by κ as in (95),\nF rlog(S,θT ,U) ≤ log(2)− 1\n4κm ∑ t r2t , (118)\nwhich proves Theorem 8. Notice that the constraint κ ≥ 1 can easily be enforced by picking µ′ sufficiently small.\nRemarks: we finish by emphasizing the fact that ineq. (19) is computed over non-noisy rados. It is not hard to see that ineqs (105) and (106) shall be all the easier to meet as m∗ is large compared to log n, log(1/τ) and ς. So, provided rados have a sufficiently large support, the convergence rate of the logistic rado-risk of RadoBoost over the non noisy rados may compete, up to a small constant factor, with the one that would be achieved by training RadoBoost over non-noisy rados."
    }, {
      "heading" : "10.8 Proof of Lemma 10",
      "text" : "Consider first that m ≥ 2d. A simple proof of the Lemma consists in considering the largest d-dim square, of edge length ` = 2R/ √ d, shown with thick dashed line in Figure 5. We then pack this square with m+1 spheres, as shown. Since the edge length is covered by dlog(m)/ log(d)e diameters of these spheres, we obtain that the radius r of each such sphere satisfies:\nr = 2R√\nd · d log(m+1)log d e\n≥ R log d 2 √ d log(m+ 1) , (119)\nbecause m ≥ 2d > d. Because of the construction, at least one of these spheres does not contain an edge vector from C(E) and is thus empty. Consider one such empty sphere whose center e∗ is the closest to 0, as shown in Figure 5, and consider one adjacent sphere, located no farther2, with one\n2If no such sphere exists, we can pick e∗ = 0, the center of a sphere B(0, r) which contains no example from S. In this case, there is no need to remove any example from S: the proof still holds by adding example (0, y) to S, to\nedge vector e = yx from C(E) inside, with (x, y) ∈ S, where S generates Π. We create S′ out of S by replacing (x, y) by two examples, (ye∗, y) and (e− ye∗, y). It is worthwhile remarking that\nC(E′) ⊂ B(0, R) (120)\nby construction, and furthermore any rado that can be created from S can also be created from S′. Hence, any Π defined over S can also be obtained from S′. There remains to remark that, by construction, e∗ is distant from every edge vector of S from at least r, and so:\nDH(E,E ′) = Ω ( R log d√ d logm ) ; (121)\nthis proves Lemma 10 when m ≥ 2d. When m < 2d, the construction of Figure 5 can still be done but with larger balls, for which\nr = R\n2 √ d . (122)\nPicking as e∗ the center of any of these empty balls, we obtain\nDH(E,E ′) ≥ R\n2 √ d , (123)\nas claimed."
    }, {
      "heading" : "10.9 Proof of Lemma 11",
      "text" : "We make a reduction from the X3C3 ([25]) problem whose instance is a set S . = {s1, s2, ..., sn} and a set of 3-subsets of S, C . = {c1, c2, ..., cd}, and an integer m. Each element of S belongs to exactly three subsets of C. The question is whether there exists a cover of S using at most m elements from C. The reduction is the following:\n• to each feature corresponds an element of C;\n• to each element sj of S we associate a boolean rado πj which is 1 in coordinate k iff sj ∈ ck, and zero otherwise:\nπj = 1{k:sj∈ck} . (124)\n(1I is “1” in coordinate ik for k ∈ I, and zero everywhere else)\n• The number of examples is m;\n• Parameters r and ` are fixed as follows:\n– if p 6= 0, the value of r is 21/p. We also fix ` = -machine, where -machine is the smallest such that 1− < 1 in machine encoding;\n– else if p = 0, then r = 2 and ` = 1;\ncreate S′.\nLet us number the constraints of Sparse-Approximation, so that we want:\n‖xi‖p ≤ ` , ∀i ∈ [m] , (Sparse examples) (125) ‖πj − πσj‖p ≤ r , ∀j ∈ [n] . (Rado approximation) (126)\nSuppose there exists a solution to X3C3 with m subsets of C, C∗ .= {c∗k1 , c∗k2 , ..., c∗km}. Create m positive examples (yi = 1) whose observation is xi . = 1{ki} (the all-0 vector with only one “1” in coordinate ki). Clearly, the sparsity constraint on examples (125) is satisfied. We craft the rados following n Rademacher assignations, where σi is +1 only for xki , and −1 otherwise. Notice that\nπj − πσj = 1{k:sj∈ck} − 1{ki,sj∈c∗ki} (127) = 1{k:sj∈ck∧ck 6∈C∗} . (128)\nIt comes\n‖πj − πσj‖p ≤ 21/p . = r , ∀j ∈ [n] , (129)\nif p 6= 0, and\n‖πj − πσj‖0 ≤ 2 . = r , ∀j ∈ [n] (130)\notherwise, since each element of S belongs to three sets in C. Therefore, there exists a solution to Sparse-Approximation.\nNow, suppose there exists a solution to Sparse-Approximation. Remark that we can remove wlog any example having null observation as this does not change the feasibility of the solution. Consider the case where p 6= 0. The Rado approximation constraint (126) of Sparse-Approximation makes that the following property (P) is satisfied:\n(P) for each j ∈ [n], there exists i ∈ [m] and feature k ∈ [d] such that πσj and example xi have their coordinate k non-zero, and furthermore the coordinate in xi has magnitude exactly : it cannot be less otherwise (126) is violated, and it cannot be more otherwise (125) is violated. Hence, each of these xi have exactly one non-zero coordinate.\nBecause property (P) holds for all rados, we see that the corresponding indexes in the xi (the corresponding non-zero coordinates for features for which (P) holds; there cannot be more than m) define a solution to X3C3. The case p = 0 is easier as (125) enforces the number of non-zero coordinates in each observation to be at most one, and therefore exactly one since there is no null observation.\nWe finally note that Sparse-Approximation trivially belongs to NP, so it is actually NP-Complete."
    }, {
      "heading" : "10.10 Proof of Lemma 12",
      "text" : "We make the same reduction as for Sparse-Approximation. The set of examples S consists of all canonical basis vectors, associated to positive class."
    }, {
      "heading" : "11 Appendix — Experiments",
      "text" : ""
    }, {
      "heading" : "11.1 Supplementary experiments to Table 1",
      "text" : "Table 3 is obtained under the same experimental setting as that of Table 1, with an important modification in how the normalized edge is computed. More specifically, the computation of rt in\nStep 2.2 of RadoBoost (see (9)) is completed by the following step:\nrt ← sign(rt) ·max{0.1, |rt|} (131)\nThe same modification is also carried out in AdaBoost ([27]) (Corollary 1). This aims to prevent the fact that domains with outlier feature values could trick AdaBoost in picking the wrong sign for αt for a large number of iterations, due to values of rt with a very small magnitude (but with the wrong sign). Experiments display that this corrects AdaBoost’s bad results on Twitter, but on other domains like Fertility, Haberman, Sonar, Abalone, the change happens to give worse results for AdaBoost and/or AdaBoost(n). RadoBoost’s results, on the other hand, tend to improve with sparse exceptions."
    }, {
      "heading" : "11.2 Supplementary experiments to Section 5 — I / III",
      "text" : "Tables 4, 5, 6, 7 present results comparing AdaBoost, RadoBoost with random rados and RadoBoost with fixed support size rados (m∗). Unless otherwise stated in Tables, the following experimental setup holds:\n• RadoBoost is trained with n = min{1000, train fold size/2} rados;\n• AdaBoost is trained using the complete training fold;\n• for each standard deviation σ, we generate 10 noisy domains; each is then processed following 10 folds stratified cross-validation. Thus, each dot on the colored curves is the average of ten experiments;\n• RadoBoost is trained with two types of rados: random rados as in Section 4 — this gives the grey dashed curves —, or rados with fixed support m∗ (noted s on the plots) as in Subsection 5.2 — this gives the colored curves —;"
    }, {
      "heading" : "11.3 Supplementary experiments to Section 5 — II / III",
      "text" : "Tables 8 and 9 compare RadoBoost trained with rados of fixed support and using a “prudential” weak learner (which picks the median feature according to |rt|), to RadoBoost trained with plain random rados and using the “strongest” possible weak learner which picks the best feature according to |rt|."
    }, {
      "heading" : "11.4 Supplementary experiments to Section 5 — III / III",
      "text" : "Tables 10 and 11 compare two different rado generation mechanisms with respect to RadoBoost: the random generation of arbitrary rados (Section 4), and the random generation of rados with fixed support (Subsection 5.2). In both Tables, the weak learner is always the same (contrary to Tables 8 and 9), i.e. the “strong” weak learner that picks the best feature according to |rt|, at each iteration."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : "<lb>The minimization of the logistic loss is a popular approach to batch supervised learning. Our<lb>paper starts from the surprising observation that, when fitting linear (or kernelized) classifiers,<lb>the minimization of the logistic loss is equivalent to the minimization of an exponential rado-loss<lb>computed (i) over transformed data that we call Rademacher observations (rados), and (ii) over<lb>the same classifier as the one of the logistic loss. Thus, a classifier learnt from rados can be<lb>directly used to classify observations. We provide a learning algorithm over rados with boosting-<lb>compliant convergence rates on the logistic loss (computed over examples). Experiments on<lb>domains with up to millions of examples, backed up by theoretical arguments, display that<lb>learning over a small set of random rados can challenge the state of the art that learns over<lb>the complete set of examples. We show that rados comply with various privacy requirements<lb>that make them good candidates for machine learning in a privacy framework. We give several<lb>algebraic, geometric and computational hardness results on reconstructing examples from rados.<lb>We also show how it is possible to craft, and efficiently learn from, rados in a differential privacy<lb>framework. Tests reveal that learning from differentially private rados can compete with learning<lb>from random rados, and hence with batch learning from examples, achieving non-trivial privacy<lb>vs accuracy tradeoffs.",
    "creator" : "LaTeX with hyperref package"
  }
}