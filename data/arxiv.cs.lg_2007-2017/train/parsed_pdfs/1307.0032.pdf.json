{
  "name" : "1307.0032.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Memory Limited, Streaming PCA",
    "authors" : [ "Ioannis Mitliagkas", "Constantine Caramanis", "Prateek Jain" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n30 7.\n00 32\nv1 [\nst at\n.M L\n] 2"
    }, {
      "heading" : "1 Introduction",
      "text" : "Principal component analysis is a fundamental tool for dimensionality reduction, clustering, classification, and many more learning tasks. It is a basic preprocessing step for learning, recognition, and estimation procedures. The core computational element of PCA is performing a (partial) singular value decomposition, and much work over the last half century has\n∗Email: {ioannis,constantine}@utexas.edu;prajain@microsoft.com\nfocused on efficient algorithms (e.g., [7] and references therein) and hence on computational complexity.\nThe recent focus on understanding high-dimensional data, where the dimensionality of the data scales together with the number of available sample points, has led to an exploration of the sample complexity of covariance estimation. This direction was largely influenced by Johnstone’s spiked covariance model, where data samples are drawn from a distribution whose (population) covariance is a low-rank perturbation of the identity matrix [11]. Work initiated there, and also work done in [19] (and references therein) has explored the power of batch PCA in the p-dimensional setting with sub-Gaussian noise, and demonstrated that the singular value decomposition (SVD) of the empirical covariance matrix succeeds in recovering the principal components (extreme eigenvectors of the population covariance) with high probability, given n = O(p) samples.\nThis paper brings the focus on another critical quantity: memory/storage. This is relevant in the so-called streaming data model, where the samples xt ∈ Rp are collected sequentially, and unless we store them, they are irretrievably gone.1 The only currently available algorithms with provable sample complexity guarantees either store all n = O(p) samples (note that for more than a single pass over the data, the samples must all be stored) or explicitly form the empirical p× p (typically dense) covariance matrix. Either case requires at least O(p2) storage. Despite the availability of massive local and distributed storage systems, for high-dimensional applications (e.g., where data points are high resolution photographs, biometrics, video, etc.), p could be on the order of 1010 − 1012, making O(p2) prohibitive, if not in fact impossible to manage. Indeed, at multiple computing scales, manipulating vectors of length O(p) is possible, when storage of O(p2) is not. A typical desktop may have 10-20 GB of RAM, but will not have more than a few TB of total storage. A modern smart-phone may have as much as a GB of RAM, but has a few GB, not TB, of storage.\nWe consider the streaming data setting, where data points are generated sequentially, and are never stored. In the setting of the so-called spiked covariance model (and natural generalizations) we show that a simple algorithm requiring O(kp) storage – the best possible – performs as well as batch algorithms (namely, SVD on the empirical covariance matrix), with sample complexity O(p log p). To the best of our knowledge, this is the only algorithm with both storage complexity and sample complexity guarantees. We discuss the connection to past work in more detail in Section 2. We introduce the model with all related details in Section 3, and present the solution to the rank 1 case, the rank k case, and the perturbedrank-k case in Sections 4.1, 4.2 and 4.3, respectively. In Section 5 we provide simulations that not only confirm the theoretical results, but demonstrate that our algorithm works well outside the assumptions of our main theorems."
    }, {
      "heading" : "2 Related Work",
      "text" : "Memory- and computation-efficient algorithms that operate on streaming data are plentiful in the literature and many seem to do well in practice. However, there is no algorithm that provably recovers the principal components in the same noise and sample-complexity regime as the batch PCA algorithm does and maintains a provably light memory footprint. Because\n1This is similar to what is sometimes referred to as the single pass model.\nof the practical relevance, there has been renewed interest recently in this problem, and the fact that this is an important unresolved issue has been pointed out in numerous places, e.g., [21, 1].\nA large body of work has focused on the non-statistical data paradigm that deals with a fixed pool of samples. This includes work on online PCA and low-rank matrix approximation in the streaming scenario, including sketching and dimensionality-reduction based techniques.\nOnline-PCA for regret minimization has been considered in several papers, most recently in [21], where the multiplicative weights approach is adapted for this problem (now experts correspond to subspaces). The goal there is to control the regret, improving on the natural follow-the-leader algorithm that performs batch-PCA at each step. However, the algorithm can require O(p2) memory, in order to store the multiplicative weights. A memory-light variant described in [1] typically requires much less memory, but there are no guarantees for this, and moreover, for certain problem instances, its memory requirement is on the order of p2.\nSub-sampling, dimensionality-reduction and sketching form another family of low-complexity and low-memory techniques, see, e.g., [5, 13, 8]. These save on memory and computation by performing SVD on the resulting smaller matrix. The results in this line of work provide worst-case guarantees over the pool of data, and typically require a rapidly decaying spectrum (which we do not have in our setting) to produce good bounds. More fundamentally, these approaches are not appropriate for data coming from a statistical model such as the spiked covariance model. It is clear that subsampling approaches, for instance, simply correspond to discarding most of the data, and for fundamental sample complexity reasons, cannot work. Sketching produces a similar effect: each column of the sketch is a random (+/−) sum of the data points. If the data points are, e.g., independent Gaussian vectors, then so will each element of the sketch, and thus this approach again runs against fundamental sample complexity constraints. Indeed, it is straightforward to check that the guarantees presented in ([5, 8]) are not strong enough to guarantee recovery of the spike. This is not because the results are weak; it is because they geared towards worst-case bounds.\nAlgorithms focused on sequential SVD (e.g., [4, 3], [6],[12] and more recently [2, 9]) seek to have the best subspace estimate at every time (i.e., each time a new data sample arrives) but without performing full-blown SVD at each step. While these algorithms indeed reduce both the computational and memory burden of batch-PCA, there are no rigorous guarantees on the quality of the principal components or on the statistical performance of these methods.\nIn a Bayesian mindset, some researchers have come up with expectation maximization approaches [16, 18], that can be used in an incremental fashion. The finite sample behavior is not known.\nStochastic-approximation-based algorithms along the lines of [15] are also quite popular, because of their low computational and memory complexity, and excellent performance in practice. They go under a variety of names, including Incremental PCA (though the term Incremental has been used in the online setting as well [10]), Hebbian learning, and stochastic power method [1]. The basic algorithms are some version of the following: upon receiving data point xt at time t, update the estimate of the top k principal components via:\nU (t+1) = Proj(U (t) + ηtxtx ⊤ t U (t)), (1)\nwhere Proj(·) denotes the “projection” that takes the SVD of the argument, and sets the top k singular values to 1 and the rest to zero (see [1] for further discussion).\nWhile empirically these algorithms perform well, to the best of our knowledge - and efforts - there does not exist any rigorous finite sample guarantee for these algorithms. The analytical challenge seems to be the high variance at each step, which makes direct analysis difficult.\nIn summary, while much work has focused on memory-constrained PCA, there has as of yet been no work that simultaneously provides sample complexity guarantees competitive with batch algorithms, and also memory/storage complexity guarantees close to the minimal requirement of O(kp) – the memory required to store only the output. We present an algorithm that provably does both."
    }, {
      "heading" : "3 Problem Formulation and Notation",
      "text" : "We consider a streaming model, where at each time step t, we receive a point xt ∈ Rp. Furthermore, any vector that is not explicitly stored can never be revisited. Now, our goal is to compute the top k principal components of the data: the k-dimensional subspace that offers the best squared-error estimate for the points. We assume a probabilistic generative model, from which the data is sampled at each step t. Specifically, we assume,\nxt = Azt +wt, (2)\nwhere A ∈ Rp×k is a fixed matrix, zt ∈ Rk×1 is a multivariate normal random variable, i.e.,\nzt ∼ N (0k×1, Ik×k),\nand vector wt ∈ Rp×1 is the “noise” vector and is also sampled from a multivariate normal distribution, i.e., wt ∼ N (0p×1, σ2Ip×p). Furthermore, we assume that all 2n random vectors (zt,wt, ∀1 ≤ t ≤ n) are mutually independent.\nIn this regime, it is well-known that batch-PCA is asymptotically consistent (hence recovering A up to unitary transformations) with number of samples scaling as n = O(p) [20]. It is interesting to note that in this high-dimensional regime, the signal-to-noise ratio quickly approaches zero, as the signal, or “elongation” of the major axis, ‖Az‖2, is O(1), while the noise magnitude, ‖w‖2, scales as O( √ p). The central goal of this paper is to provide finite sample guarantees for a streaming algorithm that requires memory no more than O(kp) and matches the consistency results of batch PCA in the sampling regime n = O(p) (possibly with additional log factors, or factors depending on σ and k).\nWe denote matrices by capital letters (e.g. A) and vectors by lower-case bold-face letters (x). ‖x‖q denotes the ℓq norm of x; ‖x‖ denotes the ℓ2 norm of x. ‖A‖ or ‖A‖2 denotes the spectral norm of A while ‖A‖F denotes the Frobenius norm of A. Without loss of generality (WLOG), we assume that: ‖A‖2 = 1, where ‖A‖2 = max‖x‖2=1 ‖Ax‖2 denotes the spectral norm of A. Finally, we write 〈a,b〉 = a⊤b for the inner product between a, b. In proofs the constant C is used loosely and its value may vary from line to line.\nAlgorithm 1 Block-Stochastic Power Method Block-Stochastic Orthogonal Iteration input {x1, . . . ,xn}, Block size: B 1: q0 ∼ N (0, Ip×p) (Initialization) H i ∼ N (0, Ip×p), 1 ≤ i ≤ k (Initialization) 2: q0 ← q0/‖q0‖2 H ← Q0R0 (QR-decomposition) 3: for τ = 0, . . . , n/B − 1 do 4: sτ+1 ← 0 Sτ+1 ← 0 5: for t = Bτ + 1, . . . , B(τ + 1) do 6: sτ+1 ← sτ+1 + 1B 〈qτ ,xt〉xt Sτ+1 ← Sτ+1 + 1Bxtx⊤t Qτ 7: end for 8: qτ+1 ← sτ+1/‖sτ+1‖2 Sτ+1 = Qτ+1Rτ+1 (QR-decomposition) 9: end for output"
    }, {
      "heading" : "4 Algorithm and Guarantees",
      "text" : "In this section, we present our proposed algorithm and its finite sample analysis. It is a block-wise stochastic variant of the classical power-method. Stochastic versions of the power method are already popular in the literature and are known to have good empirical performance; see [1] for a nice review of such methods. However, the main impediment to the analysis of such stochastic algorithms (as in (1)) is the potentially large variance of each step, due primarily to the high-dimensional regime we consider, and the vanishing SNR.\nThis motivated us to consider a modified stochastic power method algorithm, that has a variance reduction step built in. At a high level, our method updates only once in a “block” and within one block we average out noise to reduce the variance.\nBelow, we first illustrate the main ideas of our method as well as our sample complexity proof for the simpler rank-1 case. The rank-1 and rank-k algorithms are so similar, that we present them in the same panel. We provide the rank-k analysis in Section 4.2. We note that, while our algorithm describes {x1, . . . ,xn} as “input,” we mean this in the streaming sense: the data are no-where stored, and can never be revisited unless the algorithm explicitly stores them."
    }, {
      "heading" : "4.1 Rank-One Case",
      "text" : "We first consider the rank-1 case for which each sample xt is generated using: xt = uzt +wt where u ∈ Rp is the principal component that we wish to recover. Our algorithm is a block-wise method where all the n samples are divided in n/B blocks (for simplicity we assume that n/B is an integer). In the (τ + 1)-st block, we compute\nsτ+1 =\n\n\n1\nB\nB(τ+1) ∑\nt=Bτ+1\nxtx ⊤ t\n\nqτ . (3)\nThen, the iterate qτ is updated using qτ+1 = sτ+1/‖sτ+1‖2. Note that, sτ+1 can be easily computed in an online manner where O(p) operations are required per step. Furthermore, storage requirements are also linear in p."
    }, {
      "heading" : "4.1.1 Analysis",
      "text" : "We now present the sample complexity analysis of our proposed method (Algorithm 1). We show that, using O(σ4p log(p)/ǫ2) samples, Algorithm 1 obtains a solution qT of accuracy ǫ, i.e. ‖qT − u‖2 ≤ ǫ.\nTheorem 1. Denote the data stream by x1, . . . ,xn, where xt ∈ Rp, ∀t is generated by (2). Set the total number of iterations T = Ω( log(p/ǫ)\nlog((σ2+.75)/(σ2+.5)) ) and the block size B =\nΩ( (1+3(σ+σ2)\n√ p)2 log(T )\nǫ2 ). Then, with probability 0.99, ‖qT − u‖2 ≤ ǫ, where qT is the T -th\niterate of Algorithm 1. That is, Algorithm 1 obtains an ǫ-accurate solution with number of samples (n) given by:\nn = Ω̃\n( (1 + 3(σ + σ2) √ p)2 log(p/ǫ)\nǫ2 log((σ2 + .75)/(σ2 + .5))\n)\n.\nNote that in the total sample complexity, we use the notation Ω̃(·) to suppress the extra log(T ) factor for clarity of exposition, as T already appears in the expression linearly.\nProof. The proof decomposes the current iterate into the component of the current iterate, qτ , in the direction of the true principal component (the spike) u, and the perpendicular component, showing that the former eventually dominates. Doing so hinges on three key components: (a) for large enough B, the empirical covariance matrix Fτ+1 = 1 B ∑B(τ+1) t=Bτ+1 xtx ⊤ t is close to the true covariance matrix M = uu⊤ + σ2I, i.e., ‖Fτ+1 − M‖2 is small. In the process, we obtain “tighter” bounds for ‖u⊤(Fτ+1 −M)u‖ for fixed u; (b) with probability 0.99 (or any other constant probability), the initial point q0 has a component of at least O(1/ √ p) magnitude along the true direction u; (c) after τ iterations, the error in estimation is at most O(γτ ) where γ < 1 is a constant. There are several results that we use repeatedly, which we collect here, and prove individually in the appendix. Lemmas 4, 5 and 6. Let B, T and the data stream {xi} be as defined in the theorem. Then:\n• (Lemma 4): With probability 1− C/T , for C a universal constant, we have: ∥\n∥ ∥ ∥ ∥ 1 B ∑\nt\nxtx ⊤ t − uu⊤ − σ2I\n∥ ∥ ∥ ∥ ∥\n2\n≤ ǫ.\n• (Lemma 5): With probability 1− C/T , for C a universal constant, we have:\nu⊤sτ+1 ≥ u⊤qτ (1 + σ2) ( 1− ǫ 4(1 + σ2) ) ,\nwhere st = 1 B\n∑ Bτ<t≤B(τ+1) xtx ⊤ t qτ .\n• (Lemma 6): Let q0 be the initial guess for u, given by Steps 1 and 2 of Algorithm 1. Then, w.p. 0.99: |〈q0,u〉| ≥ C0√p , where C0 > 0 is a universal constant.\nStep (a) is proved in Lemmas 4 and 5, while Lemma 6 provides the required result for the initial vector q0. Using these lemmas, we next complete the proof of the theorem. We note that both (a) and (b) follow from well-known results; we provide them for completeness.\nLet qτ = √ 1− δτu + √ δτgτ , 1 ≤ τ ≤ n/B, where gτ is the component of qτ that is\nperpendicular to u and √ 1− δτ is the magnitude of the component of qτ along u. Note that gτ may well change at each iteration; we only wish to show δτ → 0. Now, using Lemma 5, the following holds with probability at least 1− C/T :\nu⊤sτ+1 ≥ √ 1− δτ (1 + σ2) ( 1− ǫ 4(1 + σ2) ) . (4)\nNext, we consider the component of sτ+1 that is perpendicular to u:\ng⊤τ+1sτ+1 = g ⊤ τ+1\n\n\n1\nB\nB(τ+1) ∑\nt=Bτ+1\nxtx ⊤ t\n\nqτ = g ⊤ τ+1(M + Eτ )qτ ,\nwhere M = uu⊤ + σ2I and Eτ is the error matrix: Eτ = M − 1B ∑B(τ+1) t=Bτ+1 xtx ⊤ t . Using Lemma 4, ‖Eτ‖2 ≤ ǫ (w.p. ≥ 1− C/T ). Hence, w.p. ≥ 1− C/T :\ng⊤τ+1sτ+1 = σ 2g⊤τ+1qτ + ‖gτ+1‖2‖Eτ‖2‖qτ‖2 ≤ σ2\n√\nδτ + ǫ. (5)\nNow, since qτ+1 = sτ+1/‖sτ+1‖2,\nδτ+1 = (g ⊤ τ+1qτ+1)\n2 = (g⊤τ+1sτ+1) 2\n(u⊤sτ+1)2 + (g⊤τ+1sτ+1) 2 ,\n(i) ≤ (g ⊤ τ+1sτ+1) 2\n(1− δτ ) ( 1 + σ2 − ǫ 4 )2 + (g⊤τ+1sτ+1)\n2 ,\n(ii) ≤ (σ 2 √ δτ + ǫ) 2\n(1− δτ ) ( 1 + σ2 − ǫ 4 )2 + (σ2 √ δτ + ǫ)2 , (6)\nwhere, (i) follows from (4) and (ii) follows from (5) along with the fact that x c+x\nis an increasing function in x for c, x ≥ 0.\nAssuming √ δτ ≥ 2ǫ and using (6) and bounding the failure probability with a union\nbound, we get (w.p. ≥ 1− τ · C/T )\nδτ+1 ≤ δτ (σ\n2 + 1/2)2 (1− δτ )(σ2 + 3/4)2 + δτ (σ2 + 1/2)2 (i) ≤ γ 2τδ0 1− (1− γ2τ )δ0 (ii) ≤ C1γ2τp, (7)\nwhere γ = σ 2+1/2\nσ2+3/4 and C1 > 0 is a global constant. Inequality (ii) follows from Lemma 6;\nto prove (i), we need one final result: the following lemma shows that the recursion given by (7) decreases δτ at a fast rate. Interestingly, the rate of decrease in error δτ initially (for small τ) might be sub-linear but for large enough τ the rate turns out to be linear. We defer the proof to the appendix.\nLemma 2. If for any τ ≥ 0 and 0 < γ < 1, we have δτ+1 ≤ γ 2δτ\n1−δτ+γ2δτ , then,\nδτ+1 ≤ γ2t+2δ0\n1− (1− γ2t+2)δ0 .\nHence, using the above equation after T = O (log(p/ǫ)/ log (1/γ)) updates, with probability at least 1−C, √δT ≤ 2ǫ. The result now follows by noting that ‖u−qT‖2 ≤ 2 √ δT .\nRemark: Note that in Theorem 1, the probability of accurate principal component recovery is a constant and does not decay with p. One can correct this by either paying a price of O(log p) in storage, or in sample complexity: for the former, we can run O(log p) instances of Algorithm 1 in parallel; alternatively, we can run Algorithm 1 O(log p) times on fresh data each time, using the next block of data to evaluate the old solutions, always keeping the best one. Either approach guarantees a success probability of at least 1− 1\npO(1) .\n4.2 General Rank-k Case\nIn this section, we consider the general rank-k PCA problem where each sample is assumed to be generated using the model of equation (2), where A ∈ Rp×k represents the k principal components that need to be recovered. Let A = UΛV ⊤ be the SVD of A where U ∈ Rp×k, Λ, V ∈ Rk×k. The matrices U and V are orthogonal, i.e., U⊤U = I, V ⊤V = I, and Σ is a diagonal matrix with diagonal elements λ1 ≥ λ2 · · · ≥ λk. The goal is to recover the space spanned by A, i.e., span(U). Without loss of generality, we can assume that ‖A‖2 = λ1 = 1.\nSimilar to the rank-1 problem, our algorithm for the rank-k problem can be viewed as a streaming variant of the classical orthogonal iteration used for SVD. But unlike the rank1 case, we require a more careful analysis as we need to bound spectral norms of various quantities in intermediate steps and simple, crude analysis can lead to significantly worse bounds. Interestingly, the analysis is entirely different from the standard analysis of the orthogonal iteration as there, the empirical estimate of the covariance matrix is fixed while in our case it varies with each block.\nFor the general rank-k problem, we use the largest-principal-angle-based distance function between any two given subspaces:\ndist (span(U), span(V )) = dist(U, V ) = ‖U⊤⊥V ‖2 = ‖V ⊤⊥ U‖2,\nwhere U⊥ and V⊥ represent an orthogonal basis of the perpendicular subspace to span(U) and span(V ), respectively. For the spiked covariance model, it is straightforward to see that this is equivalent to the usual PCA figure-of-merit, the expressed variance.\nTheorem 3. Consider a data stream, where xt ∈ Rp for every t is generated by (2), and the SVD of A ∈ Rp×k is given by A = UΛV ⊤. Let, wlog, λ1 = 1 ≥ λ2 ≥ · · · ≥ λk > 0. Let,\nT = Ω\n(\nlog(p/kǫ)/ log\n(\nσ2 + 0.75λ2k σ2 + 0.5λ2k\n))\n, B = Ω\n\n \n( (1 + σ)2 √ k + σ √ 1 + σ2k √ p )2 log(T )\nλ4kǫ 2\n\n  .\nThen, after T B-size-block-updates, w.p. 0.99, dist(U,QT ) ≤ ǫ. Hence, the sufficient number of samples for ǫ-accurate recovery of all the top-k principal components is:\nn = Ω̃\n\n \n( (1 + σ)2 √ k + σ √ 1 + σ2k √ p )2 log(p/kǫ)\nλ4kǫ 2 log\n(\nσ2+0.75λ2 k\nσ2+0.5λ2 k\n)\n\n  .\nAgain, we use Ω̃(·) to suppress the extra log(T ) factor.\nThe key part of the proof requires the following additional lemmas that bound the energy of the current iterate along the desired subspace and its perpendicular space (Lemmas 8 and 9), and Lemma 10, which controls the quality of the initialization.\nLemmas 8, 9 and 10. Let the data stream, A, B, and T be as defined in Theorem 3, σ be the variance of noise, Fτ+1 = 1 B ∑ Bτ<t≤B(τ+1) xtx ⊤ t and Qτ be the τ -th iterate of Algorithm 1.\n• (Lemma 8): ∀ v ∈ Rk and ‖v‖2 = 1, w.p. 1− 5C/T we have:\n‖U⊤Fτ+1Qτv‖2 ≥ (λ2k + σ2 − λ2kǫ 4 ) √ 1− ‖U⊤⊥Qτ‖22.\n• (Lemma 9): With probability at least 1−4C/T , ‖U⊤⊥Fτ+1Qτ‖2 ≤ σ2‖U⊤⊥Qτ‖2+λ2kǫ/2.\n• (Lemma 10): Let Q0 ∈ Rp×k be sampled uniformly at random as in Algorithm 1. Then, w.p. at least 0.99: σk(U ⊤Q0) ≥ C √ 1 kp .\nWe provide the proof of the lemmas and theorem in the appendix."
    }, {
      "heading" : "4.3 Perturbation-tolerant Subspace Recovery",
      "text" : "While our results thus far assume A has rank exactly k, and k is known a priori, here we show that both these can be relaxed; hence our results hold in a quite broad setting.\nLet xt = Azt +wt be the t-th step sample, with A = UΛV T ∈ Rp×r and U ∈ Rp×r where r ≥ k is the true rank of A which is unknown. However, we run Algorithm 1 with rank k and the goal is to recover a subspace QT , s.t., QT is contained in U .\nWe first observe that the largest-principal angle based distance function that we use in the previous section can directly be used for our more general setting. That is, dist(U,QT ) = ‖UT⊥QT‖2 measures the component of QT “outside” the subspace U and the goal is to show that component is ≤ ǫ.\nNow, our analysis can be easily modified to handle this more general setting as crucially our distance function does not change. Naturally, now the number of samples we require increases according to r. In particular, if\nn = Ω̃\n\n\n( (1 + σ)2 √ r + σ √ 1 + σ2r √ p )2 log(p/rǫ)\nλ4rǫ 2 log\n(\nσ2+0.75λ2r σ2+0.5λ2r\n)\n\n ,\nthen dist(U,QT ) ≤ ǫ. Furthermore, if we assume r ≥ C · k (or a large enough constant C > 0) then the initialization step provides us better distance, i.e., dist(U,Q0) ≤ C ′/√p rather than dist(U,Q0) ≤ C ′/ √ kp bound if r = k. This initialization step enables us to give tighter sample complexity as the r √ p in the numerator above can be replaced by √ rp."
    }, {
      "heading" : "5 Experiments",
      "text" : "In this section, we show that, as predicted by our theoretical results, our algorithm performs close to the optimal batch SVD. We provide the results from simulating the spiked covariance model, and demonstrate the phase-transition in the probability of successful recovery that is inherent to the statistical problem. Then we stray from the analyzed model and performance metric and test our algorithm on real world–and some very big–datasets, using the metric of explained variance.\nIn the experiments for Figures 1 (a)-(b), we draw data from the generative model of\n(2). Our results are averaged over at least 200 independent runs. Algorithm 1 uses the block size prescribed in Theorem 3, with the empirically tuned constant of 0.2. As expected, our algorithm exhibits linear scaling with respect to the ambient dimension p – the same as the batch SVD. The missing point on batch SVD’s curve (Figure 1(a)), corresponds to p > 2.4 · 104. Performing SVD on a dense p × p matrix, either fails or takes a very long time on most modern desktop computers; in contrast, our streaming algorithm easily runs on this size problem. The phase transition plot in Figure 1(b) shows the empirical sample complexity on a large class of problems and corroborates the scaling with respect to the noise variance we obtain theoretically.\nFigures 1 (c)-(d) complement our complete treatment of the spiked covariance model, with some out-of-model experiments. We used three bag-of-words datasets from [14]. We evaluated our algorithm’s performance with respect to the fraction of explained variance metric: given the p×k matrix V output from the algorithm, and all the provided samples in matrix X , the fraction of explained variance is defined as Tr(V TXXTV )/Tr(XXT ). To be consistent with our theory, for a dataset of n samples of dimension p, we set the number of blocks to be T = ⌈log(p)⌉ and the size of blocks to B = ⌊n/T ⌋ in our algorithm. The NIPS dataset is the smallest, with 1500 documents and 12K words and allowed us to compare our algorithm with the optimal, batch SVD. We had the two algorithms work on the document space (p = 1500) and report the results in Figure 1(c). The dashed line represents the optimal using B samples. The figure is consistent with our theoretical result: our algorithm performs as well as the batch, with an added log(p) factor in the sample complexity.\nFinally, in Figure 1 (d), we show our algorithm’s ability to tackle very large problems. Both the NY Times and PubMed datasets are of prohibitive size for traditional batch methods – the latter including 8.2 million documents on a vocabulary of 141 thousand words – so we just report the performance of Algorithm 1. It was able to extract the top 7 components for each dataset in a few hours on a desktop computer. A second pass was made on the data to evaluate the results, and we saw 7-10 percent of the variance explained on spaces with p > 104."
    }, {
      "heading" : "A Lemmas from Section 4.1",
      "text" : "We first give the statement of all the Lemmas whose proofs we omitted in the body of the paper. Then we provide some results from the literature – what we call Preliminaries – and then we prove Theorem 3 and the supporting lemmas.\nLemma 4. Let B, T and the data stream {xt} be as defined in Theorem 1. Then, w.p. 1− C/T we have:\n∥ ∥ ∥ ∥ ∥ 1 B ∑\nt\nxtx ⊤ t − uu⊤ − σ2I\n∥ ∥ ∥ ∥ ∥\n2\n≤ ǫ.\nLemma 5. Let B, T and the data stream {xt} be as defined in Theorem 1. Then, w.p. 1− C/T we have:\nu⊤sτ+1 ≥ u⊤qτ (1 + σ2) ( 1− ǫ 4(1 + σ2) ) ,\nwhere st = 1 B\n∑ Bτ<t≤B(τ+1) xtx ⊤ t qτ .\nLemma 6. Let q0 be the initial guess for u, given by Steps 1 and 2 of Algorithm 1. Then, w.p. 0.99: |〈q0,u〉| ≥ C0√p , where C0 > 0 is a universal constant.\nLemma 7. If for any τ ≥ 0 and 0 < γ < 1, we have δτ+1 ≤ γ 2δτ\n1−δτ+γ2δτ , then,\nδτ+1 ≤ γ2t+2δ0\n1− (1− γ2t+2)δ0 ."
    }, {
      "heading" : "B Lemmas from Section 4.2",
      "text" : "Lemma 8. Let X , A, B, and T be as defined in Theorem 3. Also, let σ be the variance of noise, Fτ+1 = 1 B ∑ Bτ<t≤B(τ+1) xtx ⊤ t and Qτ be the τ -th iterate of Algorithm 1. Then, ∀ v ∈ Rk and ‖v‖2 = 1, w.p. 1− 5C/T we have:\n‖U⊤Fτ+1Qτv‖2 ≥ (λ2k + σ2 − λ2kǫ 4 ) √ 1− ‖U⊤⊥Qτ‖22.\nLemma 9. Let X , A, B, Fτ+1, Qτ be as defined in Lemma 8. Then, w.p. 1 − 4C/T , ‖U⊤⊥Fτ+1Qτ‖2 ≤ σ2‖U⊤⊥Qτ‖2 + λ2kǫ/2.\nLemma 10. Let Q0 ∈ Rp×k be sampled uniformly at random from the set of all k-dimensional subspaces (see Initialization Steps of Algorithm 1). Then, w.p. at least 0.99: σk(U\n⊤Q0) ≥ C √\n1 kp , where C > 0 is a global constant."
    }, {
      "heading" : "C Preliminaries",
      "text" : "Lemma 11 (Lemma 5.4 of [20]). Let A be a symmetric k× k matrix, and let Nǫ be an ǫ-net of Sk−1 for some ǫ ∈ [0, 1). Then,\n‖A‖2 ≤ 1\n(1− 2ǫ) supx∈Nǫ |〈Ax,x〉|.\nLemma 12 (Proposition 2.1 of [19]). Consider independent random vectors x1, . . . ,xn in R\np, n ≥ p, which have sub-Gaussian distribution with parameter 1. Then for every δ > 0 with probability at least 1− δ one has,\n‖ 1 n\nn ∑\ni=1\nxix T i − E[xixTi ]‖2 ≤ C\n√\nlog(2/δ)\n√\np n .\nLemma 13 (Corollary 3.5 of [20]). Let A be an N ×n matrix whose entries are independent standard normal random variables. Then for every t ≥ 0, with probability at least 1 − 2 exp(−t2/2) one has,\n√ N −√n− t ≤ σk(A) ≤ σ1(A) ≤ √ N + √ n+ t.\nLemma 14 (Theorem 1.2 of [17]). Let ζ1, . . . , ζn be independent centered real random variables with variances at least 1 and subgaussian moments bounded by B. Let A be an k × k matrix whose rows are independent copies of the random vector (ζ1, . . . , ζn). Then for every ǫ ≥ 0 one has\nPr(σmin(A) ≤ ǫ/ √ k) ≤ Cǫ+ cn,\nwhere C > 0 and c ∈ (0, 1) depend only on B. Note that B = 1 for the standard Gaussian variables.\nLemma 15. Let xi ∈ Rm, 1 ≤ i ≤ B be i.i.d. standard multivariate normal variables. Also, yi ∈ Rn are also i.i.d. normal variables and are independent of xi, ∀i. Then, w.p. 1− δ,\n∥ ∥ ∥ ∥ ∥ 1 B ∑\ni\nxiy ⊤ i\n∥ ∥ ∥ ∥ ∥\n2\n≤ √ Cmax(m,n) log(2/δ)\nB .\nProof. Let M = ∑ i xiy T i and let m > n. Then, the goal is to show that, the following holds w.p. 1− δ: 1 B ‖Mv‖2 ≤ √ Cm log(2/δ) B\nfor all v ∈ Rn s.t. ‖v‖2 = 1. We prove the lemma by first showing that the above mentioned result holds for any fixed\nvector v and then use standard epsilon-net argument to prove it for all v. Let N be the 1/4-net of Sn−1. Then, using Lemma 5.4 of [20] (see Lemma 11),\n‖ 1 Bm MTM‖2 ≤ 2max v∈N 1 Bm ‖Mv‖22. (8)\nNow, for any fixed v: Mv = ∑ i xiy T i v = ∑ i xici, where ci = y T i v ∼ N(0, 1). Hence,\n‖Mv‖22 = m ∑\nℓ=1\n( B ∑\ni=1\nxiℓci) 2.\nNow, ∑B i=1 xiℓci ∼ N(0, ‖c‖22) where cT = [c1 c2 · · · cB]. Hence, ∑B i=1 xiℓci = ‖c‖2hℓ where hℓ ∼ N(0, 1).\nTherefore, ‖Mv‖22 = ‖c‖22‖h‖22 where hT = [h1 h2 · · ·hB]. Now,\nPr( ‖c‖22‖h‖22 Bm ≥ 1 + γ) ≤ Pr(‖c‖ 2 2 B ≥ √ 1 + γ) + Pr( ‖h‖22 m ≥ √ 1 + γ)\nζ1 ≤ 2 exp(−Bγ\n2\n32 ) + 2 exp(−mγ\n2\n32 ) ≤ 4 exp(−mγ\n2\n32 ), (9)\nwhere 0 < γ < 3 and ζ1 follows from Lemma 13.\nUsing (8), (9), the following holds with probability (1− 9n+1e−mγ 2 32 ):\n‖M‖22 Bm ≤ 1 + 2γ. (10)\nThe result now follows by setting γ appropriately and assuming n < Cm for small enough C."
    }, {
      "heading" : "D Proof of Theorem 3",
      "text" : "Recall that our algorithm proceeds in a blockwise manner; for each block of samples, we compute\nSτ+1 =\n\n\n1\nB\nB(τ+1) ∑\nt=Bτ+1\nxtx ⊤ t\n\nQτ , (11)\nwhere Qτ ∈ Rp×k is the τ -th block iterate and is an orthogonal matrix, i.e., Q⊤τ Qτ = Ik×k. Given Sτ+1, the next iterate, Qτ+1, is computed by the QR-decomposition of Sτ+1. That is,\nSτ+1 = Qτ+1Rτ+1, (12)\nwhere Rτ+1 ∈ Rk×k is an upper-triangular matrix. Proof. By using update for Qτ+1 (see (11), (12)):\nQτ+1Rτ+1 = Fτ+1Qτ , (13)\nwhere Fτ+1 = 1 B\n∑ Bτ<t≤B(τ+1) xtx ⊤ t . That is,\nU⊤⊥Qτ+1Rτ+1v = U ⊤ ⊥Fτ+1Qτv, ∀v ∈ Rk, (14)\nwhere U⊥ is an orthogonal basis of the subspace orthogonal to span(U). Now, let v1 be the singular vector corresponding to the largest singular value, then:\n‖U⊤⊥Qτ+1‖22 = ‖U⊤⊥Qτ+1v1‖22\n‖v1‖22 = ‖U⊤⊥Qτ+1Rτ+1ṽ1‖22 ‖Rτ+1ṽ1‖22\n(i) = ‖U⊤⊥Qτ+1Rτ+1ṽ1‖22 ‖U⊤Qτ+1Rτ+1ṽ1‖22 + ‖U⊤⊥Qτ+1Rτ+1ṽ1‖22\n(ii) = ‖U⊤⊥Fτ+1Qτ ṽ1‖22 ‖U⊤Fτ+1Qτ ṽ1‖22 + ‖U⊤⊥Fτ+1Qτ ṽ1‖22 . (15)\nwhere ṽ1 = R−1τ+1v1\n‖R−1τ+1v1‖2 . (i) follows as Qτ+1 is an orthogonal matrix and [U U⊥] form a complete\northogonal basis; (ii) follows by using (13). The existence of R−1τ+1 follows using Lemma 8 along with the fact that σk(Rτ+1) = ‖Rτ+1ζ0‖2 ≥ ‖U⊤Qτ+1Rτ+1ζ0‖2 = ‖U⊤Fτ+1Qτζ0‖2 > 0, where ζ0 is the singular vector of Rτ+1 corresponding to its smallest singular value, σk(Rτ+1).\nNow, using (15) with Lemmas 8, 9 and using the fact that x/(x + c) is an increasing function of x, for all x > 0, we get (w.p. ≥ 1− 2C/T ):\n‖U⊤⊥Qτ+1‖22 ≤ (σ2‖U⊤⊥Qτ‖2 + λ2kǫ/2)2\n(λ2k + σ 2 − λ\n2 k ǫ\n4 ) 2(1− ‖U⊤⊥Qτ‖22) + (σ2‖U⊤⊥Qτ‖2 + 0.5λ2kǫ)2\n.\nNow, assuming ǫ ≤ ‖U⊤⊥Qτ‖22, using the above equation and by using union bound, we get (w.p. ≥ 1− 2τC/T ):\n‖U⊤⊥Qτ+1‖22 ≤ γ2‖U⊤⊥Qτ‖22\n1− ‖U⊤⊥Qτ‖22 + γ2‖U⊤⊥Qτ‖22 , (16)\nwhere γ = σ2+λ2 k /2\nσ2+3λ2 k /4\n< 1 for λk > 0. Using Lemma 2 along with the above equation, we get\n(w.p. ≥ 1− 2τC/T ): ‖U⊤⊥Qτ+1‖22 ≤ γ2τ\n‖U⊤⊥Q0‖22 1− ‖U⊤⊥Q0‖22 .\nNow, using Lemma 10 we know that ‖U⊤⊥Q0‖22 is at most 1 − Ω(1/(kp)). Hence, for T = O(log(p/ǫ)/ log(1/γ), we get: ‖U⊤⊥QT‖22 ≤ ǫ. Furthermore, we require B (as mentioned in the Theorem) samples per block. Hence, the total sample complexity bound is given by O(BT ), concluding the proof."
    }, {
      "heading" : "E Proof of Lemma 4",
      "text" : "Proof. Note that,\n1\nB\n∑\nt\nxtx ⊤ t − uu⊤ − σ2I = uu⊤\n1\nB\n∑\nt\n(z2t − 1)+\n1\nB\n∑\nt\n(wtw ⊤ t − σ2I) +\n1\nB\n∑\nt\nztwtu ⊤ +\n1 B u ∑\nt\nztw ⊤ t . (17)\nWe now individually bound each of the above given terms in the RHS. Using standard tail bounds for covariance estimation (see Lemma 12), we can bound the first two terms (w.p. 1− 2C/T ):\n1\nB\n∣ ∣ ∣ ∣ ∣ ∑\nt\n(z2t − 1) ∣ ∣ ∣ ∣\n∣\n≤ √ C log(T )\nB ,\n‖ 1 B ∑\nt\n(wtw ⊤ t − σ2I)‖2 ≤ σ2\n√\nC1p log(T )\nB . (18)\nSimilarly, using Lemma 15, we can bound the last two terms in (17) (w.p. 1− 2C/T ):\n‖ 1 B ∑\nt\nztwtu ⊤‖2 = ‖\n1 B u ∑\nt\nztw ⊤ t ‖2 ≤ σ\n√\nC1p log(T )\nB . (19)\nThe lemma now follows by using (17), (18), (19) along with B as given by Theorem 1."
    }, {
      "heading" : "F Proof of Lemma 5",
      "text" : "Proof. Let qτ = √ 1− δτu+ √ δτu ⊥ τ , where u ⊥ τ is the component of qτ that is orthogonal to u. Now,\nu⊤sτ+1 = 1\nB\n∑\nt\n(u⊤xt)(x ⊤ t qt)\n= 1\nB\n∑\nt\n(zt + u ⊤wt)( √ 1− δτ (zt + u⊤wt) + √ δτw ⊤ t u ⊥ τ )\n= √ 1− δτ B ∑\nt\n(zt + u ⊤wt) 2 + √ δτ B ∑\nt\n(zt + u ⊤wt)w ⊤ t u ⊥ τ . (20)\nNow, the first term above is a summation of B i.i.d. chi-square variables and hence using standard results (see Lemma 13), w.p. (1− C/T ):\n1\nB\n∑\nt\n(zt + u ⊤wt) 2 ≥ (1 + σ2)(1− √ C log(2T )\nB ). (21)\nAlso, w⊤t u and w ⊤ t u ⊥ τ are independent random variables, as both w ⊤ t u, w ⊤ t u ⊥ τ are Gaussians and E[w⊤t u ⊥ τ u\n⊤wt] = 0. Hence, using Lemma 15, the following holds with probability ≥ 1− 4C/T :\n‖ 1 B ∑\nt\n(zt + u ⊤wt)w ⊤ t u ⊥ τ ‖2 ≤ σ\n√ 1 + σ2\n√\nC log(T )\nB\n(i) ≤ σ √ 1 + σ2\n√\nC1p log(T )\nB(1− δ0) √ 1− δτ ,\n(22)\nwhere (i) follows by using inductive hypothesis (i.e., √ 1− δτ > √\n1− δτ−1, induction step follows as we show that the error decreases at each step) and Lemma 6.\nThe lemma now follows by using (20), (21), (22) and by setting B, T appropriately."
    }, {
      "heading" : "G Proof of Lemma 6",
      "text" : "Proof. Using standard tail bounds for Gaussians (see Lemma 13), ‖q0‖2 ≤ 2√p with probability 1 − exp(−C1p), where C1 > 0 is a universal constant. Furthermore, (‖q0‖2q0)⊤u ∼ N(0, 1). Hence, there exists C0 > 0, s.t., with probability 0.99, |(‖q0‖2q0)Tu| ≥ C0. Hence, |q⊤0 u| ≥ C02√p ."
    }, {
      "heading" : "H Proof of Lemma 2",
      "text" : "Proof. We prove the lemma using induction. The base case (for τ = 0) follows trivially.\nNow, by the inductive hypothesis, δτ ≤ γ 2tδ0\n1−(1−γ2t)δ0 . That is,\n1 δτ ≥ 1− (1− γ 2t)δ0 γ2tδ0 .\nFinally, by assumption,\nδτ+1 ≤ γ2\n1 δτ\n− (1− γ2) ≤ γ2\n1−(1−γ2t)δ0 γ2tδ0\n− (1− γ2) .\nThe lemma follows after simplification of the above given expression."
    }, {
      "heading" : "I Proof of Lemma 8",
      "text" : "Proof. Using the generative model (2), we get:\nU⊤Fτ+1Qτv = Λ\n(\n1\nB\n∑\nt\nztz ⊤ t\n)\nΛU⊤Qτv +\n(\n1\nB\n∑\nt\nU⊤wtw ⊤ t U\n)\nU⊤Qτv\n+( 1\nB\n∑\nt\nU⊤wtz ⊤ t )ΛU ⊤Qτv+Λ( 1\nB\n∑\nt\nztw ⊤ t U)U ⊤Qτv+\n(\n1\nB\n∑\nt\n(Λzt + U ⊤wt)w ⊤ t U⊥U ⊤ ⊥Qτ\n)\nv.\n(23)\nNote that in the equation and rest of the proof, t varies from Bτ < t ≤ B(τ + 1). We now show that each of the five terms in the above given equation concentrate around their respective means. Also, let yt = U ⊤wt and y⊥t = U ⊤ ⊥wt. Note that, yt ∼ N(0, σ2Ik×k) and y⊥t ∼ N(0, σ2I(p−k)×(p−k)). (a): Consider the first term in (23). Using ‖Av‖2 ≤ ‖A‖2‖v‖2 and the assumption that λ1 = 1, we get: ‖Λ ( 1 B ∑ t ztz ⊤ t − I ) ΛU⊤Qτv‖2 ≤ ‖ ( 1 B ∑ t ztz ⊤ t − I )\n‖2‖U⊤Qτv‖2. Using Lemma 12 we get (w.p. 1− C/T ):\n‖ 1 B ∑\nt\nztz ⊤ t − I‖2 ≤\n√\nC1k log(T )\nB .\nThat is,\n‖Λ( 1 B ∑\nt\nztz ⊤ t − I)ΛU⊤Qτv‖2 ≤\n√\nC1k log(T )\nB ‖U⊤Qτv‖2. (24)\n(b): Similarly, the second term in (23) can be bounded as (w.p. 1− C/T ):\n‖ ( 1\nB\n∑\nt\nU⊤wtw ⊤ t U − σ2I\n)\nU⊤Qτv‖2 ≤ σ2 √ C1k log(T )\nB ‖U⊤Qτv‖2. (25)\n(c): Now consider the third and the fourth term. Now wt and zt are independent 0-mean Gaussians, hence using Lemma 15, we get: ‖ 1 B ∑ t U ⊤wtz⊤t ‖2 ≤ σ √ C1k log(T ) B . Hence, w.p. 1− 2C/T ,\n‖Λ( 1 B ∑\nt\nztw ⊤ t U)U ⊤Qτv‖+ ‖( 1\nB\n∑\nt\nU⊤wtzt)ΛU ⊤Qτv‖ ≤ 2σ\n√\nC1k log(T )\nB ‖U⊤Qτv‖2. (26)\n(d): Finally, we consider the last term in (23). Note that, (Λzt + U ⊤wt) ∼ N(0, D) where\nD is a diagonal matrix with Dii = λ 2 i + σ 2. Also, Q⊤U⊥U⊤⊥wt ∼ N(0, σ2I(p−k)×(p−k)) and is independent of (Λzt + U ⊤wt) as E[Q⊤U⊥U⊤⊥wtw ⊤ t U ] = 0; recall that for Gaussian RVs, covariance is zero iff RVs are independent. Hence, using Lemma 15, w.p. ≥ 1− C/T :\n‖( 1 B ∑\nt\n(Λzt + U ⊤wt)w ⊤ t U⊥U ⊤ ⊥Qτ )v‖2 ≤\n√ 1 + σ2σ\n√\nC1k log(T )\nB . (27)\nNow, using (23), (24), (25), (26), (27) (w.p. ≥ 1− 5C/T )\n‖U⊤Fτ+1Qτv‖2 ≥ ‖(Λ2+σ2I)U⊤Qτv‖2− √ C1k log(T )\nB ‖U⊤Qτv‖2\n( (1 + σ)2 + σ √ 1 + σ2\n‖U⊤Qτv‖2\n)\n.\n(28)\nNow, ‖U⊤Qτv‖2 ≥ σk(U⊤Qτv). Next, by using the inductive hypothesis (i.e., σk(UTQτ ) ≥ σk(U\nTQτ−1), induction step follows as we show that the error decreases at each step) and Lemma 10, we have ‖U⊤Qτv‖2 ≥ σk(U⊤Q0) ≥ C√pk with probability ≥ 0.99.\nAlso, ‖(Λ2+σ2I)U⊤Qτv‖2 ≥ (λ2k+σ2)‖U⊤Qτv‖2. Additionally, ‖U⊤Qτv‖2 ≥ √ 1− ‖U⊤⊥Qτ‖22. Hence, lemma follows by using these facts with (28) and by selecting B as given in Theorem 3."
    }, {
      "heading" : "J Proof of Lemma 9",
      "text" : "Proof. Similar to our proof for Lemma 8, we separate out the “error” or deviation terms in ‖U⊤⊥Fτ+1Qτ‖2 and bound them using concentration bounds. Now,\n‖U⊤⊥Fτ+1Qτv‖2 = ‖U⊤⊥ (UΛ2U⊤ + σ2I + Eτ )Qτv‖2 ≤ ‖σ2U⊤⊥Qτv‖2 + ‖U⊤⊥EτQτv‖2 ≤ σ2‖U⊤⊥Qτv‖2 + ‖Eτ‖2, (29)\nwhere Eτ is the error matrix representing deviation of the estimate Fτ+1 from its mean. That is,\nE = 1\nB\n∑\nt\nxtx ⊤ t − UΛ2U⊤ − σ2I\n= UΛ( 1\nB\n∑\nt\nztz ⊤ t − I)ΛU⊤ + (\n1\nB\n∑\nt\nwtw ⊤ t − σ2I)\n+ UΛ 1\nB\n∑\nt\nztw ⊤ t +\n1\nB\n∑\nt\nwtz ⊤ t ΛU. (30)\nNote that the above given four terms correspond to similar four terms in (23) and hence can be bounded in similar fashion. In particular, the following holds with probability 1− 4C/T :\n‖E‖2 ≤ √ C1k log(T )\nB + σ2\n√\nC1p log(T )\nB + 2σ\n√\nC1p log(T )\nB ≤ λ2kǫ/2, (31)\nwhere the second inequality follows by setting B as required by Theorem 3. The lemma now follows using (29), (30), (31)."
    }, {
      "heading" : "K Proof of Lemma 10",
      "text" : "Proof. Using Step 2 of Algorithm 1: H = Q0R0. Let vk be the singular vector of U ⊤Q0 corresponding to the smallest singular value. Then,\nσk(U ⊤Q0) = ‖U⊤Q0R0R−10 vk‖2 ‖R−10 vk‖2 ‖R−10 vk‖2\n≥ σk(U⊤Q0R0)σk(R−10 ). (32)\nNow, σk(R −1 0 ) = 1 ‖R0‖2 = 1 ‖Q0R0‖2 = 1 ‖H‖2 . Note that ‖H‖2 is the spectral norm of a random matrix with i.i.d. Gaussian entries and hence can be easily bounded using standard results. In particular, using Lemma 13, we get: ‖H‖2 ≤ C1√p w.p. ≥ 1 − e−C2p, where C1, C2 > 0 are global constants.\nBy Theorem 1.1 of [17] (see Lemma 14), w.p. ≥ 0.99, σk(U⊤Q0R0) = σk(H) ≥ C/ √ k.\nThe lemma now follows using the above two bounds with (32)."
    } ],
    "references" : [ {
      "title" : "Stochastic optimization for PCA and PLS",
      "author" : [ "R. Arora", "A. Cotter", "K. Livescu", "N. Srebro" ],
      "venue" : "In 50th Allerton Conference on Communication,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2012
    }, {
      "title" : "Online identification and tracking of subspaces from highly incomplete information",
      "author" : [ "L. Balzano", "R. Nowak", "B. Recht" ],
      "venue" : "In Communication, Control, and Computing (Allerton),",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2010
    }, {
      "title" : "Fast low-rank modifications of the thin singular value decomposition",
      "author" : [ "M. Brand" ],
      "venue" : "Linear algebra and its applications,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2006
    }, {
      "title" : "Incremental singular value decomposition of uncertain data with missing values",
      "author" : [ "Matthew Brand" ],
      "venue" : "Vision—ECCV",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2002
    }, {
      "title" : "Numerical linear algebra in the streaming model",
      "author" : [ "Kenneth L. Clarkson", "David P. Woodruff" ],
      "venue" : "In Proceedings of the 41st annual ACM symposium on Theory of computing,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2009
    }, {
      "title" : "Tracking a few extreme singular values and vectors in signal processing",
      "author" : [ "P. Comon", "G.H. Golub" ],
      "venue" : "Proceedings of the IEEE,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1990
    }, {
      "title" : "Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions",
      "author" : [ "Nathan Halko", "Per-Gunnar Martinsson", "Joel A. Tropp" ],
      "venue" : "SIAM review,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2011
    }, {
      "title" : "Online robust subspace tracking from partial information",
      "author" : [ "J. He", "L. Balzano", "J. Lui" ],
      "venue" : "arXiv preprint arXiv:1109.3827,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2011
    }, {
      "title" : "Tracking the best linear predictor",
      "author" : [ "Mark Herbster", "Manfred K. Warmuth" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2001
    }, {
      "title" : "On the distribution of the largest eigenvalue in principal components analysis.(english",
      "author" : [ "Iain M. Johnstone" ],
      "venue" : "Ann. Statist,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2001
    }, {
      "title" : "On incremental and robust subspace learning",
      "author" : [ "Y. Li" ],
      "venue" : "Pattern recognition,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2004
    }, {
      "title" : "Finite sample approximation results for principal component analysis: a matrix perturbation approach",
      "author" : [ "Boaz Nadler" ],
      "venue" : "The Annals of Statistics, page 2791–2817,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2008
    }, {
      "title" : "Fast collapsed gibbs sampling for latent dirichlet allocation",
      "author" : [ "Ian Porteous", "David Newman", "Alexander Ihler", "Arthur Asuncion", "Padhraic Smyth", "MaxWelling" ],
      "venue" : "In Proceedings of the 14th ACM SIGKDD international conference on Knowledge discovery and data mining,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2008
    }, {
      "title" : "A stochastic approximation method",
      "author" : [ "Herbert Robbins", "Sutton Monro" ],
      "venue" : "The Annals of Mathematical Statistics,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1951
    }, {
      "title" : "EM algorithms for PCA and SPCA. Advances in neural information processing systems, page",
      "author" : [ "Sam Roweis" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1998
    }, {
      "title" : "Smallest singular value of a random rectangular matrix",
      "author" : [ "Mark Rudelson", "Roman Vershynin" ],
      "venue" : "Communications on Pure and Applied Mathematics,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2009
    }, {
      "title" : "Probabilistic principal component analysis",
      "author" : [ "Michael E. Tipping", "Christopher M. Bishop" ],
      "venue" : "Journal of the Royal Statistical Society: Series B (Statistical Methodology),",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1999
    }, {
      "title" : "How close is the sample covariance matrix to the actual covariance matrix",
      "author" : [ "R. Vershynin" ],
      "venue" : "Journal of Theoretical Probability,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2010
    }, {
      "title" : "Introduction to the non-asymptotic analysis of random matrices",
      "author" : [ "Roman Vershynin" ],
      "venue" : "arXiv preprint arXiv:1011.3027,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "This direction was largely influenced by Johnstone’s spiked covariance model, where data samples are drawn from a distribution whose (population) covariance is a low-rank perturbation of the identity matrix [11].",
      "startOffset" : 207,
      "endOffset" : 211
    }, {
      "referenceID" : 17,
      "context" : "Work initiated there, and also work done in [19] (and references therein) has explored the power of batch PCA in the p-dimensional setting with sub-Gaussian noise, and demonstrated that the singular value decomposition (SVD) of the empirical covariance matrix succeeds in recovering the principal components (extreme eigenvectors of the population covariance) with high probability, given n = O(p) samples.",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 0,
      "context" : ", [21, 1].",
      "startOffset" : 2,
      "endOffset" : 9
    }, {
      "referenceID" : 0,
      "context" : "A memory-light variant described in [1] typically requires much less memory, but there are no guarantees for this, and moreover, for certain problem instances, its memory requirement is on the order of p.",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 4,
      "context" : ", [5, 13, 8].",
      "startOffset" : 2,
      "endOffset" : 12
    }, {
      "referenceID" : 11,
      "context" : ", [5, 13, 8].",
      "startOffset" : 2,
      "endOffset" : 12
    }, {
      "referenceID" : 6,
      "context" : ", [5, 13, 8].",
      "startOffset" : 2,
      "endOffset" : 12
    }, {
      "referenceID" : 4,
      "context" : "Indeed, it is straightforward to check that the guarantees presented in ([5, 8]) are not strong enough to guarantee recovery of the spike.",
      "startOffset" : 73,
      "endOffset" : 79
    }, {
      "referenceID" : 6,
      "context" : "Indeed, it is straightforward to check that the guarantees presented in ([5, 8]) are not strong enough to guarantee recovery of the spike.",
      "startOffset" : 73,
      "endOffset" : 79
    }, {
      "referenceID" : 3,
      "context" : ", [4, 3], [6],[12] and more recently [2, 9]) seek to have the best subspace estimate at every time (i.",
      "startOffset" : 2,
      "endOffset" : 8
    }, {
      "referenceID" : 2,
      "context" : ", [4, 3], [6],[12] and more recently [2, 9]) seek to have the best subspace estimate at every time (i.",
      "startOffset" : 2,
      "endOffset" : 8
    }, {
      "referenceID" : 5,
      "context" : ", [4, 3], [6],[12] and more recently [2, 9]) seek to have the best subspace estimate at every time (i.",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 10,
      "context" : ", [4, 3], [6],[12] and more recently [2, 9]) seek to have the best subspace estimate at every time (i.",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 1,
      "context" : ", [4, 3], [6],[12] and more recently [2, 9]) seek to have the best subspace estimate at every time (i.",
      "startOffset" : 37,
      "endOffset" : 43
    }, {
      "referenceID" : 7,
      "context" : ", [4, 3], [6],[12] and more recently [2, 9]) seek to have the best subspace estimate at every time (i.",
      "startOffset" : 37,
      "endOffset" : 43
    }, {
      "referenceID" : 14,
      "context" : "In a Bayesian mindset, some researchers have come up with expectation maximization approaches [16, 18], that can be used in an incremental fashion.",
      "startOffset" : 94,
      "endOffset" : 102
    }, {
      "referenceID" : 16,
      "context" : "In a Bayesian mindset, some researchers have come up with expectation maximization approaches [16, 18], that can be used in an incremental fashion.",
      "startOffset" : 94,
      "endOffset" : 102
    }, {
      "referenceID" : 13,
      "context" : "Stochastic-approximation-based algorithms along the lines of [15] are also quite popular, because of their low computational and memory complexity, and excellent performance in practice.",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 8,
      "context" : "They go under a variety of names, including Incremental PCA (though the term Incremental has been used in the online setting as well [10]), Hebbian learning, and stochastic power method [1].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 0,
      "context" : "They go under a variety of names, including Incremental PCA (though the term Incremental has been used in the online setting as well [10]), Hebbian learning, and stochastic power method [1].",
      "startOffset" : 186,
      "endOffset" : 189
    }, {
      "referenceID" : 0,
      "context" : "where Proj(·) denotes the “projection” that takes the SVD of the argument, and sets the top k singular values to 1 and the rest to zero (see [1] for further discussion).",
      "startOffset" : 141,
      "endOffset" : 144
    }, {
      "referenceID" : 18,
      "context" : "In this regime, it is well-known that batch-PCA is asymptotically consistent (hence recovering A up to unitary transformations) with number of samples scaling as n = O(p) [20].",
      "startOffset" : 171,
      "endOffset" : 175
    }, {
      "referenceID" : 0,
      "context" : "Stochastic versions of the power method are already popular in the literature and are known to have good empirical performance; see [1] for a nice review of such methods.",
      "startOffset" : 132,
      "endOffset" : 135
    }, {
      "referenceID" : 12,
      "context" : "We used three bag-of-words datasets from [14].",
      "startOffset" : 41,
      "endOffset" : 45
    } ],
    "year" : 2013,
    "abstractText" : "We consider streaming, one-pass principal component analysis (PCA), in the highdimensional regime, with limited memory. Here, p-dimensional samples are presented sequentially, and the goal is to produce the k-dimensional subspace that best approximates these points. Standard algorithms require O(p2) memory; meanwhile no algorithm can do better than O(kp) memory, since this is what the output itself requires. Memory (or storage) complexity is most meaningful when understood in the context of computational and sample complexity. Sample complexity for high-dimensional PCA is typically studied in the setting of the spiked covariance model, where p-dimensional points are generated from a population covariance equal to the identity (white noise) plus a low-dimensional perturbation (the spike) which is the signal to be recovered. It is now well-understood that the spike can be recovered when the number of samples, n, scales proportionally with the dimension, p. Yet, all algorithms that provably achieve this, have memory complexity O(p2). Meanwhile, algorithms with memory-complexity O(kp) do not have provable bounds on sample complexity comparable to p. We present an algorithm that achieves both: it uses O(kp) memory (meaning storage of any kind) and is able to compute the k-dimensional spike with O(p log p) sample-complexity – the first algorithm of its kind. While our theoretical analysis focuses on the spiked covariance model, our simulations show that our algorithm is successful on much more general models for the data.",
    "creator" : "LaTeX with hyperref package"
  }
}