{
  "name" : "1601.04114.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Training Recurrent Neural Networks by Diffusion",
    "authors" : [ "Hossein Mobahi" ],
    "emails" : [ "hmobahi@csail.mit.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Deep learning has recently beaten records in image recognition [Krizhevsky et al., 2012], speech recognition [Hinton et al., 2012a] and has made significant improvements in natural language processing [Bahdanau et al., 2014, Sutskever et al., 2014]. However, currently “training” deep networks, and specially recurrent neural networks (RNNs), is a challenging task [Martens and Sutskever, 2011]. To improve learning (in terms of convergence speed, attained training cost and generalization error) gradient based optimization methods are often used in combination with other techniques such as smart initialization [Sutskever et al., 2013], layerwise pretraining [Bengio et al., 2007], dropout [Hinton et al., 2012b], annealed learning rate, and curriculum learning [Bengio et al., 2009].\nThe difficulty in training deep networks is mainly attributed to their optimization landscape, where saddle points [Dauphin et al., 2014, Pascanu et al., 2014], plateaus, and sharp curvatures are prevalent. A general strategy for tackling difficult optimization problems is the continuation method. This method gradually transforms a highly simplified version of the problem back to its original form while following the solution along the way. The simplified problem is\nar X\niv :1\n60 1.\n04 11\n4v 1\n[ cs\n.L G\n] 1\n6 Ja\nsupposedly easy to solve. Then, each intermediate subproblem is initialized by the solution from the previous subproblem until reaching the final problem (see Figure 1).\nThere are two loose ends for using optimization by continuation: 1. how to choose the simplified problem, 2. how to transform the simplified problem to the main task. For both of these questions, there are infinite answers. More precisely, given an objective function, there are infinite ways infinite smooth convex functions that could be used as initial “easy” task, and also infinite ways to gradually transform that to the main objective function. The quality of the solution attained by the continuation method critically depends on these choices. Recently we have proved that these choices can be made optimally via the diffusion equation [Mobahi and Fisher III, 2015]. Specifically, the objective function is considered as the initial heat distribution on a domain, and the heat is diffused over time according to the heat equation.\nThe solution to the heat equation on Rn is known analytically: it is the convolution of the initial heat distribution (i.e., the objective function) with the Gaussian kernel. Obviously, convolution with the Gaussian kernel smoothes the objective function. The bandwidth parameter σ of the Gaussian kernel determines the amount of smoothing. The algorithm for optimization by diffusion starts from a large σ (highly simplified objective function), and then follows the minimizer as σ shrinks toward zero (which leads to the original cost function).\nThe optimality result we derived in [Mobahi and Fisher III, 2015] is a stepping stone for developing practical algorithms. Specifically, it suggests using Gaussian convolution for creating intermediate optimization tasks, but it does not answer whether the resulted convolution could be computed efficiently or not. In fact, the answer to this question is problem specific. We have shown that for some family of functions such as multivariate polynomials, the resulted convolution can be computed in closed form [Mobahi, 2016]. In this work, we push that result further and show that, up to very reasonable approximation, common objective functions arising in deep learning also have a closed form Gaussian convolution. This is surprising because such objective function\nis highly nonlinear; involving a nested form of ill-behaved activation functions as such sign and ReLU.\nBy studying deep learning through the diffusion and continuation method, we discover two interesting observations. First, from theoretical viewpoint, some common and successful techniques to improve learning, such as noise injection [Hinton et al., 2012b], layerwise pretraining [Bengio et al., 2007], and annealed learning rate, automatically emerge from the diffused cost function. Therefore, this theory unifies some seemingly isolated techniques. Second, from a practical viewpoint, training deep networks by this method seems to result in a significant speed up compared to stochastic gradient descent (SGD) method. The preliminary results presented in this draft indicate up to 25% reduction in training time for learning RNNs.\nThis article is organized as follows. We first show that the diffused form of common activation functions has a closed form expression. After that, when we compute the diffused cost function for training a deep network, where the result depends on the diffused activation function introduced earlier. We discuss some properties of the diffused cost function and make connections to noise injection [Hinton et al., 2012b], layerwise pretraining [Bengio et al., 2007], and annealed learning rate. We conclude this article by presenting a preliminary evaluation of the proposed algorithm against SGD."
    }, {
      "heading" : "2 Optimization by Diffusion and Continuation",
      "text" : "The optimality of using the diffusion equation for creating intermediate optimization problems is studied in our earlier work [Mobahi and Fisher III, 2015]. Briefly, is a relaxation of a time evolution process that converts an objective function to its convex envelope1 [Vese, 1999]. The latter is a nonlinear partial differential equation that lacks a closed form, but once linearized, the heat equation (a special type of diffusion equation) arises,\nd dt g(x, t) = ∆xg(x, t) , s.t. g(x, 0) = f(x) . (1)\nHere f is the original objective function, and g is its time evolution according to the heat equation. Here ∆x is the Laplace operator w.r.t. the variable x. Diffusion is a powerful tool for simplifying the objective function. For example, the number of local minima in the Ackley’s function [Ackley, 1987] is exponential in the number of variables. By diffusing this function via the heat equation, however, all local minima eventually disappear (see Figure 2).\nGoing from the nonlinear PDE of [Vese, 1999] to the (linear) heat equation is computationally of great value. That is, the solution to the heat equation is\n1The convex envelope of a function is an interesting choice (versus any other convex function) for the initial simplified version of it for various reasons. 1. Any global minimizer of the cost function is also a global minimizer of its convex envelope. 2. it provides the tightest convex underestimator of the cost function. 3. Geometrically, tt is the function whose epigraph coincides with the convex hull of the epigraph of the cost function.\nAlgorithm 1 Algorithm for Optimization by Diffusion and Continuation\n1: Input: f : X → R, Sequence ∞ > σ0 > σ1 > · · · > σm = 0. 2: x0 = global minimizer of g(x;σ0). 3: for k = 1 to m do 4: xk = Local minimizer of g(x;σk), initialized at xk−1. 5: end for 6: Output: xm\nknown analytically [Widder, 1975]: it is the Gaussian convolution of the original (objective) function and the bandwidth parameter of the Gaussian determines the time point at which the diffused function is evaluated. Diffusion combined with the path following lead to a simple optimization algorithm listed in Algorithm 1."
    }, {
      "heading" : "3 Diffused Activation Functions",
      "text" : "Let kσ(w) be the Gaussian kernel with zero mean and covariance σ 2I. The diffused activation functions listed in Table 3 are simply obtained2 by convolving them with the Gaussian kσ. Similar forms of smoothed ReLU and sign are used by [Zhang et al., 2015] with a fixed σ = 1√\n2π , for a proving learnability of deep\nnetworks.\n2All listed diffused functions are exact except tanh. Unfortunately, tanh ?kσ does not have a closed form. We leverage the approximation tanh(y) ≈ erf( √ π 2 y). Notice that we know the exact diffused form for erf as listed in the table. Thus, by convolving both sides with kσ we obtain [tanh ?kσ ](y) ≈ erf( √ π 2 y√ 1+π\n2 σ2\n). The R.H.S. of the latter form can\nbe again approximated via tanh(y) ≈ erf( √ π 2 y). This leads to the approximate identity\n[tanh ?kσ ](y) ≈ tanh( y√ 1+π\n2 σ2\n).\nName Original Diffused Sign sign(x) erf( x√\n2σ )\nError erf(ax) erf( ax√ 1+2(aσ)2 ) Tanh tanh(x) tanh( x√ 1+π2 σ 2 ) ReLU max(0, x) σ√ 2π e− x2 2σ2 + 12x ( 1 + erf( x√ 2σ ) )"
    }, {
      "heading" : "4 Training RNNs",
      "text" : ""
    }, {
      "heading" : "4.1 RNN Cost Function",
      "text" : "Given a set of S training sequences, each of length T . Denote the s’th sequence by 〈(xs,1,ys,1), . . . , (xs,T ,ys,T )〉. Given some discrepancy function d. The problem of sequence learning by an RNN can be stated as below,\nmin a,b,m0,U ,V ,W S∑ s=1 T∑ t=1 d(h(ns,t)− ys,t) (2)\ns.t. ns,t ,W h(ms,t) + b (3)\nms,t , Uxs,t + V h(ms,t−1) + a , (4)\nwhere a, b, m0, W , U and V are the weights of the network. Denote the dimension of xs,t and ys,t be X and Y respectively. Also denote the number of neurons by H. Then, a is H × 1, b is Y × 1, m0 is H × 1, W is Y ×H, U is H ×X, and V is H ×H. Obviously ns,t is Y × 1 and ms,t is H × 1.\nSuppose ms,0 = m0, i.e. the initial state is independent of the training sequence. Here h is some activation function. When the argument of h is a vector, the result will be a vector of the same size, whose entries consists of the element-wise application of h.\nTreating each ns,t and ms,t as independent variables and forcing their definition (equality) by some penalty function, we arrive at the following unconstrained problem,\nmin a,b,m0,U ,V ,W ,M ,N S∑ s=1 T∑ t=1\nd(h(ns,t)− ys,t)\n+ λ ( p ( W h(ms,t) + b− ns,t ) + p ( Uxt + V h(ms,t−1) + a−ms,t )) ,\nwhere the notation N and M are matrices whose columns are comprised of ns,t and ms,t for all choices of (s, t).\nLetting, d(e) , ‖e‖2 and p(e) , ‖e‖2, the problem can be expressed as below,\nmin a,b,m0,U ,V ,W ,M ,N S∑ s=1 T∑ t=1\n‖h(ns,t)− ys,t‖2\n+ λ ( ‖W h(ms,t) + b− ns,t‖2 + ‖Uxs,t + V h(ms,t−1) + a−ms,t‖2 ) .\nHere λ determines the weight of the penalty for constraint violation."
    }, {
      "heading" : "4.2 Diffused Cost",
      "text" : "When the objective function is evolved according to the diffusion equation (1), the diffused objective has a closed form expression. Specifically, it is obtained by the convolution of the original objective with the Gaussian kernel. This can be more formally expressed as the following. Arrange all optimization variables into a long vector w, i.e. w , vec(a, b,m0,U ,V ,W ,M ,N). Hence, the cost function can be denoted by f(w). The diffused cost function g is obtained by:\ng(w;σ) , [f ? kσ](w) . (5)\nAfter computing this convolution, the variables in w can be replaced by their original names according to the arrangements made in w , vec(a, b,m0,U ,V ,W ,M ,N).\nDenote the diffused form of the activation function h by h̃σ, that is h̃σ(x) , [h ? kσ](x). Similarly, define h̃2σ(x) , [h 2 ? kσ](x). The diffused cost w.r.t. optimization variables has the following closed form (see Appendix A):\nS∑ s=1 ( T∑ t=1\n‖h̃σ(ns,t)− ys,t‖2 + ‖ √ h̃2σ(ns,t)‖2 − ‖h̃σ(ns,t)‖2\n+ λ ( ‖W h̃σ(ms,t) + b− ns,t‖2 + ‖Uxs,t + V h̃σ(ms,t−1) + a−ms,t‖2\n+‖W diag( √ h̃2σ(ms,t))‖2F − ‖W diag(h̃σ(ms,t))‖2F + σ2Y ‖h̃σ(ms,t)‖2 ) +λ\nT−1∑ t=0\n‖V diag( √ h̃2σ(ms,t))‖2F − ‖V diag(h̃σ(ms,t))‖2F + σ2H ‖h̃σ(ms,t)‖2 ) .\nHere ‖ . ‖F denotes the Frobenius norm of a matrix."
    }, {
      "heading" : "4.3 Approximate Diffused Cost",
      "text" : "Ideal solution requires S × T auxiliary variables for ns,t and ms,t. This is not practical as often S is large. Thus, we resort to an approximate formulation here. Instead of solving for the optimal ns,t and ms,t, we approximate them as below,\nns,t = W h̃σ(ms,t) + b , ms,t = Uxs,t + V h̃σ(ms,t−1) + a . (6)\nThis allows us to eliminate the variables ns,t and ms,t from the remaining optimization. The simplified optimization problem is as below,\nS∑ s=1 ( T∑ t=1\n‖h̃σ(ns,t)− ys,t‖2 + ‖ √ h̃2σ(ns,t)‖2 − ‖h̃σ(ns,t)‖2\n+ λ ( ‖W diag( √ h̃2σ(ms,t))‖2F − ‖W diag(h̃σ(ms,t))‖2F + σ2Y ‖h̃σ(ms,t)‖2 ) +λ\nT−1∑ t=0\n‖V diag( √ h̃2σ(ms,t))‖2F − ‖V diag(h̃σ(ms,t))‖2F + σ2H ‖h̃σ(ms,t)‖2 ) .\nThe gradient of this cost w.r.t. learning parameters are provided in Appendix B."
    }, {
      "heading" : "5 Properties of Diffused Cost",
      "text" : "The optimization problem that arises from training a deep network is often challenging. Therefore, local optimization methods (e.g., SGD) are used with a combination of some helping techniques. Although these techniques seem\ndisconnected from each other, some of them emerge automatically from the diffused cost function. Therefore, these techniques might be unified under one simple theory. These methods and their connection to the diffused cost are discussed in the following."
    }, {
      "heading" : "5.1 Careful Initialization",
      "text" : "Local optimization methods are generally sensitive to initialization when it comes to nonconvex cost functions. Deep learning is not an exception [Sutskever et al., 2013]; a recent study shows that the performance of deep networks and recurrent networks critically depends on initialization [Safran and Shamir, 2015]. In contrast, the diffusion algorithm is deterministic and almost independent of initialization3 for two reasons. First, after enough smoothing the cost function becomes unimodal, and in case of convexity, will have one global minimum. In fact, the minimizer of the heavily smoothed function coincides with its center mass [Mobahi, 2012]. Thus, diffusion provides an interesting deterministic initialization. Second, the update rules are completely deterministic (unless one chooses to use SGD instead of GD for local optimization in Algorithm 1) and no notion of randomness is involved in the updates."
    }, {
      "heading" : "5.2 Annealed Learning Rate",
      "text" : "Each iteration of the gradient descent essentially sees the first order Taylor expansion of the cost function g(x) at the current estimate of the solution point x0. The linear approximation has good accuracy only within a small neighborhood of x0, say of radius ρ. Enforcing accuracy by the constraint ‖x− x0‖ ≤ ρ, we arrive at the following problem,\nmin x g(x0) + (x− x0)T∇g(x0) s.t. ‖x− x0‖ ≤ ρ . (7)\nUsing Lagrange multipliers method, the solution of this optimization turns out to be x∗ = x0 − ρ ∇g(x0)‖∇g(x0)‖ . The radius ρ could be chosen intelligently, e.g., by restricting the tolerated amount of linearization error. Specifically, in order to ensure ∀x ; ‖x − x0‖ ≤ ρ⇒ |g(x0) + (x− x0)T∇g(x0)− g(x)| ≤ , we can choose ρ = √ cf σ (see Ap-\npendix C for proof). Here cf is some number satisfying cf ≥ 12π ∑ j,k ‖ d2f dxj dxk ‖n 2 , which obviously exists when the norm is bounded. Putting the pieces together, the solution of the linearized problem can be\nexpressed as x∗ = x0 − η σ ∇g(x0)‖∇g(x0)‖ , where η , √ cf is a constant. This is\n3Path following process could be sensitive to initialization when it reaches a saddle point. Due to instability of saddle points, the direction the algorithm takes could be affected even by small perturbations. Thus, different initializations may end up reaching different solutions. However, these saddle points often occur due to the symmetry in the problem (either the original or the diffused) and the chosen direction does not affect the quality of the solution. This contrasts to gradient descent on a nonconvex objective, where depending on initialization, very solutions of different quality might be reached.\nessentially a gradient descent update with a specific choice of the step size. Since σ decays toward zero within the continuation loop, the step size (also called learning rate) anneals form an initially large value to eventually a small value."
    }, {
      "heading" : "5.3 Noise Injection",
      "text" : "Injection of random noise into the training process can lead to more stable solutions. This is often crucial in order to obtain satisfactory generalization in deep learning. The well known dropout is a specific way of noise injection: in each iteration, it eliminates a random subset of nodes throughout the learning [Hinton et al., 2012b]. The stochasticity in SGD is another relevant example. It is known that SGD achieves better generalization compared to a full batch gradient descent. Although these schemes differ in details, e.g., the distribution of the noise or how it is applied to the learning process, they share the same idea of noise injection in learning.\nIt turns out that the diffused cost function also has this property. In order to see that, recall the definition of the diffused cost function from (5):\ng(w;σ) , [f ? kσ](w) = ∫ W f(w − t)kσ(t) dt (8)\nThus, the gradient at a point w0 has the following form. ∇g(w0;σ) = ∫ W ∇f(w0 − t)kσ(t) dt (9)\n≈ 1 J J∑ j=1 ∇f(w0 − tj) , tj ∼ N (0, σ2I) . (10)\nThis means if we were to approximate the gradient of the diffused cost by MCMC method, it would average over a number of noisified gradients. Specifically, the noise would be additive w.r.t. the weights of the network and it would have a normal distribution with zero mean and variance of σ2. The noise injection of (10) recently has also been proposed by [Neelakantan et al., 2015], but with a heuristic motivation and relying on numerical sampling exactly as in (10). Such noise injection has been shown to successfully train a 20-layer network with gradient descent. From a higher level perspective, this noise injection has some similarity to SGD; the latter also averages (over multiple epochs) the effect of noisified gradients.\nA key advantage of using the diffusion framework for noise injection, however, is that the expected noisified gradient (the integral in (9)) has a closed form expression, while the other schemes are mainly sampling based. This leads to a huge computational gain for the diffusion method: while other methods would need a lot of sampling iterations in order to reach a reasonable approximation to the expected noisified gradient (and the number of these samples could grow exponentially in the number of weights), the diffusion method achieves this with almost no computational effort and without any sampling."
    }, {
      "heading" : "5.4 Layerwise Pretraining",
      "text" : "We argue that when σ is large, the network only focuses on short range dependencies, and as σ shrinks toward zero, longer range dependencies are gradually learned. In order to see why this happens, let’s for example inspect the partial gradient ∇a g, which has the form ∑T t=1 rtM t (see Appendix B for deriva-\ntions and the definition of rt), where M t , I + V diag ( h̃′(mt−1) ) M t−1 and M1 , I. Resolving the recursion in M t leads to,\nM t = I + V diag ( h̃′σ(mt−1) ) + V h̃′σ(mt−1)V h̃ ′ σ(mt−2) + . . . .\nWhen σ →∞, all the sigmoid-like activation functions listed in (3) become flat and their gradient vanishes h̃′σ → 0. This implies that by choosing σ large enough, one can find a small enough that satisfies ‖ diag(h̃′σ)‖ ≤ . Since the contribution of each term in the above sum will be at most equal to its matrix norm, we can derive,\n‖M t‖ ≤ ‖I‖+ ‖V ‖+ ( ‖V ‖)2 + ( ‖V ‖)3 + . . . .\nwhen σ is very large, and thus is very small, we can ignore all the terms involving , which leaves us with M t ≈ I. As we gradually reduce σ, and thus increase , we can reconsider terms involving smaller exponents, while the higher order terms still remain negligible. By gradually decreasing σ, M t can be approximated by I, then, I+V diag ( h̃′σ(mt−1) ) , then I+V diag ( h̃′σ(mt−1) ) + V h̃′σ(mt−1)V h̃ ′ σ(mt−2) and so on.\nThis is conceptually very similar to layerwise pretraining [Bengio et al., 2007], as the learning in each layer starts from considering only its immediate previous layer and then gradually switches to the full consideration by considering larger and larger number of previous layers."
    }, {
      "heading" : "5.5 Choice of the Activation Function",
      "text" : "In order to implement the method, we need to obtain the explicit expressions of h̃σ and h̃2σ for a given activation function h. For example, suppose we set h(x) = erf(ax), where a is a parameter that determines the sharpness of the activation function. Note that lima→∞ erf(ax) = sign(x) and erf( √ π 2 x) ≈ tanh(x). The form of h̃σ can be already looked up from Table 3, which is repeated below,\nh̃(x) = erf( ax√\n1 + 2(aσ)2 ) . (11)\nIn the following, we only focus on h̃2σ. Unfortunately, h̃2(x) lacks a closed form expression. However, observe that erf2(x) ≈ 1− e− 4π x2 . This approximation has a reasonably good accuracy as shown in Figure 3. Using this approximation, it follows that [erf2(a ) ? kσ](x) ≈ [1− e− 4 π (a ) 2 kσ](x).\nh̃2(x) , [erf2(a ) ? kσ](x)\n≈ [1− e− 4π (a ) 2\nkσ](x)\n= 1− √ π e − 4a2x2 π+8a2σ2\n√ π + 8a2σ2 ."
    }, {
      "heading" : "6 Preliminary Results",
      "text" : "Here we present a comparison between SGD and the proposed diffusion framework. The hyperparameters in both methods are carefully searched to ensure a fair comparison. We use erf as the activation function. The task is to learn adding two numbers, and is adapted from [Martens and Sutskever, 2011]. The network consists of has 10 hidden units, and it has two inputs and one output. One of the input units reads a sequence of 10 real numbers, and the other a sequence of 10 binary numbers. The binary numbers are zero everywhere except two random locations. The task is to add the values from the first sequence, at the two locations marked by the second sequence.\nWe trained the network by 1000 sequences, and generalization is computed from a test set of 100 sequences. The result is shown in the plots. The horizontal axis shows the generalization error, and the vertical axis shows how many epochs it takes to reach that generalization error. For example, with 50 batches of size 50 samples, in order to reach around error of 0.02, SGD (blue) needs about 90 epochs, while diffusion methods (red) needs about 20 epochs."
    }, {
      "heading" : "7 Related Works & Future Directions",
      "text" : "This work specifically studies the use of the diffusion equation for optimizing the objective function in deep learning. However, there is a growing number of techniques by others that propose new algorithms for deep learning. Using tensor decomposition techniques, [Janzamin et al., 2015] offers new algorithms for deep learning with performance guarantee. [Hazan et al., 2015] provides a conceptual similar algorithm to ours. However, instead of computing the convolution analytically, the latter work relies on numerical sampling. It can guarantee reaching the global minimum for certain scenarios.\nThis work relies on smoothing the objective function by convolving it with the Gaussian kernel. We have previously shown that this particular form of smoothing is optimal in a certain sense, by relating Gaussian convolution to a relaxation of the convex envelope. Although connection to the convex envelope is meaningful in the context of nonconvex objective functions, there are side benefits in smoothing even when the objective function is convex. For example, smoothing a nonsmooth convex objective function by convolution can improve the convergence rate of stochastic optimization algorithms [Duchi et al., 2012].\nAs discussed in Section 5.3, smoothing can be considered as means to inject noise into the training process. The idea of noise injection is already used in methods such as SGD or dropout [Hinton et al., 2012b] in order to improve learning. The key advantage of our framework for noise injection, however, is that the noise injection can be achieved in closed form and without need of sampling. In order words, we can compute the effect of infinitely many noisified objective functions in closed form. This is similar to the idea of Marginalized\nDenoising Autoencoders (mDA) [Chen et al., 2014], where the effect of infinitely many nosified inputs is marginalized to obtain a closed form expression. However, mDA limits the form of the injected noise. Specifically, the marginalized effect is only computable in a linear reconstruction setup (nonlinearity is applied only after computation of the marginalized reconstruction). In addition, mDA performs noise injection layer by layer in a greedy fashion. In contrast, our framework is able to compute closed form expression for the entire deep network and allowing full nonconvexity of the associated optimization, up to reasonable approximation.\nDiffusion equation provides an approximate evolution toward the convex envelope. Consequently, it is not perfect: if global minimum is very narrow, diffusion can miss that minima in favor of a wider minimum whose value is slightly larger than the narrow global minimum (see Figure 6). This may seem a disadvantage at the first glance. However, the wider minima are in fact more stable4, which could be more desired in practice, e.g. generalizing better. In fact, a recent analysis has shown that SGD attains better generalization when the objective function is smoother [Hardt et al., 2015]. Note that in our framework, initializing the algorithm with larger σ automatically provides a smoother surrogate cost function where unstable minima disappear. Thus, it is more likely to remain in the basin of attraction of the stable minima. A thorough investigation of how smoothing the cost function in the diffusion setting may improve the generalization performance is a direction for future research.\nA closely related work to ours is Annealed Gradient Descent [Pan and Jiang, 2015],\n4By a stable minimum we mean that a small perturbation of the equilibrium resides in the basin of attraction of the same equilibrium. This is not true if the minimum is too narrow; slight perturbation may put the gradient decent into a different basin of attraction.\nwhere the objective landscape is also initially approximated by a smoother function and is gradually transformed to the original one. However, the unlike this work where Gaussian smoothing is theoretically motivated for nonconvex optimization [Mobahi and Fisher III, 2015], in [Pan and Jiang, 2015] coarse-to-fine approximation of the objective function is based on heuristically motivated procedure. More precisely, the latter uses vector quantization methods in order to generate a code book by which the coarse cost function is approximated. Another difference between these two works is that the representation of the smoothed function in our framework is simpler, as we directly obtain a closed form expression of the objective function. that is a simpler setup than approximation by codebook generation."
    }, {
      "heading" : "8 Acknowledgment",
      "text" : "This research is partially funded by Shell Research. Hossein Mobahi is thankful to John W. Fisher, William T. Freeman, Yann LeCun, and Yoshua Bengio for comments and discussions and to Peter Bartlett and Fei Sha for suggesting connections to [Duchi et al., 2012, Chen et al., 2014]. Hossein Mobahi is grateful to Kate Saenko for discussions in earlier phase of this work."
    }, {
      "heading" : "A Diffused RNN Training Cost",
      "text" : "Diffusing the cost function w.r.t. a, b,U ,V ,W yields5,\nT∑ t=1\n‖h(nt)− yt‖2 (12) + λ ( ‖W h(mt) + b− nt‖2 + ‖Uxt + V h(mt−1) + a−mt‖2 (13) +σ2Y (1 + ‖h(mt)‖2) + σ2H(1 + ‖xt‖2 + ‖h(mt−1)‖2) ) . (14)\nSmoothing w.r.t. mt and nt leads 6 to,\nT∑ t=1\n‖h̃(nt)− yt‖2 + ‖ √ h̃2(nt)‖2 − ‖h̃(nt)‖2 (15) + λ ( ‖W h̃(mt) + b− nt‖2 + ‖Uxt + V h̃(mt−1) + a−mt‖2 (16)\n+σ2Y (2 + ‖h̃(mt)‖2) + σ2H(2 + ‖xt‖2 + ‖h̃(mt−1)‖2) (17) +‖W diag( √ h̃2(mt))‖2F − ‖W diag(h̃(mt))‖2F (18)\n+‖V diag( √ h̃2(mt−1))‖2F − ‖V diag(h̃(mt−1))‖2F ) . (19)\nDiscarding constants terms, i.e. those that do not depend on neither of optimization variables a, b,U ,V ,W ,M ,N , simplifies the diffused cost to the following,\nT∑ t=1\n‖h̃(nt)− yt‖2 + ‖ √ h̃2(nt)‖2 − ‖h̃(nt)‖2 (20) + λ ( ‖W h̃(mt) + b− nt‖2 + ‖Uxt + V h̃(mt−1) + a−mt‖2 (21)\n+‖W diag( √ h̃2(mt))‖2F − ‖W diag(h̃(mt))‖2F + σ2Y ‖h̃(mt)‖2 ) (22)\n+λ T−1∑ t=0\n‖V diag( √ h̃2(mt))‖2F − ‖V diag(h̃(mt))‖2F + σ2H ‖h̃(mt)‖2 . (23)\n5We use the fact that convolution of (xTy)2 with kσ(x) is (xTy)2 + σ2‖y‖2. 6We use the identity that convolution of ‖Ah(x) + b‖2 with kσ(x) is equal to ‖Ah̃(x) +\nb‖2 + ‖A diag( √ h̃2(x))‖2F − ‖A diag(h̃(x))‖ 2 F ."
    }, {
      "heading" : "B Gradient of Diffused Cost",
      "text" : "Below denotes the element-wise product of two matrices.\ndg db = ∑ t ∂nt ∂b ∂g ∂nt (24)\n= ∑ t I ( 2h̃′(nt) (h̃(nt)− yt) + h̃2 ′ (nt)− 2h̃′(nt) h̃(nt) ) (25)\n= ∑ t ( h̃2 ′ (nt)− 2h̃′(nt) yt ) . (26)\ndg\ndW = ∑ t ∂g ∂W + ∑ d ∂g ∂n (d) t ∂n (d) t ∂W (27)\n= 2λW diag ( T∑ t=1 ( h̃2(mt) − h̃2(mt) )) (28)\n+ T∑ t=1 ( h̃2 ′ (nt)− 2h̃′(nt) yt ) h̃(mt) T (29)\nrt , ( h̃2 ′ (nt)− 2h̃′(nt) yt )T ( W diag(h̃′(mt)) ) +λ (( h̃2 ′ (mt)− 2h̃′(mt) h̃(mt)\n)T (1T (W W ) + It6=T1T (V V )) +2σ2(It 6=TH + Y )(h̃′(mt) h̃(mt))T ) . (30)\n( dg\nda )T = T∑ t=1 ( dg dmt )T dmt da\n(31)\n= T∑ t=1 (( ∂g ∂nt )T ∂nt ∂mt + ( ∂g ∂mt )T ) dmt da\n(32)\n= T∑ t=1 rtM t (33)\nM t , dmt da = ∂mt ∂a + ∂mt ∂mt−1\nM t−1 = I + V diag ( h̃′(mt−1) ) M t−1(34)\nM1 , I . (35)\ndg\ndV =\n∂g\n∂V + T∑ t=1 ∑ d dg dm (d) t dm (d) t dV (36)\n= ∂g\n∂V + T∑ t=1 ∑ d (( ∂g ∂nt )T ∂nt ∂mt + ( ∂g ∂mt )T )(d) dm (d) t dV (37)\n= 2λV diag ( T−1∑ t=0 ( h̃2(mt) − h̃2(mt) )) + T∑ t=1 ∑ d r (d) t M (d) t (38)\nM (d) t ,\ndm (d) t\ndV (39)\n= ∂m\n(d) t ∂V + ∑ d′ ∂m (d) t ∂m (d′) t−1 M (d′) t−1 (40)\n= ”Zero matrix except d’th row set to h̃T (mt−1)” + ∑ d′ vd,d′ h̃ ′(m (d′) t−1)M (d′) t−1(41)\nM (d) 1 , ”Zero matrix except d’th row set to h̃ T (m0)” . (42)\ndg\ndU =\n∂g\n∂U + T∑ t=1 ∑ d dg dm (d) t dm (d) t dU (43)\n= ∂g\n∂U + T∑ t=1 ∑ d (( ∂g ∂nt )T ∂nt ∂mt + ( ∂g ∂mt )T )(d) dm (d) t dU (44)\n= 0 + T∑ t=1 ∑ d r (d) t ( P (d) t ) (45)\nP (d) t ,\ndm (d) t\ndU (46)\n= ∂m\n(d) t ∂U + ∑ d′ ∂m (d) t ∂m (d′) t−1 P (d′) t−1 (47)\n= ”Zero matrix except d’th row set to xTt ” + ∑ d′ vd,d′ h̃ ′(m (d′) t−1)P (d′) t−1(48)\nP (d) 1 , ”Zero matrix except d’th row set to x T 1 ” . (49)\n( dg\ndm0 )T = (\n∂g\n∂m0 )T + T∑ t=1 ( dg dmt )T dmt dm0\n(50)\n= ( ∂g\n∂m0 )T + T∑ t=1 (( ∂g ∂nt )T ∂nt ∂mt + ( ∂g ∂mt )T ) dmt dm0\n(51)\n= λ (( h̃2 ′ (m0)− 2h̃′(m0) h̃(m0) )T (1T (V V )) (52) +2Hσ2(h̃′(m0) h̃(m0))T ) (53)\n+ T∑ t=1 rt ( Qt ) (54)\nQt , dmt dm0 = ∂mt ∂mt−1\nQt−1 = V diag ( h̃′(mt−1) ) Qt−1 (55)\nQ0 , I . (56)"
    }, {
      "heading" : "C Bounding Linearization Error",
      "text" : "Proposition Assume n ≥ 5, cf ≥ 12π ∑ j,k ‖ d2f dxj dxk ‖n 2 and ρ2cf 1 σ2 ≤ . Then if follows that ∀x ; ‖x− x0‖ ≤ ρ⇒ |g(x0) + (x− x0)T∇g(x0)− g(x)| ≤ .\nProof First we claim that 12Λg ≤ 1 2πσ2 ∑ j,k ‖ d2f dxj dxk ‖n 2 . We prove this claim as below,\n1 2 Λg ≤ max x ‖∇2g(x)‖F (57)\n≤ max x ∑ j,k | d 2g dxj dxk (x)| (58)\n≤ ∑ j,k max x | d 2g dxj dxk (x)| (59)\n= ∑ j,k ‖ d 2g dxj dxk ‖∞ (60)\n= ∑ j,k ‖ d 2f dxj dxk ? kσ‖∞ (61)\n≤ ∑ j,k ‖ d 2f dxj dxk ‖ p p−1 ‖kσ‖p (62)\n≤ (∑ j,k ‖ d 2f dxj dxk ‖ p p−1 )(∫ X kpσ(x) dx ) 1 p\n(63)\n≤ (∑ j,k ‖ d 2f dxj dxk ‖ p p−1 )( (2π)(1−p)σ2(1−p) p ) n 4p\n(64)\n= (∑ j,k ‖ d 2f dxj dxk ‖ p p−1 )( (2π)(1−p) p ) n 4p σ n(1−p) 2p , (65)\nwhere (62) is due to Young’s convolution inequality and holds for any p ≥ 1. In particular, when n ≥ 5, by setting p = nn−4 , we obtain\n1 2 Λg ≤ (∑ j,k ‖ d 2f dxj dxk ‖ p p−1 )( (2π)(1−p) p ) n 4p σ n(1−p) 2p (66)\n1 2 Λg = (∑ j,k ‖ d 2f dxj dxk ‖n 2 ) 1 2πσ2 ( 1− 4 n )n 4−1\n(67)\n1 2 Λg ≤ (∑ j,k ‖ d 2f dxj dxk ‖n 2 ) 1 2πσ2 . (68)\nThis proves our earlier claim that 12Λg ≤ 1 2πσ2 ∑ j,k ‖ d2f dxj dxk ‖n 2 . Combining\nthis with the assumption 12π ∑ j,k ‖ d2f dxj dxk ‖n 2 ≤ cf , it follows that 12Λg ≤ cf 1 σ2 , which implies 12ρ 2Λg ≤ ρ2cf 1σ2 . The latter combined with the assumption ρ2cf 1 σ2 ≤ yields 1 2ρ\n2Λg ≤ . Combining this with the Taylor’s remainder theorem |g(x0)+(x−x0)T∇g(x0)−g(x)| ≤ 12ρ\n2Λg gives |g(x0)+(x−x0)T∇g(x0)− g(x)| ≤ ."
    } ],
    "references" : [ {
      "title" : "Neural machine translation by jointly learning to align and translate",
      "author" : [ "Bahdanau et al", "D. 2014] Bahdanau", "K. Cho", "Y. Bengio" ],
      "venue" : null,
      "citeRegEx" : "al. et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2014
    }, {
      "title" : "Greedy layer-wise training of deep networks",
      "author" : [ "Bengio et al", "Y. 2007] Bengio", "P. Lamblin", "D. Popovici", "H. Larochelle" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "al. et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2007
    }, {
      "title" : "Marginalized denoising auto-encoders for nonlinear representations",
      "author" : [ "Chen et al", "M. 2014] Chen", "K.Q. Weinberger", "F. Sha", "Y. Bengio" ],
      "venue" : "In Proceedings of the 31st International Conference on Machine Learning",
      "citeRegEx" : "al. et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2014
    }, {
      "title" : "Identifying and attacking the saddle point problem in high-dimensional non-convex optimization",
      "author" : [ "Dauphin et al", "Y.N. 2014] Dauphin", "R. Pascanu", "C. Gulcehre", "K. Cho", "S. Ganguli", "Y. Bengio" ],
      "venue" : null,
      "citeRegEx" : "al. et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2014
    }, {
      "title" : "Randomized smoothing for stochastic optimization",
      "author" : [ "Duchi et al", "J.C. 2012] Duchi", "P.L. Bartlett", "M.J. Wainwright" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "al. et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2012
    }, {
      "title" : "Train faster, generalize better: Stability of stochastic gradient descent. CoRR, abs/1509.01240",
      "author" : [ "Hardt et al", "M. 2015] Hardt", "B. Recht", "Y. Singer" ],
      "venue" : null,
      "citeRegEx" : "al. et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2015
    }, {
      "title" : "On graduated optimization for stochastic non-convex problems. CoRR, abs/1503.03712",
      "author" : [ "Hazan et al", "E. 2015] Hazan", "K.Y. Levy", "S. Shalev-Shwartz" ],
      "venue" : null,
      "citeRegEx" : "al. et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2015
    }, {
      "title" : "Deep neural networks for acoustic modeling in speech recognition: The shared views of four research groups",
      "author" : [ "Hinton et al", "G.E. 2012a] Hinton", "L. Deng", "D. Yu", "G.E. Dahl", "A. Mohamed", "N. Jaitly", "A. Senior", "V. Vanhoucke", "P. Nguyen", "T.N. Sainath", "B. Kingsbury" ],
      "venue" : "IEEE Signal Process. Mag.,",
      "citeRegEx" : "al. et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2012
    }, {
      "title" : "Improving neural networks by preventing co-adaptation of feature detectors. CoRR, abs/1207.0580",
      "author" : [ "Hinton et al", "G.E. 2012b] Hinton", "N. Srivastava", "A. Krizhevsky", "I. Sutskever", "R. Salakhutdinov" ],
      "venue" : null,
      "citeRegEx" : "al. et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2012
    }, {
      "title" : "Generalization bounds for neural networks through tensor factorization. CoRR, abs/1506.08473",
      "author" : [ "Janzamin et al", "M. 2015] Janzamin", "H. Sedghi", "A. Anandkumar" ],
      "venue" : null,
      "citeRegEx" : "al. et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2015
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "Krizhevsky et al", "A. 2012] Krizhevsky", "I. Sutskever", "G.E. Hinton" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "al. et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2012
    }, {
      "title" : "Learning recurrent neural networks with hessian-free optimization",
      "author" : [ "Martens", "Sutskever", "J. 2011] Martens", "I. Sutskever" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Martens et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Martens et al\\.",
      "year" : 2011
    }, {
      "title" : "On the Link Between Gaussian Homotopy Continuation and Convex Envelope",
      "author" : [ "Mobahi", "Fisher III", "H. 2015] Mobahi", "J.W. Fisher III" ],
      "venue" : null,
      "citeRegEx" : "Mobahi et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Mobahi et al\\.",
      "year" : 2015
    }, {
      "title" : "Adding gradient noise improves learning for very deep networks. CoRR, abs/1511.06807",
      "author" : [ "Neelakantan et al", "A. 2015] Neelakantan", "L. Vilnis", "Q.V. Le", "I. Sutskever", "L. Kaiser", "K. Kurach", "J. Martens" ],
      "venue" : null,
      "citeRegEx" : "al. et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2015
    }, {
      "title" : "Annealed gradient descent for deep learning",
      "author" : [ "Pan", "Jiang", "H. 2015] Pan", "H. Jiang" ],
      "venue" : "In Proc. of 31th Conference on Uncertainty in Artificial Intelligence (UAI",
      "citeRegEx" : "Pan et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Pan et al\\.",
      "year" : 2015
    }, {
      "title" : "On the saddle point problem for non-convex optimization. CoRR, abs/1405.4604",
      "author" : [ "Pascanu et al", "R. 2014] Pascanu", "Y.N. Dauphin", "S. Ganguli", "Y. Bengio" ],
      "venue" : null,
      "citeRegEx" : "al. et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2014
    }, {
      "title" : "On the quality of the initial basin in overspecified neural networks. CoRR, abs/1511.04210",
      "author" : [ "Safran", "Shamir", "I. 2015] Safran", "O. Shamir" ],
      "venue" : null,
      "citeRegEx" : "Safran et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Safran et al\\.",
      "year" : 2015
    }, {
      "title" : "On the importance of initialization and momentum in deep learning",
      "author" : [ "Sutskever et al", "I. 2013] Sutskever", "J. Martens", "G. Dahl", "G. Hinton" ],
      "venue" : "In Proceedings of the 30th International Conference on Machine Learning (ICML-13)",
      "citeRegEx" : "al. et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2013
    }, {
      "title" : "Sequence to sequence learning with neural networks",
      "author" : [ "Sutskever et al", "I. 2014] Sutskever", "O. Vinyals", "Q.V. Le" ],
      "venue" : "Advances in Neural Information Processing Systems",
      "citeRegEx" : "al. et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2014
    }, {
      "title" : "`1regularized neural networks are improperly learnable in polynomial time",
      "author" : [ "Zhang et al", "Y. 2015] Zhang", "J.D. Lee", "M.I. Jordan" ],
      "venue" : "CoRR, abs/1510.03528",
      "citeRegEx" : "al. et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2015
    } ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "This work presents a new algorithm for training recurrent neural networks (although ideas are applicable to feedforward networks as well). The algorithm is derived from a theory in nonconvex optimization related to the diffusion equation. The contributions made in this work are two fold. First, we show how some seemingly disconnected mechanisms used in deep learning such as smart initialization, annealed learning rate, layerwise pretraining, and noise injection (as done in dropout and SGD) arise naturally and automatically from this framework, without manually crafting them into the algorithms. Second, we present some preliminary results on comparing the proposed method against SGD. It turns out that the new algorithm can achieve similar level of generalization accuracy of SGD in much fewer number of epochs.",
    "creator" : "LaTeX with hyperref package"
  }
}