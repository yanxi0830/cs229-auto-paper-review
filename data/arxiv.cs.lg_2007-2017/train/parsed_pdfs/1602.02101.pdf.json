{
  "name" : "1602.02101.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Variance-Reduced and Projection-Free Stochastic Optimization",
    "authors" : [ "Elad Hazan", "Haipeng Luo" ],
    "emails" : [ "ehazan@cs.princeton.edu", "haipengl@cs.princeton.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : ") to O(ln 1 ) if the objective function is smooth and strongly convex, and from O( 1 2 ) to O( 1 1.5 )\nif the objective function is smooth and Lipschitz. The theoretical improvement is also observed in experiments on real-world datasets for a multiclass classification application."
    }, {
      "heading" : "1 Introduction",
      "text" : "We consider the following optimization problem\nmin w∈Ω f(w) = min w∈Ω\n1\nn n∑ i=1 fi(w)\nwhich is an extremely common objective in machine learning. We are interested in the case where 1) n, usually corresponding to the number of training examples, is very large and therefore stochastic optimization is much more efficient; and 2) the domain Ω admits fast linear optimization, while projecting onto it is much slower, necessitating projection-free optimization algorithms. Examples of such problem include multiclass classification, multitask learning, recommendation systems, matrix learning and many more (see for example (Hazan & Kale, 2012; Hazan et al., 2012; Jaggi, 2013; Dudik et al., 2012; Zhang et al., 2012; Harchaoui et al., 2015)).\nThe Frank-Wolfe algorithm (Frank & Wolfe, 1956) (also known as conditional gradient) and it variants are natural candidates for solving these problems, due to its projection-free property and its ability to handle structured constraints. However, despite gaining more popularity recently, its applicability and efficiency in the stochastic learning setting, where computing stochastic gradients is much faster than computing exact gradients, is still relatively understudied compared to variants of projected gradient descent methods.\nIn this work, we thus try to answer the following question: how fast can a projection-free algorithm achieve in terms of the number of stochastic gradient evaluations and the number of linear optimizations needed to achieve a certain accuracy? Utilizing Nesterov’s acceleration technique (Nesterov, 1983) and the recent variance reduction idea (Johnson & Zhang, 2013; Mahdavi et al., 2013), we propose two new algorithms that are substantially faster than previous work. Specifically, to achieve 1− accuracy, while the number of linear optimization is the same as previous work, the improvement of the number of stochastic gradient evaluations is summarized in Table 1:\nThe extra overhead of our algorithms is computing at most O(ln 1 ) exact gradients, which is computationally insignificant compared to the other operations. A more detailed comparisons to previous work is included in Table 2, which will be further explained in Section 2.\nar X\niv :1\n60 2.\n02 10\n1v 1\n[ cs\n.L G\n] 5\nF eb\n2 01\nWhile the idea of our algorithms is quite straightforward, we emphasize that our analysis is non-trivial, especially for the second algorithm where the convergence of a sequence of auxiliary points in Nesterov’s algorithm needs to be shown.\nTo support our theoretical results, we also conducted experiments on three large real-word datasets for a multiclass classification application. These experiments show significant improvement over both previous projection-free algorithms and algorithms such as projected stochastic gradient descent and its variance-reduced version.\nThe rest of the paper is organized as follows: Section 2 setups the problem more formally and discusses related work. Our two new algorithms are presented and analyzed in Section 3 and 4, followed by experiment details in Section 5."
    }, {
      "heading" : "2 Preliminary and Related Work",
      "text" : "We assume each function fi is convex and L-smooth, that is, for any w,v ∈ Ω,\n∇fi(v)>(w − v) ≤ fi(w)− fi(v)\n≤ ∇fi(v)>(w − v) + L\n2 ‖w − v‖2 .\nWe will use two more important properties of smoothness. The first one is\n‖∇fi(w)−∇fi(v)‖2 ≤ 2L(fi(w)− fi(v)−∇fi(v)>(w − v))\n(1)\n(proven in Appendix A for completeness), and the second one is\nfi(λw + (1− λ)v) ≥\nλfi(w) + (1− λ)fi(v)− L\n2 λ(1− λ) ‖w − v‖2\n(2)\nfor any w,v ∈ Ω and λ ∈ [0, 1]. Notice that f = 1n ∑n i=1 fi is also L-smooth since smoothness is preserved under convex combinations. For some cases, we also assume each fi is G-Lipschitz: ‖∇fi(w)‖ ≤ G for any w ∈ Ω, and f (although not necessarily each fi) is α-strongly convex, that is,\nf(w)− f(v) ≤ ∇f(w)>(w − v)− α 2 ‖w − v‖2\nfor any w,v ∈ Ω. As usual, µ = Lα is called the condition number of f . We assume the domain Ω ∈ Rd is a compact convex set with diameter D. We are interested in the case where linear optimization on Ω, formally argminv∈Ωw >v for any w ∈ Rd, is much faster than projection onto Ω, formally argminv∈Ω ‖w − v‖ 2. Examples of such domains include the set of all bounded trace norm matrices, the convex hull of all rotation matrices, flow polytope and many more (see for instance (Hazan & Kale, 2012))."
    }, {
      "heading" : "2.1 Example Application: Multiclass Classification",
      "text" : "Consider a multiclass classification problem where a set of training examples (ei, yi)i=1,...,n is given beforehand. Here ei ∈ Rm is a feature vector and yi ∈ {1, . . . , h} is the label. Our goal is to find an accurate linear predictor, a matrixw = [w>1 ; . . . ,w > h ] ∈ Rh×m that predicts argmax`w>` e for any example e. Note that here the dimensionality d is hm. Previous work (Dudik et al., 2012; Zhang et al., 2012) found that finding w by minimizing a regularized multivariate logistic loss gives a very accurate predictor in general. Specifically, the objective can be written in our notation with\nfi(w) = log\n( 1 + ∑ 6̀=yi exp(w>` ei −w>yiei) )\nand Ω = {w ∈ Rh×m : ‖w‖∗ ≤ τ} where ‖·‖∗ denotes the matrix trace norm. In this case, projecting onto Ω is equivalent to performing an SVD, which takes O(hmmin{h,m}) time, while linear optimization on Ω amounts to finding the top singular vectors, which can be done in time linear to the number of non-zeros in the corresponding h by m matrix, and is thus much faster. One can also verify that each fi is smooth. The number of examples n can be prohibitively large for non-stochastic methods (for instance, tens of millions for the ImageNet dataset (Deng et al., 2009)), which makes stochastic optimization necessary."
    }, {
      "heading" : "2.2 Detailed Efficiency Comparisons",
      "text" : "We call ∇fi(w) a stochastic gradient for f at some w, where i is picked from {1, . . . , n} uniformly at random. Note that a stochastic gradient∇fi(w) is an unbiased estimator of the exact gradient∇f(w). The efficiency of a projectionfree algorithm is measured by how many numbers of exact gradient evaluations, stochastic gradient evaluations and linear optimizations respectively are needed to achieve 1 − accuracy, that is, to output a point w ∈ Ω such that E[f(w)− f(w∗)] ≤ where w∗ ∈ argminw∈Ω f(w) is any optimum.\nIn Table 2, we summarize the efficiency (and extra assumptions needed beside convexity and smoothness1) of\n1In general, condition “G-Lipschitz” in Table 2 means each fi is G-Lipschitz, except for our STORC algorithm which only requires f being G-Lipschitz.\nexisting algorithms in the literature as well as the two new algorithms we propose. Below we briefly explain these results from top to bottom.\nThe standard Frank-Wolfe algorithm:\nvk = argmin v∈Ω\n∇f(wk−1)>v\nwk = (1− γk)wk−1 + γkvk (3)\nfor some appropriate chosen γk requires O( 1 ) iteration without additional conditions (Frank & Wolfe, 1956; Jaggi, 2013). In a recent paper, Garber & Hazan (2013) give a variant that requiresO(dµρ ln 1 ) iterations when f is strongly convex and smooth, and Ω is a polytope2. Although the dependence on is much better, the geometric constant ρ depends on the polyhedral set and can be very large. Moreover, each iteration of the algorithm requires further computation besides the linear optimization step.\nThe most obvious way to obtain a stochastic Frank-Wolfe variant is to replace∇f(wk−1) by some∇fi(wk−1), or more generally the average of some number of iid samples of∇fi(wk−1) (mini-batch approach). We call this method SFW and include its analysis in Appendix B since we do not find it explicitly analyzed before. SFW needs O( 1 3 ) stochastic gradients and O( 1 ) linear optimization steps to reach an -approximate optimum.\nThe work by Hazan & Kale (2012) focuses on a online learning setting. One can extract two results from this work for the setting studied here.3 In any case, the result is worse than SFW for both the number of stochastic gradients and the number of linear optimizations.\nStochastic Condition Gradient Sliding (SCGS), recently proposed by Lan & Zhou (2014), uses Nesterov’s acceleration technique to speed up Frank-Wolfe. Without strong convexity, SCGS needs O( 1 2 ) stochastic gradients, improving SFW. With strong convexity, this number can even be improved to O( 1 ). In both cases, the number of linear optimization steps is O( 1 ).\nThe key idea of our algorithms is to combine the variance reduction technique proposed in (Johnson & Zhang, 2013; Mahdavi et al., 2013) with some of the above-mentioned algorithms. For example, our algorithm SVRF combines this technique with SFW, also improving the number of stochastic gradients from O( 1 3 ) to O( 1 2 ), but without any extra conditions (such as Lipschitzness required for SCGS). More importantly, despite having seemingly same convergence rate, SVRF substantially outperforms SCGS empirically (see Section 5).\nOn the other hand, our second algorithm STORC combines variance reduction with SCGS, providing even further improvements. Specifically, the number of stochastic gradients is improved to: O( 1 1.5 ) when f is Lipschitz; O( 1 ) when ∇f(w∗) = 0; and finally O(ln 1 ) when f is strongly convex. Note that the condition ∇f(w ∗) = 0 essentially means that w∗ is in the interior of Ω, but it is still an interesting case when the optimum is not unique and doing unconstraint optimization would not necessary return a point in Ω.\nBoth of our algorithms require O( 1 ) linear optimization steps as previous work, and overall require computing O(ln LD 2\n) exact gradients. However, we emphasize that this extra overhead is much more affordable compared to non-stochastic Frank-Wolfe (that is, computing exact gradients every iteration) since it does not have any polynomial dependence on parameters such as d, L or µ."
    }, {
      "heading" : "2.3 Variance-Reduced Stochastic Gradients",
      "text" : "Originally proposed in (Johnson & Zhang, 2013) and independently in (Mahdavi et al., 2013), the idea of variancereduced stochastic gradients is proven to be highly useful and has been extended to various different algorithms (such as (Frostig et al., 2015; Moritz et al., 2016)).\nA variance-reduced stochastic gradient at some point w ∈ Ω with some snapshot w0 ∈ Ω is defined as\n∇̃f(w;w0) = ∇fi(w)− (∇fi(w0)−∇f(w0)),\nwhere i is again picked from {1, . . . , n} uniformly at random. The snapshotw0 is usually a decision point from some previous iteration of the algorithm and its exact gradient ∇f(w0) has been pre-computed before, so that computing ∇̃f(w;w0) only requires two standard stochastic gradient evaluations: ∇fi(w) and ∇fi(w0).\n2See also recent follow up work Lacoste-Julien & Jaggi (2015). 3The first result comes from the setting where the online loss functions are stochastic, and the second one comes from a completely online\nsetting with the standard online-to-batch conversion.\nAlgorithm 1 Stochastic Variance-Reduced Frank-Wolfe (SVRF) 1: Input: Objective function f = 1n ∑n i=1 fi.\n2: Input: Parameters γk, mk and Nk. 3: Initialize: w0 = minw∈Ω∇f(x)>w for some arbitrary x ∈ Ω. 4: for t = 1, 2, . . . , T do 5: Take snapshot: x0 = wt−1 and compute ∇f(x0). 6: for k = 1 to Nt do 7: Compute ∇̃k, the average of mk iid samples of ∇̃f(xk−1,x0). 8: Compute vk = minv∈Ω ∇̃>k v. 9: Compute xk = (1− γk)xk−1 + γkvk.\n10: end for 11: Set wt = xNt . 12: end for\nA variance-reduced stochastic gradient is clearly also unbiased, that is, E[∇̃f(w;w0)] = ∇f(w). More importantly, the term ∇fi(w0) − ∇f(w0) serves as a correction term to reduce the variance of the stochastic gradient. Formally, one can prove the following\nLemma 1. For any w,w0 ∈ Ω, we have\nE[‖∇̃f(w;w0)−∇f(w)‖2] ≤ 6L(2E[f(w)− f(w∗)] + E[f(w0)− f(w∗)]).\nIn words, the variance of the variance-reduced stochastic gradient is bounded by how close the current point and the snapshot are to the optimum. The original work proves a bound on E[‖∇̃f(w;w0)‖2] under the assumption ∇f(w∗) = 0, which we do not require here. However, the main idea of the proof is similar and we defer it to Section 6."
    }, {
      "heading" : "3 Stochastic Variance-Reduced Frank-Wolfe",
      "text" : "With the previous discussion, our first algorithm is pretty straightforward: compared to the standard Frank-Wolfe, we simply replace the exact gradient with the average of a mini-batch of variance-reduced stochastic gradients, and take snapshots every once in a while. We call this algorithm Stochastic Variance-Reduced Frank-Wolfe (SVRF), whose pseudocode is presented in Alg 1. The convergence rate of this algorithm is shown in the following theorem.\nTheorem 1. With the following parameters,\nγk = 2\nk + 1 , mk = 96(k + 1), Nt = 2\nt+3 − 2,\nAlgorithm 1 ensures E[f(wt)− f(w∗)] ≤ LD 2\n2t+1 for any t.\nBefore proving this theorem, we first show a direct implication of this convergence result.\nCorollary 1. To achieve 1 − accuracy, Algorithm 1 requires O(ln LD 2 ) exact gradient evaluations, O( L2D4\n2 )\nstochastic gradient evaluations and O(LD 2 ) linear optimizations. Proof. According to the algorithm and the choice of parameters, it is clear that these three numbers are T + 1,∑T t=1 ∑Nt k=1mk = O(4T ) and ∑T t=1Nt = O(2T ) respectively. Theorem 1 implies that T should be of order Θ(log2 LD2 ). Plugging in all parameters concludes the proof.\nTo prove Theorem 1, we first consider a fixed iteration t and prove the following lemma:\nLemma 2. For any k, we have E[f(xk)− f(w∗)] ≤ 4LD 2 k+2 if E[‖∇̃s −∇f(xs−1)‖ 2] ≤ L 2D2 (s+1)2 for all s ≤ k.\nWe defer the proof of this lemma to Section 6 for coherence. With the help of Lemma 2, we are now ready to prove the main convergence result.\nProof of Theorem 1. We prove by induction. For t = 0, by smoothness, the optimality of w0 and convexity, we have\nf(w0) ≤ f(x) +∇f(x)>(w0 − x) + L\n2 ‖w0 − x‖2\n≤ f(x) +∇f(x)>(w∗ − x) + LD 2\n2\n≤ f(w∗) + LD 2\n2 .\nNow assuming E[f(wt−1)−f(w∗)] ≤ LD 2\n2t , we consider iteration t of the algorithm and use another induction to show E[f(xk)−f(w∗)] ≤ 4LD 2 k+2 for any k ≤ Nt. The base case is trivial sincex0 = wt−1. Suppose E[f(xs−1)−f(w ∗)] ≤ 4LD2\ns+1 for any s ≤ k. Now because ∇̃s is the average of ms iid samples of ∇̃f(xs−1;x0), its variance is reduced by a factor of ms. That is, with Lemma 1 we have\nE[‖∇̃s −∇f(xs−1)‖2]\n≤ 6L ms (2E[f(xs−1)− f(w∗)] + E[f(x0)− f(w∗)])\n≤ 6L ms\n( 8LD2\ns+ 1 + LD2 2t ) ≤ 6L ms ( 8LD2 s+ 1 + 8LD2 s+ 1 ) = L2D2 (s+ 1)2 ,\nwhere the last inequality is by the fact s ≤ Nt = 2t+3 − 2 and the last equality is by plugging the choice of ms. Therefore the condition of Lemma 2 is satisfied and the induction is completed. Finally with the choice of Nt we thus prove E[f(wt)− f(w∗)] = E[f(xNt)− f(w∗)] ≤ 4LD 2 Nt+2 = LD 2 2t+1 .\nWe remark that in Alg 1, we essentially restart the algorithm (that is, reseting k to 1) after taking a new snapshot. However, another option is to continue increasing k and never reset it. Although one can show that this only leads to constant speed up for the convergence, it provides more stable update and is thus what we implement in experiments."
    }, {
      "heading" : "4 Stochastic Variance-Reduced Conditional Gradient Sliding",
      "text" : "Our second algorithm apply variance reduction to the SCGS algorithm (Lan & Zhou, 2014). Again, the key difference is that we replace the stochastic gradients with the average of a mini-batch of variance-reduced stochastic gradients, and take snapshots every once in a while. See pseudocode in Alg 2 for details.\nThe algorithm makes use of two auxiliary sequences xk and zk (Line 8 and 12), which is standard for Nesterov’s algorithm. xk is obtained by approximately solving a square norm regularized linear optimization so that it is close to xk−1 (Line 11). Note that this step does not require computing any extra gradients of f or fi, and is done by performing the standard Frank-Wolfe algorithm (Eq. (3)) until the duality gap is at most a certain value ηt,k. The duality gap is a certificate of approximate optimality (see (Jaggi, 2013)), and is a side product of the linear optimization performed at each step, requiring no extra cost.\nAlso note that the stochastic gradients are computed at the sequence zk instead of yk, which is also standard in Nesterov’s algorithm. However, according to Lemma 1, we thus need to show the convergence rate of the auxiliary sequence zk, which appears to be rarely studied previously to the best our knowledge. This is one of the key steps in our analysis.\nThe main convergence result of STORC is the following:\nAlgorithm 2 STOchastic variance-Reduced Conditional gradient sliding (STORC) 1: Input: Objective function f = 1n ∑n i=1 fi.\n2: Input: Parameters γk, βk, ηt,k, mt,k and Nt. 3: Initialize: w0 = minw∈Ω∇f(x)>w for some arbitrary x ∈ Ω. 4: for t = 1, 2, . . . do 5: Take snapshot: y0 = wt−1 and compute ∇f(y0). 6: Initialize x0 = y0. 7: for k = 1 to Nt do 8: Compute zk = (1− γk)yk−1 + γkxk−1. 9: Compute ∇̃k, the average of mt,k iid samples of ∇̃f(zk;y0).\n10: Let g(x) = βk2 ‖x− xk−1‖ 2 + ∇̃>k x. 11: Compute xk, the output of using standard Frank-Wolfe to solve minx∈Ω g(x) until the duality gap is at most\nηt,k, that is, max x∈Ω ∇g(xk)>(xk − x) ≤ ηt,k . (4)\n12: Compute yk = (1− γk)yk−1 + γkxk. 13: end for 14: Set wt = yNt . 15: end for\nTheorem 2. With the following parameters (where Dt is defined later below):\nγk = 2\nk + 1 , βk =\n3L\nk , ηt,k = 2LD2t Ntk ,\nAlgorithm 2 ensures E[f(wt)− f(w∗)] ≤ LD 2\n2t+1 for any t if any of the following three cases holds:\n(a) ∇f(w∗) = 0 and Dt = D,Nt = d2 t 2 +2e,mt,k = 900Nt.\n(b) f is G-Lipschitz and Dt = D,Nt = d2 t 2 +2e,mt,k = 700Nt + 24NtG(k+1)LD .\n(c) f is α-strongly convex and D2t = µD2 2t−1 , Nt = d √ 32µe,mt,k = 5600Ntµ where µ = Lα .\nAgain we first give a direct implication of the above result:\nCorollary 2. To achieve 1 − accuracy, Algorithm 2 requires O(ln LD 2 ) exact gradient evaluations and O( LD2 ) linear optimizations. The numbers of stochastic gradient evaluations for Case (a), (b) and (c) are respectivelyO(LD 2 ), O(LD 2 + √ LD2G 1.5 ) and O(µ 2 ln LD 2 ).\nProof. Line 11 requires O(βkD 2\nηt,k ) iterations of the standard Frank-Wolfe algorithm since g(x) is βk-smooth (see e.g.\n(Jaggi, 2013, Theorem 2)). So the numbers of exact gradient evaluations, stochastic gradient evaluations and linear optimizations are respectively T + 1, ∑T t=1 ∑Nt k=1mt,k andO( ∑T t=1 ∑Nt k=1 βkD 2 ηt,k ). Theorem 2 implies that T should be of order Θ(log2 LD2 ). Plugging in all parameters proves the corollary.\nTo prove Theorem 2, we again first consider a fixed iteration t and use the following lemma, which is essentially proven in (Lan & Zhou, 2014). We include a distilled proof in Appendix C for completeness.\nLemma 3. Suppose 0 ≤ Dt ≤ D is such that E[‖y0−w∗‖2] ≤ D2t . For any k, we have E[f(yk)−f(w∗)] ≤ 8LD2t k(k+1) if E[‖∇̃s −∇f(zs)‖2] ≤ L 2D2t\nNt(s+1)2 for all s ≤ k.\nProof of Theorem 2. We prove by induction. The base case t = 0 holds by the exact same argument as in the proof of Theorem 1. Suppose E[f(wt−1)− f(w∗)] ≤ LD 2\n2t and consider iteration t. Below we use another induction to prove\nE[f(yk)− f(w∗)] ≤ 8LD2t k(k+1) for any 1 ≤ k ≤ Nt, which will concludes the proof since for any of the three cases, we have E[f(wt)− f(w∗)] = E[f(yNt)− f(w ∗)] ≤ 8LD 2 t N2t ≤ LD 2\n2t+1 . We first show that the condition E[‖y0 −w∗‖2] ≤ D2t holds. This is trivial for Case (a) and (b) when Dt = D. For Case (c), by strong convexity and the inductive assumption, we have E[‖y0 −w∗‖2] ≤ 2αE[f(y0) − f(w ∗)] ≤\nLD2\nα2t−1 = D 2 t .\nNext note that Lemma 1 implies\nE[‖∇̃s −∇f(zs)‖2]\n≤ 6L mt,s (2E[f(zs)− f(w∗)] + E[f(y0)− f(w∗)]).\nSo the key is to bound E[f(zs)− f(w∗)]. With z1 = y0 one can verify that E[‖∇̃1 −∇f(z1)‖2] ≤ 18Lmt,1E[f(y0)− f(w∗)] ≤ 18L 2D2\nmt,12t ≤ L 2D2t 4Nt holds for all three cases, and thus E[f(ys) − f(w∗)] ≤ 8LD2t s(s+1) holds for s = 1 by\nLemma 3. Now suppose it holds for any s < k, below we discuss the three cases separately to show that it also holds for s = k.\nCase (a). By smoothness, the condition ∇f(w∗) = 0, the construction of zs, and Cauchy-Schwarz inequality, we have for any 1 < s ≤ k,\nf(zs) ≤ f(ys−1) + (∇f(ys−1)−∇f(w∗))>(zs − ys−1)\n+ L\n2 ‖zs − ys−1‖2\n= f(ys−1) + γs(∇f(ys−1)−∇f(w∗))>(xs−1 − ys−1)\n+ Lγ2s\n2 ‖xs−1 − ys−1‖2\n≤ f(ys−1) + γsD‖∇f(ys−1)−∇f(w∗)‖+ LD2γ2s\n2 .\nProperty (1) and the optimality ofw∗ implies: ‖∇f(ys−1)−∇f(w∗)‖2 ≤ 2L(f(ys−1)−f(w∗)−∇f(w∗)>(ys−1− w∗)) ≤ 2L(f(ys−1) − f(w∗)). So subtracting f(w∗) and taking expectation on both sides, and applying Jensen’s inequality and the inductive assumption, we have\nE[f(zs)− f(w∗)] ≤ E[f(ys−1)− f(w∗)] + γsD √ 2LE[f(ys−1)− f(w∗)]\n+ 2LD2\n(s+ 1)2\n≤ 8LD 2\n(s− 1)s +\n8LD2 (s+ 1) √ (s− 1)s + 2LD2 (s+ 1)2 < 55LD2 (s+ 1)2 .\nOn the other hand, we have E[f(y0) − f(w∗)] ≤ LD 2 2t ≤ 16LD2 (Nt−1)2 < 40LD2 (Nt+1)2 ≤ 40LD 2 (s+1)2 . So E[‖∇̃s − ∇f(zs)‖ 2 is at most 900L 2D2\nmt,s(s+1)2 , and the choice of mt,s ensures that this bound is at most L\n2D2\nNt(s+1)2 , satisfying the condition of\nLemma 3 and thus completing the induction.\nCase (b). With the G-Lipschitz condition we proceed similarly as follows:\nf(zs) ≤ f(ys−1) +∇f(ys−1)>(zs − ys−1) + L\n2 ‖zs − ys−1‖2\n= f(ys−1) + γs∇f(ys−1)>(xs−1 − ys−1) + LD2γ2s\n2\n≤ f(ys−1) + γsGD + LD2γ2s\n2 .\nSo using bounds derived previously and the choice of mt,s, we bound E[‖∇̃s −∇f(zs)‖2 as follows:\n6L\nmt,s\n( 16LD2\n(s− 1)s +\n4GD s+ 1 +\n4LD2\n(s+ 1)2 +\n40LD2\n(s+ 1)2 ) < 6L\nmt,s\n( 4GD\ns+ 1 +\n116LD2\n(s+ 1)2\n) < L2D2\nNt(s+ 1)2 ,\nagain completing the induction.\nCase (c). Using the definition of zs and ys and direct calcalution, one can remove the dependence of xs and verify ys−1 = s+1 2s−1zs + s−2 2s−1ys−2 for any s ≥ 2. Now we apply Property (2) with λ = s+1 2s−1 :\nf(ys−1) ≥ s+ 1\n2s− 1 f(zs) + s− 2 2s− 1 f(ys−2)\n− L 2 (s+ 1)(s− 2) (2s− 1)2 ‖zs − ys−2‖2\n= f(w∗) + s+ 1\n2s− 1 (f(zs)− f(w∗))+\ns− 2 2s− 1 (f(ys−2)− f(w∗))− L(s− 2) 2(s+ 1) ‖ys−1 − ys−2‖2\n≥ f(w∗) + 1 2 (f(zs)− f(w∗))− L 2 ‖ys−1 − ys−2‖2,\nwhere the equality is by adding and subtracting f(w∗) and the fact ys−1 − ys−2 = s+12s−1 (zs − ys−2), and the last inequality is by f(ys−2) ≥ f(w∗) and trivial relaxations.\nRearranging gives f(zs) − f(w∗) ≤ 2(f(ys−1 − f(w∗)) + L‖ys−1 − ys−2‖2. Applying Cauchy-Schwarz inequality, strong convexity and the fact µ ≥ 1, we continue with\nf(zs)− f(w∗) ≤ 2(f(ys−1 − f(w∗)) + 2L(‖ys−1 −w∗‖2 + ‖ys−2 −w∗‖2) ≤ 2(f(ys−1 − f(w∗)) + 4µ(f(ys−1)− f(w∗) + f(ys−2)− f(w∗)) ≤ 6µ(f(ys−1 − f(w∗)) + 4µ(f(ys−2)− f(w∗)),\nFor s ≥ 3, we use the inductive assumption to show E[f(zs) − f(w∗)] ≤ 48µLD 2 t (s−1)s + 32µLD2t (s−2)(s−1) ≤ 448µLD2t (s+1)2 . The case for s = 2 can be verified similarly using the bound on E[f(y0) − f(w∗)]. Finally we bound the term E[f(y0) − f(w∗)] ≤ LD 2 2t = LD2t 2µ ≤ 32LD2t (Nt+1)2 ≤ 32LD 2 t (s+1)2 , and conclude that the variance E[‖∇̃s − ∇f(zs)‖ 2 is at most 6Lmt,s ( 896µLD2t (s+1)2 + 32LD2t (s+1)2 ) ≤ L2D2t Nt(s+1)2 , completing the induction by Lemma 3."
    }, {
      "heading" : "5 Experiments",
      "text" : "To support our theory, we conduct experiments in the multiclass classification problem mentioned in Sec 2.1. Three datasets are selected from the LIBSVM repository4 with relatively large number of features, categories and examples, summarized in the Table 3.\nRecall that the loss function is multivariate logistic loss and Ω is the set of matrices with bounded trace norm τ . We focus on how fast the loss decreases instead of the final test error rate so that the tuning of τ is less important, and is fixed to 50 throughout.\nWe compare six algorithms. Four of them (SFW, SCGS, SVRF, STORC) are projection-free as discussed, and the other two are standard projected stochastic gradient descent (SGD) and its variance-reduced version (SVRG (Johnson & Zhang, 2013)), both of which require expensive projection.\nFor most of the parameters in these algorithms, we roughly follow what the theory suggests. For example, the size of mini-batch of stochastic gradients at round k is set to k2, k3 and k respectively for SFW, SCGS and SVRF, and is fixed to 100 for the other three. The number of iterations between taking two snapshots for variance-reduced methods (SVRG, SVRF and STORC) are fixed to 50. The learning rate is set to the typical decaying sequence c/ √ k for SGD and a constant c′ for SVRG as the original work suggests for some best tuned c and c′. Since the complexity of computing gradients, performing linear optimization and projecting are very different, we measure the actual running time of the algorithms and see how fast the loss decreases. Results can be found in Figure 1, where one can clearly observe that for all datasets, SGD and SVRG are significantly slower compared to the others, due to the expensive projection step, highlighting the usefulness of projection-free algorithms. Moreover, we also observe large improvement gained from the variance reduction technique, especially when comparing SCGS and STORC, as well as SVF and SVRF on the aloi dataset. Interestingly, even though the STORC algorithm gives the best theoretical results, empirically the simpler algorithms SFW and SVRF tend to have consistent better performance.\n4https://www.csie.ntu.edu.tw/˜cjlin/libsvmtools/datasets/"
    }, {
      "heading" : "6 Omitted Proofs",
      "text" : "This section includes some previously omitted proofs."
    }, {
      "heading" : "6.1 Proof of Lemma 1",
      "text" : "Proof. Let Ei denotes the conditional expectation given all the past except the realization of i. We have\nEi[‖∇̃f(w;w0)−∇f(w)‖2] = Ei[‖∇fi(w)−∇fi(w0) +∇f(w0)−∇f(w)‖2] = Ei[‖(∇fi(w)−∇fi(w∗))− (∇fi(w0)−∇fi(w∗))\n+ (∇f(w0)−∇f(w∗))− (∇f(w)−∇f(w∗))‖2] ≤ 3Ei[‖∇fi(w)−∇fi(w∗)‖2 + ‖(∇fi(w0)−∇fi(w∗)) − (∇f(w0)−∇f(w∗))‖2 + ‖∇f(w)−∇f(w∗)‖2] ≤ 3Ei[‖∇fi(w)−∇fi(w∗)‖2 + ‖∇fi(w0)−∇fi(w∗)‖2\n+ ‖∇f(w)−∇f(w∗)‖2]\nwhere the first inequality is Cauchy-Schwarz inequality, and the second one is by the fact Ei[∇fi(w0)−∇fi(w∗)] = ∇f(w0)−∇f(w∗) and that the variance of a random variable is bounded by its second moment.\nWe now apply Property (1) to bound each of the three terms above. For example, Ei‖∇fi(w) − ∇fi(w∗)‖2 ≤ 2LEi[fi(w)− fi(w∗)−∇fi(w∗)>(w−w∗)] = 2L(f(w)− f(w∗)−∇f(w∗)>(w−w∗)) ≤ 2L(f(w)− f(w∗)) where the last step is by the optimality of w∗. Proceeding similarly for the other two terms concludes the proof."
    }, {
      "heading" : "6.2 Proof of Lemma 2",
      "text" : "Proof. For any s ≤ k, by smoothness we have f(xs) ≤ f(xs−1) + ∇f(xs−1)>(xs − xs−1) + L2 ‖xs − xs−1‖ 2. Plugging in xs = (1− γs)xs−1 + γsvs gives f(xs) ≤ f(xs−1) + γs∇f(xs−1)>(vs − xs−1) + Lγ 2 s 2 ‖vs − xs−1‖ 2. Rewriting and using the fact that ‖vs−xs−1‖ ≤ D leads to f(xs) ≤ f(xs−1)+γs∇̃>s (vs−xs−1)+γs(∇f(xs−1)− ∇̃s)>(vs − xs−1) + LD 2γ2s 2 .\nThe optimality of vs implies ∇̃>s vs ≤ ∇̃>s w∗. So with further rewriting we arrive at f(xs) ≤ f(xs−1) + γs∇f(xs−1)>(w∗ − xs−1) + γs(∇f(xs−1)− ∇̃s)>(vs −w∗) + LD 2γ2s 2 .\nBy convexity, term∇f(xs−1)>(w∗−xs−1) is bounded by f(w∗)−f(xs−1), and by Cauchy-Schwarz inequality, term (∇f(xs−1)− ∇̃s)>(vs −w∗) is bounded by D‖∇̃s −∇f(xs−1)‖, which in expectation is at most LD 2\ns+1 by the condition on E[‖∇̃s −∇f(xs−1)‖2] and Jensen’s inequality. Therefore we arrive at\nE[f(xs)− f(w∗)]\n≤ (1− γs)E[f(xs−1)− f(w∗)] + LD2γs s+ 1 + LD2γ2s 2 = (1− γs)E[f(xs−1)− f(w∗)] + LD2γ2s .\nFinally we prove E[f(xk) − f(w∗)] ≤ 4LD 2 k+2 by induction. The base case is trival: E[f(x1) − f(w ∗)] ≤ (1 − γ1)E[f(x0) − f(w∗)] + LD2γ21 = LD2 since γ1 = 1. Suppose E[f(xs−1) − f(w∗)] ≤ 4LD 2 s+1 then with γs = 2 s+1 we have\nE[f(xs)− f(w∗)] ≤ 4LD2\ns+ 1\n( 1− 2\ns+ 1 +\n1\ns+ 1\n) ≤ 4LD 2\ns+ 2 ,\ncompleting the induction."
    }, {
      "heading" : "7 Conclusion and Open Problems",
      "text" : "We conclude that the variance reduction technique, previously shown to be highly useful for gradient descent variants, can also be very helpful in speeding up projection-free algorithms. The main open question is, in the strongly convex case, whether the number of stochastic gradients for STORC can be improved fromO(µ2 ln 1 ) toO(µ ln 1 ), which is typical for gradient descent methods, and whether the number of linear optimizations can be improved from O( 1 ) to O(ln 1 )."
    }, {
      "heading" : "B Analysis for SFW",
      "text" : "The concrete update of SFW is\nvk = argmin v∈Ω\n∇̃>k v\nwk = (1− γk)wk−1 + γkvk\nwhere ∇̃k is the average of mk iid samples of stochastic gradient ∇fi(wk−1). The convergence rate of SFW is presented below.\nTheorem 3. If each fi is G-Lipschitz, then with γk = 2k+1 and mk = ( G(k+1) LD )2 , SFW ensures for any k,\nE[f(wk)− f(w∗)] ≤ 4LD2\nk + 2 .\nProof. Similar to the proof of Lemma 2, we first proceed as follows,\nf(wk) ≤ f(wk−1) +∇f(wk−1)>(wk −wk−1) + L\n2 ‖wk −wk−1‖2 (smoothness)\n= f(wk−1) + γk∇f(wk−1)>(vk −wk−1) + Lγ2k\n2 ‖vk − xk−1‖2 (wk −wk−1 = γk(vk −wk−1))\n≤ f(wk−1) + γk∇̃>k (vk −wk−1) + γk(∇f(wk−1)− ∇̃k)>(vk −wk−1) + LD2γ2k\n2 (‖vk −wk−1‖ ≤ D)\n≤ f(wk−1) + γk∇̃>k (w∗ −wk−1) + γk(∇f(wk−1)− ∇̃k)>(vk −wk−1) + LD2γ2k\n2 (by optimality of vk)\n= f(wk−1) + γk∇f(wk−1)>(w∗ −wk−1) + γk(∇f(wk−1)− ∇̃k)>(vk −w∗) + LD2γ2k\n2\n≤ f(wk−1) + γk(f(w∗)− f(wk−1)) + γkD‖∇̃k −∇f(wk−1)‖+ LD2γ2k\n2 ,\nwhere the last step is by convexity and Cauchy-Schwarz inequality. Since fi is G-Lipschitz, with Jensen’s inequality, we further have E[‖∇̃k−∇f(wk−1)‖] ≤ √ E[‖∇̃k −∇f(wk−1)‖2] ≤ G√mk , which is at most LDγk 2 with the choice of γk and mk. So we arrive at E[f(wk) − f(w∗)] ≤ (1 − γk)E[f(wk−1) − f(w∗)] + LD2γ2k . It remains to use a simple induction to conclude the proof.\nNow it is clear that to achieve 1 − accuracy, SFW needs O(LD 2 ) iterations, and in total O( G2 L2D2 ( LD2 ) 3) =\nO(G 2LD4 3 ) stochastic gradients."
    }, {
      "heading" : "C Proof of Lemma 3",
      "text" : "Proof. Let δs = ∇̃s −∇f(zs). For any s ≤ k, we proceed as follows:\nf(ys) ≤ f(zs) +∇f(zs)>(ys − zs) + L\n2 ‖ys − zs‖ 2 (by smoothness)\n= (1− γs)(f(zs) +∇f(zs)>(ys−1 − zs)) + γs(f(zs) +∇f(zs)>(w∗ − zs)) + γs∇f(zs)>(xs −w∗)\n+ Lγ2s\n2 ‖xs − xs−1‖2 (by definition of ys and zs)\n≤ (1− γs)f(ys−1) + γsf(w∗) + γs∇f(zs)>(xs −w∗) + Lγ2s\n2 ‖xs − xs−1‖2 (by convexity)\n= (1− γs)f(ys−1) + γsf(w∗) + γs∇̃>s (xs −w∗) + Lγ2s\n2 ‖xs − xs−1‖2 + γsδ>s (w∗ − xs)\n≤ (1− γs)f(ys−1) + γsf(w∗) + γsηt,s − γsβs(xs − xs−1)>(xs −w∗) + Lγ2s\n2 ‖xs − xs−1‖2 + γsδ>s (w∗ − xs)\n(by Eq. (4))\n= (1− γs)f(ys−1) + γsf(w∗) + γsηt,s + βsγs\n2 (‖xs−1 −w∗‖2 − ‖xs −w∗‖2)+\nγs 2\n( (Lγs − βs) ‖xs − xs−1‖2 + 2δ>s (xs−1 − xs) + 2δ > s (w ∗ − xs−1) )\n≤ (1− γs)f(ys−1) + γsf(w∗) + γsηt,s + βsγs\n2 (‖xs−1 −w∗‖2 − ‖xs −w∗‖2) + γs 2\n( ‖δs‖2\nβs − Lγs + 2δ>s (w ∗ − xs−1)\n) ,\nwhere the last inequality is by the fact βs ≥ Lγs and thus\n(Lγs − βs) ‖xs − xs−1‖2 + 2δ>s (xs−1 − xs) = ‖δs‖2\nβs − Lγs − (βs −Lγs) ∥∥∥∥xs − xs−1 − δsβs − Lγs ∥∥∥∥2 ≤ ‖δs‖2βs − Lγs .\nNote that E[δ>s (w∗ − xs−1)] = 0. So with the condition E[‖δs‖ 2 ] ≤ L 2D2t Nt(s+1)2 def = σ2s we arrive at\nE[f(ys)−f(w∗)] ≤ (1−γs)E[f(ys−1)−f(w∗)]+γs ( ηt,s +\nβs 2 (E[‖xs−1 −w∗‖2]− E[‖xs −w∗‖2]) + σ2s 2(βs − Lγs)\n) .\nNow define Γs = Γs−1(1 − γs) when s > 1 and Γ1 = 1. By induction, one can verify Γs = 2s(s+1) and the following:\nE[f(yk)− f(w∗)] ≤ Γk k∑ s=1 γs Γs ( ηt,s + βs 2 (E[‖xs−1 −w∗‖2]− E[‖xs −w∗‖2]) + σ2s 2(βs − Lγs) ) ,\nwhich is at most\nΓk k∑ s=1 γs Γs ( ηs + σ2s 2(βs − Lγs) ) + Γk 2 ( γ1β1 Γ1 E[‖x0 −w∗‖2] + k∑ s=2 ( γsβs Γs − γs−1βs−1 Γs−1 ) E[‖xs−1 −w∗‖2] ) .\nFinally plugging in the parameters γs, βs, ηt,s, Γs and the bound E[‖x0 −w∗‖2] ≤ D2t concludes the proof:\nE[f(yk)− f(w∗)] ≤ 2\nk(k + 1) k∑ s=1 k ( 2LD2t Ntk + LD2t 2Nt(k + 1) ) + 3LD2t k(k + 1) ≤ 8LD 2 t k(k + 1) ."
    } ],
    "references" : [ {
      "title" : "Imagenet: A large-scale hierarchical image database",
      "author" : [ "Deng", "Jia", "Dong", "Wei", "Socher", "Richard", "Li", "Li-Jia", "Kai", "Fei-Fei" ],
      "venue" : "In Computer Vision and Pattern Recognition,",
      "citeRegEx" : "Deng et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Deng et al\\.",
      "year" : 2009
    }, {
      "title" : "Lifted coordinate descent for learning with trace-norm regularization",
      "author" : [ "Dudik", "Miro", "Harchaoui", "Zaid", "Malick", "Jérôme" ],
      "venue" : "In Proceedings of the Fifteenth International Conference on Artificial Intelligence and Statistics,",
      "citeRegEx" : "Dudik et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Dudik et al\\.",
      "year" : 2012
    }, {
      "title" : "An algorithm for quadratic programming",
      "author" : [ "Frank", "Marguerite", "Wolfe", "Philip" ],
      "venue" : "Naval research logistics quarterly,",
      "citeRegEx" : "Frank et al\\.,? \\Q1956\\E",
      "shortCiteRegEx" : "Frank et al\\.",
      "year" : 1956
    }, {
      "title" : "Competing with the empirical risk minimizer in a single pass",
      "author" : [ "Frostig", "Roy", "Ge", "Rong", "Kakade", "Sham M", "Sidford", "Aaron" ],
      "venue" : "In Proceedings of the 28th Annual Conference on Learning Theory,",
      "citeRegEx" : "Frostig et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Frostig et al\\.",
      "year" : 2015
    }, {
      "title" : "A linearly convergent conditional gradient algorithm with applications to online and stochastic optimization",
      "author" : [ "Garber", "Dan", "Hazan", "Elad" ],
      "venue" : "arXiv preprint arXiv:1301.4666,",
      "citeRegEx" : "Garber et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Garber et al\\.",
      "year" : 2013
    }, {
      "title" : "Conditional gradient algorithms for norm-regularized smooth convex optimization",
      "author" : [ "Harchaoui", "Zaid", "Juditsky", "Anatoli", "Nemirovski", "Arkadi" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Harchaoui et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Harchaoui et al\\.",
      "year" : 2015
    }, {
      "title" : "Projection-free online learning",
      "author" : [ "Hazan", "Elad", "Kale", "Satyen" ],
      "venue" : "In Proceedings of the 29th International Conference on Machine Learning,",
      "citeRegEx" : "Hazan et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hazan et al\\.",
      "year" : 2012
    }, {
      "title" : "Near-optimal algorithms for online matrix prediction",
      "author" : [ "Hazan", "Elad", "Kale", "Satyen", "Shalev-Shwartz", "Shai" ],
      "venue" : "In COLT 2012 - The 25th Annual Conference on Learning Theory, June",
      "citeRegEx" : "Hazan et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hazan et al\\.",
      "year" : 2012
    }, {
      "title" : "Revisiting frank-wolfe: Projection-free sparse convex optimization",
      "author" : [ "Jaggi", "Martin" ],
      "venue" : "In Proceedings of the 30th International Conference on Machine Learning,",
      "citeRegEx" : "Jaggi and Martin.,? \\Q2013\\E",
      "shortCiteRegEx" : "Jaggi and Martin.",
      "year" : 2013
    }, {
      "title" : "Accelerating stochastic gradient descent using predictive variance reduction",
      "author" : [ "Johnson", "Rie", "Zhang", "Tong" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Johnson et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Johnson et al\\.",
      "year" : 2013
    }, {
      "title" : "On the global linear convergence of frank-wolfe optimization variants",
      "author" : [ "Lacoste-Julien", "Simon", "Jaggi", "Martin" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Lacoste.Julien et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lacoste.Julien et al\\.",
      "year" : 2015
    }, {
      "title" : "Conditional gradient sliding for convex optimization",
      "author" : [ "Lan", "Guanghui", "Zhou", "Yi" ],
      "venue" : "Optimization-Online preprint (4605),",
      "citeRegEx" : "Lan et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Lan et al\\.",
      "year" : 2014
    }, {
      "title" : "Mixed optimization for smooth functions",
      "author" : [ "Mahdavi", "Mehrdad", "Zhang", "Lijun", "Jin", "Rong" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Mahdavi et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Mahdavi et al\\.",
      "year" : 2013
    }, {
      "title" : "A linearly-convergent stochastic l-bfgs algorithm",
      "author" : [ "Moritz", "Philipp", "Nishihara", "Robert", "Jordan", "Michael I" ],
      "venue" : "In Proceedings of the Nineteenth International Conference on Artificial Intelligence and Statistics,",
      "citeRegEx" : "Moritz et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Moritz et al\\.",
      "year" : 2016
    }, {
      "title" : "Accelerated training for matrix-norm regularization: A boosting approach",
      "author" : [ "Zhang", "Xinhua", "Schuurmans", "Dale", "Yu", "Yao-liang" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Zhang et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "Examples of such problem include multiclass classification, multitask learning, recommendation systems, matrix learning and many more (see for example (Hazan & Kale, 2012; Hazan et al., 2012; Jaggi, 2013; Dudik et al., 2012; Zhang et al., 2012; Harchaoui et al., 2015)).",
      "startOffset" : 151,
      "endOffset" : 268
    }, {
      "referenceID" : 1,
      "context" : "Examples of such problem include multiclass classification, multitask learning, recommendation systems, matrix learning and many more (see for example (Hazan & Kale, 2012; Hazan et al., 2012; Jaggi, 2013; Dudik et al., 2012; Zhang et al., 2012; Harchaoui et al., 2015)).",
      "startOffset" : 151,
      "endOffset" : 268
    }, {
      "referenceID" : 14,
      "context" : "Examples of such problem include multiclass classification, multitask learning, recommendation systems, matrix learning and many more (see for example (Hazan & Kale, 2012; Hazan et al., 2012; Jaggi, 2013; Dudik et al., 2012; Zhang et al., 2012; Harchaoui et al., 2015)).",
      "startOffset" : 151,
      "endOffset" : 268
    }, {
      "referenceID" : 5,
      "context" : "Examples of such problem include multiclass classification, multitask learning, recommendation systems, matrix learning and many more (see for example (Hazan & Kale, 2012; Hazan et al., 2012; Jaggi, 2013; Dudik et al., 2012; Zhang et al., 2012; Harchaoui et al., 2015)).",
      "startOffset" : 151,
      "endOffset" : 268
    }, {
      "referenceID" : 12,
      "context" : "In this work, we thus try to answer the following question: how fast can a projection-free algorithm achieve in terms of the number of stochastic gradient evaluations and the number of linear optimizations needed to achieve a certain accuracy? Utilizing Nesterov’s acceleration technique (Nesterov, 1983) and the recent variance reduction idea (Johnson & Zhang, 2013; Mahdavi et al., 2013), we propose two new algorithms that are substantially faster than previous work.",
      "startOffset" : 344,
      "endOffset" : 389
    }, {
      "referenceID" : 1,
      "context" : "Previous work (Dudik et al., 2012; Zhang et al., 2012) found that finding w by minimizing a regularized multivariate logistic loss gives a very accurate predictor in general.",
      "startOffset" : 14,
      "endOffset" : 54
    }, {
      "referenceID" : 14,
      "context" : "Previous work (Dudik et al., 2012; Zhang et al., 2012) found that finding w by minimizing a regularized multivariate logistic loss gives a very accurate predictor in general.",
      "startOffset" : 14,
      "endOffset" : 54
    }, {
      "referenceID" : 0,
      "context" : "The number of examples n can be prohibitively large for non-stochastic methods (for instance, tens of millions for the ImageNet dataset (Deng et al., 2009)), which makes stochastic optimization necessary.",
      "startOffset" : 136,
      "endOffset" : 155
    }, {
      "referenceID" : 12,
      "context" : "The key idea of our algorithms is to combine the variance reduction technique proposed in (Johnson & Zhang, 2013; Mahdavi et al., 2013) with some of the above-mentioned algorithms.",
      "startOffset" : 90,
      "endOffset" : 135
    }, {
      "referenceID" : 12,
      "context" : "3 Variance-Reduced Stochastic Gradients Originally proposed in (Johnson & Zhang, 2013) and independently in (Mahdavi et al., 2013), the idea of variancereduced stochastic gradients is proven to be highly useful and has been extended to various different algorithms (such as (Frostig et al.",
      "startOffset" : 108,
      "endOffset" : 130
    }, {
      "referenceID" : 3,
      "context" : ", 2013), the idea of variancereduced stochastic gradients is proven to be highly useful and has been extended to various different algorithms (such as (Frostig et al., 2015; Moritz et al., 2016)).",
      "startOffset" : 151,
      "endOffset" : 194
    }, {
      "referenceID" : 13,
      "context" : ", 2013), the idea of variancereduced stochastic gradients is proven to be highly useful and has been extended to various different algorithms (such as (Frostig et al., 2015; Moritz et al., 2016)).",
      "startOffset" : 151,
      "endOffset" : 194
    }, {
      "referenceID" : 3,
      "context" : ", 2013), the idea of variancereduced stochastic gradients is proven to be highly useful and has been extended to various different algorithms (such as (Frostig et al., 2015; Moritz et al., 2016)). A variance-reduced stochastic gradient at some point w ∈ Ω with some snapshot w0 ∈ Ω is defined as ∇̃f(w;w0) = ∇fi(w)− (∇fi(w0)−∇f(w0)), where i is again picked from {1, . . . , n} uniformly at random. The snapshotw0 is usually a decision point from some previous iteration of the algorithm and its exact gradient ∇f(w0) has been pre-computed before, so that computing ∇̃f(w;w0) only requires two standard stochastic gradient evaluations: ∇fi(w) and ∇fi(w0). 2See also recent follow up work Lacoste-Julien & Jaggi (2015). 3The first result comes from the setting where the online loss functions are stochastic, and the second one comes from a completely online setting with the standard online-to-batch conversion.",
      "startOffset" : 152,
      "endOffset" : 718
    } ],
    "year" : 2016,
    "abstractText" : "The Frank-Wolfe optimization algorithm has recently regained popularity for machine learning applications due to its projection-free property and its ability to handle structured constraints. However, in the stochastic learning setting, it is still relatively understudied compared to the gradient descent counterpart. In this work, leveraging a recent variance reduction technique, we propose two stochastic Frank-Wolfe variants which substantially improve previous results in terms of the number of stochastic gradient evaluations needed to achieve 1 − accuracy. For example, we improve from O( 1 ) to O(ln 1 ) if the objective function is smooth and strongly convex, and from O( 1 2 ) to O( 1 1.5 ) if the objective function is smooth and Lipschitz. The theoretical improvement is also observed in experiments on real-world datasets for a multiclass classification application.",
    "creator" : "LaTeX with hyperref package"
  }
}