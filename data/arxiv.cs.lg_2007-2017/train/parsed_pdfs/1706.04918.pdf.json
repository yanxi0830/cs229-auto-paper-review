{
  "name" : "1706.04918.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Robust Submodular Maximization:  A Non-Uniform Partitioning Approach",
    "authors" : [ "Ilija Bogunovic", "Slobodan Mitrović", "Jonathan Scarlett", "Volkan Cevher" ],
    "emails" : [ "<ilija.bogunovic@epfl.ch>,", "<slobodan.mitrovic@epfl.ch>,", "<jonathan.scarlett@epfl.ch>,", "<volkan.cevher@epfl.ch>." ],
    "sections" : [ {
      "heading" : null,
      "text" : "√ k).\nIn this paper, we solve a key open problem raised therein, presenting a new Partitioned Robust (PRO) submodular maximization algorithm that achieves the same guarantee for more general τ = o(k). Our algorithm constructs partitions consisting of buckets with exponentially increasing sizes, and applies standard submodular optimization subroutines on the buckets in order to construct the robust solution. We numerically demonstrate the performance of PRO in data summarization and influence maximization, demonstrating gains over both the greedy algorithm and the algorithm of (Orlin et al., 2016)."
    }, {
      "heading" : "1. Introduction",
      "text" : "Discrete optimization problems arise frequently in machine learning, and are often NP-hard even to approximate. In the case of a set function exhibiting submodularity, one can efficiently perform maximization subject to cardinality constraints with a ( 1− 1e ) -factor approximation guarantee. Applications include influence maximization (Kempe et al., 2003), document summarization (Lin & Bilmes, 2011), sensor placement (Krause & Guestrin, 2007), and active learning (Krause & Golovin, 2012), just to name a few.\n1LIONS, EPFL, Switzerland 2LTHC, EPFL, Switzerland. Correspondence to: Ilija Bogunovic <ilija.bogunovic@epfl.ch>, Slobodan Mitrović <slobodan.mitrovic@epfl.ch>, Jonathan Scarlett <jonathan.scarlett@epfl.ch>, Volkan Cevher <volkan.cevher@epfl.ch>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nIn many applications of interest, one requires robustness in the solution set returned by the algorithm, in the sense that the objective value degrades as little as possible when some elements of the set are removed. For instance, (i) in influence maximization problems, a subset of the chosen users may decide not to spread the word about a product; (ii) in summarization problems, a user may choose to remove some items from the summary due to their personal preferences; (iii) in the problem of sensor placement for outbreak detection, some of the sensors might fail.\nIn situations where one does not have a reasonable prior distribution on the elements removed, or where one requires robustness guarantees with a high level of certainty, protecting against worst-case removals becomes important. This setting results in the robust submodular function maximization problem, in which we seek to return a set of cardinality k that is robust with respect to the worst-case removal of τ elements.\nThe robust problem formulation was first introduced in (Krause et al., 2008), and was further studied in (Orlin et al., 2016). In fact, (Krause et al., 2008) considers a more general formulation where a constant-factor approximation guarantee is impossible in general, but shows that one can match the optimal (robust) objective value for a given set size at the cost of returning a set whose size is larger by a logarithmic factor. In contrast, (Orlin et al., 2016) designs an algorithm that obtains the first constant-factor approximation guarantee to the above problem when τ = o( √ k). A key difference between the two frameworks is that the algorithm complexity is exponential in τ in (Krause et al., 2008), whereas the algorithm of (Orlin et al., 2016) runs in polynomial time.\nContributions. In this paper, we solve a key open problem posed in (Orlin et al., 2016), namely, whether a constantfactor approximation guarantee is possible for general τ = o(k), as opposed to only τ = o( √ k). We answer this question in the affirmative, providing a new Partitioned Robust (PRO) submodular maximization algorithm that attains a constant-factor approximation guarantee; see Table 1 for comparison of different algorithms for robust monotone submodular optimization with a cardinality constraint.\nar X\niv :1\n70 6.\n04 91\n8v 1\n[ st\nat .M\nL ]\n1 5\nJu n\n20 17\nAchieving this result requires novelty both in the algorithm and its mathematical analysis: While our algorithm bears some similarity to that of (Orlin et al., 2016), it uses a novel structure in which the constructed set is arranged into partitions consisting of buckets whose sizes increase exponentially with the partition index. A key step in our analysis provides a recursive relationship between the objective values attained by buckets appearing in adjacent partitions.\nIn addition to the above contributions, we provide the first empirical study beyond what is demonstrated for τ = 1 in (Krause et al., 2008). We demonstrate several scenarios in which our algorithm outperforms both the greedy algorithm and the algorithm of (Orlin et al., 2016)."
    }, {
      "heading" : "2. Problem Statement",
      "text" : "Let V be a ground set with cardinality |V | = n, and let f : 2V → R≥0 be a set function defined on V . The function f is said to be submodular if for any sets X ⊆ Y ⊆ V and any element e ∈ V \\ Y , it holds that\nf(X ∪ {e})− f(X) ≥ f(Y ∪ {e})− f(Y ).\nWe use the following notation to denote the marginal gain in the function value due to adding the elements of a set Y to the set X:\nf(Y |X) := f(X ∪ Y )− f(X).\nIn the case that Y is a singleton of the form {e}, we adopt the shorthand f(e|X). We say that f is monotone if for any sets X ⊆ Y ⊆ V we have f(X) ≤ f(Y ), and normalized if f(∅) = 0.\nThe problem of maximizing a normalized monotone submodular function subject to a cardinality constraint, i.e.,\nmax S⊆V,|S|≤k f(S), (1)\nhas been studied extensively. A celebrated result of (Nemhauser et al., 1978) shows that a simple greedy algorithm that starts with an empty set and then iteratively adds elements with highest marginal gain provides a (1− 1/e)-approximation.\nIn this paper, we consider the following robust version of (1), introduced in (Krause et al., 2008):\nmax S⊆V,|S|≤k min Z⊆S,|Z|≤τ\nf(S \\ Z) (2)\nWe refer to τ as the robustness parameter, representing the size of the subset Z that is removed from the selected set S. Our goal is to find a set S such that it is robust upon the worst possible removal of τ elements, i.e., after the removal, the objective value should remain as large as possible. For τ = 0, our problem reduces to Problem (1).\nThe greedy algorithm, which is near-optimal for Problem (1) can perform arbitrarily badly for Problem (2). As an elementary example, let us fix ∈ [0, n− 1) and n ≥ 0, and consider the non-negative monotone submodular function given in Table 2. For k = 2, the greedy algorithm selects {s1, s2}. The set that maximizes mins∈S f(S\\s) (i.e., τ = 1) is {s1, s3}. For this set, mins∈{s1,s2} f({s1, s2} \\ s) = n − 1, while for the greedy set the robust objective value is . As a result, the greedy algorithm can perform arbitrarily worse.\nIn our experiments on real-world data sets (see Section 5), we further explore the empirical behavior of the greedy solution in the robust setting. Among other things, we observe that the greedy solution tends to be less robust when the objective value largely depends on the first few elements selected by the greedy rule.\nRelated work. (Krause et al., 2008) introduces the following generalization of (2):\nmax S⊆V,|S|≤k min i∈{1,··· ,n} fi(S), (3)\nwhere fi are normalized monotone submodular functions. The authors show that this problem is inapproximable in general, but propose an algorithm SATURATE which, when applied to (2), returns a set of size k(1+Θ(log(τk log n))) whose robust objective is at least as good as the optimal size-k set. SATURATE requires a number of function evaluations that is exponential in τ , making it very expensive to run even for small values. The work of (Powers et al., 2016) considers the same problem for different types of submodular constraints.\nRecently, robust versions of submodular maximization have been applied to influence maximization. In (He & Kempe, 2016), the formulation (3) is used to optimize a worst-case approximation ratio. The confidence interval setting is considered in (Chen et al., 2016), where two runs of the GREEDY algorithm (one pessimistic and one optimistic) are used to optimize the same ratio. By leveraging connections to continuous submodular optimization, (Staib & Jegelka, 2017) studies a related continuous robust budget allocation problem.\n(Orlin et al., 2016) considers the formulation in (2), and provides the first constant 0.387-factor approximation result, valid for τ = o( √ k). The algorithm proposed therein, which we refer to via the authors surnames as OSU, uses the greedy algorithm (henceforth referred to as GREEDY) as a sub-routine τ + 1 times. On each iteration, GREEDY is applied on the elements that are not yet selected on previous iterations, with these previously-selected elements ignored in the objective function. In the first τ runs, each solution is of size τ log k, while in the last run, the solution is of size k−τ2 log k. The union of all the obtained disjoint solutions leads to the final solution set."
    }, {
      "heading" : "3. Applications",
      "text" : "In this section, we provide several examples of applications where the robustness of the solution is favorable. The objective functions in these applications are non-negative, monotone and submodular, and are used in our numerical experiments in Section 5.\nRobust influence maximization. The goal in the influence maximization problem is to find a set of k nodes (i.e., a targeted set) in a network that maximizes some measure of influence. For example, this problem appears in viral marketing, where companies wish to spread the word of a new product by targeting the most influential individuals in a social network. Due to poor incentives or dissatisfaction with the product, for instance, some of the users from the\ntargeted set might make the decision not to spread the word about the product.\nFor many of the existing diffusion models used in the literature (e.g., see (Kempe et al., 2003)), given the targeted set S, the expected number of influenced nodes at the end of the diffusion process is a monotone and submodular function of S (He & Kempe, 2016). For simplicity, we consider a basic model in which all of the neighbors of the users in S become influenced, as well as those in S itself.\nMore formally, we are given a graph G = (V,E), where V stands for nodes and E are the edges. For a set S, letN (S) denote all of its neighboring nodes. The goal is to solve the robust dominating set problem, i.e., to find a set of nodes S of size k that maximizes\nmin |RS |≤τ,RS⊆S\n|(S \\RS) ∪N (S \\RS)|, (4)\nwhere RS ⊆ S represents the users that decide not to spread the word. The non-robust version of this objective function has previously been considered in several different works, such as (Mirzasoleiman et al., 2015b) and (NorouziFard et al., 2016).\nRobust personalized image summarization. In the personalized image summarization problem, a user has a collection of images, and the goal is to find k images that are representative of the collection.\nAfter being presented with a solution, the user might decide to remove a certain number of images from the representative set due to various reasons (e.g., bad lighting, motion blur, etc.). Hence, our goal is to find a set of images that remain good representatives of the collection even after the removal of some number of them.\nOne popular way of finding a representative set in a massive dataset is via exemplar based clustering, i.e., by minimizing the sum of pairwise dissimilarities between the exemplars S and the elements of the data set V . This problem can be posed as a submodular maximization problem subject to a cardinality constraint; cf., (Lucic et al., 2016).\nHere, we are interested in solving the robust summarization problem, i.e., we want to find a set of images S of size k that maximizes\nmin |RS |≤τ,RS⊆S\nf({e0})− f((S \\RS) ∪ {e0}), (5)\nwhere e0 is a reference element and f(S) = 1 |V | ∑ v∈V mins∈S d(s, v) is the k-medoid loss function, and where d(s, v) measures the dissimilarity between images s and v.\nFurther potential applications not covered here include robust sensor placement (Krause et al., 2008), robust protection of networks (Bogunovic & Krause, 2012), and robust feature selection (Globerson & Roweis, 2006)."
    }, {
      "heading" : "4. Algorithm and its Guarantees",
      "text" : ""
    }, {
      "heading" : "4.1. The algorithm",
      "text" : "Our algorithm, which we call the Partitioned Robust (PRO) submodular maximization algorithm, is presented in Algorithm 1. As the input, we require a non-negative monotone submodular function f : 2V → R≥0, the ground set of elements V , and an optimization subroutine A. The subroutineA(k′, V ′) takes a cardinality constraint k′ and a ground set of elements V ′. Below, we describe the properties of A that are used to obtain approximation guarantees.\nThe output of the algorithm is a set S ⊆ V of size k that is robust against the worst-case removal of τ elements. The returned set consists of two sets S0 and S1, illustrated in Figure 1. S1 is obtained by running the subroutine A on V \\ S0 (i.e., ignoring the elements already placed into S0), and is of size k − |S0|.\nWe refer to the set S0 as the robust part of the solution set S. It consists of dlog τe + 1 partitions, where every partition i ∈ {0, · · · , dlog τe} consists of dτ/2ie buckets Bj , j ∈ {1, · · · , dτ/2ie}. In partition i, every bucket contains 2iη elements, where η ∈ N+ is a parameter that is arbitrary for now; we use η = log2 k in our asymptotic theory, but our numerical studies indicate that even η = 1 works well in practice. Each bucket Bj is created afresh by using the subroutine A on V \\ S0,prev, where S0,prev contains all elements belonging to the previous buckets.\nThe following proposition bounds the cardinality of S0, and is proved in the supplementary material.\nProposition 4.1 Fix k ≥ τ and η ∈ N+. The size of the robust part S0 constructed in Algorithm 1 is\n|S0| = dlog τe∑ i=0 dτ/2ie2iη ≤ 3ητ(log k + 2).\nThis proposition reveals that the feasible values of τ (i.e., those with |S0| ≤ k) can be as high as O ( k ητ ) . We will later set η = O(log2 k), thus permitting all τ = o(k) up to a few logarithmic factors. In contrast, we recall that the algorithm OSU proposed in (Orlin et al., 2016) adopts a simpler approach where a robust set is used consisting of τ buckets of equal size τ log k, thereby only permitting the scaling τ = o( √ k).\nWe provide the following intuition as to why PRO succeeds despite having a smaller size for S0 compared to the algorithm given in (Orlin et al., 2016). First, by the design of the partitions, there always exists a bucket in partition i that at most 2i items are removed from. The bulk of our analysis is devoted to showing that the union of these buckets yields a sufficiently high objective value. While the earlier\nAlgorithm 1 Partitioned Robust Submodular optimization algorithm (PRO)\nRequire: Set V , k, τ , η ∈ N+, algorithm A Ensure: Set S ⊆ V such that |S| ≤ k\n1: S0, S1 ← ∅ 2: for i← 0 to dlog τe do 3: for j ← 1 to dτ/2ie do 4: Bj ← A (2iη, (V \\ S0)) 5: S0 ← S0 ∪Bj 6: S1 ← A (k − |S0|, (V \\ S0)) 7: S ← S0 ∪ S1 8: return S\nbuckets have a smaller size, they also have a higher objective value per item due to diminishing returns, and our analysis quantifies and balances this trade-off. Similarly, our analysis quantifies the trade-off between how much the adversary can remove from the (typically large) set S1 and the robust part S0."
    }, {
      "heading" : "4.2. Subroutine and assumptions",
      "text" : "PRO accepts a subroutine A as the input. We consider a class of algorithms that satisfy the β-iterative property, defined below. We assume that the algorithm outputs the final set in some specific order (v1, . . . , vk), and we refer to vi as the i-th output element.\nDefinition 4.2 Consider a normalized monotone submodular set function f on a ground set V , and an algorithmA. Given any set T ⊆ V and size k, suppose that A outputs an ordered set (v1, . . . , vk) when applied to T , and define Ai(T ) = {v1, . . . , vi} for i ≤ k. We say that A satisfies the β-iterative property if\nf(Ai+1(T ))− f(Ai(T )) ≥ 1\nβ max v∈T\nf(v|Ai(T )). (6)\nIntuitively, (6) states that in every iteration, the algorithm adds an element whose marginal gain is at least a 1/β fraction of the maximum marginal. This necessarily requires that β ≥ 1.\nExamples. Besides the classic greedy algorithm, which satisfies (6) with β = 1, a good candidate for our subroutine is THRESHOLDING-GREEDY (Badanidiyuru & Vondrák, 2014), which satisfies the β-iterative property with β = 1/(1− ). This decreases the number of function evaluations to O(n/ log n/ ).\nSTOCHASTIC-GREEDY (Mirzasoleiman et al., 2015a) is another potential subroutine candidate. While it is unclear whether this algorithm satisfies the β-iterative property, it requires an even smaller number of function eval-\nuations, namely, O(n log 1/ ). We will see in Section 5 that PRO performs well empirically when used with this subroutine. We henceforth refer to PRO used along with its appropriate subroutine as PRO-GREEDY, PRO-THRESHOLDING-GREEDY, and so on.\nProperties. The following lemma generalizes a classical property of the greedy algorithm (Nemhauser et al., 1978; Krause & Golovin, 2012) to the class of algorithms satisfying the β-iterative property. Here and throughout the paper, we use OPT(k, V ) to denote the following optimal set for non-robust maximization:\nOPT(k, V ) ∈ argmax S⊆V,|S|=k f(S),\nLemma 4.3 Consider a normalized monotone submodular function f : 2V → R≥0 and an algorithm A(T ), T ⊆ V , that satisfies the β-iterative property in (6). Let Al(T ) denote the set returned by the algorithm A(T ) after l iterations. Then for all k, l ∈ N+\nf(Al(T )) ≥ ( 1− e− l βk ) f(OPT(k, T )). (7)\nWe will also make use of the following property, which is implied by the β-iterative property.\nProposition 4.4 Consider a submodular set function f : 2V → R≥0 and an algorithm A that satisfies the βiterative property for some β ≥ 1. Then, for any T ⊆ V and element e ∈ V \\ A(T ), we have\nf(e|A(T )) ≤ β f(A(T )) k . (8)\nIntuitively, (8) states that the marginal gain of any nonselected element cannot be more than β times the average objective value of the selected elements. This is one of the rules used to define the β-nice class of algorithms in (Mirrokni & Zadimoghaddam, 2015); however, we note that in general, neither the β-nice nor β-iterative classes are a subset of one another."
    }, {
      "heading" : "4.3. Main result: Approximation guarantee",
      "text" : "For the robust maximization problem, we let OPT(k, V, τ) denote the optimal set:\nOPT(k, V, τ) ∈ argmax S⊆V,|S|=k min E⊆S,|E|≤τ f(S \\ E).\nMoreover, for a set S, we let E∗S denote the minimizer\nE∗S ∈ argmin E⊆S,|E|≤τ f(S \\ E). (9)\nWith these definitions, the main theoretical result of this paper is as follows.\nTheorem 4.5 Let f be a normalized monotone submodular function, and let A be a subroutine satisfying the βiterative property. For a given budget k and parameters 2 ≤ τ ≤ k3η(log k+2) and η ≥ 4(log k + 1), PRO returns a set S of size k such that\nf(S \\ E∗S) ≥ η 5β3dlog τe+η\n( 1− e− k−|S0| β(k−τ) ) 1 + η5β3dlog τe+η ( 1− e− k−|S0| β(k−τ)\n) × f(OPT(k, V, τ) \\ E∗OPT(k,V,τ)), (10)\nwhere E∗S and E ∗ OPT(k,V,τ) are defined as in (9). In addition, if τ = o (\nk η log k\n) and η ≥ log2 k, then we\nhave the following as k →∞:\nf(S \\ E∗S) ≥ ( 1− e−1/β\n2− e−1/β + o(1) ) × f(OPT(k, V, τ) \\ E∗OPT(k,V,τ)). (11)\nIn particular, PRO-GREEDY achieves an asymptotic approximation factor of at least 0.387, and PROTHRESHOLDING-GREEDY with parameter achieves an asymptotic approximation factor of at least 0.387(1− ).\nThis result solves an open problem raised in (Orlin et al., 2016), namely, whether a constant-factor approximation guarantee can be obtained for τ = o(k) as opposed to\nonly τ = o (√ k ) . In the asymptotic limit, our constant factor of 0.387 for the greedy subroutine matches that of (Orlin et al., 2016), but our algorithm permits significantly “higher robustness” in the sense of allowing larger τ values. To achieve this, we require novel proof techniques, which we now outline."
    }, {
      "heading" : "4.4. High-level overview of the analysis",
      "text" : "The proof of Theorem 4.5 is provided in the supplementary material. Here we provide a high-level overview of the main challenges.\nLet E denote a cardinality-τ subset of the returned set S that is removed. By the construction of the partitions, it is easy to verify that each partition i contains a bucket from which at most 2i items are removed. We denote these by B0, . . . , Bdlog τe, and write EBi := E ∩Bi. Moreover, we define E0 := E ∩ S0 and E1 := E ∩ S1.\nWe establish the following lower bound on the final objective function value:\nf(S \\E) ≥ max { f(S0 \\E0), f(S1)− f(E1|(S \\E)),\nf ( dlog τe⋃ i=0 (Bi \\ EBi) )} . (12)\nThe arguments to the first and third terms are trivially seen to be subsets of S \\ E, and the second term represents the utility of the set S1 subsided by the utility of the elements removed from S1.\nThe first two terms above are easily lower bounded by convenient expressions via submodular and the β-iterative property. The bulk of the proof is dedicated to bounding the third term. To do this, we establish the following recursive relations with suitably-defined “small” values of αj :\nf ( j⋃ i=0 (Bi \\ EBi) ) ≥ ( 1− 1 1 + 1αj ) f(Bj)\nf ( EBj ∣∣∣ j−1⋃ i=0 (Bi \\ EBi) ) ≤ αjf ( j−1⋃ i=0 (Bi \\ EBi) ) .\nIntuitively, the first equation shows that the objective value from buckets i = 0, . . . , j with removals cannot be too much smaller than the objective value in bucket j without removals, and the second equation shows that the loss in bucket j due to the removals is at most a small fraction of the objective value from buckets 0, . . . , j−1. The proofs of both the base case of the induction and the inductive step make use of submodularity properties and the β-iterative property (cf., Definition 4.2).\nOnce the suitable lower bounds are obtained for the terms in (12), the analysis proceeds similarly to (Orlin et al.,\n2016). Specifically, we can show that as the second term increases, the third term decreases, and accordingly lower bound their maximum by the value obtained when the two are equal. A similar balancing argument is then applied to the resulting term and the first term in (12).\nThe condition τ ≤ k3η(log k+2) follows directly from Proposition 4.1; namely, it is a sufficient condition for |S0| ≤ k, as is required by PRO."
    }, {
      "heading" : "5. Experiments",
      "text" : "In this section, we numerically validate the performance of PRO and the claims given in the preceding sections. In particular, we compare our algorithm against the OSU algorithm proposed in (Orlin et al., 2016) on different datasets and corresponding objective functions (see Table 3). We demonstrate matching or improved performance in a broad range of settings, as well as observing that PRO can be implemented with larger values of τ , corresponding to a greater robustness. Moreover, we show that for certain realworld data sets, the classic GREEDY algorithm can perform badly for the robust problem. We do not compare against SATURATE (Krause et al., 2008), due to its high computational cost for even a small τ .\nSetup. Given a solution set S of size k, we measure the performance in terms of the minimum objective value upon the worst-case removal of τ elements, i.e. minZ⊆S,|Z|≤τ f(S\\ Z). Unfortunately, for a given solution set S, finding such a set Z is an instance of the submodular minimization problem with a cardinality constraint,1 which is known to be NP-hard with polynomial approximation factors (Svitkina & Fleischer, 2011). Hence, in our experiments, we only implement the optimal “adversary” (i.e., removal of items) for small to moderate values of τ and k, for which we use a fast C++ implementation of branch-and-bound.\nDespite the difficulty in implementing the optimal adversary, we observed in our experiments that the greedy adversary, which iteratively removes elements to reduce the objective value as much as possible, has a similar impact on the objective compared to the optimal adversary for the data sets considered. Hence, we also provide a larger-scale experiment in the presence of a greedy adversary. Throughout, we write OA and GA to abbreviate the optimal adversary and greedy adversary, respectively.\nIn our experiments, the size of the robust part of the solution set (i.e., |S0|) is set to τ2 and τ log τ for OSU and PRO, respectively. That is, we set η = 1 in PRO, and similarly ignore constant and logarithmic factors in OSU, since both appear to be unnecessary in practice. We show\n1This can be seen by noting that for submodular f and any Z ⊆ X ⊆ V , f ′(Z) = f(X \\ Z) remains submodular.\nboth the “raw” objective values of the solutions, as well as the objective values after the removal of τ elements. In all experiments, we implement GREEDY using the LAZYGREEDY implementation given in (Minoux, 1978).\nThe objective functions shown in Table 3 are given in Section 3. For the exemplar objective function, we use d(s, v) = ‖s− v‖2, and let the reference element e0 be the zero vector. Instead of using the whole set V , we approximate the objective by considering a smaller random subset of V for improved computational efficiency. Since the objective is additively decomposable and bounded, standard concentration bounds (e.g., the Chernoff bound) ensure that the empirical mean over a random subsample can be made arbitrarily accurate.\nData sets. We consider the following datasets, along with the objective functions given in Section 3:\nResults. In the first set of experiments, we compare PROGREEDY (written using the shorthand PRO-GR in the legend) against GREEDY and OSU on the EGO-FACEBOOK and EGO-TWITTER datasets. In this experiment, the dominating set selection objective in (4) is considered. Figure 2 (a) and (c) show the results before and after the worst-case removal of τ = 7 elements for different values of k. In Figure 2 (b) and (d), we show the objective value for fixed k = 50 and k = 100, respectively, while the robustness parameter τ is varied.\nGREEDY achieves the highest raw objective value, followed by PRO-GREEDY and OSU. However, after the worst-case removal, PRO-GREEDY-OA outperforms both OSU-OA and GREEDY-OA. In Figure 2 (a) and (b), GREEDY-OA performs poorly due to a high concentration of the objective value on the first few elements selected by GREEDY. While OSU requires k ≥ τ2, PRO only requires k ≥ τ log τ , and hence it can be run for larger values of τ (e.g., see Figure 2 (b) and (c)). Moreover, in Figure 2 (a) and (b), we can observe that although PRO uses a smaller number of elements to build the robust part of the solution set, it has better robustness in comparison with OSU.\nIn the second set of experiments, we perform the same type of comparisons on the TINY10 and CM-MOLECULES datasets. The exemplar based clustering in (5) is used as the objective function. In Figure 2 (e) and (h), the robustness parameter is fixed to τ = 7 and τ = 6, respectively, while the cardinality k is varied. In Figure 2 (f) and (h), the cardinality is fixed to k = 100 and k = 50, respectively, while the robustness parameter τ is varied.\nAgain, GREEDY achieves the highest objective value. On the TINY10 dataset, GREEDY-OA (Figure 2 (e) and (f)) has a large gap between the raw and final objective, but it still slightly outperforms PRO-GREEDY-OA. This demonstrates that GREEDY can work well in some cases, despite failing in others. We observed that it succeeds here because the objective value is relatively more uniformly spread across the selected elements. On the same dataset, PRO-GREEDY-OA outperforms OSU-OA. On our second dataset CM-MOLECULES (Figure 2 (g) and (h)), PROGREEDY-OA achieves the highest robust objective value, followed by OSU-OA and GREEDY-OA.\nIn our final experiment (see Figure 2 (i)), we compare the performance of PRO-GREEDY against two instances of PRO-STOCHASTIC-GREEDY with = 0.01 and = 0.08 (shortened to PRO-ST in the legend), seeking to understand to what extent using the more efficient stochastic subroutine impacts the performance. We also show the performance of OSU. In this experiment, we fix k = 100 and vary τ . We use the greedy adversary instead of the optimal one, since the latter becomes computationally challenging for larger values of τ .\nIn Figure 2 (i), we observe a slight decrease in the objective value of PRO-STOCHASTIC-GREEDY due to the stochastic optimization. On the other hand, the gaps between the robust and non-robust solutions remain similar, or even shrink. Overall, we observe that at least in this example, the stochastic subroutine does not compromise the quality of the solution too significantly, despite having a lower computational complexity."
    }, {
      "heading" : "6. Conclusion",
      "text" : "We have provided a new Partitioned Robust (PRO) submodular maximization algorithm attaining a constantfactor approximation guarantee for general τ = o(k), thus\nresolving an open problem posed in (Orlin et al., 2016). Our algorithm uses a novel partitioning structure with partitions consisting of buckets with exponentially decreasing size, thus providing a “robust part” of size O(τpoly log τ). We have presented a variety of numerical experiments where PRO outperforms both GREEDY and OSU. A potentially interesting direction for further research is to understand the linear regime, in which τ = αk for some constant α ∈ (0, 1), and in particular, to seek a constant-factor guarantee for this regime.\nAcknowledgment. This work was supported in part by the European Commission under Grant ERC Future Proof, SNF 200021-146750 and SNF CRSII2-147633, and ‘EPFL Fellows’ (Horizon2020 665667)."
    }, {
      "heading" : "A. Proof of Proposition 4.1",
      "text" : "We have\n|S0| = dlog τe∑ i=0 dτ/2ie2iη\n≤ dlog τe∑ i=0 ( τ 2i + 1 ) 2iη ≤ η(dlog τe+ 1)(τ + 2dlog τe) ≤ 3ητ(dlog τe+ 1) ≤ 3ητ(log k + 2)."
    }, {
      "heading" : "B. Proof of Proposition 4.4",
      "text" : "Recalling that Aj(T ) denotes a set constructed by the algorithm after j iterations, we have\nf(Aj(T ))− f(Aj−1(T )) ≥ 1\nβ max e∈T\nf(e|Aj−1(T ))\n≥ 1 β max e∈T f(e|Ak(T ))\n≥ 1 β max e∈T\\Ak(T ) f(e|Ak(T )), (13)\nwhere the first inequality follows from the β-iterative property (6), and the second inequality follows from Aj−1(S) ⊆ Ak(S) and the submodularity of f .\nContinuing, we have\nf(Ak(T )) = k∑ j=1 f(Aj(T ))− f(Aj−1(T ))\n≥ k β max e∈T\\Ak(T ) f(e|Ak(T )),\nwhere the last inequality follows from (13).\nBy rearranging, we have for any e ∈ T \\ Ak(T ) that\nf(e|Ak(T )) ≤ β f(Ak(T ))\nk ."
    }, {
      "heading" : "C. Proof of Lemma 4.3",
      "text" : "Recalling that Aj(T ) denotes the set constructed after j iterations when applied to T , we have\nmax e∈T\\Aj−1(T )\nf(e|Aj−1(T )) ≥ 1\nk ∑ e∈OPT(k,T )\\Aj−1(T ) f(e|Aj−1(T ))\n≥ 1 k f(OPT(k, T )|Aj−1(T )) ≥ 1 k ( f(OPT(k, T ))− f(Aj−1(T )) ) , (14)\nwhere the first line holds since the maximum is lower bounded by the average, the line uses submodularity, and the last line uses monotonicity.\nBy combining the β-iterative property with (14), we obtain\nf(Aj(T ))− f(Aj−1(T )) ≥ 1\nβ max e∈T\\Aj−1(T ) f(e|Aj−1(T ))\n≥ 1 kβ\n( f(OPT(k, T ))− f(Aj−1(T )) ) .\nBy rearranging, we obtain f(OPT(k, T ))− f(Aj−1(T )) ≤ βk ( f(Aj(T ))− f(Aj−1(T )) ) . (15)\nWe proceed by following the steps from the proof of Theorem 1.5 in (Krause & Golovin, 2012). Defining δj := f(OPT(k, T ))− f(Aj(T )), we can rewrite (15) as δj−1 ≤ βk(δj−1 − δj). By rearranging, we obtain\nδj ≤ (\n1− 1 βk\n) δj−1.\nApplying this recursively, we obtain δl ≤ ( 1− 1βk )l δ0, where δ0 = f(OPT(k, T )) since f is normalized (i.e., f(∅) = 0). Finally, applying 1− x ≤ e−x and rearranging, we obtain\nf(Al(T )) ≥ ( 1− e− l βk ) f(OPT(k, T ))."
    }, {
      "heading" : "D. Proof of Theorem 4.5",
      "text" : "D.1. Technical Lemmas\nWe first provide several technical lemmas that will be used throughout the proof. We begin with a simple property of submodular functions.\nLemma D.1 For any submodular function f on a ground set V , and any sets A,B,R ⊆ V , we have\nf(A ∪B)− f(A ∪ (B \\R)) ≤ f(R | A).\nProof. Define R2 := A ∩R, and R1 := R \\A = R \\R2. We have\nf(A ∪B)− f(A ∪ (B \\R)) = f(A ∪B)− f((A ∪B) \\R1) = f(R1 | (A ∪B) \\R1) ≤ f(R1 | (A \\R1)) (16) = f(R1 | A) (17) = f(R1 ∪R2 | A) (18) = f(R | A),\nwhere (16) follows from the submodularity of f , (17) follows since A and R1 are disjoint, and (18) follows since R2 ⊆ A. 2\nThe next lemma provides a simple lower bound on the maximum of two quantities; it is stated formally since it will be used on multiple occasions.\nLemma D.2 For any set function f , sets A,B, and constant α > 0, we have max{f(A), f(B)− αf(A)} ≥ ( 1\n1 + α\n) f(B), (19)\nand\nmax{αf(A), f(B)− f(A)} ≥ ( α\n1 + α\n) f(B). (20)\nProof. Starting with (19), we observe that one term is increasing in f(A) and the other is decreasing in f(A). Hence, the maximum over all possible f(A) is achieved when the two terms are equal, i.e., f(A) = 11+αf(B). We obtain (20) via the same argument. 2\nThe following lemma relates the function values associated with two buckets formed by PRO, denoted by X and Y . It is stated with respect to an arbitrary set EY , but when we apply the lemma, this will correspond to the elements of Y that are removed by the adversary.\nLemma D.3 Under the setup of Theorem 4.5, let X and Y be buckets of PRO such that Y is constructed at a later time than X . For any set EY ⊆ Y , we have\nf(X ∪ (Y \\ EY )) ≥ 1\n1 + α f(Y ),\nand f(EY | X) ≤ αf(X), (21)\nwhere α = β |EY ||X| .\nProof. Inequality (21) follows from the β-iterative property of A; specifically, we have from (8) that\nf(e|X) ≤ β f(X) |X| ,\nwhere e is any element of the ground set that is neither in X nor any bucket constructed before X . Hence, we can write\nf(EY | X) ≤ ∑ e∈EY f(e|X) ≤ β |EY | |X| f(X) = αf(X),\nwhere the first inequality is by submodularity. This proves (21).\nNext, we write\nf(Y )− f(X ∪ (Y \\ EY )) ≤ f(X ∪ Y )− f(X ∪ (Y \\ EY )) (22) ≤ f(EY | X), (23)\nwhere (22) is by monotonicity, and (23) is by Lemma D.1 with A = X , B = Y , and R = EY .\nCombining (21) and (23), together with the fact that f(X ∪ (Y \\ EY )) ≥ f(X) (by monotonicity), we have\nf(X ∪ (Y \\ EY )) ≥ max {f(X), f(Y )− αf(X)}\n≥ 1 1 + α f(Y ), (24)\nwhere (24) follows from (19). 2\nFinally, we provide a lemma that will later be used to take two bounds that are known regarding the previously-constructed buckets, and use them to infer bounds regarding the next bucket.\nLemma D.4 Under the setup of Theorem 4.5, let Y and Z be buckets of PRO such that Z is constructed at a later time than Y , and let EY ⊆ Y and EZ ⊆ Z be arbitrary sets. Moreover, let X be a set (not necessarily a bucket) such that\nf((Y \\ EY ) ∪X) ≥ 1\n1 + α f(Y ), (25)\nand f(EY | X) ≤ αf(X). (26)\nThen, we have f(EZ | (Y \\ EY ) ∪X) ≤ αnextf((Y \\ EY ) ∪X), (27)\nand f((Z \\ EZ) ∪ (Y \\ EY ) ∪X) ≥\n1\n1 + αnext f(Z), (28)\nwhere\nαnext = β |EZ | |Y | (1 + α) + α. (29)\nProof. We first prove (27):\nf(EZ | (Y \\ EY ) ∪X) = f((Y \\ EY ) ∪X ∪ EZ)− f((Y \\ EY ) ∪X) ≤ f(X ∪ Y ∪ EZ)− f((Y \\ EY ) ∪X) (30) = f(EZ | X ∪ Y ) + f(X ∪ Y )− f((Y \\ EY ) ∪X) ≤ f(EZ | Y ) + f(X ∪ Y )− f((Y \\ EY ) ∪X) (31)\n≤ β |EZ | |Y | f(Y ) + f(X ∪ Y )− f((Y \\ EY ) ∪X) (32)\n≤ β |EZ | |Y | (1 + α)f((Y \\ EY ) ∪X) + f(X ∪ Y )− f((Y \\ EY ) ∪X) (33)\n≤ β |EZ | |Y | (1 + α)f((Y \\ EY ) ∪X) + f(EY | (Y \\ EY ) ∪X) (34)\n≤ β |EZ | |Y | (1 + α)f((Y \\ EY ) ∪X) + f(EY | X) (35)\n≤ β |EZ | |Y | (1 + α)f((Y \\ EY ) ∪X) + αf(X) (36)\n≤ β |EZ | |Y | (1 + α)f((Y \\ EY ) ∪X) + αf((Y \\ EY ) ∪X) (37)\n= ( β |EZ | |Y | (1 + α) + α ) f((Y \\ EY ) ∪X)., (38)\nwhere: (30) and (31) follow by monotonicity and submodularity, respectively; (32) follows from the second part of Lemma D.3; (33) follows from (25); (34) is obtained by applying Lemma D.1 for A = X , B = Y , and R = EY ; (35) follows by submodularity; (36) follows from (26); (37) follows by monotonicity. Finally, by defining αnext := β |EZ ||Y | (1 + α) + α in (38) we establish the bound in (27).\nIn the rest of the proof, we show that (28) holds as well. First, we have\nf((Z \\ EZ) ∪ (Y \\ EY ) ∪X) ≥ f(Z)− f(EZ | (Y \\ EY ) ∪X) (39)\nby Lemma D.1 with B = Z, R = EZ and A = (Y \\EY )∪X . Now we can use the derived bounds (38) and (39) to obtain\nf((Z \\ EZ) ∪ (Y \\ EY ) ∪X) ≥ f(Z)− f(EZ | (Y \\ EY ) ∪X) ≥ f(Z)− ( β |EZ | |Y | (1 + α) + α ) f((Y \\ EY ) ∪X).\nFinally, we have f((Z \\ EZ) ∪ (Y \\ EY ) ∪X) ≥ max { f((Y \\ EY ) ∪X), f(Z)− ( β |EZ | |Y | (1 + α) + α ) f((Y \\ EY ) ∪X) } ≥ 1\n1 + αnext f(Z),\nwhere the last inequality follows from Lemma D.1. 2\nObserve that the results we obtain on f(EZ | (Y \\ EY ) ∪X) and on f((Z \\ EZ) ∪ (Y \\ EY ) ∪X) in Lemma D.4 are of the same form as the pre-conditions of the lemma. This will allow us to apply the lemma recursively.\nD.2. Characterizing the Adversary\nLet E denote a set of elements removed by an adversary, where |E| ≤ τ . Within S0, PRO constructs dlog τe+1 partitions. Each partition i ∈ {0, . . . , dlog τe} consists of dτ/2ie buckets, each of size 2iη, where η ∈ N will be specified later. We let B denote a generic bucket, and define EB to be all the elements removed from this bucket, i.e. EB = B ∩ E.\nThe following lemma identifies a bucket in each partition for which not too many elements are removed.\nLemma D.5 Under the setup of Theorem 4.5, suppose that an adversary removes a set E of size at most τ from the set S constructed by PRO. Then for each partition i, there exists a bucket Bi such that |EBi | ≤ 2i, i.e., at most 2i elements are removed from this bucket.\nProof. Towards contradiction, assume that this is not the case, i.e., assume |EBi | > 2i for every bucket of the i-th partition. As the number of buckets in partition i is dτ/2ie, this implies that the adversary has to spend a budget of\n|E| ≥ 2i|EBi | > 2idτ/2ie = τ,\nwhich is in contradiction with |E| ≤ τ . 2 We consider B0, . . . , Bdlog τe as above, and show that even in the worst case, f (⋃dlog τe i=0 (Bi \\ EBi) ) is almost as large\nas f ( Bdlog τe ) for appropriately set η. To achieve this, we apply Lemma D.4 multiple times, as illustrated in the following lemma. We henceforth write ηh := η/2 for brevity.\nLemma D.6 Under the setup of Theorem 4.5, suppose that an adversary removes a set E of size at most τ from the set S constructed by PRO, and let B0, · · · , Bdlog τe be buckets such that |EBi | ≤ 2i for each i ∈ {1, · · · dlog τe} (cf., Lemma D.5). Then,\nf dlog τe⋃ i=0 (Bi \\ EBi)  ≥ (1− 1 1 + 1α ) f ( Bdlog τe ) = 1 1 + α f ( Bdlog τe ) , (40)\nand\nf EBdlog τe ∣∣∣ dlog τe−1⋃ i=0 (Bi \\ EBi)  ≤ αf dlog τe−1⋃ i=0 (Bi \\ EBi)  , (41) for some\nα ≤ β2 (1 + ηh) dlog τe − ηdlog τeh η dlog τe h . (42)\nProof. In what follows, we focus on the case where there exists some bucketB0 in partition i = 0 such thatB0\\EB0 = B0. If this is not true, then E must be contained entirely within this partition, since it contains τ buckets. As a result, (i) we trivially obtain (40) even when α is replaced by zero, since the union on the left-hand side contains Bdlog τe; (ii) (41) becomes trivial since the left-hand side is zero is a result of EBdlog τe = ∅.\nWe proceed by induction. Namely, we show that\nf ( j⋃ i=0 (Bi \\ EBi) ) ≥ ( 1− 1 1 + 1αj ) f(Bj) =\n1\n1 + αj f(Bj), (43)\nand\nf ( EBj ∣∣∣ j−1⋃ i=0 (Bi \\ EBi) ) ≤ αjf ( j−1⋃ i=0 (Bi \\ EBi) ) , (44)\nfor every j ≥ 1, where\nαj ≤ β2 (1 + ηh) j − ηjh ηjh . (45)\nUpon showing this, the lemma is concluded by setting j = dlog τe.\nBase case j = 1. In the case that j = 1, taking into account that EB0 = ∅, we observe from (43) that our goal is to bound f(B0 ∪ (B1 \\ EB1)). Applying Lemma D.3 with X = B0, Y = B1, and EY = EB1 , we obtain\nf(B0 ∪ (B1 \\ EB1)) ≥ 1\n1 + α1 f(B1),\nand f(EB1 | B0) ≤ α1f(B0),\nwhere α1 = β |EB1 | |B0| . We have |B0| = η, while |EB1 | ≤ 2 by assumption. Hence, we can upper bound α1 and rewrite as\nα1 ≤ β 2\nη = β\n1\nηh = β (1 + ηh)− ηh ηh ≤ β2 (1 + ηh)− ηh ηh ,\nwhere the last inequality follows since β ≥ 1 by definition.\nInductive step. Fix j ≥ 2. Assuming that the inductive hypothesis holds for j− 1, we want to show that it holds for j as well.\nWe write\nf ( j⋃ i=0 (Bi \\ EBi) ) = f (( j−1⋃ i=0 (Bi \\ EBi) ) ∪ (Bj \\ EBj ) ) ,\nand apply Lemma D.4 with X = ⋃j−2 i=0 (Bi \\ EBi), Y = Bj−1, EY = EBj−1 , Z = Bj , and EZ = EBj . Note that the conditions (25) and (26) of Lemma D.4 are satisfied by the inductive hypothesis. Hence, we conclude that (43) and (44) hold with\nαj = β |EBj | |Bj−1| (1 + αj−1) + αj−1.\nIt remains to show that (45) holds for αj , assuming it holds for αj−1. We have\nαj = β |EBj | |Bj−1| (1 + αj−1) + αj−1\n≤ β 1 ηh\n( 1 + β\n(1 + ηh) j−1 − ηj−1h ηj−1h\n) + β\n(1 + ηh) j−1 − ηj−1h ηj−1h\n(46)\n≤ β2 ( 1\nηh\n( 1 +\n(1 + ηh) j−1 − ηj−1h ηj−1h\n) +\n(1 + ηh) j−1 − ηj−1h ηj−1h\n) (47)\n= β2\n( 1\nηh\n(1 + ηh) j−1\nηj−1h + (1 + ηh) j−1 − ηj−1h ηj−1h\n)\n= β2\n( (1 + ηh) j−1\nηjh + ηh(1 + ηh) j−1 − ηjh ηjh\n)\n= β2 (1 + ηh) j − ηjh ηjh ,\nwhere (46) follows from (45) and the fact that\nβ |EBj | |Bj−1| ≤ β 2 j 2j−1η = β 2 η = β 1 ηh ,\nby |EBj | ≤ 2j and |Bj−1| = 2j−1η; and (47) follows since β ≥ 1. 2\nInequality (45) provides an upper bound on αj , but it is not immediately clear how the bound varies with j. The following lemma provides a more compact form.\nLemma D.7 Under the setup of Lemma D.6, we have for 2dlog τe ≤ ηh that\nαj ≤ 3β2 j\nη (48)\nProof. We unfold the right-hand side of (45) in order to express it in a simpler way. First, consider j = 1. From (45) we obtain α1 ≤ 2β2 1η , as required. For j ≥ 2, we obtain the following:\nβ−2αj ≤ (1 + ηh) j − ηjh ηjh\n= j−1∑ i=0 ( j i ) ηih ηjh\n(49)\n= j\nηh + j−2∑ i=0 ( j i ) ηih ηjh\n(50)\n= j\nηh + j−2∑ i=0 (∏j−i t=1(j − t+ 1)∏j−i t=1 t ηih ηjh )\n≤ j ηh + 1 2 j−2∑ i=0 jj−i ηih ηjh\n(51)\n= j\nηh +\n1\n2 j−2∑ i=0 ( j ηh )j−i\n= j\nηh +\n1\n2\n( −1− j\nηh + j∑ i=0 ( j ηh )j−i) ,\nwhere (49) is a standard summation identity, and (51) follows from ∏j−i t=1(j− t+ 1) ≤ jj−i and ∏j−i t=1 t ≥ 2 for j− i ≥ 2. Next, explicitly evaluating the summation of the last equality, we obtain\nβ−2αj ≤ j\nηh +\n1\n2 −1− j ηh + 1− ( j ηh )j+1 1− jηh  ≤ j ηh + 1 2 ( −1− j ηh + 1\n1− jηh\n)\n= j\nηh +\n1\n2\n ( j ηh )2 1− jηh  (52) = j\nηh +\nj\n2ηh\n( j ηh\n1− jηh\n) , (53)\nwhere (52) follows from (−a− 1)(−a+ 1) = a2 − 1 with a = j/ηh.\nNext, observe that if j/ηh ≤ 1/2, or equivalently 2j ≤ ηh, (54)\nthen we can weaken (53) to\nβ−2αj ≤ j\nηh +\nj\n2ηh =\n3\n2\nj\nηh = 3\nj η , (55)\nwhich yields (48).\n2\nD.3. Completing the Proof of Theorem 4.5\nWe now prove Theorem 4.5 in several steps. Throughout, we define µ to be a constant such that f(E1 | (S \\E)) = µf(S1) holds, and we write E0 := E∗S ∩ S0, E1 := E∗S ∩ S1, and EBi := E∗S ∩Bi, where E∗S is defined in (9). We also make use of the following lemma characterizing the optimal adversary. The proof is straightforward, and can be found in Lemma 2 of (Orlin et al., 2016)\nLemma D.8 (Orlin et al., 2016) Under the setup of Theorem 4.5, we have for all X ⊂ V with |X| ≤ τ that\nf(OPT(k, V, τ) \\ E∗OPT(k,V,τ)) ≤ f(OPT(k − τ, V \\X)).\nInitial lower bounds: We start by providing three lower bounds on f(S \\ E∗S). First, we observe that f(S \\ E∗S) ≥ f(S0 \\ E0) and f(S \\ E∗S) ≥ f (⋃dlog τe i=0 (Bi \\ EBi) ) . We also have\nf(S \\ E) = f(S)− f(S) + f(S \\ E) = f(S0 ∪ S1) + f(S \\ E0)− f(S \\ E0)− f(S) + f(S \\ E) (56) = f(S1) + f(S0 | S1) + f(S \\ E0)− f(S)− f(S \\ E0) + f(S \\ E) = f(S1) + f(S0 | (S \\ S0)) + f(S \\ E0)− f(E0 ∪ (S \\ E0))− f(S \\ E0) + f(S \\ E) (57) = f(S1) + f(S0 | (S \\ S0))− f(E0 | (S \\ E0))− f(S \\ E0) + f(S \\ E) = f(S1) + f(S0 | (S \\ S0))− f(E0 | (S \\ E0))− f(E1 ∪ (S \\ E)) + f(S \\ E) (58) = f(S1) + f(S0 | (S \\ S0))− f(E0 | (S \\ E0))− f(E1 | S \\ E) = f(S1)− f(E1 | S \\ E) + f(S0 | (S \\ S0))− f(E0 | (S \\ E0)) ≥ (1− µ)f(S1), (59)\nwhere (56) and (57) follow from S = S0∪S1, (58) follows from E∗S = E0∪E1, and (59) follows from f(S0 | (S \\S0))− f(E0 | (S \\ E0)) ≥ 0 (due to E0 ⊆ S0 and S \\ S0 ⊆ S \\ E0), along with the definition of µ.\nBy combining the above three bounds on f(S \\ E∗S), we obtain\nf(S \\ E∗S) ≥ max f(S0 \\ E0), (1− µ)f(S1), f dlog τe⋃\ni=0\n(Bi \\ EBi)  . (60) We proceed by further bounding these terms.\nBounding the first term in (60): Defining S′0 := OPT(k − τ, V \\E0) ∩ (S0 \\E0) and X := OPT(k − τ, V \\E0) \\ S′0, we have\nf(S0 \\ E0) + f(OPT(k − τ, V \\ S0)) ≥ f(S′0) + f(X) (61) ≥ f(OPT(k − τ, V \\ E0)) (62) ≥ f(OPT(k, V, τ) \\ E∗OPT(k,V,τ)), (63)\nwhere (61) follows from monotonicity, i.e. (S0 \\ E0) ⊆ S′0 and (V \\ S0) ⊆ (V \\ E0), (62) follows from the fact that OPT(k − τ, V \\E0) = S′0 ∪X and submodularity,2 and (63) follows from Lemma D.8 and |E0| ≤ τ . We rewrite (63) as\nf(S0 \\ E0) ≥ f(OPT(k, V, τ) \\ E∗OPT(k,V,τ))− f(OPT(k − τ, V \\ S0)). (64)\nBounding the second term in (60): Note that S1 is obtained by using A that satisfies the β-iterative property on the set V \\ S0, and its size is |S1| = k − |S0|. Hence, from Lemma 4.3 with k − τ in place of k, we have\nf(S1) ≥ ( 1− e− k−|S0| β(k−τ) ) f(OPT(k − τ, V \\ S0)). (65)\n2The submodularity property can equivalently be written as f(A) + f(B) ≥ f(A ∪B) + f(A ∩B).\nBounding the third term in (60): We can view S1 as a large bucket created by our algorithm after creating the buckets in S0. Therefore, we can apply Lemma D.4 with X = ⋃dlog τe−1 i=0 (Bi \\ EBi), Y = Bdlog τe, Z = S1, EY = E∗S ∩ Y , and EZ = E1. Conditions (25) and (26) needed to apply Lemma D.4 are provided by Lemma D.6. From Lemma D.4, we obtain the following with α as in (42):\nf E1 ∣∣∣∣∣ dlog τe⋃\ni=0\n(Bi \\ EBi)  ∪ (S1 \\ E1)  ≤ (β |E1|\n|Bdlog τe| (1 + α) + α\n) f dlog τe⋃ i=0 (Bi \\ EBi)  . (66) Furthermore, noting that the assumption η ≥ 4(log k+ 1) implies 2dlog τe ≤ ηh, we can upper-bound α as in Lemma D.7 by (48) for j = dlog τe. Also, we have β |E1||Bdlog τe| ≤ β τ 2dlog τeη\n≤ βη . Putting these together, we upper bound (66) as follows:\nf E1 ∣∣∣∣∣ dlog τe⋃\ni=0\n(Bi \\ EBi)  ∪ (S1 \\ E1)  ≤ (β\nη\n( 1 +\n3β2dlog τe η\n) +\n3β2dlog τe η\n) f dlog τe⋃ i=0 (Bi \\ EBi)  ≤ 5β\n3dlog τe η f dlog τe⋃ i=0 (Bi \\ EBi)  , where we have used η ≥ 1 and dlog τe ≥ 1 (since τ ≥ 2 by assumption). We rewrite the previous equation as\nf dlog τe⋃ i=0 (Bi \\ EBi)  ≥ η 5β3dlog τe f E1 ∣∣∣∣∣ dlog τe⋃ i=0 (Bi \\ EBi)  ∪ (S1 \\ E1) \n≥ η 5β3dlog τe f(E1 | (S \\ E)) (67) = η\n5β3dlog τe µf(S1), (68)\nwhere (67) follows from submodularity, and (68) follows from the definition of µ.\nCombining the bounds: Returning to (60), we have\nf(S \\ E∗S) ≥ max f(S0 \\ E0), (1− µ)f(S1), f dlog τe⋃\ni=0\n(Bi \\ EBi)  ≥ max { f(S0 \\ E0), (1− µ)f(S1), η\n5β3dlog τe µf(S1)\n} (69)\n≥ max{f(OPT(k, V, τ) \\ E∗OPT(k,V,τ))− f(OPT(k − τ, V \\ S0)), (1− µ) ( 1− e− k−|S0| β(k−τ) ) f(OPT(k − τ, V \\ S0)),\nη 5β3dlog τe µ ( 1− e− k−|S0| β(k−τ) ) f(OPT(k − τ, V \\ S0))} (70)\n≥ max{f(OPT(k, V, τ) \\ E∗OPT(k,V,τ))− f(OPT(k − τ, V \\ S0)), η\n5β3dlog τe\n1 + η5β3dlog τe\n( 1− e− k−|S0| β(k−τ) ) f(OPT(k − τ, V \\ S0))} (71)\n= max{f(OPT(k, V, τ) \\ E∗OPT(k,V,τ))− f(OPT(k − τ, V \\ S0)), η\n5β3dlog τe+ η\n( 1− e− k−|S0| β(k−τ) ) f(OPT(k − τ, V \\ S0))}\n≥ η 5β3dlog τe+η\n( 1− e− k−|S0| β(k−τ) ) 1 + η5β3dlog τe+η ( 1− e− k−|S0| β(k−τ) )f(OPT(k, V, τ) \\ E∗OPT(k,V,τ)), (72)\nwhere (69) follows from (68), (70) follows from (64) and (65), (71) follows since max{1− µ, cµ} ≥ c1+c analogously to (19), and (72) follows from (20). Hence, we have established (72).\nTurning to the permitted values of τ , we have from Proposition 4.1 that\n|S0| ≤ 3ητ(log k + 2).\nFor the choice of τ to yield valid set sizes, we only require |S0| ≤ k; hence, it suffices that\nτ ≤ k 3η(log k + 2) . (73)\nFinally, we consider the second claim of the lemma. For τ ∈ o (\nk η(log k) ) we have |S0| ∈ o(k). Furthermore, by setting\nη ≥ log2 k (which satisfies the assumption η ≥ 4(log k + 1) for large k), we get k−|S0|β(k−τ) → β −1 and η5β3dlog τe+η → 1 as k →∞. Hence, the constant factor converges to 1−e −1/β\n2−e−1/β , yielding (11). In the case that GREEDY is used as the subroutine,\nwe have β = 1, and hence the constant factor converges t 1−e −1\n2−e−1 ≥ 0.387. If THRESHOLDING-GREEDY is used, we have β = 11− , and hence the constant factor converges to 1−e −1 2−e −1 ≥ (1− ) 1−e−1 2−e−1 ≥ (1− )0.387."
    } ],
    "references" : [ {
      "title" : "Fast algorithms for maximizing submodular functions",
      "author" : [ "Badanidiyuru", "Ashwinkumar", "Vondrák", "Jan" ],
      "venue" : "In ACMSIAM Symp. Disc. Alg. (SODA), pp",
      "citeRegEx" : "Badanidiyuru et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Badanidiyuru et al\\.",
      "year" : 2014
    }, {
      "title" : "Robust protection of networks against cascading phenomena",
      "author" : [ "Bogunovic", "Ilija", "Krause", "Andreas" ],
      "venue" : "Tech. Report ETH Zürich,",
      "citeRegEx" : "Bogunovic et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Bogunovic et al\\.",
      "year" : 2012
    }, {
      "title" : "Robust influence maximization",
      "author" : [ "Chen", "Wei", "Lin", "Tian", "Tan", "Zihan", "Zhao", "Mingfei", "Zhou", "Xuren" ],
      "venue" : "arXiv preprint arXiv:1601.06551,",
      "citeRegEx" : "Chen et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2016
    }, {
      "title" : "Nightmare at test time: robust learning by feature deletion",
      "author" : [ "Globerson", "Amir", "Roweis", "Sam" ],
      "venue" : "In Int. Conf. Mach. Learn. (ICML),",
      "citeRegEx" : "Globerson et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Globerson et al\\.",
      "year" : 2006
    }, {
      "title" : "Robust influence maximization",
      "author" : [ "He", "Xinran", "Kempe", "David" ],
      "venue" : "In Int. Conf. Knowledge Discovery and Data Mining (KDD),",
      "citeRegEx" : "He et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "He et al\\.",
      "year" : 2016
    }, {
      "title" : "Maximizing the spread of influence through a social network",
      "author" : [ "Kempe", "David", "Kleinberg", "Jon", "Tardos", "Éva" ],
      "venue" : "In Int. Conf. on Knowledge Discovery and Data Mining (SIGKDD),",
      "citeRegEx" : "Kempe et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Kempe et al\\.",
      "year" : 2003
    }, {
      "title" : "Submodular function maximization. Tractability: Practical Approaches to Hard Problems",
      "author" : [ "Krause", "Andreas", "Golovin", "Daniel" ],
      "venue" : null,
      "citeRegEx" : "Krause et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Krause et al\\.",
      "year" : 2012
    }, {
      "title" : "Near-optimal observation selection using submodular functions",
      "author" : [ "Krause", "Andreas", "Guestrin", "Carlos" ],
      "venue" : "In Conf. Art. Intell. (AAAI),",
      "citeRegEx" : "Krause et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Krause et al\\.",
      "year" : 2007
    }, {
      "title" : "Robust submodular observation selection",
      "author" : [ "Krause", "Andreas", "McMahan", "H Brendan", "Guestrin", "Carlos", "Gupta", "Anupam" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Krause et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Krause et al\\.",
      "year" : 2008
    }, {
      "title" : "A class of submodular functions for document summarization",
      "author" : [ "Lin", "Hui", "Bilmes", "Jeff" ],
      "venue" : "In Assoc. for Comp. Ling.: Human Language Technologies-Volume",
      "citeRegEx" : "Lin et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Lin et al\\.",
      "year" : 2011
    }, {
      "title" : "Horizontally scalable submodular maximization",
      "author" : [ "Lucic", "Mario", "Bachem", "Olivier", "Zadimoghaddam", "Morteza", "Krause", "Andreas" ],
      "venue" : "In Proc. Int. Conf. Mach. Learn. (ICML),",
      "citeRegEx" : "Lucic et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Lucic et al\\.",
      "year" : 2016
    }, {
      "title" : "Discovering social circles in ego networks",
      "author" : [ "Mcauley", "Julian", "Leskovec", "Jure" ],
      "venue" : "ACM Trans. Knowl. Discov. Data,",
      "citeRegEx" : "Mcauley et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Mcauley et al\\.",
      "year" : 2014
    }, {
      "title" : "Accelerated greedy algorithms for maximizing submodular set functions",
      "author" : [ "Minoux", "Michel" ],
      "venue" : "In Optimization Techniques,",
      "citeRegEx" : "Minoux and Michel.,? \\Q1978\\E",
      "shortCiteRegEx" : "Minoux and Michel.",
      "year" : 1978
    }, {
      "title" : "Randomized composable core-sets for distributed submodular maximization",
      "author" : [ "Mirrokni", "Vahab", "Zadimoghaddam", "Morteza" ],
      "venue" : "In ACM Symposium on Theory of Computing (STOC),",
      "citeRegEx" : "Mirrokni et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Mirrokni et al\\.",
      "year" : 2015
    }, {
      "title" : "Lazier than lazy greedy",
      "author" : [ "Mirzasoleiman", "Baharan", "Badanidiyuru", "Ashwinkumar", "Karbasi", "Amin", "Vondrák", "Jan", "Krause", "Andreas" ],
      "venue" : "In Proc. Conf. Art. Intell. (AAAI),",
      "citeRegEx" : "Mirzasoleiman et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Mirzasoleiman et al\\.",
      "year" : 2015
    }, {
      "title" : "Distributed submodular cover: Succinctly summarizing massive data",
      "author" : [ "Mirzasoleiman", "Baharan", "Karbasi", "Amin", "Badanidiyuru", "Ashwinkumar", "Krause", "Andreas" ],
      "venue" : "In Adv. Neur. Inf. Proc. Sys. (NIPS),",
      "citeRegEx" : "Mirzasoleiman et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Mirzasoleiman et al\\.",
      "year" : 2015
    }, {
      "title" : "An analysis of approximations for maximizing submodular set functionsi",
      "author" : [ "Nemhauser", "George L", "Wolsey", "Laurence A", "Fisher", "Marshall L" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Nemhauser et al\\.,? \\Q1978\\E",
      "shortCiteRegEx" : "Nemhauser et al\\.",
      "year" : 1978
    }, {
      "title" : "An efficient streaming algorithm for the submodular cover problem",
      "author" : [ "Norouzi-Fard", "Ashkan", "Bazzi", "Abbas", "Bogunovic", "Ilija", "El Halabi", "Marwa", "Hsieh", "Ya-Ping", "Cevher", "Volkan" ],
      "venue" : "In Adv. Neur. Inf. Proc. Sys. (NIPS),",
      "citeRegEx" : "Norouzi.Fard et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Norouzi.Fard et al\\.",
      "year" : 2016
    }, {
      "title" : "Robust monotone submodular function maximization",
      "author" : [ "Orlin", "James B", "Schulz", "Andreas S", "Udwani", "Rajan" ],
      "venue" : "In Int. Conf. on Integer Programming and Combinatorial Opt. (IPCO)",
      "citeRegEx" : "Orlin et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Orlin et al\\.",
      "year" : 2016
    }, {
      "title" : "Constrained robust submodular optimization",
      "author" : [ "Powers", "Thomas", "Bilmes", "Jeff", "Wisdom", "Scott", "Krout", "David W", "Atlas", "Les" ],
      "venue" : "NIPS OPT2016 workshop,",
      "citeRegEx" : "Powers et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Powers et al\\.",
      "year" : 2016
    }, {
      "title" : "Machine learning for quantum mechanics in a nutshell",
      "author" : [ "Rupp", "Matthias" ],
      "venue" : "Int. Journal of Quantum Chemistry,",
      "citeRegEx" : "Rupp and Matthias.,? \\Q2015\\E",
      "shortCiteRegEx" : "Rupp and Matthias.",
      "year" : 2015
    }, {
      "title" : "Robust budget allocation via continuous submodular functions",
      "author" : [ "Staib", "Matthew", "Jegelka", "Stefanie" ],
      "venue" : "http://people.csail.mit.edu/stefje/ papers/robust_budget.pdf,",
      "citeRegEx" : "Staib et al\\.,? \\Q2017\\E",
      "shortCiteRegEx" : "Staib et al\\.",
      "year" : 2017
    }, {
      "title" : "Submodular approximation: Sampling-based algorithms and lower bounds",
      "author" : [ "Svitkina", "Zoya", "Fleischer", "Lisa" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "Svitkina et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Svitkina et al\\.",
      "year" : 2011
    }, {
      "title" : "80 million tiny images: A large data set for nonparametric object and scene recognition",
      "author" : [ "Torralba", "Antonio", "Fergus", "Rob", "Freeman", "William T" ],
      "venue" : "IEEE Trans. Patt. Ana. Mach. Intel.,",
      "citeRegEx" : "Torralba et al\\.,? \\Q1958\\E",
      "shortCiteRegEx" : "Torralba et al\\.",
      "year" : 1958
    } ],
    "referenceMentions" : [ {
      "referenceID" : 18,
      "context" : "We focus on the worst-case setting considered in (Orlin et al., 2016), in which a constant-factor approximation guarantee was given for τ = o( √ k).",
      "startOffset" : 49,
      "endOffset" : 69
    }, {
      "referenceID" : 18,
      "context" : "We numerically demonstrate the performance of PRO in data summarization and influence maximization, demonstrating gains over both the greedy algorithm and the algorithm of (Orlin et al., 2016).",
      "startOffset" : 172,
      "endOffset" : 192
    }, {
      "referenceID" : 5,
      "context" : "Applications include influence maximization (Kempe et al., 2003), document summarization (Lin & Bilmes, 2011), sensor placement (Krause & Guestrin, 2007), and active learning (Krause & Golovin, 2012), just to name a few.",
      "startOffset" : 44,
      "endOffset" : 64
    }, {
      "referenceID" : 8,
      "context" : "The robust problem formulation was first introduced in (Krause et al., 2008), and was further studied in (Orlin et al.",
      "startOffset" : 55,
      "endOffset" : 76
    }, {
      "referenceID" : 18,
      "context" : ", 2008), and was further studied in (Orlin et al., 2016).",
      "startOffset" : 36,
      "endOffset" : 56
    }, {
      "referenceID" : 8,
      "context" : "In fact, (Krause et al., 2008) considers a more general formulation where a constant-factor approximation guarantee is impossible in general, but shows that one can match the optimal (robust) objective value for a given set size at the cost of returning a set whose size is larger by a logarithmic factor.",
      "startOffset" : 9,
      "endOffset" : 30
    }, {
      "referenceID" : 18,
      "context" : "In contrast, (Orlin et al., 2016) designs an algorithm that obtains the first constant-factor approximation guarantee to the above problem when τ = o( √ k).",
      "startOffset" : 13,
      "endOffset" : 33
    }, {
      "referenceID" : 8,
      "context" : "A key difference between the two frameworks is that the algorithm complexity is exponential in τ in (Krause et al., 2008), whereas the algorithm of (Orlin et al.",
      "startOffset" : 100,
      "endOffset" : 121
    }, {
      "referenceID" : 18,
      "context" : ", 2008), whereas the algorithm of (Orlin et al., 2016) runs in polynomial time.",
      "startOffset" : 34,
      "endOffset" : 54
    }, {
      "referenceID" : 18,
      "context" : "In this paper, we solve a key open problem posed in (Orlin et al., 2016), namely, whether a constantfactor approximation guarantee is possible for general τ = o(k), as opposed to only τ = o( √ k).",
      "startOffset" : 52,
      "endOffset" : 72
    }, {
      "referenceID" : 18,
      "context" : "Achieving this result requires novelty both in the algorithm and its mathematical analysis: While our algorithm bears some similarity to that of (Orlin et al., 2016), it uses a novel structure in which the constructed set is arranged into partitions consisting of buckets whose sizes increase exponentially with the partition index.",
      "startOffset" : 145,
      "endOffset" : 165
    }, {
      "referenceID" : 8,
      "context" : "In addition to the above contributions, we provide the first empirical study beyond what is demonstrated for τ = 1 in (Krause et al., 2008).",
      "startOffset" : 118,
      "endOffset" : 139
    }, {
      "referenceID" : 18,
      "context" : "We demonstrate several scenarios in which our algorithm outperforms both the greedy algorithm and the algorithm of (Orlin et al., 2016).",
      "startOffset" : 115,
      "endOffset" : 135
    }, {
      "referenceID" : 16,
      "context" : "A celebrated result of (Nemhauser et al., 1978) shows that a simple greedy algorithm that starts with an empty set and then iteratively adds elements with highest marginal gain provides a (1− 1/e)-approximation.",
      "startOffset" : 23,
      "endOffset" : 47
    }, {
      "referenceID" : 8,
      "context" : "In this paper, we consider the following robust version of (1), introduced in (Krause et al., 2008):",
      "startOffset" : 78,
      "endOffset" : 99
    }, {
      "referenceID" : 8,
      "context" : "(Krause et al., 2008) introduces the following generalization of (2):",
      "startOffset" : 0,
      "endOffset" : 21
    }, {
      "referenceID" : 19,
      "context" : "The work of (Powers et al., 2016) considers the same problem for different types of submodular constraints.",
      "startOffset" : 12,
      "endOffset" : 33
    }, {
      "referenceID" : 2,
      "context" : "The confidence interval setting is considered in (Chen et al., 2016), where two runs of the GREEDY algorithm (one pessimistic and one optimistic) are used to optimize the same ratio.",
      "startOffset" : 49,
      "endOffset" : 68
    }, {
      "referenceID" : 18,
      "context" : "(Orlin et al., 2016) considers the formulation in (2), and provides the first constant 0.",
      "startOffset" : 0,
      "endOffset" : 20
    }, {
      "referenceID" : 5,
      "context" : ", see (Kempe et al., 2003)), given the targeted set S, the expected number of influenced nodes at the end of the diffusion process is a monotone and submodular function of S (He & Kempe, 2016).",
      "startOffset" : 6,
      "endOffset" : 26
    }, {
      "referenceID" : 10,
      "context" : ", (Lucic et al., 2016).",
      "startOffset" : 2,
      "endOffset" : 22
    }, {
      "referenceID" : 8,
      "context" : "Further potential applications not covered here include robust sensor placement (Krause et al., 2008), robust protection of networks (Bogunovic & Krause, 2012), and robust feature selection (Globerson & Roweis, 2006).",
      "startOffset" : 80,
      "endOffset" : 101
    }, {
      "referenceID" : 18,
      "context" : "In contrast, we recall that the algorithm OSU proposed in (Orlin et al., 2016) adopts a simpler approach where a robust set is used consisting of τ buckets of equal size τ log k, thereby only permitting the scaling τ = o( √ k).",
      "startOffset" : 58,
      "endOffset" : 78
    }, {
      "referenceID" : 18,
      "context" : "We provide the following intuition as to why PRO succeeds despite having a smaller size for S0 compared to the algorithm given in (Orlin et al., 2016).",
      "startOffset" : 130,
      "endOffset" : 150
    }, {
      "referenceID" : 16,
      "context" : "The following lemma generalizes a classical property of the greedy algorithm (Nemhauser et al., 1978; Krause & Golovin, 2012) to the class of algorithms satisfying the β-iterative property.",
      "startOffset" : 77,
      "endOffset" : 125
    }, {
      "referenceID" : 18,
      "context" : "This result solves an open problem raised in (Orlin et al., 2016), namely, whether a constant-factor approximation guarantee can be obtained for τ = o(k) as opposed to",
      "startOffset" : 45,
      "endOffset" : 65
    }, {
      "referenceID" : 18,
      "context" : "387 for the greedy subroutine matches that of (Orlin et al., 2016), but our algorithm permits significantly “higher robustness” in the sense of allowing larger τ values.",
      "startOffset" : 46,
      "endOffset" : 66
    }, {
      "referenceID" : 18,
      "context" : "Once the suitable lower bounds are obtained for the terms in (12), the analysis proceeds similarly to (Orlin et al., 2016).",
      "startOffset" : 102,
      "endOffset" : 122
    }, {
      "referenceID" : 18,
      "context" : "In particular, we compare our algorithm against the OSU algorithm proposed in (Orlin et al., 2016) on different datasets and corresponding objective functions (see Table 3).",
      "startOffset" : 78,
      "endOffset" : 98
    }, {
      "referenceID" : 8,
      "context" : "We do not compare against SATURATE (Krause et al., 2008), due to its high computational cost for even a small τ .",
      "startOffset" : 35,
      "endOffset" : 56
    }, {
      "referenceID" : 18,
      "context" : "Conclusion We have provided a new Partitioned Robust (PRO) submodular maximization algorithm attaining a constantfactor approximation guarantee for general τ = o(k), thus resolving an open problem posed in (Orlin et al., 2016).",
      "startOffset" : 206,
      "endOffset" : 226
    } ],
    "year" : 2017,
    "abstractText" : "We study the problem of maximizing a monotone submodular function subject to a cardinality constraint k, with the added twist that a number of items τ from the returned set may be removed. We focus on the worst-case setting considered in (Orlin et al., 2016), in which a constant-factor approximation guarantee was given for τ = o( √ k). In this paper, we solve a key open problem raised therein, presenting a new Partitioned Robust (PRO) submodular maximization algorithm that achieves the same guarantee for more general τ = o(k). Our algorithm constructs partitions consisting of buckets with exponentially increasing sizes, and applies standard submodular optimization subroutines on the buckets in order to construct the robust solution. We numerically demonstrate the performance of PRO in data summarization and influence maximization, demonstrating gains over both the greedy algorithm and the algorithm of (Orlin et al., 2016).",
    "creator" : "LaTeX with hyperref package"
  }
}