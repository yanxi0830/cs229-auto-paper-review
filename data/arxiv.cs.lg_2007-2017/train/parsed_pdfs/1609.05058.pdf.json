{
  "name" : "1609.05058.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Formal Solution to the Grain of Truth Problem",
    "authors" : [ "Jan Leike" ],
    "emails" : [ "jan.leike@anu.edu.au", "jessica@intelligence.org", "benya@intelligence.org" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 9.\n05 05\n8v 1\n[ cs\n.A I]\n1 6\nSe p\nA Bayesian agent acting in a multi-agent environment learns to predict the other agents’ policies if its prior assigns positive probability to them (in other words, its prior contains a grain of truth). Finding a reasonably large class of policies that contains the Bayes-optimal policies with respect to this class is known as the grain of truth problem. Only small classes are known to have a grain of truth and the literature contains several related impossibility results. In this paper we present a formal and general solution to the full grain of truth problem: we construct a class of policies that contains all computable policies as well as Bayes-optimal policies for every lower semicomputable prior over the class. When the environment is unknown, Bayes-optimal agents may fail to act optimally even asymptotically. However, agents based on Thompson sampling converge to play ε-Nash equilibria in arbitrary unknown computable multi-agent environments. While these results are purely theoretical, we show that they can be computationally approximated arbitrarily closely.\nKeywords. General reinforcement learning, multi-agent systems, game theory, self-reflection, asymptotic optimality, Nash equilibrium, Thompson sampling, AIXI."
    }, {
      "heading" : "1 INTRODUCTION",
      "text" : "Consider the general setup of multiple reinforcement learning agents interacting sequentially in a known environment with the goal to maximize discounted reward.1 Each agent knows how the environment behaves, but does not know the other agents’ behavior. The natural (Bayesian) approach would be to define a class of possible policies that the other\n1We mostly use the terminology of reinforcement learning. For readers from game theory we provide a dictionary in Table 1.\nReinforcement learning Game theory\nstochastic policy mixed strategy deterministic policy pure strategy agent player multi-agent environment infinite extensive-form game reward payoff/utility (finite) history history infinite history path of play\nTable 1: Terminology dictionary between reinforcement learning and game theory.\nagents could adopt and take a prior over this class. During the interaction, this prior gets updated to the posterior as our agent learns the others’ behavior. Our agent then acts optimally with respect to this posterior belief.\nA famous result for infinitely repeated games states that as long as each agent assigns positive prior probability to the other agents’ policies (a grain of truth) and each agent acts Bayes-optimal, then the agents converge to playing an εNash equilibrium [KL93].\nAs an example, consider an infinitely repeated prisoners dilemma between two agents. In every time step the payoff matrix is as follows, where C means cooperate and D means defect.\nC D C 3/4, 3/4 0, 1 D 1, 0 1/4, 1/4\nDefine the set of policies Π := {π∞, π0, π1, . . .} where policy πt cooperates until time step t or the opponent defects (whatever happens first) and defects thereafter. The Bayes-optimal behavior is to cooperate until the posterior belief that the other agent defects in the time step after the next is greater than some constant (depending on the discount function) and then defect afterwards. Therefore Bayes-optimal behavior leads to a policy from the set Π\n(regardless of the prior). If both agents are Bayes-optimal with respect to some prior, they both have a grain of truth and therefore they converge to a Nash equilibrium: either they both cooperate forever or after some finite time they both defect forever. Alternating strategies like TitForTat (cooperate first, then play the opponent’s last action) are not part of the policy class Π, and adding them to the class breaks the grain of truth property: the Bayes-optimal behavior is no longer in the class. This is rather typical; a Bayesian agent usually needs to be more powerful than its environment [LH15b].\nUntil now, classes that admit a grain of truth were known only for small toy examples such as the iterated prisoner’s dilemma above [SLB09, Ch. 7.3]. The quest to find a large class admitting a grain of truth is known as the grain of truth problem [Hut09, Q. 5j]. The literature contains several impossibility results on the grain of truth problem [FY01, Nac97, Nac05] that identify properties that cannot be simultaneously satisfied for classes that allow a grain of truth.\nIn this paper we present a formal solution to multi-agent reinforcement learning and the grain of truth problem in the general setting (Section 3). We assume that our multiagent environment is computable, but it does not need to be stationary/Markov, ergodic, or finite-state [Hut05]. Our class of policies is large enough to contain all computable (stochastic) policies, as well as all relevant Bayes-optimal policies. At the same time, our class is small enough to be limit computable. This is important because it allows our result to be computationally approximated.\nIn Section 4 we consider the setting where the multi-agent environment is unknown to the agents and has to be learned in addition to the other agents’ behavior. A Bayes-optimal agent may not learn to act optimally in unknown multiagent environments even though it has a grain of truth. This effect occurs in non-recoverable environments where taking one wrong action can mean a permanent loss of future value. In this case, a Bayes-optimal agent avoids taking these dangerous actions and therefore will not explore enough to wash out the prior’s bias [LH15a]. Therefore, Bayesian agents are not asymptotically optimal, i.e., they do not always learn to act optimally [Ors13].\nHowever, asymptotic optimality is achieved by Thompson sampling because the inherent randomness of Thompson sampling leads to enough exploration to learn the entire environment class [LLOH16]. This leads to our main result: if all agents use Thompson sampling over our class of multi-agent environments, then for every ε > 0 they converge to an ε-Nash equilibrium asymptotically.\nThe central idea to our construction is based on reflective oracles [FST15, FTC15b]. Reflective oracles are probabilistic oracles similar to halting oracles that answer whether the probability that a given probabilistic Turing\nmachine T outputs 1 is higher than a given rational number p. The oracles are reflective in the sense that the machine T may itself query the oracle, so the oracle has to answer queries about itself. This invites issues caused by self-referential liar paradoxes of the form “if the oracle says that I return 1 with probability > 1/2, then return 0, else return 1.” Reflective oracles avoid these issues by being allowed to randomize if the machines do not halt or the rational number is exactly the probability to output 1. We introduce reflective oracles formally in Section 2 and prove that there is a limit computable reflective oracle."
    }, {
      "heading" : "2 REFLECTIVE ORACLES",
      "text" : ""
    }, {
      "heading" : "2.1 PRELIMINARIES",
      "text" : "Let X denote a finite set called alphabet. The set X ∗ := ⋃∞\nn=0 X n is the set of all finite strings over the alphabet X , the set X∞ is the set of all infinite strings over the alphabet X , and the set X ♯ := X ∗ ∪ X∞ is their union. The empty string is denoted by ǫ, not to be confused with the small positive real number ε. Given a string x ∈ X ♯, we denote its length by |x|. For a (finite or infinite) string x of length ≥ k, we denote with x1:k the first k characters of x, and with x<k the first k− 1 characters of x. The notation x1:∞ stresses that x is an infinite string.\nA function f : X ∗ → R is lower semicomputable iff the set {(x, p) ∈ X ∗ × Q | f(x) > p} is recursively enumerable. The function f is computable iff both f and −f are lower semicomputable. Finally, the function f is limit computable iff there is a computable function φ such that\nlim k→∞ φ(x, k) = f(x).\nThe program φ that limit computes f can be thought of as an anytime algorithm for f : we can stop φ at any time k and get a preliminary answer. If the program φ ran long enough (which we do not know), this preliminary answer will be close to the correct one.\nWe use ∆Y to denote the set of probability distributions over Y . A list of notation can be found in Appendix A."
    }, {
      "heading" : "2.2 DEFINITION",
      "text" : "A semimeasure over the alphabet X is a function ν : X ∗ → [0, 1] such that (i) ν(ǫ) ≤ 1, and (ii) ν(x) ≥ ∑\na∈X ν(xa) for all x ∈ X ∗. In the terminology of measure theory, semimeasures are probability measures on the probability space X ♯ = X ∗∪X∞ whose σ-algebra is generated by the cylinder sets Γx := {xz | z ∈ X ♯} [LV08, Ch. 4.2]. We call a semimeasure (probability) a measure iff equalities hold in (i) and (ii) for all x ∈ X ∗.\nNext, we connect semimeasures to Turing machines. The literature uses monotone Turing machines, which naturally\ncorrespond to lower semicomputable semimeasures [LV08, Sec. 4.5.2] that describe the distribution that arises when piping fair coin flips into the monotone machine. Here we take a different route.\nA probabilistic Turing machine is a Turing machine that has access to an unlimited number of uniformly random coin flips. Let T denote the set of all probabilistic Turing machines that take some input in X ∗ and may query an oracle (formally defined below). We take a Turing machine T ∈ T to correspond to a semimeasure λT where λT (a | x) is the probability that T outputs a ∈ X when given x ∈ X ∗ as input. The value of λT (x) is then given by the chain rule\nλT (x) :=\n|x| ∏\nk=1\nλT (xk | x<k). (1)\nThus T gives rise to the set of semimeasures M where the conditionals λ(a | x) are lower semicomputable. In contrast, the literature typically considers semimeasures whose joint probability (1) is lower semicomputable. This set M contains all computable measures. However, M is a proper subset of the set of all lower semicomputable semimeasures because the product (1) is lower semicomputale, but there are some lower semicomputable semimeasures whose conditional is not lower semicomputable [LH15c, Thm. 6].\nIn the following we assume that our alphabet is binary, i.e., X := {0, 1}.\nDefinition 1 (Oracle). An oracle is a function O : T × {0, 1}∗ ×Q → ∆{0, 1}.\nOracles are understood to be probabilistic: they randomly return 0 or 1. Let TO denote the machine T ∈ T when run with the oracle O, and let λOT denote the semimeasure induced by TO. This means that drawing from λOT involves two sources of randomness: one from the distribution induced by the probabilistic Turing machine T and one from the oracle’s answers.\nThe intended semantics of an oracle are that it takes a query (T, x, p) and returns 1 if the machine TO outputs 1 on input x with probability greater than p when run with the oracle O, i.e., when λOT (1 | x) > p. Furthermore, the oracle returns 0 if the machine TO outputs 1 on input x with probability less than p when run with the oracle O, i.e., when λOT (1 | x) < p. To fulfill this, the oracle O has to make statements about itself, since the machine T from the query may again query O. Therefore we call oracles of this kind reflective oracles. This has to be defined very carefully to avoid the obvious diagonalization issues that are caused by programs that ask the oracle about themselves. We impose the following self-consistency constraint.\nDefinition 2 (Reflective Oracle). An oracle O is reflective iff for all queries (T, x, p) ∈ T × {0, 1}∗ ×Q,\n(i) λOT (1 | x) > p implies O(T, x, p) = 1, and\n(ii) λOT (0 | x) > 1− p implies O(T, x, p) = 0.\nIf p under- or overshoots the true probability of λOT ( · | x), then the oracle must reveal this information. However, in the critical case when p = λOT (1 | x), the oracle is allowed to return anything and may randomize its result. Furthermore, since T might not output any symbol, it is possible that λOT (0 | x) + λ O T (1 | x) < 1. In this case the oracle can reassign the non-halting probability mass to 0, 1, or randomize; see Figure 1.\nExample 3 (Reflective Oracles and Diagonalization). Let T ∈ T be a probabilistic Turing machine that outputs 1−O(T, ǫ, 1/2) (T can know its own source code by quining [Kle52, Thm. 27]). In other words, T queries the oracle about whether it is more likely to output 1 or 0, and then does whichever the oracle says is less likely. In this case we can use an oracle O(T, ǫ, 1/2) := 1/2 (answer 0 or 1 with equal probability), which implies λOT (1 | ǫ) = λ O T (0 | ǫ) = 1/2, so the conditions of Definition 2 are satisfied. In fact, for this machine T we must have O(T, ǫ, 1/2) = 1/2 for all reflective oracles O. ♦\nThe following theorem establishes that reflective oracles exist.\nTheorem 4 ([FTC15a, App. B]). There is a reflective oracle.\nDefinition 5 (Reflective-Oracle-Computable). A semimeasure is called reflective-oracle-computable iff it is computable on a probabilistic Turing machine with access to a reflective oracle.\nFor any probabilistic Turing machine T ∈ T we can complete the semimeasure λOT ( · | x) into a reflectiveoracle-computable measure λ O\nT ( · | x): Using the oracle O and a binary search on the parameter p we search for the crossover point p where O(T, x, p) goes from returning 1 to returning 0. The limit point p∗ ∈ R of the binary search is random since the oracle’s answers may be random. But the main point is that the expectation of p∗ exists, so λ O\nT (1 | x) = E[p ∗] = 1 − λ\nO T (0 | x) for all\nx ∈ X ∗. Hence λ O\nT is a measure. Moreover, if the oracle\nis reflective, then λ O\nT (x) ≥ λ O T (x) for all x ∈ X ∗. In this sense the oracle O can be viewed as a way of ‘completing’\nall semimeasures λOT to measures by arbitrarily assigning the non-halting probability mass. If the oracle O is reflective this is consistent in the sense that Turing machines who run other Turing machines will be completed in the same way. This is especially important for a universal machine that runs all other Turing machines to induce a Solomonoffstyle distribution."
    }, {
      "heading" : "2.3 A LIMIT COMPUTABLE REFLECTIVE ORACLE",
      "text" : "The proof of Theorem 4 given in [FTC15a, App. B] is nonconstructive and uses the axiom of choice. In Section 2.4 we give a constructive proof for the existence of reflective oracles and show that there is one that is limit computable.\nTheorem 6 (A Limit Computable Reflective Oracle). There is a reflective oracle that is limit computable.\nThis theorem has the immediate consequence that reflective oracles cannot be used as halting oracles. At first, this result may seem surprising: according to the definition of reflective oracles, they make concrete statements about the output of probabilistic Turing machines. However, the fact that the oracles may randomize some of the time actually removes enough information such that halting can no longer be decided from the oracle output.\nCorollary 7 (Reflective Oracles are not Halting Oracles). There is no probabilistic Turing machine T such that for every prefix program p and every reflective oracle O, we have that λOT (1 | p) > 1/2 if p halts and λ O T (1 | p) < 1/2 otherwise.\nProof. Assume there was such a machine T and let O be the limit computable oracle from Theorem 6. Since O is reflective we can turn T into a deterministic halting oracle by calling O(T, p, 1/2) which deterministically returns 1 if p halts and 0 otherwise. Since O is limit computable, we can finitely compute the output of O on any query to arbitrary finite precision using our deterministic halting oracle. We construct a probabilistic Turing machine T ′ that uses our halting oracle to compute (rather than query) the oracle O on (T ′, ǫ, 1/2) to a precision of 1/3 in finite time. If O(T ′, ǫ, 1/2)± 1/3 > 1/2, the machine T ′ outputs 0, otherwise T ′ outputs 1. Since our halting oracle is entirely deterministic, the output of T ′ is entirely deterministic as well (and T ′ always halts), so λOT ′(0 | ǫ) = 1 or λ O T ′ (1 | ǫ) = 1. Therefore O(T ′, ǫ, 1/2) = 1 or O(T ′, ǫ, 1/2) = 0 because O is reflective. A precision of 1/3 is enough to tell them apart, hence T ′ returns 0 if O(T ′, ǫ, 1/2) = 1 and T ′ returns 1 if O(T ′, ǫ, 1/2) = 0. This is a contradiction.\nA similar argument can also be used to show that reflective oracles are not computable."
    }, {
      "heading" : "2.4 PROOF OF THEOREM 6",
      "text" : "The idea for the proof of Theorem 6 is to construct an algorithm that outputs an infinite series of partial oracles converging to a reflective oracle in the limit.\nThe set of queries is countable, so we can assume that we have some computable enumeration of it:\nT × {0, 1}∗ ×Q =: {q1, q2, . . .}\nDefinition 8 (k-Partial Oracle). A k-partial oracle Õ is function from the first k queries to the multiples of 2−k in [0, 1]:\nÕ : {q1, q2, . . . , qk} → {n2 −k | 0 ≤ n ≤ 2k}\nDefinition 9 (Approximating an Oracle). A k-partial oracle Õ approximates an oracle O iff |O(qi) − Õ(qi)| ≤ 2−k−1 for all i ≤ k.\nLet k ∈ N, let Õ be a k-partial oracle, and let T ∈ T be an oracle machine. The machine T Õ that we get when we run T with the k-partial oracle Õ is defined as follows (this is with slight abuse of notation since k is taken to be understood implicitly).\n1. Run T for at most k steps.\n2. If T calls the oracle on qi for i ≤ k,\n(a) return 1 with probability Õ(qi)− 2−k−1, (b) return 0 with probability 1− Õ(qi)− 2−k−1, and\n(c) halt otherwise.\n3. If T calls the oracle on qj for j > k, halt.\nFurthermore, we define λÕT analogously to λ O T as the distribution generated by the machine T Õ.\nLemma 10. If a k-partial oracle Õ approximates a reflective oracle O, then λOT (1 | x) ≥ λ Õ T (1 | x) and λOT (0 | x) ≥ λ Õ T (0 | x) for all x ∈ {0, 1} ∗ and all T ∈ T .\nProof. This follows from the definition of T Õ: when running T with Õ instead of O, we can only lose probability mass. If T makes calls whose index is > k or runs for more than k steps, then the execution is aborted and no further output is generated. If T makes calls whose index i ≤ k, then Õ(qi)− 2−k−1 ≤ O(qi) since Õ approximates O. Therefore the return of the call qi is underestimated as well.\nDefinition 11 (k-Partially Reflective). A k-partial oracle Õ is k-partially reflective iff for the first k queries (T, x, p)\n• λÕT (1 | x) > p implies Õ(T, x, p) = 1, and\n• λÕT (0 | x) > 1− p implies Õ(T, x, p) = 0.\nIt is important to note that we can check whether a k-partial oracle is k-partially reflective in finite time by running all machines T from the first k queries for k steps and tallying up the probabilities to compute λÕT . Lemma 12. If O is a reflective oracle and Õ is a k-partial oracle that approximatesO, then Õ is k-partially reflective.\nLemma 12 only holds because we use semimeasures whose conditionals are lower semicomputable.\nProof. Assuming λÕT (1 | x) > p we get from Lemma 10 that λOT (1 | x) ≥ λ Õ T (1 | x) > p. Thus O(T, x, p) = 1 because O is reflective. Since Õ approximates O, we get 1 = O(T, x, p) ≤ Õ(T, x, p)+2−k−1, and since Õ assigns values in a 2−k-grid, it follows that Õ(T, x, p) = 1. The second implication is proved analogously.\nDefinition 13 (Extending Partial Oracles). A k + 1-partial oracle Õ′ extends a k-partial oracle Õ iff |Õ(qi)−Õ′(qi)| ≤ 2−k−1 for all i ≤ k.\nLemma 14. There is an infinite sequence of partial oracles (Õk)k∈N such that for each k, Õk is a k-partially reflective k-partial oracle and Õk+1 extends Õk.\nProof. By Theorem 4 there is a reflective oracle O. For every k, there is a canonical k-partial oracle Õk that approximates O: restrict O to the first k queries and for any such query q pick the value in the 2−k-grid which is closest to O(q). By construction, Õk+1 extends Õk and by Lemma 12, each Õk is k-partially reflective.\nLemma 15. If the k + 1-partial oracle Õk+1 extends the k-partial oracle Õk, then λ Õk+1 T (1 | x) ≥ λ Õk T (1 | x) and λ Õk+1 T (0 | x) ≥ λ Õk T (0 | x) for all x ∈ {0, 1}\n∗ and all T ∈ T .\nProof. T Õk+1 runs for one more step than T Õk , can answer one more query and has increased oracle precision. Moreover, since Õk+1 extends Õk , we have |Õk+1(qi) − Õk(qi)| ≤ 2\n−k−1, and thus Õk+1(qi)−2−k−1 ≥ Õk(qi)− 2−k. Therefore the success to answers to the oracle calls (case 2(a) and 2(b)) will not decrease in probability.\nNow everything is in place to state the algorithm that constructs a reflective oracle in the limit. It recursively traverses a tree of partial oracles. The tree’s nodes are the partial oracles; level k of the tree contains all k-partial oracles. There is an edge in the tree from the k-partial oracle Õk to the i-partial oracle Õi if and only if i = k + 1 and Õi extends Õk.\nFor every k, there are only finitely many k-partial oracles, since they are functions from finite sets to finite sets. In particular, there are exactly two 1-partial oracles (so the search\ntree has two roots). Pick one of them to start with, and proceed recursively as follows. Given a k-partial oracle Õk, there are finitely many (k + 1)-partial oracles that extend Õk (finite branching of the tree). Pick one that is (k + 1)- partially reflective (which can be checked in finite time). If there is no (k+1)-partially reflective extension, backtrack.\nBy Lemma 14 our search tree is infinitely deep and thus the tree search does not terminate. Moreover, it can backtrack to each level only a finite number of times because at each level there is only a finite number of possible extensions. Therefore the algorithm will produce an infinite sequence of partial oracles, each extending the previous. Because of finite backtracking, the output eventually stabilizes on a sequence of partial oracles Õ1, Õ2, . . .. By the following lemma, this sequence converges to a reflective oracle, which concludes the proof of Theorem 6.\nLemma 16. Let Õ1, Õ2, . . . be a sequence where Õk is a k-partially reflective k-partial oracle and Õk+1 extends Õk for all k ∈ N. Let O := limk→∞ Õk be the pointwise limit. Then\n(a) λÕkT (1 | x) → λ O T (1 | x) and λ Õk T (0 | x) → λ O T (0 | x)\nas k → ∞ for all x ∈ {0, 1}∗ and all T ∈ T , and\n(b) O is a reflective oracle.\nProof. First note that the pointwise limit must exists because |Õk(qi)− Õk+1(qi)| ≤ 2−k−1 by Definition 13.\n(a) Since Õk+1 extends Õk, each Õk approximates O. Let x ∈ {0, 1}∗ and T ∈ T and consider the se-\nquence ak := λ Õk T (1 | x) for k ∈ N. By Lemma 15, ak ≤ ak+1, so the sequence is monotone increasing. By Lemma 10, ak ≤ λOT (1 | x), so the sequence is bounded. Therefore it must converge. But it cannot converge to anything strictly below λOT (1 | x) by the definition of TO.\n(b) By definition, O is an oracle; it remains to show that O is reflective. Let qi = (T, x, p) be some query. If p < λOT (1 | x), then by (a) there is a k large\nenough such that p < λÕtT (1 | x) for all t ≥ k. For any t ≥ max{k, i}, we have Õt(T, x, p) = 1 since Õt is t-partially reflective. Therefore 1 = limk→∞ Õk(T, x, p) = O(T, x, p). The case 1 − p < λOT (0 | x) is analogous."
    }, {
      "heading" : "3 A GRAIN OF TRUTH",
      "text" : ""
    }, {
      "heading" : "3.1 NOTATION",
      "text" : "In reinforcement learning, an agent interacts with an environment in cycles: at time step t the agent chooses an action at ∈ A and receives a percept et = (ot, rt) ∈ E\nconsisting of an observation ot ∈ O and a real-valued reward rt ∈ R; the cycle then repeats for t + 1. A history is an element of (A×E)∗. In this section, we use æ ∈ A×E to denote one interaction cycle, and æ<t to denote a history of length t− 1.\nWe fix a discount function γ : N → R with γt ≥ 0 and ∑∞\nt=1 γt < ∞. The goal in reinforcement learning is to maximize discounted rewards\n∑∞ t=1 γtrt. The discount\nnormalization factor is defined as Γt := ∑∞\nk=t γk. The effective horizon Ht(ε) is a horizon that is long enough to encompass all but an ε of the discount function’s mass:\nHt(ε) := min{k | Γt+k/Γt ≤ ε} (2)\nA policy is a function π : (A × E)∗ → ∆A that maps a history æ<t to a distribution over actions taken after seeing this history. The probability of taking action a after history æ<t is denoted with π(a | æ<t). An environment is a function ν : (A × E)∗ × A → ∆E where ν(e | æ<tat) denotes the probability of receiving the percept e when taking the action at after the history æ<t. Together, a policy π and an environment ν give rise to a distribution νπ over histories. Throughout this paper, we make the following assumptions.\nAssumption 17. (a) Rewards are bounded between 0 and 1.\n(b) The set of actions A and the set of percepts E are both finite.\n(c) The discount function γ and the discount normalization factor Γ are computable.\nDefinition 18 (Value Function). The value of a policy π in an environment ν given history æ<t is defined recursively as V πν (æ<t) := ∑ a∈A π(a | æ<t)V π ν (æ<ta) and\nV πν (æ<tat) := 1\nΓt\n∑\net∈E\nν(et | æ<tat) ( γtrt + Γt+1V π ν (æ1:t) )\nif Γt > 0 and V πν (æ<tat) := 0 if Γt = 0. The optimal value is defined as V ∗ν (æ<t) := supπ V π ν (æ<t). Definition 19 (Optimal Policy). A policy π is optimal in environment ν (ν-optimal) iff for all histories æ<t ∈ (A× E)∗ the policy π attains the optimal value: V πν (æ<t) = V ∗ν (æ<t).\nWe assumed that the discount function is summable, rewards are bounded (Assumption 17a), and actions and percepts spaces are both finite (Assumption 17b). Therefore an optimal deterministic policy exists for every environment [LH14, Thm. 10]."
    }, {
      "heading" : "3.2 REFLECTIVE BAYESIAN AGENTS",
      "text" : "Fix O to be a reflective oracle. From now on, we assume that the action space A := {α, β} is binary. We can treat\ncomputable measures over binary strings as environments: the environment ν corresponding to a probabilistic Turing machine T ∈ T is defined by\nν(et | æ<tat) := λ O T (y | x) = k ∏\ni=1\nλ O\nT (yi | xy1 . . . yi−1)\nwhere y1:k is a binary encoding of et and x is a binary encoding of æ<tat. The actions a1:∞ are only contextual, and not part of the environment distribution. We define\nν(e<t | a<t) :=\nt−1 ∏\nk=1\nν(ek | æ<k).\nLet T1, T2, . . . be an enumeration of all probabilistic Turing machines in T . We define the class of reflective environments\nMOrefl := { λ O T1 , λ O T2 , . . . } .\nThis is the class of all environments computable on a probabilistic Turing machine with reflective oracle O, that have been completed from semimeasures to measures using O.\nAnalogously to AIXI [Hut05], we define a Bayesian mixture over the class MOrefl. Let w ∈ ∆M O refl be a lower semicomputable prior probability distribution on MOrefl. Possible choices for the prior include the Solomonoff prior w ( λ O\nT\n)\n:= 2−K(T ), where K(T ) denotes the length of the shortest input to some universal Turing machine that encodes T [Sol78].2 We define the corresponding Bayesian mixture\nξ(et | æ<tat) := ∑\nν∈MOrefl\nw(ν | æ<t)ν(et | æ<tat) (3)\nwhere w(ν | æ<t) is the (renormalized) posterior,\nw(ν | æ<t) := w(ν) ν(e<t | a<t)\nξ(e<t | a<t) . (4)\nThe mixture ξ is lower semicomputable on an oracle Turing machine because the posterior w( · | æ<t) is lower semicomputable. Hence there is an oracle machine T such that ξ = λOT . We define its completion ξ := λ O\nT as the completion of λOT . This is the distribution that is used to compute the posterior. There are no cyclic dependencies since ξ is called on the shorter history æ<t. We arrive at the following statement.\nProposition 20 (Bayes is in the Class). ξ ∈ MOrefl.\nMoreover, since O is reflective, we have that ξ dominates all environments ν ∈ MOrefl:\nξ(e1:t | a1:t)\n2Technically, the lower semicomputable prior 2−K(T ) is only a semidistribution because it does not sum to 1. This turns out to be unimportant.\n= ξ(et | æ<tat)ξ(e<t | a<t)\n≥ ξ(et | æ<tat)ξ(e<t | a<t) = ξ(e<t | a<t) ∑\nν∈MOrefl\nw(ν | æ<t)ν(et | æ<tat)\n= ξ(e<t | a<t) ∑\nν∈MOrefl\nw(ν) ν(e<t | a<t)\nξ(e<t | a<t) ν(et | æ<tat)\n= ∑\nν∈MOrefl\nw(ν)ν(e1:t | a1:t)\n≥ w(ν)ν(e1:t | a1:t)\nThis property is crucial for on-policy value convergence.\nLemma 21 (On-Policy Value Convergence [Hut05, Thm. 5.36]). For any policy π and any environment µ ∈ MOrefl with w(µ) > 0,\nV πµ (æ<t)− V π ξ (æ<t) → 0 µπ-almost surely as t → ∞."
    }, {
      "heading" : "3.3 REFLECTIVE-ORACLE-COMPUTABLE POLICIES",
      "text" : "This subsection is dedicated to the following result that was previously stated but not proved in [FST15, Alg. 6]. It contrasts results on arbitrary semicomputable environments where optimal policies are not limit computable [LH15b, Sec. 4].\nTheorem 22 (Optimal Policies are Oracle Computable). For every ν ∈ MOrefl, there is a ν-optimal (stochastic) policy π∗ν that is reflective-oracle-computable.\nNote that even though deterministic optimal policies always exist, those policies are typically not reflectiveoracle-computable.\nTo prove Theorem 22 we need the following lemma.\nLemma 23 (Reflective-Oracle-Computable Optimal Value Function). For every environment ν ∈ MOrefl the optimal value function V ∗ν is reflective-oracle-computable.\nProof. This proof follows the proof of [LH15b, Cor. 13]. We write the optimal value explicitly as\nV ∗ν (æ<t) = 1\nΓt lim m→∞ max ∑\næt:m\nm ∑\nk=t\nγkrk\nk ∏\ni=t\nν(ei | æ<i),\n(5) where ∑ max denotes the expectimax operator:\nmax ∑\næt:m\n:= max at∈A\n∑\net∈E\n. . . max am∈A\n∑\nem∈E\nFor a fixed m, all involved quantities are reflective-oraclecomputable. Moreover, this quantity is monotone increasing in m and the tail sum from m+ 1 to ∞ is bounded by Γm+1 which is computable according to Assumption 17c and converges to 0 as m → ∞. Therefore we can enumerate all rationals above and below V ∗ν .\nProof of Theorem 22. According to Lemma 23 the optimal value function V ∗ν is reflective-oracle-computable. Hence there is a probabilistic Turing machine T such that\nλOT (1 | æ<t) = ( V ∗ν (æ<tα)− V ∗ ν (æ<tβ) + 1 ) /2.\nWe define a policy π that takes action α if O(T,æ<t, 1/2) = 1 and action β if O(T,æ<t, 1/2) = 0. (This policy is stochastic because the answer of the oracle O is stochastic.)\nIt remains to show that π is a ν-optimal policy. If V ∗ν (æ<tα) > V ∗ ν (æ<tβ), then λ O T (1 | æ<t) > 1/2, thus O(T,æ<t, 1/2) = 1 since O is reflective, and hence π takes action α. Conversely, if V ∗ν (æ<tα) < V ∗ ν (æ<tβ), then λOT (1 | æ<t) < 1/2, thus O(T,æ<t, 1/2) = 0 since O is reflective, and hence π takes action β. Lastly, if V ∗ν (æ<tα) = V ∗ ν (æ<tβ), then both actions are optimal and thus it does not matter which action is returned by policy π. (This is the case where the oracle may randomize.)"
    }, {
      "heading" : "3.4 SOLUTION TO THE GRAIN OF TRUTH PROBLEM",
      "text" : "Together, Proposition 20 and Theorem 22 provide the necessary ingredients to solve the grain of truth problem.\nCorollary 24 (Solution to the Grain of Truth Problem). For every lower semicomputable prior w ∈ ∆MOrefl the Bayesoptimal policy π∗\nξ is reflective-oracle-computable where ξ\nis the Bayes-mixture corresponding to w defined in (3).\nProof. From Proposition 20 and Theorem 22.\nHence the environment class MOrefl contains any reflectiveoracle-computable modification of the Bayes-optimal policy π∗\nξ . In particular, this includes computable multi-agent\nenvironments that contain other Bayesian agents over the class MOrefl. So any Bayesian agent over the class M O refl has a grain of truth even though the environment may contain other Bayesian agents of equal power. We proceed to sketch the implications for multi-agent environments in the next section."
    }, {
      "heading" : "4 MULTI-AGENT ENVIRONMENTS",
      "text" : "This section summarizes our results for multi-agent systems. The proofs can be found in [Lei16]."
    }, {
      "heading" : "4.1 SETUP",
      "text" : "In a multi-agent environment there are n agents each taking sequential actions from the finite action space A. In each time step t = 1, 2, . . ., the environment receives action ait from agent i and outputs n percepts e1t , . . . , e n t ∈ E , one for\neach agent. Each percept eit = (o i t, r i t) contains an observation oit and a reward r i t ∈ [0, 1]. Importantly, agent i only sees its own action ait and its own percept e i t (see Figure 2). We use the shorthand notation at := (a1t , . . . , a n t ) and et := (e 1 t , . . . , e n t ) and denote æ i <t = a i 1e i 1 . . . a i t−1e i t−1 and æ<t = a1e1 . . . at−1et−1.\nWe define a multi-agent environment as a function\nσ : (An × En)∗ ×An → ∆(En).\nThe agents are given by n policies π1, . . . , πn where πi : (A× E)∗ → ∆A. Together they specify the history distribution\nσπ1:n(ǫ) : = 1\nσπ1:n(æ1:t) : = σπ1:n(æ<tat)σ(et | æ<tat)\nσπ1:n(æ<tat) : = σπ1:n(æ<t) n ∏\ni=1\nπi(a i t | æ i <t).\nEach agent i acts in a subjective environment σi given by joining the multi-agent environment σ with the policies π1, . . . , πi−1, πi+1, . . . , πn by marginalizing over the histories that πi does not see. Together with policy πi, the environment σi yields a distribution over the histories of agent i\nσπii (æ i <t) :=\n∑\næj<t,j 6=i\nσπ1:n(æ<t).\nWe get the definition of the subjective environment σi with the identity σi(eit | æ i <ta i t) := σ πi i (e i t | æ i <ta i t). It is crucial to note that the subjective environment σi and the policy πi are ordinary environments and policies, so we can use the formalism from Section 3.\nOur definition of a multi-agent environment is very general and encompasses most of game theory. It allows for cooperative, competitive, and mixed games; infinitely repeated games or any (infinite-length) extensive form games with finitely many players.\nThe policy πi is an ε-best response after history æi<t iff\nV ∗σi(æ i <t)− V πi σi (æi<t) < ε.\nIf at some time step t, all agents’ policies are ε-best responses, we have an ε-Nash equilibrium. The property of multi-agent systems that is analogous to asymptotic optimality is convergence to an ε-Nash equilibrium."
    }, {
      "heading" : "4.2 INFORMED REFLECTIVE AGENTS",
      "text" : "Let σ be a multi-agent environment and let π∗σ1 , . . . π ∗ σn be such that for each i the policy π∗σi is an optimal policy in agent i’s subjective environment σi. At first glance this seems ill-defined: The subjective environment σi depends on each other policy π∗σj for j 6= i, which depends on the subjective environment σj , which in turn depends on the policy π∗σi . However, this circular definition actually has a well-defined solution.\nTheorem 25 (Optimal Multi-Agent Policies). For any reflective-oracle-computable multi-agent environment σ, the optimal policies π∗σ1 , . . . , π ∗ σn\nexist and are reflectiveoracle-computable.\nNote the strength of Theorem 25: each of the policies π∗σi is acting optimally given the knowledge of everyone else’s policies. Hence optimal policies play 0-best responses by definition, so if every agent is playing an optimal policy, we have a Nash equilibrium. Moreover, this Nash equilibrium is also a subgame perfect Nash equilibrium, because each agent also acts optimally on the counterfactual histories that do not end up being played. In other words, Theorem 25 states the existence and reflectiveoracle-computability of a subgame perfect Nash equilibrium in any reflective-oracle-computable multi-agent environment. From Theorem 6 we then get that these subgame perfect Nash equilibria are limit computable.\nCorollary 26 (Solution to Computable Multi-Agent Environments). For any computable multi-agent environment σ, the optimal policies π∗σ1 , . . . , π ∗ σn\nexist and are limit computable."
    }, {
      "heading" : "4.3 LEARNING REFLECTIVE AGENTS",
      "text" : "Since our class MOrefl solves the grain of truth problem, the result by Kalai and Lehrer [KL93] immediately implies that for any Bayesian agents π1, . . . , πn interacting in an infinitely repeated game and for all ε > 0 and all i ∈ {1, . . . , n} there is almost surely a t0 ∈ N such that for all t ≥ t0 the policy πi is an ε-best response. However, this hinges on the important fact that every agent has to know the game and also that all other agents are Bayesian agents. Otherwise the convergence to an ε-Nash equilibrium may fail, as illustrated by the following example.\nAt the core of the following construction is a dogmatic prior [LH15a, Sec. 3.2]. A dogmatic prior assigns very\nhigh probability to going to hell (reward 0 forever) if the agent deviates from a given computable policy π. For a Bayesian agent it is thus only worth deviating from the policy π if the agent thinks that the prospects of following π are very poor already. This implies that for general multi-agent environments and without additional assumptions on the prior, we cannot prove any meaningful convergence result about Bayesian agents acting in an unknown multi-agent environment.\nExample 27 (Reflective Bayesians Playing Matching Pennies). In the game of matching pennies there are two agents (n = 2), and two actions A = {α, β} representing the two sides of a penny. In each time step agent 1 wins if the two actions are identical and agent 2 wins if the two actions are different. The payoff matrix is as follows.\nα β α 1,0 0,1 β 0,1 1,0\nWe use E = {0, 1} to be the set of rewards (observations are vacuous) and define the multi-agent environment σ to give reward 1 to agent 1 iff a1t = a 2 t (0 otherwise) and reward 1 to agent 2 iff a1t 6= a 2 t (0 otherwise). Note that neither agent knows a priori that they are playing matching pennies, nor that they are playing an infinite repeated game with one other player.\nLet π1 be the policy that takes the action sequence (ααβ)∞ and let π2 := πα be the policy that always takes action α. The average reward of policy π1 is 2/3 and the average reward of policy π2 is 1/3. Let ξ be a universal mixture (3). By Lemma 21, V π1\nξ → c1 ≈ 2/3 and V\nπ2\nξ → c2 ≈ 1/3\nalmost surely when following policies (π1, π2). Therefore there is an ε > 0 such that V π1\nξ > ε and V π2 ξ > ε for all\ntime steps. Now we can apply [LH15a, Thm. 7] to conclude that there are (dogmatic) mixtures ξ′1 and ξ ′ 2 such that π\n∗ ξ′ 1\nalways follows policy π1 and π∗ξ′ 2 always follows policy π2. This does not converge to a (ε-)Nash equilibrium. ♦\nA policy π is asymptotically optimal in mean in an environment class M iff for all µ ∈ M\nEπµ [ V ∗µ (æ<t)− V π µ (æ<t) ] → 0 as t → ∞ (6)\nwhere Eπµ denotes the expectation with respect to the probability distribution µπ over histories generated by policy π acting in environment µ.\nAsymptotic optimality stands out because it is currently the only known nontrivial objective notion of optimality in general reinforcement learning [LH15a].\nThe following theorem is the main convergence result. It states that for asymptotically optimal agents we get convergence to ε-Nash equilibria in any reflective-oraclecomputable multi-agent environment.\nTheorem 28 (Convergence to Equilibrium). Let σ be an reflective-oracle-computable multi-agent environment and let π1, . . . , πn be reflective-oracle-computable policies that are asymptotically optimal in mean in the class MOrefl. Then for all ε > 0 and all i ∈ {1, . . . , n} the σπ1:n -probability that the policy πi is an ε-best response converges to 1 as t → ∞.\nIn contrast to Theorem 25 which yields policies that play a subgame perfect equilibrium, this is not the case for Theorem 28: the agents typically do not learn to predict off-policy and thus will generally not play ε-best responses in the counterfactual histories that they never see. This weaker form of equilibrium is unavoidable if the agents do not know the environment because it is impossible to learn the parts that they do not interact with.\nTogether with Theorem 6 and the asymptotic optimality of the Thompson sampling policy [LLOH16, Thm. 4] that is reflective-oracle computable we get the following corollary.\nCorollary 29 (Convergence to Equilibrium). There are limit computable policies π1, . . . , πn such that for any computable multi-agent environment σ and for all ε > 0 and all i ∈ {1, . . . , n} the σπ1:n -probability that the policy πi is an ε-best response converges to 1 as t → ∞."
    }, {
      "heading" : "5 DISCUSSION",
      "text" : "This paper introduced the class of all reflective-oraclecomputable environments MOrefl. This class solves the grain of truth problem because it contains (any computable modification of) Bayesian agents defined over MOrefl: the optimal agents and Bayes-optimal agents over the class are all reflective-oracle-computable (Theorem 22 and Corollary 24).\nIf the environment is unknown, then a Bayesian agent may end up playing suboptimally (Example 27). However, if each agent uses a policy that is asymptotically optimal in mean (such as the Thompson sampling policy [LLOH16]) then for every ε > 0 the agents converge to an ε-Nash equilibrium (Theorem 28 and Corollary 29).\nOur solution to the grain of truth problem is purely theoretical. However, Theorem 6 shows that our class MOrefl allows for computable approximations. This suggests that practical approaches can be derived from this result, and reflective oracles have already seen applications in one-shot games [FTC15b]."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We thank Marcus Hutter and Tom Everitt for valuable comments."
    }, {
      "heading" : "A LIST OF NOTATION",
      "text" : ":= defined to be equal N the natural numbers, starting with 0 Q the rational numbers R the real numbers t (current) time step, t ∈ N k, n, i time steps, natural numbers p a rational number X ∗ the set of all finite strings over the alphabet X X∞ the set of all infinite strings over the alphabet X X ♯ the set of all finite and infinite strings over the alphabet X O a reflective oracle Õ a partial oracle q a query to a reflective oracle T the set of all probabilistic Turing machines that can query an oracle T, T ′ probabilistic Turing machines that can query an oracle, T, T ′ ∈ T K(x) the Kolmogorov complexity of a string x λT the semimeasure corresponding to the probabilistic Turing machine T λOT the semimeasure corresponding to the\nprobabilistic Turing machine T with reflective oracle O\nλ O\nT the completion of λ O T into a measure using\nthe reflective oracle O A the finite set of possible actions O the finite set of possible observations E the finite set of possible percepts, E ⊂ O×\nR\nα, β two different actions, α, β ∈ A at the action in time step t ot the observation in time step t rt the reward in time step t, bounded between 0 and 1 et the percept in time step t, we use et = (ot, rt) implicitly æ<t the first t − 1 interactions,\na1e1a2e2 . . . at−1et−1 (a history of length t− 1)\nǫ the empty string/the history of length 0 ε a small positive real number γ the discount function γ : N → R≥0\nΓt a discount normalization factor, Γt := ∑∞ k=t γk ν, µ environments/semimeasures σ multi-agent environment σπ1:n history distribution induced by policies\nπ1, . . . , πn acting in the multi-agent environment σ\nσi subjective environment of agent i π a policy, π : (A× E)∗ → A π∗ν an optimal policy for environment ν V πν the ν-expected value of the policy π V ∗ν the optimal value in environment ν M a countable class of environments MOrefl the class of all reflective-oraclecomputable environments w a universal prior, w ∈ ∆MOrefl ξ the universal mixture over all environments MOrefl, a semimeasure ξ the completion of λOT into a measure using\nthe reflective oracle O"
    } ],
    "references" : [ {
      "title" : "Reflective variants of Solomonoff induction and AIXI",
      "author" : [ "Benja Fallenstein", "Nate Soares", "Jessica Taylor" ],
      "venue" : "In Artificial General Intelligence. Springer,",
      "citeRegEx" : "Fallenstein et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Fallenstein et al\\.",
      "year" : 2015
    }, {
      "title" : "Reflective oracles: A foundation for classical game theory",
      "author" : [ "Benja Fallenstein", "Jessica Taylor", "Paul F Christiano" ],
      "venue" : "Technical report, Machine Intelligence Research Institute,",
      "citeRegEx" : "Fallenstein et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Fallenstein et al\\.",
      "year" : 2015
    }, {
      "title" : "Reflective oracles: A foundation for game theory in artificial intelligence",
      "author" : [ "Benja Fallenstein", "Jessica Taylor", "Paul F Christiano" ],
      "venue" : "In Logic, Rationality, and Interaction,",
      "citeRegEx" : "Fallenstein et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Fallenstein et al\\.",
      "year" : 2015
    }, {
      "title" : "On the impossibility of predicting the behavior of rational agents",
      "author" : [ "Dean P Foster", "H Peyton Young" ],
      "venue" : "Proceedings of the National Academy of Sciences,",
      "citeRegEx" : "Foster and Young.,? \\Q2001\\E",
      "shortCiteRegEx" : "Foster and Young.",
      "year" : 2001
    }, {
      "title" : "Open problems in universal induction & intelligence",
      "author" : [ "Marcus Hutter" ],
      "venue" : null,
      "citeRegEx" : "Hutter.,? \\Q2009\\E",
      "shortCiteRegEx" : "Hutter.",
      "year" : 2009
    }, {
      "title" : "Rational learning leads to Nash equilibrium",
      "author" : [ "Ehud Kalai", "Ehud Lehrer" ],
      "venue" : null,
      "citeRegEx" : "Kalai and Lehrer.,? \\Q1993\\E",
      "shortCiteRegEx" : "Kalai and Lehrer.",
      "year" : 1993
    }, {
      "title" : "Introduction to Metamathematics",
      "author" : [ "Stephen Cole Kleene" ],
      "venue" : "Wolters-Noordhoff Publishing,",
      "citeRegEx" : "Kleene.,? \\Q1952\\E",
      "shortCiteRegEx" : "Kleene.",
      "year" : 1952
    }, {
      "title" : "Nonparametric General Reinforcement Learning",
      "author" : [ "Jan Leike" ],
      "venue" : "PhD thesis, Australian National University,",
      "citeRegEx" : "Leike.,? \\Q2016\\E",
      "shortCiteRegEx" : "Leike.",
      "year" : 2016
    }, {
      "title" : "General time consistent discounting",
      "author" : [ "Tor Lattimore", "Marcus Hutter" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "Lattimore and Hutter.,? \\Q2014\\E",
      "shortCiteRegEx" : "Lattimore and Hutter.",
      "year" : 2014
    }, {
      "title" : "Bad universal priors and notions of optimality",
      "author" : [ "Jan Leike", "Marcus Hutter" ],
      "venue" : "In Conference on Learning Theory, pages 1244–1259,",
      "citeRegEx" : "Leike and Hutter.,? \\Q2015\\E",
      "shortCiteRegEx" : "Leike and Hutter.",
      "year" : 2015
    }, {
      "title" : "On the computability of AIXI",
      "author" : [ "Jan Leike", "Marcus Hutter" ],
      "venue" : "In Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Leike and Hutter.,? \\Q2015\\E",
      "shortCiteRegEx" : "Leike and Hutter.",
      "year" : 2015
    }, {
      "title" : "On the computability of Solomonoff induction and knowledge-seeking",
      "author" : [ "Jan Leike", "Marcus Hutter" ],
      "venue" : "In Algorithmic Learning Theory,",
      "citeRegEx" : "Leike and Hutter.,? \\Q2015\\E",
      "shortCiteRegEx" : "Leike and Hutter.",
      "year" : 2015
    }, {
      "title" : "Thompson sampling is asymptotically optimal in general environments",
      "author" : [ "Jan Leike", "Tor Lattimore", "Laurent Orseau", "Marcus Hutter" ],
      "venue" : "In Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Leike et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Leike et al\\.",
      "year" : 2016
    }, {
      "title" : "An Introduction to Kolmogorov Complexity and Its Applications",
      "author" : [ "Ming Li", "Paul M.B. Vitányi" ],
      "venue" : "Texts in Computer Science. Springer,",
      "citeRegEx" : "Li and Vitányi.,? \\Q2008\\E",
      "shortCiteRegEx" : "Li and Vitányi.",
      "year" : 2008
    }, {
      "title" : "Prediction, optimization, and learning",
      "author" : [ "John H Nachbar" ],
      "venue" : "in repeated games. Econometrica,",
      "citeRegEx" : "Nachbar.,? \\Q1997\\E",
      "shortCiteRegEx" : "Nachbar.",
      "year" : 1997
    }, {
      "title" : "Asymptotic non-learnability of universal agents with computable horizon functions",
      "author" : [ "Laurent Orseau" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "Orseau.,? \\Q2013\\E",
      "shortCiteRegEx" : "Orseau.",
      "year" : 2013
    }, {
      "title" : "Multiagent Systems: Algorithmic, GameTheoretic, and Logical Foundations",
      "author" : [ "Yoav Shoham", "Kevin Leyton-Brown" ],
      "venue" : null,
      "citeRegEx" : "Shoham and Leyton.Brown.,? \\Q2009\\E",
      "shortCiteRegEx" : "Shoham and Leyton.Brown.",
      "year" : 2009
    }, {
      "title" : "Complexity-based induction systems: Comparisons and convergence theorems",
      "author" : [ "Ray Solomonoff" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "Solomonoff.,? \\Q1978\\E",
      "shortCiteRegEx" : "Solomonoff.",
      "year" : 1978
    } ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "A Bayesian agent acting in a multi-agent environment learns to predict the other agents’ policies if its prior assigns positive probability to them (in other words, its prior contains a grain of truth). Finding a reasonably large class of policies that contains the Bayes-optimal policies with respect to this class is known as the grain of truth problem. Only small classes are known to have a grain of truth and the literature contains several related impossibility results. In this paper we present a formal and general solution to the full grain of truth problem: we construct a class of policies that contains all computable policies as well as Bayes-optimal policies for every lower semicomputable prior over the class. When the environment is unknown, Bayes-optimal agents may fail to act optimally even asymptotically. However, agents based on Thompson sampling converge to play ε-Nash equilibria in arbitrary unknown computable multi-agent environments. While these results are purely theoretical, we show that they can be computationally approximated arbitrarily closely.",
    "creator" : "LaTeX with hyperref package"
  }
}