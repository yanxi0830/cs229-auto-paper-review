{
  "name" : "1506.06081.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Convergent Gradient Descent Algorithm for Rank Minimization and Semidefinite Programming from Random Linear Measurements",
    "authors" : [ "Qinqing Zheng", "John Lafferty" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Semidefinite programming has become a key optimization tool in many areas of applied mathematics, signal processing and machine learning. SDPs often arise naturally from the problem structure, or are derived as surrogate optimizations that are relaxations of difficult combinatorial problems [7, 1, 8]. In spite of the importance of SDPs in principle—promising efficient algorithms with polynomial runtime guarantees—it is widely recognized that current optimization algorithms based on interior point methods can handle only relatively small problems. Thus, a considerable gap exists between the theory and applicability of SDP formulations. Scalable algorithms for semidefinite programming, and closely related families of nonconvex programs more generally, are greatly needed.\nA parallel development is the surprising effectiveness of simple classical procedures such as gradient descent for large scale problems, as explored in the recent machine learning literature. In many areas of machine learning and signal processing such as classification, deep learning, and phase retrieval, gradient descent methods, in particular first order stochastic optimization, have led to remarkably efficient algorithms that can attack very large scale problems [3, 2, 10, 6]. In this paper we build on this work to develop first-order algorithms for solving the rank minimization problem under random measurements and a closely related family of semidefinite programs. Our algorithms are efficient and scalable, and we prove that they attain linear convergence to the global optimum under natural assumptions.\nThe affine rank minimization problem is to find a matrix X? ∈ Rn×p of minimum rank satisfying constraints A(X?) = b, where A : Rn×p −→ Rm is an affine transformation. The underde-\nar X\niv :1\n50 6.\n06 08\n1v 3\n[ st\nat .M\nL ]\n2 4\nM ar\ntermined case where m np is of particular interest, and can be formulated as the optimization\nmin X∈Rn×p\nrank(X)\nsubject to A(X) = b. (1)\nThis problem is a direct generalization of compressed sensing, and subsumes many machine learning problems such as image compression, low rank matrix completion and low-dimensional metric embedding [18, 12]. While the problem is natural and has many applications, the optimization is nonconvex and challenging to solve. Without conditions on the transformation A or the minimum rank solution X?, it is generally NP hard [15].\nExisting methods, such as nuclear norm relaxation [18], singular value projection (SVP) [11], and alternating least squares (AltMinSense) [12], assume that a certain restricted isometry property (RIP) holds for A. In the random measurement setting, this essentially means that at least O(r(n + p) log(n + p)) measurements are available, where r = rank(X?) [18]. In this work, we assume that (i) X? is positive semidefinite and (ii) A : Rn×n −→ Rm is defined as A(X)i = tr(AiX), where each Ai is a random n×n symmetric matrix from the Gaussian Orthogonal Ensemble (GOE), with (Ai)jj ∼ N (0, 2) and (Ai)jk ∼ N (0, 1) for j 6= k. Our goal is thus to solve the optimization\nmin X 0\nrank(X)\nsubject to tr(AiX) = bi, i = 1, . . . ,m. (2)\nIn addition to the wide applicability of affine rank minimization, the problem is also closely connected to a class of semidefinite programs. In Section 2, we show that the minimizer of a particular class of SDP can be obtained by a linear transformation of X?. Thus, efficient algorithms for problem (2) can be applied in this setting as well.\nNoting that a rank-r solution X? to (2) can be decomposed as X? = Z?Z?> where Z? ∈ Rn×r, our approach is based on minimizing the squared residual\nf(Z) = 1\n4m ∥∥A(ZZ>)− b∥∥2 = 1 4m m∑ i=1 ( tr(Z>AiZ)− bi )2 .\nWhile this is a nonconvex function, we take motivation from recent work for phase retrieval by Candès et al. [6], and develop a gradient descent algorithm for optimizing f(Z), using a carefully constructed initialization and step size. Our main contributions concerning this algorithm are as follows.\n• We prove that withO(r3n log n) constraints our gradient descent scheme can exactly recover X? with high probability. Empirical experiments show that this bound may potentially be improved to O(rn log n).\n• We show that our method converges linearly, and has lower computational cost compared with previous methods.\n• We carry out a detailed comparison of rank minimization algorithms, and demonstrate that when the measurement matricesAi are sparse, our gradient method significantly outperforms alternative approaches.\nIn Section 3 we briefly review related work. In Section 4 we discuss the gradient scheme in detail. Our main analytical results are presented in Section 5, with detailed proofs contained in the supplementary material. Our experimental results are presented in Section 6, and we conclude with a brief discussion of future work in Section 7."
    }, {
      "heading" : "2 Semidefinite Programming and Rank Minimization",
      "text" : "Before reviewing related work and presenting our algorithm, we pause to explain the connection between semidefinite programming and rank minimization. This connection enables our scalable gradient descent algorithm to be applied and analyzed for certain classes of SDPs.\nConsider a standard form semidefinite program\nmin X̃ 0\ntr(C̃X̃)\nsubject to tr(ÃiX̃) = bi, i = 1, . . . ,m (3)\nwhere C̃, Ã1, . . . , Ãm ∈ Sn. If C̃ is positive definite, then we can write C̃ = LL> where L ∈ Rn×n is invertible. It follows that the minimum of problem (3) is the same as\nmin X 0\ntr(X)\nsubject to tr(AiX) = bi, i = 1, . . . ,m (4)\nwhere Ai = L−1ÃiL−1 >. In particular, minimizers X̃∗ of (3) are obtained from minimizers X∗ of (4) via the transformation X̃∗ = L−1 > X∗L−1.\nSince X is positive semidefinite, tr(X) is equal to ‖X‖∗. Hence, problem (4) is the nuclear norm relaxation of problem (2). Next, we characterize the specific cases where X∗ = X?, so that the SDP and rank minimization solutions coincide. The following result is from Recht et al. [18].\nTheorem 1. Let A : Rn×n −→ Rm be a linear map. For every integer k with 1 ≤ k ≤ n, define the k-restricted isometry constant to be the smallest value δk such that\n(1− δk) ‖X‖F ≤ ‖A(X)‖ ≤ (1 + δk) ‖X‖F\nholds for any matrix X of rank at most k. Suppose that there exists a rank r matrix X? such that A(X?) = b. If δ2r < 1, then X? is the only matrix of rank at most r satisfying A(X) = b. Furthermore, if δ5r < 1/10, then X? can be attained by minimizing ‖X‖∗ over the affine subset.\nIn other words, since δ2r ≤ δ5r, if δ5r < 1/10 holds for the transformation A and one finds a matrix X of rank r satisfying the affine constraint, then X must be positive semidefinite. Hence, one can ignore the semidefinite constraint X 0 when solving the rank minimization (2). The resulting problem then can be exactly solved by nuclear norm relaxation. Since the minimum rank solution is positive semidefinite, it then coincides with the solution of the SDP (4), which is a constrained nuclear norm optimization.\nThe observation that one can ignore the semidefinite constraint justifies our experimental comparison with methods such as nuclear norm relaxation, SVP, and AltMinSense, described in the following section."
    }, {
      "heading" : "3 Related Work",
      "text" : "Burer and Monteiro [4] proposed a general approach for solving semidefinite programs using factored, nonconvex optimization, giving mostly experimental support for the convergence of the algorithms. The first nontrivial guarantee for solving affine rank minimization problem is given by Recht et al. [18], based on replacing the rank function by the convex surrogate nuclear norm, as already mentioned in the previous section. While this is a convex problem, solving it in practice is nontrivial, and a variety of methods have been developed for efficient nuclear norm minimization. The most popular algorithms are proximal methods that perform singular value thresholding [5] at every iteration. While effective for small problem instances, the computational expense of the SVD prevents the method from being useful for large scale problems.\nRecently, Jain et al. [11] proposed a projected gradient descent algorithm SVP (Singular Value Projection) that solves\nmin X∈Rn×p\n‖A(X)− b‖2\nsubject to rank(X) ≤ r,\nwhere ‖·‖ is the `2 vector norm and r is the input rank. In the (t+1)th iteration, SVP updatesX t+1 as the best rank r approximation to the gradient updateX t−µA>(A(X t)−b), which is constructed from the SVD. If rank(X?) = r, then SVP can recover X? under a similar RIP condition as the nuclear norm heuristic, and enjoys a linear numerical rate of convergence. Yet SVP suffers from the expensive per-iteration SVD for large problem instances.\nSubsequent work of Jain et al. [12] proposes an alternating least squares algorithm AltMinSense that avoids the per-iteration SVD. AltMinSense factorizes X into two factors U ∈ Rn×r, V ∈ Rp×r such thatX = UV > and minimizes the squared residual ∥∥A(UV >)− b∥∥2 by updating U and V alternately. Each update is a least squares problem. The authors show that the iterates obtained by AltMinSense converge to X? linearly under a RIP condition. However, the least squares problems are often ill-conditioned, it is difficult to observe AltMinSense converging to X? in practice.\nAs described above, considerable progress has been made on algorithms for rank minimization and certain semidefinite programming problems. Yet truly efficient, scalable and provably convergent algorithms have not yet been obtained. In the specific setting that X? is positive semidefinite, our algorithm exploits this structure to achieve these goals. We note that recent and independent\nwork of Tu et al. [21] proposes a hybrid algorithm called Procrustes Flow (PF), which uses a few iterations of SVP as initialization, and then applies gradient descent."
    }, {
      "heading" : "4 A Gradient Descent Algorithm for Rank Minimization",
      "text" : "Our method is described in Algorithm 1. It is parallel to the Wirtinger Flow (WF) algorithm for phase retrieval [6], to recover a complex vector x ∈ Cn given the squared magnitudes of its linear measurements bi = |〈ai, x〉|2, i ∈ [m], where a1, . . . , am ∈ Cn. Candès et al. [6] propose a first-order method to minimize the sum of squared residuals\nfWF(z) = n∑ i=1 ( |〈ai, z〉|2 − bi )2 . (5)\nThe authors establish the convergence of WF to the global optimum—given sufficient measurements, the iterates of WF converge linearly to x up to a global phase, with high probability.\nIf z and the ais are real-valued, the function fWF(z) can be expressed as\nfWF(z) = n∑ i=1 ( z>aia > i z − x>aia>i x )2 ,\nwhich is a special case of f(Z) whereAi = aia>i and each of Z andX ? are rank one. See Figure 1a for an illustration; Figure 1b shows the convergence rate of our method. Our methods and results are thus generalizations of Wirtinger flow for phase retrieval.\nBefore turning to the presentation of our technical results in the following section, we present some intuition and remarks about how and why this algorithm works. For simplicity, let us assume that the rank is specified correctly.\nInitialization is of course crucial in nonconvex optimization, as many local minima may be present. To obtain a sufficiently accurate initialization, we use a spectral method, similar to those used in [17, 6]. The starting point is the observation that a linear combination of the constraint values and matrices yields an unbiased estimate of the solution.\nLemma 1. Let M = 1 m ∑m i=1 biAi. Then 1 2 E(M) = X?, where the expectation is with respect to the randomness in the measurement matrices Ai.\nBased on this fact, let X? = U?ΣU?> be the eigenvalue decomposition of X?, where U? = [u?1, . . . , u ? r] and Σ = diag(σ1, . . . , σr) such that σ1 ≥ . . . ≥ σr are the nonzero eigenvalues of X?. Let Z? = U?Σ 1 2 . Clearly, u?s = z ? s/ ‖z?s‖ is the top sth eigenvector of E(M) associated with eigenvalue 2 ‖z?s‖ 2. Therefore, we initialize according to z0s = √ |λs| 2 vs where (vs, λs) is the top sth eigenpair of M . For sufficiently large m, it is reasonable to expect that Z0 is close to Z?; this is confirmed by concentration of measure arguments.\nCertain key properties of f(Z) will be seen to yield a linear rate of convergence. In the analysis of convex functions, Nesterov [16] shows that for unconstrained optimization, the gradient descent\nscheme with sufficiently small step size will converge linearly to the optimum if the objective function is strongly convex and has a Lipschitz continuous gradient. However, these two properties are global and do not hold for our objective function f(Z). Nevertheless, we expect that similar conditions hold for the local area near Z?. If so, then if we start close enough to Z?, we can achieve the global optimum.\nIn our subsequent analysis, we establish the convergence of Algorithm 1 with a constant step size of the form µ/ ‖Z?‖2F , where µ is a small constant. Since ‖Z?‖F is unknown, we replace it by ‖Z0‖F ."
    }, {
      "heading" : "5 Convergence Analysis",
      "text" : "In this section we present our main result analyzing the gradient descent algorithm, and give a sketch of the proof. To begin, note that the symmetric decomposition of X? is not unique, since X? = (Z?U)(Z?U)> for any r × r orthonormal matrix U . Thus, the solution set is\nS = { Z̃ ∈ Rn×r | Z̃ = Z?U for some U with UU> = U>U = I } .\nNote that ‖Z̃‖2F = ‖X?‖∗ for any Z̃ ∈ S. We define the distance to the optimal solution in terms of this set.\nDefinition 1. Define the distance between Z and Z? as\nd(Z,Z?) = min UU>=U>U=I ‖Z − Z?U‖F = min Z̃∈S\n∥∥Z − Z̃∥∥ F .\nAlgorithm 1: Gradient descent for rank minimization input: {Ai, bi}mi=1, r, µ initialization\nSet (v1, λ1), . . . , (vr, λr) to the top r eigenpairs of 1m ∑m i=1 biAi s.t. |λ1| ≥ · · · ≥ |λr|\nZ0 = [z01 , . . . , z 0 r ] where z 0 s = √ |λs| 2 · vs, s ∈ [r]\nk ← 0 repeat\n∇f(Zk) = 1 m m∑ i=1 ( tr(Zk>AiZk)− bi ) AiZ k\nZk+1 = Zk − µ∑r s=1 |λs|/2 ∇f(Zk)\nk ← k + 1 until convergence; output: X̂ = ZkZk>\nOur main result for exact recovery is stated below, assuming that the rank is correctly specified. Since the true rank is typically unknown in practice, one can start from a very low rank and gradually increase it.\nTheorem 2. Let the condition number κ = σ1/σr denote the ratio of the largest to the smallest nonzero eigenvalues of X?. There exists a universal constant c0 such that if m ≥ c0κ2r3n log n, with high probability the initialization Z0 satisfies\nd(Z0, Z?) ≤ √ 3\n16 σr. (6)\nMoreover, there exists a universal constant c1 such that when using constant step size µ/ ‖Z?‖2F with µ ≤ c1\nκn and initial value Z0 obeying (6), the kth step of Algorithm 1 satisfies d(Zk, Z?) ≤ √ 3\n16 σr\n( 1− µ\n12κr )k/2 with high probability.\nWe now outline the proof, giving full details in the supplementary material. The proof has four main steps. The first step is to give a regularity condition under which the algorithm converges linearly if we start close enough to Z?. This provides a local regularity property that is similar to the Nesterov [16] criteria that the objective function is strongly convex and has a Lipschitz continuous gradient.\nDefinition 2. Let Z = arg minZ̃∈S ∥∥Z − Z̃∥∥ F denote the matrix closest to Z in the solution set. We say that f satisfies the regularity condition RC(ε, α, β) if there exist constants α, β such that for any Z satisfying d(Z,Z?) ≤ ε, we have\n〈∇f(Z), Z −Z〉 ≥ 1 α σr ∥∥Z −Z∥∥2 F +\n1\nβ ‖Z?‖2F ‖∇f(Z)‖2F .\nUsing this regularity condition, we show that the iterative step of the algorithm moves closer to the optimum, if the current iterate is sufficiently close.\nTheorem 3. Consider the update Zk+1 = Zk − µ ‖Z?‖2F ∇f(Zk). If f satisfies RC(ε, α, β), d(Zk, Z?) ≤ ε, and 0 < µ < min(α/2, 2/β), then\nd(Zk+1, Z?) ≤ √\n1− 2µ ακr d(Zk, Z?).\nIn the next step of the proof, we condition on two events that will be shown to hold with high probability using concentration results. Let δ denote a small value to be specified later.\nA1 For any u ∈ Rn such that ‖u‖ ≤ √σ1,∥∥∥∥∥ 1m m∑ i=1 (u>Aiu)Ai − 2uu> ∥∥∥∥∥ ≤ δr .\nA2 For any Z̃ ∈ S, ∥∥∥∥∥∂2f(Z̃)∂z̃s∂z̃>k − E [ ∂2f(Z̃) ∂z̃s∂z̃>k ]∥∥∥∥∥ ≤ δr , for all s, k ∈ [r]. Here the expectations are with respect to the random measurement matrices. Under these assumptions, we can show that the objective satisfies the regularity condition with high probability.\nTheorem 4. Suppose that A1 and A2 hold. If δ ≤ 1 16 σr, then f satisfies the regularity condition RC( √\n3 16 σr, 24, 513κn) with probability at least 1−mCe−ρn, where C, ρ are universal constants.\nNext we show that under A1, a good initialization can be found.\nTheorem 5. Suppose that A1 holds. Let {vs, λs}rs=1 be the top r eigenpairs of M = 1 m m∑ i=1 biAi\nsuch that |λ1| ≥ · · · ≥ |λr|. Let Z0 = [z1, . . . , zr] where zs = √ |λs| 2 · vs, s ∈ [r]. If δ ≤ σr4√r , then\nd(Z0, Z?) ≤ √\n3σr/16.\nFinally, we show that conditioning on A1 and A2 is valid since these events have high probability as long as m is sufficiently large.\nTheorem 6. If the number of samples m ≥ 42 min(δ2/r2σ21, δ/rσ1) n log n, then for any u ∈ Rn\nsatisfying ‖u‖ ≤ √σ1, ∥∥∥∥∥ 1m m∑ i=1 (u>Aiu)Ai − 2uu> ∥∥∥∥∥ ≤ δr holds with probability at least 1−mCe−ρn − 2 n2 , where C and ρ are universal constants.\nTheorem 7. For any x ∈ Rn, if m ≥ 128 min(δ2/4r2σ21, δ/2rσ1) n log n, then for any Z̃ ∈ S\n∥∥∥∥∥∂2f(Z̃)∂z̃s∂z̃>k − E [ ∂2f(Z̃) ∂z̃s∂z̃>k ]∥∥∥∥∥ ≤ δr , for all s, k ∈ [r], with probability at least 1− 6me−n − 4\nn2 . Note that since we need δ ≤ min (\n1 16 , 1 4 √ r ) σr, we have δrσ1 ≤ 1, and the number of measure-\nments required by our algorithm scales as O(r3κ2n log n), while only O(r2κ2n log n) samples are required by the regularity condition. We conjecture this bound could be further improved to be O(rn log n); this is supported by the experimental results presented below.\nRecently, Tu et al. [21] establish a tighter O(r2κ2n) bound overall. Specifically, when only one single SVP step is used in preprocessing, the initialization of PF is also the spectral decomposition of 1\n2 M . The authors show that O(r2κ2n) measurements are sufficient for the initial solution to\nsatisfy d(Z0, Z?) ≤ O(√σr) with high probability, and demonstrate an O(rn) sample complexity for the regularity condition."
    }, {
      "heading" : "6 Experiments",
      "text" : "In this section we report the results of experiments on synthetic datasets. We compare our gradient descent algorithm with nuclear norm relaxation, SVP and AltMinSense for which we drop the positive semidefiniteness constraint, as justified by the observation in Section 2. We use ADMM for the nuclear norm minimization, based on the algorithm for the mixture approach in Tomioka et al. [19]; see Appendix G. For simplicity, we assume that AltMinSense, SVP and the gradient scheme know the true rank. Krylov subspace techniques such as the Lanczos method could be used compute the partial eigendecomposition; we use the randomized algorithm of Halko et al. [9] to compute the low rank SVD. All methods are implemented in MATLAB and the experiments were run on a MacBook Pro with a 2.5GHz Intel Core i7 processor and 16 GB memory."
    }, {
      "heading" : "6.1 Computational Complexity",
      "text" : "It is instructive to compare the per-iteration cost of the different approaches; see Table 1. Suppose that the density (fraction of nonzero entries) of each Ai is ρ. For AltMinSense, the cost of solving the least squares problem is O(mn2r2 + n3r3 + mn2rρ). The other three methods have O(mn2ρ) cost to compute the affine transformation. For the nuclear norm approach, the O(n3) cost is from the SVD and the O(m2) cost is due to the update of the dual variables. The gradient scheme requires 2n2r operations to compute ZkZk> and to multiply Zk by n× n matrix to obtain the gradient. SVP needs O(n2r) operations to compute the top r singular vectors. However, in practice this partial SVD is more expensive than the 2n2r cost required for the matrix multiplies in the gradient scheme.\nClearly, AltMinSense is the least efficient. For the other approaches, in the dense case (ρ large), the affine transformation dominates the computation. Our method removes the overhead caused by the SVD. In the sparse case (ρ small), the other parts dominate and our method enjoys a low cost."
    }, {
      "heading" : "6.2 Runtime Comparison",
      "text" : "We conduct experiments for both dense and sparse measurement matrices. AltMinSense is indeed slow, so we do not include it here.\nIn the first scenario, we randomly generate a 400 × 400 rank-2 matrix X? = xx> + yy> where x, y ∼ N (0, I). We also generate m = 6n matrices A1, . . . , Am from the GOE, and then take b = A(X?). We report the relative error measured in the Frobenius norm defined as ‖X̂ −X?‖F/‖X?‖F . For the nuclear norm approach, we set the regularization parameter to λ = 10−5. We test three values η = 10, 100, 200 for the penalty parameter and select η = 100 as it leads to the fastest convergence. Similarly, for SVP we evaluate the three values 5×10−5, 10−4, 2×10−4 for the step size, and select 10−4 as the largest for which SVP converges. For our approach, we test the three values 0.6, 0.8, 1.0 for µ and select 0.8 in the same way.\nIn the second scenario, we use a more general and practical setting. We randomly generate a rank-2 matrix X? ∈ R600×600 as before. We generate m = 7n sparse Ais whose entries are i.i.d. Bernoulli:\n(Ai)jk = { 1 with probability ρ, 0 with probability 1− ρ,\nwhere we use ρ = 0.001. For all the methods we use the same strategies as before to select parameters. For the nuclear norm approach, we try three values η = 10, 100, 200 and select η = 100. For SVP, we test the three values 5 × 10−3, 2 × 10−3, 10−3 for the step size and select 10−3. For the gradient algorithm, we check the three values 0.8, 1, 1.5 for µ and choose 1.\nThe results are shown in Figures 2a and 2b. In the dense case, our method is faster than the nuclear norm approach and slightly outperforms SVP. In the sparse case, it is significantly faster than the other approaches."
    }, {
      "heading" : "6.3 Sample Complexity",
      "text" : "We also evaluate the number of measurements required by each method to exactly recover X?, which we refer to as the sample complexity. We randomly generate the true matrix X? ∈ Rn×n and compute the solutions of each method given m measurements, where the Ais are randomly drawn from the GOE. A solution with relative error below 10−5 is considered to be successful. We run 40 trials and compute the empirical probability of successful recovery.\nWe consider cases where n = 60 or 100 and X? is of rank one or two. The results are shown in Figure 2c. For SVP and our approach, the phase transitions happen around m = 1.5n when X? is rank-1 and m = 2.5n when X? is rank-2. This scaling is close to the number of degrees of freedom in each case; this confirms that the sample complexity scales linearly with the rank r. The phase transition for the nuclear norm approach occurs later. The results suggest that the sample complexity of our method should also scale as O(rn log n) as for SVP and the nuclear norm approach [11, 18]."
    }, {
      "heading" : "7 Conclusion",
      "text" : "We connect a special case of affine rank minimization to a class of semidefinite programs with random constraints. Building on a recently proposed first-order algorithm for phase retrieval [6], we develop a gradient descent procedure for rank minimization and establish convergence to the optimal solution with O(r3n log n) measurements. We conjecture that O(rn log n) measurements are sufficient for the method to converge, and that the conditions on the sampling matrices Ai can be significantly weakened. More broadly, the technique used in this paper—factoring the semidefinite matrix variable, recasting the convex optimization as a nonconvex optimization, and applying first-order algorithms—first proposed by Burer and Monteiro [4], may be effective for a much wider class of SDPs, and deserves further study."
    }, {
      "heading" : "Acknowledgements",
      "text" : "Research supported in part by NSF grant IIS-1116730 and ONR grant N00014-12-1-0762. The authors thank Afonso Bandeira, Ryota Tomioka and the authors of Tu et al. [21] for helpful comments on this work."
    }, {
      "heading" : "A Proof of Lemma 1",
      "text" : "Let A = (aij) be a random matrix that is GOE distributed; thus aij ∼ N (0, 1) for i 6= j and aii ∼ N (0, 2). We have E(M) = ∑r s=1 E((z?s\n>Az?s)A). Hence, it suffices to show that E((x>Ax)A) = 2xx> for any x ∈ Rn. The (i, j) entry of (x>Ax)A has expected value\nE((x>Ax)aij) = E (∑ k ∑ l xkxlaklaij ) = ∑ k ∑ l xkxlE(aklaij)\n= ∑ k ∑ l xkxl · { 0 if (k, l) 6= (i, j) ∧ (k, l) 6= (j, i) E(a2kl) otherwise\n= { 2xixjE(a2ij) if i 6= j x2iE(a2ii) otherwise\n= { 2xixj if i 6= j, 2x2i otherwise,\nwhere we use that the variance of aii is 2 and the variance of aij is 1 for any i 6= j. In matrix form, this is E((x>Ax)A) = 2xx>.\nB Ingredients We first present some technical lemmas that will be needed later. Recall Definition 2 that for any Z, Z = arg minZ̃∈S ∥∥Z − Z̃∥∥ F\n. Let H = Z −Z . The sth column of Z, Z , Z?, H are denoted by zs, z̄s, z?s , hs respectively. We shall use the following formulas for the gradient and second order partial derivatives:\n∇f(Z) = 1 m m∑ i=1 ( tr(H>AiH) + 2 tr(Z>AiH) ) (AiH + AiZ),\n∂2f(Z) ∂zs∂z>s = 1 m m∑ i=1 ( 2Aizsz > s A > i + ( tr(Z>AiZ)− bi ) Ai ) , ∀s ∈ [r],\n∂2f(Z) ∂zs∂z>k = 1 m m∑ i=1 2Aizsz > k A > i , ∀s, k ∈ [r] such that s 6= k.\nThe next ingredient we need is the expectation of the second order partial derivatives with respect to the random measurement matrices.\nLemma 2. Let A = (aij) be a GOE distributed random matrix. For any two fixed vectors x and y, we have E [AxyA] = x>yI + yx>.\nProof. The expectation of (i, j) entry of Axy>A is\nE[(Axy>A)ij] = E (∑ k l aikajkxkyl ) .\nIf i = j, then we have\nE[(Axy>A)ii] = E (∑ k a2ikxkyk ) = ∑ k xkyk + xiyi,\nsince Var(a2ii) = 2 and Var(a2ik) = 1 if k 6= i. On the other hand, if i 6= j, then\nE[(Axy>A)ij] = E (∑ kl aikajlxkyl ) = E(a2ijxjyi) = xjyi.\nTherefore, E(Axy>A) = x>yI + yx>. Lemma 3. For all s ∈ [r], it holds that E [ ∂2f(Z)\n∂zs∂z>s\n] = 2 ‖zs‖2 I + 2zsz>s + 2ZZ> − 2X? and\nE [ ∂2f(Z)\n∂zs∂z>k\n] = 2z>s zkI + 2zkz > s for all k ∈ [r] such that k 6= s, where the expectation is over the\nrandom measurement matrices.\nProof. The case where k 6= s is a direct result of Lemma 2. For the other case, let A = (aij) be a GOE distributed random matrix. It follows from Lemma 1 that\nE [ ∂2f(Z)\n∂zs∂z>s\n] = 2E(Azsz>s A) + 2ZZ> − 2X?.\nBy Lemma 2, we have E(Azsz>s A) = ‖zs‖ 2 I + zsz > s .\nSubstituting this back into the above equation, we obtain the lemma.\nWe next recall a concentration result for the operator (spectral) norm of the random measurement matrices.\nLemma 4. (Ledoux and Rider [14, Theorem 1]) There exists two absolute constants C and ρ = 1√ 8C such that with probability at least 1− Ce−ρn,\n‖Ai‖ ≤ 3 √ n.\nA tighter upper bound is actually given in the Tracy-Widow law: w.h.p. ‖Ai‖ = O(2 √ n+n1/6).\nCorollary 1. With probability at least 1 −mCe−ρn, the average of the squared operator norm of the random measurement matrices is upper bounded by 9n.\nProof. Applying a union bound we have\nP\n( 1\nm m∑ i=1 ‖Ai‖2 ≤ 9n\n) ≥ P ( ∀i, ‖Ai‖ ≤ 3 √ n )\n≥ 1− m∑ i=1 P ( ‖Ai‖ > 3 √ n ) ≥ 1−mCe−ρn,\nwhere we use Lemma 4 in the last line.\nThe following two technical lemmas are important tools for us. Define the set\nE(ε) = {Z | d(Z,Z?) ≤ ε} .\nLemma 5. Suppose that A1 holds: ∥∥ 1 m ∑m i=1(u >Aiu)Ai − 2uu> ∥∥ ≤ δ r , for any u such that ‖u‖ ≤ √ σ1. If δ ≤ 116σr, then for any Z ∈ E (√ 3 16 σr ) it holds that\n2 ∥∥HH>∥∥2\nF − δ ‖H‖2F ≤\n1\nm m∑ i=1 tr(H>AiH)2 ≤ δ ‖H‖2F + 2 ∥∥HH>∥∥2 F .\nProof. Let hs be the sth column of H . Since maxs∈[r] ‖hs‖2 ≤ ‖H‖F ≤ √ 3 16 σr ≤ √ σ1, it follows from the assumption of the lemma that∥∥∥∥∥ 1m m∑ i=1 (h>s Aihs)Ai − 2hsh>s\n∥∥∥∥∥ ≤ δr , s = 1, . . . , r. By the triangle inequality, we have∥∥∥∥∥ 1m m∑ i=1 r∑ s=1 (h>s Aihs)Ai − 2 r∑ s=1 hsh > s\n∥∥∥∥∥ ≤ δ and consequently\n−δ ‖hs‖2 ≤ h>s\n( 1\nm m∑ i=1 tr(H>AiH)Ai − 2HH> ) h>s ≤ δ ‖hs‖ 2 , s = 1, . . . , r,\nwhere we replace r∑ s=1 h>s Aihs by tr(H >AiH) and ∑r s=1 hsh > s by HH >. Taking the sum of the above inequalities, we obtain\n−δ ‖H‖2F ≤ 1\nm m∑ i=1 tr(H>AiH)2 − 2 tr(H>HH>H) ≤ δ ‖H‖2F .\nNote that tr(H>HH>H) = ∥∥HH>∥∥2\nF . Therefore,\n2 ∥∥HH>∥∥2\nF − δ ‖H‖2F ≤\n1\nm m∑ i=1 tr(H>AiH)2 ≤ δ ‖H‖2F + 2 ∥∥HH>∥∥2 F .\nLemma 6. Suppose that A2 holds: for any Z̃ such that Z̃Z̃> = X? we have∥∥∥∥∥∂2f(Z̃)∂z̃s∂z̃>k − E [ ∂2f(Z̃) ∂z̃s∂z̃>k ]∥∥∥∥∥ ≤ δr , s, k = 1, . . . , r. (7) Then(\nσr − δ\n2\n) ‖H‖2F + ∥∥H>Z∥∥2 F ≤ 1 m m∑ i=1 tr(H>AiZ)2 ≤ ( σ1 + δ 2 ) ‖H‖2F + ∥∥H>Z∥∥2 F .\nProof. Our goal is to bound 1 m m∑ i=1 tr(H>AiZ)2. This can be expanded as\n1\nm m∑ i=1 ( r∑ s=1 (h>s Aiz̄s) )2 = 1 m m∑ i=1 r∑ s=1 (h>s Aixs) 2 + 1 m m∑ i=1 ∑ s<k 2(h>s Aixs)(h > k Aixk).\nWe first bound the sum of the quadratic terms. For any s ∈ [r], we have\n∂2f(Z) ∂z̄s∂z̄>s = 1 m m∑ i=1 2Aiz̄sz̄ > s Ai,\nE [ ∂2f(Z)\n∂z̄s∂z̄>s\n] = 2 ‖z̄s‖2 I + 2z̄sz̄>s .\nIt follows from assumption (7) that for any s ∈ [r],\n−δ r ‖hs‖2 ≤ 1 m m∑ i=1 2(h>s Aiz̄s) 2 − 2 ‖z̄s‖2 ‖hs‖2 − 2(h>s z̄s)2 ≤ δ r ‖hs‖2 .\nTaking the sum of above inequalities, we obtain\n− δ 2r r∑ s=1 ‖hs‖2 ≤ 1 m m∑ i=1 r∑ s=1 (h>s Aiz̄s) 2 − r∑ s=1 ‖z̄s‖2 ‖hs‖2 − r∑ s=1 (h>s z̄s) 2 ≤ δ 2r r∑ s=1 ‖hs‖2 . (8)\nSimilarly, we bound the sum of the cross terms. For any fixed s, k such that s 6= k, we have\n∂2f(Z) ∂z̄s∂z̄>k = 1 m f(Z) m∑ i=1 2Aiz̄sz̄ > k Ai,\nE [ ∂2f(Z)\n∂z̄s∂z̄>k\n] = 2z̄>s z̄kI + 2z̄kz̄ > s ,\nand consequently\n−δ r ∑ s<k ‖hs‖ ‖hk‖ ≤ 1 m m∑ i=1 ∑ s<k 2(h>s Aiz̄s)(h > k Aiz̄k)− 2 ∑ s<k z̄>s z̄kh > s hk − 2 ∑ s<k h>s z̄kz̄ > s hk (9)\n≤ δ r ∑ s<k ‖hs‖ ‖hk‖ .\nWe combine equations (9) and (8) to get\n− δ 2r ∑ sk ‖hs‖ ‖hk‖ ≤ 1 m m∑ i=1 tr(H>AiZ)2− ∑ sk z̄>s z̄kh > s hk− ∑ sk h>s z̄kz̄ > s hk ≤ δ 2r ∑ sk ‖hs‖ ‖hk‖ . (10) Note that ∑ sk h > s z̄kz̄ > s hk = tr(H >ZH>Z), ∑ sk z̄ > s z̄kh > s hk = ∥∥ZH>∥∥2 F and\n∑ sk ‖hs‖ ‖hk‖ = ( r∑ s=1 ‖hs‖ )2 ≤ r r∑ s=1 ‖hs‖2 = r ‖H‖2F .\nBy Lemma 7, tr(H>ZH>Z) = ∥∥H>Z∥∥2\nF . Replacing those terms in equation (10) gives us\n−δ 2 ‖H‖2F + ∥∥ZH>∥∥2 F + ∥∥H>Z∥∥2 F ≤ 1 m m∑ i=1 tr(H>AiZ)2 ≤ δ 2 ‖H‖2F + ∥∥ZH>∥∥2 F + ∥∥H>Z∥∥2 F .\nFinally, we obtain the claim by noticing that\n√ σr ‖H‖F ≤ ∥∥ZH>∥∥ F ≤ √ σ1 ‖H‖F ,\nwhere √ σ1 = σmax(Z) ≥ · · · ≥ σmin(Z) = √ σr are the singular values ofZ .\nLemma 7. tr(H>ZH>Z) = ∥∥H>Z∥∥2\nF .\nProof. Let Ū = arg minUU>=U>U=I ‖Z − Z?U‖ 2 F = arg maxUU>=U>U=I〈U,Z? >Z〉. Note that 〈A,B〉 ≤ ‖A‖∗ ‖B‖ for any matrices A,B that are of the same size. The equality holds when B = UAV > A whereA = UAΣAV > A is the SVD ofA. Hence, Ū = Ũ Ṽ\n> where Ũ S̃Ṽ > is the SVD of Z?>Z; Z = Z?Ū . Therefore, Z>Z = Z>Z?Ū = Ṽ S̃Ṽ > is symmetric and positive semidefinite. Thus, H>Z = Z>Z −Z>Z is also symmetric. This implies that tr(H>ZH>Z) = ∥∥H>Z∥∥2 F ."
    }, {
      "heading" : "C Linear Convergence",
      "text" : "Proof of Theorem 3\nLet Hk = Zk −Zk. Then we have that ∥∥Zk+1 −Zk∥∥2 F = ∥∥∥∥∥Zk − µ‖Z?‖2F∇f(Zk)−Zk ∥∥∥∥∥ 2\nF = ∥∥Hk∥∥2\nF +\nµ2\n‖Z?‖4F ∥∥∇f(Zk)∥∥2 F − 2µ ‖Z?‖2F 〈∇f(Zk), Hk〉\n≤ ∥∥Hk∥∥2\nF +\nµ2\n‖Z?‖4F ∥∥∇f(Zk)∥∥2 F − 2µ ‖Z?‖2F\n( 1\nα σr ∥∥Hk∥∥2 F +\n1\nβ ‖Z?‖2F\n∥∥∇f(Zk)∥∥2 F\n)\n= ( 1− 2µ\nα · σr∑r\ns=1 σs\n)∥∥Hk∥∥2 F\n+ µ(µ− 2/β) ‖Z?‖4F\n∥∥∇f(Zk)∥∥2 F\n≤ (\n1− 2µ α · σr rσ1\n)∥∥Hk∥∥2 F\n= ( 1− 2µ\nακr\n) d(Zk, Z?)2,\nwhere we use the definition of RC(ε, α, β) in the third line, ‖Z?‖2F = ‖X?‖∗ = ∑r\ns=1 σs in the third to last line and 0 < µ < min {α/2, 2/β} in the second to last line. Therefore,\nd(Zk+1, Z?) = min Z̃∈S ∥∥∥Zk+1 − Z̃∥∥∥2 F ≤ √ 1− 2µ ακr d(Zk, Z?)."
    }, {
      "heading" : "D Regularity Condition",
      "text" : "As mentioned before, Nesterov [16, Theorem 2.1.11] shows that the gradient scheme converges linearly under a condition similar to the regularity condition, which is satisfied if the function is strongly convex and has a Lipschitz continuous gradient (strongly smooth). In order to prove Theorem 4, we show that with high probability the function f satisfies the local curvature condition, which is analogous to strong convexity, and the local smoothness condition, which is analogous to strong smoothness.\nC1 Local Curvature Condition There exists a constant C1 such that for any Z satisfying d(Z,Z?) ≤ √ 3 16 σr,\n〈∇f(Z), Z −Z〉 ≥ C1 ∥∥Z −Z∥∥2 F + ∥∥(Z −Z)>Z∥∥2 F .\nC2 Local Smoothness Condition There exist constants C2, C3 such that for any Z satisfying d(Z,Z?) ≤ √ 3 16 σr,\n‖∇f(Z)‖2F ≤ C2 ∥∥Z −Z∥∥2 F + C3 ∥∥(Z −Z)>Z∥∥2 F .\nD.1 Proof of the Local Curvature Condition\n〈∇f(Z), H〉 =\np2︷ ︸︸ ︷ 2\nm m∑ i=1 tr(H>AiZ)2 +\nq2︷ ︸︸ ︷ 1\nm m∑ i=1 tr(H>AiH)2 + 3 m m∑ i=1 tr(H>AiZ) tr(H>AiH)\n≥ p2 + q2 − 3 m √√√√ m∑ i=1 tr(H>AiZ)2 √√√√ m∑ i=1 tr(H>AiH)2\n= p2 + q2 − 3√ 2 p︷ ︸︸ ︷√√√√ 2 m m∑ i=1 tr(H>AiZ)2 q︷ ︸︸ ︷√√√√ 1 m m∑ i=1 tr(H>AiH)2\n= ( p− 3\n2 √ 2 q\n)2 − 1\n8 q2 ≥ ( p2\n2 − 9 8 q2 ) − 1 8 q2\n= p2 2 − 5 4 q2 = 1 m m∑ i=1 tr(H>AiZ)2 − 5 4 1 m ∑ i tr(H>AiH)2\n≥ ( σr − δ\n2\n) ‖H‖2F + ∥∥H>Z∥∥2 F − 5δ 4 ‖H‖2F − 5 2 ∥∥HH>∥∥2 F\n≥ ( σr − 5\n2 ‖H‖2F −\n7 4 δ\n) ‖H‖2F + ∥∥H>Z∥∥2 F .\nwhere we use Cauchy-Schwarz inequality in the 2nd line, the inequality (a− b)2 ≥ a2 2 − b2 in the 5th line, Lemma 5 and 6 in the 7th line, and the fact that ∥∥HH>∥∥\nF ≤ ‖H‖2F in the 8th line. Since ‖H‖F ≤ √ 3 16 σr and δ ≤ 116σr, we have\n〈∇f(Z), H〉 ≥ 27 64 σr ‖H‖2F + ∥∥H>Z∥∥2 F . (11)\nD.2 Proof of the Local Smoothness Condition We need to upper bound ‖∇f(Z)‖2F = max‖W‖F=1 |〈∇f(Z),W 〉| 2. It suffices to show that for\nany W ∈ Rn×R of unit Frobenius norm, |〈∇f(Z),W 〉|2 is upper bounded if Z ∈ E (√\n3 16 σr\n) .\nSince (a+ b+ c+ d)2 ≤ 4(a2 + b2 + c2 + d2), we have\n|〈∇f(Z),W 〉|2 =\n( 1\nm m∑ i=1 ( tr(H>AiH) + 2 tr(H>AiZ) ) ( tr(W>AiH) + tr(W>AiZ)\n))2\n=\n( 1\nm m∑ i=1 tr(H>AiH) tr(W>AiH) + 2 tr(H>AiZ) tr(W>AiH)\n+ tr(H>AiH) tr(W>AiZ) + 2 tr(H>AiZ) tr(W>AiZ) )2\n≤ 4\n( 1\nm m∑ i=1 tr(H>AiH) tr(W>AiH)\n)2 + 4 ( 2\nm m∑ i=1 tr(H>AiZ) tr(W>AiH)\n)2\n+ 4\n( 1\nm m∑ i=1 tr(H>AiH) tr(W>AiZ)\n)2 + 4 ( 2\nm m∑ i=1 tr(H>AiZ) tr(W>AiZ)\n)2 .\nThe first term in the righthand side can be upper bounded as\n4\n( 1\nm m∑ i=1 tr(H>AiH) tr(W>AiH)\n)2 ≤ 4 ( 1\nm m∑ i=1\ntr(H>AiH)2 )( 1\nm m∑ i=1\ntr(W>AiH)2 )\n≤ 4 ( 2 ‖H‖4F + δ ‖H‖ 2 F )( 1 m m∑ i=1 ‖W‖2F ‖AiH‖ 2 F )\n= 4 ( 2 ‖H‖4F + δ ‖H‖ 2 F )( 1 m m∑ i=1 ‖AiH‖2F )\n≤ 4 ( 2 ‖H‖4F + δ ‖H‖ 2 F )( 1 m m∑ i=1 ‖Ai‖2 ‖H‖2F ) ≤ 36n ‖H‖2F ( 2 ‖H‖4F + δ ‖H‖ 2 F ) ,\nwhere we use the Cauchy-Schwarz inequality in the first and second line, Lemma 5 and ∥∥HH>∥∥\nF ≤\n‖H‖2F in the third line and Corollary 1 in the last line. The other three terms are bounded similarly. For the second term, we have\n4\n( 2\nm m∑ i=1 tr(H>AiZ) tr(W>AiH)\n)2 ≤ 16 ( 1\nm m∑ i=1\ntr(H>AiZ)2 )( 1\nm m∑ i=1\ntr(W>AiH)2 )\n≤ 36n ‖H‖2F ( (4σ1 + 2δ) ‖H‖2F + 4 ∥∥H>Z∥∥2\nF\n) ,\nwhere we use Lemma 6 and 1. The third term is bounded as\n4\n( 1\nm m∑ i=1 tr(H>AiH) tr(W>AiZ)\n)2 ≤ 4 ( 1\nm m∑ i=1\ntr(H>AiH)2 )( 1\nm m∑ i=1\ntr(W>AiZ)2 )\n≤ 36n ∥∥Z∥∥2\nF\n( 2 ‖H‖4F + δ ‖H‖ 2 F ) ,\nand the fourth term is bounded as\n4\n( 2\nm m∑ i=1 tr(H>AiZ) tr(W>AiZ)\n)2 ≤ 16 ( 1\nm m∑ i=1\ntr(H>AiZ)2 )( 1\nm m∑ i=1 (W>AiZ) 2 ) ≤ 36n ∥∥Z∥∥2 F ( (4σ1 + 2δ) ‖H‖2F + 4 ∥∥H>Z∥∥2 F ) .\nPutting these inequalities together, we have ‖∇f(Z)‖2F ≤ 36n (∥∥Z∥∥2 F + ‖H‖2F )( 2 ‖H‖4F + (4σ1 + 3δ) ‖H‖ 2 F + 4 ∥∥H>Z∥∥2 F ) .\nHence, ‖∇f(Z)‖2F\n144n (∥∥Z∥∥2\nF + ‖H‖2F\n) ≤ (σ1 + 1 2 ‖H‖2F + 3 4 δ ) ‖H‖2F + ∥∥H>Z∥∥2 F .\nSince ‖H‖F ≤ √ 3 16 σr and δ ≤ 116σr, we have\n‖∇f(Z)‖2 144n (∥∥Z∥∥2\nF + (3/16)σr\n) ≤ (σ1 + 9 64 σr ) ‖H‖2F + ∥∥H>Z∥∥2 F .\nD.3 Proof of the Regularity Condition Now we combine the curvature and the smoothness conditions. For any γ ∈ (\n0, σ1 σr\n) , it holds that\nγ σr σ1 · ‖∇f(Z)‖ 2 F 144n (∥∥Z∥∥2\nF + (3/16)σr\n) ≤ γ σr σ1 · ( σ1 + 9 64 σr ) ‖H‖2F + ∥∥H>Z∥∥2 F . (12)\nCombining equation (11) and (12), we obtain\n〈∇f(Z), H〉 ≥ ( 27\n64 − γ − γ σr\nσ1\n9\n64\n) σr ‖H‖2F + γ\nσr σ1 · ‖∇f(Z)‖ 2 F 144n( ∥∥Z∥∥2\nF + (3/16)σr) ≥ ( 27\n64 − 73 64 γ\n) σr ‖H‖2F + γ\nσr σ1 · ‖∇f(Z)‖ 2 F 144n( ∥∥Z∥∥2\nF + (3/16)σr)\n.\nIf we take γ = 1 3 , then\n〈∇f(Z), H〉 ≥ 1 24 σr ‖H‖2F + σr σ1 · ‖∇f(Z)‖ 2 F 3 · 144n (∥∥Z∥∥2\nF + (3/16)σr ) ≥ 1\n24 σr ‖H‖2F +\nσr/σ1\n513n ‖Z?‖2F ‖∇f(Z)‖2F ,\nwhere we use ∥∥Z∥∥2\nF = ‖Z?‖2F = ‖X?‖∗ ≥ σr. Thus we have\n〈∇f(Z), H〉 ≥ 1 α σr ‖H‖2F +\n1\nβ ‖Z?‖2F ‖∇f(Z)‖2F\nfor α ≥ 24 and β ≥ σ1 σr · 513n.\nE Initialization Proof of Theorem 5\nBy assumption, we have∥∥∥∥∥ 1m m∑ i=1 (z?s >Aiz ? s)Ai − 2z?sz?s > ∥∥∥∥∥ ≤ δr , s ∈ [r]. Hence,\n‖M − 2X?‖ = ∥∥∥∥∥ 1m m∑ i=1 r∑ s=1 (z?s >Aiz ? s)Ai − 2 r∑ s=1 z?sz ? s T ∥∥∥∥∥ ≤ r∑ s=1 ∥∥∥∥∥ 1m m∑ i=1 (z?s >Aiz ? s)Ai − 2z?sz?s > ∥∥∥∥∥ ≤ δ. (13)\nLet λ′1 ≥ · · · ≥ λ′n be the eigenvalues of M . By Weyl’s theorem, we have\n|λ′s − 2σs| ≤ δ, s ∈ [n].\nSince δ < σr, it is easy to see λ′1 ≥ · · · ≥ λ′r > δ and |λ′s| ≤ δ, s = r + 1, . . . , n. Hence, λs = λ′s, s ∈ [r], and Z0Z0> is the best rank r approximation of 1\n2 M . Therefore,∥∥∥Z0Z0> − Z?Z?>∥∥∥\nF ≤ √\n2r ∥∥∥Z0Z0> − Z?Z?>∥∥∥\n= √ 2r ∥∥∥∥Z0Z0> − 12M + 12M − Z?Z?> ∥∥∥∥ ≤ √ 2r (∥∥∥∥Z0Z0> − 12M ∥∥∥∥+ ∥∥∥∥12M − Z?Z?>\n∥∥∥∥) ≤ √ 2rδ,\nwhere we used ‖A‖F ≤ √ rank(A) ‖A‖ in first line, the fact ∥∥∥Z0Z0> − 12M∥∥∥ = 12 |λr+1| ≤ 12δ and inequality (13) in the last line. Let H = Z0 − Z0. We want to bound d(Z0, Z?)2 = ‖H‖2F . According to the discussion in Lemma 7, H>Z0 is symmetric and Z0>Z0 is positive semidefinite.\nThe following step closely follows [21]. It holds that∥∥∥Z0Z0> − Z?Z?>∥∥∥2 F = ∥∥∥Z0Z0> −Z0Z0>∥∥∥2 F\n= ∥∥∥HZ0> +Z0H> +HH>∥∥∥2\nF = tr ( Z0H>HZ0 > +HZ0 > HZ0 > +HH>Z0 >\n+Z0H>Z0H> +HZ0 > Z0H +HH>Z0H>\n+Z0H>HH> +HZ0 > HH> +HH>HH> ) = tr ( (H>H)2 + 2(H>Z0)2 + 2(H>H)(Z0 > Z0) + 4(H>H)(H>Z0)\n) = tr (( H>H + √ 2H>Z0 )2 + (4− 2 √ 2)(H>H)(H>Z0) + 2(H>H)(Z0 > Z0)\n) ≥ tr ( (4− 2 √ 2)(H>H)(H>Z0) + 2(H>H)(Z>Z)\n) = tr ( (4− 2 √ 2)(H>H)(Z0 > Z0) ) + tr ( (2 √ 2− 2)(H>H)(Z>Z) ) ,\nwhere in the fourth line we used the property that the trace is invariant under cyclic permutations and H>Z0 = Z0 > H .\nSince Z0>Z0 is positive semidefinite, tr((H>H)(Z0>Z0)) is nonnegative. Hence,∥∥∥Z0Z0> − Z?Z?>∥∥∥2 F ≥ (2 √ 2− 2) tr ( (H>H)(Z>Z)\n) = (2 √ 2− 2) ∥∥HZ>∥∥2 F ≥ (2 √\n2− 2) ‖H‖2F σr = (2 √ 2− 2)σrd(Z0, Z?)2.\nIf δ ≤ σr 4 √ r , then\nd(Z0, Z?)2 ≤ ∥∥Z0Z0 − Z?Z?>∥∥2 F\n(2 √ 2− 2)σr ≤ 2rδ\n2\n(2 √ 2− 2)σr ≤ 3 16 σr."
    }, {
      "heading" : "F Sample Complexity",
      "text" : "In this section, we verify that our assumptions hold with high probability if m ≥ cn log n, where c is a constant that depends on δ, r, and κ. Our proof relies on the following concentration inequality.\nTheorem 8. (Matrix Bernstein Inequality [20]) Let S1, . . . , Sm be independent random matrices with dimension n × n. Assume that E(Si) = 0 and ‖Si‖ ≤ L, for all i ∈ [m]. Let ν2 =\nmax {∥∥∑m i=1 E(SiS>i ) ∥∥ ,∥∥∑mi=1 E(S>i Si)∥∥}. Then for all δ ≥ 0, P\n(∥∥∥∥∥ 1m m∑ i=1 Si ∥∥∥∥∥ ≥ δ ) ≤ 2n exp ( −m2δ2 ν2 + Lmδ/3 ) .\nWe first give a technical lemma that we will use later.\nLemma 8. Let A = (aij) be a random matrix drawn from GOE. Let S = a11A − 2e1e>1 . There exist absolute constants C, ρ such that with probability at least 1− Ce−ρn, we have\n‖S‖ ≤ 18n.\nProof. Let Ã = A − a11e1e>1 . S = a11Ã + (a211 − 2)e1e>1 . Note that a11 and Ã are independent, hence ‖S‖ ≤ |a11|‖Ã‖ + |a211 − 2|. Besides, since a11 ∼ N (0, 2), we can see that a211/2 is χ2 distributed.\nFirst we bound the operator norm of Ã. We rewrite ‖Ã‖ as\n‖Ã‖ = max ‖u‖=1 |u>Ãu| = max ‖u‖=1 |u>Du− du21| ≤ ‖D‖+ |d|,\nwhere D = Ã+ de1e>1 , d ∼ N (0, 2). As D is GOE distributed, by Lemma 4,\nP ( ‖D‖ > 3 √ n ) ≤ C ′e−ρ′n, (14)\nwhere C ′ and ρ′ are absolute constants. Using the Gaussian tail inequality, we have\nP ( |d| > 2 √ n ) ≤ 2e−n. (15)\nCombining inequalities (14) and (15), we have P ( ‖Ã‖ > 5 √ n ) ≤ P ( ‖D‖ > 3 √ n ∨ |d| > 2 √ n ) ≤ C ′e−ρ′n + 2e−n, (16)\nwhere the last inequality follows from the union bound. Next we bound the deviation of the χ2 term. By the corollary of Lemma 1 in Laurent and Massart [13], we have\nP(|a211 − 2| > 4( √ n+ n)) ≤ 2e−n. (17)\nSince a11 is identically distributed as d, inequality (15) holds for a11 as well. Namely, P (|a11| > 2 √ n) ≤ 2e−n. Combining this with inequalities (17), (16), we have\nP ( ‖S‖ ≤ 14n+ 4 √ n ) ≥ 1− 6e−n − C ′e−ρ′n.\nFinally, the statement is obtained by choosing proper C, ρ, and using √ n ≤ n.\nF.1 Proof of Theorem 6 Proof. It is equivalent to show that for any unit vector u, with high probability,∥∥∥∥∥ 1m m∑ i=1 (u>Aiu)Ai − 2uu> ∥∥∥∥∥ ≤ δrσ1 . If P is an orthonormal matrix, then∥∥∥∥∥ 1m m∑ i=1 ( (Pu)>Ai(Pu) ) Ai − 2(Pu)(Pu)> ∥∥∥∥∥ = ∥∥∥∥∥ 1m m∑ i=1 ( u>(P>AiP )uAi ) − 2Puu>P>\n∥∥∥∥∥ =\n∥∥∥∥∥ 1m m∑ i=1 u>(P>AiP )uP >AiP − 2uu> ∥∥∥∥∥ =\n∥∥∥∥∥ 1m m∑ i=1 u>ÃiuÃi − 2uu> ∥∥∥∥∥ ,\nwhere in the second line we use unitary invariance of the operator norm, and in the last line we denote P>AiP by Ãi. Since the GOE is invariant under orthogonal conjugation, Ãi and Ai are identically distributed. Hence, it suffices to prove the claim when u = e1, i.e.∥∥∥∥∥ 1m m∑ i=1 a (i) 11Ai − 2e1e>1\n∥∥∥∥∥ ≤ δ0, where a(i)11 is the (1, 1) entry of Ai and δ0 = δ rσ1 .\nTo show this, we apply Theorem 8, where Si = a (i) 11Ai − 2e1e>1 . This requires that the operator norm of Si is bounded, for each i. We address this by noticing that with high probability ‖Si‖ ≤ 18n, ∀i. To be precise, by Lemma 8 there exist constants C, ρ, such that\nP (‖Si‖ > 18n) ≤ Ce−ρn, i = 1, . . . ,m.\nTaking the union bound over all the Sis leads to P (\nmax i ‖Si‖ > 18n\n) ≤ mCe−ρn. (18)\nNext, we calculate ν2 = ‖ ∑m\ni=1 E(S2i )‖ = m ‖E(S21)‖. Let A = (aij) denote A1, S denote S1. We have E(S2) = E(a112A2)− 4e1e>1 , and(\na211A 2 ) 11 = a411 + n∑ k=2 a211a 2 1k,\n( a211A 2 ) ii = a211 ( a2ii + n∑ k 6=i a2ik ) , ∀i 6= 1,\n( a211A 2 ) ij = a211 n∑ k=1 aikajk, ∀i 6= j.\nIt is easy to see that E(a211A2) = diag(2n+10, 2n+2, . . . , 2n+2). Consequently, ν2 = (2n+6)m. By Theorem 8, if m ≥ 42\nmin(δ20 ,δ0) · n log n, then\nP (∥∥∥∥∥ 1m m∑ i=1 Si ∥∥∥∥∥ ≥ δ0 ) ≤ 2n exp ( −mδ20 2n(1 + 3δ0) + 6 ) ≤ 2n exp ( −mδ20\n2n(4 + 3δ0) ) ≤ 2n exp ( −mδ20\n14n ·max(1, δ0) ) ≤ 2 n2 .\n(19)\nCombining inequalities (18) and (19), we conclude that\nP (∥∥∥∥∥ 1m m∑ i=1 a (i) 11Ai − 2e1e>1 ∥∥∥∥∥ ≤ δ0 ) ≥ 1−mCe−ρn − 2 n2 .\nF.2 Proof of Theorem 7 The formulation of the second order partial derivatives and their expectations is given in Appendix B.\nIt is easy to see that for anyZ ∈ S, maxs∈[r] ‖z̄r‖ ≤ √ σ1. Thus it is sufficient to prove that for\nany two unitary vector u and y with high probability it holds that∥∥∥∥∥ 1m m∑ i=1 2Aiuy >Ai − 2u>yI − 2yu> ∥∥∥∥∥ ≤ δrσ1 . We can decompose y as y = βu + β⊥u⊥ for a certain unit vector u⊥ that is orthogonal to u, where β2 + β2⊥ = 1. Let δ0 = δ\n2rσ1 . It suffices to prove the following two claims.\n(i) For any unitary vector u, with high probability∥∥∥∥∥ 1m m∑ i=1 2Aiuu >Ai − 2I − 2uu> ∥∥∥∥∥ ≤ δ0. (ii) For any two orthogonal unit vectors u and u⊥, with high probability∥∥∥∥∥ 1m m∑ i=1 2Aiuu > ⊥Ai − 2u⊥u> ∥∥∥∥∥ ≤ δ0.\nProof of (i)\nIf P is an orthonormal matrix, then∥∥∥∥∥ 1m m∑ i=1 2AiPuu >PAi − 2I − 2Puu>P> ∥∥∥∥∥ = ∥∥∥∥∥ 1m m∑ i=1 2P>AiPuu >P>AiP − 2I − 2uu> ∥∥∥∥∥ =\n∥∥∥∥∥ 1m m∑ i=1 2Ãiuu >Ãi − 2I − 2uu> ∥∥∥∥∥ , where Ãi and Ai have the same distribution. Hence we only need to prove the case where u = e1:∥∥∥∥∥ 1m m∑ i=1 2v(i)v(i) > − 2I − 2e1e>1\n∥∥∥∥∥ ≤ δ0, where v(i) = Aie1 is the first column of Ai.\nLet Si = 2(v(i)v(i) > − I − e1e>1 ). To apply Theorem 8, we need to show that with high probability ‖Si‖ is bounded for each i and calculate ν2 = ‖ ∑n\ni=1 E(S2i )‖ = m ‖E(S21)‖. Let S, v, A denote S1, v(1), and A(1) respectively. It is easy to see that\n‖S‖ ≤ 2 ‖v‖2 + 4 = 2(w + a211) + 4, where w = ∑n k=2 a 2 1k. As a11 ∼ N (0, 2), a1k ∼ N (0, 1) for k 6= 1, we can see that a211/2 and w are χ2 distributed with degrees of freedom 1 and n − 1, respectively. Using the χ2 tail bound, we have\nP ( a211/2 > 2( √ n+ n) + 1 ) ≤ e−n,\nP (w > 5n− 1) ≤ e−n, k = 2, . . . , n. It follows from the union bound that\nP (‖S‖ > 26n+ 6) ≤ 2e−n, and consequently\nP (\nmax i ‖Si‖ > 26n+ 6\n) ≤ 2me−n. (20)\nTo calculate ν2, we expand E(S2) as E(S2) = 4E ( (vv>)2 ) − 4(I + e1e>1 )2\n= 4E ( ‖v‖2 vv> ) − 4(I + 3e1e>1 ).\nSome simple calculations show that( ‖v‖2 vv> ) 11 = v1 4 + n∑ k=2 vk 2v1\n2,( ‖v‖2 vv> ) jj = v1 2vj 2 + vj 4 + ∑ k 6=1,j vk 2vj 2, j = 2, . . . , n,\n( ‖v‖2 vv> ) jl = n∑ k=1 vk 2vjvl, j < l.\nAs v1 ∼ N (0, 2), vj ∼ N (0, 1) for j 6= 1,\nE ( ‖v‖2 vv> ) 11 = 2n+ 10,\nE ( ‖v‖2 vv> ) jj = n+ 3, j = 2, . . . , n,\nE ( ‖v‖2 vv> ) jl = 0, j < l.\nHence, E(S2) = diag(8n+ 24, 4n+ 8, . . . , 4n+ 8) and thus ν2 = m(8n+ 24). If m ≥ (128/min(δ20, δ0))n log n, then by applying Theorem 8 we can see\nP (∥∥∥∥∥ 1m m∑ i=1 2v(i)v(i) > − 2I − 2e1e>1 ∥∥∥∥∥ > δ0 ) ≤ 2n exp ( −mδ20 8n+ 24 + (26 3 n+ 2)δ0 ) ≤ 2n exp ( −mδ20\n(128/3)nmax(1, δ0) ) ≤ 2 n2 .\n(21)\nCombining inequalities (21) and (20) leads to\nP (∥∥∥∥∥ 1m m∑ i=1 2v(i)v(i) > − 2I − 2e1e>1 ∥∥∥∥∥ ≤ δ0 ) ≥ 1− 2me−n − 2 n2 .\nProof of (ii)\nWe only need to prove the case where u = e1 and u⊥ = e2 due to the same reason above. That is,∥∥∥∥∥ 1m m∑ i=1 2v(i)q(i) > − 2e2e>1 ∥∥∥∥∥ ≤ δ0, where v(i) and q(i) are the first and second columns of Ai.\nAs before, let Si = 2(v(i)q(i) > − e2e>1 ) and let S, v, q, A denote S1, v(1), q(1) and A(1) respectively. From the proof of (i), we can see that with probability at least 1 − 4e−n both ‖v‖ and ‖q‖ are no larger than √ 13n+ 1. Since ‖S‖ ≤ 2 ‖v‖ ‖q‖+ 2, we have\nP (\nmax i ‖Si‖ ≥ 26n+ 4\n) ≤ 4me−n.\nNext, we calculate ν2 = mmax {∥∥E(SS>)∥∥ ,∥∥E(S>S)∥∥}.\nE(SS>) = 4E(‖q‖2)E(vv>) + 4e2e>2 .\nE(S>S) = 4E(‖v‖2)E(qq>) + 4e1e>1 .\nSome simple calculation shows that E(‖v‖2) = E(‖q‖2) = n + 1, E(vv>) = I + e1e>1 and E(qq>) = I + e2e>2 . Hence,\nE(SS>) = 4(n+ 1)I + 4(n+ 1)e1e>1 + 4e2e>2 ,\nE(S>S) = 4(n+ 1)I + 4(n+ 1)e2e>2 + 4e1e>1 ,\nand ν2 = 8(n+ 1)m. If m ≥ 78 min(δ20 ,δ0) n log n, then by applying Theorem 8 we have\nP (∥∥∥∥∥ 1m m∑ i=1 2v(i)q(i) > − 2e1e>2 ∥∥∥∥∥ > δ0 ) ≤ 2n exp ( −mδ20 8n+ 8 + (26n+4 3 )δ0 ) ≤ 2n exp ( −mδ20\n26nmax(1, δ0) ) ≤ 2 n2 .\n(22)\nThis means,\nP (∥∥∥∥∥ 1m m∑ i=1 2v(i)q(i) > − 2e1e>2 ∥∥∥∥∥ ≤ δ0 ) ≥ 1− 4me−n − 2 n2 ."
    }, {
      "heading" : "G ADMM for Nuclear Norm Minimization",
      "text" : "We reformulate the nuclear norm minimizing problem as\nmin X∈Rn×n\n1\n2λ ‖A(X)− b‖2 + ‖X‖∗ , (23)\nwhere λ > 0 is the regularization parameter. λ→ 0 will enforce the minimizer X∗nuc satisfying the affine constraint A(X∗nuc) = b.\nWe apply ADMM to the dual problem of (23):\nmin α∈Rm,V ∈Rn×n\nλ 2 ‖α‖2 − α>b\nsubject to ‖V ‖ ≤ 1 A>(α) = V,\n(24)\nwhere we introduce an auxiliary variable V to make this problem equality constrained. The augmented Lagrangian of problem (24) can be written as\nLη(α,X) = λ\n2 ‖α‖2 − α>b+ 1‖·‖≤1(V ) + 〈X,A>(α)− V 〉+\nη\n2\n∥∥A>(α)− V ∥∥2 F ,\nwhere X is the multiplier, η is the penalty parameter, and 1‖·‖≤1 is the indicator function of the unit spectral norm ball i.e. 1‖·‖≤1(V ) equals 0 if ‖V ‖ ≤ 1 and +∞ otherwise.\nLet vec(·) denote the vectorization of a matrix, whose inverse mapping is denoted by mat(·). We can rewrite the transformations asA(X) = Avec(X) andA>(α) = mat(A>α) = ∑m i=1 αiAi, where A is a m× n2 matrix whose ith row is vec(Ai)>. The ADMM starts from initialization (α0, V 0, X0) and updates the three variables alternately. The updates can be computed in close forms:\nαk+1 = (λI + ηAA>)−1 ( b+ Avec ( ηV k −Xk )) ,\nV k+1 = proj ( m∑\ni=1\nαk+1i Ai +X k/η\n) ,\nXk+1 = Xk + η ( m∑ i=1 αk+1i Ai − V k+1 ) ,\nwhere proj(·) is the projection onto the unit spectral norm ball. Let X = UΣV > be the singular value decomposition of X ,\nproj(X) = U min(Σ, 1)V >.\nIn fact, the update of V can be combined with other steps without being computed explicitly. One only has to iterate the following two steps:\nαk+1 = (λI + ηAA>)−1 ( b+ Avec ( η ∑ i=1 αkiAi +X k−1 − 2Xk )) ,\nXk+1 = proxη\n( η m∑ i=1 αk+1i Ai +X k ) ,\nwhere proxη(·) is the singular value soft-thresholding operator defined as\nproxη(X) = U max(Σ− η, 0)V >.\nThe sequence of multipliers { Xk }\nconverges to the primal solution of (23). To speed up the update of α, the Cholesky decomposition of λI + ηAA> is precomputed in our implementation."
    } ],
    "references" : [ {
      "title" : "High-dimensional analysis of semidefinite relaxations for sparse principal components",
      "author" : [ "Arash A. Amini", "Martin J. Wainwright" ],
      "venue" : "The Annals of Statistics,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2009
    }, {
      "title" : "Adaptivity of averaged stochastic gradient descent to local strong convexity for logistic regression",
      "author" : [ "Francis Bach" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2014
    }, {
      "title" : "Non-asymptotic analysis of stochastic approximation algorithms for machine learning",
      "author" : [ "Francis Bach", "Eric Moulines" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2011
    }, {
      "title" : "A nonlinear programming algorithm for solving semidefinite programs via low-rank factorization",
      "author" : [ "Samuel Burer", "Renato DC Monteiro" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2003
    }, {
      "title" : "A singular value thresholding algorithm for matrix completion",
      "author" : [ "Jian-Feng Cai", "Emmanuel J Candès", "Zuowei Shen" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1956
    }, {
      "title" : "Phase retrieval via wirtinger flow: Theory and algorithms",
      "author" : [ "Emmanuel Candès", "Xiaodong Li", "Mahdi Soltanolkotabi" ],
      "venue" : "arXiv preprint arXiv:1407.1065,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2014
    }, {
      "title" : "A direct formulation for sparse PCA using semidefinite programming",
      "author" : [ "A. d’Aspremont", "L. El Ghaoui", "M.I. Jordan", "G. Lanckriet" ],
      "venue" : "Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2004
    }, {
      "title" : "Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming",
      "author" : [ "Michel X. Goemans", "David P. Williamson" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1995
    }, {
      "title" : "Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions",
      "author" : [ "Nathan Halko", "Per-Gunnar Martinsson", "Joel A Tropp" ],
      "venue" : "SIAM review,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2011
    }, {
      "title" : "Stochastic variational inference",
      "author" : [ "Matt Hoffman", "David M. Blei", "Chong Wang", "John Paisley" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2013
    }, {
      "title" : "Guaranteed rank minimization via singular value projection",
      "author" : [ "Prateek Jain", "Raghu Meka", "Inderjit S Dhillon" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2010
    }, {
      "title" : "Low-rank matrix completion using alternating minimization",
      "author" : [ "Prateek Jain", "Praneeth Netrapalli", "Sujay Sanghavi" ],
      "venue" : "In Proceedings of the forty-fifth annual ACM symposium on Theory of computing,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2013
    }, {
      "title" : "Adaptive estimation of a quadratic functional by model selection",
      "author" : [ "Beatrice Laurent", "Pascal Massart" ],
      "venue" : "Annals of Statistics,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2000
    }, {
      "title" : "Small deviations for beta ensembles",
      "author" : [ "Michel Ledoux", "Brian Rider" ],
      "venue" : "Electron. J. Probab.,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2010
    }, {
      "title" : "Rank minimization via online learning",
      "author" : [ "Raghu Meka", "Prateek Jain", "Constantine Caramanis", "Inderjit S Dhillon" ],
      "venue" : "In Proceedings of the 25th International Conference on Machine learning,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2008
    }, {
      "title" : "Introductory lectures on convex optimization, volume 87",
      "author" : [ "Yurii Nesterov" ],
      "venue" : "Springer Science & Business Media,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2004
    }, {
      "title" : "Phase retrieval using alternating minimization",
      "author" : [ "Praneeth Netrapalli", "Prateek Jain", "Sujay Sanghavi" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2013
    }, {
      "title" : "Guaranteed minimum-rank solutions of linear matrix equations via nuclear norm minimization",
      "author" : [ "Benjamin Recht", "Maryam Fazel", "Pablo A Parrilo" ],
      "venue" : "SIAM review,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2010
    }, {
      "title" : "Estimation of low-rank tensors via convex optimization",
      "author" : [ "Ryota Tomioka", "Kohei Hayashi", "Hisashi Kashima" ],
      "venue" : "arXiv preprint arXiv:1010.0789,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2010
    }, {
      "title" : "An introduction to matrix concentration inequalities",
      "author" : [ "Joel A Tropp" ],
      "venue" : "arXiv preprint arXiv:1501.01571,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "SDPs often arise naturally from the problem structure, or are derived as surrogate optimizations that are relaxations of difficult combinatorial problems [7, 1, 8].",
      "startOffset" : 154,
      "endOffset" : 163
    }, {
      "referenceID" : 0,
      "context" : "SDPs often arise naturally from the problem structure, or are derived as surrogate optimizations that are relaxations of difficult combinatorial problems [7, 1, 8].",
      "startOffset" : 154,
      "endOffset" : 163
    }, {
      "referenceID" : 7,
      "context" : "SDPs often arise naturally from the problem structure, or are derived as surrogate optimizations that are relaxations of difficult combinatorial problems [7, 1, 8].",
      "startOffset" : 154,
      "endOffset" : 163
    }, {
      "referenceID" : 2,
      "context" : "In many areas of machine learning and signal processing such as classification, deep learning, and phase retrieval, gradient descent methods, in particular first order stochastic optimization, have led to remarkably efficient algorithms that can attack very large scale problems [3, 2, 10, 6].",
      "startOffset" : 279,
      "endOffset" : 292
    }, {
      "referenceID" : 1,
      "context" : "In many areas of machine learning and signal processing such as classification, deep learning, and phase retrieval, gradient descent methods, in particular first order stochastic optimization, have led to remarkably efficient algorithms that can attack very large scale problems [3, 2, 10, 6].",
      "startOffset" : 279,
      "endOffset" : 292
    }, {
      "referenceID" : 9,
      "context" : "In many areas of machine learning and signal processing such as classification, deep learning, and phase retrieval, gradient descent methods, in particular first order stochastic optimization, have led to remarkably efficient algorithms that can attack very large scale problems [3, 2, 10, 6].",
      "startOffset" : 279,
      "endOffset" : 292
    }, {
      "referenceID" : 5,
      "context" : "In many areas of machine learning and signal processing such as classification, deep learning, and phase retrieval, gradient descent methods, in particular first order stochastic optimization, have led to remarkably efficient algorithms that can attack very large scale problems [3, 2, 10, 6].",
      "startOffset" : 279,
      "endOffset" : 292
    }, {
      "referenceID" : 17,
      "context" : "This problem is a direct generalization of compressed sensing, and subsumes many machine learning problems such as image compression, low rank matrix completion and low-dimensional metric embedding [18, 12].",
      "startOffset" : 198,
      "endOffset" : 206
    }, {
      "referenceID" : 11,
      "context" : "This problem is a direct generalization of compressed sensing, and subsumes many machine learning problems such as image compression, low rank matrix completion and low-dimensional metric embedding [18, 12].",
      "startOffset" : 198,
      "endOffset" : 206
    }, {
      "referenceID" : 14,
      "context" : "Without conditions on the transformation A or the minimum rank solution X, it is generally NP hard [15].",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 17,
      "context" : "Existing methods, such as nuclear norm relaxation [18], singular value projection (SVP) [11], and alternating least squares (AltMinSense) [12], assume that a certain restricted isometry property (RIP) holds for A.",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 10,
      "context" : "Existing methods, such as nuclear norm relaxation [18], singular value projection (SVP) [11], and alternating least squares (AltMinSense) [12], assume that a certain restricted isometry property (RIP) holds for A.",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 11,
      "context" : "Existing methods, such as nuclear norm relaxation [18], singular value projection (SVP) [11], and alternating least squares (AltMinSense) [12], assume that a certain restricted isometry property (RIP) holds for A.",
      "startOffset" : 138,
      "endOffset" : 142
    }, {
      "referenceID" : 17,
      "context" : "In the random measurement setting, this essentially means that at least O(r(n + p) log(n + p)) measurements are available, where r = rank(X) [18].",
      "startOffset" : 141,
      "endOffset" : 145
    }, {
      "referenceID" : 5,
      "context" : "[6], and develop a gradient descent algorithm for optimizing f(Z), using a carefully constructed initialization and step size.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 17,
      "context" : "[18].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 3,
      "context" : "3 Related Work Burer and Monteiro [4] proposed a general approach for solving semidefinite programs using factored, nonconvex optimization, giving mostly experimental support for the convergence of the algorithms.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 17,
      "context" : "[18], based on replacing the rank function by the convex surrogate nuclear norm, as already mentioned in the previous section.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 4,
      "context" : "The most popular algorithms are proximal methods that perform singular value thresholding [5] at every iteration.",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 10,
      "context" : "[11] proposed a projected gradient descent algorithm SVP (Singular Value Projection) that solves min X∈Rn×p ‖A(X)− b‖ subject to rank(X) ≤ r, where ‖·‖ is the `2 vector norm and r is the input rank.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "[12] proposes an alternating least squares algorithm AltMinSense that avoids the per-iteration SVD.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 5,
      "context" : "It is parallel to the Wirtinger Flow (WF) algorithm for phase retrieval [6], to recover a complex vector x ∈ C given the squared magnitudes of its linear measurements bi = |〈ai, x〉|, i ∈ [m], where a1, .",
      "startOffset" : 72,
      "endOffset" : 75
    }, {
      "referenceID" : 5,
      "context" : "[6] propose a first-order method to minimize the sum of squared residuals",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 16,
      "context" : "To obtain a sufficiently accurate initialization, we use a spectral method, similar to those used in [17, 6].",
      "startOffset" : 101,
      "endOffset" : 108
    }, {
      "referenceID" : 5,
      "context" : "To obtain a sufficiently accurate initialization, we use a spectral method, similar to those used in [17, 6].",
      "startOffset" : 101,
      "endOffset" : 108
    }, {
      "referenceID" : 15,
      "context" : "In the analysis of convex functions, Nesterov [16] shows that for unconstrained optimization, the gradient descent",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 0,
      "context" : "The underlying truth is Z = [1, 1]>.",
      "startOffset" : 28,
      "endOffset" : 34
    }, {
      "referenceID" : 0,
      "context" : "The underlying truth is Z = [1, 1]>.",
      "startOffset" : 28,
      "endOffset" : 34
    }, {
      "referenceID" : 15,
      "context" : "This provides a local regularity property that is similar to the Nesterov [16] criteria that the objective function is strongly convex and has a Lipschitz continuous gradient.",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 18,
      "context" : "[19]; see Appendix G.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 8,
      "context" : "[9] to compute the low rank SVD.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 10,
      "context" : "The results suggest that the sample complexity of our method should also scale as O(rn log n) as for SVP and the nuclear norm approach [11, 18].",
      "startOffset" : 135,
      "endOffset" : 143
    }, {
      "referenceID" : 17,
      "context" : "The results suggest that the sample complexity of our method should also scale as O(rn log n) as for SVP and the nuclear norm approach [11, 18].",
      "startOffset" : 135,
      "endOffset" : 143
    }, {
      "referenceID" : 5,
      "context" : "Building on a recently proposed first-order algorithm for phase retrieval [6], we develop a gradient descent procedure for rank minimization and establish convergence to the optimal solution with O(rn log n) measurements.",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 3,
      "context" : "More broadly, the technique used in this paper—factoring the semidefinite matrix variable, recasting the convex optimization as a nonconvex optimization, and applying first-order algorithms—first proposed by Burer and Monteiro [4], may be effective for a much wider class of SDPs, and deserves further study.",
      "startOffset" : 227,
      "endOffset" : 230
    }, {
      "referenceID" : 0,
      "context" : "References [1] Arash A.",
      "startOffset" : 11,
      "endOffset" : 14
    }, {
      "referenceID" : 1,
      "context" : "[2] Francis Bach.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "[3] Francis Bach and Eric Moulines.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 3,
      "context" : "[4] Samuel Burer and Renato DC Monteiro.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5] Jian-Feng Cai, Emmanuel J Candès, and Zuowei Shen.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "[6] Emmanuel Candès, Xiaodong Li, and Mahdi Soltanolkotabi.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "[7] A.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "[8] Michel X.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "[9] Nathan Halko, Per-Gunnar Martinsson, and Joel A Tropp.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 9,
      "context" : "[10] Matt Hoffman, David M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[11] Prateek Jain, Raghu Meka, and Inderjit S Dhillon.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "[12] Prateek Jain, Praneeth Netrapalli, and Sujay Sanghavi.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "[13] Beatrice Laurent and Pascal Massart.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 13,
      "context" : "[14] Michel Ledoux and Brian Rider.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 14,
      "context" : "[15] Raghu Meka, Prateek Jain, Constantine Caramanis, and Inderjit S Dhillon.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 15,
      "context" : "[16] Yurii Nesterov.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "[17] Praneeth Netrapalli, Prateek Jain, and Sujay Sanghavi.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 17,
      "context" : "[18] Benjamin Recht, Maryam Fazel, and Pablo A Parrilo.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "[19] Ryota Tomioka, Kohei Hayashi, and Hisashi Kashima.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "[20] Joel A Tropp.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "(Matrix Bernstein Inequality [20]) Let S1, .",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 12,
      "context" : "By the corollary of Lemma 1 in Laurent and Massart [13], we have P(|a11 − 2| > 4( √ n+ n)) ≤ 2e−n.",
      "startOffset" : 51,
      "endOffset" : 55
    } ],
    "year" : 2016,
    "abstractText" : "We propose a simple, scalable, and fast gradient descent algorithm to optimize a nonconvex objective for the rank minimization problem and a closely related family of semidefinite programs. WithO(r3κ2n log n) random measurements of a positive semidefinite n×nmatrix of rank r and condition number κ, our method is guaranteed to converge linearly to the global optimum.",
    "creator" : "LaTeX with hyperref package"
  }
}