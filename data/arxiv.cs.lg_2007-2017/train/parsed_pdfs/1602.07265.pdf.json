{
  "name" : "1602.07265.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Search Improves Label for Active Learning",
    "authors" : [ "Alina Beygelzimer", "Daniel Hsu", "John Langford", "Chicheng Zhang" ],
    "emails" : [ "beygel@yahoo-inc.com", "djhsu@cs.columbia.edu", "jcl@microsoft.com", "chichengzhang@ucsd.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 2.\n07 26\n5v 2\n[ cs\n.L G\n] 2"
    }, {
      "heading" : "1 Introduction",
      "text" : "Most active learning theory is based on interacting with a Label oracle: An active learner observes unlabeled examples, each with a label that is initially hidden. The learner provides an unlabeled example to the oracle, and the oracle responds with the label. Using Label in an active learning algorithm is known to give (sometimes exponentially large) problem-dependent improvements in label complexity, even in the agnostic setting where no assumption is made about the underlying distribution [e.g., Balcan et al., 2006, Hanneke, 2007, Dasgupta et al., 2007, Hanneke, 2014].\nA well-known deficiency of Label arises in the presence of rare classes in classification problems, frequently the case in practice [Attenberg and Provost, 2010, Simard et al., 2014]. Class imbalance may be so extreme that simply finding an example from the rare class can exhaust the labeling budget. Consider the problem of learning interval functions in [0, 1]. Any Label-only active learner needs at least Ω(1/ǫ) Label queries to learn an arbitrary target interval with error at most ǫ [Dasgupta, 2005]. Given any positive example from the interval, however, the query complexity of learning intervals collapses to O(log(1/ǫ)), as we can just do a binary search for each of the end points.\nA natural approach used to overcome this hurdle in practice is to search for known examples of the rare class [Attenberg and Provost, 2010, Simard et al., 2014]. Domain experts are often adept at finding examples of a class by various, often clever means. For instance, when building a hate speech filter, a simple web search can readily produce a set of positive examples. Sending a random batch of unlabeled text to Label is unlikely to produce any positive examples at all.\nAnother form of interaction common in practice is providing counterexamples to a learned predictor. When monitoring the stream filtered by the current hate speech filter, a human editor may spot a clear-cut\n∗beygel@yahoo-inc.com †djhsu@cs.columbia.edu ‡jcl@microsoft.com §chichengzhang@ucsd.edu\nexample of hate speech that seeped through the filter. The editor, using all the search tools available to her, may even be tasked with searching for such counterexamples. The goal of the learning system is then to interactively restrict the searchable space, guiding the search process to where it is most effective.\nCounterexamples can be ineffective or misleading in practice as well. Reconsidering the intervals example above, a counterexample on the boundary of an incorrect interval provides no useful information about any other examples. What is a good counterexample? What is a natural way to restrict the searchable space? How can the intervals problem be generalized?\nWe define a new oracle, Search, that provides counterexamples to version spaces. Given a set of possible classifiers H mapping unlabeled examples to labels, a version space V ⊆ H is the subset of classifiers still under consideration by the algorithm. A counterexample to a version space is a labeled example which every classifier in the version space classifies incorrectly. When there is no counterexample to the version space, Search returns nothing.\nHow can a counterexample to the version space be used? We consider a nested sequence of hypothesis classes of increasing complexity, akin to Structural Risk Minimization (SRM) in passive learning [see, e.g., Vapnik, 1982, Devroye et al., 1996]. When Search produces a counterexample to the version space, it gives a proof that the current hypothesis class is too simplistic to solve the problem effectively. We show that this guided increase in hypothesis complexity results in a radically lower Label complexity than directly learning on the complex space. Sample complexity bounds for model selection in Label-only active learning were studied by Balcan et al. [2010], Hanneke [2011].\nSearch can easily model the practice of seeding discussed earlier. If the first hypothesis class has just the constant always-negative classifier h(x) = −1, a seed example with label +1 is a counterexample to the version space. Our most basic algorithm uses Search just once before using Label, but it is clear from inspection that multiple seeds are not harmful, and they may be helpful if they provide the proof required to operate with an appropriately complex hypothesis class.\nDefining Search with respect to a version space rather than a single classifier allows us to formalize “counterexample far from the boundary” in a general fashion which is compatible with the way Label-based active learning algorithms work.\nRelated work. The closest oracle considered in the literature is the Class Conditional Query (CCQ) [Balcan and Hanneke, 2012] oracle. A query to CCQ specifies a finite set of unlabeled examples and a label while returning an example in the subset with the specified label, if one exists.\nIn contrast, Search has an implicit query set that is an entire region of the input space rather than a finite set. Simple searches over this large implicit domain can more plausibly discover relevant counterexamples: When building a detector for penguins in images, the input to CCQ might be a set of images and the label “penguin”. Even if we are very lucky and the set happens to contain a penguin image, a search amongst image tags may fail to find it in the subset because it is not tagged appropriately. Search is more likely to discover counterexamples—surely there are many images correctly tagged as having penguins.\nWhy is it natural to define a query region implicitly via a version space? There is a practical reason—it is a concise description of a natural region with an efficiently implementable membership filter [Beygelzimer et al., 2010, 2011, Huang et al., 2015]. (Compare this to an oracle call that has to explicitly enumerate a large set of examples. The algorithm of Balcan and Hanneke [2012] uses samples of size roughly dν/ǫ2.)\nThe use of Search in this paper is also substantially different from the use ofCCQ by Balcan and Hanneke [2012]. Our motivation is to use Search to assist Label, as opposed to using Search alone. This is especially useful in any setting where the cost of Search is significantly higher than the cost of Label—we hope to avoid using Search queries whenever it is possible to make progress using Label queries. This is consistent with how interactive learning systems are used in practice. For example, the Interactive Classification and Extraction system of Simard et al. [2014] combines Label with search in a production environment.\nThe final important distinction is that we require Search to return the label of the optimal predictor in the nested sequence. For many natural sequences of hypothesis classes, the Bayes optimal classifier is eventually in the sequence, in which case it is equivalent to assuming that the label in a counterexample is the most probable one, as opposed to a randomly-drawn label from the conditional distribution (as in CCQ\nand Label). Is this a reasonable assumption? Unlike with Label queries, where the labeler has no choice of what to label, here the labeler chooses a counterexample. If a human editor finds an unquestionable example of hate speech that seeped through the filter, it is quite reasonable to assume that this counterexample is consistent with the Bayes optimal predictor for any sensible feature representation.\nOrganization. Section 2 formally introduces the setting. Section 3 shows that Search is at least as powerful as Label. Section 4 shows how to use Search and Label jointly in the realizable setting where a zero-error classifier exists in the nested sequence of hypothesis classes. Section 5 handles the agnostic setting where Label is subject to label noise, and shows an amortized approach to combining the two oracles with a good guarantee on the total cost."
    }, {
      "heading" : "2 Definitions and Setting",
      "text" : "In active learning, there is an underlying distribution D over X × Y, where X is the instance space and Y := {−1,+1} is the label space. The learner can obtain independent draws from D, but the label is hidden unless explicitly requested through a query to the Label oracle. Let DX denote the marginal of D over X .\nWe consider learning with a nested sequence of hypotheses classes H0 ⊂ H1 ⊂ · · · ⊂ Hk · · · , where Hk ⊆ YX has VC dimension dk. For a set of labeled examples S ⊆ X ×Y, let Hk(S) := {h ∈ Hk : ∀(x, y) ∈ S h(x) = y} be the set of hypotheses in Hk consistent with S. Let err(h) := Pr(x,y)∼D[h(x) 6= y] denote the error rate of a hypothesis h with respect to distribution D, and err(h, S) be the error rate of h on the labeled examples in S. Let h∗k = argminh∈Hk err(h) breaking ties arbitrarily and let k ∗ := argmink≥0 err(h ∗ k) breaking ties in favor of the smallest such k. For simplicity, we assume the minimum is attained at some finite k∗. Finally, define h∗ := h∗k∗ , the optimal hypothesis in the sequence of classes. The goal of the learner is to learn a hypothesis with error rate not much more than that of h∗.\nIn addition to Label, the learner can also query Search with a version space.\nOracle SearchH(V ) (where H ∈ {Hk}∞k=0) input: Set of hypotheses V ⊂ H output: Labeled example (x, h∗(x)) s.t. h(x) 6= h∗(x) for all h ∈ V , or ⊥ if there is no such example.\nThus if SearchH(V ) returns an example, this example is a systematic mistake made by all hypotheses in V . (If V = ∅, we expect Search to return some example, i.e., not ⊥.)\nOur analysis is given in terms of the disagreement coefficient of Hanneke [2007], which has been a central parameter for analyzing active learning algorithms. Define the region of disagreement of a set of hypotheses V as Dis(V ) := {x ∈ X : ∃h, h′ ∈ V s.t. h(x) 6= h′(x)}. The disagreement coefficient of V at scale r is θV (r) := suph∈V,r′≥r PrDX [Dis(BV (h, r ′))]/r′, where BV (h, r ′) = {h′ ∈ V : Prx∼DX [h′(x) 6= h(x)] ≤ r′} is the ball of radius r′ around h. The Õ(·) notation hides factors that are polylogarithmic in 1/δ and quantities that do appear, where δ is the usual confidence parameter."
    }, {
      "heading" : "3 The Relative Power of the Two Oracles",
      "text" : "Although Search cannot always implement Label efficiently, it is as effective at reducing the region of disagreement. The clearest example is learning threshold classifiers H := {hw : w ∈ [0, 1]} in the realizable case, where hw(x) = +1 if w ≤ x ≤ 1, and −1 if 0 ≤ x < w. A simple binary search with Label achieves an exponential improvement in query complexity over passive learning. The agreement region of any set of threshold classifiers with thresholds in [wmin, wmax] is [0, wmin)∪ [wmax, 1]. Since Search is allowed to return any counterexample in the agreement region, there is no mechanism for forcing Search to return the label of a particular point we want. However, this is not needed to achieve logarithmic query complexity with\nSearch: If binary search starts with querying the label of x ∈ [0, 1], we can query SearchH(Vx), where Vx := {hw ∈ H : w < x} instead. If Search returns ⊥, we know that the target w∗ ≤ x and can safely reduce the region of disagreement to [0, x). If Search returns a counterexample (x0,−1) with x0 ≥ x, we know that w∗ > x0 and can reduce the region of disagreement to (x0, 1].\nThis observation holds more generally. In the proposition below, we assume that Label(x) = h∗(x) for simplicity. If Label(x) is noisy, the proposition holds for any active learning algorithm that doesn’t eliminate any h ∈ H : h(x) = Label(x) from the version space.\nProposition 1. For any call x ∈ X to Label such that Label(x) = h∗(x), we can construct a call to Search that achieves a no lesser reduction in the region of disagreement.\nProof. For any V ⊆ H , let HSearch(V ) be the hypotheses in H consistent with the output of SearchH(V ): if SearchH(V ) returns a counterexample (x, y) to V , then HSearch(V ) := {h ∈ H : h(x) = y}; otherwise, HSearch(V ) := V . Let HLabel(x) := {h ∈ H : h(x) = Label(x)}. Also, let Vx := H+1(x) := {h ∈ H : h(x) = +1}. We will show that Vx is such that HSearch(Vx) ⊆ HLabel(x), and hence Dis(HSearch(Vx)) ⊆ Dis(HLabel(x)).\nThere are two cases to consider: If h∗(x) = +1, then SearchH(Vx) returns ⊥. In this case, HLabel(x) = HSearch(Vx) = H+1(x), and we are done. If h\n∗(x) = −1, Search(Vx) returns a valid counterexample (possibly (x,−1)) in the region of agreement of H+1(x), eliminating all of H+1(x). Thus HSearch(Vx) ⊂ H \\H+1(x) = HLabel(x), and the claim holds also.\nAs shown by the problem of learning intervals on the line, SEARCH can be exponentially more powerful than LABEL."
    }, {
      "heading" : "4 Realizable Case",
      "text" : "We now turn to general active learning algorithms that combine Search and Label. We focus on algorithms using both Search and Label since Label is typically easier to implement than Search and hence should be used where Search has no significant advantage. (Whenever Search is less expensive than Label, Section 3 suggests a transformation to a Search-only algorithm.)\nThis section considers the realizable case, in which we assume that the hypothesis h∗ = h∗k∗ ∈ Hk∗ has err(h∗) = 0. This means that Label(x) returns h∗(x) for any x in the support of DX ."
    }, {
      "heading" : "4.1 Combining LABEL and SEARCH",
      "text" : "Our algorithm (shown as Algorithm 1) is called Larch, because it combines Label and Search. Like many selective sampling methods, Larch uses a version space to determine its Label queries.\nFor concreteness, we use (a variant of) the algorithm of Cohn et al. [1994], denoted by CAL, as a subroutine in Larch. The inputs to CAL are: a version space V , the Label oracle, a target error rate, and a confidence parameter; and its output is a set of labeled examples (implicitly defining a new version space). CAL is described in Appendix B; its essential properties are specified in Lemma 1.\nLarch differs from Label-only active learners (like CAL) by first calling Search in Step 3. If Search returns ⊥, Larch checks to see if the last call to CAL resulted in a small-enough error, halting if so in Step 6, and decreasing the allowed error rate if not in Step 8. If Search instead returns a counterexample, the hypothesis class Hk must be impoverished, so in Step 12, Larch increases the complexity of the hypothesis class to the minimum complexity sufficient to correctly classify all known labeled examples in S. After the Search, CAL is called in Step 14 to discover a sufficiently low-error (or at least low-disagreement) version space with high probability.\nWhen Larch advances to index k (for any k ≤ k∗), its set of labeled examples S may imply a version space Hk(S) ⊆ Hk that can be actively-learned more efficiently than the whole of Hk. In our analysis, we quantify this through the disagreement coefficient of Hk(S), which may be markedly smaller than that of the full Hk.\nAlgorithm 1 Larch\ninput: Nested hypothesis classes H0 ⊂ H1 ⊂ · · · ; oracles Label and Search; learning parameters ǫ, δ ∈ (0, 1)\n1: initialize S ← ∅, (index) k ← 0, ℓ ← 0 2: for i = 1, 2, . . . do 3: e ← SearchHk(Hk(S)) 4: if e = ⊥ then # no counterexample found 5: if 2−ℓ ≤ ǫ then 6: return any h ∈ Hk(S) 7: else 8: ℓ ← ℓ+ 1 9: end if 10: else # counterexample found 11: S ← S ∪ {e} 12: k ← min{k′ : Hk′ (S) 6= ∅} 13: end if 14: S ← S ∪ CAL(Hk(S),Label, 2−ℓ, δ/(i2 + i)) 15: end for\nThe following theorem bounds the oracle query complexity of Algorithm 1 for learning with both Search and Label in the realizable setting. The proof is in section 4.2.\nTheorem 1. Assume that err(h∗) = 0. For each k′ ≥ 0, let θk′ (·) be the disagreement coefficient of Hk′(S[k′]), where S[k′] is the set of labeled examples S in Larch at the first time that k ≥ k′. Fix any ǫ, δ ∈ (0, 1). If Larch is run with inputs hypothesis classes {Hk}∞k=0, oracles Label and Search, and learning parameters ǫ, δ, then with probability at least 1−δ: Larch halts after at most k∗+log2(1/ǫ) for-loop iterations and returns a classifier with error rate at most ǫ; furthermore, it draws at most Õ(k∗dk∗/ǫ) unlabeled examples from DX , makes at most k∗+log2(1/ǫ) queries to Search, and at most Õ ( ( k∗ + log(1/ǫ) )\n· (maxk′≤k∗ θk′ (ǫ)) · dk∗ · log2(1/ǫ)) queries to Label.\nUnion-of-intervals example. We now show an implication of Theorem 1 in the case where the target hypothesis h∗ is the union of non-trivial intervals in X := [0, 1], assuming that DX is uniform. For k ≥ 0, let Hk be the hypothesis class of the union of up to k intervals in [0, 1] with H0 containing only the alwaysnegative hypothesis. (Thus, h∗ is the union of k∗ non-empty intervals.) The disagreement coefficient of H1 is Ω(1/ǫ), and hence Label-only active learners like CAL are not very effective at learning with such classes. However, the first Search query by Larch provides a counterexample to H0, which must be a positive example (x1,+1). Hence, H1(S[1]) (where S[1] is defined in Theorem 1) is the class of intervals that contain x1 with disagreement coefficient θ1 ≤ 4.\nNow consider the inductive case. Just before Larch advances its index to a value k (for any k ≤ k∗), Search returns a counterexample (x, h∗(x)) to the version space; every hypothesis in this version space (which could be empty) is a union of fewer than k intervals. If the version space is empty, then S must already contain positive examples from at least k different intervals in h∗ and at least k−1 negative examples separating them. If the version space is not empty, then the point x is either a positive example belonging to a previously uncovered interval in h∗ or a negative example splitting an existing interval. In either case, S[k] contains positive examples from at least k distinct intervals separated by at least k − 1 negative examples. The disagreement coefficient of the set of unions of k intervals consistent with S[k] is at most 4k, independent of ǫ.\nThe VC dimension of Hk is O(k), so Theorem 1 implies that with high probability, Larch makes at most k∗ + log(1/ǫ) queries to Search and Õ((k∗)3 log(1/ǫ) + (k∗)2 log3(1/ǫ)) queries to Label."
    }, {
      "heading" : "4.2 Proof of Theorem 1",
      "text" : "The proof of Theorem 1 uses the following lemma regarding the CAL subroutine, proved in Appendix B. It is similar to a result of Hanneke [2011], but an important difference here is that the input version space V is not assumed to contain h∗.\nLemma 1. Assume Label(x) = h∗(x) for every x in the support of DX . For any hypothesis set V ⊆ YX with VC dimension d < ∞, and any ǫ, δ ∈ (0, 1), the following holds with probability at least 1 − δ. CAL(V,Label, ǫ, δ) returns labeled examples T ⊆ {(x, h∗(x)) : x ∈ X} such that for any h in V (T ), Pr(x,y)∼D[h(x) 6= y ∧ x ∈ Dis(V (T ))] ≤ ǫ; furthermore, it draws at most Õ(d/ǫ) unlabeled examples from DX , and makes at most Õ (θV (ǫ) · d · log2(1/ǫ)) queries to Label.\nWe now prove Theorem 1. By Lemma 1 and a union bound, there is an event with probability at least 1−∑i≥1 δ/(i2+i) ≥ 1−δ such that each call to CAL made by Larch satisfies the high-probability guarantee from Lemma 1. We henceforth condition on this event.\nWe first establish the guarantee on the error rate of a hypothesis returned by Larch. By the assumed properties of Label and Search, and the properties of CAL from Lemma 1, the labeled examples S in Larch are always consistent with h∗. Moreover, the return property of CAL implies that at the end of any loop iteration, with the present values of S, k, and ℓ, we have Pr(x,y)∼D[h(x) 6= y ∧ x ∈ Dis(Hk(S))] ≤ 2−ℓ for all h ∈ Hk(S). (The same holds trivially before the first loop iteration.) Therefore, if Larch halts and returns a hypothesis h ∈ Hk(S), then there is no counterexample to Hk(S), and Pr(x,y)∼D[h(x) 6= y ∧ x ∈ Dis(Hk(S))] ≤ ǫ. These consequences and the law of total probability imply err(h) = Pr(x,y)∼D[h(x) 6= y ∧ x ∈ Dis(Hk(S))] ≤ ǫ.\nWe next consider the number of for-loop iterations executed by Larch. Let Si, ki, and ℓi be, respectively, the values of S, k, and ℓ at the start of the i-th for-loop iteration in Larch. We claim that if Larch does not halt in the i-th iteration, then one of k and ℓ is incremented by at least one. Clearly, if there is no counterexample to Hki(Si) and 2\n−ℓi > ǫ, then ℓ is incremented by one (Step 8). If, instead, there is a counterexample (x, y), then Hki(Si ∪ {(x, y)}) = ∅, and hence k is incremented to some index larger than ki (Step 12). This proves that ki+1 + ℓi+1 ≥ ki + ℓi + 1. We also have ki ≤ k∗, since h∗ ∈ Hk∗ is consistent with S, and ℓi ≤ log2(1/ǫ), as long as Larch does not halt in for-loop iteration i. So the total number of for-loop iterations is at most k∗ + log2(1/ǫ). Together with Lemma 1, this bounds the number of unlabeled examples drawn from DX .\nFinally, we bound the number of queries to Search and Label. The number of queries to Search is the same as the number of for-loop iterations—this is at most k∗+log2(1/ǫ). By Lemma 1 and the fact that V (S′ ∪ S′′) ⊆ V (S′) for any hypothesis space V and sets of labeled examples S′, S′′, the number of Label queries made by CAL in the i-th for-loop iteration is at most Õ(θki(ǫ) · dki · ℓ2i · polylog(i)). The claimed bound on the number of Label queries made by Larch now readily follows by taking a max over i, and using the facts that i ≤ k∗ and dk′ ≤ dk∗ for all k′ ≤ k."
    }, {
      "heading" : "4.3 An Improved Algorithm",
      "text" : "Larch is somewhat conservative in its use of Search, interleaving just one Search query between sequences of Label queries (from CAL). Often, it is advantageous to advance to higher complexity hypothesis classes quickly, as long as there is justification to do so. Counterexamples from Search provide such justification, and a ⊥ result from Search also provides useful feedback about the current version space: outside of its disagreement region, the version space is in complete agreement with h∗ (even if the version space does not contain h∗). Based on these observations, we propose an improved algorithm for the realizable setting, which we call Seabel. Due to space limitations, we present it in Appendix C. We prove the following performance guarantee for Seabel.\nTheorem 2. Assume that err(h∗) = 0. Let θk(·) denote the disagreement coefficient of V kii at the first iteration i in Seabel where ki ≥ k. Fix any ǫ, δ ∈ (0, 1). If Seabel is run with inputs hypothesis classes {Hk}∞k=0, oracles Search and Label, and learning parameters ǫ, δ ∈ (0, 1), then with probability 1 − δ:\nSeabel halts and returns a classifier with error rate at most ǫ; furthermore, it draws at most Õ((dk∗ + log k∗)/ǫ) unlabeled examples from DX , makes at most k ∗ + O (log(dk∗/ǫ) + log log k ∗) queries to Search, and at most Õ (maxk≤k∗ θk(2ǫ) · (dk∗ log2(1/ǫ) + log k∗)) queries to Label.\nIt is not generally possible to directly compare Theorems 1 and 2 on account of the algorithm-dependent disagreement coefficient bounds. However, in cases where these disagreement coefficients are comparable (as in the union-of-intervals example), the Search complexity in Theorem 2 is slightly higher (by additive log terms), but the Label complexity is smaller than that from Theorem 1 by roughly a factor of k∗. For the union-of-intervals example, Seabel would learn target union of k∗ intervals with k∗ +O(log(k∗/ǫ)) queries to Search and Õ((k∗)2 log2(1/ǫ)) queries to Label."
    }, {
      "heading" : "5 Non-Realizable Case",
      "text" : "In this section, we consider the case where the optimal hypothesis h∗ may have non-zero error rate, i.e., the non-realizable (or agnostic) setting. In this case, the algorithm Larch, which was designed for the realizable setting, is no longer applicable. First, examples obtained by Label and Search are of different quality: those returned by Search always agree with h∗, whereas the labels given by Label need not agree with h∗. Moreover, the version spaces (even when k = k∗) as defined by Larch may always be empty due to the noisy labels.\nAnother complication arises in our SRM setting that differentiates it from the usual agnostic active learning setting. When working with a specific hypothesis class Hk in the nested sequence, we may observe high error rates because (i) the finite sample error is too high (but additional labeled examples could reduce it), or (ii) the current hypothesis class Hk is impoverished. In case (ii), the best hypothesis in Hk may have a much larger error rate than h∗, and hence lower bounds [Kääriäinen, 2006] imply that active learning on Hk instead of Hk∗ may be substantially more difficult.\nThese difficulties in the SRM setting are circumvented by an algorithm that adaptively estimates the error of h∗. The algorithm, A-Larch (Algorithm 5), is presented in Appendix D.\nTheorem 3. Assume err(h∗) = ν. Let θk(·) denote the disagreement coefficient of V kii at the first iteration i in A-Larch where ki ≥ k. Fix any ǫ, δ ∈ (0, 1). If A-Larch is run with inputs hypothesis classes {Hk}∞k=0, oracles Search and Label, learning parameter δ, and unlabeled example budget Õ((dk∗ +log k\n∗)(ν+ ǫ)/ǫ2), then with probability 1 − δ: A-Larch returns a classifier with error rate ≤ ν + ǫ; it makes at most k∗ + O (log(dk∗/ǫ) + log log k\n∗) queries to Search, and Õ (maxk≤k∗ θk(2ν + 2ǫ) · (dk∗ log2(1/ǫ) + log k∗) · (1 + ν2/ǫ2)) queries to Label.\nThe proof is in Appendix D. The Label query complexity is at least a factor of k∗ better than that in Hanneke [2011], and sometimes exponentially better thanks to the reduced disagreement coefficient of the version space when consistency constraints are incorporated."
    }, {
      "heading" : "5.1 AA-Larch: an Opportunistic Anytime Algorithm",
      "text" : "In many practical scenarios, termination conditions based on quantities like a target excess error rate ǫ are undesirable. The target ǫ is unknown, and we instead prefer an algorithm that performs as well as possible until a cost budget is exhausted. Fortunately, when the primary cost being considered are Label queries, there are many Label-only active learning algorithms that readily work in such an “anytime” setting [see, e.g., Dasgupta et al., 2007, Hanneke, 2014].\nThe situation is more complicated when we consider both Search and Label: we can often make substantially more progress with Search queries than with Label queries (as the error rate of the best hypothesis in Hk′ for k\n′ > k can be far lower than in Hk). AA-Larch (Algorithm 2) shows that although these queries come at a higher cost, the cost can be amortized.\nAA-Larch relies on several subroutines: Sample-and-Label, Error-Check, Prune-Version-Space and Upgrade-Version-Space (Algorithms 6, 7, 8, and 9). The detailed descriptions are deferred to\nAlgorithm 2 AA-Larch\ninput: Nested hypothesis set H0 ⊆ H1 ⊆ · · · ; oracles Label and Search; learning parameter δ ∈ (0, 1); Search-to-Label cost ratio τ , dataset size upper bound N . output: hypothesis h̃. 1: Initialize: consistency constraints S ← ∅, counter c ← 0, k ← 0, verified labeled dataset L̃ ← ∅, working\nlabeled dataset L0 ← ∅, unlabeled examples processed i ← 0, Vi ← Hk(S). 2: loop 3: Reset counter c ← 0. 4: repeat 5: if Error-Check(Vi, Li, δi) then 6: (k, S, Vi) ← Upgrade-Version-Space(k, S, ∅) 7: Vi ← Prune-Version-Space(Vi, L̃, δi) 8: Li ← L̃ 9: continue loop\n10: end if 11: i ← i+ 1 12: (Li, c) ← Sample-and-Label(Vi−1,Label, Li−1, c) 13: Vi ← Prune-Version-Space(Vi−1, Li, δi) 14: until c = τ or li = N 15: e ← SearchHk(Vi) 16: if e 6= ⊥ then 17: (k, S, Vi) ← Upgrade-Version-Space(k, S, {e}) 18: Vi ← Prune-Version-Space(Vi, L̃, δi) 19: Li ← L̃ 20: else 21: Update verified dataset L̃ ← Li. 22: Store temporary solution h̃ = argminh′∈Vi err(h\n′, L̃). 23: end if 24: end loop\nAppendix E. Sample-and-Label performs standard disagreement-based selective sampling using oracle Label; labels of examples in the disagreement region are queried, otherwise inferred. Prune-Version-Space prunes the version space given the labeled examples collected, based on standard generalization error bounds. Error-Check checks if the best hypothesis in the version space has large error; Search is used to find a systematic mistake for the version space; if either event happens, AA-Larch calls Upgrade-Version-Space to increase k, the level of our working hypothesis class.\nTheorem 4. Assume err(h∗) = ν. Let θk′(·) denote the disagreement coefficient of Vi at the first iteration i after which k ≥ k′. Fix any ǫ ∈ (0, 1). Let nǫ = Õ(maxk≤k∗ θk(2ν + 2ǫ)dk∗(1 + ν2/ǫ2)) and define Cǫ = 2(nǫ + k\n∗τ). Run Algorithm 2 with a nested sequence of hypotheses {Hk}∞k=0, oracles Label and Search, confidence parameter δ, cost ratio τ ≥ 1, and upper bound N = Õ(dk∗/ǫ2). If the cost spent is at least Cǫ, then with probability 1− δ, the current hypothesis h̃ has error at most ν + ǫ.\nThe proof is in Appendix E. A comparison to Theorem 3 shows that AA-Larch is adaptive: for any cost complexity C, the excess error rate ǫ is roughly at most twice that achieved by A-Larch."
    }, {
      "heading" : "6 Discussion",
      "text" : "The Search oracle captures a powerful form of interaction that is useful for machine learning. Our theoretical analyses of Larch and variants demonstrate that Search can substantially improve Label-based active learners, while being plausibly cheaper to implement than oracles like CCQ.\nAre there examples where CCQ is substantially more powerful than Search? This is a key question, because a good active learning system should use minimally powerful oracles. Another key question is: Can the benefits of Search be provided in a computationally efficient general purpose manner?"
    }, {
      "heading" : "A Basic Facts and Notations Used in Proofs",
      "text" : ""
    }, {
      "heading" : "A.1 Concentration Inequalities",
      "text" : "Lemma 2 (Bernstein’s Inequality). Let X1, . . . , Xn be independent zero-mean random variables. Suppose that |Xi| ≤ M almost surely. Then for all positive t,\nPr\n\n\nn ∑\ni=1\nXi > t\n  ≤ exp ( − t 2/2\n∑n j=1 E[X 2 j ] +Mt/3\n)\n.\nLemma 3. Let Z1, . . . , Zn be independent Bernoulli random variables with mean p. Let Z̄ = 1 n\n∑n\ni=1 Zi."
    }, {
      "heading" : "Then with probability 1− δ,",
      "text" : "Z̄ ≤ p+ √ 2p ln(1/δ)\nn +\n2 ln(1/δ)\n3n .\nProof. Let Xi = Zi − p for all i, note that |Xi| ≤ 1. The lemma follows from Bernstein’s Inequality and algebra.\nLemma 4 (Freedman’s Inequality). Let X1, . . . , Xn be a martingale difference sequence, and |Xi| ≤ M almost surely. Let V be the sum of the conditional variances, i.e.\nV = n ∑\ni=1\nE[X2i |X1, . . . .Xi−1]"
    }, {
      "heading" : "Then, for every t, v > 0,",
      "text" : "Pr\n\n\nn ∑\ni=1\nXi > t and V ≤ v\n  ≤ exp ( − t 2/2\nv +Mt/3\n)\n.\nLemma 5. Let Z1, . . . , Zn be a sequence of Bernoulli random variables, where E[Zi|Z1, . . . , Zi−1] = pi. Then, for every δ > 0, with probability 1− δ:\nn ∑\ni=1\nZi ≤ 2vn + √ 4vn ln log 4n\nδ +\n2 3 ln log 4n δ .\nwhere vn = max( ∑n i=1 pi, 1). Proof. Let Xi = Zi − pi for all i, note that {Xi} is a martingale difference sequence and |Xi| ≤ 1. From Freedman’s Inequality and algebra, for any v,\nPr\n\n \n1\nn\nn ∑\ni=1\nZi > v +\n√\n2v ln log 4n δ\nn +\n2 ln log 4n δ\n3n and\nn ∑\ni=1\npi ≤ v\n\n  ≤ δ\nlogn+ 2 .\nThe proof follows by taking union bound over v = 2i, i = 0, 1, . . . , ⌈logn⌉. Define\nφ(d,m, δ) := 1\nm\n(\nd log em2 + log 2\nδ\n)\n. (1)\nTheorem 5 (Vapnik and Chervonenkis, 1971). Let F be a family of functions f : Z → {0, 1} on a domain Z with VC dimension at most d, and let P be a distribution on Z. Let Pn denote the empirical measure from an iid sample of size n from P . For any δ ∈ (0, 1), with probability at least 1− δ, for all f ∈ F ,\n−min { ε+ √ Pfε, √ Pnfε } ≤ Pf − Pnf ≤ min { ε+ √ Pnfε, √ Pfε }\nwhere ε := φ(d, n, δ)."
    }, {
      "heading" : "A.2 Notations",
      "text" : "For convenience, we define σ(d,m, δ) := φ(d,m, δ/3) , (2)\nas we will often split the overall allowed failure probability δ across two or three separate events. Because we apply the deviation inequalities to the hypothesis classes from {Hk}∞k=0, we also define:\nσk(m, δ) := σ(dk,m, δ), (3)\nwhere dk is the VC dimension of Hk. We have the following simple fact.\nFact 1.\nσ\n(\nd,m, δ\n2 logm(logm+ 1)\n)\n≥ ǫ =⇒ m ≤ 64 ǫ\n(\nd log 512\nǫ + log\n24\nδ\n)\n.\nFor integers i ≥ 1 and k ≥ 0, define\nδi := δ\ni(i+ 1) , δi,k := δi (k + 1)(k + 2)\nNote that ∑∞ i=1 δi = δ and ∑∞ k=0 δi,k = δi.\nFinally, for any distribution D̃ overX×Y and any hypothesis h : X → Y, we use err(h, D̃) := Pr(x,y)∼D̃[h(x) 6= y] to denote the probability with respect to D̃ that h makes a classification error."
    }, {
      "heading" : "B Active Learning Algorithm CAL",
      "text" : "In this section, we describe and analyze a variant of the Label-only active learning algorithm of Cohn et al. [1994], which we refer to as CAL. Note that Hanneke [2011] provides a label complexity analysis of CAL in terms of the disagreement coefficient under the assumption that the Label oracle is consistent with some hypothesis in the hypothesis class used by CAL. We cannot use that analysis because we call CAL as a subroutine in Larch with sets of hypotheses V that do not necessarily contain the optimal hypothesis h∗."
    }, {
      "heading" : "B.1 Description of CAL",
      "text" : "CAL takes as input a set of hypotheses V , the Label oracle (which always returns h∗(x) when queried with a point x), and learning parameters ǫ, δ ∈ (0, 1).\nThe pseudocode for CAL is given in Algorithm 3 below, where we use the notation\nU≤i :=\ni ⋃\nj=1\nUj\nfor any sequence of sets (Uj)j∈N."
    }, {
      "heading" : "B.2 Proof of Lemma 1",
      "text" : "We now give the proof of Lemma 1. Let V0 := V and Vi := V (T≤i) for each i ≥ 1. Clearly V0 ⊇ V1 ⊇ · · · , and hence Dis(V0) ⊇ Dis(V1) ⊇ · · · as well. Let Ei be the event in which the following hold:\n1. If CAL executes iteration i, then every h ∈ Vi satisfies\nPr x∼DX\n[h(x) 6= h∗(x) ∧ x ∈ Dis(Vi)] ≤ φ(d, 2i, δi/2) .\nAlgorithm 3 CAL\ninput: Hypothesis set V with VC dimension ≤d; oracle Label; learning parameters ǫ, δ ∈ (0, 1) output: Labeled examples T 1: for i = 1, 2, . . . do 2: Ti ← ∅ 3: for j = 1, 2, . . . , 2i do 4: xi,j ← independent draw from DX (the corresponding label is hidden) 5: if xi,j ∈ Dis(V (T≤i−1)) then 6: Ti ← Ti ∪ {(xi,j ,Label(xi,j))} 7: end if\n8: end for\n9: if φ(d, 2i, δi/2) ≤ ǫ or V (T≤i) = ∅ then 10: return T≤i 11: end if\n12: end for\n2. If CAL executes iteration i, then the number of Label queries in iteration i is at most\n2iµi +O ( √ 2iµi log(2/δi) + log(2/δi) ) ,\nwhere µi := θVi−1(ǫ) · 2φ(d, 2i−1, δi−1/2) .\nWe claim that E0 ∩ E1 ∩ · · · ∩ Ei holds with probability at least 1 − ∑i i′=1 δi′ ≥ 1 − δ. The proof is by induction. The base case is trivial, as E0 holds deterministically. For the inductive case, we just have to show that Pr(Ei | E0 ∩ E1 ∩ · · · ∩ Ei−1) ≥ 1− δi.\nCondition on the event E0 ∩ E1 ∩ · · · ∩ Ei−1. Suppose CAL executes iteration i. For all x /∈ Dis(Vi−1), let Vi−1(x) denote the label assigned by every h ∈ Vi−1 to x. Define\nŜi := { (xi,j , ŷi,j) : j ∈ {1, 2, . . . , 2i} , xi,j /∈ Dis(Vi−1), ŷi,j = Vi−1(xi,j) } .\nObserve that Ŝi∪Ti is an iid sample of size 2i from a distribution (which we call Di−1) over labeled examples (x, y), where x ∼ DX and y is given by\ny :=\n{\nVi−1(x) if x /∈ Dis(Vi−1) , h∗(x) if x ∈ Dis(Vi−1) .\nIn fact, for any h ∈ Vi−1, we have\nerrDi−1(h) = Pr (x,y)∼Di−1 [h(x) 6= y] = Pr x∼DX [h(x) 6= h∗(x) ∧ x ∈ Dis(Vi−1)] . (4)\nThe VC inequality (Theorem 5) implies that, with probability at least 1− δi/2,\n∀h ∈ V ( err(h, Ŝi ∪ Ti) = 0 =⇒ errDi−1(h) ≤ φ(d, 2i, δi/2) ) . (5)\nConsider any h ∈ Vi. We have err(h, Ti) = 0 by definition of Vi. We also have err(h, Ŝi) = 0 since h ∈ Vi ⊆ Vi−1. So in the event that (5) holds, we have\nPr x∼DX [h(x) 6= h∗(x) ∧ x ∈ Dis(Vi)] ≤ Pr x∼DX [h(x) 6= h∗(x) ∧ x ∈ Dis(Vi−1)]\n= errDi−1(h) ≤ φ(d, 2i, δi/2) ,\nwhere the first inequality follows because Dis(Vi) ⊆ Dis(Vi−1), and the equality follows from (4). Now we prove the Label query bound.\nClaim 1. On event Ei−1 for every h, h ′ ∈ Vi−1,\nPr x∼DX\n[h(x) 6= h′(x)] ≤ 2φ(d, 2i−1, δi−1/2)\nProof. On event Ei−1, every h ∈ Vi−1 satisfies\nPr x∼DX\n[h(x) 6= h∗(x), x ∈ Dis(Vi−1)] ≤ φ(d, 2i−1, δi−1/2) .\nTherefore, for any h, h′ ∈ Vi−1, we have\nPr x∼DX [h(x) 6= h′(x)] = Pr x∼DX [h(x) 6= h′(x), x ∈ Dis(Vi−1)]\n≤ Pr x∼DX [h(x) 6= h∗(x), x ∈ Dis(Vi−1)]\n+ Pr x∼DX\n[h′(x) 6= h∗(x), x ∈ Dis(Vi−1)]\n≤ 2φ(d, 2i−1, δi−1/2) .\nSince CAL does not halt before iteration i, we have 2φ(d, 2i−1, δi−1/2) ≥ ǫ, and hence the above claim and the definition of the disagreement coefficient imply\nPr x∼DX\n[x ∈ Dis(Vi−1)] ≤ θVi−1(ǫ) · 2φ(d, 2i−1, δi−1/2) = µi .\nTherefore, µi is an upper bound on the probability that Label is queried on xi,j , for each j = 1, 2, . . . , 2 i. By Lemma 3, the number of queries to Label is at most\n2iµi + O ( √ 2iµi log(2/δi) + log(2/δi) ) .\nwith probability at least 1− δi/2. We conclude by a union bound that Pr(Ei | E0 ∩E1 ∩ · · · ∩Ei−1) ≥ 1− δi as required.\nWe now show that in the event E0 ∩ E1 ∩ · · · , which holds with probability at least 1 − δ, the required consequences from Lemma 1 are satisfied. The definition of φ from (1) and the halting condition in CAL imply that the number of iterations I executed by CAL satisfies\nσ(d, 2I−1, δI−1/2) ≥ ǫ .\nThus by Fact 1,\n2I ≤ O ( 1\nǫ\n(\nd log 1\nǫ + log\n1\nδ\n)\n)\n,\nwhich immediately gives the required bound on the number of unlabeled points drawn from DX . Moreover, I can be bounded as\nI = O ( log(d/ǫ) + log log(1/δ) ) .\nTherefore, in the event E0 ∩ E1 ∩ · · · ∩ EI , CAL returns a set of labeled examples T := T≤I in which every h ∈ V (T ) satisfies\nPr x∼DX\n[h(x) 6= h∗(x) ∧ x ∈ Dis(V (T ))] ≤ ǫ ,\nand the number of Label queries is bounded by\nI ∑\ni=1\n(\n2iµi +O ( √ 2iµi log(2/δi) + log(2/δi) )\n)\n=\nI ∑\ni=1\nO\n 2i · ( θVi−1(ǫ) d log 2i + log(2/δi)\n2i\n)\n+ log(2/δi)\n\n\n=\nI ∑\ni=1\nO (\nθVi−1(ǫ) · ( d · i+ log(1/δ) )\n)\n= O\n(\nθV (ǫ) · ( d · ( log(d/ǫ) + log log(1/δ) )2 + ( log(d/ǫ) + log log(1/δ) ) · log(1/δ) )\n)\n= Õ ( θV (ǫ) · d · log2(1/ǫ) )\nas claimed."
    }, {
      "heading" : "C An Improved Algorithm for the Realizable Case",
      "text" : "In this section, we present an improved algorithm for using Search and Label in the realizable section. We call this algorithm Seabel (Algorithm 4)."
    }, {
      "heading" : "C.1 Description of Seabel",
      "text" : "Seabel proceeds in iterations like Larch, but takes more advantage of Search. Each iteration is split into two stages: the verification stage, and the sampling stage.\nIn the verification stage (Steps 4–13), Seabel makes repeated calls to Search to advance to as high of a complexity class as possible, until ⊥ is returned. When ⊥ is returned, it guarantees that whenever the latest version space completely agrees on an unlabeled point, then it is also in agreement with h∗, even if it does not contain h∗.\nIn the sampling stage (Steps 14–19), Seabel performs selective sampling, querying and infering labels based on disagreement over the new version space V kii . The preceding verification stage ensures that whenever a label is inferred, it is guaranteed to be in agreement with h∗.\nThe algorithm calls Algorithm 6 in Appendix E, where we slightly abuse the notation in Sample-and-Label that if the counter parameter is missing then it simply does not get updated."
    }, {
      "heading" : "C.2 Proof of Theorem 2",
      "text" : "Observe that Ti+1 is an iid sample of size 2 i+1 from a distribution (which we call Di) over labeled examples (x, y), where x ∼ DX , and\ny :=\n{\nV kii (x) if x /∈ Dis(V kii ) , h∗(x) if x ∈ Dis(V kii ) ,\nfor every x in the support of DX . (T1 is an iid sample from D0 := D; also note k0 = 0 and S0 = ∅.)\nLemma 6. Algorithm 4 maintains the following invariants:\n1. The loop in the verification stage of iteration i terminates for all i ≥ 1.\n2. ki ≤ k∗ for all i ≥ 0.\n3. h∗(x) = V kii (x) for all x /∈ Dis(V kii ) for all i ≥ 1.\nAlgorithm 4 Seabel\ninput: Nested hypothesis classes H0 ⊆ H1 ⊆ · · · ; oracles Search and Label; learning parameters ǫ, δ ∈ (0, 1)\n1: initialize S0 ← ∅, k0 ← 0. 2: Draw x1,1, x1,2 at random from DX , T1 ← { (x1,1,Label(x1,1)), (x1,2,Label(x1,2)) } 3: for iteration i = 1, 2, . . . do 4: S ← Si−1, k ← min { k′ ≥ ki−1 : Hk′(Si−1 ∪ Ti) 6= ∅ }\n# Verification stage (Steps 4–13) 5: loop 6: e ← SearchHk(Hk(S ∪ Ti)) 7: if e 6= ⊥ then 8: S ← S ∪ {e} 9: k ← min { k′ > k : Hk′(S ∪ Ti) 6= ∅ }\n10: else 11: break\n12: end if\n13: end loop 14: Si ← S, ki ← k # Sampling stage (Steps 14–19) 15: Define new version space V kii = Hki(Si ∪ Ti) 16: Ti+1 ← ∅ 17: for j = 1, 2, . . . , 2i+1 do 18: Ti+1 ← Sample-and-Label(V kii ,Label, Ti+1) 19: end for 20: if σki(2 i, δi,ki) ≤ ǫ then 21: return any ĥ ∈ V kii 22: end if\n23: end for\n4. h∗ is consistent with Si ∪ Ti+1 for all i ≥ 0.\nProof. It is easy to see that S only contains examples provided by Search, and hence the labels are consistent with h∗.\nNow we prove that the invariants hold by induction on i, starting with i = 0. For the base case, only the last invariant needs checking, and it is true because the labels in T1 are obtained from Label.\nFor the inductive step, fix any i ≥ 1, and assume that ki−1 ≤ k∗, and that h∗ is consistent with Ti. Now consider the verification stage in iteration i. We first prove that the loop in the verification stage will terminate and establish some properties upon termination. Observe that k and S are initially ki−1 and Si−1, respectively. Throughout the loop, the examples added to S are obtained from Search, and hence are consistent with h∗. Thus, h∗ ∈ Hk∗(S ∪ Ti), implying Hk∗(S ∪ Ti) 6= ∅. If k = k∗, then SearchHk∗ (Hk∗(S∪Ti)) would return⊥ and Algorithm 4 would exit the loop. If SearchHk(Hk(S∪Ti)) 6= ⊥, then k < k∗, and k cannot be increased beyond k∗ since Hk∗(S∪Ti) 6= ∅. Thus, the loop must terminate with k ≤ k∗, implying ki ≤ k∗. This establishes invariants 1 and 2. Moreover, because the loop terminates with SearchHk(Hk(S ∪ Ti)) returning ⊥ (and here, k = ki and Hk(S ∪ Ti) = V kii ), there is no counterexample x ∈ X such that h∗ disagrees with every h ∈ V kii . This implies that h∗(x) = V kii (x) for all x /∈ Dis(V kii ), i.e., invariant 3.\nNow consider any (x, y) added to Ti+1 in the sampling stage. If x ∈ Dis(V kii ), the label is obtained from Label, and hence is consistent with h∗; if x /∈ Dis(V kii ), the label is V kii (x), which is the same as h∗(x) as previously argued. So h∗ is consistent with all examples in Ti+1, and hence also all examples in Si ∪ Ti+1, proving invariant 4. This completes the induction.\nLet Ei be the event in which the following hold:\n1. For every k ≥ 0, every h ∈ Hk satisfies\nerr(h,Di−1) ≤ err(h, Ti) + √ err(h, Ti)σk(2i, δi,k) + σk(2 i, δi,k) .\n2. The number of Label queries in iteration i (to form Ti+1) is at most\n2i+1 Pr x∼DX\n[x ∈ Dis(V kii )] +O ( √\n2i+1 Pr x∼DX\n[x ∈ Dis(V kii )] log(1/δi) + log(1/δi) ) ,\nUsing Theorem 5 and Lemma 3, along with the union bound, Pr(Ei) ≥ 1− δi. Define E := ∩∞i=1Ei; a union bound implies that Pr(E) ≥ 1− δ.\nWe now prove Theorem 2, starting with the error rate guarantee. Condition on the event E. Since ki ≤ k∗ (Lemma 6), the definition of σk from (3), the halting condition in Algorithm 4, and Fact 1 imply that the algorithm must halt after at most I iterations, where\n2I ≤ O ( 1\nǫ\n(\ndk∗ log 1\nǫ + log\nk∗\nδ\n)\n)\n. (6)\nSo let I denote the iteration in which Algorithm 4 halts. By definition of EI , we have\nerr(ĥ, Di−1) ≤ err(ĥ, Ti) + √ err(ĥ, Ti)σki (2 i, δi,ki) + σki(2 i, δi,ki)\n= σki(2 i, δi,ki) ≤ ǫ ,\nwhere the second inequality follows from the termination condition. By Lemma 6, h∗(x) = V ki−1 i−1 (x) for all x /∈ Dis(V ki−1i−1 ). Therefore, D(· | x) = Di−1(· | x) for every x in the support of DX , and\nerr(ĥ, D) = err(ĥ, Di−1) ≤ ǫ .\nNow we bound the unlabeled, Label, and Search complexities, all conditioned on event E. First, as argued above, the algorithm halts after at most I iterations, where 2I is bounded as in (6). The number of unlabeled examples drawn from DX across all iterations is within a factor of two of the number of examples drawn in the final sampling stage, which is O(2I). Thus (6) also gives the bound on the number of unlabeled examples drawn.\nNext, we consider the Search complexity. For each iteration i, each call to Search either returns a counterexample that forces k to increment (but never past k∗, as implied by Lemma 6), or returns ⊥ which causes an exit from the verification stage loop. Therefore, the total number of Search calls is at most\nk∗ + I = k∗ +O\n(\nlog dk∗\nǫ + log log\nk∗\nδ\n)\n.\nFinally, we consider the Label complexity. For i ≤ I, we first show that the version space V kii is always contained in a ball of small radius (with respect to the disagreement pseudometric). Specifically, for every h, h′ in V kii , err(h, Ti) = 0 and err(h, Ti) = 0. By definition of Ei, this implies that\nerr(h,Di−1) ≤ σki (2i, δi,ki) and err(h′, Di−1) ≤ σki(2i, δi,ki).\nTherefore, by the triangle inequality and the fact ki ≤ k∗,\nPr x∼D\n[h(x) 6= h′(x)] ≤ 2σki(2i, δi,ki) ≤ 2σk∗(2i, δi,k∗).\nAlso, the upper bound 2I ≤ Õ(dk∗/ǫ) from (6) implies the lower bound σk∗(2i, δi,k∗) ≥ ǫ/2 for i ≤ I. Thus, the probability mass of the disagreement region can be bounded as\nPr x∼DX\n[x ∈ Dis(V kii )] ≤ θki(ǫ) · 2σk∗(2i, δi,k∗).\nBy definition of Ei, the number of queries to Label at iteration i is at most\n2i+1 Pr x∼DX\n[x ∈ Dis(V kii )] +O ( √\n2i+1 Pr x∼DX\n[x ∈ Dis(V kii )] log(1/δi,k) + log(1/δi) ) ,\nwhich is at most O ( 2i · θki(ǫ) · σk∗(2i, δi,k∗) ) .\nWe conclude that the total number of Label queries by Algorithm 4 is bounded by\n2 + I ∑\ni=1\nO ( 2i · θki(ǫ) · σk∗(2i, δi,k∗) )\n= 2 +\nI ∑\ni=1\nO\n(\n2i · max k≤k∗\nθk(ǫ) · σk∗(2i, δi,k∗) )\n= O\n\n  max k≤k∗ θk(ǫ) ·\n\n\nI ∑\ni=1\n2i · d ln(2 i) + ln( (i\n2+i)(k∗)2\nδ )\n2i\n\n\n\n \n= O\n(\nmax k≤k∗\nθk(ǫ) · ( dk∗I 2 + I log k∗\nδ\n)\n)\n= O\n\nmax k≤k∗\nθk(ǫ) · ( dk∗ ( log dk∗\nǫ + log log\nk∗\nδ\n)2\n+\n(\nlog dk∗\nǫ + log log\nk∗\nδ\n)\nlog k∗\nδ\n)\n\n\n= Õ\n(\nmax k≤k∗\nθk(ǫ) · ( dk∗ · log2 1\nǫ + log k∗\n)\n)\nas claimed."
    }, {
      "heading" : "D A-Larch: An Adaptive Agnostic Algorithm",
      "text" : "In this section, we present a generalization of Seabel that works in the agnostic setting. We call this algorithm A-Larch (Algorithm 5)."
    }, {
      "heading" : "D.1 Description of A-Larch",
      "text" : "A-Larch proceeds in iterations like Seabel. Each iteration is split into three stages: the error estimation stage, the verification stage, and the sampling stage.\nIn the error estimation stage, A-Larch uses a structural risk minimization approach (Step 4) to compute γi−1, a (tight) upper bound on Pr[h\n∗(x) 6= y, x ∈ Dis(Vi−1)]. (See item 1 of Lemma 7 for justification.) The verification stage (Steps 5–18) and sampling stage (Steps 20–23) in A-Larch are similar to the corresponding stages in Seabel. Same as Seabel, the algorithm calls Algorithm 6, 8 and 9 in Appendix E (Sample-and-Label, Prune-Version-Space andUpgrade-Version-Space, respectively), where we slightly abuse the notation in Sample-and-Label that if the counter parameter is missing then it simply does not get updated.\nAlgorithm 5 A-Larch\ninput: Nested hypothesis set H0 ⊆ H1 ⊆ · · · ; oracles Label and Search; learning parameter δ ∈ (0, 1); unlabeled examples budget m = 2I+2. output: hypothesis ĥ. 1: initialize S ← ∅, k0 ← 0. 2: Draw x1,1, x1,2 at random from DX , T1 ← { (x1,1,Label(x1,1)), (x1,2,Label(x1,2)) }\n3: for i = 1, 2, . . . , I do 4: γi−1 ← mink′≥ki−1,h∈Hk′ { err(h, Ti) + √ err(h, Ti)σk′ (2i, δi,k′ ) + σk′ (2 i, δi,k′) }\n# Error estimation\nstage (Step 4) 5: S ← Si−1, k ← ki−1. # Verification stage (Steps 5–18) 6: V ki ← Prune-Version-Space(Hk(S), Ti, δi) 7: loop 8: if minh∈Hk(S) err(h, Ti) > γi−1 + √ γi−1σk(2i, δi,k) + σk(2 i, δi,k) then\n9: (k, S, V ki ) ← Upgrade-Version-Space(k, S, ∅) 10: else 11: e ← SearchHk(V ki ) 12: if e 6= ⊥ then 13: (k, S, V ki ) ← Upgrade-Version-Space(k, S, {e}) 14: else\n15: break 16: end if\n17: end if 18: end loop 19: Si ← S, ki ← k 20: Ti+1 ← ∅ # Sampling stage (Steps 20–23) 21: for j = 1, 2, . . . , 2i+1 do 22: Ti+1 ← Sample-and-Label(V kii ,Label, Ti+1) 23: end for 24: end for 25: return any ĥ ∈ V kII ."
    }, {
      "heading" : "D.2 Proof of Theorem 3",
      "text" : "Let\nM(ν, k∗, ǫ, δ) := min\n{\n2n : n ∈ N, 6 √ νσk∗(2n, δn,k∗) + 21σk∗(2 n, δn,k∗) ≤ ǫ\n}\n= O\n(\n(dk∗ log(1/ǫ) + log(k ∗/δ))(ν + ǫ)\nǫ2\n)\n.\nwhere the second line is from Fact 1.\nTheorem 6 (Restatement of Theorem 3). Assume err(h∗) = ν. If Algorithm 5 is run with inputs hypothesis classes {Hk}∞k=0, oracles Search and Label, learning parameter δ, unlabeled examples budget m = M(ν, k∗, ǫ, δ) and the disagreement coefficient of Hk(S) is at most θk(·), then, with probability 1− δ: (1) The returned hypothesis ĥ satisfies err(ĥ) ≤ ν + ǫ . (2) The total number of queries to oracle Search is at most\nk∗ + logm ≤ k∗ +O ( log dk∗\nǫ + log log\nk∗\nδ\n)\n.\n(3) The total number of queries to oracle Label is at most\nÕ\n\nmax k≤k∗\nθk(2ν + 2ǫ) · dk∗ ( log 1\nǫ\n)2 · ( 1 + ν2\nǫ2\n)\n\n .\nThe proof relies on an auxillary lemma. First, we need to introduce the following notation. Observe that Ti+1 is an iid sample of size 2\ni+1 from a distribution (which we call Di) over labeled examples (x, y), where x ∼ DX and the conditional distribution is\nDi(y | x) := { 1{y = V kii (x)} if x /∈ Dis(V kii ) , D(y | x) if x ∈ Dis(V kii ) .\nT1 is a sample of size 2 from D0 := D. Let Ei be the event in which the following hold:\n1. For every k ≥ 0, every h ∈ Hk satisfies\nerr(h,Di−1) ≤ err(h, Ti) + √ err(h, Ti)σk(2i, δi,k) + σk(2 i, δi,k) ,\nerr(h, Ti) ≤ err(h,Di−1) + √ err(h,Di−1)σk(2i, δi,k) + σk(2 i, δi,k) .\n2. The number of Label queries at iteration i is at most\n2i+1 Pr x∼DX\n[x ∈ Dis(V kii )] +O ( √\n2i+1 Pr x∼DX\n[x ∈ Dis(V kii )] log(1/δi) + log(1/δi) ) .\nUsing Theorem 5 and Lemma 3, along with the union bound, Pr(Ei) ≥ 1 − δi. Define E := ∩∞i=1Ei, by union bound, Pr(E) ≥ 1− δ. Recall that ki is the value of k at the end of iteration i.\nLemma 7. On event E, Algorithm 5 maintains the following invariants:\n1. For all i ≥ 1, γi−1 is such that\nerr(h∗, Di−1) ≤ γi−1 ≤ err(h∗, Di−1) + 2 √ err(h∗, Di−1)σk∗(2i, δi,k∗) + 3σk∗(2 i, δi,k∗).\n2. The loop in the verification stage of iteration i terminates for all i ≥ 1.\n3. ki ≤ k∗ for all i ≥ 0.\n4. h∗(x) = V kii (x) for all x /∈ Dis(V kii ) for all i ≥ 1.\n5. For all i ≥ 0, for every hypothesis h, err(h,Di)− err(h∗, Di) ≥ err(h,D)− err(h∗, D). Therefore, h∗ is the optimal hypothesis among ∪kHk with respect to Di.\nProof. Throughout, we assume the event E holds. It is easy to see that S only contains examples provided by Search, and hence the labels are consistent with h∗. Now we prove that the invariants hold by induction on i, starting with i = 0. For the base case, invariant 3 holds since k0 = 0 ≤ k∗, and invariant 5 holds since D0 = D and h∗ is the optimal hypothesis in ∪kHk. Now consider the inductive step. We first prove that invariant 1 holds.\n(1) By definition of Ei, for all k ′ ≥ ki−1, we have for all h ∈ Hk′ ,\nerr(h,Di−1) ≤ err(h, Ti) + √ err(h, Ti)σk′ (2i, δi,k′ ) + σk′ (2 i, δi,k′) .\nThus,\nmin h∈H\nk′\nerr(h,Di−1) ≤ min h∈H\nk′\nerr(h, Ti) + √ err(h, Ti)σk′ (2i, δi,k′) + σk′ (2 i, δi,k′) .\nTaking minimum over k′ ≥ ki−1 on both sides, notice that h∗ is the optimal hypothesis with respect to Di−1 and recall the definition of γi−1, we get\nerr(h∗, Di−1) ≤ γi−1 .\n(2) By definition of γi−1, we have\nγi−1 = min k′≥ki−1,h∈Hk′\n{\nerr(h, Ti) + √ err(h, Ti)σk′ (2i, δi,k′ ) + σk′ (2 i, δi,k′)\n}\nTaking k′ = k∗, h = h∗, we get\nγi−1 ≤ err(h∗, Ti) + √ err(h∗, Ti)σk∗ (2i, δi,k∗) + σk∗(2 i, δi,k∗)\nIn conjunction with the fact that by definition of Ei,\nerr(h∗, Ti) ≤ err(h∗, Di−1) + √ err(h∗, Di−1)σk∗(2i, δi,k∗) + σk∗(2 i, δi,k∗)\nWe get\nγi−1 ≤ err(h∗, Di−1) + 2 √ err(h∗, Di−1)σk∗(2i, δi,k∗) + 3σk∗(2 i, δi,k∗) .\nThus, invariant 1 is established for iteration i. Now consider the verification stage in iteration i. We first prove that the loop in the verification stage will terminate and establish some properties upon termination. Observe that k and S are initially ki−1 and Si−1, respectively. Throughout the loop, the examples added to S are obtained from Search, and hence are consistent with h∗. In addition, we have the following claim regarding k∗.\nClaim 2. If invariants 1–5 holds for iteration i− 1, then for iteration i, the following holds:\n(a) minh∈Hk∗ (S) err(h, Ti) ≤ γi−1 + √ γi−1σk∗(2i, δi,k∗) + σk∗(2 i, δi,k∗)\n(b)\nh∗ ∈ V k∗i = { h ∈ Hk∗(S) :\nerr(h, Ti) ≤ min h′∈Hk∗ (S)\nerr(h′, Ti) + 2 √ err(h′, Ti)σk∗(2i, δi,k∗) + 3σk∗(2 i, δi,k∗) } .\nProof. Recall that h∗ is the optimal hypothesis under distribution Di−1. We have already shown above that err(h∗, Di−1) ≤ γi−1. By the definition of Ei,\nmin h∈Hk∗ (S)\nerr(h, Ti) ≤ err(h∗, Ti)\n≤ err(h∗, Di−1) + √ err(h∗, Di−1)σ(2i, δi,k∗) + σ(2 i, δi,k∗)\n≤ γi−1 + √ γi−1σk∗(2i, δi,k∗) + σk∗(2 i, δi,k∗)\nwhere the last inequality is from that err(h∗, Di−1) ≤ γi−1. This proves item (a). On the other hand, for all h′ in Hk∗(S),\nerr(h∗, Ti) ≤ err(h∗, Di−1) + √ err(h∗, Di−1)σk∗(2i, δi,k∗) + σ(2 i, δi,k∗)\n≤ err(h′, Di−1) + √ err(h′, Di−1)σk∗ (2i, δi,k∗) + σ(2 i, δi,k∗)\n≤ err(h′, Ti) + 2 √ err(h′, Ti)σk∗ (2i, δi,k∗) + 3σ(2 i, δi,k∗) .\nwhere the first inequality is from the definition of Ei, the second inequality is from Invariant 5 of iteration i− 1, the third inequality is from the definition of Ei.\nThus, err(h∗, Ti) ≤ minh′∈Hk∗ (S) err(h′, Ti) + 2 √ err(h′, Ti)σk∗(2i, δi,k∗) + 3σk∗(2 i, δi,k∗), proving item\n(b).\nClaim 2 implies that k cannot increase beyond k∗. To see this, observe that Claim 2(a) implies the condition in Step 8 is not satisfied for k = k∗. In addition, Claim 2(b) implies that h∗ ∈ V k∗i 6= ∅, which in turn means that SearchHk∗ (V k∗\ni ) = ⊥. Hence, the loop in the verification stage would terminate if k ever reaches k∗. Because iteration i starts with k ≤ k∗ (as invariant 3 holds in iteration i − 1), invariants 2 and 3 must also hold for iteration i.\nFinally, we can establish invariants 4 and 5 for iteration i. Because the loop terminates with SearchHk(V ki i )\nreturning ⊥, there is no counterexample x ∈ X such that h∗ disagrees with every h ∈ V kii . This implies that h∗(x) = V kii (x) for all x /∈ Dis(V kii ) (i.e., invariant 4). Hence, for any hypothesis h,\nerr(h,Di) = Pr[h(x) 6= h∗(x), x /∈ Dis(V kii )] + Pr[h(x) 6= y, x ∈ Dis(V kii )] .\nTherefore,\nerr(h,Di)− err(h∗, Di) = Pr[h(x) 6= h∗(x), x /∈ Dis(V kii )] + Pr[h(x) 6= y, x ∈ Dis(V kii )]\n− Pr[h∗(x) 6= y, x ∈ Dis(V kii )] ≥ Pr[h(x) 6= y, x /∈ Dis(V kii )]− Pr[h∗(x) 6= y, x /∈ Dis(V kii )]\n+ Pr[h(x) 6= y, x ∈ Dis(V kii )]− Pr[h∗(x) 6= y, x ∈ Dis(V kii )] = err(h,D)− err(h∗, D) ,\nwhich proves invariant 5 for iteration i.\nProof of Theorem 6. Supose event E happens. We first show a claim regarding the error of hypotheses in current version spaces.\nClaim 3. On event E, for all i ≥ 1, for all h ∈ V kii ,\nerr(h,D) ≤ err(h∗, Di−1) + 6 √ err(h∗, Di−1)σk∗(2i, δi,k∗) + 21σk∗(2 i, δi,k∗).\nProof. First, for every h in V kii ,\nerr(h, Ti) ≤ min h′∈Hki (S)\nerr(h′, Ti) + 2 √ err(h′, Ti)σki(2 i, δi,ki) + 3σki(2 i, δi,ki) ,\nand since the condition in step 8 is not satisfied for k = ki, we know that\nmin h′∈Hki (S)\nerr(h′, Ti) ≤ γi−1 + √ γi−1σki(2 i, δi,ki) + σki(2 i, δi,ki) .\nThus,\nerr(h, Ti) ≤ γi−1 + 3 √ γi−1σki(2 i, δi,ki) + 6σki(2 i, δi,ki) . (7)\nBy definition of event Ei, we also have\nerr(h,Di−1) ≤ err(h, Ti) + √ err(h, Ti)σki (2 i, δi,ki) + σki(2 i, δi,ki) .\nHence,\nerr(h,Di−1) ≤ γi−1 + 4 √ γi−1σki(2 i, δi,ki) + 10σki(2 i, δi,ki) .\nFurthermore, by item 1 of Lemma 7,\nγi−1 ≤ err(h∗, Di−1) + 2 √ err(h∗, Di−1)σk∗ (2i, δi,k∗) + 3σk∗(2 i, δi,k∗) .\nThis implies that\nerr(h,Di−1) ≤ err(h∗, Di−1) + 6 √ err(h∗, Di−1)σki (2 i, δi,ki) + 21σki(2 i, δi,ki)\n≤ err(h∗, Di−1) + 6 √ err(h∗, Di−1)σk∗ (2i, δi,k∗) + 21σk∗(2 i, δi,k∗) .\nwhere the second inequality is from item 3 of Lemma 7.\nWe first prove the error rate guarantee. Suppose iteration i = I = log2 M(ν, k ∗, ǫ, δ) has been reached.\nObserve that from Claim 3, for ĥ ∈ V kII ,\nerr(ĥ, DI−1)− err(h∗, DI−1) ≤ 6 √ err(h∗, DI−1)σk∗(2I , δI,k∗) + 21σk∗(2 I , δI,k∗) ≤ ǫ\nwhere the second inequality is from that m = 2I = M(ν, k∗, ǫ, δ). Thus, by item 5 of Lemma 7,\nerr(ĥ, D)− err(h∗, D) ≤ err(ĥ, DI−1)− err(h∗, DI−1) ≤ ǫ .\nNext, we prove the bound on the number of Search queries. From Lemma 7, Algorithm 5 maintains the invariant that k ≤ k∗. For each iteration i, each call to Search either returns an example forcing k to increment, or returns ⊥ which causes an exit from the verification stage loop. Therefore, the total number of Search calls is at most\nk∗ + I ≤ k∗ +O ( log dk∗\nǫ2 + log log\nk∗\nδ\n)\n.\nFinally, we prove the bound on the number of Label queries. This is done in a few steps.\n1. We first show that the version space V kii is always contained in a ball of small radius (with respect to the\ndisagreement pseudometric Prx∼DX [h(x) 6= h′(x)]). Specifically, for 1 ≤ i ≤ I, for any h, h′ ∈ V kii , from Claim 3, in conjunction with triangle inequality, and that err(h∗, Di−1) ≤ err(h,D) = ν,\nPr x∼DX\n[h(x) 6= h′(x)]\n≤ 2 err(h∗, Di−1) + 12 √ err(h∗, Di−1)σk∗(2i, δi,k∗) + 42σk∗(2 i, δi,k∗)\n≤ 2ν + 12 √ νσk∗(2i, δi,k∗) + 42σk∗(2 i, δi,k∗)\nThus, V kii is contained in BHki (S)(h, 2ν + 12 √ νσk∗ (2i, δi,k∗) + 42σk∗(2 i, δi,k∗)) for some h in Hki(S).\n2. Next we bound the label complexity per iteration. Note that by the choice of m = 2I = M(ν, k∗, ǫ, δ), 6 √ νσk∗(2I−1, δI−1,k∗) + 21σk∗(2 I−1, δI−1,k∗) ≥ ǫ, therefore for all 1 ≤ i ≤ I, 6 √\nνσk∗(2i, δi,k∗) + 21σk∗(2 i, δi,k∗) ≥ ǫ/2. Thus, the size of the disagreement region can be bounded as\nPr x∼DX\n[x ∈ Dis(V kii )] ≤ θk(2ν + ǫ) · ( 2ν + 12 √ νσk∗ (2i, δi,k∗) + 42σk∗(2 i, δi,k∗) )\n≤ θk(2ν + ǫ) · ( 8ν + 48σk∗(2 i, δi,k∗) ) . (8)\nBy definition of Ei, the number of queries to Label at iteration i is at most\n2i+1 Pr x∼DX\n[x ∈ Dis(V kii )] +O ( √\n2i+1 Pr x∼DX\n[x ∈ Dis(V kii )] log(1/δi,k∗) + log(1/δi,k∗) ) .\nCombining this with (8) gives\n# Label queries in iteration i = O ( 2i · θki(2ν + ǫ) · (ν + σk∗(2i, δi,k∗)) ) . (9)\n3. From the setting of m = 2I = Õ(dk∗(ν + ǫ)/ǫ 2), we get that\nI = O\n(\nlog dk∗\nǫ + log log\nk∗\nδ\n)\n.\nNow, using (9), we get that the total number of Label queries by Algorithm 5 is bounded by\n2 +\nI ∑\ni=1\nO ( 2i · θki(2ν + ǫ) · (ν + σk∗(2i, δi,k∗)) )\n= 2 +\nI ∑\ni=1\nO\n(\n2i · max k≤k∗\nθk(2ν + ǫ) · (ν + σk∗(2i, δi,k∗)) )\n= O\n\n  max k≤k∗ θk(2ν + ǫ) ·\n\n\nI ∑\ni=1\n2i(ν + σk∗(2 i, δi,k∗))\n\n\n\n \n= O\n\n  max k≤k∗ θk(2ν + ǫ) ·\n ν2I + I ∑\ni=1\n2i d ln(2i) + ln( (i\n2+i)(k∗)2\nδ )\n2i\n\n\n\n \n= O\n(\nmax k≤k∗\nθk(2ν + ǫ) · ( ν2I + dk∗I 2 + I log k∗\nδ\n)\n)\n= O\n\nmax k≤k∗\nθk(2ν + ǫ) · ( ν2 + ǫν\nǫ2\n(\ndk∗ log 1\nǫ + log\nk∗\nδ\n)\n+ dk∗\n(\nlog dk∗\nǫ + log log\nk∗\nδ\n)2\n+\n(\nlog dk∗\nǫ + log log\nk∗\nδ\n)\nlog k∗\nδ\n)\n\n\n= Õ\n\nmax k≤k∗\nθk(2ν + ǫ) · ( dk∗(log 1\nǫ )2 + log\nk∗\nδ\n) · ( 1 + ν2\nǫ2\n)\n\n ."
    }, {
      "heading" : "E Performance Guarantees of AA-Larch",
      "text" : ""
    }, {
      "heading" : "E.1 Detailed Description of Subroutines",
      "text" : "Subroutine Sample-and-Label performs standard disagreement-based selective sampling. Specifically, it draws an unlabeled example x from the DX . If x is in the agreement region of version space V , its label is inferred as V (x); otherwise, we query the Label oracle to get its label. The counter c is incremented when Label is called.\nAlgorithm 6 Sample-and-Label\ninput: Version space V ⊂ H , oracle Label, labeled dataset L, counter c. output: New labeled dataset L′, new counter c′. 1: x ← independent draw from DX (the corresponding label is hidden). 2: if x ∈ Dis(V ) then 3: L′ ← L ∪ { (x,Label(x)) }\n4: c′ ← c+ 1 5: else 6: L′ ← L ∪ { (x, V (x)) } 7: c′ ← c 8: end if\nSubroutine Error-Check checks if the version space has high error, based on item 2 of Lemma 9 – that is, if k = k∗, then Error-Check should never fail. Furthermore, if version space Vi fails Error-Check, then Vi should have small radius – see Lemma 8 for details.\nAlgorithm 7 Error-Check\ninput: Version space V ⊂ Hk, labeled dataset L of size l, confidence δ. output: Boolean variable b indicating if V has high error. 1: Let δk := δ/((k + 1)(k + 2)) for all k ≥ 0. 2: γ ← mink′≥k,h∈H\nk′\n{ err(h, L) + 2 √ err(h, L)σk′(l, δk′) + 3σk′(l, δk′) }\n3: if minh∈V err(h, L) > γ + 2 √\nγσk(l, δk) + 3σk(l, δk) then 4: b ← true 5: else 6: b ← false 7: end if\nSubroutine Prune-Version-Space performs update on our version space based on standard generalization error bounds. The version space never eliminates the optimal hypothesis in Hk(S) when working with Hk. Claim 4 shows that, if at step i, k = k ∗, then h∗ ∈ Vi from then on.\nAlgorithm 8 Prune-Version-Space\ninput: Version space V ⊂ Hk, labeled dataset L of size l, confidence δ. output: Pruned version space V ′. 1: Update version space:\nV ′ ← {\nh ∈ V : err(h, L) ≤ min h′∈V err(h′, L) + 2 √ err(h′, L)σk(l, δk) + 3σk(l, δk) } ,\nwhere δk := δ\n(k+1)(k+2) .\nSubroutine Upgrade-Version-Space is called when (1) a systematic mistake of the version space Vi has been found by Search; or (2) Error-Check detects that the error of Vi is high. In either case, k can be increased to the minimum level such that the updated Hk(S) is nonempty. This still maintains the invariant that k ≤ k∗.\nAlgorithm 9 Upgrade-Version-Space\ninput: Current level of hypothesis class k, seed set S, seed to be added s. output: New level of hypothesis class k, new seed set S, updated version space V . 1: S ← S ∪ s 2: k ← min { k′ > k : Hk′(S) 6= ∅ }\n3: V ← Hk(S)"
    }, {
      "heading" : "E.2 Proof of Theorem 4",
      "text" : "This section uses the following definition of σ:\nσk(m, δ) = φ(dk,m, δ/3) = 1\nm (d log em2 + log\n6 δ ).\nWe restate Theorem 4 here for convenience.\nTheorem 7. There exist constants c1, c2 > 0 such that the following holds. Assume err(h ∗) = ν. Let θk′(·) denote the disagreement coefficient of Vi at the first step i after which k ≥ k′. Fix any ǫ, δ ∈ (0, 1). Let nǫ = c1 maxk≤k∗ θk(2ν+2ǫ)(dk∗ log 1 ǫ +log 1 δ )(1+ν2/ǫ2) and define Cǫ = 2(nǫ+k\n∗τ). Run Algorithm 2 with a nested sequence of hypotheses {Hk}∞k=0, oracles Label and Search, confidence parameter δ, cost ratio τ ≥ 1, and upper bound N = c2(dk∗ log 1ǫ + log 1δ )/ǫ2. If the cost spent is at least Cǫ, then with probability 1− δ, the current hypothesis h̃ has error at most ν + ǫ.\nRemark. The purpose of having a bound on unlabeled examples, N , is rather technical— to deter the algorithm from getting into an infinite loop due to its blind self-confidence. Suppose that AA-Larch starts with H0 that has a single element h. Then, without such an N -based condition, it will incorrectly infer the labels of all the unlabeled examples drawn and end up with an infinite loop between lines 4 and 14. The condition on N is very mild—any N satisfying N = poly(dk∗ , 1/ǫ) and N = Ω(dk∗/ǫ 2) is sufficient.\nProof of Theorem 7. For integer j ≥ 0, define step j as the execution period in AA-Larch when the value of i is j.\nLet li = |Li|. Denote by LDi the dataset containing unlabeled examples in Li labeled entirely by Label, i.e., LDi = { (x,Label(x)) : (x, y) ∈ Li }\n. Note that LDi is an iid sample from D. We call dataset Li has favorable bias, if the following holds for any hypothesis h:\nerr(h, LDi )− err(h∗, LDi ) ≤ err(h, Li)− err(h∗, Li). (10) Let Ei be the event that the following conditions hold:\n1. For every k ≥ 0, every h ∈ Hk satisfies\nerr(h,D) ≤ err(h, LDi ) + √ err(h, LDi )σk(li, δi,k) + σk(li, δi,k) ,\nerr(h, LDi ) ≤ err(h,D) + √ err(h,D)σk(li, δi,k) + σk(li, δi,k) .\nFor every h, h′ ∈ Hk, (err(h, LDi )− err(h′, LDi ))− (err(h,D)− err(h′, D))\n≤ √\ndLD i\n(h, h′) · σk(li, δi,k) + σk(li, δi,k) .\nwhere dLD i (h, h′) = 1 li\n∑\n(x,y)∈LD i\n[h(x) 6= h′(x)], fraction of LDi where h and h′ disagree.\n2. For every 1 ≤ i′ < i, the number of Label queries from step i′ to step i is at most\ni ∑\nj=i′\nPr x∼DX\n[x ∈ Dis(Vj−1)] +O\n\n \n√ √ √ √ i ∑\nj=i′\nPr x∼DX\n[x ∈ Dis(Vj−1)] log(1/δi) + log(1/δi)\n\n  ,\nwhere Vj denotes its final value in Algorithm 2.\nUsing Theorem 5 and Lemma 5, along with the union bound, Pr(Ei) ≥ 1− δi. Define E := ∩∞i=1Ei, by union bound, Pr(E) ≥ 1− δ. We henceforth condition on E holding.\nDefine\nM(ν, k∗, ǫ, δ,N) := min\n{\nm ∈ N : 8 √ νσk∗(m, δm+k∗N,k∗) + 35σk∗(m, δm+k∗N,k∗) ≤ ǫ }\n≤ O ( (dk∗ log(1/ǫ) + log(Nk ∗/δ))(ν + ǫ)\nǫ2\n)\nWe say that an iteration of the loop is verified if Step 20 is triggered; all other iterations are unverified. Let Γ be the set of i’s where xi gets added to the final set L, and ∆ be the set of i’s where xi gets discarded. It is easy to see that if i is in Γ (resp. ∆), then the i is in a verified (resp. unverified) iteration.\nDefine i∗ := min { i ∈ Γ : li ≥ M(ν, k∗, ǫ, δ,N) }\n. Denote by ki the final value of k after i unlabeled examples are processed.\nWe need to prove two claims:\n1. For i ≥ i∗, err(h̃i) ≤ ν + ǫ, where h̃i is the hypothesis h̃ stored at the end of step i. 2. The total cost spent by Algorithm 2 up to step i∗ is at most Cǫ.\nTo prove the first claim, fix any i ≥ i∗. The stored hypothesis h̃i is updated only when i ∈ Γ, so it suffices to consider only i ∈ Γ. From Lemma 10, i ≤ li + k∗N . We also have li ≥ M(ν, k∗, ǫ, δ,N). Since h̃i ∈ Vi, Lemma 8 gives\nerr(h̃i) ≤ ν + 8 √ νσk∗(li, δi,k∗) + 35σk∗(li, δi,k∗)\n≤ ν + 8 √\nνσk∗(li, δli+k∗N,k∗) + 35σk∗(li, δli+k∗N,k∗)\n≤ ν + ǫ, as desired.\nFor the second claim, we first show that for i in Γ, the version space is contained in a ball of small radius (with respect to the disagreement pseudometric), thus bounding the size of its disagreement region. Lemma 8 shows that for i ∈ Γ, every hypothesis h ∈ Vi has error at most ν + 8 √\nνσk∗ (li, δi,k∗) + 35σk∗(li, δi,k∗). Thus, by the triangle inequality and Lemma 10,\nVi ⊆ BHki (h, 2ν + 16 √ νσk∗(li, δi,k∗) + 70σk∗(li, δi,k∗))\n⊆ BHki (h, 2ν + 16 √ νσk∗(li, δli+k∗N,k∗) + 70σk∗(li, δli+k∗N,k∗)).\nfor some h in Hki(S). This shows that for i ∈ Γ, i ≤ i∗, Prx∼DX [x ∈ Dis(Vi)]\n≤ θki(2ν + 2ǫ) · ( 2ν + 16 √ νσk∗(li, δli+k∗N,k∗) + 70σk∗(li, δli+k∗N,k∗) )\n≤ maxk≤k∗ θk(2ν + 2ǫ) · ( 2ν + 16 √ νσk∗(li, δli+k∗N,k∗) + 70σk∗(li, δli+k∗N,k∗) ) , (11)\nwhere the first inequality is from the definition of θki(·) and 8 √ νσk∗(li, δli+k∗N,k∗)+35σk∗(li, δli+k∗N,k∗) ≥ ǫ for i ≤ i∗, the second inequality is from ki ≤ k∗.\nFor i ≥ 1, let Zi be the indicator of whether Label is queried with xi in Step 12, i.e.,\nZi = 1{xi ∈ Dis(Vi−1)} .\nFor 0 ≤ k ≤ ki∗ , define\ni0k := min {i ≤ i∗ : ki ≥ k} , the first step when the hypothesis class reaches ≥ k, ik := max {i ≤ i∗ : ki ≤ k} , the last step when the hypothesis class is still ≤ k by the end of that step, i′k := max { i0k ≤ i ≤ ik : ki ≤ k, i ∈ Γ } , the last verified step for hypothesis class ≤ k (if exists).\nWe call class k skipped if there is no step i such that ki = k. If level k is skipped, then ik = ik−1 = i 0 k − 1, and i′k is undefined. Let\nWk :=\ni′ k\n∑\ni=i0 k +1\nZi\nbe the number of verified queried examples when working with hypothesis class Hk. Note that Wk/τ is the number of verified iterations when working with Hk. If level k is skipped, then Wk := 0.\nLet\nYk :=\nik+1 ∑\ni=i′ k +1\nZi\nbe the number of unverified queried examples when working with hypothesis class Hk. Note that Yk ≤ τ , and there is at most one unverified iteration when working with Hk. If level k is skipped,then Yk := 0.\nTherefore, the total cost when working with Hk is at most\nWk τ · 2τ + Yk + τ ≤ 2τ + 2Wk\nFurthermore, Claim 4 implies that there is no unverified iteration when working with Hk∗ . Hence the total cost when working with Hk∗ has a tighter upper bound, that is, 2Wk∗ .\nAs a shorthand, let m = M(ν, k∗, ǫ, δ,N). We now bound the total cost incurred up to time i∗ as\nk∗−1 ∑\nk=0\n(2τ + 2Wk) + 2Wk∗ = 2τk ∗ + 2\nki∗ ∑\nk=0\nWk\n= 2τk∗ + 2\nki∗ ∑\nk=0\ni′ k\n∑\ni=i0 k +1\nZi\n= 2τk∗ +O\n\n2 ∑\ni∈Γ:i≤i∗\nPr x∼DX\n[x ∈ Dis(Vi−1)]\n\n+O\n(\nk∗ ln 1\nδi∗\n)\n≤ 2\n\n  τk∗ +O\n\n\nm−1 ∑\nl=1\nmax k≤k∗ θk(2ν + 2ǫ)(ν + σk∗(l, δl+k∗N,k∗))\n\n\n\n \n≤ 2\n\n  τk∗ +O\n\nmax k≤k∗ θk(2ν + 2ǫ)\nm−1 ∑\nl=1\n(ν + σk∗(l, δl+k∗N,k∗)))\n\n\n\n \n≤ 2\n\n  τk∗ + Õ\n\nmax k≤k∗ θk(2ν + 2ǫ)dk∗\n(\n1 + ν2\nǫ2\n)\n\n\n\n \n≤ 2 (τk∗ + nǫ) = Cǫ, where the first equality is by algebra, the second equality is from the definition of Wk, and the third equality is from the definition of E. The first inequalty is from Lemma 8, using Equation (11) to bound Prx∼DX [x ∈ Dis(Vi−1)] and noting that {li : i ∈ Γ, i ≤ i∗} = [m].\nNow we provide the proof of our two key lemmas(Lemmas 8 and 10). Consider the last call of Prune-Version-Space in step i. Define γi as the value of γ in line 2 of\nError-Check:\nγi = min k′≥ki,h∈Hk′\n{\nerr(h, Li) + 2 √ err(h, Li)σk′ (l, δi,k′) + 3σk′ (l, δi,k′)\n}\n(12)\nMeanwhile, from line 1 of Prune-Version-Space, we have for all h ∈ Vi,\nerr(h, Li) ≤ min h′∈Vi\nerr(h′, Li) + 2 √ err(h′, Li)σki(li, δi,ki) + 3σki(li, δi,ki)\nwhere Vi denotes its final value.\nLemma 8. Assume that the following conditions hold:\n1. The dataset Li has favorable bias, i.e. it satisfies Equation (10).\n2. The version space Vi is such that Error-Check(Vi, Li, δi) returns false, i.e. it has a low empirical error on Li:\nmin h′∈Vi\nerr(h′, Li) ≤ γi + 2 √ γiσki(li, δi,ki) + 3σki(li, δi,ki). (13)\nThen, every h ∈ Vi is such that\nerr(h) ≤ ν + 8 √\nνσk∗(li, δi,k∗) + 35σk∗(li, δi,k∗). (14)\nwhere Vi and Li denote their final values, respectively. Specifically, Equation (14) holds for any h ∈ Vi such that i ∈ Γ or i+ 1 ∈ Γ.\nProof. Lemma 10 shows that ki ≤ k∗, which we will use below. Start with Equation (13):\nmin h′∈Vi\nerr(h′, Li) ≤ γi + 2 √ γiσki(li, δi,ki) + 3σki(li, δi,ki).\nSince ki ≤ k∗, σki(li, δi,ki) ≤ σk∗(li, δi,k∗). From the definition of γi (Equation (12)), taking k = k ∗ ≥ ki, h = h∗ ∈ Hk∗ ,\nγi ≤ err(h∗, Li) + 2 √ err(h∗, Li)σk∗ (li, δi,k∗) + 3σk∗(li, δi,k∗).\nPlugging the latter into the former and using σ as a shorthand for σk∗(li, δi,k∗), we have\nmin h′∈Vi\nerr(h′, Li) ≤ err(h∗, Li) + 2 √ err(h∗, Li)σ + 3σ + 2\n√\n(err(h∗, Li) + 2 √ err(h∗, Li)σ + 3σ)σ + 3σ\n≤ err(h∗, Li) + 2 √ err(h∗, Li)σ + 6σ + 2( √ err(h∗, Li)σ + √ 3σ) ≤ err(h∗, Li) + 4 √ err(h∗, Li)σ + 10σ .\nFix any h ∈ Vi. By construction,\nerr(h, Li) ≤ min h′∈Vi\nerr(h′, Li) + 2 √ err(h′, Li)σki (li, δi,ki) + 3σki(li, δi,ki).\nPlugging the former into the latter (recalling that σki (li, δi,ki) ≤ σ) gives\nerr(h, Li)− err(h∗, Li) ≤4 √ err(h∗, Li)σ + 10σ + 2( √ err(h∗, Li)σ + √ 10σ) + 3σ\n≤6 √ err(h∗, Li)σ + 20σ.\nCombined with Equation (10), we have,\nerr(h, LDi )− err(h∗, LDi ) ≤ 6 √ err(h∗, Li)σ + 20σ.\nSince err(h∗, Li) ≤ err(h∗, LDi ),\nerr(h, LDi )− err(h∗, LDi ) ≤ 6 √ err(h∗, LDi )σ + 20σ.\nFrom the definition of Ei, err(h∗, LDi ) ≤ ν + √ νσ + σ.\nerr(h) ≤ err(h, LDi ) + √ err(h, LDi )σ + σ.\nPlugging in and simplifying algebratically gives\nerr(h) ≤ ν + 8√νσ + 35σ.\nNow, if i ∈ Γ, the dataset Li has favorable bias from lemma 11; if i /∈ Γ and i + 1 ∈ Γ, the final value of Li equals some Lj for some j ∈ Γ, therefore also has favorable bias.\nMeanwhile, if i ∈ Γ, Algorithm 2 fails Error-Check(Vi, Li, δi) for k = ki. If i /∈ Γ and i+ 1 ∈ Γ, then i + 1 is the start of some verified iteration, i.e. i + 1 = i0k for some k. Hence the final value of Vi also fails Error-Check(Vi, Li, δi) for k = ki. In both cases, Equation (13) holds.\nTherefore, if i ∈ Γ or i+ 1 ∈ Γ, then Equation (14) holds for every h in Vi.\nLemma 9. For step i, suppose Li has favorable bias, i.e. Equation (10) holds. Then for any k and any h ∈ Hk,\nerr(h∗, Li)− err(h, Li) ≤ 2 √ err(h, Li)σk̄(li, δi,k̄) + 3σk̄(li, δi,k̄),\nwhere k̄ = max(k∗, k). Specifically:\n1. for any h ∈ Hk∗ ,\nerr(h∗, Li)− err(h, Li) ≤ 2 √ err(h, Li)σk∗ (li, δi,k∗) + 3σk∗(li, δi,k∗), (15)\n2. The empirical error of h∗ on Li can be bounded as follows:\nerr(h∗, Li) ≤ γi + 2 √ γiσk∗(li, δi,k∗) + 3σk∗(li, δi,k∗) (16)\nProof. Fix any k and h ∈ Hk. Since k̄ ≥ k, σk(li, δi,k) ≤ σk̄(li, δi,k̄). Similarly, σk∗(li, δi,k∗) ≤ σk̄(li, δi,k̄). Using the shorthand σ := σk̄(li, δi,k̄) and noting that h, h ∗ ∈ Hk̄,\nerr(h∗, Li)− err(h, Li) ≤ err(h∗, LDi )− err(h, LDi ) ≤ √\ndLD i\n(h∗, h) · σ + σ\n≤ √ (err(h∗, Li) + err(h, Li)) · σ + σ. ≤ √ err(h∗, Li)σ + √ err(h, Li)σ + σ.\nwhere the first inequality is from Equation (10), the second inequality is from the definition of Ei and the optimality of h∗, and the third inequality is from the triangle inequality. Letting A = err(h∗, Li), B = err(h, Li), and C = B + √ Bσ + σ, we can rewrite the above inequality as A ≤ C + √ Aσ. Solving the\nresulting quadratic equation in terms of A, we have A ≤ C + σ + √ Cσ, or\nA ≤ B + √ Bσ + 2σ + √ σ(B + √ Bσ + σ)\n≤ B + √ Bσ + 2σ + √ σ( √ B + √ σ) ≤ B + 2 √ Bσ + 3σ,\nor err(h∗, Li) ≤ err(h, Li) + 2 √ err(h, Li)σ + 3σ.\nSpecifically:\n1. Taking k = k∗, we get that Equation (15) holds for any h ∈ Hk∗ , establishing item 1.\n2. Define\n(k̂i, ĥi) := arg min k′≥k∗,h∈H\nk′\n{\nerr(h, Li) + 2 √ err(h, Li)σk′ (li, δi,k′) + 3σk′(li, δi,k′)\n}\n.\nIn this notation, γi = err(ĥi, Li) + 2 √\nerr(ĥi, Li)σk̂i (li, δi,k̂i) + 3σk̂i(li, δi,k̂i). We have\nγi + 2 √ γiσk∗(li, δi,k∗) + 3σk∗(li, δi,k∗) ≥ err(ĥi, Li) + 2 √ err(ĥi, Li)σk̄(li, δi,k̄) + 3σk̄(li, δi,k̄)\n≥ err(h∗, Li),\nwhere k̄ = max(k∗, k̂i) and the last inequality comes from applying Lemma 9 for h ′ = ĥi ∈ Hk̂i and k̄. This establishes Equation (16), proving item 2.\nLemma 10. At any step of AA-Larch, k ≤ k∗. Consequently, for every i, i ≤ li + k∗N .\nProof. We prove the lemma in two steps.\n1. Notice that there are two places where k is incremented in AA-Larch, line 6 and line 17. If k < k∗, neither line would increment it beyond k∗ as h∗ ∈ Hk∗ and h∗ is consistent with S. If k = k∗, Claim 4 below shows that k will stay at k∗. This proves the first part of the claim.\n2. An iteration becomes unverified only if k gets incremented, and Algorithm 2 maintains the invariant that ki ≤ k∗. Thus, the number of unverified iterations is at most k∗. In addition, each newly sampled set is of size at most N . So the number of unverified examples is at most k∗N .\nHence, i—the total number of examples processed up to step i—equals the sum of the number of verified examples li, plus the number of unverified examples, which is at most k\n∗N . This proves the second part of the claim.\nWe show a technical claim used in the proof of Lemma 10 which guarantees that, on event E, when k has reached k∗, it will remain k∗ from then on. Recall that ki is defined as the final value of k at the end of step i; i0k = min {i : ki ≥ k} is the step at the end of which the working hypothesis space reaches level ≥ k.\nClaim 4. If i0k∗ is finite, then the following hold for all i ≥ i0k∗ :\n(C1) Li has favorable bias.\n(C2) Step i terminates with ki = k ∗.\n(C3) h∗ ∈ Vi.\nAbove, Li and Vi denote their final values in AA-Larch.\nProof. By induction on i.\nBase Case. Let i = i0k∗ . Consider the execution of AA-Larch at the start of step i 0 k∗ (line 11). Since by definition of ik, the final value of k at step i 0 k∗ − 1 is < k∗, at step i0k∗ , line 5 or line 16 is triggered. Hence the dataset Li0 k∗\nequals some verified labeled dataset L stored by AA-Larch, i.e. Lj for some j ∈ Γ. Thus, applying Lemma 11, Claim C1 holds.\nWe focus on the moment in step i = i0k∗ when k increases to k ∗ in Upgrade-Version-Space(line 6\nor 17). Now consider the temporary Vi0 k∗ computed in the next line (Prune-Version-Space). Item 2 of Lemma 9 implies that the version space Vi0 k∗ is such that Error-Check(Vi0 k∗ , Li0 k∗ , δi0 k∗ ) returns false. Therefore the final value of k in step i0k∗ is exactly k ∗. Claim C2 follows.\nClaim C2 implies the temporary Vi0 k∗ is final. Item 1 of Lemma 9 implies that h∗ ∈ Vi0 k∗ , establishing\nClaim C3.\nInductive Case. Now consider i ≥ i0k∗ +1. The inductive hypothesis says that Claims C1–3 hold for step i− 1.\nClaim C1 follows from Claim C3 in step i−1. Indeed, the newly added xi either comes from the agreement region of Vi−1, in which case label yi agrees with h\n∗(xi), or is from the disagreement region of Vi−1, in which case the inferred label yi is queried from Label. Following the same reasoning as the proof of Lemma 11, Claim C1 is true.\nClaims C2 and C3 follows the same reasoning as the proof for the base case.\nLemma 11. If i is in Γ, then Li has favorable bias. That is, for any hypothesis h,\nerr(h, LDi )− err(h∗, LDi ) ≤ err(h, Li)− err(h∗, Li).\nProof. We can split LDi into two subsets, the subset where L D i agrees with Li and the subset Q D i = {(x, y) ∈ LDi : h ∗(x) 6= y} where LDi disagrees with Li. On the former subset, LDi is identical to Li, thus we just need to show that err(h,QDi )− err(h∗, QDi ) ≤ err(h,Qi)− err(h∗, Qi),\nwhere Qi = {(x, y) : (x,−y) ∈ QDi }. Since err(h∗, QDi ) = 1 and err(h∗, Qi) = 0, this reduces to showing that err(h,QDi ) ≤ 1 + err(h,Qi), which is easily seen to hold for any h as err(h,QDi ) ≤ 1 and err(h,Qi) ≥ 0."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "We investigate active learning with access to two distinct oracles: Label (which is standard) and Search (which is not). The Search oracle models the situation where a human searches a database to seed or counterexample an existing solution. Search is stronger than Label while being natural to implement in many situations. We show that an algorithm using both oracles can provide exponentially large problem-dependent improvements over Label alone.",
    "creator" : "LaTeX with hyperref package"
  }
}