{
  "name" : "1603.08367.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Sparse Activity and Sparse Connectivity in Supervised Learning",
    "authors" : [ "Markus Thom", "Aapo Hyvärinen" ],
    "emails" : [ "MARKUS.THOM@UNI-ULM.DE", "GUENTHER.PALM@UNI-ULM.DE" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Sparseness is a concept of efficiency in neural networks, and exists in two variants in that context (Laughlin and Sejnowski, 2003). The sparse activity property means that only a small fraction of neurons is active at any time. The sparse connectivity property means that each neuron is connected to only a limited number of other neurons. Both properties have been observed in mammalian brains (Hubel and Wiesel, 1959; Olshausen and Field, 2004; Mason et al., 1991; Markram et al., 1997) and have inspired a variety of machine learning algorithms. A notable result was achieved through the sparse coding model of Olshausen and Field (1996). Given small patches from images of natural scenes, the model is able to produce Gabor-like filters, resembling properties of simple cells found in mammalian primary visual cortex (Hubel and Wiesel, 1959; Vinje and Gallant, 2000). Another example is the optimal brain damage method of LeCun et al. (1990), which can be used to prune synaptic connections in a neural network, making connectivity sparse. Although only a small fraction of possible connections remains after pruning, this is sufficient to achieve equivalent classification results. Since then, numerous approaches on how to measure sparseness have been proposed, see Hurley and Rickard (2009) for an overview, and how to achieve sparse solutions of classical machine learning problems.\nc©2013 Markus Thom and Günther Palm.\nar X\niv :1\n60 3.\n08 36\n7v 1\n[ cs\n.L G\n] 2\nThe L0 pseudo-norm is a natural sparseness measure. Its computation consists of counting the number of non-vanishing entries in a vector. Using it rather than other sparseness measures has been shown to induce biologically more plausible properties (Rehn and Sommer, 2007). However, finding of optimal solutions subject to the L0 pseudo-norm turns out to be NP-hard (Natarajan, 1995; Weston et al., 2003). Analytical properties of this counting measure are very poor, for it is non-continuous, rendering the localization of approximate solutions difficult. The Manhattan norm of a vector is a convex relaxation of the L0 pseudo-norm (Donoho, 2006), and has been employed in a vast range of applications. This sparseness measure has the significant disadvantage of not being scale-invariant, so that an intuitive notion of sparseness cannot be derived from it."
    }, {
      "heading" : "1.1 Hoyer’s Normalized Sparseness Measure",
      "text" : "A normalized sparseness measure σ based on the ratio of the L1 or Manhattan norm and the L2 or Euclidean norm of a vector has been proposed by Hoyer (2004),\nσ : Rn \\{0}→ [0, 1] , x 7→ √\nn− ‖x‖1/‖x‖2√ n−1 ,\nwhere higher values indicate more sparse vectors. σ is well-defined because ‖x‖2≤‖x‖1≤ √\nn‖x‖2 holds for all x ∈ Rn (Laub, 2004). As σ(αx) = σ(x) for all α , 0 and all x ∈ Rn \\ {0}, σ is also scale-invariant. As composition of differentiable functions, σ is differentiable on its entire domain.\nThis sparseness measure fulfills all criteria of Hurley and Rickard (2009) except for Dalton’s fourth law, which states that the sparseness of a vector should be identical to the sparseness of the vector resulting from multiple concatenation of the original vector. This property, however, is not crucial for a proper sparseness measure. For example, sparseness of connectivity in a biological brain increases quickly with its volume, so that connectivity in a human brain is about 170 times more sparse than in a rat brain (Karbowski, 2003). It follows that σ features all desirable properties of a proper sparseness measure.\nA sparseness-enforcing projection operator, suitable for projected gradient descent algorithms, was proposed by Hoyer (2004) for optimization with respect to σ. For a pre-defined target degree of sparseness σ∗ ∈ (0, 1), the operator finds the closest vector of a given scale that has sparseness σ∗ given an arbitrary vector. This can be expressed formally as Euclidean projection onto parameterizations of the sets\nS(λ1,λ2) := { s ∈Rn | ‖s‖1 = λ1 and ‖s‖2 = λ2 } and S (λ1,λ2) ≥0 := S (λ1,λ2)∩Rn≥0.\nThe first set is for achieving unrestricted projections, whereas the latter set is useful in situations where only non-negative solutions are feasible, for example in non-negative matrix factorization problems. The constants λ1,λ2 > 0 are target norms and can be chosen such that all points in these sets achieve a sparseness of σ∗. For example, if λ2 was set to unity for yielding normalized projections, then λ1 can be easily derived from the definition of σ.\nHoyer’s original algorithm for computation of such a projection is an alternating projection onto a hyperplane representing the L1 norm constraint, a hypersphere representing the L2 norm constraint, and the non-negative orthant. A slightly modified version of this algorithm has been proved to be correct by Theis et al. (2005) in the special case when exactly one negative entry emerges that is zeroed out in the orthant projection. However, there is still no mathematically satisfactory proof for the general case."
    }, {
      "heading" : "1.2 Contributions of this Paper",
      "text" : "This paper improves upon previous work in the following ways. Section 2 proposes a simple algorithm for carrying out sparseness-enforcing projections with respect to Hoyer’s sparseness measure. Further, an improved algorithm is proposed and compared with Hoyer’s original algorithm. Because the projection itself is differentiable, it is the ideal tool for achieving sparseness in gradient-based learning. This is exploited in Section 3, where the sparseness projection is used to obtain a classifier that features both sparse activity and sparse connectivity in a natural way. The benefit of these two key properties is demonstrated on a real-world classification problem, proving that sparseness acts as regularizer and improves classification results. The final sections give an overview of related concepts and conclude this paper.\nOn the theoretical side, a first rigorous and mathematically satisfactory analysis of the properties of the sparseness-enforcing projection is provided. This is lengthy and technical and therefore deferred into several appendixes. Appendix A fixes the notation and gives an introduction to general projections. In Appendix B, certain symmetries of subsets of the Euclidean space and their effect on projections onto such sets is studied. The problem of finding projections onto sets where Hoyer’s sparseness measure attains a constant value is addressed in Appendix C. Ultimately, the algorithms proposed in Section 2 are proved to be correct. Appendix D investigates analytical properties of the sparseness projection and concludes with an efficient algorithm that computes its gradient. The gradients for optimization of the parameters of the architecture proposed in Section 3 are collected in the final Appendix E."
    }, {
      "heading" : "2. Algorithms for the Sparseness-Enforcing Projection Operator",
      "text" : "The projection onto a set is a fundamental concept, for example see Deutsch (2001):\nDefinition 1 Let x ∈Rn and ∅ ,M ⊆Rn. Then every point in\nprojM(x) := {y ∈M | ‖y− x‖2 ≤ ‖z− x‖2 for all z ∈M }\nis called Euclidean projection of x onto M. When there is exactly one point y in projM(x), then y = projM(x) is used as an abbreviation.\nBecause Rn is finite-dimensional, projM(x) is nonempty for all x ∈ Rn if and only if M is closed, and projM(x) is a singleton for all x ∈Rn if and only if M is closed and convex (Deutsch, 2001). In the literature, the elements from projM(x) are also called best approximations to x from M.\nProjections onto sets that fulfill certain symmetries are of special interest in this paper and are formalized and discussed in Appendix B in greater detail. It is notable that projections onto a permutation-invariant set M, that is a set where membership is stable upon coordinate permutation, are order-preserving. This is proved in Lemma 9(a). As a consequence, when a vector is sorted in ascending or descending order, then its projection onto M is sorted accordingly. If M is reflection-invariant, that is when the signs of arbitrary coordinates can be swapped without violating membership in M, then the projection onto M is orthant-preserving, as shown in Lemma 9(b). This means that a point and its projection onto M are located in the same orthant. By exploiting this property, projections onto M can be yielded by recording and discarding the signs of the coordinates of the argument, projecting onto M∩Rn≥0, and finally restoring the signs of the coordinates of the result using the signs of the argument. This is formalized in Lemma 11.\nAs an example for these concepts, consider the set Z := {x ∈Rn | ‖x‖0 = κ} of all vectors with exactly κ ∈N non-vanishing entries. Z is clearly both permutation-invariant and reflectioninvariant. Therefore, the projection with respect to an L0 pseudo-norm constraint must be both order-preserving and orthant-preserving. In fact, the projection onto Z consists simply of zeroing out all entries but the κ that are greatest in absolute value (Blumensath and Davies, 2009). This trivially fulfills the aforementioned properties of order-preservation and orthant-preservation.\nPermutation-invariance and reflection-invariance are closed under intersection and union operations. Therefore, the unrestricted target set S(λ1,λ2) for the σ projection is permutation-invariant and reflection-invariant. It is hence enough to handle projections onto S(λ1,λ2)≥0 in the first place, as projections onto the unrestricted target set can easily be recovered.\nIn the remainder of this section, let n ∈N be the problem dimensionality and let λ1,λ2 > 0 be the fixed target norms, which must fulfill λ2 ≤ λ1 ≤ √ nλ2 to avoid the existence of only trivial solutions. In the applications of the sparseness projection in this paper, λ2 is always set to unity to achieve normalized projections, and λ1 is adjusted as explained in Section 1.1 to achieve the target degree of sparseness σ∗. The related problem of finding the best approximation to a point x regardless of the concrete scaling, that is computing projections onto { s ∈Rn \\{0} | σ(s) = σ∗ }, can be solved by projecting x onto S(λ1,λ2) and rescaling the result p such as to minimize ‖x−αp‖2 under variation of α ∈ R, which yields α = 〈x, p〉/‖p‖22. This method is justified theoretically by Remark 5."
    }, {
      "heading" : "2.1 Alternating Projections",
      "text" : "First note that the target set can be written as an intersection of simpler sets. Let e1, . . . ,en ∈Rn be the canonical basis of the n-dimensional Euclidean space Rn. Further, let e := ∑ni=1 ei ∈ Rn be the vector where all entries are identical to unity. Then H := {a ∈Rn | eT a = λ1 } denotes the target hyperplane where the coordinates of all points sum up to λ1. In the non-negative orthant Rn≥0, this is equivalent to the L1 norm constraint. Further, define K := {q ∈Rn | ‖q‖2 = λ2 } as the target hypersphere of all points satisfying the L2 norm constraint. This yields the following factorization:\nS(λ1,λ2)≥0 =R n ≥0∩H ∩K =: D.\nFor computation of projections onto an intersection of a finite number of closed and convex sets, it is enough to perform alternating projections onto the members of the intersection (Deutsch, 2001). As K is clearly non-convex, this general approach has to be altered to work in this specific setup.\nFirst, consider L := H ∩K, which denotes the intersection of the L1 norm target hyperplane and the L2 norm target hypersphere. L essentially possesses the structure of a hypercircle, that is, all points in L lie also in H and there is a central point m ∈ H and a real number ρ ≥ 0 such that all points in L have squared distance ρ from m. It will be shown in Appendix C that m = λ1/n · e ∈Rn and ρ = λ22− λ 2 1/n. The intersection of the non-negative orthant with the L1 norm hyperplane, C := Rn≥0∩H, is a scaled canonical simplex. Its barycenter coincides with the barycenter m of L. Finally, for an index set I ⊆{1, . . . ,n} let LI := {a ∈ L | ai = 0 for all i < I } denote the subset of points from L, where all coordinates with index not in I vanish. Its barycenter is given by mI = λ1/d ·∑i∈I ei ∈Rn. With these preparations, a simple algorithm can be proposed; it computes the sparseness-enforcing projection with respect to a constraint induced by Hoyer’s sparseness measure σ.\nTheorem 2 For every x ∈Rn, Algorithm 1 computes an element from projD(x). If r ,m after line 1 and r , mI after line 4 in all iterations, then projD(x) is a singleton.\nAlgorithm 1: Proposed algorithm for computing the sparseness-enforcing projection operator for Hoyer’s sparseness measure σ.\nInput: x ∈Rn and λ1,λ2 ∈R>0 with λ2 ≤ λ1 ≤ √\nnλ2. Output: s ∈ projD(x) where D = S (λ1,λ2) ≥0 .\n// Project onto target hyperplane H and target hypercircle L. 1 r := projH(x); 2 s ∈ projL(r); // Perform alternating projections until feasible solution is found. 3 while s <Rn≥0 do // Project onto scaled canonical simplex C. 4 r := projC(s); // Project onto L keeping already vanished coordinates at zero. 5 s ∈ projLI (r) where I := { i ∈ {1, . . . ,n} | ri , 0}; 6 end\nAs already pointed out, the idea of Algorithm 1 is that projections onto D can be computed by alternating projections onto the geometric structures just defined. The rigorous proof of correctness from Appendix C proceeds by showing that the set of solutions is not tampered by projection onto the intermediate structures H, C, L and LI . Because of the non-convexity of L and LI , the relation between these sets and the simplex C is non-trivial and needs long arguments to be described further, see especially Lemma 26 and Corollary 27.\nThe projection onto the hyperplane H is straightforward and discussed in Section C.1.1. As L is essentially a hypersphere embedded in a subspace H of Rn, projections of points from H onto L are achieved by shifting and scaling, see Section C.1.2. The alternating projection onto H and L in the beginning of Algorithm 1 make the result of the projection onto D invariant to positive scaling and arbitrary shifting of the argument, as shown in Corollary 19. This is especially useful in practice, alleviating the need for certain pre-processing methods. The formula for projections onto L can be generalized for projections onto LI for an index set I ⊆ {1, . . . ,n}, by keeping already vanished coordinates at zero, see Section C.3.\nProjections onto the simplex C are more involved and discussed at length in Section C.2. The most relevant result is that if x∈Rn \\C, then there exists a separator t̂ ∈R such that p := projC(x) = max(x− t̂ · e, 0), where the maximum is taken element-wise (Chen and Ye, 2011). In the cases considered in this paper it is always t̂ ≥ 0 as shown in Lemma 28. This implies that all entries in x that are less than t̂ do not survive the projection, and hence the L0 pseudo-norm of x is strictly greater than that of p. The simplex projection therefore enhances sparseness.\nThe separator t̂ and the number of nonzero entries in the projection onto C can be computed with Algorithm 2, which is an adapted version of the algorithm of Chen and Ye (2011). In line 1, Sn denotes the symmetric group and Pτ denotes the permutation matrix associated with a permutation τ ∈ Sn. The algorithm works by sorting its argument x and then determining t̂ as the mean value of the largest entries of x minus the target L1 norm λ1. The number of relevant entries for computation of t̂ is equal to the L0 pseudo-norm of the projection and is found by trying all feasible values, starting with the largest ones. The computational complexity of Algorithm 2 is dominated by sorting the input vector and is thus quasilinear.\nAlgorithm 2: Computation of information for performing projections onto C, which is a scaled canonical simplex. This is an adapted version of the algorithm of Chen and Ye (2011).\nInput: x ∈Rn \\C and λ1 ∈R>0. Output: (t̂, d) ∈R×N such that projC(x) = max(x− t̂ · e, 0) and ‖projC(x)‖0 = d. // Sort the input vector in descending order.\n1 Let τ ∈ Sn such that xτ(1) ≥ ·· · ≥ xτ(n) and y := Pτx ∈Rn;\n// Find the only feasible separator t̂. 2 s := 0; 3 for i := 1 to n−1 do 4 s := s+ yi; t := s−λ1i ; 5 if t ≥ yi+1 then return (t, i); 6 end 7 s := s+ yn; t := s−λ1n ; return (t, n);\nAlgorithm 3: Explicit and optimized variant of Algorithm 1. Input: x ∈Rn and λ1,λ2 ∈R>0 with λ2 ≤ λ1 ≤ √ nλ2.\nOutput: s ∈ projD(x) where D = S (λ1,λ2) ≥0 .\n1 procedure proj_L(y ∈Rd) 2 ρ := λ22− λ 2 1/d; // Compute squared radius of LI (Lemma 15). 3 ϕ := ∑di=1 y2i − λ 2 1/d; // ϕ := ‖y−mI‖22 (Remark 14). 4 if ϕ = 0 then 5 (y1, . . . , yd−1) T := λ1/d + √ρ/ √\nd(d−1); // y equals the barycenter of LI, 6 yd := λ1/d− √ ρ(d−1)/ √ d; // pick a sorted projection (Remark 18).\n7 else y := λ1/d · e+ √\nρ/ϕ · (y− λ1/d · e); // Pick unique projection (Lemma 17). 8 end\n// Beginning of main body. 9 Let τ ∈ Sn such that xτ(1) ≥ ·· · ≥ xτ(n) and y := Pτx ∈Rn; // Sort the input vector. 10 y := y+ 1/n · (λ1−∑ni=1 yi)e; // Project onto H (Lemma 13). 11 proj_L(y1, . . . ,yn); // Project in-place onto L.\n// Perform alternating projections until feasible solution is found. 12 d := n; // Store current number of relevant entries of y. 13 while (y1, . . . , yd)T <Rd≥0 do 14 (t̂, d) := proj_C(y1, . . . ,yd); // This is carried out by Algorithm 2. 15 (y1, . . . , yd) T := (y1, . . . , yd) T − t̂; // Project onto C (Proposition 24). 16 proj_L(y1, . . . ,yd); // Project onto LI where I = {1, . . . ,d} (Lemma 30). 17 end\n// Undo sorting permutation and set remaining entries to zero. 18 s ∈ {0}n; for i := 1 to d do sτ(i) := yi;"
    }, {
      "heading" : "2.2 Optimized Variant",
      "text" : "Because of the permutation-invariance of the sets involved in the projections, it is enough to sort the vector that is to be projected onto D once. This guarantees that the working vector that emerges from subsequent projections is sorted also. No additional sorting has then to be carried out when using Algorithm 2 for projections onto C. This additionally has the side effect that the non-vanishing entries of the working vector are always concentrated in its first entries. Hence all relevant information can always be stored in a small unit-stride array, to which access is more efficient than to a large sparse array. Further, the index set I of non-vanishing entries in the working vector is always of the form I = {1, . . . ,d}, where d is the number of nonzero entries.\nAlgorithm 3 is a variant of Algorithm 1 where these optimizations were applied, and where the explicit formulas for the intermediate projections were used. The following result, which is proved in Appendix C, states that both algorithms always compute the same result:\nTheorem 3 Algorithm 1 is equivalent to Algorithm 3.\nProjections onto C increase the amount of vanishing entries in the working vector, which is of finite dimension n. Hence, at most n alternating projections are carried out, and the algorithm terminates in finite time. Further, the complexity of each iteration is at most linear in the L0 pseudo-norm of the working vector. The theoretic overall computational complexity is thus at most quadratic in problem dimensionality n."
    }, {
      "heading" : "2.3 Comparison with Hoyer’s Original Algorithm",
      "text" : "The original algorithm for the sparseness-enforcing projection operator proposed by Hoyer (2004) is hard to understand, and correctness has been proved by Theis et al. (2005) in a special case only. A simple alternative has been proposed with Algorithm 1 in this paper. Based on the symmetries induced by Hoyer’s sparseness measure σ and by exploiting the projection onto a simplex, an improved method was given in Algorithm 3.\nThe improved algorithm proposed in this paper always requires at most the same number of iterations of alternating projections as the original algorithm. The original algorithm uses a projection onto the non-negative orthant Rn≥0 to achieve vanishing coordinates in the working vector. This operation can be written as projRn≥0(x) = max(x, 0). In the improved algorithm, a simplex projection is used for this purpose, expressed formally as projC(x) = max(x− t̂ · e, 0) with t̂ ∈ R chosen accordingly. Due to the theoretical results on simplex geometry from Section C.2 and their application in Lemma 28 in Section C.3, the number t̂ is always non-negative. Therefore, at least the same amount of entries is set to zero in the simplex projection compared to the projection onto the non-negative orthant, see also Corollary 29. Hence with induction for the number of non-vanishing entries in the working vector, the number of iterations the proposed algorithm needs to terminate is bounded by the number of iterations the original method needs to terminate given the same input.\nThe experimental determination of an estimate of the number of iterations required was carried out as follows. Random vectors with sparseness 0.15 were sampled and their sparse projections were computed using the respective algorithms, to gain the best normalized approximations with a target sparseness degree of σ∗ := 0.90. For both algorithms the very same vectors were used as input. During the run-time of the algorithms, the number of iterations that were necessary to compute the result were counted. Additionally, the number of nonzero entries in the working vector was\nrecorded in each iteration. This was done for different dimensionalities, and for each dimensionality 1000 vectors were sampled.\nFigure 1 shows statistics on the number of iterations the algorithms needed to terminate. As was already observed by Hoyer (2004), the number of required iterations grows very slowly with problem dimensionality. For n = 106, only between 12 and 14 iterations were needed with the original algorithm to compute the result. With Algorithm 3, this can be improved to requiring 9 to 10 iterations, which amounts to roughly 30% less iterations. Due to the small slope in the number of required iterations, it can be conjectured that this quantity is at most logarithmic in problem dimensionality n. If this applies, the complexity of Algorithm 3 is at most quasilinear. Because the input vector is sorted in the beginning, it is also not possible to fall below this complexity class.\nThe progress of working dimensionality reduction for problem dimensionality n = 1000 is depicted in Figure 2, averaged over the 1000 input vectors from the experiment. After the first iteration, that is after projecting onto H and L, the working dimensionality still matches the input dimensionality. Starting with the second iteration, dimensions are discarded by projecting onto Rn≥0 in the original algorithm and onto C in the improved variant, which yields vanishing entries in the working vectors. With the original algorithm, in the mean 54% of all entries are nonzero after the second iteration, while with the improved algorithm only 27% of the original 1000 dimensions remain in the mean. This trend continues in subsequent iterations such that the final working dimensionality is reached more quickly with the algorithm proposed in this paper. Although using Algorithm 2 to perform the simplex projection is more expensive than just setting negative entries to zero in the orthant projection, the overhead quickly amortizes because of the boost in dimensionality reduction.\nFor determination of the relative speedup incorporated with both the simplex projection and the access to unit-stride arrays due to the permutation-invariance, both algorithms were implemented as C++ programs using an optimized implementation of the BLAS library for carrying out the vector operations. The employed processor was an Intel Core i7-990X. For a range of different dimensionalities, a set of vectors with varying initial sparseness were sampled. The number of the vectors for every pair of dimensionality and initial sparseness was chosen such that the processing time of the algorithms was several orders of magnitudes greater than the latency time of the operation system. Then the absolute time needed for the algorithms to compute the projections with a target sparseness of 0.90 were measured, and their ratio was taken to compute the relative speedup. The results of this experiment are depicted in Figure 3. It is evident that the maximum speedup is achieved for vectors with a dimensionality between 29 and 215, and an initial sparseness greater than 0.40. For low initial sparseness, as is achieved by randomly sampled vectors, a speedup of about 2.5 can be achieved for a broad spectrum of dimensionality between 24 and 213.\nThe improvements to the original algorithm are thus not only theoretical, but also noticeable in practice. The speedup is especially useful when the projection is used as a neuronal transfer function in a classifier as proposed in Section 3, because then the computational complexity of the prediction of class membership of unknown samples can be reduced."
    }, {
      "heading" : "2.4 Function Definition and Differentiability",
      "text" : "It is clear from Theorem 2 that the projection onto D is unique almost everywhere. Therefore the set R := { x ∈Rn | |projD(x)| , 1} is a null set. However, R,∅ as for example the projection is not unique for vectors where all entries are identical. In other words, for x := ξe ∈Rn for some ξ ∈R follows projH(x) = m and projL(m) = L. If n = 2 a possible solution is given by (α,β)\nT ∈ projD(x) with α and β given as stated in Remark 18, as in this case α and β are positive. Additionally, another solution is given by (β,α)T ∈ projD(x) which is unequal to the other solution because of α , β. A similar argument can be used to show non-uniqueness for all n ≥ 2. As R is merely a small set, non-uniqueness is not an issue in practical applications.\nThe sparseness-enforcing projection operator that is restricted to non-negative solutions can thus be cast almost everywhere as a function\nπ≥0 : Rn \\R→ D, x 7→ projD(x).\nExploiting reflection-invariance implies that the unrestricted variant of the projection\nπ : Rn \\R→ S(λ1,λ2), x 7→ s◦π≥0 (|x|) ,\nis well-defined, where s ∈ {±1}n is given as described in Lemma 11. Note that computation of π≥0 is a crucial prerequisite to computation of the unrestricted variant π. It will be used exclusively in Section 3 because non-negativity is not necessary in the application proposed there.\nIf π or π≥0 is employed in an objective function that is to be optimized, the information whether these functions are differentiable is crucial for selecting an optimization strategy. As an example, consider once more projections onto Z := {x ∈Rn | ‖x‖0 = κ} where κ ∈N is a constant. It was already mentioned in Section 2 that the projection onto Z consists simply of zeroing out the elements that are smallest in absolute value. Let x ∈ Rn be a point and let τ ∈ Sn be a permutation such that\n∣∣xτ(1)∣∣ ≥ ·· · ≥ ∣∣xτ(n)∣∣. Clearly, if ∣∣xτ(κ)∣∣ , ∣∣xτ(κ+1)∣∣ then projZ(x) = y where yi = xi for i ∈ {τ(1), . . . ,τ(κ)} and yi = 0 for i ∈ {τ(κ+ 1), . . . ,τ(n)}. Moreover, when ∣∣xτ(κ)∣∣ , ∣∣xτ(κ+1)∣∣ then\nthere exists a neighborhood U of x such that projZ(s) = ∑κi=1 sτ(i)eτ(i) for all s ∈U . With this closedform expression, s 7→ projZ(s) is differentiable in x with gradient ∂projZ(x)/∂x = diag ( ∑κi=1 eτ(i) ) , that is the identity matrix where the entries on the diagonal belonging to small absolute values of x have been zeroed out. If the requirement on x is not fulfilled, then a small distortion of x is sufficient to find a point in which the projection onto Z is differentiable.\nIn contrast to the L0 projection, differentiability of π and π≥0 is non-trivial. A full-length discussion is given in Appendix D, and concludes that both π and π≥0 are differentiable almost everywhere. It is more efficient when only the product of the gradient with an arbitrary vector needs to be computed, see Corollary 36. Such an expression emerges in a natural way by application of the chain rule to an objective function where the sparseness-enforcing projection is used. In practice this weaker form is thus mostly no restriction and preferable for efficiency reasons over the more general complete gradient as given in Theorem 35.\nThe derivative of π≥0 is obtained by exploiting the structure of Algorithm 1. Because the projection onto D is essentially a composition of projections onto H, C, L and LI , the overall gradient can be computed using the chain rule. The gradients of the intermediate projections are simple expressions and can be combined to yield one matrix for each iteration of alternating projections. Since these iteration gradients are basically sums of dyadic products, their product with an arbitrary vector can be computed by primitive vector operations. With matrix product associativity, this process can be repeated to efficiently compute the product of the gradient of π≥0 with an arbitrary vector. For this, it is sufficient to record some intermediate quantities during execution of Algorithm 3, which does not add any major overhead to the algorithm itself. The gradient of the unrestricted variant π can be deduced in a straightforward way from the gradient of π≥0 because of their close relationship."
    }, {
      "heading" : "3. Sparse Activity and Sparse Connectivity in Supervised Learning",
      "text" : "The sparseness-enforcing projection operator can be cast almost everywhere as vector-valued function π, which is differentiable almost everywhere, see Section 2.4. This section proposes a hybrid of an auto-encoder network and a two-layer neural network, where the sparseness projection is employed as a neuronal transfer function. The proposed model is called supervised online autoencoder (SOAE) and is intended for classification by means of a neural network that features sparse activity and sparse connectivity. Because of the analytical properties of the sparseness-enforcing projection operator, the model can be optimized end-to-end using gradient-based methods."
    }, {
      "heading" : "3.1 Architecture",
      "text" : "Figure 4 depicts the data flow in the proposed model. There is one module for reconstruction capabilities and one module for classification capabilities. The reconstruction module, depicted on the left of Figure 4, operates by converting an input sample x ∈ Rd into an internal representation h ∈Rn, and then computing an approximation x̃ ∈Rd to the original input sample. In doing so, the product u ∈ Rn of the input sample with a matrix of bases W ∈ Rd×n is computed, and a transfer function f : Rn→Rn is applied. For sparse activity, f can be chosen to be the sparseness-enforcing projection operator π or the projection with respect to the L0 pseudo-norm. This guarantees that the internal representation is sparsely populated and close to u. The reconstruction is achieved like in a linear generative model, by multiplication of the matrix of bases with the internal representation. Hence the same matrix W is used for both encoding and decoding, rendering the reconstruction module symmetric, or in other words with tied weights. This approach is similar to principal com-\nponent analysis (Hotelling, 1933), restricted Boltzmann machines for deep auto-encoder networks (Hinton et al., 2006) and to sparse encoding symmetric machine (Ranzato et al., 2008).\nBy enforcing W to be sparsely populated, the sparse connectivity property holds as well. More formally, the aim is that σ(Wei) = σW holds for all i ∈ {1, . . . ,n}, where σW ∈ (0, 1) is the target degree of connectivity sparseness and Wei is the i-th column of W . This condition was adopted from non-negative matrix factorization with sparseness constraints (Hoyer, 2004). In the context of neural networks, the synaptic weights of individual neurons are stored in the columns of the weight matrix W . The interpretation of this formal sparseness constraint is then that each neuron is only allowed to be sparsely connected with the input layer.\nThe classification module is shown on the right-hand side of Figure 4. It computes a classification decision y ∈ Rc by feeding h through a one-layer neural network. The network output y is yielded through computation of the product with a matrix of weights Wout ∈ Rn×c, addition of a threshold vector θout ∈ Rc and application of a transfer function g : Rc → Rc. This module shares the inference of the internal representation with the reconstruction module, which can also be considered a one-layer neural network. Therefore the entire processing path from x to y forms a two-layer neural network (Rumelhart et al., 1986), where W stores the synaptic weights of the hidden layer, and Wout and θout are the parameters of the output layer.\nThe input sample x shall be approximated by x̃, and the target vector for classification t ∈ Rc shall be approximated by y. This is achieved by optimization of the parameters of SOAE, that is the quantities W , Wout and θout. The goodness of the approximation x ≈ x̃ is estimated using a differentiable similarity measure sR : Rd ×Rd → R, and the approximation y ≈ t is assessed by\nanother similarity measure sC : Rc×Rc→R. For minimizing the deviation in both approximations, the objective function\nESOAE (W, Wout, θout) := (1−α) · sR (x̃, x)+α · sC (y, t)\nshall be optimized, where α ∈ [0, 1] controls the trade-off between reconstruction and classification capabilities. To incorporate sparse connectivity, feasible solutions are restricted to fulfill σ(Wei) = σW for all i∈ {1, . . . ,n}. If α = 0, then SOAE is identical to a symmetric auto-encoder network with sparse activity and sparse connectivity. In the case of α= 1, SOAE forms a two-layer neural network for classification with a sparsely connected hidden layer and where the activity in the hidden layer is sparse. The parameter α can also be used to blend continuously between these two extremes. Note that x̃ only depends on W but not on Wout or θout, but y depends on W , Wout and θout. Hence Wout and θout are only relevant when α > 0, whereas W is essential for all choices of α.\nAn appropriate choice for sR is the correlation coefficient (see for example Rodgers and Nicewander, 1988), because it is normed to values in the interval [−1, 1], invariant to affine-linear transformations, and differentiable. If f is set to π, then a model that is invariant to the concrete scaling and shifting of the occurring quantities can be yielded. This follows because π is also invariant to such transformations, see Corollary 19. The similarity measure for classification capabilities sC is chosen to be the cross-entropy error function (Bishop, 1995), which was shown empirically by Simard et al. (2003) to induce better classification capabilities than the mean squared error function. The softmax transfer function (Bishop, 1995) is used as transfer function g of the output layer. It provides a natural pairing together with the cross-entropy error function (Dunne and Campbell, 1997) and supports multi-class classification."
    }, {
      "heading" : "3.2 Learning Algorithm",
      "text" : "The proposed optimization algorithm for minimization of the objective function ESOAE is projected gradient descent (Bertsekas, 1999). Here, each update to the degrees of freedom is followed by application of the sparseness projection to the columns of W to enforce sparse connectivity. There are theoretical results on the convergence of projected gradient methods when projections are carried out onto convex sets (Bertsekas, 1999), but here the target set for projection is non-convex. Nevertheless, the experiments described below show that projected gradient descent is an adequate heuristic in the situation of the SOAE framework to tune the network parameters. For completeness, the gradients of ESOAE with respect to the network parameters are given in Appendix E. Update steps are carried out after every presentation of a pair of an input sample and associated target vector. This online learning procedure results in faster learning and improves generalization capabilities over batch learning (Wilson and Martinez, 2003; Bottou and LeCun, 2004).\nA learning set with samples from Rd and associated target vectors from {0,1}c as one-of-ccodes is input to the algorithm. The dimensionality of the internal representation n and the target degree of sparseness with respect to the connectivity σW ∈ (0, 1) are parameters of the algorithm. Sparseness of connectivity increases for larger σW , as Hoyer’s sparseness measure is employed in the definition of the set of feasible solutions.\nTwo possible choices for the hidden layer’s transfer function f to achieve sparse activity were discussed in this paper. One possibility is to carry out the projection with respect to the L0 pseudonorm. The more sophisticated method is to use the unrestricted sparseness-enforcing projection operator π with respect to Hoyer’s sparseness measure σ, which can be carried out by Algorithm 3.\nIn both cases, a target degree for sparse activity is a parameter of the learning algorithm. In case of the L0 projection, this sparseness degree is denoted by κ ∈ {1, . . . ,n}, and sparseness increases with smaller values of it. For the σ projection, σH ∈ (0, 1) is used, where larger values indicate more sparse activity.\nInitialization of the columns of W is achieved by selecting a random subset of the learning set, similar to the initialization of radial basis function networks (Bishop, 1995). This ensures significant activity of the hidden layer from the very start, resulting in strong gradients and therefore reducing training time. The parameters of the output layer, that is Wout and θout, are initialized by sampling from a zero-mean Gaussian distribution with a standard deviation of 1/100.\nIn every epoch, a randomly selected subset of samples and associated target vectors from the learning set is used for stochastic gradient descent to update W , Wout and θout. The results from Appendix E can be used to efficiently compute the gradient of the objective function. There, the gradient for the transfer function f only emerges as a product with a vector. The gradient for the L0 projection is trivial and was given as an example in Section 2.4. If f is Hoyer’s sparseness-enforcing projection operator, it is possible to exploit that only the product of the gradient with a vector is needed. In this case, it is more efficient to compute the result of the multiplication implicitly using Corollary 36 and thus avoid the computation of the entire gradient of π.\nAfter every epoch, a sparseness projection is applied to the columns of W . This guarantees that σ(Wei) = σW holds for all i ∈ {1, . . . ,n}, and therefore the sparse connectivity property is fulfilled. The trade-off variable α which controls the weight of the reconstruction and the classification term is adjusted according to α(ν) := 1− exp(−ν/100), where ν ∈N denotes the number of the current epoch. Thus α starts at zero, increases slowly and asymptotically reaches one. The emphasis at the beginning of the optimization is thus on reconstruction capabilities. Subsequently, classification capabilities are incorporated slowly, and in the final phase of training classification capabilities exclusively are optimized. This continuous variant of unsupervised pre-training (Hinton et al., 2006) leads to parameters in the vicinity of a good minimizer for classification capabilities before classification is preferred over reconstruction through the trade-off parameter α. Compared to the choice α ≡ 1 this strategy helps to stabilize the trajectory in parameter space and makes the objective function values settle down more quickly, such that the termination criterion is satisfied earlier."
    }, {
      "heading" : "3.3 Description of Experiments",
      "text" : "To assess the classification capabilities and the impact of sparse activity and sparse connectivity, the MNIST database of handwritten digits (LeCun and Cortes, 1998) was employed. It is a popular benchmark data set for classification algorithms, and numerous results with respect to this data set are reported in the literature. The database consists of 70 000 samples, divided into a learning set of 60 000 samples and an evaluation set of 10 000 samples. Each sample represents a digit of size 28×28 pixels and has a class label from {0, . . . ,9} associated with it. Therefore the input and output dimensionalities are d := 282 = 784 and c := 10, respectively. The classification error is given in percent of all 10 000 evaluation samples, hence 0.01% corresponds to a single misclassified digit.\nFor generation of the original data set, the placement of the digits has been achieved based on their barycenter (LeCun and Cortes, 1998). Because of sampling and rounding errors, the localization uncertainty can hence be assumed to be less than one pixel in both directions. To account for this uncertainty, the learning set was augmented by jittering each sample in each of eight possible directions by one pixel, yielding 540 000 samples for learning in total. The evaluation set was left\nunchanged to yield results that can be compared to the literature. As noted by Hinton et al. (2006), the learning problem is no more permutation-invariant due to the jittering, as information on the neighborhood of the pixels is implicitly incorporated in the learning set.\nHowever, classification results improve dramatically when such prior knowledge is used. This was demonstrated by Schölkopf (1997) using the virtual support vector method, which improved a support vector machine with polynomial kernel of degree five from an error of 1.4% to 1.0% by jittering the support vectors by one pixel in four principal directions. This result was extended by DeCoste and Schölkopf (2002), where a support vector machine with a polynomial kernel of degree nine was improved from an error of 1.22% to 0.68% by jittering in all possible eight directions. Further improvements can be achieved by generating artificial training samples using elastic distortions (Simard et al., 2003). This reduced the error of a two-layer neural network with 800 hidden units to 0.7%, compared to the 1.1% error yielded when training on samples created by affine distortions. Very big and very deep neural networks possess a large number of adaptable weights. In conjunction with elastic and affine distortions such neural networks can yield errors as low as 0.35% (Cireşan et al., 2010). The current record error of 0.23% is held by an approach that combines distorted samples with a committee of convolutional neural networks (Cireşan et al., 2012). This is an architecture that has been optimized exclusively for input data that represents images, that is where the neighborhood of the pixels is hard-wired in the classifier. To allow for a plain evaluation that does not depend on additional parameters for creating artificial samples, the jittered learning set with 540 000 samples is used throughout this paper.\nThe experimental methodology was as follows. The number of hidden units was chosen to be n := 1000 in all experiments that are described below. This is an increased number compared to the 800 hidden units employed by Simard et al. (2003), but promises to yield better results when an adequate number of learning samples is used. As all tested learning algorithms are essentially gradient descent methods, an initial step size had to be chosen. For each candidate step size, five runs of a two-fold cross validation were carried out on the learning set. Then, for each step size the median of the ten resulting classification errors was computed. The winning step size was then determined to be the one that achieved a minimum median of classification errors.\nIn every epoch, 21 600 samples were randomly chosen from the learning set and presented to the network. This number of samples was chosen as it is 1/25-th of the jittered learning set. The step size was multiplicatively annealed using a factor of 0.999 after every epoch. Optimization was terminated once the relative change in the objective function became very small and no more significant progress on the learning set could be observed. The resulting classifiers were then applied to the evaluation set, and misclassifications were counted."
    }, {
      "heading" : "3.4 Experimental Results",
      "text" : "Two variants of the supervised online auto-encoder architecture as proposed in this section were trained on the augmented learning set. In both variants, the target degree of sparse connectivity was set to σW := 0.75. This choice was made because 96% of all samples in the learning set possess a sparseness which is less than 0.75. Therefore, the resulting bases are forced to be truly sparsely connected compared to the sparseness of the digits.\nThe first variant is denoted by SOAE-σ. Here, the sparseness-enforcing projection operator π was used as transfer function f in the hidden layer. Target degrees of sparse activity σH with respect to Hoyer’s sparseness measure σ were chosen from the interval [0.20, 0.95] in steps of size 0.05.\nThis variant was then trained on the jittered learning set using the method described in Section 3.2. For every value of σH , the resulting sparseness of activity was measured after training using the L0 pseudo-norm. For this, each sample of the learning set was presented to the networks, and the number of active units in the hidden layer was counted. Figure 5 shows the resulting mean value and standard deviation of sparse activity. If σH = 0.20 is chosen, then in the mean about 800 of the total 1000 hidden units are active upon presentation of a sample from the learning set. For σH = 0.80 only one hundred units are active at any one time, and for σH = 0.95 there are only eleven active units. The standard deviation of the activity decreases when sparseness increases, hence the mapping from σH to the resulting number of active units becomes more accurate.\nThe second variant, denoted SOAE-L0, differs from SOAE-σ in that the projection with respect to the L0 pseudo-norm as transfer function f was used. The target sparseness of activity is given by a parameter κ ∈ {1, . . . ,n}, which controls the exact number of units that are allowed to be active at any one time. For the experiments, the values for κ were chosen to match the mean activities from the SOAE-σ experiments. This way the results of both variants can be compared based on a unified value of activity sparseness. The results are depicted in Figure 6. Usage of the σ projection consequently outperforms the L0 projection for all sparseness degrees. Even for high sparseness of activity, that is when only about ten percent of the units are allowed to be active at any one time, good classification capabilities can be obtained with SOAE-σ. For κ ∈ [242, 558], the classification results of SOAE-L0 reach an optimum. SOAE-σ is more robust, as classification capabilities first begin to collapse when sparseness is below 5%, whereas SOAE-L0 starts to degenerate when sparseness falls below 20%. For σH ∈ [0.45, 0.85], roughly translating to between 5% and 50% activity, about equal classification performance is achieved using SOAE-σ.\nIt can thus be concluded that using the sparseness-enforcing projection operator as described in this paper yields better results than when the simple L0 projection is used to achieve sparse activity. To assess the benefit more precisely and to investigate the effect of individual factors, several comparative experiments have been carried out. A summary of these experiments and their outcome is given in Table 1. The variants SOAE-σ and SOAE-L0 denote the entirety of the respective experiments where sparseness of activity lies in the intervals described above, that is σH ∈ [0.45, 0.85] and κ ∈ [242, 558], respectively. Using these intervals, SOAE-σ and SOAE-L0 achieved a median error of 0.75% and 0.82% on the evaluation set, respectively. Variant SOAE-σ-conn is essentially equal to SOAE-σ, except for sparse connectivity not being incorporated. Sparseness of activity here was also chosen to be σH ∈ [0.45, 0.85], which resulted in about equal classification results over the entire range. Dropping of sparse connectivity increases misclassifications, for the median error of SOAE-σ-conn is 0.81% and thereby greater than the median error of SOAE-σ.\nThe other five approaches included in the comparison are multi-layer perceptrons (MLPs) with the same topology and dynamics as the classification module of supervised online auto-encoder, with two exceptions. First, the transfer function of the hidden layer f was set to a hyperbolic tangent, thus not including explicit sparse activity. Second, in all but one experiment sparse connectivity was either not incorporated, or achieved through other means than by performing a σ projection after each learning epoch. Besides the variation in sparseness of connectivity, the experiments differ in the initialization of the network parameters.\nFor each variant, 55 runs were carried out and the resulting classifiers were applied to the evaluation set to compute the classification error. Then, the best four and the worst four results were discarded and not included in further analysis. Hence a random sample of size 47 was achieved, where 15% of the original data were trimmed away. This procedure was also applied to the results\nof SOAE-σ, SOAE-σ-conn, and SOAE-L0, to obtain a total of eight random samples of equal size for comparison with another.\nThe most basic variant, denoted the baseline in this discussion, is MLP-random, where all network parameters were initialized randomly. This achieved a median error of 0.88% on the evaluation set, being considerably worse than SOAE-σ. For variant MLP-samples, the hidden layer was initialized by replication of n randomly chosen samples from the learning set. This did decrease the overall learning time. However, the median classification error was slightly worse with 0.91% compared to MLP-random.\nFor variant MLP-SCFC, the network parameters were initialized in an unsupervised manner using the sparse coding for fast classification (SCFC) algorithm (Thom et al., 2011a). This method is a precursor to the SOAE proposed in this paper. It also features sparse connectivity and sparse activity but differs in some essential parts. First, sparseness of activity is achieved through a latent variable that stores the optimal sparse code words of all samples simultaneously. Using this matrix of code words, the activity of individual units was enforced to be sparse over time on the entire learning set. SOAE achieves sparseness over space, as for each sample only a pre-defined fraction of units is allowed to be active at any one time. A second difference is that sparse activity is achieved only indirectly by approximation of the latent matrix of code words with a feed-forward representation. With SOAE, sparseness of activity is guaranteed by construction. MLP-SCFC achieved a median classification error of 0.91% on the MNIST evaluation set, rendering it slightly worse than MLP-random and equivalent to MLP-samples.\nThe first experiment that incorporates only sparse connectivity is SMLP-SCFC. Initialization was done as for MLP-SCFC, but during training sparseness of connectivity was yielded by application of the sparseness-enforcing projection operator to the weights of the hidden layer after every learning epoch. Hence the sparseness gained from unsupervised initialization was retained.\nMLP-SCFC features sparse connectivity only after initialization, but loses this property when training proceeds. With this slight modification, the median error of SMLP-SCFC decreases to 0.81%, which is significantly better than the baseline result.\nThe effect of better generalization due to sparse connectivity has also been observed by LeCun et al. (1990) in the context of convolutional neural networks. It can be explained by the bias-variance decomposition of the generalization error (Geman et al., 1992). When the effective number of the degrees of freedom is constrained, overfitting will be less likely and hence classifiers produce better results on average. The same argument can be applied to SOAE-σ, where additional sparse activity further improves classification results.\nThe last variant is called MLP-OBD. Here, the optimal brain damage (OBD) algorithm (LeCun et al., 1990) was used to prune synaptic connections in the hidden layer that are irrelevant for the computation of the classification decision of the network. The parameters of the network were first initialized randomly and then optimized on the learning set. Then the impact for each synaptic connection on the objective function was estimated using the Taylor series of the objective function, where a diagonal approximation of the Hessian was employed and terms of cubic or higher order were neglected. Using this information, the number of connections was halved by setting the weight of connections with low impact to zero. The network was then retrained with weights of removed connections kept at zero. This procedure was repeated until a target percentage γ of active synaptic connections in the hidden layer was achieved. For the results reported here, γ = 12.5% was chosen as this reflects the sparse connectivity σW = 0.75 of the other approaches best. MLP-OBD achieved a median classification error of 0.89%, which is comparable to the baseline result."
    }, {
      "heading" : "3.5 Statistical Analysis and Conclusions",
      "text" : "A statistical analysis was carried out to assess the significance of the differences in the performance of the eight algorithms. The procedure follows the proposals of Pizarro et al. (2002) and Demšar (2006) for hypothesis testing, and is concluded by effect size estimation as proposed by Grissom (1994) and Acion et al. (2006). For each algorithm, a sample of size 47 was available, allowing for robust analysis results.\nFirst, all results were tested for normality using the test developed by Shapiro and Wilk (1965). The resulting test statistics W and p-values are given in Table 1. As all p-values are large, it cannot be rejected that the samples came from normally distributed populations. Thus normality is assumed in the remainder of this discussion. Next, the test proposed by Levene (1960) was applied to determine whether equality of variances of the groups holds. This resulted in a test statistic F = 2.7979 with 7 and 368 degrees of freedom, and therefore a p-value of 0.0075. Hence the hypothesis that all group variances are equal can be rejected with very high significance. Consequently, parametric omnibus and post-hoc tests cannot be applied, as they require the groups to have equal variance.\nAs an alternative, the nonparametric test by Kruskal and Wallis (1952) which is based on rank information was employed to test whether all algorithms produced classifiers with equal classification errors in the mean. The test statistic was H = 214.44 with 7 degrees of freedom, and the p-value was less than 10−15. There is hence a statistically significant difference in the mean classification results. To locate this deviation, a critical difference for comparing the mean ranks of the algorithms was computed. A Tukey-Kramer type modification applied to Dunn’s procedure yields this critical difference, which is less conservative than Nemenyi’s procedure for the Kruskal-Wallis test (Hochberg and Tamhane, 1987). Note that this approach is nevertheless similar to the post-hoc\nprocedure proposed by Demšar (2006) for paired observations, such that the diagrams proposed there can be adapted to the case for unpaired observations. The result is depicted in Figure 7, where the critical difference for statistical significance at the α = 0.01 level is given. This test induces a highly significant partitioning of the eight algorithms, namely three groups A, B and C given by\nA := {SOAE-σ} , B := {SOAE-σ-conn, SOAE-L0, SMLP-SCFC} , and C := {MLP-OBD, MLP-random, MLP-samples, MLP-SCFC} .\nThis partition in turn induces an equivalence relation. Statistical equivalence is hence unambiguous and well-defined at α = 0.01. Moreover, the p-value for this partition is 0.007. If the significance level α would have been set lower than this, then groups A and B would blend together.\nTo assess the benefit when an algorithm from one group is chosen over an algorithm from another group, the probability of superior experiment outcome was estimated (Grissom, 1994; Acion et al., 2006). For this, the classification errors were pooled with respect to membership in the three groups. It was then tested whether these pooled results still come from normal distributions. As group A is a singleton, this is trivially fulfilled with the result from Table 1. For group B, the Shapiro-Wilk test statistic was W = 0.9845 and the p-value was 0.11. Group C achieved a test statistic of W = 0.9882 and a p-value of 0.12. If a standard significance level of α = 0.01 is chosen, then B and C can be assumed to be normally distributed also.\nLet EG be the random variable modeling the classification results of the algorithms from group G∈ {A,B,C}. It is assumed that EG is normally distributed with unknown mean and unknown variance for all G. Then EG−EG̃ is clearly normally distributed also for two groups G, G̃ ∈ {A,B,C}. Therefore, the probability P(EG < EG̃) that one algorithm produces a better classifier than another could be computed from the Gaussian error function if the group means and variances were known. However, using Rao-Blackwell theory a minimum variance unbiased estimator R̂2 of this probability can be computed easily (Downton, 1973). Evaluation of the expression for R̂2 shows that P(EA < EB) can be estimated by 0.87, P(EB < EC) can be estimated by 0.88, and P(EA < EC) can be estimated by 0.99. Therefore, the effect of choosing SOAE-σ over any of the seven other algorithms is dramatic (Grissom, 1994).\nThese results can be interpreted as follows. When neither sparse activity nor sparse connectivity is incorporated, then the worst classification results are obtained regardless of the initialization of the network parameters. The exception is MLP-OBD which incorporates sparse connectivity, although, as its name says, in a destructive way. Once a synaptic connection has been removed, it cannot be recovered, as the measure for relevance of LeCun et al. (1990) vanishes for synaptic connections of zero strength. The statistics for SMLP-SCFC shows that when sparse connectivity is obtained using the sparseness-enforcing projection operator, then superior results can be achieved. Because of the nature of projected gradient descent, it is possible here to restore deleted connections if it helps to decrease the classification error during learning. For SOAE-σ-conn only sparse activity was used, and classification results were statistically equivalent to SMLP-SCFC.\nTherefore, using either sparse activity or sparse connectivity improves classification capabilities. When both are used, then results improve even more as variant SOAE-σ shows. This does not hold for SOAE-L0 however, where the L0 projection was used as transfer function. As Hoyer’s sparseness measure σ and the according projection possess desirable analytical properties, they can be considered smooth approximations to the L0 pseudo-norm. It is this smoothness which seems to produce this benefit in practice."
    }, {
      "heading" : "4. Related Work",
      "text" : "This section reviews work related with the contents of this paper. First, the theoretical foundations of the sparseness-enforcing projection operator are discussed. Next, its application as neuronal transfer function to achieve sparse activity in a classification scenario is put in context with alternative approaches, and possible advantages of sparse connectivity are described."
    }, {
      "heading" : "4.1 Sparseness-Enforcing Projection Operator",
      "text" : "The first major part of this paper dealt with improvements to the work of Hoyer (2004) and Theis et al. (2005). Here, an algorithm for the sparseness-enforcing projection with respect to Hoyer’s sparseness measure σ was proposed. The technical proof of correctness is given in Appendix C. The set that should be projected onto is an intersection of a simplex C and a hypercircle L, which is a hypersphere lying in a hyperplane. The overall procedure can be described as performing alternating projections onto C and certain subsets of L. This approach is common for handling projections onto intersections of individual sets. For example, von Neumann (1950) proposed essentially the same idea when the investigated sets are closed subspaces, and has shown that this converges to a solution. A similar approach can be carried out for intersections of closed, convex cones (Dykstra, 1983), which can be generalized to translated cones that can be used to approximate any convex set (Dykstra and Boyle, 1987). For these alternating methods, it is only necessary to know how projections onto individual members of the intersection can be achieved.\nAlthough these methods exhibit great generality, they have two severe drawbacks in the scenario of this paper. First, the target set for projection must be an intersection of convex sets. The scaled canonical simplex C is clearly convex, but the hypercircle L is non-convex if it contains more than one point. The condition that generates L cannot easily be weakened to achieve convexity. If the original hypersphere were replaced with a closed ball, then L would be convex. But this changes the meaning of the problem dramatically, as now virtually any sparseness below the original target degree of sparseness can be obtained. This is because when the target L1 norm λ1 is fixed, the sparseness measure σ decreases whenever the target L2 norm decreases. In geometric terms, the\nmethod proposed in this paper performs a projection from within a circle onto its boundary to increase the sparseness of the working vector. This argument is given in more detail in Figure 11 and the proof of Lemma 28(f).\nThe second drawback of the general methods for projecting onto intersections is that a solution is only achieved asymptotically, even when the convexity requirements are fulfilled. Due to the special structure of C and L, the number of alternating projections that have to be carried out to find a solution using Algorithm 3 is bounded from above by the problem dimensionality. Thus an exact projection is always found in finite time. Furthermore, the solution is guaranteed to be found in time that is at most quadratic in problem dimensionality.\nA crucial point is the computation of the projection onto C and certain subsets of L. Due to the nature of the L2 norm, the latter is straightforward. For the former, efficient algorithms have been proposed recently (Duchi et al., 2008; Chen and Ye, 2011). When only independent solutions are required, the projection of a point x onto a scaled canonical simplex of L1 norm λ1 can also be carried out in linear time (Liu and Ye, 2009), without having to sort the vector that is to be projected. This can be achieved by showing that the separator t̂ for performing the simplex projection is the unique zero of the monotonically decreasing function t 7→ ‖max(|x|− t · e, 0)‖1−λ1. The zero of this function can be found efficiently using the bisection method, and exploiting the special structure of the occurring expressions (Liu and Ye, 2009).\nIn the context of this paper an explicit closed-form expression for t̂ is preferable as it permits additional insight into the properties of the projected point. The major part in proving the correctness of Algorithm 1 is the interconnection between C and L, that is that the final solution has zero entries at the according positions in the working vector and thus a chain monotonically decreasing in L0 pseudo-norm is achieved. This result is established through Lemma 26, which characterizes projections onto certain faces of a simplex, Corollary 27 and their application in Lemma 28.\nAnalysis of the theoretical properties of the sparseness-enforcing projection is concluded with its differentiability in Appendix D. The idea is to exploit the finiteness of the projection sequence and to apply the chain rule of differential calculus. It is necessary to show that the projection chain is robust in a neighborhood of the argument. This reduces analysis to individual projection steps which have already been studied in the literature. For example, the projection onto a closed, convex set is guaranteed to be differentiable almost everywhere (Hiriart-Urruty, 1982). Here non-convexity of L is not an issue, as the only critical point is its barycenter. For the simplex C, a characterization of critical points is given with Lemma 32 and Lemma 33, and it is shown that the expression for the projection onto C is invariant to local changes. An explicit expression for construction of the gradient of the sparseness-enforcing projection operator is given in Theorem 35. In Corollary 36 it is shown that the computation of the product of the gradient with an arbitrary vector can be achieved efficiently by exploiting sparseness and the special structure of the gradient.\nSimilar approaches for sparseness projections are discussed in the following. The iterative hard thresholding algorithm is a gradient descent algorithm, where a projection onto an L0 pseudo-norm constraint is performed (Blumensath and Davies, 2009). Its application lies in compressed sensing, where a linear generative model is used to infer a sparse representation for a given observation. Sparseness here acts as regularizer which is necessary because observations are sampled below the Nyquist rate. In spite of the simplicity of the method, it can be shown that it achieves a good approximation to the optimal solution of this NP-hard problem (Blumensath and Davies, 2009).\nClosely related with the work of this paper is the generalization of Hoyer’s sparseness measure by Theis and Tanaka (2006). Here, the L1 norm constraint is replaced with a generalized Lp pseudo-\nnorm constraint, such that the sparseness measure becomes σp(x) := ‖x‖p/‖x‖2. For p = 1, Hoyer’s sparseness measure up to a constant normalization is obtained. When p converges decreasingly to zero, then σp(x)p converges point-wise to the L0 pseudo-norm. Hence for small values of p a more natural sparseness measure is obtained. Theis and Tanaka (2006) also proposed an extension of Hoyer’s projection algorithm. It is essentially von Neumann’s alternating projection method, where closed subspaces have been replaced by \"spheres\" that are induced by Lp pseudo-norms. Note that these sets are non-convex when p < 1, such that convergence is not guaranteed. Further, no closedform solution for the projection onto an \"Lp-sphere\" is known for p < {1,2,∞}, such that numerical methods have to be employed.\nA problem where similar projections are employed is to minimize a convex function subject to group sparseness (see for example Friedman et al., 2010). In this context, mixed norm balls are of particular interest (Sra, 2012). For a matrix X ∈ Rn×g, the mixed Lp,q norm is defined as the Lp norm of the Lq norms of the columns of X , that is ‖X‖p,q :=\n∥∥(‖Xe1‖q , . . . , ‖Xeg‖q )T∥∥p. Here, X can be interpreted to be a data point with entries partitioned into g groups. When p = 1, then the projection onto a simplex can be generalized directly for q = 2 (van den Berg et al., 2008) and for q = ∞ (Quattoni et al., 2009). The case when p = 1 and q≥ 1 is more difficult, but can be solved as well (Liu and Ye, 2010; Sra, 2012).\nThe last problem discussed here is the elastic net criterion (Zou and Hastie, 2005), which is a constraint on the sum of an L1 norm and an L2 norm. The feasible set can be written as the convex set N := {s ∈Rn | λ1 ‖s‖1 +λ2 ‖s‖ 2 2 ≤ 1}, where λ1,λ2 ≥ 0 control the shape of N. Note that in N only the sum of two norms is considered, whereas the non-convex set S(λ1,λ2) consists of the intersection of two different constraints. Therefore, the elastic net induces a different notion of sparseness than Hoyer’s sparseness measure σ does. As is the case for mixed norm balls, the projection onto a simplex can be generalized to achieve projections onto N (Mairal et al., 2010)."
    }, {
      "heading" : "4.2 Supervised Online Auto-Encoder",
      "text" : "The sparseness-enforcing projection operator π with respect to Hoyer’s sparseness measure σ and the projection onto an L0 pseudo-norm constraint are differentiable almost everywhere. Thus they are suitable for gradient-based optimization algorithms. In Section 3, they were used as transfer functions in a hybrid of an auto-encoder network and a two-layer neural network to infer a sparse internal representation. This representation was subsequently employed to approximate the input sample and to compute a classification decision. In addition, the matrix of bases which was used to compute the internal representation was enforced to be sparsely populated by application of the sparseness projection after each learning epoch. Hence the supervised online auto-encoder proposed in this paper features both sparse activity and sparse connectivity.\nThese two key properties have also been investigated and exploited in the context of autoassociative memories for binary inputs. If the entries of the training patterns are sparsely populated, the weight matrix of the memory will be sparsely populated as well after training if Hebbian-like learning rules are used (Kohonen, 1972). The assumption of sparsely coded inputs also results in increased completion capacity and noise resistance of the associative memory (Palm, 1980). If the input data is not sparse inherently, feature detectors can perform a sparsification prior to the actual processing through the memory (Baum et al., 1988).\nA purely generative model that also possesses these two key properties is non-negative matrix factorization with sparseness constraints (Hoyer, 2004). This is an extension to plain non-negative\nmatrix factorization (Paatero and Tapper, 1994) which was shown to achieve sparse connectivity on certain data sets (Lee and Seung, 1999). However, there are data sets on which this does not work (Li et al., 2001; Hoyer, 2004). Although Hoyer’s model makes sparseness easily controllable by explicit constraints, it is not inherently suited to classification tasks. An extension intended to incorporate class membership information to increase discriminative capabilities was proposed by Heiler and Schnörr (2006). In their approach, an additional constraint was added ensuring that every internal representation is close to the mean of all internal representations that belong to the same class. In other words, the method can be interpreted as supervised clustering, with the number of clusters equal to the number of classes. However, there is no guarantee that a distribution of internal representations exists such that both the reproduction error is minimized and the internal representations can be arranged in such a pattern. Unfortunately, Heiler and Schnörr (2006) used only a subset of a small data set for handwritten digit recognition to evaluate their approach.\nA precursor to the supervised online auto-encoder was proposed by Thom et al. (2011a). There, inference of sparse internal representations was achieved by fitting a one-layer neural network to approximate a latent variable of optimal sparse representations. The transfer function used for this approximation was a hyperbolic tangent raised to an odd power greater or equal to three. This resulted in a depression of activities with small magnitude, favoring sparseness of the result. Similar techniques to achieve a shrinkage-like effect for increasing sparseness of activity in a neural network were used by Gregor and LeCun (2010) and Glorot et al. (2011). Information processing is here purely local, that is a scalar function is evaluated entrywise on a vector, and thus no information is interchanged among individual entries.\nThe use of non-local shrinkage to reduce Gaussian noise in sparse coding has already been described by Hyvärinen et al. (1999). Here, a maximum likelihood estimate with only weak assumptions yields a shrinkage operation, which can be conceived as projection onto a scaled canonical simplex. In the use case of object recognition, a hard shrinkage was also employed to de-noise filter responses (Mutch and Lowe, 2006). Whenever a best approximation from a permutationinvariant set is used, a shrinkage-like operation must be employed. Using a projection operator as neural transfer function is hence a natural extension of these ideas. When the projection is sufficiently smooth, the entire model can be tuned end-to-end using gradient methods to achieve an auto-encoder or a classifier.\nThe second building block from Thom et al. (2011a) that was incorporated into supervised online auto-encoder is the architectural concept for classification. It is well-known that two layers in a neural network are sufficient to approximate any continuous function on a compactum with arbitrary precision (Cybenko, 1989; Funahashi, 1989; Hornik et al., 1989). Similar architectures have also been proposed for classification in combination with sparse coding of the inputs. However, sparse connectivity was not considered in this context. Bradley and Bagnell (2009) used the Kullback-Leibler divergence as implicit sparseness penalty term and combined this with the backpropagation algorithm to yield a classifier that achieved a 1.30% error rate on the MNIST evaluation set. The Kullback-Leibler divergence was chosen to replace the usual L1 norm penalty term, as it is smoother than the latter and therefore sparsely coded internal representations are more stable subject to subtle changes of the input. A related technique is supervised dictionary learning by Mairal et al. (2009), where the objective function is an additive combination of a classification error term, a term for the reproduction error, and an L1 norm constraint. Inference of sparse internal representations is achieved through solving an optimization problem. Such procedures are time-consuming and greatly increase the computational complexity of classification. With this approach, a classifi-\ncation error of 1.05% on the MNIST evaluation set was achieved. These two approaches used the original MNIST learning set without jittering the digits and can thus be considered permutationinvariant. Augmentation of the learning set with virtual samples would have contributed to improve classification performance, as demonstrated by Schölkopf (1997).\nFinally consider once more the sparse connectivity property, which is mostly neglected in the literature in favor of sparse activity. It was shown in this paper that sparse connectivity helps to improve generalization capabilities. In practice, this property can also be used to reduce the computational complexity of classification by one order of magnitude (Thom et al., 2011b). This results from exploiting sparseness and using sparse matrix-vector multiplication algorithms to infer the internal representation, which is the major computational burden in class membership prediction. It was shown in this paper and by Thom et al. (2011b) that a small number of nonzero entries in the weight matrix of the hidden layer is sufficient for achieving good classification results. Furthermore, the additional savings in required storage capacity and bandwidth allow using platforms with modest computational power for practical implementations. Sparseness is therefore an elementary concept of efficiency in artificial processing systems."
    }, {
      "heading" : "5. Conclusions",
      "text" : "Without sparseness in their brains, higher mammals probably would not have developed to viable life-forms. This important concept of efficiency was discovered by neuroscientists, and practical benefit was obtained by the engineers of artificial information processing systems. This paper studied Hoyer’s sparseness measure σ, and in particular the projection of arbitrary vectors onto sets where σ attains a constant value. A simple yet efficient algorithm for computing this sparsenessenforcing projection operator was proposed in this paper, and its correctness was proved. In addition, it was demonstrated that the proposed algorithm is superior in run-time to Hoyer’s original algorithm. The analysis of the theoretical properties of this projection was concluded by showing it is differentiable almost everywhere.\nAs projections onto σ constraints are well-understood, they constitute the ideal tool for building systems that can benefit from sparseness constraints. An original use case was introduced in this paper. Here, the σ projection was implemented as neuronal transfer function, yielding a differentiable closed-form expression for inference of sparse code words. Besides this sparse activity, the connectivity in this system was also forced to be sparse by performing the σ projection after the presentation of learning examples. Because of its smoothness, the entire system can be optimized end-to-end by gradient-based methods, yielding a classification architecture exhibiting true sparse information processing.\nThis supervised online auto-encoder was applied on a benchmark data set for pattern recognition. Because sparseness constraints reduce the amount of feasible solutions, it is not clear in the first place whether the same performance can be achieved at all. However, when the target degree of sparseness of the activity is in a reasonable range, classification results are not only equivalent but superior to classical non-sparse approaches. This result is supported by statistical evaluation showing that this performance increase is not merely coincidental, but statistically significant. Therefore, sparseness can be seen as regularizer that offers the potential to improve artificial systems in the same way it seems to improve biological systems."
    }, {
      "heading" : "Acknowledgments",
      "text" : "The authors wish to thank Patrik O. Hoyer and Xiaojing Ye for sharing the source code of their algorithms. The authors are also grateful to the anonymous reviewers for their valuable comments and feedback. This work was supported by Daimler AG, Germany."
    }, {
      "heading" : "Appendix A. Notation and Prerequisites",
      "text" : "This appendix fixes the notation and provides prerequisites for the following appendices. N denotes the natural numbers including zero,R the real numbers andR≥0 the non-negative real numbers. Rn is the n-dimensional Euclidean space with canonical basis e1, . . . ,en ∈ Rn, and e := ∑ni=1 ei ∈ Rn denotes the vector where all entries are identical to unity. For all other vectors, a subscript denotes the corresponding entry of the vector, that is xi = eTi x for x ∈ Rn. The amount of nonzero entries in a vector is given by the L0 pseudo-norm, ‖·‖0. ‖·‖1 and ‖·‖2 denote the Manhattan norm and Euclidean norm, respectively. 〈·, ·〉 denotes the canonical dot product in the Euclidean space. Given a vector x, diag(x) denotes the square matrix with x on its main diagonal and zero entries at all other positions, and a◦b = diag(a)b denotes the Hadamard product or entrywise product for vectors a and b. When A and B are square matrices, then diag(A,B) denotes the block diagonal matrix with the blocks given by A and B. Sn is the symmetric group, and Pτ denotes the permutation matrix for τ ∈ Sn. For a set M ⊆ U , MC denotes its complement in the universal set U , where U ∈ {Rn,{1, . . . ,n}} is clear from the context. The power set of M is denoted by℘(M). If M⊆Rn, then ∂M denotes its boundary in the topological sense. The sign function is denoted by sgn(·). A list of symbols that are frequently used throughout the paper is given in Table 2.\nThe important concept of the projection onto a set was given in Definition 1. The following basic statement will be used extensively in this paper and follows from 〈x, x〉= ‖x‖22 for all x ∈Rn and the fact that the scalar product is a symmetric bilinear form (Laub, 2004):\nProposition 4 Let a,b ∈ Rn. Then ‖a±b‖22 = ‖a‖ 2 2 + ‖b‖ 2 2± 2〈a, b〉. Further it is ‖a−b‖ 2 2 = ‖a− p‖22 +‖p−b‖ 2 2 +2〈a− p, p−b〉 for all p ∈Rn.\nAs an example, note that the outcome of the sparseness-enforcing projection operator depends only on the target sparseness degree up to scaling:\nRemark 5 Let λ1,λ2 > 0 and λ̃1, λ̃2 > 0 be pairs of target norms such that λ1/λ2 = λ̃1/λ̃2. Then\nprojS(λ1 ,λ2)(x) = λ̃2/λ2 ·projS(λ̃1 ,λ̃2)(x) for all x ∈R n.\nProof It is sufficient to show only one inclusion. Let x ∈ Rn be arbitrary, p ∈ projS(λ1 ,λ2)(x) and r̃ ∈ S(λ̃1,λ̃2). Define p̃ := λ̃1/λ1 · p = λ̃2/λ2 · p ∈ Rn, then ‖ p̃‖1 = ∣∣λ̃1/λ1∣∣ · ‖p‖1 = λ̃1 and analogously ‖ p̃‖2 = λ̃2, hence p̃∈ S(λ̃1,λ̃2). For the claim to hold it has now to be shown that ‖ p̃− x‖2 ≤‖r̃− x‖2. Write r := λ2/λ̃2 · r̃ ∈Rn, which in fact lies in S(λ1,λ2). So ‖p− x‖2 ≤ ‖r− x‖2 by definition of p, and with Proposition 4 follows ‖r̃− x‖22−‖p̃− x‖ 2 2 = ‖r̃‖ 2 2 +‖x‖ 2 2−2〈r̃, x〉−‖ p̃‖ 2 2−‖x‖ 2 2 +2〈p̃, x〉=\n2〈p̃− r̃, x〉= λ̃2/λ2 ·2〈p− r, x〉= λ̃2/λ2 · ( ‖r− x‖22−‖p− x‖ 2 2 ) ≥ 0.\nHence only the ratio of the target L1 norm to the target L2 norm is important and not their actual scale. This argument can be generalized to projections onto any scale-invariant set and therefore naturally holds also for S(λ1,λ2)≥0 ."
    }, {
      "heading" : "Appendix B. Projections onto Symmetric Sets",
      "text" : "This appendix investigates certain symmetries of sets and their effect on projections onto such sets. A great variety of sparseness measures fulfills certain symmetries as vector entries are equally weighted, see Hurley and Rickard (2009). This means that no entry is preferred over another, and for negative entries usually the absolute value or the squared value is taken, such that the signs of the entries are ignored. Consider the following definition of symmetries that are to be analyzed:\nDefinition 6 Let ∅ ,M ⊆Rn. Then M is called permutation-invariant if and only if Pτx ∈M for all x ∈M and all permutations τ ∈ Sn. Further, M is called reflection-invariant if and only if b◦x ∈M for all x ∈M and all b ∈ {±1}n.\nIn other words, a subset M of the Euclidean space is permutation-invariant if set membership is invariant to permutation of individual coordinates. M is reflection-invariant if single entries can be\nnegated without violating set membership. This is equivalent to x−2∑i∈I xiei ∈M for all x ∈M and all index sets I ⊆ {1, . . . ,n}, which is a condition that is technically easier to handle. The following observation states that these symmetries are closed under common set operations:\nRemark 7 Let ∅ , A,B ⊆ Rn. When A and B are permutation-invariant or reflection-invariant, then so are A∪B, A∩B and AC.\nThe proof is obvious by elementary set algebra. Now consider the following general properties of functions mapping to power sets:\nDefinition 8 Let ∅ , M ⊆ Rn, let ℘(M) be its power set and let f : Rn→℘(M) be a function. f is called order-preserving if and only if xi > x j implies pi ≥ p j for all x ∈Rn, for all p ∈ f (x) and for all i, j ∈ {1, . . . ,n}. f is called absolutely order-preserving if and only if from |xi|> ∣∣x j∣∣ follows |pi| ≥\n∣∣p j∣∣ for all x ∈Rn, for all p ∈ f (x) and for all i, j ∈ {1, . . . ,n}. f is called orthant-preserving if and only if sgn(xi) = sgn(pi) or xi = 0 or pi = 0 for all x ∈M and all p ∈ f (x).\nHence, a function f is order-preserving if the relative order of entries of its arguments does not change upon function evaluation. Thus if the entries of x are sorted in ascending or descending order, then so are the entries of every vector in f (x). Orthant-preservation denotes the fact that x and every vector from f (x) are located in the same orthant. The link between set symmetries and projection properties is established by the following result. A weaker form of its statements has been described by Duchi et al. (2008) in the special case of a projection onto a simplex.\nLemma 9 Let ∅ ,M ⊆Rn and p : Rn→℘(M), x 7→ projM(x). Then the following holds:\n(a) When M is permutation-invariant, then p is order-preserving.\n(b) When M is reflection-invariant, then p is orthant-preserving.\nProof (a) Let x ∈ Rn and p ∈ projM(x). Let i, j ∈ {1, . . . ,n} with xi > x j. Assume that pi < p j. Let τ := (i, j) ∈ Sn and q := Pτ p, then q ∈M because of M being permutation-invariant. Consider d := ‖p− x‖22−‖q− x‖ 2 2. Because τ is a single transposition, application of Proposition 4 yields d = 2(p j− pi)(xi− x j). By requirement d > 0, which contradicts the minimality of p as being a projection of x onto M. Hence pi ≥ p j must hold.\n(b) Let x ∈ Rn and p ∈ projM(x). Define I := { i ∈ {1, . . . ,n} | sgn(xi) , sgn(pi)}. The claim holds trivially if I = ∅. Assume I , ∅ and define q := p−2∑i∈I piei. It follows q ∈M because M is reflection-invariant. Proposition 4 implies ‖q‖22 = ‖p‖ 2 2, and clearly 〈q, x〉= 〈p, x〉−2∑i∈I pixi. Therefore application of Proposition 4 yields d := ‖p− x‖22−‖q− x‖ 2 2 = −4∑i∈I pixi. By the definition of I one obtains pixi ∈ {−1,0}. Hence would there be an index i ∈ I with pi , 0 and xi , 0, then d > 0, but ‖p− x‖22 > ‖q− x‖ 2 2 would contradict the minimality of p. Therefore I = { i ∈ {1, . . . ,n} | pi = 0 or xi = 0}, and the claim follows.\nWhen the projection onto a permutation-invariant set is unique, then equal entries of the argument cause equal entries in the projection:\nRemark 10 Let ∅ ,M ⊆Rn be permutation-invariant and x ∈Rn. When p = projM(x) is unique, then pi = p j follows for all i, j ∈ {1, . . . ,n} with xi = x j.\nProof Let x ∈ Rn, p = projM(x) and i, j ∈ {1, . . . ,n} with xi = x j. Assume pi , p j would hold and let τ := (i, j) ∈ Sn and q := Pτ p , p. With the permutation-invariance of M follows q ∈ M, and ‖q− x‖2 = ‖p− x‖2 with xi = x j. Hence q ∈ projM(x), so q = p with the uniqueness of the projection, which contradicts q , p. Therefore, pi = p j.\nThe next result shows how solutions to a projection onto reflection-invariant sets can be turned into non-negative solutions and vice-versa. Its second part was already observed by Hoyer (2004), in the special case of the sparseness-enforcing projection operator, and by Duchi et al. (2008), when the connection between projections onto a simplex and onto an L1 ball was studied. Both did not provide a proof, but in the latter work a hint to a possible proof was given. With Lemma 11 it suffices to consider non-negative solutions for projections onto reflection-invariant sets.\nLemma 11 Let ∅ , A⊆Rn be reflection-invariant, B := A∩Rn≥0 and p,x ∈Rn. Then: (a) If p ∈ projA(x), then |p| ∈ projB(|x|).\n(b) If p ∈ projB(|x|), then s◦ p ∈ projA(x) where s ∈ {±1} n is given by si := 1 if xi ≥ 0 and\nsi :=−1 otherwise for all i ∈ {1, . . . ,n}. Proof First note that if q ∈ projA(x), then sgn(xi) = sgn(qi) or xi = 0 or qi = 0 with Lemma 9(b). Hence for all i∈{1, . . . ,n} follows (|qi|− |xi|)2 =(qi · sgn(qi)− xi · sgn(xi))2 =(qi− xi)2, and therefore ‖q− x‖22 = ‖|q|− |x|‖ 2 2. Furthermore, |q| ∈ A because of A reflection-invariant and |q| ∈ Rn≥0, so |q| ∈ B. (a) Let p∈ projA(x) and q∈ B, then |p| ∈ B and it has to be shown that ‖|p|− |x|‖2 ≤ ‖q−|x|‖2. Define I := { i ∈ {1, . . . ,n} | xi < 0} and q̃ := q− 2∑i∈I qiei, that is the signs of entries in I are flipped. Clearly q̃ ∈ A, so in conjunction with the remark at the beginning of the proof follows ‖|p|− |x|‖22 = ‖p− x‖ 2 2 ≤ ‖q̃− x‖ 2 2. For i < I one obtains xi ≥ 0 and q̃i = qi, hence q̃i−xi = qi−|xi|. For i∈ I follows xi < 0 and q̃i =−qi, hence q̃i−xi =−(qi−|xi|). This yields (q̃i− xi)2 =(qi−|xi|)2 for all i ∈ {1, . . . ,n}, thus ‖q̃− x‖22 = ‖q−|x|‖ 2 2, and the claim follows.\n(b) Let p ∈ projB(|x|). If i ∈ {1, . . . ,n} with xi ≥ 0, then clearly si pi− xi = pi− |xi|. For i ∈ {1, . . . ,n} with xi < 0 follows si pi− xi = −(pi−|xi|). Therefore, ‖s◦ p− x‖22 = ‖p−|x|‖ 2 2. Let q∈ projA(x), then the remark at the beginning of the proof yields ‖q− x‖ 2 2 = ‖|q|− |x|‖ 2 2 and |q| ∈B. p ∈ projB(|x|) yields ‖p−|x|‖ 2 2 ≤ ‖|q|− |x|‖ 2 2, and the claim follows.\nUsing this result immediately yields a condition for projections to be absolutely order-preserving:\nLemma 12 Let∅,M⊆Rn be both permutation-invariant and reflection-invariant. Then the function p : Rn→℘(M), x 7→ projM(x), is absolutely order-preserving. Proof Let x ∈Rn, p ∈ projM(x), and i, j ∈ {1, . . . ,n} with |xi|>\n∣∣x j∣∣. Define L := M∩Rn≥0, which is permutation-invariant with Remark 7. Lemma 11 implies that |p| ∈ projL(|x|), and with Lemma 9 follows |pi| ≥\n∣∣p j∣∣. The application of these elementary results to projections onto sets on which functions achieve constant values is straightforward. Examples were given in Section 2 with the sets Z and S(λ1,λ2)."
    }, {
      "heading" : "Appendix C. Proof of Correctness of Algorithm 1 and Algorithm 3",
      "text" : "The purpose of this appendix is to rigorously prove correctness of Algorithm 1 and Algorithm 3, that is that they compute projections onto S(λ1,λ2)≥0 . Projections onto S\n(λ1,λ2) can then be inferred easily as explained in Appendix B.\nC.1 Geometric Structures and First Considerations\nThe aim is to compute projections onto D, which is the intersection of the non-negative orthantRn≥0, the target hyperplane H and the target hypersphere K, see Section 2.1. Further, the intersection of H and K yields a hypercircle L, and the intersection of Rn≥0 and H yields a scaled canonical simplex C. The structure of H and L will be analyzed in Section C.1.1 and Section C.1.2, respectively. The properties of C are discussed in Section C.2 and Section C.3. These results will then be used in Section C.4 to prove Theorem 2 and Theorem 3.\nFor the analysis of subsets where certain coordinates vanish, it is useful to define the following quantities for an index set I ⊆ {1, . . . ,n} with cardinality d := |I|. The corresponding face of C is denoted by CI := {c ∈C | ci = 0 for all i < I } and has barycenter mI := λ1/d ·∑i∈I ei ∈CI . Further, LI := {a ∈ L | ai = 0 for all i < I } denotes the hypercircle with according vanishing entries, and ρI := λ22− λ 2 1/d is the squared radius of LI . Note that mI is also the barycenter of LI .\nWith these definitions the intermediate goal is now to prove that projections onto D can be computed by alternating projections onto the geometric structures defined earlier. The idea is to show that the set of solutions is not tampered by alternating projections onto H, C, L and LI .\nC.1.1 L1 NORM CONSTRAINT—TARGET HYPERPLANE\nFirst, the projection onto the target hyperplane H is considered. Lemma 13 is an elaborated version of a result from Theis et al. (2005), which is included here for completeness. Using its statements, it can be assumed that the considered point lies on H without modification of the solution set of the projection onto the target set D.\nLemma 13 Let x ∈Rn. Then the following holds: (a) projH(x) = x+ 1/n · ( λ1− eT x ) e.\n(b) Let r := projH(x). Then projD(x) = projD(r).\nProof (a) This is essentially a projection onto a hyperplane, yielding a unique result. (b) With (a) follows r− x = 1/n · ( λ1− eT x ) e. Hence 〈h, r− x〉 = λ1/n · ( λ1− eT x ) holds for arbitrary h ∈ H. This expression is independent of the entries of h, which yields 〈a−b, r− x〉= 0 for every a,b ∈ H.\nNow let p ∈ projD(x), that is ‖p− x‖2 ≤ ‖q− x‖2 for all q ∈ D. Let q ∈ D be arbitrary. With D ⊆ H follows 〈q− p, r− x〉 = 0, and thus Proposition 4 yields ‖q− r‖22−‖p− r‖ 2 2 = ‖q− x‖ 2 2− ‖p− x‖22 +2〈q− p, x− r〉= ‖q− x‖ 2 2−‖p− x‖ 2 2 ≥ 0, hence ‖p− r‖ 2 2 ≤ ‖q− r‖ 2 2, so p ∈ projD(r).\nFor the converse let p ∈ projD(r). Analogously ‖q− x‖ 2 2−‖p− x‖ 2 2 = ‖q− r‖ 2 2−‖p− r‖ 2 2 ≥ 0,\nhence p ∈ projD(x).\nTherefore, the barycenter m is the projection of the origin onto H. The next remark gathers additional information on the norm of m and dot products with this point.\nRemark 14 It is ‖m‖22 = λ 2 1/n. Further, 〈m, h〉= λ21/n for all h ∈H, and thus ‖h−m‖22 = ‖h‖ 2 2−λ 2 1/n with Proposition 4.\nC.1.2 L1 AND L2 NORM CONSTRAINT—TARGET HYPERSPHERE\nAfter the projection onto the target hyperplane H has been carried out, consider now the joint constraint of H and the target hypersphere K. First note that L = H ∩K is a hypercircle, that is a hypersphere in the subspace H, with intrinsic dimensionality reduced by one:\nLemma 15 Consider L = H ∩K and ρ = λ22− λ 2 1/n. Then the following holds:\n(a) L = L̃ := {q ∈ H | ‖q−m‖22 = ρ}.\n(b) L , ∅ if and only if λ2 ≥ λ1/√n.\nProof (a) Follows immediately from Remark 14. (b) L is nonempty if and only if ρ≥ 0 using (a), and ρ = (λ2 + λ1/√n)(λ2− λ1/√n). Hence, with λ1,λ2 > 0 one obtains ρ≥ 0 if and only if λ2− λ1/√n≥ 0. Hence L , ∅ by the requirement that λ2 ≤ λ1 ≤ √\nnλ2. Further, the following observation follows immediately from Proposition 4 and ‖a‖2 = ‖b‖2 = λ2 for all a,b ∈ L:\nRemark 16 For all a,b ∈ L it is ‖a−b‖22 = 2 ( λ22−〈a, b〉 ) , hence 〈a, b〉= λ22− 1/2 · ‖a−b‖ 2 2.\nTherefore, on L the dot product is equal to the Euclidean norm up to an additive constant. Next consider projections onto L and note that the solution set with respect to D is not changed by this operation. The major arguments for this result have been taken over from Theis et al. (2005). Here, the statements from Lemma 15 have been incorporated and the resulting quadratic equation was solved explicitly, simplifying the original version of Theis et al. (2005).\nLemma 17 Let r ∈ H with r , m. Let s := m+δ(r−m) where δ := √ρ/‖r−m‖2. Then:\n(a) δ > 0, s ∈ L, and ‖q− r‖22−‖s− r‖ 2 2 = 1/δ · ‖q− s‖ 2 2 for all q ∈ L.\n(b) s = projL(r).\n(c) projD(r) = projD(s).\nProof (a) First note that δ > 0 because of r ,m. Clearly s = (1−δ)m+δr. Further, s ∈H because of eT s = λ1, and s ∈ L because of ‖s−m‖22 = ρ and Lemma 15.\nLet q ∈ L be arbitrary. One obtains ‖q‖2 = ‖s‖2 with q,s ∈ K and therefore application of Proposition 4 yields ‖q− r‖22−‖s− r‖ 2 2 = 2〈s−q, r〉. With Remark 14 follows 〈m, r〉 = λ 2 1/n and ‖r‖22 = ‖r−m‖ 2 2 + λ 2 1/n. Hence, 〈s, r〉 = (1− δ)〈m, r〉+ δ〈r, r〉 = λ21/n+ δ‖r−m‖22. On the other hand, from s−m = δ(r−m) and hence r = (1− 1/δ)m+ 1/δ · s, and using Remark 16 it follows that 〈q, r〉= (1− 1/δ)λ21/n+ 1/δ · ( λ22− 1/2 · ‖q− s‖ 2 2 ) . Therefore with δ‖r−m‖22 = ρ/δ one obtains\n〈s−q, r〉= δ‖r−m‖22 + 1/δ · ( λ21/n−λ22 + 1/2 · ‖q− s‖ 2 2 ) = 12δ ‖q− s‖ 2 2 ,\nand the claim follows directly by substitution. (b) Let q ∈ L, then (a) implies ‖q− r‖22−‖s− r‖ 2 2 = 1/δ · ‖q− s‖ 2 2 ≥ 0 with equality if and only if q = s because of ‖·‖2 being positive definite. Thus s is the unique projection of r onto L. (c) With (a) follows ‖q− s‖22−‖p− s‖ 2 2 = δ ( ‖q− r‖22−‖p− r‖ 2 2 )\nfor all p,q ∈ D because of D⊆ L. For projD(r)⊆ projD(s), let p ∈ projD(r) and q ∈D. By definition ‖p− r‖ 2 2 ≤ ‖q− r‖ 2 2, and thus ‖q− s‖22−‖p− s‖ 2 2 ≥ 0 with δ > 0, hence p ∈ projD(s). For the converse, let p ∈ projD(s) and q ∈ D. Similarly, ‖q− r‖22−‖p− r‖ 2 2 = 1/δ · ( ‖q− s‖22−‖p− s‖ 2 2 ) ≥ 0, thus p ∈ projD(r).\nLemma 17 does not hold when r = m, which forms a null set. In practice, however, this can occur when the input vector x for Algorithm 1 is poorly chosen, for example if all entries are equal. In this case, projL(r) = L, hence any point from L can be chosen for further processing.\nRemark 18 One possibility in the case r = m would be to choose the point s := α∑n−1i=1 ei + βen where α,β ∈ R for s ∈ projL(r), that is forcing the last entry to be unequal to the other ones. For satisfying s ∈ L, set α := λ1/n+ √ρ/√n(n−1) and β := λ1−α(n−1) = λ1/n− √ ρ(n−1)/ √ n. This yields\nα−β = √ρ ( 1/ √ n(n−1)+ √ n−1/ √ n ) > 0, hence α , β. This choice has the convenient side effect of s being sorted in descending order.\nCombining these properties of H and L, it can now be shown that projections onto D are invariant to affine-linear transformations with positive scaling:\nCorollary 19 Let α > 0, β ∈R and x ∈Rn. Then projD(αx+βe) = projD(x).\nProof Let α > 0, β ∈ R and x ∈ Rn. With Lemma 13 and Lemma 17 it is enough to show that projL(projH(αx+βe)) = projL(projH(x)). Let x̃ := αx+βe, r̃ := projH(x̃) and s̃ := projL(r̃). Lemma 13 and eT e = n yield r̃ = (αx+βe)+ 1/n · ( λ1−αeT x−βeT e ) e = αx+ 1/n · ( λ1−αeT x ) e. Hence r̃ is independent of β. Lemma 17 yields s̃=m+ δ̃(r̃−m), where δ̃ := √ρ/‖r̃−m‖2. Application of Proposition 4 yields\n‖r̃‖22 = ‖αx‖ 2 2 + ∥∥1/n · (λ1−αeT x)e∥∥22 +2〈αx, 1/n · (λ1−αeT x)e〉\n= α2 ‖x‖22 + 1/n · ( λ1−αeT x )( λ1 +αeT x ) = α2 ‖x‖22 + 1/n · ( λ21−α2(eT x)2 ) ,\nand with Remark 14 follows ‖r̃−m‖22 = ‖r̃‖ 2 2−λ 2 1/n =α2 ( ‖x‖22−1/n ·(eT x)2 ) . Let r := projH(x) and\ns := projL(r), then Lemma 13 and Lemma 17 imply r = x+ 1/n · ( λ1− eT x ) e and s = m+δ(r−m), where δ := √ρ/‖r−m‖2. Likewise ‖r−m‖22 = ‖x‖ 2 2− 1/n · (eT x)2, and hence δ/δ̃ = ‖r̃−m‖2/‖r−m‖2 = α, where α > 0 must hold. This yields\ns̃ = m+ δ̃(r̃−m) = m+ δ/α · ( αx+ λ1/n · e−α/n · eT xe− λ1/n · e ) = m+δ ( x− 1/n · eT xe ) = s,\nwhich shows that the projection is invariant.\nTherefore, shifting and positive scaling of the argument of Algorithm 1 do not change the outcome. An overview of the steps carried out this far is given in Figure 8. Consider a point x ∈ Rn and s := projL(projH(x)). When s ∈ Rn≥0, then already s ∈ D and hence s ∈ projD(x). Therefore only situations in which s <Rn≥0 holds are relevant in the remainder of this discussion.\nC.2 Simplex Geometry\nThe joint constraint of the target hyperplane H with non-negativity yields simplex C. The following definition is likewise to definitions from Chen and Ye (2011) and Michelot (1986):\nDefinition 20 For n∈N, n≥ 1, the set4n := {α ∈Rn≥0 | eT α = 1} is called canonical n-simplex.\nIt is clear that C =Rn≥0∩H = {λ1α | α ∈4n } is a scaled canonical simplex. Further, for an index set I ⊆ {1, . . . ,n} the set CI = {c ∈C | ci = 0 for all i < I } is a face of the simplex, which intrinsically possesses the structure of a simplex itself—although of reduced intrinsic dimensionality. Consider the following observation on the topology of C embedded in the subspace H:\nProposition 21 Let c = λ1α ∈ C with α ∈ 4n. Then c ∈ ∂C in the metric space (H, ‖·‖2) if and only if there is a j ∈ {1, . . . ,n} with α j = 0.\nThe proof is simple and omitted as it does not contribute to deeper insight. Hence the faces CI are subsets of ∂C, which is the topological border of C in (H, ‖·‖2). Using Proposition 21 a statement on the inradius of C can be made, which in turn can be used to show that for n = 2 no simplex projection has to be carried out at all:\nProposition 22 The squared inradius of C is ρin := λ21 n(n−1) . It is L⊆C for n = 2.\nProof Because C is closed and convex, it is enough to consider the distance between interior points and boundary points. Hence the insphere radius of a point p ∈C can be computed as being the minimum distance to any of the boundary points. With Proposition 21 these points can be characterized as points where at least one entry vanishes. Using Lagrange multipliers it can be shown that minc∈∂C ‖m− c‖22 = ρin. Further, it can be shown that no point other than m is center of a larger insphere. This is achieved by constructing projections on certain faces of C, as is discussed in detail in the forthcoming Lemma 26. When n = 2 and λ2 ≤ λ1, which is fulfilled by requirement on λ1 and λ2, then ρ = λ22− λ 2 1/n≤ λ21/2 = ρin, and L⊆C follows with Lemma 15.\nThe projection within H from outside a simplex is unique and must be located on its boundary:\nRemark 23 Let s ∈ H \\C. Then projC(s) ∈ ∂C in (H, ‖·‖2).\nThe proof is obvious because C is closed and convex. By combination of Proposition 21 and Remark 23, it is now evident that the projection within H onto C yields vanishing entries. After the\nfirst projection onto H, this subspace is never left throughout the arguments presented here, such that Remark 23 always applies. It has yet to be shown that the projection onto D possesses zero entries in the same coordinates. This way, a reduction of problem dimensionality can be achieved, and an iterative algorithm can be constructed to compute the projection onto D. The algorithm is guaranteed to terminate at the latest when the problem dimensionality equals two with Proposition 22.\nC.2.1 PROJECTION ONTO A SIMPLEX\nQuite a few methods have been proposed for carrying out projections onto canonical simplexes. An iterative algorithm was developed by Michelot (1986) which is very similar to Hoyer’s original method for computation of the projection onto D. A simpler and more effective algorithm has been developed by Duchi et al. (2008). Building upon this work, Chen and Ye (2011) have proposed and rigorously proved correctness of a very similar algorithm, which is more explicit than that of Duchi et al. (2008). Their algorithm can be adapted to better suit the needs for the sparseness-enforcing projection. This adapted version was given by Algorithm 2 in Section 2. The following note makes the adaptations explicit.\nProposition 24 Let x ∈Rn \\C and p := projC(x). Then the following holds:\n(a) There exists t̂ ∈R such that p = max(x− t̂ · e, 0), where the maximum is taken element-wise.\n(b) Algorithm 2 computes t̂ such that (a) holds and the number of nonzero entries in p.\nProof The arguments from Chen and Ye (2011) hold for projections onto 4n. The case of the scaled canonical simplex can be recovered using p = λ1 · proj4n (x/λ1). Therefore lines 4 and 7 of Algorithm 2 can be adapted from t := s−1i and t := s−1 n to t := s−λ1 i and t := s−λ1 n , respectively. The correct number of nonzero entries in p follows immediately from its expression from (a), the fact that y is sorted in descending order and the termination criterion of Algorithm 2.\nAs already described in Section 2.2, symmetries can be exploited for projections onto C:\nRemark 25 When x is already sorted in descending order, then no sorting is needed at the beginning of Algorithm 2. The projection p is then sorted also, because C is permutation-invariant. In this case, the nonzero entries of p are located in the first d := ‖p‖0 entries, while pd+1 = · · ·= pn = 0.\nThis fact is useful for optimizing access to the relevant entries of the working vector, which can then be stored contiguously in memory.\nC.2.2 PROJECTION ONTO A FACE OF A SIMPLEX\nThe projection within H onto C yields zero entries in the working vector. It still remains to be shown that the projection onto D possesses zero entries at the same coordinates as the projection onto C. If this holds true, then the dimensionality of the original problem can be reduced, and iterative arguments can be applied. The main building block in the proof is the explicit construction of projections from within the simplex onto a certain face. The next Lemma is fundamental for proving correctness of Algorithm 1. It describes the construction of the result of the projection onto a simplex face and poses a statement on its norm, which in turn is used to prove that the position of vanishing entries does not change upon projection.\nLemma 26 Let q ∈ C and let ∅ , I ⊆ {1, . . . ,n} be an arbitrary index set. Then there exists an s ∈CI with ‖q− v‖22 = ‖q− s‖ 2 2+‖s− v‖ 2 2 for all v ∈CI . If additionally max j∈J q j ≤mini∈I qi holds for J := IC, then ‖s‖2 ≥ ‖q‖2 with equality if and only if q j = 0 for all j ∈ J. More precisely, let h := |J| and let J = { j1, . . . , jh} such that q j1 ≤ ·· · ≤ q jh . Consider the sequence s(0), . . . ,s(h) ∈Rn defined iteratively by s(0) := q and\ns(k) := s(k−1)− s(k−1)jk e jk + 1 n−k s (k−1) jk ( e−∑ki=1e ji ) for k ∈ {1, . . . ,h}. Write s := s(h). Then the following holds:\n(a) s(k) ∈C{ j1,..., jk}C for all k ∈ {1, . . . ,h}.\n(b) 〈 s(0)− s(k), s(k)− s(k+1) 〉 = 0 for all k ∈ {0, . . . ,h−1}.\n(c) ∥∥s(k)−q∥∥22 = ∑ki=1∥∥s(i)− s(i−1)∥∥22 for all k ∈ {0, . . . ,h}.\n(d) s(k−1)jk = q jk + 1 n−k+1 ∑ k−1 i=1 q ji for all k ∈ {1, . . . ,h}.\n(e) 〈 s(0)− s(k), s(k)− v 〉 = 0 for all k ∈ {0, . . . ,h} and for all v ∈CI .\n(f) ‖q− v‖22 = ∥∥q− s(k)∥∥22 +∥∥s(k)− v∥∥22 for all k ∈ {0, . . . ,h} and for all v ∈CI .\n(g) s = projCI (q).\nIf max j∈J q j ≤mini∈I qi, then the following holds as well:\n(h) s(k)j1 ≤ ·· · ≤ s (k) jh ≤mini∈I s (k) i for all k ∈ {0, . . . ,h}.\n(i) s(k−1)jk ≤ λ1 n−k+1 for all k ∈ {1, . . . ,h}.\n(j) ∥∥s(k−1)∥∥2 ≤ ∥∥s(k)∥∥2 for all k ∈ {1, . . . ,h}, and hence ‖s‖2 ≥ ‖q‖2.\n(k) ‖s‖2 = ‖q‖2 if and only if q j = 0 for all j ∈ J.\nProof In other words, s(k) is constructed from s(k−1) by setting entry jk to zero, and adjusting all remaining entries, but the ones previously set to zero, such that the L1 norm is preserved. This generates a finite series of points progressively approaching CI , see (a), where the final point is from CI . As all relevant dot products vanish, see (b) and (e), this is a process of orthogonal projections. Hence the distance between points can be computed using the Pythagorean theorem, see (c) and (f). In (g) it is then shown that s is the unique projection of q onto CI .\nIf the entry jk in s(k−1) does not vanish, then the L2 norm of the newly constructed point is greater than that of the original point, see (j) and (k). The entries with indices from J must be sufficiently small for this non-decreasing norm property to hold, see (h) and (i). The magnitude of these entries, however, is strongly connected with the magnitudes of respective entries from the original point q, that is, the rank is preserved from one point to its successor. Figure 9 gives an example for n = 3 in which cases the non-decreasing norm property holds.\nLet ak := 1n−k ( e−∑ki=1 e ji ) −e jk ∈Rn for k ∈ {1, . . . ,h}. Then s(k) = s(k−1)+s (k−1) jk ak, and with\ninduction follows s(k) = s(0)+∑ki=1 s (i−1) ji ai for k ∈ {1, . . . ,h}.\n(a) First note that eT ak = 1n−k (n− k)− 1 = 0 and that ak ∈ R n ≥0 for all k ∈ {1, . . . ,h}. It is now shown by induction that s(k) lies on the claimed face of C. For k = 1, one obtains s(1)j1 = 0 and s(1)i = qi+ 1 n−1 q j1 for i, j1. Thus s (1) i ≥ 0 for all i∈ {1, . . . ,n} because of qi≥ 0 for all i∈ {1, . . . ,n}. Further eT s(1) = eT q+q j1e T a1 = eT q = λ1, hence s(1) ∈C{1,...,n}\\{ j1 }.\nFor k−1→ k, assume s(k−1)i = 0 for all i ∈ { j1, . . . , jk−1}, s (k−1) i ≥ 0 for all i ∈ {1, . . . ,n} and\neT s(k−1) = λ1. Clearly, s (k) i = s (k−1) i = 0 holds for i ∈ { j1, . . . , jk−1}. Furthermore, one obtains s(k)jk = s (k−1) jk − s (k−1) jk = 0. With s\n(k−1) ∈ Rn≥0 and ak ∈ Rn≥0 follows that s(k) ∈ Rn≥0. Finally it is eT s(k) = eT s(k−1)+ s(k−1)jk e\nT ak = eT s(k−1) = λ1. Hence s(k) ∈C{1,...,n}\\{ j1,..., jk}. (b) For i ∈ {1, . . . ,k} follows\n〈 e−∑iµ=1e jµ , e−∑ k+1 ν=1e jν 〉 = 〈e, e〉− 〈 e, ∑k+1ν=1e jν 〉 − 〈 ∑iµ=1e jµ , e 〉 + 〈 ∑iµ=1e jµ , ∑ k+1 ν=1e jν 〉 = n− (k+1)− i+ i = n− k−1,\nand therefore\n〈ai, ak+1〉= 1(n−i)(n−k−1) 〈 e−∑iµ=1e jµ , e−∑ k+1 ν=1e jν 〉 + 〈 e ji , e jk+1 〉 − 1n−i 〈 e−∑iµ=1e jµ , e jk+1 〉 − 1n−k−1 〈 e ji , e−∑ k+1 ν=1e jν\n〉 = n−k−1(n−i)(n−k−1) +0− 1 n−i − 0 n−k−1 = 0.\nThus 〈 s(0)− s(k), s(k)− s(k+1) 〉 = 〈\n∑ki=1s (i−1) ji ai, s (k) jk+1ak+1 〉 = ∑ki=1s (i−1) ji s (k) jk+1 〈ai, ak+1〉= 0.\n(c) Follows by induction using Proposition 4 and (b). (d) Clearly, 〈 e jk , ai 〉 = 1n−i for i ∈ {1, . . . ,k−1}, hence with induction follows\ns(k−1)jk = 〈 e jk , s (k−1)〉= 〈e jk , s(0)〉+∑k−1i=1 s(i−1)ji 〈e jk , ai〉= q jk +∑k−1i=1 1n−i s(i−1)ji IH = q jk +∑ k−1 i=1 1 n−i q ji +∑ k−1 i=1 ∑ i−1 µ=1 1 n−i 1 n−i+1 q jµ = q jk +∑ k−1 i=1 q ji [ 1 n−i +∑ k−1 µ=i+1 1 n−µ 1 n−µ+1 ] .\nUsing ∑k−1i=1 ∑ i−1 µ=1 = ∑1≤µ<i≤k−1 = ∑ k−1 µ=1 ∑ k−1 i=µ+1 the order of summation was changed after the induction step, and then the variables i and µ were swapped. For the claim to hold it is enough to show that 1n−i +∑ k−1 µ=i+1 1 n−µ 1 n−µ+1 = 1 n−k+1 for all i ∈ {1, . . . ,k−1}, which follows by reverse induction.\n(e) Proof by induction. Let v ∈ CI , that is eT v = λ1 and v j = 0 for all j ∈ J. For k = 0, s(0)−s(k) = 0 and the claim follows. For k−1→ k, first note that 〈ak, q〉= 1n−k ( λ1−∑ki=1 q ji ) −q jk ,〈\nak, s(k−1) 〉 = 〈 ak, s(0) 〉 +∑k−1i=1 s (i−1) ji 〈ak, ai〉= 〈ak, q〉 because 〈ak, ai〉= 0 for all i∈ {1, . . . ,k−1}\nas shown in (b), thus 〈 ak, s(0)−2s(k−1) 〉 =−〈ak, q〉. Furthermore 〈ak, v〉= λ1n−k because 〈 e ji , v 〉 = v ji = 0 for all i ∈ {1, . . . ,h}, and 〈ak, ak〉 = ‖ak‖ 2 2 = 1 (n−k)2 ∥∥e−∑ki=1 e ji∥∥22 + ∥∥e jk∥∥22 = 1 + 1n−k .\nTherefore,〈 s(0)− s(k), s(k)− v 〉 = 〈 s(0)− s(k−1)− s(k−1)jk ak, s (k−1)+ s(k−1)jk ak− v 〉\n= 〈 s(0)− s(k−1), s(k−1)− v 〉 + s(k−1)jk 〈 ak, s(0)−2s(k−1)− s (k−1) jk ak + v 〉 IH = s(k−1)jk ( −〈ak, q〉− s (k−1) jk 〈ak, ak〉+ 〈ak, v〉\n) = s(k−1)jk ( − λ1n−k + 1 n−k ∑ k i=1q ji +q jk − s (k−1) jk ( 1+ 1n−k ) + λ1n−k\n) = s(k−1)jk ( q jk ( 1+ 1n−k ) + 1n−k ∑ k−1 i=1 q ji− s (k−1) jk ( 1+ 1n−k )) = 0,\nwhere the final equality was yielded using the statement from (d) and ( 1+ 1n−k ) · 1n−k+1 = 1 n−k .\n(f) Follows using Proposition 4 and (e). (g) A unique Euclidean projection exists because CI is closed and convex. s ∈CI with (a), and\n‖q− s‖22 ≤ ‖q− v‖ 2 2 for all v ∈CI with (f). Therefore s = projCI (q).\n(h) In the remainder of the proof assume that max j∈J q j ≤ mini∈I qi holds. It is first shown by induction that s(k)j1 ≤ ·· · ≤ s (k) jh for all k ∈ {0, . . . ,h}. For k = 0 this is fulfilled as requirement on q and by definition of J. For k− 1→ k, let µ,ν ∈ { j1, . . . , jh} with µ < ν. Then with χ denoting the indicator function and with A := χ{ jk }(µ)−χ{ jk }(ν)+ 1 n−k ( χ{ j1,..., jk}C(ν)−χ{ j1,..., jk}C(µ) ) follows\ns(k)ν − s (k) µ = s (k−1) ν − s (k−1) µ + s (k−1) jk A. Clearly, when A≥ 0 then the claim follows with the induction hypothesis and with s(k−1)jk ≥ 0 due to (a). First consider the case of µ∈ { j1, . . . , jk−1}. If ν∈ { j1, . . . , jk−1} also, then A= 0. If ν= jk, then A =−1, and hence s(k)ν − s (k) µ = s (k−1) ν − s (k−1) µ − s(k−1)ν =−s (k−1) µ which however vanishes with (a). If ν∈ { jk+1, . . . , jh}, then A = 1n−k ≥ 0. If µ = jk, then ν∈ { jk+1, . . . , jh}, and then A = 1+ 1\nn−k ≥ 0. If µ ∈ { jk+1, . . . , jh}, then ν ∈ { jµ+1, . . . , jh}, thus A = 0. Hence the first claim is always fulfilled.\nNext, it is shown that max j∈J s (k) j ≤ mini∈I s (k) i for all k ∈ {0, . . . ,h}. For k = 0 this is the requirement on q. For k− 1→ k, let i ∈ I and j ∈ J. It is then χ{ jk }(i) = 0, χ{ jk }( j) ∈ {0,1}, χ{ j1,..., jk}C(i) = 1 and χ{ j1,..., jk}C( j) = 0, therefore\ns(k)i − s (k) j = s (k−1) i − s (k−1) jk χ{ jk }(i)+ 1 n−k s (k−1) jk χ{ j1,..., jk}C(i)\n− s(k−1)j + s (k−1) jk χ{ jk }( j)− 1 n−k s (k−1) jk χ{ j1,..., jk}C( j)\n= s(k−1)i − s (k−1) j + s (k−1) jk ( 1 n−k +χ{ jk }( j) ) ≥ 0,\nwhere s(k−1)i − s (k−1) j ≥ 0 holds by induction hypothesis.\n(i) With (a) follows λ1 = eT s(k−1) and s (k−1) ji = 0 for all i ∈ {1, . . . ,k−1}. s (k−1) i ≥ s (k−1) jk holds\nfor all i ∈ I with (h), and s(k−1)ji ≥ s (k−1) jk for all i ∈ {k+1, . . . ,h}. Therefore,\nλ1 = ∑ni=1s (k−1) i = ∑i∈Is (k−1) i +∑ k−1 i=1 s (k−1) ji + s (k−1) jk +∑ h i=k+1s (k−1) ji ≥ ( (n−h)+1+(h− k) ) s(k−1)jk = (n− k+1)s (k−1) jk ,\nand the claim follows because n− k+1 > 0. (j) In (e) it was shown that ‖ak‖22 = 1+ 1n−k . Furthermore,〈\ns(k−1), ak 〉 = 1n−k ( λ1−∑k−1i=1 s (k−1) ji − s (k−1) jk ) − s(k−1)jk = 1 n−k ( λ1− s (k−1) jk ) − s(k−1)jk ,\nbecause all s(k−1)ji vanish for i ∈ {1, . . . ,k−1} using (a). Application of Proposition 4 yields∥∥s(k)∥∥22−∥∥s(k−1)∥∥22 = ∥∥s(k−1)jk ak∥∥22 +2s(k−1)jk 〈s(k−1), ak〉 = s(k−1)jk [ s(k−1)jk ( 1+ 1n−k ) + 2n−k ( λ1− s (k−1) jk ) −2s(k−1)jk\n] = s(k−1)jk [ 2λ1 n−k − s (k−1) jk ( 1+ 1n−k )] ,\nwhich is non-negative when s(k−1)jk ≤ ( 1+ 1n−k )−1 · 2λ1n−k = 2λ1n−k+1 . With (i) this is always fulfilled, hence\n∥∥s(k−1)∥∥2≤ ∥∥s(k)∥∥2, and ‖s‖2≥‖q‖2 follows immediately using a telescoping sum argument. (k) When q j = 0 for all j ∈ J, then s = q and the claim follows. When there is a jk ∈ { j1, . . . , jh} with q jk , 0, let k be minimal such that either k = 1 or q jk−1 = 0, hence s (k−1) jk = q jk . With (i) follows 0 < s(k−1)jk ≤ λ1 n−k+1 < 2λ1 n−k+1 , and hence ∥∥s(k)∥∥22−∥∥s(k−1)∥∥22 > 0 with (j), thus ∥∥s∥∥2 > ∥∥q∥∥2.\nThe application of Lemma 26 then shows that the projection of a point from a face CI of C onto D must reside on the same face CI , given the original point is located within a sphere with squared radius ρI around mI . As will be shown in Lemma 28, this is automatically fulfilled for projections from L onto C.\nCorollary 27 Let I ⊆ {1, . . . ,n}, let v ∈CI with ‖v‖2 < λ2, and let q ∈ projD(v). Then q ∈CI .\nProof Let J := {1, . . . ,n}\\ I, and let q ∈ projD(v). Assume there is at least one j ∈ J with q j , 0. For showing max j∈J q j ≤ mini∈I qi, assume there are i ∈ I and j ∈ J with q j > qi. Then vi > 0 and v j = 0 because of v ∈CI . D is permutation-invariant using Remark 7 as intersection of permutationinvariant sets. Hence let τ := (i, j) ∈ Sn be the transposition swapping i and j, and consider\nd := ‖q− v‖22−‖Pτq− v‖ 2 2 = 2(q j−qi)(vi− v j) .\nIt is d > 0 because of q j−qi > 0 and vi− v j = vi > 0. Hence ‖Pτq− v‖2 < ‖q− v‖2 and Pτq ∈ D, which violates the minimality of q. Therefore, max j∈J q j ≤mini∈I qi must hold.\nA drawing for the next arguments is given in Figure 10. With Lemma 26 there is an s ∈CI such that ‖q− v‖22 = ‖q− s‖ 2 2 +‖s− v‖ 2 2 and ‖s‖2 > λ2. Consider f : [0, 1]→ R, β 7→ ‖v+β(s− v)‖2. Clearly f (0) = ‖v‖2 < λ2 and f (1) = ‖s‖2 > λ2, hence with the intermediate value theorem there exists a β∗ ∈ (0, 1) with f (β∗) = λ2. Let t := v+ β∗ (s− v) ∈ Rn, which lies in CI because of v,s ∈CI and CI is convex. By construction ‖t‖2 = λ2, hence t ∈ D̃ := {a ∈ D | ai = 0 for all i < I }. Clearly, ‖v− t‖2 +‖t− s‖2 = |β∗| · ‖s− v‖2 + |1−β∗| · ‖v− s‖2 = ‖s− v‖2. Let p ∈ projD̃(v), then ‖v− p‖2 ≤ ‖v− t‖2. Therefore,\n‖q− v‖22 = ‖q− s‖ 2 2 +‖s− v‖ 2 2 = ‖q− s‖ 2 2 +(‖v− t‖2 +‖t− s‖2) 2 > ‖v− t‖22 ≥ ‖v− p‖ 2 2 .\nBecause of D̃⊆ D, p ∈ D also, hence ‖q− v‖2 ≤ ‖p− v‖2, which contradicts ‖q− v‖2 > ‖v− p‖2. Hence, q j = 0 for all j ∈ J must hold, and thus q ∈CI .\nBecause CI is isomorphic to a simplex, but with lower dimensionality than C, an algorithm can be constructed to compute the projection onto D, as discussed in the following.\nC.3 Self-Similarity of the Feasible Set\nThe next Lemma summarizes previous results and analyzes projections from L onto C in greater detail. It shows that the solution set with respect to the projection onto D is not tampered, and that all solutions have zeros at the same positions as the projection onto C. Figure 11 provides orientation on the quantities discussed in Lemma 28.\nLemma 28 Let s ∈ L\\C and r ∈ projC(s). Let I := { i ∈ {1, . . . ,n} | ri , 0} and d := |I|. Then:\n(a) There exists t̂ ∈R≥0 such that r = max(s− t̂ · e, 0), with the maximum taken element-wise.\n(b) I , ∅ and I , {1, . . . ,n}.\n(c) si > t̂ and si− ri = t̂ for all i ∈ I. si ≤ t̂ and si− ri = si for all i < I.\n(d) 〈r, s− r〉= λ1t̂ .\n(e) 〈mI, s− r〉= λ1t̂ , thus 〈mI− r, s− r〉= 0.\n(f) projD(r)⊆CI , hence from q ∈ projD(r) follows qi = 0 for all i < I.\n(g) Let q ∈ projD(r). Then 〈q− r, s− r〉= 0, and thus ‖q− s‖ 2 2 = ‖q− r‖ 2 2 +‖r− s‖ 2 2.\n(h) projD(r) = projD(s)⊆CI .\nProof (a) The existence of t̂ ∈ R such that r = max(s− t̂ · e, 0) is guaranteed by Proposition 24. It remains to be shown that t̂ ≥ 0. Consider the index set J := { j ∈ {1, . . . ,n} | s j ≥ 0} of nonnegative entries of s. Because of s ∈ L\\C one obtains eT s = λ1 and there is an index i with si < 0, hence J , {1, . . . ,n}. Therefore, λ1 = ∑ j∈J s j +∑ j<J s j < ∑ j∈J s j. Now assume t̂ < 0, then s j− t̂ > 0 for all j ∈ J, and hence r j = s j− t̂ for all j ∈ J. Using r ∈C yields\nλ1 = ∑nj=1r j ≥∑ j∈Jr j = ∑ j∈J (s j− t̂) = ∑ j∈Js j−|J| · t̂ > ∑ j∈Js j,\nwhich contradicts ∑ j∈J s j > λ1. Hence t̂ ≥ 0 must hold. (b) Would I = ∅ hold, then r = 0, which is impossible because of r ∈C. I = {1, . . . ,n} would violate the existence of vanishing entries in r, as is guaranteed by Remark 23. (c) Using (a): When i ∈ I, then 0 < ri = si− t̂ and the claim follows. When i < I, then ri = 0, hence si− t̂ ≤ 0 and the claim follows. (d) eT r = eT s = λ1 because r,s ∈ H, hence using (c) yields\n0 = 〈e, s− r〉= ∑i∈I (si− ri)+∑i<I (si− ri) = ∑i∈I t̂ +∑i<Isi = dt̂ +λ1−∑i∈Isi,\nthus 〈r, s− r〉= ∑i∈Iri (si− ri) = ∑i∈I (si− t̂) t̂ = t̂ ( ∑i∈Isi−dt̂ ) = λ1t̂.\n(e) 〈mI, s− r〉= λ1/d ·∑i∈I (si− ri) = λ1/d ·∑i∈I t̂ = λ1t̂ with (c), and the claim follows with (d). (f) r ∈CI by definition of I. Using this, (c) and t̂ ≥ 0 from (a) yields\nλ22 = ‖s‖ 2 2 = ∑i∈Is2i +∑i<Is2i = ∑i∈I (ri + t̂)2 +∑i<Is2i\n> ∑i∈Ir2i +dt̂2 +2t̂∑i∈Iri = ‖r‖22 +dt̂2 +2λ1t̂ ≥ ‖r‖22 ,\nthus the claim holds using Corollary 27. (g) With (f) follows q ∈CI . Hence 〈q, s− r〉= ∑i∈I qi (si− ri) = t̂ ∑i∈I qi = λ1t̂ with (c), and the claims follow with (d) and Proposition 4. (h) Let p ∈ projD(s) and q ∈ projD(r). Then using (g) and Proposition 4 one obtains that ‖q− s‖22−‖p− s‖ 2 2 = ‖q− r‖ 2 2−‖p− r‖ 2 2 +2〈p− r, s− r〉. With (c) and (d) follows\n〈p− r, s− r〉= ∑i∈I pi (si− ri)+∑i<I pi (si− ri)−〈r, s− r〉= ∑i∈I pit̂ +∑i<I pisi−λ1t̂ = t̂ ( λ1−∑i<I pi ) +∑i<I pisi−λ1t̂ = ∑i<I pi (si− t̂)≤ 0.\nNow q∈ projD(r) yields ‖q− r‖ 2 2 ≤ ‖p− r‖ 2 2, and hence ‖q− s‖ 2 2−‖p− s‖ 2 2 ≤ 0, thus q∈ projD(s). Similarly, ‖q− s‖22−‖p− s‖2≥ 0 with p∈ projD(s), so ‖q− r‖ 2 2−‖p− r‖ 2 2≥−2〈p− r, s− r〉 ≥ 0, therefore p ∈ projD(r).\nThe following corollary states a similar result as in Theis et al. (2005). However, the proof here uses the notion of simplex projections instead of relying on pure analytical statements. The result presented here is stronger, as multiple entries of the vector can be set to zero simultaneously, while in Theis et al. (2005) at most one entry can be zeroed out in a single iteration.\nCorollary 29 Let s ∈ L\\C and p ∈ projD(s). Then pi = 0 for all i ∈ {1, . . . ,n} with si ≤ 0.\nProof Let i ∈ {1, . . . ,n} with si ≤ 0. Let r ∈ projC(s). With Lemma 28(a) follows ri = 0 because t̂ ≥ 0, and the claim follows with Lemma 28(h).\nThe final step is to meet the hypersphere constraint again. For this, the simplex projection r is projected onto the target hypersphere, simultaneously keeping already vanished entries at zero, yielding a point u. Lemma 30 gives an explicit formulation of this projection and shows that the solution set with respect to the projection onto D stays the same. Refer to Figure 11 for a sketch of the construction of u.\nLemma 30 Let s ∈ L \\C, r := projC(s) = max(s− t̂ · e, 0) with t̂ ∈ R≥0 using Lemma 28. Let I := { i ∈ {1, . . . ,n} | ri , 0} and d := |I|. Let u := mI +δ(r−mI) where δ := √ρI/‖r−mI‖2. Then:\n(a) u ∈ L and ui = 0 for all i < I, hence u ∈ LI .\n(b) projD(u)⊆CI .\n(c) u = projLI (r).\n(d) projD(u) = projD(r) = projD(s)⊆CI .\nProof (a) Clearly u∈H. With mI,r∈H and Remark 14 follows that 〈m, mI〉= 〈m, r〉= λ21/n. Moreover, 〈mI, mI〉= λ21/d and 〈r, mI〉= ∑i∈I ri · λ1/d = λ21/d, therefore 〈r, mI−m〉= 〈mI, mI−m〉. With u = (1−δ)mI +δr it is 〈u, mI−m〉= 〈mI, mI−m〉= λ21 (1/d− 1/n). Hence 〈u−mI, mI−m〉= 0. Further, ‖m−mI‖22 = ‖m‖ 2 2 +‖mI‖ 2 2−2〈m, mI〉= λ21 (1/d− 1/n).\nThus with Proposition 4, ‖u−m‖22 = ‖u−mI‖ 2 2+‖mI−m‖ 2 2 = ρI +λ21 (1/d− 1/n) = ρ, and with Lemma 15 follows u ∈ L. For i < I, one obtains ui = (1−δ)eTi mI +δri = 0, hence u ∈ LI . (b) If u ∈ C, then u ∈ D because of u ∈ L with (a), and hence u = projD(u). The claim then follows with ui = 0 for all i < I. If u <C, then let q ∈ projD(u). With Corollary 29 applied to u follows that qi = 0 for all i with ui ≤ 0, especially for all i < I. Hence the claim follows. (c) Write I = {i1, . . . , id} and consider ϕ : Rn→ Rd , (x1, . . . , xn)T 7→ (xi1 , . . . , xid )\nT . Further, let H̃ := {a ∈Rd | eT a = λ1 }, K̃ := {q ∈Rd | ‖q‖2 = λ2 }, L̃ := H̃ ∩ K̃ and D̃ := Rd≥0 ∩ H̃ ∩ K̃. Clearly, when xi = 0 for all i < I, then eT x = eT ϕ(x) and ‖x‖2 = ‖ϕ(x)‖2. Thus in this case membership of x in one of H, K, L or D implies membership of ϕ(x) in H̃, K̃, L̃ or D̃, respectively.\nApplication of Lemma 17 to ϕ(r) and ϕ(u) implies that ϕ(u) = projL̃(ϕ(r)). Let q ∈ LI , then ϕ(q) ∈ L̃, hence ‖ϕ(u)−ϕ(r)‖2 ≤ ‖ϕ(q)−ϕ(r)‖2. From i < I follows ri = ui = qi = 0, hence ‖u− r‖2 = ‖ϕ(u)−ϕ(r)‖2 and ‖q− r‖2 = ‖ϕ(q)−ϕ(r)‖2, and the claim follows.\n(d) For the converse of ϕ, let ψ : Rd → Rn, x̃ 7→ x where xi = 0 for all i < I and xi = x̃ j when there is a j ∈ {1, . . . ,d} with i = i j. Analogous to the above, membership of ỹ in one of H̃, K̃, L̃ or D̃ implies membership of ψ(ỹ) in H, K, L or D, respectively.\nWith Lemma 28(f) and Lemma 28(h) it is enough to show projD(u) = projD(r). Like in (c), from Lemma 17 follows as well that projD̃(ϕ(r)) = projD̃(ϕ(u)). Let p ∈ projD(u) and q ∈ projD(r), then p∈CI with (b) and q∈CI with Lemma 28(f), and thus ϕ(p),ϕ(q)∈ D̃. Assume ϕ(p) < projD̃(ϕ(u)), then there exists an a ∈ D̃ with ‖ψ(a)−u‖2 = ‖a−ϕ(u)‖2 < ‖ϕ(p)−ϕ(u)‖2 = ‖p−u‖2, violating the minimality of p. Hence ϕ(p) ∈ projD̃(ϕ(u)), and analogously follows ϕ(q) ∈ projD̃(ϕ(r)). Now projD̃(ϕ(r)) = projD̃(ϕ(u)) implies that ϕ(p) ∈ projD̃(ϕ(r)) and ϕ(q) ∈ projD̃(ϕ(u)). Thus, ‖p− r‖2 = ‖ϕ(p)−ϕ(r)‖2 = ‖ϕ(q)−ϕ(r)‖2 = ‖q− r‖2, so p ∈ projD(r), and one obtains analogously that q ∈ projD(u). Therefore projD(u) = projD(r).\nWith Lemma 30 a point u is constructed. If u ∈C, then it is already the solution for the projection onto D. Otherwise, Lemma 28 and Lemma 30 can be applied once more, gaining a new point u.\nLemma 28(b) states that the amount of nonzero entries of u must decrease, hence this process can be repeated for at most n iterations. If a point with only two non-vanishing entries results, it is guaranteed to be a solution by Proposition 22.\nC.4 Proof of Theorem 2 and Theorem 3\nUsing the previous results it can now be shown that the proposed Algorithm 1 actually computes a correct solution, and that the algorithm always terminates in finite time.\nProof of Theorem 2 For proving partial correctness, let x ∈ Rn be arbitrary. Lemma 13 yields projD(x) = projD(r) after line 1, and with Lemma 17 follows projD(x) = projD(s) after line 2. There is a pre-test loop in line 3, and it has to be shown that the loop-invariant is projD(x) = projD(s). At the beginning of the loop, s < Rn≥0 must hold, thus s ∈ L \\C. After line 4, projD(x) = projD(r) holds with Lemma 28. Then with Lemma 30, projD(x) = projD(s) is ensured after line 5, hence the loop-invariant holds. Thus, after the loop it is projD(x) = projD(s) and s ∈ D, so projD(x) = s. If r = m in line 2 or r = mI in line 5, s can be chosen to be any point from L or LI , respectively, for example the point given in Remark 18. In this case, the projection is not unique, but a valid representative is found.\nTo prove total correctness, it has to be shown that the loop in line 3 terminates. Remark 23 applied to CI guarantees that the number of nonzero entries in s is strictly less at the end of the loop than the number of nonzero entries upon entering the loop. Hence, at most n iterations of the loop can be carried out, and when |I| = 2 the solution is already in D with Proposition 22. Thus the algorithm terminates in finite time.\nIt remains to be shown that the optimized variant is also correct.\nProof of Theorem 3 First note that Algorithm 3 consists of a procedure proj_L carrying out projections onto L and LI in-place, and a main body. A function proj_C is called to obtain the information on how to perform projections onto C. This is carried out by Algorithm 2. Upon entry of the main body, the input vector x is sorted in descending order, yielding a vector y. The algorithm then operates on the sorted vector y, and undoes the sorting permutation at the end. Because H, L and C are permutation-invariant, the projections onto the respective sets are guaranteed to remain sorted with Lemma 9.\nTherefore, y has not to be sorted again for the simplex projection, as Algorithm 2 would require. Also note from Lemma 28 that in the simplex projection the smallest elements are set to zero, and the original Algorithm 1 continues working on the d non-vanishing entries. Because of the order-preservation, entries d + 1, . . . , n of y are zero, and all relevant information is concentrated in y1, . . . , yd . Therefore, Algorithm 3 can continue working on these first d entries only, and the index set of non-vanishing entries is always I = {1, . . . ,d}. As the nonzero elements are stored contiguously in memory, access to y can be realized as a small unit-stride array. This is more efficient than working on a large and sparsely populated vector. Therefore, the loop starting at line 13 corresponds to the loop starting at line 3 in Algorithm 1. At the end of the main body, the sorting permutation τ is inverted and the entries from the sorted result vector y are stored in a new vector s. Because yd+1, . . . , yn = 0, these entries can be ignored by setting the entire vector s to zero before-hand.\nThe proposed optimizations hence lead to the same solution which the original algorithm computes."
    }, {
      "heading" : "Appendix D. Analytical Properties of the Sparseness-Enforcing Projection Operator",
      "text" : "In this appendix, it is studied in which situations π≥0 and π as defined in Section 2.4 are differentiable, and hence continuous. Further, an explicit expression for their gradient is sought. It is clear by Theorem 2 that the projection of any point onto D can be written as finite composition of projections onto H, L, C and LI , respectively. In other words, for all points x ∈Rn \\R there exists a finite sequence of index sets I1, . . . , Ih ⊆ {1, . . . ,n} with I j ) I j+1 for j ∈ {1, . . . ,h−1} such that\nπ≥0(x) = [ j=h1 ( projLI j ◦projC ) ◦projL ◦projH ] (x),\nwhere j=h1 denotes iterated composition of functions, starting with j = h and decreasing until j = 1, that is π≥0(x) = projLIh (projC(· · ·projLI1 (projC(projL(projH(x)))) · · ·)). The sequence I1, . . . , Ih here depends on x. The intermediate goal is to show that this sequence remains fixed in a neighborhood of x, and that each projection in the chain is differentiable almost everywhere. This then implies differentiability of π≥0 except for a null set. Because of the close relationship of π with π≥0, π is then also differentiable almost everywhere as shown in the end of this appendix.\nThe projection onto H is differentiable everywhere, as is clear from its explicit formula given in Lemma 13. Considering L and LI for I ⊆ {1, . . . ,n}, the projection is unique and can be cast as functionRn→Rn unless the point to be projected is equal to the barycenters m and mI , respectively. By considering the explicit formulas given in Lemma 17 and Lemma 30, it is clear that these functions are differentiable as composition of differentiable functions. Thus only the projection onto the simplex C demands attention. Note that the number t̂ from Proposition 24 is equal to the mean value of the entries of the argument, that survive the projection, modulo an additive constant:\nProposition 31 Let x ∈ Rn \\C and p := projC(x). Then there is a set I ⊆ {1, . . . ,n} such that p = max(x− t̂ · e, 0) where t̂ = 1/|I| · (∑i∈I xi−λ1).\nProof Follows directly from Proposition 24 and Algorithm 2 by undoing the permutation τ.\nNote that when I = {1, . . . ,n}, this is very similar to the projection onto H, see Lemma 13. The next result states a condition under which I is locally constant, and hence identifies points where the projection onto C is differentiable with a closed form expression:\nLemma 32 Let x ∈ Rn \\C, and let p := projC(x), I ⊆ {1, . . . ,n} and t̂ ∈ R be given as in Proposition 31. When xi , t̂ for all i ∈ {1, . . . ,n}, then the following holds where u := ∑i∈I ei ∈ Rn and v := e−u ∈Rn are the indicator vectors of I and IC, respectively:\n(a) pi > 0 if and only if i ∈ I.\n(b) p = x+ 1/d · ( λ1−uT x ) u− v◦x, where ◦ denotes the Hadamard product and d := |I|.\n(c) There exists a constant ε > 0 and a neighborhood U := {s ∈Rn | ‖x− s‖2 < ε} of x, such that sgn(projC(s)) = sgn(p) for all s ∈U.\n(d) projC(s) = s+ 1/d · ( λ1−uT s ) u− v◦s for all s ∈U.\n(e) s 7→ projC(s) is differentiable in x.\nProof Only a sketch of a proof is presented here. (a) Follows from the characterization of t̂ given in Proposition 31. (b) The identity can be validated directly using (a) and Proposition 31. (c) Follows by choosing ε := 1/2 ·mini∈{1,...,n} |xi− t̂|, which is positive by requirement on x. (d) Validation follows like in (b) using (c). (e) The projection onto C can be written locally in closed form using (d). In the same neighborhood, the index set of vanishing entries of the projected points does not change. Hence, the projection is differentiable as a composition of differentiable functions.\nIt is clear that there are points in which s 7→ projC(s) is continuous but not differentiable, for example points that are projected onto one of the vertices of C. The structure in this situation is locally equivalent to that of the absolute value function. However, for every point where the projection onto C is not differentiable, a subtle change is sufficient to find a point where the projection is differentiable:\nLemma 33 Consider the function p : Rn \\C→C, s 7→ projC(s) and let x ∈Rn \\C be a point such that p is not differentiable in x. Then for all ε > 0 there exists a point y ∈Rn with ‖x− y‖2 < ε such that p is differentiable in y.\nProof Let t̂ ∈R be the separator from Proposition 31 for the projection onto C. Let the index set of all collisions with t̂ be denoted by J := { j ∈ {1, . . . ,n} | x j = t̂ }, which is nonempty with Lemma 32 because p is not differentiable in x. Define δ := ε/ √ 4|J| > 0 and consider y := x− δ∑ j∈J e j ∈ Rn. Clearly, ‖x− y‖2 = ε/2. From Proposition 31 follows that the separating t̂ for the projection onto C is independent of the entries of x with indices in J, as long as they are less than or equal to t̂. Because δ > 0, these entries in y are strictly smaller than t̂, hence p is differentiable in y with Lemma 32.\nTherefore the set on which s 7→ projC(s) is not differentiable forms a null set. The next result gathers the gradients of the individual projections involved in the computation of the sparseness-enforcing projection operator with respect to σ. Using the chain rule, the gradient of π≥0 can be derived afterwards as multiplication of the individual gradients.\nLemma 34 The individual projections for π≥0 are differentiable almost everywhere. Their gradients are given as follows:\n(a) ∂projH(x)∂x = En− 1/n · ee T , where En ∈Rn×n is the identity matrix. (b) ∂projL(x)∂x = √ρ\n‖x−m‖2\n( En− 1/‖x−m‖22 · (x−m)(x−m)T ) .\n(c) ∂projC(x)∂x = En− 1/d · uu T − diag(v). Here, I := { i ∈ {1, . . . ,n} | eTi projC(x) , 0} is the index\nset of nonzero entries of the projection onto C, d := |I|, u := ∑i∈I ei ∈Rn and v := e−u ∈Rn.\n(d) ∂projLI (x) ∂x = √ρI\n‖x−mI‖2\n( En− 1/‖x−mI‖22 · (x−mI)(x−mI)T ) .\nProof (a) Follows from the closed form expression in Lemma 13. (b) Lemma 17 yields projL(x) = m+ δ(x) · (x−m) with δ(x) =\n√ρ/‖x−m‖2. With the quotient rule follows ∂δ(x)/∂x =−√ρ/‖x−m‖32 · (x−m)T , as ρ does not depend on x. The claim then follows by application of the product rule.\n(c) Follows from Lemma 32, similar to (a), using v◦x = diag(v)x. (d) Follows exactly as in (b).\nClearly, the gradients for projH and for projL are special cases of the gradients of projC and projLI , respectively. Therefore, they need no separate handling in the computation of the overall gradient. Exploiting the special structure of the matrices involved and the readily sorted input as in Algorithm 3, the gradient computation can be further optimized. For the remainder of this appendix, let Oa×b ∈ {0}a×b and Ja×b ∈ {1}a×b denote the matrices with a rows and b columns where all entries equal zero and unity, respectively.\nTheorem 35 Let x ∈ Rn be sorted in descending order and π≥0 be differentiable in x. Let h ∈N denote the number of iterations Algorithm 3 needs to terminate. In every iteration of the algorithm, store the following values for i ∈ {1, . . . ,h}, where line numbers reference Algorithm 3:\n• di ∈N denoting the current dimensionality as determined by lines 12 and 14. • δi := √ ρ/ϕ ∈R where ρ and ϕ are determined in lines 2 and 3, respectively.\n• r(i) := y−mI ∈Rdi as computed in line 7.\nLet N := dh = ‖π≥0(x)‖0 denote the number of nonzero entries in the projection onto D, and define s(i) := ( eT1 r(i), . . . , e T Nr(i) )T ∈RN as the first N entries of each r(i). For i ∈ {1, . . . ,h} let Ai := δiEN− δi/di · JN×N−αis(i)s(i)T +αi/di · s(i)s(i)T JN×N ∈RN×N where αi := δi/‖r(i)‖22,\nand let A := ∏i=h1 Ai = Ah · · ·A1 ∈ RN×N . Then the gradient of π≥0 in x is diag ( A, O(n−N)×(n−N) ) , that is a block diagonal matrix where the quadratic submatrix with row and column indices from 1 to N is given by A, and where all other entries vanish.\nProof The gradient of projections onto H is merely a special case of projections onto C, which also applies to the respective projections onto L and LI , see Lemma 34. Hence, the very first iteration is a special case of iterations with i > 1. Consider one single iteration i ∈ {1, . . . ,h} of Algorithm 3, that is the computation of projLI ◦projC for some I ⊆ {1, . . . ,n}. Write d := di, δ := δi, α := αi and r := r(i) for short. Because the input vector x is sorted by requirement, all intermediate vectors that are projected are sorted as well using Lemma 9. Thus I = {1, . . . ,d} holds.\nWith Lemma 34, the gradient GC ∈ Rn×n of the projection onto both H and C is of the form GC := En−1/d ·uuT −diag(v), where u :=∑di=1 ei and v := e−u. Let q := (r1, . . . ,rd ,0, . . . ,0)\nT ∈Rn be a copy of r padded with zeros to achieve full dimensionality n. The gradient of the projection onto L, and in general LI , is given by GL := δEn−αqq ∈ Rn×n using Lemma 34. The gradient of the whole iteration is then given by the chain rule, yielding\nG := GLGC = δEn− δ/d ·uuT −δdiag(v)−αqqT +α/d ·qqT uuT +αqqT diag(v) ∈Rn×n.\nWrite O := O(n−d)×(n−d), then G is a block diagonal matrix of a matrix fromRd×d and O: Note that En−diag(v)= diag(Ed ,O), uuT = diag(Jd×d ,O), and qqT = diag(rrT ,O). Therefore, qqT diag(v)= diag(rrT ,O) · ( 0 0 0 En−d ) = 0, and qqT uuT = diag(rrT Jd×d ,O). Thus\nG = δdiag(Ed ,O)− δ/d ·diag(Jd×d ,O)−αdiag(rrT ,O)+α/d ·diag(rrT Jd×d ,O) = diag ( δEd− δ/d · Jd×d−αrrT +α/d · rrT Jd×d , O ) .\nBy denoting the gradient of iteration i by matrix Gi ∈ Rn×n for i ∈ {1, . . . ,h} and by application of the chain rule follows that the gradient of all iterations is given by ∏i=h1 Gi. In this matrix, all\nentries but the top left submatrix of dimensionality N×N are vanishing, where N = dh. This is because the according statement applies to Gi for the top left submatrix of dimensionality di× di, and d1 > · · ·> dh holds, and only the according entries survive the matrix multiplication. Therefore it is sufficient to compute only the top left N×N entries of the gradients of the individual iterations, as the remaining entries are not relevant for the final gradient. This is reflected by the definition of the matrices Ai for i ∈ {1, . . . ,h} from the claim.\nThe gradient can thus be computed using matrix-matrix multiplications, where the matrices are square and the edge length is the number of nonzero entries in the result of the projection. This computation is more efficient than using the n×n matrices of the individual projections. However, when the target degree of sparseness is low, and thus the amount of nonzero entries N in the result of the projection is large, gradient computation can become very inefficient. In practice, often only the product of the gradient with an arbitrary vector is required. In this case, the procedure can be sped up by exploiting the special structure of the gradient of π≥0: Corollary 36 Let x ∈Rn be sorted in descending order and π≥0 be differentiable in x. The product of the gradient of π≥0 in x with an arbitrary vector can be computed using vector operations only. Proof Note that because of the associativity of the matrix product it is enough to consider the product of the gradient G ∈Rn×n of one iteration of Algorithm 3 with one vector y ∈Rn. Because of the statements of Theorem 35, it suffices to consider the top left N×N entries of G and the first N entries of y, as all other entries vanish. Therefore let A := δEN− δ/d ·JN×N−αssT +α/d · ssT JN×N ∈ RN×N be the non-vanishing block of G as given by Theorem 35, let u := JN×1 ∈RN be the vector of ones such that uuT = JN×N , and let z := (y1, . . . , yN)\nT ∈RN denote the vector with the first entries of y. Using matrix product associativity and distributivity over multiplication with a scalar yields\nAz = δ(z− 1/d · 〈z, u〉 ·u)+α(1/d · 〈s, u〉〈z, u〉−〈s, z〉)s, where 〈z, u〉= ∑Ni=1 zi and 〈s, u〉= ∑Ni=1 si. Hence Az can be computed in-place from z by subtraction of a scalar value from all entries, rescaling by δ, and adding a scaled version of vector s.\nAlthough in Theorem 35 and Corollary 36 it was necessary that the input vector is sorted, the general case can easily be recovered:\nProposition 37 Let x ∈Rn be a point, τ ∈ Sn such that y := Pτx ∈Rn is sorted in descending order and π≥0 be differentiable in y with gradient G ∈Rn×n. Then π≥0 is also differentiable in x, and the gradient is PTτ GPτ. Proof Follows with PTτ = Pτ−1 = P−1τ , π≥0(x) = PTτ π≥0(Pτx) = Pτπ≥0(y) and the chain rule.\nLikewise, the gradient for the unrestricted projection π can be computed from the gradient for π≥0: Proposition 38 Let x ∈Rn be a point such that π≥0 is differentiable in |x| with gradient G ∈Rn×n. Let s ∈ {±1}n be given such that π(x) = s◦π≥0 (|x|). Then π is differentiable in x, and the gradient is diag(s)Gdiag(s).\nProof Follows analogously to Proposition 37, using |x|= s◦x = diag(s)x.\nSumming up, the gradient of the projection onto S(λ1,λ2)≥0 and S (λ1,λ2) can be computed efficiently by bookkeeping a few values as discussed in Theorem 35, and applying simple operations to recover the general case. When only the product of the gradient with a vector is required, the computation can be made more efficient as stated in Corollary 36. Direct application of Theorem 35 should be avoided in this situation because of the high computational complexity."
    }, {
      "heading" : "Appendix E. Gradients for SOAE Learning",
      "text" : "The objective function ESOAE is a convex combination of two similarity measures sR and sC. The degrees of freedom W , Wout and θout of the SOAE architecture should be tuned by gradient-based methods to minimize these functions. This appendix reports the gradient information needed for reproduction of the experiments. The first statement addresses the reconstruction module.\nProposition 39 It is (∂sR(x̃, x)/∂W)T = xgW f ′(u)+gT hT ∈Rd×n where g := ∂sR(x̃,x)/∂x̃ ∈R1×d is the gradient of the similarity measure with respect to its first argument. Additionally, (∂sR(x̃, x)/∂Wout)T = 0 ∈Rn×c and ∂sR(x̃, x)/∂θout = 0 ∈R1×c.\nProof As sR does not depend on Wout or θout, the respective gradients vanish. The symmetry between encoding and decoding yields x̃ :=W · f ( W T x ) . The gradient for W follows using the chain rule and the product rule for matrix calculus, see Neudecker (1969) and Vetter (1970).\nThe correlation coefficient is the recommended choice for the similarity measure of the reconstruction module because it is normed and invariant to affine-linear transformations. It is also differentiable almost everywhere:\nProposition 40 If sR is the correlation coefficient and x, x̃ ∈Rd \\{0}, then( ∂sR(x̃,x)\n∂x̃\n)T = 1√\nλµ\n( x− 〈e, x〉d e ) − sR(x̃,x)λ ( x̃− 〈e, x̃〉d e ) ∈Rd ,\nwhere all entries of e ∈Rd are unity, λ := ‖x̃‖22− 1/d · 〈e, x̃〉 2 ∈R and µ := ‖x‖22− 1/d · 〈e, x〉 2 ∈R.\nProof One obtains √\nλµ · sR(x̃,x) = 〈x, x̃〉− 1/d · 〈e, x̃〉〈e, x〉 because sR is the correlation coefficient. The claim then follows with the quotient rule.\nThe gradients of the similarity measure for classification capabilities are essentially equal to those of an ordinary two-layer neural network, and can be computed using the back-propagation algorithm (Rumelhart et al., 1986). However, the pairing of the softmax transfer function with the crossentropy error function provides a particularly simple structure of the gradient (Dunne and Campbell, 1997). For completeness, the gradients of the classification module of SOAE are summarized:\nProposition 41 If sC is the cross-entropy error function, g is the softmax transfer function and the target vector for classification t is a one-of-c code, then (∂sC(y, t)/∂Wout)T = h · (y− t)T ∈ Rn×c, ∂sC(y, t)/∂θout = (y− t)T ∈R1×c and (∂sC(y, t)/∂W)T = x · ( (y− t)TW Tout f ′(u) ) ∈Rd×n.\nProof Basic matrix calculus (Neudecker, 1969; Vetter, 1970) yields ∂sC(y, t)/∂θout =(∂sC(y, t)/∂y) ·g′(y), (∂sC(y, t)/∂Wout) T = h · (∂sC(y, t)/∂θout) and (∂sC(y, t)/∂W)T = x · ( (∂sC(y, t)/∂θout) ·W Tout f ′(u) ) . By requirement ∂sC(y, t)/∂y =−(t}y)T , where } denotes the element-wise quotient, g′(y) = diag(y)− yyT and ∑ci=1 ti = 1. Therefore (∂sC(y, t)/∂θout) T = ( yyT −diag(y) ) ·(t}y) = y · 〈y, t}y〉−y◦ t}y= y−t using 〈y, t}y〉= ∑ci=1 yi · ti/yi = 1, and the claim follows.\nAs ESOAE is a convex combination of the reconstruction error and the classification error, its overall gradient follows immediately from Proposition 39 and Proposition 41. Proposition 40, the results from Appendix D, and the gradient of the L0 projection as described in Section 2.4 can then be used to compute the explicit gradients for the procedure proposed in this paper."
    } ],
    "references" : [ {
      "title" : "Probabilistic index: An intuitive non-parametric approach to measuring the size of treatment effects",
      "author" : [ "L. Acion", "J.J. Peterson", "S. Temple", "S. Arndt" ],
      "venue" : "Statistics in Medicine,",
      "citeRegEx" : "Acion et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Acion et al\\.",
      "year" : 2006
    }, {
      "title" : "Internal representations for associative memory",
      "author" : [ "E.B. Baum", "J. Moody", "F. Wilczek" ],
      "venue" : "Biological Cybernetics,",
      "citeRegEx" : "Baum et al\\.,? \\Q1988\\E",
      "shortCiteRegEx" : "Baum et al\\.",
      "year" : 1988
    }, {
      "title" : "Nonlinear Programming",
      "author" : [ "D.P. Bertsekas" ],
      "venue" : "Athena Scientific, 2nd edition,",
      "citeRegEx" : "Bertsekas.,? \\Q1999\\E",
      "shortCiteRegEx" : "Bertsekas.",
      "year" : 1999
    }, {
      "title" : "Neural Networks for Pattern Recognition",
      "author" : [ "C.M. Bishop" ],
      "venue" : null,
      "citeRegEx" : "Bishop.,? \\Q1995\\E",
      "shortCiteRegEx" : "Bishop.",
      "year" : 1995
    }, {
      "title" : "A simple, efficient and near optimal algorithm for compressed sensing",
      "author" : [ "T. Blumensath", "M.E. Davies" ],
      "venue" : "In Proceedings of the IEEE International Conference on Acoustics, Speech and Signal Processing,",
      "citeRegEx" : "Blumensath and Davies.,? \\Q2009\\E",
      "shortCiteRegEx" : "Blumensath and Davies.",
      "year" : 2009
    }, {
      "title" : "Large scale online learning",
      "author" : [ "L. Bottou", "Y. LeCun" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Bottou and LeCun.,? \\Q2004\\E",
      "shortCiteRegEx" : "Bottou and LeCun.",
      "year" : 2004
    }, {
      "title" : "Differentiable sparse coding",
      "author" : [ "D.M. Bradley", "J.A. Bagnell" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Bradley and Bagnell.,? \\Q2009\\E",
      "shortCiteRegEx" : "Bradley and Bagnell.",
      "year" : 2009
    }, {
      "title" : "Projection onto a simplex",
      "author" : [ "Y. Chen", "X. Ye" ],
      "venue" : "Technical Report arXiv:1101.6081v2, University of Florida,",
      "citeRegEx" : "Chen and Ye.,? \\Q2011\\E",
      "shortCiteRegEx" : "Chen and Ye.",
      "year" : 2011
    }, {
      "title" : "Deep, big, simple neural nets for handwritten digit recognition",
      "author" : [ "D.C. Cireşan", "U. Meier", "L.M. Gambardella", "J. Schmidhuber" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "Cireşan et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Cireşan et al\\.",
      "year" : 2010
    }, {
      "title" : "Multi-column deep neural networks for image classification",
      "author" : [ "D.C. Cireşan", "U. Meier", "J. Schmidhuber" ],
      "venue" : "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
      "citeRegEx" : "Cireşan et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Cireşan et al\\.",
      "year" : 2012
    }, {
      "title" : "Approximation by superpositions of a sigmoidal function",
      "author" : [ "G. Cybenko" ],
      "venue" : "Mathematics of Control, Signals, and Systems,",
      "citeRegEx" : "Cybenko.,? \\Q1989\\E",
      "shortCiteRegEx" : "Cybenko.",
      "year" : 1989
    }, {
      "title" : "Training invariant support vector machines",
      "author" : [ "D. DeCoste", "B. Schölkopf" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "DeCoste and Schölkopf.,? \\Q2002\\E",
      "shortCiteRegEx" : "DeCoste and Schölkopf.",
      "year" : 2002
    }, {
      "title" : "Statistical comparisons of classifiers over multiple data sets",
      "author" : [ "J. Demšar" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Demšar.,? \\Q2006\\E",
      "shortCiteRegEx" : "Demšar.",
      "year" : 2006
    }, {
      "title" : "For most large underdetermined systems of linear equations the minimal `1-norm solution is also the sparsest solution",
      "author" : [ "D.L. Donoho" ],
      "venue" : "Communications on Pure and Applied Mathematics,",
      "citeRegEx" : "Donoho.,? \\Q2006\\E",
      "shortCiteRegEx" : "Donoho.",
      "year" : 2006
    }, {
      "title" : "The estimation of Pr(Y < X) in the normal case",
      "author" : [ "F. Downton" ],
      "venue" : "Technometrics, 15(3):551–558,",
      "citeRegEx" : "Downton.,? \\Q1973\\E",
      "shortCiteRegEx" : "Downton.",
      "year" : 1973
    }, {
      "title" : "Efficient projections onto the `1-ball for learning in high dimensions",
      "author" : [ "J. Duchi", "S. Shalev-Shwartz", "Y. Singer", "T. Chandra" ],
      "venue" : "In Proceedings of the International Conference on Machine Learning,",
      "citeRegEx" : "Duchi et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Duchi et al\\.",
      "year" : 2008
    }, {
      "title" : "On the pairing of the softmax activation and cross-entropy penalty functions and the derivation of the softmax activation function",
      "author" : [ "R.A. Dunne", "N.A. Campbell" ],
      "venue" : "In Proceedings of the Australasian Conference on Neural Networks,",
      "citeRegEx" : "Dunne and Campbell.,? \\Q1997\\E",
      "shortCiteRegEx" : "Dunne and Campbell.",
      "year" : 1997
    }, {
      "title" : "An algorithm for restricted least squares regression",
      "author" : [ "R.L. Dykstra" ],
      "venue" : "Journal of the American Statistical Association,",
      "citeRegEx" : "Dykstra.,? \\Q1983\\E",
      "shortCiteRegEx" : "Dykstra.",
      "year" : 1983
    }, {
      "title" : "An algorithm for least squares projections onto the intersection of translated, convex cones",
      "author" : [ "R.L. Dykstra", "J.P. Boyle" ],
      "venue" : "Journal of Statistical Planning and Inference,",
      "citeRegEx" : "Dykstra and Boyle.,? \\Q1987\\E",
      "shortCiteRegEx" : "Dykstra and Boyle.",
      "year" : 1987
    }, {
      "title" : "A note on the group lasso and a sparse group lasso",
      "author" : [ "J. Friedman", "T. Hastie", "R. Tibshirani" ],
      "venue" : "Technical Report arXiv:1001.0736v1,",
      "citeRegEx" : "Friedman et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Friedman et al\\.",
      "year" : 2010
    }, {
      "title" : "On the approximate realization of continuous mappings by neural networks",
      "author" : [ "K. Funahashi" ],
      "venue" : "Neural Networks,",
      "citeRegEx" : "Funahashi.,? \\Q1989\\E",
      "shortCiteRegEx" : "Funahashi.",
      "year" : 1989
    }, {
      "title" : "Neural networks and the bias/variance dilemma",
      "author" : [ "S. Geman", "E. Bienenstock", "R. Doursat" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "Geman et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Geman et al\\.",
      "year" : 1992
    }, {
      "title" : "Deep sparse rectifier neural networks",
      "author" : [ "X. Glorot", "A. Bordes", "Y. Bengio" ],
      "venue" : "In Proceedings of the International Conference on Artificial Intelligence and Statistics,",
      "citeRegEx" : "Glorot et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Glorot et al\\.",
      "year" : 2011
    }, {
      "title" : "Learning fast approximations of sparse coding",
      "author" : [ "K. Gregor", "Y. LeCun" ],
      "venue" : "In Proceedings of the International Conference on Machine Learning,",
      "citeRegEx" : "Gregor and LeCun.,? \\Q2010\\E",
      "shortCiteRegEx" : "Gregor and LeCun.",
      "year" : 2010
    }, {
      "title" : "Probability of the superior outcome of one treatment over another",
      "author" : [ "R.J. Grissom" ],
      "venue" : "Journal of Applied Psychology,",
      "citeRegEx" : "Grissom.,? \\Q1994\\E",
      "shortCiteRegEx" : "Grissom.",
      "year" : 1994
    }, {
      "title" : "Learning sparse representations by non-negative matrix factorization and sequential cone programming",
      "author" : [ "M. Heiler", "C. Schnörr" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Heiler and Schnörr.,? \\Q2006\\E",
      "shortCiteRegEx" : "Heiler and Schnörr.",
      "year" : 2006
    }, {
      "title" : "A fast learning algorithm for deep belief nets",
      "author" : [ "G.E. Hinton", "S. Osindero", "Y.W. Teh" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "Hinton et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Hinton et al\\.",
      "year" : 2006
    }, {
      "title" : "At what points is the projection mapping differentiable",
      "author" : [ "J.-B. Hiriart-Urruty" ],
      "venue" : "The American Mathematical Monthly,",
      "citeRegEx" : "Hiriart.Urruty.,? \\Q1982\\E",
      "shortCiteRegEx" : "Hiriart.Urruty.",
      "year" : 1982
    }, {
      "title" : "Multiple Comparison Procedures",
      "author" : [ "Y. Hochberg", "A.C. Tamhane" ],
      "venue" : null,
      "citeRegEx" : "Hochberg and Tamhane.,? \\Q1987\\E",
      "shortCiteRegEx" : "Hochberg and Tamhane.",
      "year" : 1987
    }, {
      "title" : "Multilayer feedforward networks are universal approximators",
      "author" : [ "K. Hornik", "M. Stinchcombe", "H. White" ],
      "venue" : "Neural Networks,",
      "citeRegEx" : "Hornik et al\\.,? \\Q1989\\E",
      "shortCiteRegEx" : "Hornik et al\\.",
      "year" : 1989
    }, {
      "title" : "Analysis of a complex of statistical variables into principal components",
      "author" : [ "H. Hotelling" ],
      "venue" : "Journal of Educational Psychology,",
      "citeRegEx" : "Hotelling.,? \\Q1933\\E",
      "shortCiteRegEx" : "Hotelling.",
      "year" : 1933
    }, {
      "title" : "Non-negative matrix factorization with sparseness constraints",
      "author" : [ "P.O. Hoyer" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Hoyer.,? \\Q2004\\E",
      "shortCiteRegEx" : "Hoyer.",
      "year" : 2004
    }, {
      "title" : "Receptive fields of single neurones in the cat’s striate cortex",
      "author" : [ "D.H. Hubel", "T.N. Wiesel" ],
      "venue" : "Journal of Physiology,",
      "citeRegEx" : "Hubel and Wiesel.,? \\Q1959\\E",
      "shortCiteRegEx" : "Hubel and Wiesel.",
      "year" : 1959
    }, {
      "title" : "Comparing measures of sparsity",
      "author" : [ "N. Hurley", "S. Rickard" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "Hurley and Rickard.,? \\Q2009\\E",
      "shortCiteRegEx" : "Hurley and Rickard.",
      "year" : 2009
    }, {
      "title" : "Sparse code shrinkage: Denoising by nonlinear maximum likelihood estimation",
      "author" : [ "A. Hyvärinen", "P.O. Hoyer", "E. Oja" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Hyvärinen et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Hyvärinen et al\\.",
      "year" : 1999
    }, {
      "title" : "How does connectivity between cortical areas depend on brain size? Implications for efficient computation",
      "author" : [ "J. Karbowski" ],
      "venue" : "Journal of Computational Neuroscience,",
      "citeRegEx" : "Karbowski.,? \\Q2003\\E",
      "shortCiteRegEx" : "Karbowski.",
      "year" : 2003
    }, {
      "title" : "Correlation matrix memories",
      "author" : [ "T. Kohonen" ],
      "venue" : "IEEE Transactions on Computers,",
      "citeRegEx" : "Kohonen.,? \\Q1972\\E",
      "shortCiteRegEx" : "Kohonen.",
      "year" : 1972
    }, {
      "title" : "Use of ranks in one-criterion variance analysis",
      "author" : [ "W.H. Kruskal", "W.A. Wallis" ],
      "venue" : "Journal of the American Statistical Association,",
      "citeRegEx" : "Kruskal and Wallis.,? \\Q1952\\E",
      "shortCiteRegEx" : "Kruskal and Wallis.",
      "year" : 1952
    }, {
      "title" : "Matrix Analysis for Scientists and Engineers",
      "author" : [ "A.J. Laub" ],
      "venue" : "Society for Industrial and Applied Mathematics,",
      "citeRegEx" : "Laub.,? \\Q2004\\E",
      "shortCiteRegEx" : "Laub.",
      "year" : 2004
    }, {
      "title" : "The MNIST database of handwritten digits",
      "author" : [ "Y. LeCun", "C. Cortes" ],
      "venue" : null,
      "citeRegEx" : "LeCun and Cortes.,? \\Q1998\\E",
      "shortCiteRegEx" : "LeCun and Cortes.",
      "year" : 1998
    }, {
      "title" : "Optimal brain damage",
      "author" : [ "Y. LeCun", "J.S. Denker", "S.A. Solla" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "LeCun et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "LeCun et al\\.",
      "year" : 1990
    }, {
      "title" : "Learning the parts of objects by nonnegative matrix factorization",
      "author" : [ "D.D. Lee", "H.S. Seung" ],
      "venue" : null,
      "citeRegEx" : "Lee and Seung.,? \\Q1999\\E",
      "shortCiteRegEx" : "Lee and Seung.",
      "year" : 1999
    }, {
      "title" : "Robust tests for equality of variances. In Contributions to Probability and Statistics: Essays in Honor of Harold Hotelling, pages 278–292",
      "author" : [ "H. Levene" ],
      "venue" : null,
      "citeRegEx" : "Levene.,? \\Q1960\\E",
      "shortCiteRegEx" : "Levene.",
      "year" : 1960
    }, {
      "title" : "Learning spatially localized, parts-based representation",
      "author" : [ "S.Z. Li", "X. Hou", "H. Zhang", "Q. Cheng" ],
      "venue" : "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
      "citeRegEx" : "Li et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Li et al\\.",
      "year" : 2001
    }, {
      "title" : "Efficient euclidean projections in linear time",
      "author" : [ "J. Liu", "J. Ye" ],
      "venue" : "In Proceedings of the International Conference on Machine Learning,",
      "citeRegEx" : "Liu and Ye.,? \\Q2009\\E",
      "shortCiteRegEx" : "Liu and Ye.",
      "year" : 2009
    }, {
      "title" : "Efficient `1/`q norm regularization",
      "author" : [ "J. Liu", "J. Ye" ],
      "venue" : "Technical Report arXiv:1009.4766v1,",
      "citeRegEx" : "Liu and Ye.,? \\Q2010\\E",
      "shortCiteRegEx" : "Liu and Ye.",
      "year" : 2010
    }, {
      "title" : "Supervised dictionary learning",
      "author" : [ "J. Mairal", "F. Bach", "J. Ponce", "G. Sapiro", "A. Zisserman" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Mairal et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Mairal et al\\.",
      "year" : 2009
    }, {
      "title" : "Online learning for matrix factorization and sparse coding",
      "author" : [ "J. Mairal", "F. Bach", "J. Ponce", "G. Sapiro" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Mairal et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Mairal et al\\.",
      "year" : 2010
    }, {
      "title" : "Physiology and anatomy of synaptic connections between thick tufted pyramidal neurones in the developing rat neocortex",
      "author" : [ "H. Markram", "J. Lübke", "M. Frotscher", "A. Roth", "B. Sakmann" ],
      "venue" : "Journal of Physiology,",
      "citeRegEx" : "Markram et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Markram et al\\.",
      "year" : 1997
    }, {
      "title" : "Synaptic transmission between individual pyramidal neurons of the rat visual cortex in vitro",
      "author" : [ "A. Mason", "A. Nicoll", "K. Stratford" ],
      "venue" : "Journal of Neuroscience,",
      "citeRegEx" : "Mason et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Mason et al\\.",
      "year" : 1991
    }, {
      "title" : "A finite algorithm for finding the projection of a point onto the canonical simplex of Rn",
      "author" : [ "C. Michelot" ],
      "venue" : "Journal of Optimization Theory and Applications,",
      "citeRegEx" : "Michelot.,? \\Q1986\\E",
      "shortCiteRegEx" : "Michelot.",
      "year" : 1986
    }, {
      "title" : "Multiclass object recognition with sparse, localized features",
      "author" : [ "J. Mutch", "D.G. Lowe" ],
      "venue" : "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
      "citeRegEx" : "Mutch and Lowe.,? \\Q2006\\E",
      "shortCiteRegEx" : "Mutch and Lowe.",
      "year" : 2006
    }, {
      "title" : "Sparse approximate solutions to linear systems",
      "author" : [ "B.K. Natarajan" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "Natarajan.,? \\Q1995\\E",
      "shortCiteRegEx" : "Natarajan.",
      "year" : 1995
    }, {
      "title" : "Some theorems on matrix differentiation with special reference to Kronecker matrix products",
      "author" : [ "H. Neudecker" ],
      "venue" : "Journal of the American Statistical Association,",
      "citeRegEx" : "Neudecker.,? \\Q1969\\E",
      "shortCiteRegEx" : "Neudecker.",
      "year" : 1969
    }, {
      "title" : "Emergence of simple-cell receptive field properties by learning a sparse code for natural images",
      "author" : [ "B.A. Olshausen", "D.J. Field" ],
      "venue" : null,
      "citeRegEx" : "Olshausen and Field.,? \\Q1996\\E",
      "shortCiteRegEx" : "Olshausen and Field.",
      "year" : 1996
    }, {
      "title" : "Sparse coding of sensory inputs",
      "author" : [ "B.A. Olshausen", "D.J. Field" ],
      "venue" : "Current Opinion in Neurobiology,",
      "citeRegEx" : "Olshausen and Field.,? \\Q2004\\E",
      "shortCiteRegEx" : "Olshausen and Field.",
      "year" : 2004
    }, {
      "title" : "Positive matrix factorization: A non-negative factor model with optimal utilization of error estimates of data",
      "author" : [ "P. Paatero", "U. Tapper" ],
      "venue" : "values. Environmetrics,",
      "citeRegEx" : "Paatero and Tapper.,? \\Q1994\\E",
      "shortCiteRegEx" : "Paatero and Tapper.",
      "year" : 1994
    }, {
      "title" : "On associative memory",
      "author" : [ "G. Palm" ],
      "venue" : "Biological Cybernetics,",
      "citeRegEx" : "Palm.,? \\Q1980\\E",
      "shortCiteRegEx" : "Palm.",
      "year" : 1980
    }, {
      "title" : "Multiple comparison procedures applied to model selection",
      "author" : [ "J. Pizarro", "E. Guerrero", "P.L. Galindo" ],
      "venue" : null,
      "citeRegEx" : "Pizarro et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Pizarro et al\\.",
      "year" : 2002
    }, {
      "title" : "An efficient projection for l1,∞ regularization",
      "author" : [ "A. Quattoni", "X. Carreras", "M. Collins", "T. Darrell" ],
      "venue" : "In Proceedings of the International Conference on Machine Learning,",
      "citeRegEx" : "Quattoni et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Quattoni et al\\.",
      "year" : 2009
    }, {
      "title" : "Sparse feature learning for deep belief networks",
      "author" : [ "M. Ranzato", "Y. Boureau", "Y. LeCun" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Ranzato et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Ranzato et al\\.",
      "year" : 2008
    }, {
      "title" : "A network that uses few active neurones to code visual input predicts the diverse shapes of cortical receptive fields",
      "author" : [ "M. Rehn", "F.T. Sommer" ],
      "venue" : "Journal of Computational Neuroscience,",
      "citeRegEx" : "Rehn and Sommer.,? \\Q2007\\E",
      "shortCiteRegEx" : "Rehn and Sommer.",
      "year" : 2007
    }, {
      "title" : "Thirteen ways to look at the correlation coefficient",
      "author" : [ "J.L. Rodgers", "W.A. Nicewander" ],
      "venue" : "The American Statistician,",
      "citeRegEx" : "Rodgers and Nicewander.,? \\Q1988\\E",
      "shortCiteRegEx" : "Rodgers and Nicewander.",
      "year" : 1988
    }, {
      "title" : "Learning representations by back-propagating",
      "author" : [ "D.E. Rumelhart", "G.E. Hinton", "R.J. Williams" ],
      "venue" : "errors. Nature,",
      "citeRegEx" : "Rumelhart et al\\.,? \\Q1986\\E",
      "shortCiteRegEx" : "Rumelhart et al\\.",
      "year" : 1986
    }, {
      "title" : "Support Vector Learning",
      "author" : [ "B. Schölkopf" ],
      "venue" : "PhD thesis, Technische Universität Berlin,",
      "citeRegEx" : "Schölkopf.,? \\Q1997\\E",
      "shortCiteRegEx" : "Schölkopf.",
      "year" : 1997
    }, {
      "title" : "An analysis of variance test for normality (complete samples)",
      "author" : [ "S.S. Shapiro", "M.B. Wilk" ],
      "venue" : null,
      "citeRegEx" : "Shapiro and Wilk.,? \\Q1965\\E",
      "shortCiteRegEx" : "Shapiro and Wilk.",
      "year" : 1965
    }, {
      "title" : "Best practices for convolutional neural networks applied to visual document analysis",
      "author" : [ "P.Y. Simard", "D. Steinkraus", "J.C. Platt" ],
      "venue" : "In Proceedings of the International Conference on Document Analysis and Recognition,",
      "citeRegEx" : "Simard et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Simard et al\\.",
      "year" : 2003
    }, {
      "title" : "Fast projections onto mixed-norm balls with applications",
      "author" : [ "S. Sra" ],
      "venue" : "Data Mining and Knowledge Discovery,",
      "citeRegEx" : "Sra.,? \\Q2012\\E",
      "shortCiteRegEx" : "Sra.",
      "year" : 2012
    }, {
      "title" : "Sparseness by iterative projections onto spheres",
      "author" : [ "F.J. Theis", "T. Tanaka" ],
      "venue" : "In Proceedings of the IEEE International Conference on Acoustics, Speech and Signal Processing,",
      "citeRegEx" : "Theis and Tanaka.,? \\Q2006\\E",
      "shortCiteRegEx" : "Theis and Tanaka.",
      "year" : 2006
    }, {
      "title" : "First results on uniqueness of sparse non-negative matrix factorization",
      "author" : [ "F.J. Theis", "K. Stadlthanner", "T. Tanaka" ],
      "venue" : "In Proceedings of the European Signal Processing Conference,",
      "citeRegEx" : "Theis et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Theis et al\\.",
      "year" : 2005
    }, {
      "title" : "Supervised matrix factorization with sparseness constraints and fast inference",
      "author" : [ "M. Thom", "R. Schweiger", "G. Palm" ],
      "venue" : "In Proceedings of the International Joint Conference on Neural Networks,",
      "citeRegEx" : "Thom et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Thom et al\\.",
      "year" : 2011
    }, {
      "title" : "Training of sparsely connected MLPs",
      "author" : [ "M. Thom", "R. Schweiger", "G. Palm" ],
      "venue" : "In Lecture Notes in Computer Science,",
      "citeRegEx" : "Thom et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Thom et al\\.",
      "year" : 2011
    }, {
      "title" : "Group sparsity via linear-time projection",
      "author" : [ "E. van den Berg", "M. Schmidt", "M.P. Friedlander", "K. Murphy" ],
      "venue" : "Technical Report TR-2008-09,",
      "citeRegEx" : "Berg et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Berg et al\\.",
      "year" : 2008
    }, {
      "title" : "Derivative operations on matrices",
      "author" : [ "W.J. Vetter" ],
      "venue" : "IEEE Transactions on Automatic Control,",
      "citeRegEx" : "Vetter.,? \\Q1970\\E",
      "shortCiteRegEx" : "Vetter.",
      "year" : 1970
    }, {
      "title" : "Sparse coding and decorrelation in primary visual cortex during natural vision",
      "author" : [ "W.E. Vinje", "J.L. Gallant" ],
      "venue" : null,
      "citeRegEx" : "Vinje and Gallant.,? \\Q2000\\E",
      "shortCiteRegEx" : "Vinje and Gallant.",
      "year" : 2000
    }, {
      "title" : "Functional Operators, Volume II: The Geometry of Orthogonal Spaces",
      "author" : [ "J. von Neumann" ],
      "venue" : null,
      "citeRegEx" : "Neumann.,? \\Q1950\\E",
      "shortCiteRegEx" : "Neumann.",
      "year" : 1950
    }, {
      "title" : "Use of the zero-norm with linear models and kernel methods",
      "author" : [ "J. Weston", "A. Elisseeff", "B. Schölkopf", "M. Tipping" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Weston et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Weston et al\\.",
      "year" : 2003
    }, {
      "title" : "The general inefficiency of batch training for gradient descent learning",
      "author" : [ "D.R. Wilson", "T.R. Martinez" ],
      "venue" : "Neural Networks,",
      "citeRegEx" : "Wilson and Martinez.,? \\Q2003\\E",
      "shortCiteRegEx" : "Wilson and Martinez.",
      "year" : 2003
    }, {
      "title" : "Regularization and variable selection via the elastic net",
      "author" : [ "H. Zou", "T. Hastie" ],
      "venue" : "Journal of the Royal Statistical Society: Series B (Statistical Methodology),",
      "citeRegEx" : "Zou and Hastie.,? \\Q2005\\E",
      "shortCiteRegEx" : "Zou and Hastie.",
      "year" : 2005
    } ],
    "referenceMentions" : [ {
      "referenceID" : 32,
      "context" : "Both properties have been observed in mammalian brains (Hubel and Wiesel, 1959; Olshausen and Field, 2004; Mason et al., 1991; Markram et al., 1997) and have inspired a variety of machine learning algorithms.",
      "startOffset" : 55,
      "endOffset" : 148
    }, {
      "referenceID" : 55,
      "context" : "Both properties have been observed in mammalian brains (Hubel and Wiesel, 1959; Olshausen and Field, 2004; Mason et al., 1991; Markram et al., 1997) and have inspired a variety of machine learning algorithms.",
      "startOffset" : 55,
      "endOffset" : 148
    }, {
      "referenceID" : 49,
      "context" : "Both properties have been observed in mammalian brains (Hubel and Wiesel, 1959; Olshausen and Field, 2004; Mason et al., 1991; Markram et al., 1997) and have inspired a variety of machine learning algorithms.",
      "startOffset" : 55,
      "endOffset" : 148
    }, {
      "referenceID" : 48,
      "context" : "Both properties have been observed in mammalian brains (Hubel and Wiesel, 1959; Olshausen and Field, 2004; Mason et al., 1991; Markram et al., 1997) and have inspired a variety of machine learning algorithms.",
      "startOffset" : 55,
      "endOffset" : 148
    }, {
      "referenceID" : 32,
      "context" : "Given small patches from images of natural scenes, the model is able to produce Gabor-like filters, resembling properties of simple cells found in mammalian primary visual cortex (Hubel and Wiesel, 1959; Vinje and Gallant, 2000).",
      "startOffset" : 179,
      "endOffset" : 228
    }, {
      "referenceID" : 74,
      "context" : "Given small patches from images of natural scenes, the model is able to produce Gabor-like filters, resembling properties of simple cells found in mammalian primary visual cortex (Hubel and Wiesel, 1959; Vinje and Gallant, 2000).",
      "startOffset" : 179,
      "endOffset" : 228
    }, {
      "referenceID" : 32,
      "context" : "Both properties have been observed in mammalian brains (Hubel and Wiesel, 1959; Olshausen and Field, 2004; Mason et al., 1991; Markram et al., 1997) and have inspired a variety of machine learning algorithms. A notable result was achieved through the sparse coding model of Olshausen and Field (1996). Given small patches from images of natural scenes, the model is able to produce Gabor-like filters, resembling properties of simple cells found in mammalian primary visual cortex (Hubel and Wiesel, 1959; Vinje and Gallant, 2000).",
      "startOffset" : 56,
      "endOffset" : 301
    }, {
      "referenceID" : 32,
      "context" : "Both properties have been observed in mammalian brains (Hubel and Wiesel, 1959; Olshausen and Field, 2004; Mason et al., 1991; Markram et al., 1997) and have inspired a variety of machine learning algorithms. A notable result was achieved through the sparse coding model of Olshausen and Field (1996). Given small patches from images of natural scenes, the model is able to produce Gabor-like filters, resembling properties of simple cells found in mammalian primary visual cortex (Hubel and Wiesel, 1959; Vinje and Gallant, 2000). Another example is the optimal brain damage method of LeCun et al. (1990), which can be used to prune synaptic connections in a neural network, making connectivity sparse.",
      "startOffset" : 56,
      "endOffset" : 606
    }, {
      "referenceID" : 32,
      "context" : "Both properties have been observed in mammalian brains (Hubel and Wiesel, 1959; Olshausen and Field, 2004; Mason et al., 1991; Markram et al., 1997) and have inspired a variety of machine learning algorithms. A notable result was achieved through the sparse coding model of Olshausen and Field (1996). Given small patches from images of natural scenes, the model is able to produce Gabor-like filters, resembling properties of simple cells found in mammalian primary visual cortex (Hubel and Wiesel, 1959; Vinje and Gallant, 2000). Another example is the optimal brain damage method of LeCun et al. (1990), which can be used to prune synaptic connections in a neural network, making connectivity sparse. Although only a small fraction of possible connections remains after pruning, this is sufficient to achieve equivalent classification results. Since then, numerous approaches on how to measure sparseness have been proposed, see Hurley and Rickard (2009) for an overview, and how to achieve sparse solutions of classical machine learning problems.",
      "startOffset" : 56,
      "endOffset" : 958
    }, {
      "referenceID" : 61,
      "context" : "Using it rather than other sparseness measures has been shown to induce biologically more plausible properties (Rehn and Sommer, 2007).",
      "startOffset" : 111,
      "endOffset" : 134
    }, {
      "referenceID" : 52,
      "context" : "However, finding of optimal solutions subject to the L0 pseudo-norm turns out to be NP-hard (Natarajan, 1995; Weston et al., 2003).",
      "startOffset" : 92,
      "endOffset" : 130
    }, {
      "referenceID" : 76,
      "context" : "However, finding of optimal solutions subject to the L0 pseudo-norm turns out to be NP-hard (Natarajan, 1995; Weston et al., 2003).",
      "startOffset" : 92,
      "endOffset" : 130
    }, {
      "referenceID" : 13,
      "context" : "The Manhattan norm of a vector is a convex relaxation of the L0 pseudo-norm (Donoho, 2006), and has been employed in a vast range of applications.",
      "startOffset" : 76,
      "endOffset" : 90
    }, {
      "referenceID" : 31,
      "context" : "A normalized sparseness measure σ based on the ratio of the L1 or Manhattan norm and the L2 or Euclidean norm of a vector has been proposed by Hoyer (2004),",
      "startOffset" : 143,
      "endOffset" : 156
    }, {
      "referenceID" : 38,
      "context" : "σ is well-defined because ‖x‖2≤‖x‖1≤ √ n‖x‖2 holds for all x ∈ Rn (Laub, 2004).",
      "startOffset" : 66,
      "endOffset" : 78
    }, {
      "referenceID" : 35,
      "context" : "For example, sparseness of connectivity in a biological brain increases quickly with its volume, so that connectivity in a human brain is about 170 times more sparse than in a rat brain (Karbowski, 2003).",
      "startOffset" : 186,
      "endOffset" : 203
    }, {
      "referenceID" : 32,
      "context" : "This sparseness measure fulfills all criteria of Hurley and Rickard (2009) except for Dalton’s fourth law, which states that the sparseness of a vector should be identical to the sparseness of the vector resulting from multiple concatenation of the original vector.",
      "startOffset" : 49,
      "endOffset" : 75
    }, {
      "referenceID" : 31,
      "context" : "A sparseness-enforcing projection operator, suitable for projected gradient descent algorithms, was proposed by Hoyer (2004) for optimization with respect to σ.",
      "startOffset" : 112,
      "endOffset" : 125
    }, {
      "referenceID" : 31,
      "context" : "Hoyer’s original algorithm for computation of such a projection is an alternating projection onto a hyperplane representing the L1 norm constraint, a hypersphere representing the L2 norm constraint, and the non-negative orthant. A slightly modified version of this algorithm has been proved to be correct by Theis et al. (2005) in the special case when exactly one negative entry emerges that is zeroed out in the orthant projection.",
      "startOffset" : 0,
      "endOffset" : 328
    }, {
      "referenceID" : 4,
      "context" : "In fact, the projection onto Z consists simply of zeroing out all entries but the κ that are greatest in absolute value (Blumensath and Davies, 2009).",
      "startOffset" : 120,
      "endOffset" : 149
    }, {
      "referenceID" : 7,
      "context" : "The most relevant result is that if x∈Rn \\C, then there exists a separator t̂ ∈R such that p := projC(x) = max(x− t̂ · e, 0), where the maximum is taken element-wise (Chen and Ye, 2011).",
      "startOffset" : 166,
      "endOffset" : 185
    }, {
      "referenceID" : 7,
      "context" : "The most relevant result is that if x∈Rn \\C, then there exists a separator t̂ ∈R such that p := projC(x) = max(x− t̂ · e, 0), where the maximum is taken element-wise (Chen and Ye, 2011). In the cases considered in this paper it is always t̂ ≥ 0 as shown in Lemma 28. This implies that all entries in x that are less than t̂ do not survive the projection, and hence the L0 pseudo-norm of x is strictly greater than that of p. The simplex projection therefore enhances sparseness. The separator t̂ and the number of nonzero entries in the projection onto C can be computed with Algorithm 2, which is an adapted version of the algorithm of Chen and Ye (2011). In line 1, Sn denotes the symmetric group and Pτ denotes the permutation matrix associated with a permutation τ ∈ Sn.",
      "startOffset" : 167,
      "endOffset" : 656
    }, {
      "referenceID" : 7,
      "context" : "This is an adapted version of the algorithm of Chen and Ye (2011). Input: x ∈Rn \\C and λ1 ∈R>0.",
      "startOffset" : 47,
      "endOffset" : 66
    }, {
      "referenceID" : 31,
      "context" : "The original algorithm for the sparseness-enforcing projection operator proposed by Hoyer (2004) is hard to understand, and correctness has been proved by Theis et al.",
      "startOffset" : 84,
      "endOffset" : 97
    }, {
      "referenceID" : 31,
      "context" : "The original algorithm for the sparseness-enforcing projection operator proposed by Hoyer (2004) is hard to understand, and correctness has been proved by Theis et al. (2005) in a special case only.",
      "startOffset" : 84,
      "endOffset" : 175
    }, {
      "referenceID" : 31,
      "context" : "As was already observed by Hoyer (2004), the number of required iterations grows very slowly with problem dimensionality.",
      "startOffset" : 27,
      "endOffset" : 40
    }, {
      "referenceID" : 30,
      "context" : "ponent analysis (Hotelling, 1933), restricted Boltzmann machines for deep auto-encoder networks (Hinton et al.",
      "startOffset" : 16,
      "endOffset" : 33
    }, {
      "referenceID" : 26,
      "context" : "ponent analysis (Hotelling, 1933), restricted Boltzmann machines for deep auto-encoder networks (Hinton et al., 2006) and to sparse encoding symmetric machine (Ranzato et al.",
      "startOffset" : 96,
      "endOffset" : 117
    }, {
      "referenceID" : 60,
      "context" : ", 2006) and to sparse encoding symmetric machine (Ranzato et al., 2008).",
      "startOffset" : 49,
      "endOffset" : 71
    }, {
      "referenceID" : 31,
      "context" : "This condition was adopted from non-negative matrix factorization with sparseness constraints (Hoyer, 2004).",
      "startOffset" : 94,
      "endOffset" : 107
    }, {
      "referenceID" : 63,
      "context" : "Therefore the entire processing path from x to y forms a two-layer neural network (Rumelhart et al., 1986), where W stores the synaptic weights of the hidden layer, and Wout and θout are the parameters of the output layer.",
      "startOffset" : 82,
      "endOffset" : 106
    }, {
      "referenceID" : 3,
      "context" : "The similarity measure for classification capabilities sC is chosen to be the cross-entropy error function (Bishop, 1995), which was shown empirically by Simard et al.",
      "startOffset" : 107,
      "endOffset" : 121
    }, {
      "referenceID" : 3,
      "context" : "The softmax transfer function (Bishop, 1995) is used as transfer function g of the output layer.",
      "startOffset" : 30,
      "endOffset" : 44
    }, {
      "referenceID" : 16,
      "context" : "It provides a natural pairing together with the cross-entropy error function (Dunne and Campbell, 1997) and supports multi-class classification.",
      "startOffset" : 77,
      "endOffset" : 103
    }, {
      "referenceID" : 3,
      "context" : "The similarity measure for classification capabilities sC is chosen to be the cross-entropy error function (Bishop, 1995), which was shown empirically by Simard et al. (2003) to induce better classification capabilities than the mean squared error function.",
      "startOffset" : 108,
      "endOffset" : 175
    }, {
      "referenceID" : 2,
      "context" : "The proposed optimization algorithm for minimization of the objective function ESOAE is projected gradient descent (Bertsekas, 1999).",
      "startOffset" : 115,
      "endOffset" : 132
    }, {
      "referenceID" : 2,
      "context" : "There are theoretical results on the convergence of projected gradient methods when projections are carried out onto convex sets (Bertsekas, 1999), but here the target set for projection is non-convex.",
      "startOffset" : 129,
      "endOffset" : 146
    }, {
      "referenceID" : 77,
      "context" : "This online learning procedure results in faster learning and improves generalization capabilities over batch learning (Wilson and Martinez, 2003; Bottou and LeCun, 2004).",
      "startOffset" : 119,
      "endOffset" : 170
    }, {
      "referenceID" : 5,
      "context" : "This online learning procedure results in faster learning and improves generalization capabilities over batch learning (Wilson and Martinez, 2003; Bottou and LeCun, 2004).",
      "startOffset" : 119,
      "endOffset" : 170
    }, {
      "referenceID" : 3,
      "context" : "Initialization of the columns of W is achieved by selecting a random subset of the learning set, similar to the initialization of radial basis function networks (Bishop, 1995).",
      "startOffset" : 161,
      "endOffset" : 175
    }, {
      "referenceID" : 26,
      "context" : "This continuous variant of unsupervised pre-training (Hinton et al., 2006) leads to parameters in the vicinity of a good minimizer for classification capabilities before classification is preferred over reconstruction through the trade-off parameter α.",
      "startOffset" : 53,
      "endOffset" : 74
    }, {
      "referenceID" : 39,
      "context" : "To assess the classification capabilities and the impact of sparse activity and sparse connectivity, the MNIST database of handwritten digits (LeCun and Cortes, 1998) was employed.",
      "startOffset" : 142,
      "endOffset" : 166
    }, {
      "referenceID" : 39,
      "context" : "For generation of the original data set, the placement of the digits has been achieved based on their barycenter (LeCun and Cortes, 1998).",
      "startOffset" : 113,
      "endOffset" : 137
    }, {
      "referenceID" : 66,
      "context" : "Further improvements can be achieved by generating artificial training samples using elastic distortions (Simard et al., 2003).",
      "startOffset" : 105,
      "endOffset" : 126
    }, {
      "referenceID" : 8,
      "context" : "35% (Cireşan et al., 2010).",
      "startOffset" : 4,
      "endOffset" : 26
    }, {
      "referenceID" : 9,
      "context" : "23% is held by an approach that combines distorted samples with a committee of convolutional neural networks (Cireşan et al., 2012).",
      "startOffset" : 109,
      "endOffset" : 131
    }, {
      "referenceID" : 23,
      "context" : "As noted by Hinton et al. (2006), the learning problem is no more permutation-invariant due to the jittering, as information on the neighborhood of the pixels is implicitly incorporated in the learning set.",
      "startOffset" : 12,
      "endOffset" : 33
    }, {
      "referenceID" : 23,
      "context" : "As noted by Hinton et al. (2006), the learning problem is no more permutation-invariant due to the jittering, as information on the neighborhood of the pixels is implicitly incorporated in the learning set. However, classification results improve dramatically when such prior knowledge is used. This was demonstrated by Schölkopf (1997) using the virtual support vector method, which improved a support vector machine with polynomial kernel of degree five from an error of 1.",
      "startOffset" : 12,
      "endOffset" : 337
    }, {
      "referenceID" : 9,
      "context" : "This result was extended by DeCoste and Schölkopf (2002), where a support vector machine with a polynomial kernel of degree nine was improved from an error of 1.",
      "startOffset" : 28,
      "endOffset" : 57
    }, {
      "referenceID" : 8,
      "context" : "35% (Cireşan et al., 2010). The current record error of 0.23% is held by an approach that combines distorted samples with a committee of convolutional neural networks (Cireşan et al., 2012). This is an architecture that has been optimized exclusively for input data that represents images, that is where the neighborhood of the pixels is hard-wired in the classifier. To allow for a plain evaluation that does not depend on additional parameters for creating artificial samples, the jittered learning set with 540 000 samples is used throughout this paper. The experimental methodology was as follows. The number of hidden units was chosen to be n := 1000 in all experiments that are described below. This is an increased number compared to the 800 hidden units employed by Simard et al. (2003), but promises to yield better results when an adequate number of learning samples is used.",
      "startOffset" : 5,
      "endOffset" : 795
    }, {
      "referenceID" : 21,
      "context" : "It can be explained by the bias-variance decomposition of the generalization error (Geman et al., 1992).",
      "startOffset" : 83,
      "endOffset" : 103
    }, {
      "referenceID" : 40,
      "context" : "Here, the optimal brain damage (OBD) algorithm (LeCun et al., 1990) was used to prune synaptic connections in the hidden layer that are irrelevant for the computation of the classification decision of the network.",
      "startOffset" : 47,
      "endOffset" : 67
    }, {
      "referenceID" : 39,
      "context" : "The effect of better generalization due to sparse connectivity has also been observed by LeCun et al. (1990) in the context of convolutional neural networks.",
      "startOffset" : 89,
      "endOffset" : 109
    }, {
      "referenceID" : 28,
      "context" : "A Tukey-Kramer type modification applied to Dunn’s procedure yields this critical difference, which is less conservative than Nemenyi’s procedure for the Kruskal-Wallis test (Hochberg and Tamhane, 1987).",
      "startOffset" : 174,
      "endOffset" : 202
    }, {
      "referenceID" : 52,
      "context" : "The procedure follows the proposals of Pizarro et al. (2002) and Demšar (2006) for hypothesis testing, and is concluded by effect size estimation as proposed by Grissom (1994) and Acion et al.",
      "startOffset" : 39,
      "endOffset" : 61
    }, {
      "referenceID" : 11,
      "context" : "(2002) and Demšar (2006) for hypothesis testing, and is concluded by effect size estimation as proposed by Grissom (1994) and Acion et al.",
      "startOffset" : 11,
      "endOffset" : 25
    }, {
      "referenceID" : 11,
      "context" : "(2002) and Demšar (2006) for hypothesis testing, and is concluded by effect size estimation as proposed by Grissom (1994) and Acion et al.",
      "startOffset" : 11,
      "endOffset" : 122
    }, {
      "referenceID" : 0,
      "context" : "(2002) and Demšar (2006) for hypothesis testing, and is concluded by effect size estimation as proposed by Grissom (1994) and Acion et al. (2006). For each algorithm, a sample of size 47 was available, allowing for robust analysis results.",
      "startOffset" : 126,
      "endOffset" : 146
    }, {
      "referenceID" : 0,
      "context" : "(2002) and Demšar (2006) for hypothesis testing, and is concluded by effect size estimation as proposed by Grissom (1994) and Acion et al. (2006). For each algorithm, a sample of size 47 was available, allowing for robust analysis results. First, all results were tested for normality using the test developed by Shapiro and Wilk (1965). The resulting test statistics W and p-values are given in Table 1.",
      "startOffset" : 126,
      "endOffset" : 337
    }, {
      "referenceID" : 0,
      "context" : "(2002) and Demšar (2006) for hypothesis testing, and is concluded by effect size estimation as proposed by Grissom (1994) and Acion et al. (2006). For each algorithm, a sample of size 47 was available, allowing for robust analysis results. First, all results were tested for normality using the test developed by Shapiro and Wilk (1965). The resulting test statistics W and p-values are given in Table 1. As all p-values are large, it cannot be rejected that the samples came from normally distributed populations. Thus normality is assumed in the remainder of this discussion. Next, the test proposed by Levene (1960) was applied to determine whether equality of variances of the groups holds.",
      "startOffset" : 126,
      "endOffset" : 619
    }, {
      "referenceID" : 0,
      "context" : "(2002) and Demšar (2006) for hypothesis testing, and is concluded by effect size estimation as proposed by Grissom (1994) and Acion et al. (2006). For each algorithm, a sample of size 47 was available, allowing for robust analysis results. First, all results were tested for normality using the test developed by Shapiro and Wilk (1965). The resulting test statistics W and p-values are given in Table 1. As all p-values are large, it cannot be rejected that the samples came from normally distributed populations. Thus normality is assumed in the remainder of this discussion. Next, the test proposed by Levene (1960) was applied to determine whether equality of variances of the groups holds. This resulted in a test statistic F = 2.7979 with 7 and 368 degrees of freedom, and therefore a p-value of 0.0075. Hence the hypothesis that all group variances are equal can be rejected with very high significance. Consequently, parametric omnibus and post-hoc tests cannot be applied, as they require the groups to have equal variance. As an alternative, the nonparametric test by Kruskal and Wallis (1952) which is based on rank information was employed to test whether all algorithms produced classifiers with equal classification errors in the mean.",
      "startOffset" : 126,
      "endOffset" : 1104
    }, {
      "referenceID" : 12,
      "context" : "Figure 7: Diagram for multiple comparison of algorithms following Demšar (2006). For each algorithm, the mean rank was computed during the Kruskal-Wallis test.",
      "startOffset" : 66,
      "endOffset" : 80
    }, {
      "referenceID" : 12,
      "context" : "procedure proposed by Demšar (2006) for paired observations, such that the diagrams proposed there can be adapted to the case for unpaired observations.",
      "startOffset" : 22,
      "endOffset" : 36
    }, {
      "referenceID" : 24,
      "context" : "To assess the benefit when an algorithm from one group is chosen over an algorithm from another group, the probability of superior experiment outcome was estimated (Grissom, 1994; Acion et al., 2006).",
      "startOffset" : 164,
      "endOffset" : 199
    }, {
      "referenceID" : 0,
      "context" : "To assess the benefit when an algorithm from one group is chosen over an algorithm from another group, the probability of superior experiment outcome was estimated (Grissom, 1994; Acion et al., 2006).",
      "startOffset" : 164,
      "endOffset" : 199
    }, {
      "referenceID" : 14,
      "context" : "However, using Rao-Blackwell theory a minimum variance unbiased estimator R̂2 of this probability can be computed easily (Downton, 1973).",
      "startOffset" : 121,
      "endOffset" : 136
    }, {
      "referenceID" : 24,
      "context" : "Therefore, the effect of choosing SOAE-σ over any of the seven other algorithms is dramatic (Grissom, 1994).",
      "startOffset" : 92,
      "endOffset" : 107
    }, {
      "referenceID" : 39,
      "context" : "Once a synaptic connection has been removed, it cannot be recovered, as the measure for relevance of LeCun et al. (1990) vanishes for synaptic connections of zero strength.",
      "startOffset" : 101,
      "endOffset" : 121
    }, {
      "referenceID" : 17,
      "context" : "A similar approach can be carried out for intersections of closed, convex cones (Dykstra, 1983), which can be generalized to translated cones that can be used to approximate any convex set (Dykstra and Boyle, 1987).",
      "startOffset" : 80,
      "endOffset" : 95
    }, {
      "referenceID" : 18,
      "context" : "A similar approach can be carried out for intersections of closed, convex cones (Dykstra, 1983), which can be generalized to translated cones that can be used to approximate any convex set (Dykstra and Boyle, 1987).",
      "startOffset" : 189,
      "endOffset" : 214
    }, {
      "referenceID" : 29,
      "context" : "The first major part of this paper dealt with improvements to the work of Hoyer (2004) and Theis et al.",
      "startOffset" : 74,
      "endOffset" : 87
    }, {
      "referenceID" : 29,
      "context" : "The first major part of this paper dealt with improvements to the work of Hoyer (2004) and Theis et al. (2005). Here, an algorithm for the sparseness-enforcing projection with respect to Hoyer’s sparseness measure σ was proposed.",
      "startOffset" : 74,
      "endOffset" : 111
    }, {
      "referenceID" : 29,
      "context" : "The first major part of this paper dealt with improvements to the work of Hoyer (2004) and Theis et al. (2005). Here, an algorithm for the sparseness-enforcing projection with respect to Hoyer’s sparseness measure σ was proposed. The technical proof of correctness is given in Appendix C. The set that should be projected onto is an intersection of a simplex C and a hypercircle L, which is a hypersphere lying in a hyperplane. The overall procedure can be described as performing alternating projections onto C and certain subsets of L. This approach is common for handling projections onto intersections of individual sets. For example, von Neumann (1950) proposed essentially the same idea when the investigated sets are closed subspaces, and has shown that this converges to a solution.",
      "startOffset" : 74,
      "endOffset" : 658
    }, {
      "referenceID" : 15,
      "context" : "For the former, efficient algorithms have been proposed recently (Duchi et al., 2008; Chen and Ye, 2011).",
      "startOffset" : 65,
      "endOffset" : 104
    }, {
      "referenceID" : 7,
      "context" : "For the former, efficient algorithms have been proposed recently (Duchi et al., 2008; Chen and Ye, 2011).",
      "startOffset" : 65,
      "endOffset" : 104
    }, {
      "referenceID" : 44,
      "context" : "When only independent solutions are required, the projection of a point x onto a scaled canonical simplex of L1 norm λ1 can also be carried out in linear time (Liu and Ye, 2009), without having to sort the vector that is to be projected.",
      "startOffset" : 159,
      "endOffset" : 177
    }, {
      "referenceID" : 44,
      "context" : "The zero of this function can be found efficiently using the bisection method, and exploiting the special structure of the occurring expressions (Liu and Ye, 2009).",
      "startOffset" : 145,
      "endOffset" : 163
    }, {
      "referenceID" : 27,
      "context" : "For example, the projection onto a closed, convex set is guaranteed to be differentiable almost everywhere (Hiriart-Urruty, 1982).",
      "startOffset" : 107,
      "endOffset" : 129
    }, {
      "referenceID" : 4,
      "context" : "The iterative hard thresholding algorithm is a gradient descent algorithm, where a projection onto an L0 pseudo-norm constraint is performed (Blumensath and Davies, 2009).",
      "startOffset" : 141,
      "endOffset" : 170
    }, {
      "referenceID" : 4,
      "context" : "In spite of the simplicity of the method, it can be shown that it achieves a good approximation to the optimal solution of this NP-hard problem (Blumensath and Davies, 2009).",
      "startOffset" : 144,
      "endOffset" : 173
    }, {
      "referenceID" : 4,
      "context" : "The iterative hard thresholding algorithm is a gradient descent algorithm, where a projection onto an L0 pseudo-norm constraint is performed (Blumensath and Davies, 2009). Its application lies in compressed sensing, where a linear generative model is used to infer a sparse representation for a given observation. Sparseness here acts as regularizer which is necessary because observations are sampled below the Nyquist rate. In spite of the simplicity of the method, it can be shown that it achieves a good approximation to the optimal solution of this NP-hard problem (Blumensath and Davies, 2009). Closely related with the work of this paper is the generalization of Hoyer’s sparseness measure by Theis and Tanaka (2006). Here, the L1 norm constraint is replaced with a generalized Lp pseudo-",
      "startOffset" : 142,
      "endOffset" : 724
    }, {
      "referenceID" : 67,
      "context" : "In this context, mixed norm balls are of particular interest (Sra, 2012).",
      "startOffset" : 61,
      "endOffset" : 72
    }, {
      "referenceID" : 59,
      "context" : ", 2008) and for q = ∞ (Quattoni et al., 2009).",
      "startOffset" : 22,
      "endOffset" : 45
    }, {
      "referenceID" : 45,
      "context" : "The case when p = 1 and q≥ 1 is more difficult, but can be solved as well (Liu and Ye, 2010; Sra, 2012).",
      "startOffset" : 74,
      "endOffset" : 103
    }, {
      "referenceID" : 67,
      "context" : "The case when p = 1 and q≥ 1 is more difficult, but can be solved as well (Liu and Ye, 2010; Sra, 2012).",
      "startOffset" : 74,
      "endOffset" : 103
    }, {
      "referenceID" : 78,
      "context" : "The last problem discussed here is the elastic net criterion (Zou and Hastie, 2005), which is a constraint on the sum of an L1 norm and an L2 norm.",
      "startOffset" : 61,
      "endOffset" : 83
    }, {
      "referenceID" : 47,
      "context" : "As is the case for mixed norm balls, the projection onto a simplex can be generalized to achieve projections onto N (Mairal et al., 2010).",
      "startOffset" : 116,
      "endOffset" : 137
    }, {
      "referenceID" : 30,
      "context" : "For p = 1, Hoyer’s sparseness measure up to a constant normalization is obtained. When p converges decreasingly to zero, then σp(x) converges point-wise to the L0 pseudo-norm. Hence for small values of p a more natural sparseness measure is obtained. Theis and Tanaka (2006) also proposed an extension of Hoyer’s projection algorithm.",
      "startOffset" : 11,
      "endOffset" : 275
    }, {
      "referenceID" : 36,
      "context" : "If the entries of the training patterns are sparsely populated, the weight matrix of the memory will be sparsely populated as well after training if Hebbian-like learning rules are used (Kohonen, 1972).",
      "startOffset" : 186,
      "endOffset" : 201
    }, {
      "referenceID" : 57,
      "context" : "The assumption of sparsely coded inputs also results in increased completion capacity and noise resistance of the associative memory (Palm, 1980).",
      "startOffset" : 133,
      "endOffset" : 145
    }, {
      "referenceID" : 1,
      "context" : "If the input data is not sparse inherently, feature detectors can perform a sparsification prior to the actual processing through the memory (Baum et al., 1988).",
      "startOffset" : 141,
      "endOffset" : 160
    }, {
      "referenceID" : 31,
      "context" : "A purely generative model that also possesses these two key properties is non-negative matrix factorization with sparseness constraints (Hoyer, 2004).",
      "startOffset" : 136,
      "endOffset" : 149
    }, {
      "referenceID" : 56,
      "context" : "matrix factorization (Paatero and Tapper, 1994) which was shown to achieve sparse connectivity on certain data sets (Lee and Seung, 1999).",
      "startOffset" : 21,
      "endOffset" : 47
    }, {
      "referenceID" : 41,
      "context" : "matrix factorization (Paatero and Tapper, 1994) which was shown to achieve sparse connectivity on certain data sets (Lee and Seung, 1999).",
      "startOffset" : 116,
      "endOffset" : 137
    }, {
      "referenceID" : 43,
      "context" : "However, there are data sets on which this does not work (Li et al., 2001; Hoyer, 2004).",
      "startOffset" : 57,
      "endOffset" : 87
    }, {
      "referenceID" : 31,
      "context" : "However, there are data sets on which this does not work (Li et al., 2001; Hoyer, 2004).",
      "startOffset" : 57,
      "endOffset" : 87
    }, {
      "referenceID" : 51,
      "context" : "In the use case of object recognition, a hard shrinkage was also employed to de-noise filter responses (Mutch and Lowe, 2006).",
      "startOffset" : 103,
      "endOffset" : 125
    }, {
      "referenceID" : 10,
      "context" : "It is well-known that two layers in a neural network are sufficient to approximate any continuous function on a compactum with arbitrary precision (Cybenko, 1989; Funahashi, 1989; Hornik et al., 1989).",
      "startOffset" : 147,
      "endOffset" : 200
    }, {
      "referenceID" : 20,
      "context" : "It is well-known that two layers in a neural network are sufficient to approximate any continuous function on a compactum with arbitrary precision (Cybenko, 1989; Funahashi, 1989; Hornik et al., 1989).",
      "startOffset" : 147,
      "endOffset" : 200
    }, {
      "referenceID" : 29,
      "context" : "It is well-known that two layers in a neural network are sufficient to approximate any continuous function on a compactum with arbitrary precision (Cybenko, 1989; Funahashi, 1989; Hornik et al., 1989).",
      "startOffset" : 147,
      "endOffset" : 200
    }, {
      "referenceID" : 20,
      "context" : "An extension intended to incorporate class membership information to increase discriminative capabilities was proposed by Heiler and Schnörr (2006). In their approach, an additional constraint was added ensuring that every internal representation is close to the mean of all internal representations that belong to the same class.",
      "startOffset" : 122,
      "endOffset" : 148
    }, {
      "referenceID" : 20,
      "context" : "An extension intended to incorporate class membership information to increase discriminative capabilities was proposed by Heiler and Schnörr (2006). In their approach, an additional constraint was added ensuring that every internal representation is close to the mean of all internal representations that belong to the same class. In other words, the method can be interpreted as supervised clustering, with the number of clusters equal to the number of classes. However, there is no guarantee that a distribution of internal representations exists such that both the reproduction error is minimized and the internal representations can be arranged in such a pattern. Unfortunately, Heiler and Schnörr (2006) used only a subset of a small data set for handwritten digit recognition to evaluate their approach.",
      "startOffset" : 122,
      "endOffset" : 709
    }, {
      "referenceID" : 20,
      "context" : "An extension intended to incorporate class membership information to increase discriminative capabilities was proposed by Heiler and Schnörr (2006). In their approach, an additional constraint was added ensuring that every internal representation is close to the mean of all internal representations that belong to the same class. In other words, the method can be interpreted as supervised clustering, with the number of clusters equal to the number of classes. However, there is no guarantee that a distribution of internal representations exists such that both the reproduction error is minimized and the internal representations can be arranged in such a pattern. Unfortunately, Heiler and Schnörr (2006) used only a subset of a small data set for handwritten digit recognition to evaluate their approach. A precursor to the supervised online auto-encoder was proposed by Thom et al. (2011a). There, inference of sparse internal representations was achieved by fitting a one-layer neural network to approximate a latent variable of optimal sparse representations.",
      "startOffset" : 122,
      "endOffset" : 896
    }, {
      "referenceID" : 19,
      "context" : "Similar techniques to achieve a shrinkage-like effect for increasing sparseness of activity in a neural network were used by Gregor and LeCun (2010) and Glorot et al.",
      "startOffset" : 125,
      "endOffset" : 149
    }, {
      "referenceID" : 19,
      "context" : "Similar techniques to achieve a shrinkage-like effect for increasing sparseness of activity in a neural network were used by Gregor and LeCun (2010) and Glorot et al. (2011). Information processing is here purely local, that is a scalar function is evaluated entrywise on a vector, and thus no information is interchanged among individual entries.",
      "startOffset" : 153,
      "endOffset" : 174
    }, {
      "referenceID" : 19,
      "context" : "Similar techniques to achieve a shrinkage-like effect for increasing sparseness of activity in a neural network were used by Gregor and LeCun (2010) and Glorot et al. (2011). Information processing is here purely local, that is a scalar function is evaluated entrywise on a vector, and thus no information is interchanged among individual entries. The use of non-local shrinkage to reduce Gaussian noise in sparse coding has already been described by Hyvärinen et al. (1999). Here, a maximum likelihood estimate with only weak assumptions yields a shrinkage operation, which can be conceived as projection onto a scaled canonical simplex.",
      "startOffset" : 153,
      "endOffset" : 475
    }, {
      "referenceID" : 19,
      "context" : "Similar techniques to achieve a shrinkage-like effect for increasing sparseness of activity in a neural network were used by Gregor and LeCun (2010) and Glorot et al. (2011). Information processing is here purely local, that is a scalar function is evaluated entrywise on a vector, and thus no information is interchanged among individual entries. The use of non-local shrinkage to reduce Gaussian noise in sparse coding has already been described by Hyvärinen et al. (1999). Here, a maximum likelihood estimate with only weak assumptions yields a shrinkage operation, which can be conceived as projection onto a scaled canonical simplex. In the use case of object recognition, a hard shrinkage was also employed to de-noise filter responses (Mutch and Lowe, 2006). Whenever a best approximation from a permutationinvariant set is used, a shrinkage-like operation must be employed. Using a projection operator as neural transfer function is hence a natural extension of these ideas. When the projection is sufficiently smooth, the entire model can be tuned end-to-end using gradient methods to achieve an auto-encoder or a classifier. The second building block from Thom et al. (2011a) that was incorporated into supervised online auto-encoder is the architectural concept for classification.",
      "startOffset" : 153,
      "endOffset" : 1186
    }, {
      "referenceID" : 6,
      "context" : "Bradley and Bagnell (2009) used the Kullback-Leibler divergence as implicit sparseness penalty term and combined this with the backpropagation algorithm to yield a classifier that achieved a 1.",
      "startOffset" : 0,
      "endOffset" : 27
    }, {
      "referenceID" : 6,
      "context" : "Bradley and Bagnell (2009) used the Kullback-Leibler divergence as implicit sparseness penalty term and combined this with the backpropagation algorithm to yield a classifier that achieved a 1.30% error rate on the MNIST evaluation set. The Kullback-Leibler divergence was chosen to replace the usual L1 norm penalty term, as it is smoother than the latter and therefore sparsely coded internal representations are more stable subject to subtle changes of the input. A related technique is supervised dictionary learning by Mairal et al. (2009), where the objective function is an additive combination of a classification error term, a term for the reproduction error, and an L1 norm constraint.",
      "startOffset" : 0,
      "endOffset" : 545
    }, {
      "referenceID" : 64,
      "context" : "Augmentation of the learning set with virtual samples would have contributed to improve classification performance, as demonstrated by Schölkopf (1997).",
      "startOffset" : 135,
      "endOffset" : 152
    }, {
      "referenceID" : 70,
      "context" : "In practice, this property can also be used to reduce the computational complexity of classification by one order of magnitude (Thom et al., 2011b). This results from exploiting sparseness and using sparse matrix-vector multiplication algorithms to infer the internal representation, which is the major computational burden in class membership prediction. It was shown in this paper and by Thom et al. (2011b) that a small number of nonzero entries in the weight matrix of the hidden layer is sufficient for achieving good classification results.",
      "startOffset" : 128,
      "endOffset" : 410
    }, {
      "referenceID" : 38,
      "context" : "The following basic statement will be used extensively in this paper and follows from 〈x, x〉= ‖x‖2 for all x ∈Rn and the fact that the scalar product is a symmetric bilinear form (Laub, 2004):",
      "startOffset" : 179,
      "endOffset" : 191
    }, {
      "referenceID" : 31,
      "context" : "1) Sparseness measure by Hoyer (2004) π and π≥0 (see Section 2.",
      "startOffset" : 25,
      "endOffset" : 38
    }, {
      "referenceID" : 33,
      "context" : "A great variety of sparseness measures fulfills certain symmetries as vector entries are equally weighted, see Hurley and Rickard (2009). This means that no entry is preferred over another, and for negative entries usually the absolute value or the squared value is taken, such that the signs of the entries are ignored.",
      "startOffset" : 111,
      "endOffset" : 137
    }, {
      "referenceID" : 15,
      "context" : "A weaker form of its statements has been described by Duchi et al. (2008) in the special case of a projection onto a simplex.",
      "startOffset" : 54,
      "endOffset" : 74
    }, {
      "referenceID" : 30,
      "context" : "Its second part was already observed by Hoyer (2004), in the special case of the sparseness-enforcing projection operator, and by Duchi et al.",
      "startOffset" : 40,
      "endOffset" : 53
    }, {
      "referenceID" : 15,
      "context" : "Its second part was already observed by Hoyer (2004), in the special case of the sparseness-enforcing projection operator, and by Duchi et al. (2008), when the connection between projections onto a simplex and onto an L1 ball was studied.",
      "startOffset" : 130,
      "endOffset" : 150
    }, {
      "referenceID" : 69,
      "context" : "Lemma 13 is an elaborated version of a result from Theis et al. (2005), which is included here for completeness.",
      "startOffset" : 51,
      "endOffset" : 71
    }, {
      "referenceID" : 69,
      "context" : "The major arguments for this result have been taken over from Theis et al. (2005). Here, the statements from Lemma 15 have been incorporated and the resulting quadratic equation was solved explicitly, simplifying the original version of Theis et al.",
      "startOffset" : 62,
      "endOffset" : 82
    }, {
      "referenceID" : 69,
      "context" : "The major arguments for this result have been taken over from Theis et al. (2005). Here, the statements from Lemma 15 have been incorporated and the resulting quadratic equation was solved explicitly, simplifying the original version of Theis et al. (2005).",
      "startOffset" : 62,
      "endOffset" : 257
    }, {
      "referenceID" : 7,
      "context" : "The following definition is likewise to definitions from Chen and Ye (2011) and Michelot (1986):",
      "startOffset" : 57,
      "endOffset" : 76
    }, {
      "referenceID" : 7,
      "context" : "The following definition is likewise to definitions from Chen and Ye (2011) and Michelot (1986):",
      "startOffset" : 57,
      "endOffset" : 96
    }, {
      "referenceID" : 47,
      "context" : "An iterative algorithm was developed by Michelot (1986) which is very similar to Hoyer’s original method for computation of the projection onto D.",
      "startOffset" : 40,
      "endOffset" : 56
    }, {
      "referenceID" : 14,
      "context" : "A simpler and more effective algorithm has been developed by Duchi et al. (2008). Building upon this work, Chen and Ye (2011) have proposed and rigorously proved correctness of a very similar algorithm, which is more explicit than that of Duchi et al.",
      "startOffset" : 61,
      "endOffset" : 81
    }, {
      "referenceID" : 7,
      "context" : "Building upon this work, Chen and Ye (2011) have proposed and rigorously proved correctness of a very similar algorithm, which is more explicit than that of Duchi et al.",
      "startOffset" : 25,
      "endOffset" : 44
    }, {
      "referenceID" : 7,
      "context" : "Building upon this work, Chen and Ye (2011) have proposed and rigorously proved correctness of a very similar algorithm, which is more explicit than that of Duchi et al. (2008). Their algorithm can be adapted to better suit the needs for the sparseness-enforcing projection.",
      "startOffset" : 25,
      "endOffset" : 177
    }, {
      "referenceID" : 7,
      "context" : "Proof The arguments from Chen and Ye (2011) hold for projections onto 4n.",
      "startOffset" : 25,
      "endOffset" : 44
    }, {
      "referenceID" : 69,
      "context" : "The following corollary states a similar result as in Theis et al. (2005). However, the proof here uses the notion of simplex projections instead of relying on pure analytical statements.",
      "startOffset" : 54,
      "endOffset" : 74
    }, {
      "referenceID" : 69,
      "context" : "The following corollary states a similar result as in Theis et al. (2005). However, the proof here uses the notion of simplex projections instead of relying on pure analytical statements. The result presented here is stronger, as multiple entries of the vector can be set to zero simultaneously, while in Theis et al. (2005) at most one entry can be zeroed out in a single iteration.",
      "startOffset" : 54,
      "endOffset" : 325
    }, {
      "referenceID" : 53,
      "context" : "The gradient for W follows using the chain rule and the product rule for matrix calculus, see Neudecker (1969) and Vetter (1970).",
      "startOffset" : 94,
      "endOffset" : 111
    }, {
      "referenceID" : 53,
      "context" : "The gradient for W follows using the chain rule and the product rule for matrix calculus, see Neudecker (1969) and Vetter (1970).",
      "startOffset" : 94,
      "endOffset" : 129
    }, {
      "referenceID" : 63,
      "context" : "The gradients of the similarity measure for classification capabilities are essentially equal to those of an ordinary two-layer neural network, and can be computed using the back-propagation algorithm (Rumelhart et al., 1986).",
      "startOffset" : 201,
      "endOffset" : 225
    }, {
      "referenceID" : 16,
      "context" : "However, the pairing of the softmax transfer function with the crossentropy error function provides a particularly simple structure of the gradient (Dunne and Campbell, 1997).",
      "startOffset" : 148,
      "endOffset" : 174
    }, {
      "referenceID" : 53,
      "context" : "Proof Basic matrix calculus (Neudecker, 1969; Vetter, 1970) yields ∂sC(y, t)/∂θout =(∂sC(y, t)/∂y) ·g′(y), (∂sC(y, t)/∂Wout) T = h · (∂sC(y, t)/∂θout) and (∂sC(y, t)/∂W) = x · ( (∂sC(y, t)/∂θout) ·W T out f ′(u) ) .",
      "startOffset" : 28,
      "endOffset" : 59
    }, {
      "referenceID" : 73,
      "context" : "Proof Basic matrix calculus (Neudecker, 1969; Vetter, 1970) yields ∂sC(y, t)/∂θout =(∂sC(y, t)/∂y) ·g′(y), (∂sC(y, t)/∂Wout) T = h · (∂sC(y, t)/∂θout) and (∂sC(y, t)/∂W) = x · ( (∂sC(y, t)/∂θout) ·W T out f ′(u) ) .",
      "startOffset" : 28,
      "endOffset" : 59
    } ],
    "year" : 2016,
    "abstractText" : "Sparseness is a useful regularizer for learning in a wide range of applications, in particular in neural networks. This paper proposes a model targeted at classification tasks, where sparse activity and sparse connectivity are used to enhance classification capabilities. The tool for achieving this is a sparseness-enforcing projection operator which finds the closest vector with a pre-defined sparseness for any given vector. In the theoretical part of this paper, a comprehensive theory for such a projection is developed. In conclusion, it is shown that the projection is differentiable almost everywhere and can thus be implemented as a smooth neuronal transfer function. The entire model can hence be tuned end-to-end using gradient-based methods. Experiments on the MNIST database of handwritten digits show that classification performance can be boosted by sparse activity or sparse connectivity. With a combination of both, performance can be significantly better compared to classical non-sparse approaches.",
    "creator" : "LaTeX with hyperref package"
  }
}