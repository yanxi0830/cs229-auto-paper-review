{
  "name" : "1205.6432.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Multiclass Learning Approaches: A Theoretical Comparison with Implications",
    "authors" : [ "Amit Daniely", "Sivan Sabato", "Shai Shalev-Shwartz" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "In this work we consider multiclass prediction: The problem of classifying objects into one of several possible target classes. Applications include, for example, categorizing documents according to topic, and determining which object appears in a given image. We assume that objects (a.k.a. instances) are vectors in X = Rd and the class labels come from the set Y = [k] = {1, . . . , k}. Following the standard PAC model, the learner receives a training set of m examples, drawn i.i.d. from some unknown distribution, and should output a classifier which maps X to Y .\nThe centrality of the multiclass learning problem has spurred the development of various approaches for tackling the task. Perhaps the most straightforward approach is a reduction from multiclass classification to binary classification. For example, the One-vs-All (OvA) method is based on a reduction of the multiclass problem into k binary problems, each of which discriminates between one class to all the rest of the classes (e.g. Rumelhart et al. [1986]). A different reduction is the All-Pairs (AP) approach in which all pairs of classes are compared to each other [Hastie and Tibshirani, 1998]. These two approaches have been unified under the framework of Error Correction Output Codes (ECOC) [Dietterich and Bakiri, 1995, Allwein et al., 2000]. A tree-based classifier (TC) is another reduction in which the prediction is obtained by traversing a binary tree, where at each node of the tree a binary classifier is used to decide on the rest of the path (see for example Beygelzimer et al. [2007]).\nAll of the above methods are based on reductions to binary classification. We pay special attention to the case where the underlying binary classifiers are linear separators (halfspaces). Formally, each w ∈ Rd+1 defines the linear separator hw(x) = sign(〈w, x̄〉), where x̄ = (x, 1) ∈ Rd+1 is the concatenation of the vector x and the scalar 1. While halfspaces are our primary focus, many of our results hold for any underlying binary hypothesis class of VC dimension d+ 1. ∗Dept. of Mathematics, The Hebrew University, Jerusalem, Israel †School of Computer Science and Engineering, The Hebrew University, Jerusalem, Israel ‡School of Computer Science and Engineering, The Hebrew University, Jerusalem, Israel\nar X\niv :1\n20 5.\n64 32\nv2 [\ncs .L\nG ]\n1 J\nun 2\nOther, more direct approaches to multiclass classification over Rd have also been proposed (e.g. Vapnik [1998], Weston and Watkins [1999], Crammer and Singer [2001]). In this paper we analyze the Multiclass SVM (MSVM) formulation of Crammer and Singer [2001], in which each hypothesis is of the form hW (x) = argmaxi∈[k](Wx̄)i, where W is a k× (d+ 1) matrix and (Wx̄)i is the i’th element of the vector Wx̄ ∈ Rk.\nWe theoretically analyze the prediction performance of the aforementioned methods, namely, OvA, AP, ECOC, TC, and MSVM. The error of a multiclass predictor h : Rd → [k] is defined to be the probability that h(x) 6= y, where (x, y) is sampled from the underlying distributionD over Rd× [k], namely, Err(h) = P(x,y)∼D[h(x) 6= y]. Our main goal is to understand which method is preferable in terms of the error it will achieve, based on easy-to-verify properties of the problem at hand.\nOur analysis pertains to the type of classifiers each method can potentially find, and does not depend on the specific training algorithm. More precisely, each method corresponds to a hypothesis class, H, which contains the multiclass predictors that may be returned by the method. For example, the hypothesis class of MSVM isH = {x 7→ argmaxi∈[k](Wx̄)i : W ∈ Rk×(d+1)}.\nA learning algorithm, A, receives a training set, S = {(xi, yi)}mi=1, sampled i.i.d. according to D, and returns a multiclass predictor which we denote by A(S) ∈ H. A learning algorithm is called an Empirical Risk Minimizer (ERM) if it returns a hypothesis inH that minimizes the empirical error on the sample. We denote by h? a hypothesis inH with minimal error,1 that is, h? ∈ argminh∈H Err(h).\nWhen analyzing the error of A(S), it is convenient to decompose this error as a sum of approximation error and estimation error:\nErr(A(S)) = Err(h?)︸ ︷︷ ︸ approximation + Err(A(S))− Err(h?)︸ ︷︷ ︸ estimation . (1)\n• The approximation error is the minimum error achievable by a predictor in the hypothesis class,H. The approximation error does not depend on the sample size, and is determined solely by the allowed hypothesis class.\n• The estimation error of an algorithm is the difference between the approximation error, and the error of the classifier the algorithm chose based on the sample. This error exists both for statistical reasons, since the sample may not be large enough to determine the best hypothesis, and for algorithmic reasons, since the learning algorithm may not output the best possible hypothesis given the sample. For the ERM algorithm, the estimation error can be bounded from above by order of √ C(H)/m\nwhere C(H) is a complexity measure of H (analogous to the VC dimension) and m is the sample size. A similar term also bounds the estimation error from below for any algorithm. Thus C(H) is an estimate of the best achievable estimation error for the class.\nWhen studying the estimation error of different methods, we follow the standard distribution-free analysis. Namely, we will compare the algorithms based on the worst-case estimation error, where worst-case is over all possible distributions D. Such an analysis can lead us to the following type of conclusion: If two hypothesis classes have roughly the same complexity, C(H1) ≈ C(H2), and the number of available training examples is significantly larger than this value of complexity, then for both hypothesis classes we are going to have a small estimation error. Hence, in this case the difference in prediction performance between the two methods will be dominated by the approximation error and by the success of the learning algorithm in approaching the best possible estimation error. In our discussion below we disregard possible differences in optimality which stem from algorithmic aspects and implementation details. A rigorous comparison of training heuristics would certainly be of interest and is left to future work.\nFor the approximation error we will provide even stronger results, by comparing the approximation error of classes for any distribution. We rely on the following definition.\n1For simplicity, we assume that the minimum is attainable.\nDefinition 1.1. Given two hypothesis classes, H,H′, we say that H essentially contains H′ if for any distribution, the approximation error ofH is at most the approximation error ofH′. H strictly containsH′ if, in addition, there is a distribution for which the approximation error ofH is strictly smaller than that of H′.\nOur main findings are as follows (see a full comparison in Table 1). The formal statements are given in Section 3.\n• The estimation errors of OvA, MSVM, and TC are all roughly the same, in the sense that C(H) = Θ̃(dk) for all of the corresponding hypothesis classes. The complexity of AP is Θ̃(dk2). The complexity of ECOC with a code of length l and code-distance δ is at most Õ(dl) and at least dδ/2. It follows that for randomly generated codes, C(H) = Θ̃(dl). Note that this analysis shows that a larger code-distance yields a larger estimation error and might therefore hurt performance. This contrasts with previous “reduction-based” analyses of ECOC, which concluded that a larger code distance improves performance.\n• We prove that the hypothesis class of MSVM essentially contains the hypothesis classes of both OvA and TC. Moreover, these inclusions are strict. Since the estimation errors of these three methods are roughly the same, it follows that the MSVM method dominates both OvA and TC in terms of achievable prediction performance.\n• In the TC method, one needs to associate each leaf of the tree to a label. If no prior knowledge on how to break the symmetry is known, it is suggested in Beygelzimer et al. [2007] to break symmetry by choosing a random permutation of the labels. We show that whenever d k, for any distribution D, with high probability over the choice of a random permutation, the approximation error of the resulting tree would be close to 1/2. It follows that a random choice of a permutation is likely to yield a poor predictor.\n• We show that if d k, for any distribution D, the approximation error of ECOC with a randomly generated code matrix is likely to be close to 1/2.\n• We show that the hypothesis class of AP essentially contains the hypothesis class of MSVM (hence also that of OvA and TC), and that there can be a substantial gap in the containment. Therefore, as expected, the relative performance of AP and MSVM depends on the well-known trade-off between estimation error and approximation error.\nThe above findings suggest that in terms of performance, it may be wiser to choose MSVM over OvA and TC, and especially so when d k. We note, however, that in some situations (e.g. d = k) the prediction success of these methods can be similar, while TC has the advantage of having a testing run-time of d log(k), compared to the testing run-time of dk for OvA and MSVM. In addition, TC and ECOC may be a good choice when there is additional prior knowledge on the distribution or on how to break symmetry between the different labels."
    }, {
      "heading" : "1.1 Related work",
      "text" : "Allwein et al. [2000] analyzed the multiclass error of ECOC as a function of the binary error. The problem with such a “reduction-based” analysis is that such analysis becomes problematic if the underlying binary problems are very hard. Indeed, our analysis reveals that the underlying binary problems would be too hard if d k and the code is randomly generated. The experiments in Allwein et al. [2000] show that when using kernel-based SVM or AdaBoost as the underlying classifier, OvA is inferior to random ECOC. However, in their experiments, the number of classes is small relative to the dimension of the feature space, especially if working with kernels or with combinations of weak learners.\nCrammer and Singer [2001] presented experiments demonstrating that MSVM outperforms OvA on several data sets. Rifkin and Klautau [2004] criticized the experiments of Crammer and Singer [2001], Allwein et al. [2000], and presented another set of experiments demonstrating that all methods perform roughly the same when the underlying binary classifier is very strong (SVM with a Guassian kernel). As our analysis shows, it is not surprising that with enough data and powerful binary classifiers, all methods should perform well. However, in many practical applications, we will prefer not to employ kernels (either because of shortage of examples, which might lead to a large estimation error, or due to computational constraint), and in such cases we expect to see a large difference between the methods.\nBeygelzimer et al. [2007] analyzed the regret of a specific training method for trees, called Filter Tree, as a function of the regret of the binary classifier. The regret is defined to be the difference between the learned classifier and the Bayes-optimal classifier for the problem. Here again we show that the regret values of the underlying binary classifiers are likely to be very large whenever d k and the leaves of the tree are associated to labels in a random way. Thus in this case the regret analysis is problematic. Several authors presented ways to learn better splits, which corresponds to learning the association of leaves to labels (see for example Bengio et al. [2011] and the references therein). Some of our negative results do not hold for such methods, as these do not randomly attach labels to tree leaves.\nDaniely et al. [2011] analyzed the properties of multiclass learning with various ERM learners, and have also provided some bounds on the estimation error of multiclass SVM and of trees. In this paper we both improve these bounds, derive new bounds for other classes, and also analyze the approximation error of the classes. To the best of our knowledge, this is the first case of using VC theory to analyze the approximation error of hypothesis classes."
    }, {
      "heading" : "2 Definitions and Preliminaries",
      "text" : "We first formally define the hypothesis classes that we analyze in this paper.\nMulticlass SVM (MSVM): For W ∈ Rk×(d+1) define hW : Rd → [k] by hW (x) = argmaxi∈[k](Wx̄)i and let L = {hW : W ∈ Rk×(d+1)}. Though NP-hard in general, solving the ERM problem with respect to L can be done efficiently in the realizable case (namely, whenever exists a hypothesis with zero empirical error on the sample).\nTree-based classifiers (TC): A tree-based multiclass classifier is a full binary tree whose leaves are associated with class labels and whose internal nodes are associated with binary classifiers. To classify an instance, we start with the root node and apply the binary classifier associated with it. If the prediction is 1 we traverse to the right child. Otherwise, we traverse to the left child. This process continues until we reach a leaf, and then we output the label associated with the leaf. Formally, a tree for k classes is a full binary tree T together with a bijection λ : leaf(T )→ [k], which associates a label to each of the leaves. We usually identify T with the pair (T, λ). The set of internal nodes of T is denoted by N(T ). Let H ⊂ {±1}X be a binary hypothesis class. Given a mapping C : N(T )→ H, define a multiclass predictor, hC : X → [k], by setting hC(x) = λ(v) where v is the last node of the root-to-leaf path v1, . . . vm = v such that vi+1 is the\nleft (resp. right) child of vi if C(vi)(x) = −1 (resp. C(vi)(x) = 1). Let HT = {hC | C : N(T ) → H}. Also, let Htrees = ∪T is a tree for k classesHT . If H is the class of linear separators over Rd, then for any tree T the ERM problem with respect toHT can be solved efficiently in the realizable case. However, the ERM problem is NP-hard in the non-realizable case.\nError Correcting Output Codes (ECOC): An ECOC is a code M ∈ Rk×l along with a bijection λ : [k] → [k]. We sometimes identify λ with the identity function and M with (M,λ)2. Given a code M , and the result of l binary classifiers represented by a vector u ∈ {−1, 1}l, the code selects a label via M̃ : {−1, 1}l → [k], defined by M̃(u) = λ ( arg maxi∈[k] ∑l j=1Mijuj ) . Given binary classifiers h1, . . . , hl\nfor each column in the code matrix, the code assigns to the instance x ∈ X the label M̃(h1(x), . . . , hl(x)). Let H ⊂ {±1}X be a binary hypothesis class. Denote by HM ⊆ [k]X the hypotheses class HM = {h : X → [k] | ∃(h1, . . . , hl) ∈ Hl s.t. ∀x ∈ X , h(x) = M̃(h1(x), . . . , hl(x))}.\nThe distance of a binary code, denoted by δ(M) for M ∈ {±1}k×l, is the minimal hamming distance between any two pairs of rows in the code matrix. Formally, the hamming distance between u, v ∈ {−1,+1}l is ∆h(u, v) = |{r : u[r] 6= v[r]}|, and δ(M) = min1≤i<j≤k ∆h(M [i],M [j]). The ECOC paradigm described in [Dietterich and Bakiri, 1995] proposes to choose a code with a large distance.\nOne vs. All (OvA) and All Pairs (AP): Let H ⊂ {±1}X and k ≥ 2. In the OvA method we train k binary problems, each of which discriminates between one class and the rest of the classes. In the AP approach all pairs of classes are compared to each other. This is formally defined as two ECOCs. Define MOvA ∈ Rk×k to be the matrix whose (i, j) elements is 1 if i = j and −1 if i 6= j. Then, the hypothesis class of OvA is HOvA = HMOvA . For the AP method, let MAP ∈ Rk×( k 2) be such that for all i ∈ [k] and 1 ≤ j < l ≤ k, the coordinate corresponding to row i and column (j, l) is defined to be −1 if i = j, 1 if i = l, and 0 otherwise. Then, the hypothesis class of AP isHAP = HMAP .\nOur analysis of the estimation error is based on results that bound the sample complexity of multiclass learning. The sample complexity of an algorithm A is the function mA defined as follows: For , δ > 0, mA( , δ) is the smallest integer such that for every m ≥ mA( , δ) and every distribution D on X ×Y , with probability of > 1− δ over the choice of an i.i.d. sample S of size m,\nErr(A(Sm)) ≤ min h∈H Err(h) + . (2)\nThe first term on the right-hand side is the approximation error of H. Therefore, the sample complexity is the number of examples required to ensure that the estimation error ofA is at most (with high probability). We denote the sample complexity of a class H by mH( , δ) = infAmA( , δ), where the infimum is taken over all learning algorithms.\nTo bound the sample complexity of a hypothesis class we rely on upper and lower bounds on the sample complexity in terms of two generalizations of the VC dimension for multiclass problems, called the Graph dimension and the Natarajan dimension and denoted dG(H) and dN (H). For completeness, these dimensions are formally defined in the appendix.\nTheorem 2.1. Daniely et al. [2011] For every hypothesis classH, and for every ERM rule,\nΩ\n( dN (H) + ln( 1δ )\n2\n) ≤ mH( , δ) ≤ mERM( , δ) ≤ O ( min{dN (H) ln(|Y|), dG(H)}+ ln( 1δ )\n2 ) We note that the constants in the O,Ω notations are universal.\n2The use of λ here allows us to later consider codes with random association of rows to labels."
    }, {
      "heading" : "3 Main Results",
      "text" : "In Section 3.1 we analyze the sample complexity of the different hypothesis classes. We provide lower bounds on the Natarajan dimensions of the various hypothesis classes, thus concluding, in light of Theorem 2.1, a lower bound on the sample complexity of any algorithm. We also provide upper bounds on the graph dimensions of these hypothesis classes, yielding, by the same theorem, an upper bound on the estimation error of ERM. In Section 3.2 we analyze the approximation error of the different hypothesis classes."
    }, {
      "heading" : "3.1 Sample Complexity",
      "text" : "Together with Theorem 2.1, the following theorems estimate, up to logarithmic factors, the sample complexity of the classes under consideration. We note that these theorems support the rule of thumb that the Natarajan and Graph dimensions are of the same order of the number of parameters. The first theorem shows that the sample complexity of MSVM depends on Θ̃(dk).\nTheorem 3.1. d(k − 1) ≤ dN (L) ≤ dG(L) ≤ O(dk log(dk)).\nNext, we analyze the sample complexities of TC and ECOC. These methods rely on an underlying hypothesis class of binary classifiers. While our main focus is the case in which the binary hypothesis class is halfspaces over Rd, the upper bounds on the sample complexity we derive below holds for any binary hypothesis class of VC dimension d+ 1.\nTheorem 3.2. For every binary hypothesis class of VC dimension d + 1, and for any tree T , dG(HT ) ≤ dG(Htrees) ≤ O(dk log(dk)). If the underlying hypothesis class is halfspaces over Rd, then also\nd(k − 1) ≤ dN (HT ) ≤ dG(HT ) ≤ dG(Htrees) ≤ O(dk log(dk)).\nTheorems 3.1 and 3.2 improve results from Daniely et al. [2011] where it was shown that bd2cb k 2 c ≤ dN (L) ≤ O(dk log(dk)), and for every tree dG(HT ) ≤ O(dk log(dk)). Further it was shown that if H is the set of halfspaces over Rd, then Ω ( dk\nlog(k)\n) ≤ dN (HT ).\nWe next turn to results for ECOC, and its special cases OvA and AP.\nTheorem 3.3. For every M ∈ Rk×l and every binary hypothesis class of VC dimension d, dG(HM ) ≤ O(dl log(dl)). Moreover, if M ∈ {±1}k×l and the underlying hypothesis class is halfspaces over Rd, then\nd · δ(M)/2 ≤ dN (HM ) ≤ dG(HM ) ≤ O(dl log(dl)) .\nWe note if the code has a large distance, which is the case, for instance, in random codes, then δ(M) = Ω(l). In this case, the bound is tight up to logarithmic factors.\nTheorem 3.4. For any binary hypothesis class of VC dimension d, dG(HOvA) ≤ O(dk log(dk)) and dG(HAP) ≤ O(dk2 log(dk)). If the underlying hypothesis class is halfspaces over Rd we also have:\nd(k − 1) ≤ dN (HOvA) ≤ dG(HOvA) ≤ O(dk log(dk)) and d ( k−1\n2\n) ≤ dN (HAP) ≤ dG(HAP) ≤ O(dk2 log(dk))."
    }, {
      "heading" : "3.2 Approximation error",
      "text" : "We first show that the class L essentially contains HOvA and HT for any tree T , assuming, of course, that H is the class of halfspaces in Rd. We find this result quite surprising, since the sample complexity of all of these classes is of the same order.\nTheorem 3.5. L essentially containsHtrees andHOvA. These inclusions are strict for d ≥ 2 and k ≥ 3.\nOne might suggest that a small increase in the dimension would perhaps allow us to embed L inHT for some tree T or for OvA. The next result shows that this is not the case.\nTheorem 3.6. Any embedding into a higher dimension that allows HOvA or HT (for some tree T for k classes) to essentially contain L, necessarily embeds into a dimension of at least Ω̃(dk).\nThe next theorem shows that the approximation error of AP is better than that of MSVM (and hence also better than OvA and TC). This is expected as the sample complexity of AP is considerably higher, and therefore we face the usual trade-off between approximation and estimation error.\nTheorem 3.7. HAP essentially contains L. Moreover, there is a constant k∗ > 0, independent of d, such that the inclusion is strict for all k ≥ k∗.\nFor a random ECOC of length o(k), it is easy to see that it does not contain MSVM, as MSVM has higher complexity. It is also not contained in MSVM, as it generates non-convex regions of labels.\nWe next derive absolute lower bounds on the approximation errors of ECOC and TC when d k. Recall that both methods are built upon binary classifiers that should predict h(x) = 1 if the label of x is in L, for some L ⊂ [k], and should predict h(x) = −1 if the label of x is not in L. As the following lemma shows, when the partition of [k] into the two sets L and [k] \\ L is arbitrary and balanced, and k d, such binary classifiers will almost always perform very poorly.\nLemma 3.8. There exists a constant C > 0 for which the following holds. Let H ⊆ {±1}X be any hypothesis class of VC-dimension d, let µ ∈ (0, 1/2], and let D be any distribution over X × [k] such that ∀i P(x,y)∼D(y = i) ≤ 10k . Let φ : [k]→ {±1} be a randomly chosen function which is sampled according to one of the following rules: (1) For each i ∈ [k], each coordinate φ(i) is chosen independently from the other coordinates and P(φ(i) = −1) = µ; or (2) φ is chosen uniformly among all functions satisfying |{i ∈ [k] : φ(i) = −1}| = µk.\nLet Dφ be the distribution over X × {±1} obtained by drawing (x, y) according to D and replacing it with (x, φ(y)). Then, for any ν > 0, if k ≥ C · ( d+ln( 1δ )\nν2\n) , then with probability of at least 1− δ over the\nchoice of φ, the approximation error ofH with respect to Dφ will be at least µ− ν.\nAs the corollaries below show, Lemma 3.8 entails that when k d, both random ECOCs with a small code length, and balanced trees with a random labeling of the leaves, are expected to perform very poorly.\nCorollary 3.9. There is a constant C > 0 for which the following holds. Let (T, λ) be a tree for k classes such that λ : leaf(T ) → [k] is chosen uniformly at random. Denote by kL and kR the number of leaves of the left and right sub-trees (respectively) that descend from root, and let µ = min{k1k , k2 k }. Let H ⊆ {±1}X be a hypothesis class of VC-dimension d, let ν > 0, and letD be any distribution over X × [k] such that ∀i P(x,y)∼D(y = i) ≤ 10k . Then, for k ≥ C · ( d+ln( 1δ ) ν2 ) , with probability of at least 1 − δ over the choice of λ, the approximation error ofHT with respect to D is at least µ− ν.\nCorollary 3.10. There is a constant C > 0 for which the following holds. Let (M,λ) be an ECOC where M ∈ Rk×l, and assume that the bijection λ : [k] → [k] is chosen uniformly at random. Let H ⊆ {±1}X be a hypothesis class of VC-dimension d, let ν > 0, and let D be any distribution over X × [k] such that ∀i P(x,y)∼D(y = i) ≤ 10k . Then, for k ≥ C · ( dl log(dl)+ln( 1δ ) ν2 ) , with probability of at least 1− δ over the choice of λ, the approximation error ofHM with respect to D is at least 1/2− ν.\nNote that the first corollary holds even if only the top level of the binary tree is balanced and splits the labels randomly to the left and the right sub-trees. The second corollary holds even if the code itself is not random (nor does it have to be binary), and only the association of rows with labels is random. In particular, if the length of the code is O(log(k)), as suggested in Allwein et al. [2000], and the number of classes is Ω̃(d), then the code is expected to perform poorly.\nFor an ECOC with a matrix of length Ω(k) and d = o(k), we do not have such a negative result as stated in Corollary 3.10. Nonetheless, Lemma 3.8 implies that the prediction of the binary classifiers when d = o(k) is just slightly better than a random guess, thus it seems to indicate that the ECOC method will still perform poorly. Moreover, most current theoretical analyses of ECOC estimate the error of the learned multiclass hypothesis in terms of the average error of the binary classifiers. Alas, when the number of classes is large, Lemma 3.8 shows that this average will be close to 12 .\nFinally, let us briefly discuss the tightness of Lemma 3.8. Let x1, . . . , xd+1 ∈ Rd be affinely independent and let D be the distribution over Rd × [d + 1] defined by P(x,y)∼D((x, y) = (xi, i)) = 1d+1 . Is is not hard to see that for every φ : [d + 1] → {±1}, the approximation error of the class of halfspaces with respect toDφ is zero. Thus, in order to ensure a large approximation error for every distribution, the number of classes must be at least linear in the dimension, so in this sense, the lemma is tight. Yet, this example is very simple, since each class is concentrated on a single point and the points are linearly independent. It is possible that in real-world distributions, a large approximation error will be exhibited even when k < d.\nWe note that the phenomenon of a large approximation error, described in Corollaries 3.9 and 3.10, does not reproduce in the classes L,HOvA andHAP , since these classes are symmetric."
    }, {
      "heading" : "4 Proof Techniques",
      "text" : "Due to lack of space, the proofs for all the results stated above are provided in the appendix. In this section we give a brief description of our main proof techniques.\nMost of our proofs for the estimation error results, stated in Section 3.1, are based on a similar method which we now describe. Let L : {±1}l → [k] be a multiclass-to-binary reduction (e.g., a tree), and for H ⊆ {±1}X , denote L(H) = {x 7→ L(h1(x), . . . , hl(x)) | h1, . . . , hl ∈ H}. Our upper bounds for dG(L(H)) are mostly based on the following simple lemma.\nLemma 4.1. If VC(H) = d then dG(L(H)) = O(ld ln(ld)).\nThe technique for the lower bound on dN (L(W)) when W is the class of halfspaces in Rd is more involved, and quite general. We consider a binary hypothesis class G ⊆ {±1}[d]×[l] which consists of functions having an arbitrary behaviour over [d]× {i}, and a very uniform behaviour on other inputs (such as mapping all other inputs to a constant). We show that L(G) N -shatters the set [d]× [l]. Since G is quite simple, this is usually not very hard to show. Finally, we show that the class of halfspaces is richer than G, in the sense that the inputs to G can be mapped to points in Rd such that the functions of G can be mapped to halfspaces. We conclude that dN (L(W)) ≥ dN (L(G)).\nTo prove the approximation error lower bounds stated in Section 3.2, we use the techniques of VC theory in an unconventional way. The idea of this proof is as follows: Using a uniform convergence argument based on the VC dimension of the binary hypothesis class, we show that there exists a small labeled sample S whose approximation error for the hypothesis class is close to the approximation error for the distribution, for all possible label mappings. This allows us to restrict our attention to a finite set of hypotheses, by their restriction to the sample. For these hypotheses, we show that with high probability over the choice of label mapping, the approximation error on the sample is high. A union bound on the finite set of possible hypotheses shows that the approximation error on the distribution will be high, with high probability over the choice of the label mapping."
    }, {
      "heading" : "5 Implications",
      "text" : "The first immediate implication of our results is that whenever the number of examples in the training set is Ω̃(dk), MSVM should be preferred to OvA and TC. This is certainly true if the hypothesis class of MSVM, L, has a zero approximation error (the realizable case), since the ERM is then solvable with respect to L.\nNote that since the inclusions given in Theorem 3.5 are strict, there are cases where the data is realizable with MSVM but not withHOvA or with respect to any tree.\nIn the non-realizable case, implementing the ERM is intractable for all of these methods. Nonetheless, for each method there are reasonable heuristics to approximate the ERM, which should work well when the approximation error is small. Therefore, we believe that MSVM should be the method of choice in this case as well due to its lower approximation error. However, variations in the optimality of algorithms for different hypothesis classes should also be taken into account in this analysis. We leave this detailed analysis of specific training heuristics for future work. Our analysis also implies that it is highly unrecommended to use TC with a randomly selected λ or ECOC with a random code whenever k > d. Finally, when the number of examples is much larger than dk2, the analysis implies that it is better to choose the AP approach.\nTo conclude this section, we illustrate the relative performance of MSVM, OvA, TC, and ECOC, by considering the simplistic case where d = 2, and each class is concentrated on a single point in R2. In the leftmost graph below, there are two classes in R2, and the approximation error of all algorithms is zero. In the middle graph, there are 9 classes ordered on the unit circle of R2. Here, both MSVM and OvA have a zero approximation error, but the error of TC and of ECOC with a random code will most likely be large. In the rightmost graph, we chose random points in R2. MSVM still has a zero approximation error. However, OvA cannot learn the binary problem of distinguishing between the middle point and the rest of the points and hence has a larger approximation error.\nMSVM 3 3 3 OvA 3 3 7 TC/ECOC 3 7 7"
    }, {
      "heading" : "A Proofs",
      "text" : ""
    }, {
      "heading" : "A.1 Notation and Definitions",
      "text" : "Throughout the proofs, we fix d, k ≥ 2. We denote byW = Wd = {hw : w ∈ Rd+1} the class of linear separators (with bias) over Rd. We assume the following ”tie breaking” conventions:\n• For f : [k]→ R, argmaxi∈[k]f(i) is the minimal number i0 ∈ [k] for which f(i0) = maxi∈[k] f(i);\n• sign(0) = 1.\nGiven a hypotheses classH ⊆ YX , denote its restriction toA ⊆ X byH|A = {f |A : f ∈ H}. LetH ⊆ YX be a hypothesis class and let φ : Y → Y ′, ι : X → X ′ be functions. Denote φ ◦ H = {φ ◦ h : h ∈ H} and H ◦ ι = {h ◦ ι : h ∈ H}.\nGiven H ⊆ YX and a distribution D over X × Y , denote the approximation error by Err∗D(H) = infh∈H ErrD(h). Recall that by definition 1.1, H essentially contains H′ ⊆ YX if and only if Err∗D(H) ≤ Err∗D(H′) for every distribution D. For a binary hypothesis classH, denote its VC dimension by VC(H).\nLet H ⊆ YX be a hypothesis class and let S ⊆ X . We say that H G-shatters S if there exists an f : S → Y such that for every T ⊆ S there is a g ∈ H such that\n∀x ∈ T, g(x) = f(x), and ∀x ∈ S \\ T, g(x) 6= f(x).\nWe say that H N-shatters S if there exist f1, f2 : S → Y such that ∀y ∈ S, f1(y) 6= f2(y), and for every T ⊆ S there is a g ∈ H such that\n∀x ∈ T, g(x) = f1(x), and ∀x ∈ S \\ T, g(x) = f2(x).\nThe graph dimension of H, denoted dG(H), is the maximal cardinality of a set that is G-shattered by H. The Natarajan dimension of H, denoted dN (H), is the maximal cardinality of a set that is N-shattered by H. Both of these dimensions coincide with the VC-dimension for |Y| = 2. Note also that we always have dN (H) ≤ dG(H). As shown in Ben-David et al. [1995], it also holds that dG(H) ≤ 4.67 log2(|Y |)dN (H).\nProof of Lemma 4.1. Let A ⊆ X be a G-shattered set with |A| = dG(L(H)). By Sauer’s Lemma, 2|A| ≤ |H|A|l ≤ |A|dl, thus dG(L(H)) = |A| = O(ld log(ld))."
    }, {
      "heading" : "A.2 Multiclass SVM",
      "text" : "Proof of Theorem 3.1. The lower bound follows from Theorems 3.5 and 3.2. To upper bound dG := dG(L), let S = {x1, . . . , xdG} ⊆ Rd be a set which is G-shattered by L, and let f : S → [k] be a function that witnesses the shattering. For x ∈ Rd and j ∈ [k], denote\nφ(x, j) = (0, . . . 0, x[1], . . . , x[d], 1, 0, . . . , 0) ∈ R(d+1)k,\nwhere x[1] is in the (d+ 1)(j − 1) coordinate. For every (i, j) ∈ [dG]× [k], define zi,j = φ(xi, f(xi))− φ(xi, j). Denote Z = {zi,j | (i, j) ∈ [dG]× [k]}. Since VC(W(d+1)k) = (d+ 1)k+ 1, by Sauer’s lemma,\n|W(d+1)k|Z | ≤ |Z|(d+1)k+1 = (dGk)(d+1)k+1.\nWe now show that there is a one-to-one mapping from subsets of S toW(d+1)k|Z , thus concluding an upper bound on the size of S. For any T ⊆ S, choose W (T ) ∈ Rk×(d+1)(R) such that\n{x ∈ S | hW (T )(x) = f(x)} = T.\nSuch a W (T ) exists because of the G-shattering of S by L using the witness f . Define the vector w(T ) ∈ Rk(d+1) which is the concatenation of the rows of W (T ), that is\nw(T ) = (W (T )(1,1), . . . ,W (T )(1,d+1), . . . ,W (T )(k,1), . . . ,W (T )(k,d+1))\n. Now, suppose that T1 6= T2 for T1, T2 ⊆ S. We now show that w(T1)|Z 6= w(T2)|Z . Suppose w.l.o.g. that there is some xi ∈ T1 \\ T2. Thus, f(xi) = hW (T1)(xi) 6= hW (T2)(xi) =: j. It follows that the inner product of xi with row f(xi) of W (T1) is greater than the inner product of xi with row j of W (T1), while for W (T2), the situation is reversed. Therefore, sign(〈w(T1), zi,j〉) 6= sign(〈w(T2), zi,j〉), so w(T1) and w(T2) induce different labelings of Z. It follows that the number of subsets of S is bounded by the size of W(d+1)k|Z , thus 2dG ≤ (kdG)(d+1)k+1. We conclude that dG ≤ O(dk log(dk)).\nA.3 Simple classes that can be represented by the class of linear separators In this section we define two fairly simple hypothesis classes, and show that the class of linear separators is richer than them. We will later use this observation to prove lower bounds on the Natarajan dimension of various multiclass hypothesis classes.\nLet l ≥ 2. For f ∈ {−1, 1}[d], i ∈ [l], j ∈ {−1, 1} define f i,j : [d]× [l]→ {−1, 1} by\nf i,j(u, v) =\n{ f(u) v = i\nj v 6= i,\nAnd define the hypothesis class F l as\nF l = {f i,j : f ∈ {±1}[d], i ∈ [l], j ∈ {−1, 1}}.\nFor g ∈ {−1, 1}[d], i ∈ [l], j ∈ {±1} define gi,j : [d]× [l]→ {−1, 1} by\ngi,j(u, v) =  h(u) v = i j v > i\n−j v < i,\nAnd define the hypothesis class Gl as\nGl = {gi,j : g ∈ {−1, 1}[d], i ∈ [l], j ∈ {±1}}.\nLet H ⊂ YX ,H′ ⊂ YX ′ be two hypotheses classes. We say that H is richer than H′ if there is a mapping ι : X ′ → X such that H′ = H ◦ ι. It is clear that if H is richer than H′ then dN (H′) ≤ dN (H) and dG(H′) ≤ dG(H). Thus, the notion of richness can be used to establish lower and upper bounds on the Natarajan and Graph dimension, respectively. The following lemma shows thatW is richer than F l and Gl for every l. This will allow us to use the classes F l, Gl instead ofW when bounding from below the dimension of an ECOC or TC hypothesis class in which the binary classifiers are fromW .\nLemma A.1. For any integer l ≥ 2,W is richer than F l and Gl.\nProof. We shall first prove that W is richer than F l. Choose l unit vectors e1, . . . , el ∈ Rd. For every i ∈ [l], choose d affinely independent vectors such that\nx1,i, . . . , xd,i ∈ {x ∈ Rd : 〈x, ei〉 = 1, ∀i′ 6= i, 〈x, ei′〉 < 1}.\nThis can be done by choosing d affinely independent vectors in {x ∈ Rd : 〈x, ei〉 = 1} that are very close to ei. Define ι(m, i) = xm,i. Now fix i ∈ [l] and j ∈ {−1,+1}, and let f i,j ∈ F l. We must show that f i,j = h ◦ ι for some h ∈ W . We will show that there exists an affine map Λ : Rd → R for which f i,j = sign ◦Λ ◦ ι. This suffices, sinceW is exactly the set of all functions of the form sign ◦Λ where Λ is an affine map. Define M = {x ∈ Rd : 〈x, ei〉 = 1}, and let A : M → R be the affine map defined by\n∀m ∈ [d], A(xm,i) = f(m, i).\nLet P : Rd →M be the orthogonal projection of Rd on M . For α ∈ R, define an affine map Λα : Rd → R by\nΛα(x) = A(P (x)) + α · 〈x− ei, ei〉.\nNote that, ∀m ∈ [d], Λα(xm,i) = f(m, i). Moreover, for every i′ 6= i and m ∈ [d] we have 〈xm,i′ − ei, ei〉 < 0. Thus, by choosing |α| sufficiently large and choosing sign(α) depending on j, we can make sure that f i,j = sign ◦ Λα ◦ ι.\nThe proof thatW is richer than Gl is similar and simpler. Let e1, . . . , ed ∈ Rd−1 be affinely independent. Define\nι(m, i) = (em, i) ∈ Rd−1 × R ∼= Rd,\nGiven gi,j ∈ Gd,l, let A : Rd−1 × {i} → R be the affine map defined by A(em, i) = gi,j(m, i) and let P : Rd → Rd−1 × {i} be the orthogonal projection. Define Λ : Rd → R by\nΛ(x, y) = A(P (x, y)) + j · 10 · (y − i).\nIt is easy to check that sign ◦ Λ ◦ ι = gi,j .\nNote A.2. From Lemma A.1 it follows that VC(F l),VC(Gl) ≤ d+ 1. On the other hand, both F l and Gl shatter ([d]× {1}) ∪ {(1, 2)}. Thus, VC(F l) = VC(Gl) = d+ 1"
    }, {
      "heading" : "A.4 Trees",
      "text" : "Proof of Theorem 3.2. We first prove the upper bound. Let A ⊆ X be a G-shattered set with |A| = dG(Htrees). By Sauer’s Lemma, and since the number of trees is bounded by kk, we have\n2|A| ≤ kk · |H|A|k ≤ kk · |A|dk,\nthus dG(Htrees) = |A| = O(dk log(dk)). To prove the lower bound, by Lemma A.1, it is enough to show that dN (GlT ) ≥ d · (k − 1) for some l. We will take l = |N(T )| = k − 1. Linearly order N(T ) such that for every node v, the nodes in the left sub-tree emanating from v are smaller than the nodes in the corresponding right sub-tree. We will identify\n[l] with N(T ) by an order-preserving map, thus Gl ⊂ {−1, 1}[d]×N(T ). We also identify the labels with the leaves.\nDefine g1 : [d]×N(T )→ leaf(T ) by setting g1(i, v) to be the leaf obtained by starting from the node v, going right once and then going left until reaching a leaf. Similarly, define g2 : [d]×N(T )→ leaf(T ) by setting g2(i, v) to be the leaf obtained by starting from the node v, going left once and then going right until reaching a leaf.\nWe shall show that g1, g2 witness the N -shattering of [d]×N(T ) by GlT . Given S ⊂ [d]×N(T ) define C : N(T )→ Gl by\nC(v)(i, u) =  −1 u < v 1 u > v\n1 u = v, (i, u) ∈ S −1 u = v, (i, u) /∈ S.\nIt is not hard to check that ∀(i, u) ∈ S, hC(i, u) = g1(i, u), and ∀(i, u) /∈ S, hC(i, u) = g2(i, u).\nNote A.3. Define G̃l = {gi,1 : g ∈ {−1, 1}[d], i ∈ [l]}. The proof shows that dN (G̃lT ) ≥ d · (k − 1). Since VC(G̃l) = d, we obtain a simpler proof of Theorem 23 from Daniely et al. [2011], which states that for every tree T there exists a classH of VC dimension d for which dN (HT ) ≥ d(k − 1)."
    }, {
      "heading" : "A.5 ECOC, One vs. All and All Pairs",
      "text" : "To prove the results for ECOC and its special cases, we first prove a more general theorem, based on the notion of a sensitive vector for a given code. Fix a code M ∈ Rk×l(R). We say that a binary vector u ∈ {±1}l is q-sensitive for M if there are q indices j ∈ [l] for which M̃(u) 6= M̃(u ⊕ ej). Here, u⊕ ej := (u[1], . . . ,−u[j], . . . , u[l]).\nTheorem A.4. If there exists a q-sensitive vector for a code M ∈ Rk×l(R) then dN (WM ) ≥ d · q.\nProof. By Lemma A.1, it suffices to show that dN (F lM ) ≥ d · q. Let u ∈ {±1}l be a q-sensitive vector. Assume w.l.o.g. that the sensitive coordinates are 1, . . . , q. We shall show that [d] × [q] is N -shattered by F lM . Define g1, g2 : [d]× [q]→ [k] by\ng1(x, y) = M̃(u), g2(x, y) = M̃(u⊕ ey)\nLet T ⊂ [d] × [q]. Define h1, . . . , hl ∈ F l as follows. For every j > q, define hj ≡ u[j]. For j ≤ q define\nhj(x, y) =  u[j] y 6= j u[j] y = j, (x, y) ∈ T −u[j] y = j, (x, y) ∈ [d]× [q] \\ T.\nFor h = (h1, . . . , hl), it is not hard to check that\n∀(x, y) ∈ T, M̃(h1(x, y), . . . , hl(x, y)) = g1(x, y), and ∀(x, y) ∈ [d]× [q] \\ T, M̃(h1(x, y), . . . , hl(x, y)) = g2(x, y).\nThe following lemma shows that a code with a large distance is also highly sensitive. In fact, we prove a stronger claim: the sensitivity is actually at least as large as the distance between any row and the row closest to it in Hamming distance. Formally, we consider ∆(M) = maxi minj 6=i ∆h(M [i],M [j]) ≥ δ(M).\nLemma A.5. For any codeM ∈ Rk×l(±1), there is a q-sensitive vector forM , where q ≥ 12∆(M) ≥ 1 2δ(M).\nProof. Let i1 the row in M such that its hamming distance to the row closest to it is ∆(M). Denote by i2 the index of the closest row (if there is more than one such row, choose one of them arbitrarily). We have ∆h(M [i1],M [i2]) = ∆(M). In addition, ∀i 6= i1, i2,∆h(M [i1],M [i]) ≥ ∆(M). Assume w.l.o.g. that the indices in which rows i1 and i2 differ are 1, . . . ,∆(M). Consider first the case that i1 < i2. Define u ∈ {±1}[l] by\nu[j] = { M(i1,j) j ≤ d∆2 e M(i2,j) otherwise.\nIs is not hard to check that for every 1 ≤ j ≤ d∆2 e, i1 = M̃(u) and M̃(u⊕ej) = i2, thus u is d ∆ 2 e-sensitive. If i1 > i2, the proof is similar except that u is defined as\nu[j] = { M(i2,j) j ≤ d∆2 e M(i1,j) otherwise.\nProof of Theorem 3.3. The upper bound follows from Lemma 4.1. The lower bound follows form Theorem A.4 and Lemma A.5.\nProof of Theorem 3.4. The upper bounds follow from Theorem 3.3. To show that dN (WOvA) ≥ (k − 1)d, we note that the all-negative vector u = (−1, . . . ,−1) of length k is (k − 1)-sensitive for the code MOvA, and apply Theorem A.4.\nTo show that dN (WAP) ≥ d ( k−1\n2\n) , assume for simplicity that k is odd (a similar analysis can be given\nwhen k is even). Define u ∈ {±1}( k 2) by\n∀i < j, u[i, j] = { 1 j − i ≤ k−12 −1 otherwise.\nFor every n ∈ [k], we have ∑\n1≤i<j≤k u[i, j] · MAPn,(i,j) = 0, as the summation counts the number of pairs (i, j) such that n ∈ {i, j} and MAPn,(i,j) agrees with u[i, j]. Thus, M̃ AP(u) = 1, by our tiebreaking assumptions. Moreover, it follows that for every 1 < i < j ≤ k, we have M̃AP(u⊕e(i,j)) ∈ {i, j}, since flipping entry [i, j] of u increases (MAPu)j or (MAPu)i by 1 and does not increase the rest of the coordinates of the vector MAPu. This shows that u is ( k−1\n2\n) -sensitive."
    }, {
      "heading" : "A.6 Approximation",
      "text" : "Proof of Theorem 3.5. We first show that for any tree for k classes T , L essentially containsWT . It follows that L essentially containsWtrees as well. Let D a distribution over Rd, let C : N(T )→W be a mapping associating nodes in T to binary classifiers in W , and let > 0. We will show that there exists a matrix W ∈ Rk×(d+1) such that Prx∼D[hW (x) 6= hC(x)] < .\nFor every v ∈ N(T ), denote by w(v) ∈ Rd+1 the linear separator such that C(v) = hw(v). For every w ∈ Rd+1 define w̃ = w + (0, . . . , 0, γ). Recall that for x ∈ Rd, x̄ ∈ Rd+1 is simply the concatenation (x, 1). Choose r > 0 large enough so that Prx∼D[||x̄|| > r] < /2 and ∀v ∈ N(T ), ||w̃(v)|| < r. Choose γ > 0 small enough so that\nPr x∼D [∃v ∈ N(T ), 〈w̃(v), x̄〉 ∈ (−γ, γ)] = Pr x∼D [∃v ∈ N(T ), 〈w(v), x̄〉 ∈ (−2γ, 0)] < /2.\nLet a = 2r2/γ+ 1. For i ∈ [k], let vi,1, . . . , vi,mi be the path from the root to the leaf associated with label i. For each 1 ≤ j < mi define bi,j = 1 if vi,j+1 is the right son of vi,j , and bi,j = −1 otherwise. Now, define W ∈ Rk×(d+1) to be the matrix whose i’th row is wi = ∑mi−1 j=1 a −j · bi,jw̃(vi,j).\nTo prove that Prx∼D[hW (x) 6= hC(x)] < , it suffices to show that hW (x) = hC(x) for every x ∈ Rd satisfying ||x̄|| < r and ∀v ∈ N(T ), 〈w̃(v), x̄〉 /∈ (−γ, γ), since the probability mass of the rest of the vectors is less than . Let x ∈ Rd be a vector that satisfies these assumptions. Denote i1 = hC(x). It suffices to show that for all i2 ∈ [k] \\ {i1}, 〈wi1 , x̄〉 > 〈wi2 , x̄〉, since this would imply that hW (x) = i1 as well.\nIndeed, fix i2 6= i1, and let j0 be the length of the joint prefix of the two root-to-leaf paths that match the labels i1 and i2. In other words, ∀j ≤ j0, vi1,j = vi2,j and vi1,j0+1 6= vi2,j0+1. Note that\n〈x̄, (bi1,j0 − bi2,j0)w̃(vi1,j0)〉 = 〈x̄, 2bi1,j0w̃(vi1,j0)〉 = 2|〈x̄, w̃(vi1,j0)〉| ≥ 2γ.\nThe last equality holds because bi1,j0 and 〈x̄, w(vi1,j0)〉 have the same sign by definition of bi,j . We have\n〈wi1 , x̄〉 − 〈wi2 , x̄〉 = 〈x̄, mi1−1∑ j=1 a−jbi1,jw̃(vi1,j)− mi2−1∑ j=1 a−jbi2,jw̃(vi2,j)〉\n= 〈x̄, a−j0(bi1,j0 − bi2,j0)w̃(vi1,j0)〉+ 〈x̄, mi1−1∑ j=j0+1 a−jbi1,jw̃(vi1,j)− mi2−1∑ j=j0+1 a−jbi2,jw̃(vi2,j)〉\n≥ 〈x̄, a−j0(bi1,j0 − bi2,j0)w̃(vi1,j0)〉 − ∞∑\nj=j0+1\na−j2r2\n≥ 2a−j0 ( γ − r 2\na− 1\n) > 0.\nSince this holds for all i2 6= i1, it follows that hW (x) = i1. Thus, we have proved that L essentially contains Wtrees.\nNext, we show that L strictly contains Wtrees, by showing a distribution over labeled examples such that the approximation error using L is strictly smaller than the approximation error usingWtrees. Assume w.l.o.g. that d = 2 and k = 3: even if they are larger we can always restrict the support of the distribution to a subspace of dimension 2 and to only three of the labels. Consider the distribution D over R2× [3] such that its marginal over R2 is uniform in the unit circle, and Pr(X,Y )∼D[Y = i | X = x] = I[x ∈ Di], where D1, D2, D3 be subsets sectors of equal angle of the unit circle (see Figure 1):\nClearly, by taking the rows ofW to point to the middle of each sector (dashed arrows in the illustration), we get Err∗D(L) = 0. In contrast, no linear separator can split the three labels into two gropus without error, thus Err∗D(Wtrees) > 0.\nFinally, to see that L essentially contains WOvA, we note that WOvA = WT where T is a tree such that each of its internal nodes has a leaf corresponding to one of the labels as its left son. Thus WOvA is essentially contained inWtrees.\nProof of Theorem 3.7. It is easily seen thatWAP contains L: Let W ∈ Rd+1×k, and denote its i’th row by W [i]. For each column (i, j) of MAP, define the binary classifier hi,j ∈ W such that ∀x ∈ Rd, hi,j(x̄) = sign(〈W [j]−W [i], x̄〉). Then for all x, hW (x) = M̃AP(h1,1(x), . . . , hk−1,k(x)).\nTo show that the inclusion is strict, as in the proof of Theorem 3.5, we can and will assume that d = 2. Choose k∗ to be the minimal number such that for every k ≥ k∗, dN (WAP ) > dN (L): This number exists by Theorems 3.4 and 3.1 (note that though we chose k∗ w.r.t. d = 2, the same k∗ is valid for every d). For any k ≥ k∗, it follows that there is a set S ⊆ R2 that is N -shattered byWAP but not by L. Thus, there is a hypothesis h ∈ WAP such that for every g ∈ L, g|S 6= h|S . Define the distribution D to be uniform over {(x, h(x)) : x ∈ S}. Then clearly Err∗D(L) > Err ∗ D(WAP ) = 0.\nNext, we prove Theorem 3.6, which we restate more formally as follows. Note that the result on OvA is implied since there exists a tree that implements OvA.\nTheorem A.6. (Restatement of Theorem 3.6) If there exists an embedding ι : Rd → Rd′ and a tree T such thatWd′T ◦ ι essentially contains L, then necessarily d′ ≥ Ω̃(dk).\nProof. Assume that i ∈ [k] is the class corresponding to the leaf with the least depth, l. Note that l ≤ log2(k). Let φ : [k] → {±1} be the function that is 1 on {i} and −1 otherwise. It is not hard to see that φ ◦ L is the hypothesis class of convex polyhedra in Rd having k − 1 faces. Thus,\nVC(φ ◦ L) ≥ (k − 1)d, (3)\n[see e.g. Takacs, 2009]. On the other hand, φ ◦ Wd′T , is the class of convex polyhedra in Rd ′\nhaving l ≤ log2(k) faces. Thus, by Lemma 4.1\nVC(φ ◦Wd ′ T ◦ ι) ≤ VC(φ ◦Wd ′ T ) ≤ O(ld′ log(ld′)) ≤ O(log(k)d′ log(log(k)d′)) (4)\nBy the assumption thatWd′T ◦ ι essentially contains L, VC(φ ◦ L) ≤ VC(φ ◦ Wd ′\nT ◦ ι). Combining with equations (3) and (4) it follows that d(k − 1) = O(log(k)d′ log(log(k)d′)). Thus, d′ = Ω̃ (dk).\nTo prove Lemma 3.8, we first state the classic VC-dimension theorem, which will be useful to us.\nTheorem A.7 (Vapnik [1998]). There exists a constant C > 0 such that for every hypothesis class H ⊆ {±1}X of VC dimension d, a distribution D over X , , δ > 0 and m ≥ C d+ln( 1 δ ) 2 we have\nPr S∼Dm\n[ Err∗D(H) ≥ inf\nh∈H ErrS(h)−\n] ≥ 1− δ.\nWe also use the following lemma, which proves a variant of Hoeffding’s inequality.\nLemma A.8. Let β1, . . . , βk ≥ 0 and let γ1, . . . , γk ∈ R, such that ∀i, |γi| ≤ βi. Fix an integer j ∈ {1, . . . , bk2 c} and let µ = j/k. Let (X1, . . . , Xk) ∈ {±1}\nk be a random vector sampled uniformly from the set {(x1, . . . , xk) : ∑k i=1\nx1+1 2 = µk}. Define Yi = βi +Xiγi and denote αi = βi + |γi|. Assume that∑k\ni=1 αi = 1. Then\nPr [ k∑ i=1 Yi ≤ µ− ] ≤ 2 exp ( −\n2 2 ∑k i=1 α 2 i\n) .\nProof. First, since µ < 12 , it suffices to prove the claim for the case ∀i, γi ≥ 0 since this is the “harder” case. Let Z1, . . . , Zk ∈ {±1} be independent random variables such that Pr[Zi = 1] = µ − 2 . Denote Wi = βi + Ziγi. Further denote W̄ = ∑k i=1Wi and Z̄ = ∑k i=1 Zi+1 2 .\nNote that for every j0 ≤ j = µk, given that Z̄ = j0, W̄ can be described as follows: We start with the value ∑k i=1 βi−γi and then choose j0 indices uniformly from [k]. For each chosen index i, the value of W̄\nis increased by 2γi. ∑k i=1 Yi can be described in the same way, except that that j ≥ j0 indices are chosen.\nThus, Pr [∑k i=1 Yi ≤ µ− ] ≤ Pr [ W̄ ≤ µ− | Z̄ = j0 ] . Thus, we have\nPr [ k∑ i=1 Yi ≤ µ− ] ≤ Pr [ W̄ ≤ µ− | Z̄ ≤ µk ] ≤ Pr [ W̄ ≤ µ− ] /Pr [ Z̄ ≤ µk\n] ≤ 2 Pr [ W̄ ≤ µ−\n] ≤ 2 exp ( − 2\n2 ∑k i=1 α 2 i\n) .\nThe last inequality follows from Hoeffding’s inequality and noting that\nE[Wi] = βi + (2(µ− 2 )− 1)γi = (µ− 2 )(βi + γi) + (1− µ+ 2 )(βi − γi) ≥ (µ− 2 )αi.\nSo that ∑k i=1E[Wi] ≥ (µ− 2 ) ∑k i=1 αi = µ− 2 .\nProof of Lemma 3.8. The idea of this proof is as follows: Using a uniform convergence argument based on the VC dimension of the binary hypothesis class, we show that there exists a labeled sample S such that |S| ≈ d+kν2 , and for all possible mappings φ, the approximation error of the hypothesis class on the sample is close to the approximation error on the distribution Dφ. This allows us to restrict our attention to a finite set of hypotheses, based on their restriction to the sample. For these hypotheses, we show that with high probability over the choice of φ, the approximation error on the sample is high. Using a union bound on the possible hypotheses, we conclude that the approximation error on the distribution will be high, with high probability over the choice of φ.\nFor i ∈ [k], denote pi = Prx∼D[f(x) = i]. Let S = {(x1, y1), . . . , (xm, ym)} ⊆ X × [k] be an i.i.d. sample drawn according to D where m = dC d+(k+2) ln(2)(ν/2)2 e, for the constant from C from Theorem A.7. Given S, denote Sφ{(x1, φ(y1)), . . . , (xm, φ(ym))} ⊆ X × {±1}. For i ∈ [k], let p̂i = |{j:yj=i}|m .\nFor any fixed φ : [k] → {±1}, with probability > 1 − 2−(k+2) over the choice of S we have, by Theorem A.7, that Err∗Dφ(H) > infh∈H ErrSφ(h)− ν. Since |{±1} [k]| = 2k, w.p. > 1− 14 ,\n∀φ ∈ {±1}[k], Err∗Dφ(H) > infh∈HErrSφ(h)− ν 2 . (5)\nMoreover, we have\nE[ k∑ i=1 p̂2i ] = 1 m2 k∑ i=1 (( m 2 ) p2i +mpi ) ≤ k · ( m(m− 1) 2m2 100 k2 + 10 mk ) ≤ 60 k .\nThus, by Markov’s inequality, w.p. ≥ 12 we have\nk∑ i=1 p̂2i < 120 k . (6)\nThus, with probability at least 1− 14 − 1 2 > 0, both (6) and (5) holds. In particular, there exists a sample S for which both (6) and (5) hold. Let us fix such an S = {(x1, y1), . . . , (xm, ym)}. Assume now that φ ∈ {±1}[k] is sampled according to the first condition. Denote\nYi = |{j : h(xj) 6= φ(yj) and yj = i}|/m.\nFor a fixed h ∈ H we have\nPr φ\n[ ErrSφ(h) < µ− ν\n2\n] = Pr\nφ [ k∑ i=1 Yi < µ− ν 2 ]\nWe note that Yi are independent random variables withE[Yi] ≥ µp̂i and 0 ≤ Yi ≤ p̂i. Thus, by Hoeffding’s inequality,\nPr φ\n[ ErrSφ(h) < µ− ν\n2\n] ≤ exp ( − ν 2\n2 ∑k i=1 p̂ 2 i\n) ≤ exp ( −ν 2k\n240\n) .\nBy Sauer’s lemma, |H|{x1,...,xm}| ≤ ( em d )d . Thus, with probability ≥ 1 − ( em d )d exp ( −ν 2k 240 ) over the choice of φ, infh∈H ErrSφ(h) ≥ µ− ν2 and by (5) also\nErr∗Dφ(H) ≥ 1\n2 − ν. (7)\nFinally, since m = O ( k+d ν2 ) , if k = Ω ( d ln(1/ν)+ln(1/δ) ν2 ) then Eq. (7) holds w.p > 1 − δ, concluding the proof for the case when the first condition holds. If the second condition holds, the proof is very similar, with the sole difference that Lemma A.8 is used instead of Hoeffding’s inequality.\nProof of Corollary 3.9. The Corollary follows from Lemma 3.8, by noting that Err∗D(HT ) ≥ Err ∗ Dφ(H), where φ : [k] → {±1} is defined as φ(i) = 1 if and only if λ−1(i) is in the right subtree emanating from the root of T .\nProof of Corollary 3.10. Let φ : [k] → {±1} be the function that is −1 on [ bk2 c ]\nand 1 otherwise. By Lemma 4.1, applied to L(H) = φ ◦ H(M,Id), VC(φ ◦ H(M,Id)) = O(dl log(dl)), so that, by Lemma 3.8 (applied to a random choice of λ instead of φ), Err∗Dφ◦λ(φ◦H(M,Id)) ≥ 1 2−ν with probability> 1−δ over the choice of λ. The proof follows as we note that for every λ, Err∗D(H(M,λ−1)) = Err ∗ Dλ(H(M,Id)) ≥ Err∗Dφ◦λ(φ ◦ H(M,Id))."
    } ],
    "references" : [ {
      "title" : "Reducing multiclass to binary: A unifying approach for margin classifiers",
      "author" : [ "E.L. Allwein", "R.E. Schapire", "Y. Singer" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Allwein et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Allwein et al\\.",
      "year" : 2000
    }, {
      "title" : "Characterizations of learnability for classes",
      "author" : [ "S. Ben-David", "N. Cesa-Bianchi", "D. Haussler", "P. Long" ],
      "venue" : "n}-valued functions. Journal of Computer and System Sciences,",
      "citeRegEx" : "Ben.David et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Ben.David et al\\.",
      "year" : 1995
    }, {
      "title" : "Label embedding trees for large multi-class tasks",
      "author" : [ "S. Bengio", "J. Weston", "D. Grangier" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "Bengio et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Bengio et al\\.",
      "year" : 2011
    }, {
      "title" : "Multiclass classification with filter trees",
      "author" : [ "A. Beygelzimer", "J. Langford", "P. Ravikumar" ],
      "venue" : null,
      "citeRegEx" : "Beygelzimer et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Beygelzimer et al\\.",
      "year" : 2007
    }, {
      "title" : "On the algorithmic implementation of multiclass kernel-based vector machines",
      "author" : [ "K. Crammer", "Y. Singer" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Crammer and Singer.,? \\Q2001\\E",
      "shortCiteRegEx" : "Crammer and Singer.",
      "year" : 2001
    }, {
      "title" : "Multiclass learnability and the erm principle",
      "author" : [ "A. Daniely", "S. Sabato", "S. Ben-David", "S. Shalev-Shwartz" ],
      "venue" : "In COLT,",
      "citeRegEx" : "Daniely et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Daniely et al\\.",
      "year" : 2011
    }, {
      "title" : "Solving multiclass learning problems via error-correcting output codes",
      "author" : [ "T.G. Dietterich", "G. Bakiri" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Dietterich and Bakiri.,? \\Q1995\\E",
      "shortCiteRegEx" : "Dietterich and Bakiri.",
      "year" : 1995
    }, {
      "title" : "Classification by pairwise coupling",
      "author" : [ "Trevor Hastie", "Robert Tibshirani" ],
      "venue" : "The Annals of Statistics,",
      "citeRegEx" : "Hastie and Tibshirani.,? \\Q1998\\E",
      "shortCiteRegEx" : "Hastie and Tibshirani.",
      "year" : 1998
    }, {
      "title" : "In defense of one-vs-all classification",
      "author" : [ "Ryan Rifkin", "Aldebaro Klautau" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Rifkin and Klautau.,? \\Q2004\\E",
      "shortCiteRegEx" : "Rifkin and Klautau.",
      "year" : 2004
    }, {
      "title" : "Learning internal representations by error propagation",
      "author" : [ "David E. Rumelhart", "Geoffrey E. Hinton", "Ronald J. Williams" ],
      "venue" : "Parallel Distributed Processing – Explorations in the Microstructure of Cognition,",
      "citeRegEx" : "Rumelhart et al\\.,? \\Q1986\\E",
      "shortCiteRegEx" : "Rumelhart et al\\.",
      "year" : 1986
    }, {
      "title" : "Convex polyhedron learning and its applications",
      "author" : [ "G. Takacs" ],
      "venue" : "PhD thesis, Budapest University of Technology and Economics,",
      "citeRegEx" : "Takacs.,? \\Q2009\\E",
      "shortCiteRegEx" : "Takacs.",
      "year" : 2009
    }, {
      "title" : "Support vector machines for multi-class pattern recognition",
      "author" : [ "J. Weston", "C. Watkins" ],
      "venue" : "In Proceedings of the Seventh European Symposium on Artificial Neural Networks,",
      "citeRegEx" : "Weston and Watkins.,? \\Q1999\\E",
      "shortCiteRegEx" : "Weston and Watkins.",
      "year" : 1999
    }, {
      "title" : "ι). Combining with equations",
      "author" : [ ],
      "venue" : null,
      "citeRegEx" : "◦,? \\Q1998\\E",
      "shortCiteRegEx" : "◦",
      "year" : 1998
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "A different reduction is the All-Pairs (AP) approach in which all pairs of classes are compared to each other [Hastie and Tibshirani, 1998].",
      "startOffset" : 110,
      "endOffset" : 139
    }, {
      "referenceID" : 5,
      "context" : "Rumelhart et al. [1986]).",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "These two approaches have been unified under the framework of Error Correction Output Codes (ECOC) [Dietterich and Bakiri, 1995, Allwein et al., 2000]. A tree-based classifier (TC) is another reduction in which the prediction is obtained by traversing a binary tree, where at each node of the tree a binary classifier is used to decide on the rest of the path (see for example Beygelzimer et al. [2007]).",
      "startOffset" : 129,
      "endOffset" : 403
    }, {
      "referenceID" : 10,
      "context" : "Vapnik [1998], Weston and Watkins [1999], Crammer and Singer [2001]).",
      "startOffset" : 15,
      "endOffset" : 41
    }, {
      "referenceID" : 4,
      "context" : "Vapnik [1998], Weston and Watkins [1999], Crammer and Singer [2001]).",
      "startOffset" : 42,
      "endOffset" : 68
    }, {
      "referenceID" : 4,
      "context" : "Vapnik [1998], Weston and Watkins [1999], Crammer and Singer [2001]). In this paper we analyze the Multiclass SVM (MSVM) formulation of Crammer and Singer [2001], in which each hypothesis is of the form hW (x) = argmaxi∈[k](Wx̄)i, where W is a k× (d+ 1) matrix and (Wx̄)i is the i’th element of the vector Wx̄ ∈ R.",
      "startOffset" : 42,
      "endOffset" : 162
    }, {
      "referenceID" : 3,
      "context" : "If no prior knowledge on how to break the symmetry is known, it is suggested in Beygelzimer et al. [2007] to break symmetry by choosing a random permutation of the labels.",
      "startOffset" : 80,
      "endOffset" : 106
    }, {
      "referenceID" : 6,
      "context" : "The ECOC paradigm described in [Dietterich and Bakiri, 1995] proposes to choose a code with a large distance.",
      "startOffset" : 31,
      "endOffset" : 60
    }, {
      "referenceID" : 5,
      "context" : "Daniely et al. [2011] For every hypothesis classH, and for every ERM rule,",
      "startOffset" : 0,
      "endOffset" : 22
    }, {
      "referenceID" : 5,
      "context" : "2 improve results from Daniely et al. [2011] where it was shown that bd2cb k 2 c ≤ dN (L) ≤ O(dk log(dk)), and for every tree dG(HT ) ≤ O(dk log(dk)).",
      "startOffset" : 23,
      "endOffset" : 45
    }, {
      "referenceID" : 0,
      "context" : "In particular, if the length of the code is O(log(k)), as suggested in Allwein et al. [2000], and the number of classes is Ω̃(d), then the code is expected to perform poorly.",
      "startOffset" : 71,
      "endOffset" : 93
    } ],
    "year" : 2012,
    "abstractText" : "We theoretically analyze and compare the following five popular multiclass classification methods: One vs. All, All Pairs, Tree-based classifiers, Error Correcting Output Codes (ECOC) with randomly generated code matrices, and Multiclass SVM. In the first four methods, the classification is based on a reduction to binary classification. We consider the case where the binary classifier comes from a class of VC dimension d, and in particular from the class of halfspaces over R. We analyze both the estimation error and the approximation error of these methods. Our analysis reveals interesting conclusions of practical relevance, regarding the success of the different approaches under various conditions. Our proof technique employs tools from VC theory to analyze the approximation error of hypothesis classes. This is in sharp contrast to most, if not all, previous uses of VC theory, which only deal with estimation error.",
    "creator" : "LaTeX with hyperref package"
  }
}