{
  "name" : "1204.0566.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "The Kernelized Stochastic Batch Perceptron",
    "authors" : [ "Andrew Cotter" ],
    "emails" : [ "cotter@ttic.edu", "shais@cs.huji.ac.il", "nati@ttic.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n20 4.\n05 66\nv2 [\ncs .L\nG ]\n2 1\nJu n"
    }, {
      "heading" : "1. Introduction",
      "text" : "We present a novel algorithm for training kernel Support Vector Machines (SVMs). One may view a SVM as the bi-criterion optimization problem of seeking a predictor with large margin (low norm) on the one hand, and small training error on the other. Our approach is a stochastic gradient method on a nonstandard scalarization of this bi-criterion problem. In particular, we use the “slack constrained” scalarized optimization problem introduced by Hazan et al. (2011) where we seek to maximize the classification margin, subject to a constraint on the total amount of “slack”, i.e. sum of the violations of this margin. Our approach is based on an efficient method for computing unbiased gradient estimates on the objective. Our algorithm can be seen as a generalization of the “Batch Perceptron” to the non-separable case (i.e. when errors are allowed), made possible by introducing stochasticity, and we therefore refer to it as the “Stochastic Batch Perceptron” (SBP).\nThe SBP is fundamentally different from Pegasos (Shalev-Shwartz et al., 2011) and other stochastic gradient approaches to the problem of training SVMs, in\nThis is the “long version” of our ICML 2012 paper. The only difference between the two versions is that this one includes appendices.\nthat calculating each stochastic gradient estimate still requires considering the entire data set. In this regard, despite its stochasticity, the SBP is very much a “batch” rather than “online” algorithm. For a linear SVM, each iteration would require runtime linear in the training set size, resulting in an unacceptable overall runtime. However, in the kernel setting, essentially all known approaches already require linear runtime per iteration. A more careful analysis reveals the benefits of the SBP over previous kernel SVM optimization algorithms.\nIn order to compare the SBP runtime to the runtime of other SVM optimization algorithms, which typically work on different scalarizations of the bi-criterion problem, we follow Bottou & Bousquet (2008); Shalev-Shwartz & Srebro (2008) and compare the runtimes required to ensure a generalization error of L∗ + ǫ, assuming the existence of some unknown predictor u with norm ‖u‖ and expected hinge loss L∗. The main advantage of the SBP is in the regime in which ǫ = Ω(L∗), i.e. we seek a constant factor approximation to the best achievable error (e.g. we would like an error of 1.01L∗). In this regime, the overall SBP runtime is ‖u‖4 /ǫ, compared with ‖u‖4 /ǫ3 for Pegasos and ‖u‖4 /ǫ2 for the best known dual decomposition approach."
    }, {
      "heading" : "2. Setup and Formulations",
      "text" : "Training a SVM amounts to finding a vector w defining a classifier x 7→ sign(〈w,Φ (x)〉), that on the one hand has small norm (corresponding to a large classification margin), and on the other has a small training error, as measured through the average hinge loss on the training sample: L̂(w) = 1n ∑n i=1 ℓ (yi 〈w,Φ (xi)〉), where each (xi, yi) is a labeled example, and ℓ (a) = max (0, 1− a) is the hinge loss. This is captured by\nthe following bi-criterion optimization problem:\nmin w∈Rd\n‖w‖ , L̂(w). (2.1)\nWe focus on kernelized SVMs, where the feature map Φ(x) is specified implicitly via a kernel K (x, x′) = 〈Φ (x),Φ (x′)〉, and assume that K(x, x′) ≤ 1. We consider only “black box” access to the kernel (i.e. our methods work for any kernel, as long as we can compute K(x, x′) efficiently), and in our runtime analysis treat kernel evaluations as requiring O(1) runtime. Since kernel evaluations dominate the runtime of all methods studied (ours as well as previous methods), one can also interpret the runtimes as indicating the number of required kernel evaluations. To simplify our derivation, we often discuss the explicit SVM, using Φ(x), and refer to the kernel only when needed.\nA typical approach to the bi-criterion Problem 2.1 is to scalarize it using a parameter λ controlling the tradeoff between the norm (inverse margin) and the empirical error:\nmin w∈Rd\nλ 2 ‖w‖2 + 1 n\nn ∑\ni=1\nℓ (yi 〈w,Φ (xi)〉) (2.2)\nDifferent values of λ correspond to different Pareto optimal solutions of Problem 2.1, and the entire Pareto front can be explored by varying λ.\nWe instead consider the “slack constrained” scalarization (Hazan et al., 2011), where we maximize the “margin” subject to a constraint of ν on the total allowed “slack”, corresponding to the average error. That is, we aim at maximizing the margin by which all points are correctly classified (i.e. the minimal distance between a point and the separating hyperplane), after allowing predictions to be corrected by a total amount specified by the slack constraint:\nmax w∈Rd max ξ∈Rn min i∈{1,...,n}\n(yi 〈w,Φ (xi)〉+ ξi) (2.3)\nsubject to: ‖w‖ ≤ 1, ξ 0, 1T ξ ≤ nν In this scalarization, varying ν explores different Pareto optimal solutions of Problem 2.1. This is captured by the following Lemma, which also quantifies how suboptimal solutions of the slack-constrained objective correspond to Pareto suboptimal points:\nLemma 2.1. (Hazan et al., 2011, Lemma 2.1) For any u 6= 0, consider Problem 2.3 with ν = L̂ (u) / ‖u‖. Let w̄ be an ǭ-suboptimal solution to this problem with objective value γ, and consider the rescaled solution w = w̄/γ. Then:\n‖w‖ ≤ 1 1− ǭ ‖u‖ ‖u‖ , L̂ (w) ≤\n1\n1− ǭ ‖u‖L̂ (u)"
    }, {
      "heading" : "3. The Stochastic Batch Perceptron",
      "text" : "In this section, we will develop the Stochastic Batch Perceptron. We consider Problem 2.3 as optimization of the variable w with a single constraint ‖w‖ ≤ 1, with the objective being to maximize:\nf (w) = max ξ 0,1T ξ≤nν min p∈∆n\nn ∑\ni=1\npi (yi 〈w,Φ (xi)〉+ ξi)\n(3.1) Notice that we replaced the minimization over training indices i in Problem 2.3 with an equivalent minimization over the probability simplex, ∆n = {p 0 : 1T p = 1}, and that we consider p and ξ to be a part of the objective, rather than optimization variables. The objective f(w) is a concave function of w, and we are maximizing it over a convex constraint ‖w‖ ≤ 1, and so this is a convex optimization problem in w.\nOur approach will be to perform a stochastic gradient update on w at each iteration: take a step in the direction specified by an unbiased estimator of a (super)gradient of f(w), and project back to ‖w‖ ≤ 1. To this end, we will need to identify the (super)gradients of f(w) and understand how to efficiently calculate unbiased estimates of them."
    }, {
      "heading" : "3.1. Warmup: The Separable Case",
      "text" : "As a warmup, we first consider the separable case, where ν = 0 and no errors are allowed. The objective is then:\nf(w) = min i\nyi 〈w,Φ (xi)〉 , (3.2)\nThis is simply the “margin” by which all points are correctly classified, i.e. γ s.t. ∀i yi 〈w,Φ(xi)〉 ≥ γ. We seek a linear predictor w with the largest possible margin. It is easy to see that (super)gradients with respect to w are given by yiΦ(xi) for any index i attaining the minimum in Equation 3.2, i.e. by the “most poorly classified” point(s). A gradient ascent approach would then be to iteratively find such a point, update w ← w+ ηyiΦ(xi), and project back to ‖w‖ ≤ 1. This is akin to a “batch Perceptron” update, which at each iteration searches for a violating point and adds it to the predictor.\nIn the separable case, we could actually use exact supergradients of the objective. As we shall see, it is computationally beneficial in the non-separable case to base our steps on unbiased gradient estimates. We therefore refer to our method as the “Stochastic Batch Perceptron” (SBP), and view it as a generalization of the batch Perceptron which uses stochasticity and is applicable in the non-separable setting. In the same\nway that the “batch Perceptron” can be used to maximize the margin in the separable case, the SBP can be used to obtain any SVM solution along the Pareto front of the bi-criterion Problem 2.1.\n3.2. Supergradients of f(w)\nFor a fixed w, we define c ∈ Rn be the vector of “responses”:\nci = yi 〈w,Φ (xi)〉 (3.3)\nSupergradients of f(w) at w can be characterized explicitly in terms of minimax-optimal pairs p∗ and ξ∗ such that p∗ = argminp∈∆n pt(c + ξ∗) and ξ∗ = argmaxξ 0,1T ξ≤nν(p ∗)T (c+ ξ).\nLemma 3.1 (Proof in Appendix C). For any w, let p∗, ξ∗ be minimax optimal for Equation 3.1. Then ∑n\ni=1 p ∗ i yiΦ (xi) is a supergradient of f(w) at w.\nThis suggests a simple method for obtaining unbiased estimates of supergradients of f(w): sample a training index i with probability p∗i , and take the stochastic supergradient to be yiΦ (xi). The only remaining question is how one finds a minimax optimal p∗.\nIt is possible to find a minimax optimal p∗ in O(n) time. For any ξ, a solution of minp∈∆n pT (x+ ξ) must put all of the probability mass on those indices i for which ci + ξi is minimized. Hence, an optimal ξ\n∗ will maximize the minimal value of ci + ξ ∗ i . This is illustrated in Figure 1. The intuition is that the total mass nν available to ξ is distributed among the indices as if this volume of water were poured into a basin with height ci. The result is that the indices i with the lowest responses have columns of water above them such that the common surface level of the water is γ.\nOnce the “water level” γ has been determined, the optimal p∗ must be uniform on those indices i for which ξ∗i > 0, i.e. for which ci < γ, must be zero on all i s.t. ci > γ, and could take any intermediate value when ci = γ (that is, for some q > 0, we must have ci < γ → p∗i = q, ci = γ → 0 ≤ p∗i ≤ q, and ci > γ → p∗i = 0—see Figure 1). In particular, the uniform distribution over all indices such that ci ≤ γ is minimax optimal. Notice that in the separable case, where no slack is allowed, γ = mini ci and any distribution supported on the minimizing point(s) is minimax optimal, and yiΦ(xi) is an exact supergradient for such an i, as discussed in Section 3.1.\nIt is straightforward to find the water level γ in linear time once the responses ci are sorted (as in Figure 1), i.e. with a total runtime of O(n log n) due to sorting. It is also possible to find the water level γ in linear time, without sorting the responses, using a divideand-conquer algorithm, further of which may be found in Appendix B."
    }, {
      "heading" : "3.3. Kernelized Implementation",
      "text" : "In a kernelized SVM, w is an element of an implicit space, and cannot be represented explicitly. We therefore represent w as w =\n∑n i=1 αiyiΦ (xi), and main-\ntain not w itself, but instead the coefficients αi. Our stochastic gradient estimates are always of the form yiΦ(xi) for an index i. Taking a step in this direction amounts to simply increasing the corresponding αi.\nWe could calculate all the responses ci at each iteration as ci = ∑n j=1 αjyiyjK(xi, xj). However, this would require a quadratic number of kernel evaluations per iteration. Instead, as is typically done in kernelized SVM implementations, we keep the responses ci on hand, and after each stochastic gradient step of the form w ← w + ηyjΦ (xj), we update the responses as:\nci ← ci + ηyiyjK(xi, xj) (3.4) This involves only n kernel evaluations per iteration.\nIn order to project w onto the unit ball, we must either track ‖w‖ or calculate it from the responses as ‖w‖ = ∑ni=1 αici. Rescaling w so as to project it back into ‖w‖ ≤ 1 is performed by rescaling all coefficients αi and responses ci, again taking time O(n) and no additional kernel evaluations."
    }, {
      "heading" : "3.4. Putting it Together",
      "text" : "We are now ready to summarize the SBP algorithm. Starting from w(0) = 0 (so both α(0) and all responses are zero), each iteration proceeds as follows:\n1. Find p∗ by finding the “water level” γ from the re-\nsponses (Section 3.2), and taking p∗ to be uniform on those indices for which ci ≤ γ.\n2. Sample j ∼ p∗. 3. Update w(t+1) ← P ( w(t) + ηtyjΦ (xj) )\n, where P projects onto the unit ball and ηt =\n1√ t . This is\ndone by first increasing α ← α + ηt and updating the responses as in Equation 3.4, then calculating ‖w‖ (Section 3.3) and scaling α and c by min(1, 1/ ‖w‖).\nUpdating the responses as in Equation 3.4 requires O(n) kernel evaluations (the most computationally expensive part) and all other operations require O(n) scalar arithmetic operations.\nSince at each iteration we are just updating using an unbiased estimator of a supergradient, we can rely on the standard analysis of stochastic gradient descent to bound the suboptimality after T iterations:\nLemma 3.2 (Proof in Appendix C). For any T, δ > 0, after T iterations of the Stochastic Batch Perceptron, with probability at least 1 − δ, the average iterate w̄ = 1T ∑T t=1 w (t) (corresponding to ᾱ = 1T ∑T t=1 α (t)), satisfies: f (w̄) ≥ sup‖w‖≤1 f (w) −O (√ 1 T log 1 δ ) .\nSince each iteration is dominated by n kernel evaluations, and thus takes linear time (we take a kernel evaluation to require O(1) time), the overall runtime to achieve ǫ suboptimality for Problem 2.3 is O(n/ǫ2)."
    }, {
      "heading" : "3.5. Learning Runtime",
      "text" : "The previous section has given us the runtime for obtaining a certain suboptimality of Problem 2.3. However, since the suboptimality in this objective is not directly comparable to the suboptimality of other scalarizations, e.g. Problem 2.2, we follow Bottou & Bousquet (2008); Shalev-Shwartz & Srebro (2008), and analyze the runtime required to achieve a desired generalization performance, instead of that to achieve a certain optimization accuracy on the empirical optimization problem.\nRecall that our true learning objective is to find a predictor with low generalization error L0/1(w) = Pr(x,y) {y 〈w,Φ(x)〉 ≤ 0} with respect to some unknown distribution over x, y based on a training set drawn i.i.d. from this distribution. We assume that there exists some (unknown) predictor u that has norm ‖u‖ and low expected hinge loss L∗ = L(u) = E [ℓ(y 〈u,Φ(x)〉)] (otherwise, there is no point in training a SVM), and analyze the runtime to find a predictor w with generalization error L0/1(w) ≤ L∗ + ǫ. In order to understand the SBP runtime, we must\ndetermine both the required sample size and optimization accuracy. Following Hazan et al. (2011), and based on the generalization guarantees of Srebro et al. (2010), using a sample of size:\nn = Õ\n(\n(L∗ + ǫ ǫ ) ‖u‖2 ǫ\n)\n(3.5)\nand optimizing the empirical SVM bi-criterion Problem 2.1 such that:\n‖w‖ ≤ 2 ‖u‖ ; L̂ (w)− L̂ (u) ≤ ǫ/2 (3.6)\nsuffices to ensure L0/1(w) ≤ L∗ + ǫ with high probability. Referring to Lemma 2.1, Equation 3.6 will be satisfied for w̄/γ as long as w̄ optimizes the objective of Problem 2.3 to within:\nǭ = ǫ/2\n‖u‖ (L̂(u) + ǫ/2) ≥ Ω\n(\nǫ\n‖u‖ (L̂(u) + ǫ)\n)\n(3.7)\nwhere the inequality holds with high probability for the sample size of Equation 3.5. Plugging this sample size and the optimization accuracy of Equation 3.7 into the SBP runtime of O(n/ǭ2) yields the overall runtime:\nÕ\n(\n(L∗ + ǫ ǫ )3 ‖u‖4 ǫ\n)\n(3.8)\nfor the SBP to find w̄ such that its rescaling satisfies L0/1(w) ≤ L(u) + ǫ with high probability. In the realizable case, where L∗ = 0, or more generally when we would like to reach L∗ to within a small constant multiplicative factor, we have ǫ = Ω(L∗), the first factor in Equation 3.8 is a constant, and the runtime simplifies to Õ(‖u‖4 /ǫ). As we will see in Section 4, this is a better guarantee than that enjoyed by any other SVM optimization approach."
    }, {
      "heading" : "3.6. Including an Unregularized Bias",
      "text" : "It is possible to use the SBP to train SVMs with a bias term, i.e. where one seeks a predictor of the form x 7→ (〈w,Φ(x)〉+ b). We then take stochastic gradient steps on:\nf(w) = (3.9)\nmax b∈R,ξ 0 1 T ξ≤nν min p∈∆n\nn ∑\ni=1\npi (yi 〈w,Φ(xi)〉+ yib+ ξi)\nLemma 3.1 still holds, but we must now find minimax optimal p∗,ξ∗ and b∗. This can be accomplished using a modified “water filling” involving two basins,\none containing the positively-classified examples, and the other the negatively-classified ones. As in the case without an unregularized bias, this can be accomplished in O(n) time—see Appendix B for details."
    }, {
      "heading" : "4. Relationship to Other Methods",
      "text" : "We discuss the relationship between the SBP and several other SVM optimization approaches, highlighting similarities and key differences, and comparing their performance guarantees."
    }, {
      "heading" : "4.1. SIMBA",
      "text" : "Recently, Hazan et al. (2011) presented SIMBA, a method for training linear SVMs based on the same “slack constrained” scalarization (Problem 2.3) we use here. SIMBA also fully optimizes over the slack variables ξ at each iteration, but differs in that, instead of fully optimizing over the distribution p (as the SBP does), SIMBA updates p using a stochastic mirror descent step. The predictor w is then updated, as in the SBP, using a random example drawn according to p. A SBP iteration is thus in a sense more “thorough” then a SIMBA iteration. The SBP theoretical guarantee (Lemma 3.2) is correspondingly better by a logarithmic factor (compare to Hazan et al. (2011, Theorem 4.3)). All else being equal, we would prefer performing a SBP iteration over a SIMBA iteration.\nFor linear SVMs, a SIMBA iteration can be performed in time O(n + d). However, fully optimizing p as described in Section 3.2 requires the responses ci, and calculating or updating all n responses would require time O(nd). In this setting, therefore, a SIMBA iteration is much more efficient than a SBP iteration.\nIn the kernel setting, calculating even a single response requires O(n) kernel evaluation, which is the same cost as updating all responses after a change to a single coordinate αi (Section 3.3). This makes the responses essentially “free”, and gives an advantage to methods\nsuch as the SBP (and the dual decomposition methods discussed below) which make use of the responses.\nAlthough SIMBA is preferable for linear SVMs, the SBP is preferable for kernelized SVMs. It should also be noted that SIMBA relies heavily on having direct access to features, and that it is therefore not obvious how to apply it directly in the kernel setting."
    }, {
      "heading" : "4.2. Pegasos and SGD on L̂(w)",
      "text" : "Pegasos (Shalev-Shwartz et al., 2011) is a SGD method optimizing the regularized scalarization of Problem 2.2. Alternatively, one can perform SGD on L̂(w) subject to the constraint that ‖w‖ ≤ B, yielding similar learning guarantees (e.g. (Zhang, 2004)). At each iteration, these algorithms pick an example uniformly at random from the training set. If the margin constraint is violated on the example, w is updated by adding to it a scaled version of yiΦ(xi). Then, w is scaled and possibly projected back to ‖w‖ ≤ B. The actual update performed at each iteration is thus very similar to that of the SBP. The main difference is that in Pegasos and related SGD approaches, examples are picked uniformly at random, unlike the SBP which samples from the set of violating examples.\nIn a linear SVM, where Φ(xi) ∈ Rd are given explicitly, each Pegasos (or SGD on L̂(w)) iteration is extremely simple and requires runtime which is linear in the dimensionality of Φ(xi). A SBP update would require calculating and referring to all O(n) responses. However, with access only to kernel evaluations, even a Pegasos-type update requires either considering all support vectors, or alternatively updating all responses, and might also take O(n) time, just like the much “smarter” SBP step.\nTo understand the learning runtime of such methods in the kernel setting, recall that SGD converges to an ǫ-accurate solution of the optimization problem after at most ‖u‖2 /ǫ2 iterations. Therefore, the overall runtime is n ‖u‖2 /ǫ2. Combining this with Equation 3.5 yields that the runtime requires by SGD to achieve a learning accuracy of ǫ is Õ ( ((L∗ + ǫ)/ǫ) ‖u‖4 /ǫ3 ) . When ǫ = Ω(L∗), this scales as 1/ǫ3 compared with the 1/ǫ scaling for the SBP (see also Table 1)."
    }, {
      "heading" : "4.3. Dual Decomposition Methods",
      "text" : "Many of the most popular packages for optimizing kernel SVMs, including LIBSVM (Chang & Lin, 2001) and SVM-Light (Joachims, 1998), use dualdecomposition approaches. This family of algorithms\nworks on the dual of the scalarization 2.2, given by:\nmax α∈[0, 1λn ] n\nn ∑\ni=1\nαi − 1\n2\nn ∑\ni,j=1\nαiαjyiyjK(xi, xj) (4.1)\nand proceed by iteratively choosing a small working set of dual variables αi, and then optimizing over these variables while holding all other dual variables fixed. At an extreme, SMO (Platt, 1998) uses a working set of the smallest possible size (two in problems with an unregularized bias, one in problems without). Most dual decomposition approaches rely on having access to all the responses ci (as in the SBP), and employ some heuristic to select variables αi that are likely to enable a significant increase in the dual objective.\nOn an objective without an unregularized bias the structure of SMO is similar to the SBP: the responses ci are used to choose a single point j in the training set, then αj is updated, and finally the responses are updated accordingly. There are two important differences, though: how the training example to update is chosen, and how the change in αj is performed.\nSMO updates αj so as to exactly optimize the dual Problem 4.1, while the SBP takes a step along αj so as to improve the primal Problem 2.3. Dual feasibility is not maintained, so the SBP has more freedom to use large coefficients on a few support vectors, potentially resulting in sparser solutions.\nThe use of heuristics to choose the training example to update makes SMO very difficult to analyze. Although it is known to converge linearly after some number of iterations (Chen et al., 2006), the number of iterations required to reach this phase can be very large (see a detailed discussion in Appendix E). To the best of our knowledge, the most satisfying analysis for a dual decomposition method is the one given in Hush et al. (2006). In terms of learning runtime, this analysis yields a runtime of Õ ( ((L(u) + ǫ) /ǫ)2 ‖u‖4 /ǫ2 ) to guarantee L0/1(w) ≤ L(u) + ǫ. When ǫ = Ω(L∗), this runtime scales as 1/ǫ2, compared with the 1/ǫ guarantee for the SBP."
    }, {
      "heading" : "4.4. Stochastic Dual Coordinate Ascent",
      "text" : "Another variant of the dual decomposition approach is to choose a single αi randomly at each iteration and update it so as to optimize Equation 4.1 (Hsieh et al., 2008). The advantage here is that we do not need to use all of the responses at each iteration, so that if it is easy to calculate responses on-demand, as in the case of linear SVMs, each SDCA iteration can be calculated in time O(d) (Hsieh et al., 2008). In a sense, SDCA relates to SMO in a similar fashion that Pegasos re-\nlates to the SBP: SDCA and Pegasos are preferable on linear SVMs since they choose working points at random; SMO and the SBP choose working points based on more information (namely, the responses), which are unnecessarily expensive to compute in the linear case, but, as discussed earlier, are essentially “free” in kernelized implementations. Pegasos and the SBP both work on the primal (though on different scalarizations), while SMO and SDCA work on the dual and maintain dual feasibility.\nThe current best analysis of the runtime of SDCA is not satisfying, and yields the bound n/λǫ on the number of iterations, which is a factor of n larger than the bound for Pegasos. Since the cost of each iteration is the same, this yields a significantly worse guarantee. We do not know if a better guarantee can be derived for SDCA. See a detailed discussion in Appendix E."
    }, {
      "heading" : "4.5. The Online Perceptron",
      "text" : "We have so far considered only the problem of optimizing the bi-criterion SVM objective of Problem 2.1. However, because the online Perceptron achieves the same form of learning guarantee (despite not optimizing the bi-criterion objective), it is reasonable to consider it, as well.\nThe online Perceptron makes a single pass over the training set. At each iteration, if w errs on the point under consideration (i.e. yi 〈w,Φ(xi)〉 ≤ 0), then yiΦ(xi) is added into w. Let M be the number of mistakes made by the Perceptron on the sequence of examples. Support vectors are added only when a mistake is made, and so each iteration of the Perceptron involves at most M kernel evaluations. The total runtime is therefore Mn.\nWhile the Perceptron is an online learning algorithm, it can also be used for obtaining guarantees on the generalization error using an online-to-batch conversion (e.g. (Cesa-Bianchi et al., 2001)).\nFrom a bound on the number of mistakes M (e.g. Shalev-Shwartz (2007, Corollary 5)), it is possible to show that the expected number of mistakes the Perceptron makes is upper bounded by nL(u)+‖u‖ √\nnL(u)+ ‖u‖2. This implies that the total runtime required by the Perceptron to achieve L0/1(w) ≤ L(u) + ǫ is O ( ((L(u) + ǫ) /ǫ)3 ‖u‖4 /ǫ ) . This is of the same or-\nder as the bound we have derived for SBP. However, the Perceptron does not converge to a Pareto optimal solution to the bi-criterion Problem 2.1, and therefore cannot be considered a SVM optimization procedure. Furthermore, the online Perceptron generalization analysis relies on an “online-to-batch” conver-\nsion technique (e.g. (Cesa-Bianchi et al., 2001)), and is therefore valid only for a single pass over the data. If we attempt to run the Perceptron for multiple passes, then it might begin to overfit uncontrollably. Although the worst-case theoretical guarantee obtained after a single pass is indeed similar to that for an optimum of the SVM objective, in practice an optimum of the empirical SVM optimization problem does seem to have significantly better generalization performance."
    }, {
      "heading" : "5. Experiments",
      "text" : "We compared the SBP to other SVM optimization approaches on the datasets in Table 2. We compared to Pegasos (Shalev-Shwartz et al., 2011), SDCA (Hsieh et al., 2008), and SMO (Platt, 1998) with a second order heuristic for working point selection (Fan et al., 2005). These approaches work on the regularized formulation of Problem 2.2 or its dual (Problem 4.1). To enable comparison, the parameter ν for the SBP was derived from λ as ‖ŵ∗‖ ν = 1 n ∑n i=1 ℓ (yi 〈w∗,Φ (xi)〉), where ŵ∗ is the known (to us) optimum.\nWe first compared the methods on a SVM formulation without an unregularized bias, since Pegasos and SDCA do not naturally handle one. So that this comparison would be implementation-independent, we measure performance in terms of the number of kernel evaluations. As can be seen in Figure 2, the SBP outperforms Pegasos and SDCA, as predicted by the upper bounds. The SMO algorithm has a dramatically different performance profile, in line with the known analysis: it makes relatively little progress, in terms of generalization error, until it reaches a certain critical point, after which it converges rapidly. Unlike the other methods, terminating SMO early in order to obtain a cruder solution does not appear to be advisable.\nWe also compared to the online Perceptron algorithm. Although use of the Perceptron is justified for nonseparable data only if run for a single pass over the training set, we did continue running for multiple passes. The Perceptron’s generalization performance is similar to that of the SBP for the first epoch, but the SBP continues improving over additional passes. As discussed in Section 4.5, the Perceptron is unsafe and might overfit after the first epoch, an effect which is clearly visible on the Adult dataset.\nTo give a sense of actual runtime, we compared our implementation of the SBP1 to the SVM package LIBSVM, running on an Intel E7500 processor. We\n1Source code is available from http://ttic.uchicago.edu/~cotter/projects/SBP\nallowed an unregularized bias (since that is what LIBSVM uses), and used the parameters in Table 2. For these experiments, we replaced the Reuters dataset with the version of the Forest dataset used by Nguyen et al. (2010), using their parameters. LIBSVM converged to a solution with 14.9% error in 195s on Adult, 0.44% in 1980s on MNIST, and 1.8% in 35 hours on Forest. In one-quarter of each of these runtimes, SBP obtained 15.0% error on Adult, 0.46% on MNIST, and 1.6% on Forest. These results of course depend heavily on the specific stopping criterion used."
    }, {
      "heading" : "6. Summary and Discussion",
      "text" : "The Stochastic Batch Perceptron is a novel approach for training kernelized SVMs. The SBP fares well empirically, and, as summarized in Table 1, our runtime guarantee for the SBP is the best of any existing guarantee for kernelized SVM training. An interesting open question is whether this runtime is optimal, i.e. whether any algorithm relying only on black-box kernel accesses must perform Ω ( ((L∗ + ǫ)/ǫ)3 ‖u‖4 /ǫ )\nkernel evaluations.\nAs with other stochastic gradient methods, deciding when to terminate SBP optimization is an open issue. The most practical approach seems to be to terminate when a holdout error stabilizes. We should note that even for methods where the duality gap can be used (e.g. SMO), this criterion is often too strict, and the use of cruder criteria may improve training time.\nAcknowledgements: S. Shalev-Shwartz is supported by the Israeli Science Foundation grant number 590-10."
    }, {
      "heading" : "Blum, M., Floyd, R. W., Pratt, V., Rivest, R. L., and",
      "text" : "Tarjan, R. E. Time bounds for selection. JCSS, 7(4): 448–461, August 1973.\nBottou, L. and Bousquet, O. The tradeoffs of large scale learning. In NIPS’08, pp. 161–168, 2008.\nCesa-Bianchi, N., Conconi, A., and Gentile, C. On the generalization ability of on-line learning algorithms. IEEE Trans. on Inf. Theory, 50:2050–2057, 2001.\nChang, C-C. and Lin, C-J. LIBSVM: a library for support vector machines, 2001. Software available at http://www.csie.ntu.edu.tw/~cjlin/libsvm.\nChen, P-H., Fan, R-E., and Lin, C-J. A study on smo-type decomposition methods for support vector machines. IEEE Transactions on Neural Networks, 17(4):893–908, 2006."
    }, {
      "heading" : "Collins, M., Globerson, A., Koo, T., Carreras, X., and",
      "text" : "Bartlett, P. Exponentiated gradient algorithms for conditional random fields and max-margin markov net-\nworks. JMLR, 9:1775–1822, 2008.\nFan, R-E., Chen, P-S., and Lin, C-J. Working set selection using second order information for training support vector machines. JMLR, 6:1889–1918, 2005.\nHazan, E., Koren, T., and Srebro, N. Beating SGD: Learning SVMs in sublinear time. In NIPS’11, 2011."
    }, {
      "heading" : "Hsieh, C-J., Chang, K-W., Lin, C-J., Keerthi, S. S., and",
      "text" : "Sundararajan, S. A dual coordinate descent method for large-scale linear SVM. In ICML’08, pp. 408–415, 2008.\nHush, D., Kelly, P., Scovel, C., and Steinwart, I. QP algorithms with guaranteed accuracy and run time for support vector machines. JMLR, 7:733–769, 2006.\nJoachims, T. Making large-scale support vector machine learning practical. In Schölkopf, B., Burges, C., and Smola, A. J. (eds.), Advances in Kernel Methods - Support Vector Learning. MIT Press, 1998.\nKakade, S. M. and Tewari, A. On the generalization ability of online strongly convex programming algorithms. In NIPS’09, 2009."
    }, {
      "heading" : "Nguyen, D D, Matsumoto, K., Takishima, Y., and",
      "text" : "Hashimoto, K. Condensed vector machines: learning fast machine for large data. Trans. Neur. Netw., 21(12): 1903–1914, Dec 2010.\nPlatt, J. C. Fast training of support vector machines us-\ning Sequential Minimal Optimization. In Schölkopf, B., Burges, C., and Smola, A. J. (eds.), Advances in Kernel Methods - Support Vector Learning. MIT Press, 1998.\nRahimi, A. and Recht, B. Random features for large-scale kernel machines. In NIPS’07, 2007.\nScovel, C., Hush, D., and Steinwart, I. Approximate duality. JOTA, 2008.\nShalev-Shwartz, S. Online Learning: Theory, Algorithms, and Applications. PhD thesis, The Hebrew University of Jerusalem, July 2007.\nShalev-Shwartz, S. and Srebro, N. SVM optimization: Inverse dependence on training set size. In ICML’08, pp. 928–935, 2008."
    }, {
      "heading" : "Shalev-Shwartz, S., Singer, Y., Srebro, N., and Cotter,",
      "text" : "A. Pegasos: Primal Estimated sub-GrAdient SOlver for SVM. Mathematical Programming, 127(1):3–30, March 2011."
    }, {
      "heading" : "Srebro, N., Sridharan, K., and Tewari, A. Smoothness,",
      "text" : "low-noise and fast rates. In NIPS’10, 2010.\nZhang, T. Solving large scale linear prediction problems using stochastic gradient descent algorithms. In ICML’04, 2004.\nZinkevich, M. Online convex programming and generalized infinitesimal gradient ascent. In ICML’03, 2003."
    }, {
      "heading" : "A. Additional Experiments",
      "text" : "While our focus in this paper is on optimization of the kernel SVM objective, and not on the broader problem of large-scale learning, one may wonder how well the SBP compares to techniques which accelerate the training of kernel SVMs through approximation. One such is the random Fourier projection algorithm of Rahimi & Recht (2007), which can be used to transform a kernel SVM problem into an approximatelyequivalent linear SVM. The resulting problem may then be optimized using one of the many existing fast linear SVM solvers, such as Pegasos, SDCA or SIMBA. Unlike methods (such as the SBP) which rely only on black-box kernel accesses, Rahimi and Recht’s projection technique can only be applied on a certain class of kernel functions (shift-invariant kernels), of which the Gaussian kernel is a member.\nFor d-dimensional feature vectors, and using a Gaussian kernel with parameter σ2, Rahimi and Recht’s approach is to sample v1, . . . , vk ∈ Rd independently according to vi ∼ N (0, I), and then define the mapping P : Rd → R2k as:\nP (x)2i = 1√ k cos\n(\n1 σ 〈vi, x〉\n)\nP (x)2i+1 = 1√ k sin\n(\n1 σ 〈vi, x〉\n)\nThen 〈P (xi),P (xj)〉 ≈ K (xi, xj), with the quality of this approximation improving with increasing k (see Rahimi & Recht (2007, Claim 1) for details).\nNotice that computing each pair of Fourier features requires computing the d-dimensional inner product 〈v, x〉. For comparison, let us write the Gaussian kernel in the following form:\nK (xi, xj) = exp\n(\n− 1 2σ2 ‖xi − xj‖2 )\n=exp\n(\n− 1 2σ2 ( ‖xi‖2 + ‖xj‖2 − 2 〈xi, xj〉 )\n)\nThe norms ‖xi‖ may be cheaply precomputed, so the dominant cost of performing a single Gaussian kernel evaluation is, likewise, that of the d-dimensional inner product 〈xi, xj〉. This observation suggests that the computational cost of the use of Fourier features may be directly compared with that of a kernel-evaluation-based SVM optimizer in terms of d-dimensional inner products. Figure 3 contains such a comparison. In this figure, the computational cost of a 2k-dimensional Fourier linearization is taken to be the cost of computing P (xi) on the entire training set (kn inner products, where n is the\nnumber of training examples)—we ignore the cost of optimizing the resulting linear SVM entirely. The plotted testing error is that of the optimum of the resulting linear SVM problem, which approximates the original kernel SVM. We can see that at least on Reuters and MNIST, the SBP is preferable to (i.e. faster than) approximating the kernel with random Fourier features.\nB. Implementation Details\nWe begin this appendix by providing complete pseudocode, which may be found in Algorithm 1, for the SBP algorithm which we outlined in Section 3.4. This implementation requires that we be able to find a minimax-optimal probability distribution p∗ to the objective of Equation 3.1.\nAs was discussed in Section 3.2, in a problem without an unregularized bias, such a probability distribution can be derived from the “water level” γ, which can be found in O(n) time using Algorithm 2. This algorithm works by subdividing the set of responses into those less than, equal to and greater than a pivot value (if one uses the median, which can be found in linear time using e.g. the median-of-medians algorithm (Blum et al., 1973), then the overall will be linear in n). Then, it calculates the size, minimum and sum of each of these subsets, from which the total volume of the water required to cover the subsets can be easily calculated. It then recurses into the subset containing the point at which a volume of nν just suffices to cover the responses, and continues until γ is found.\nIn Section 3.6, we mentioned that a similar result holds for the objective of Equation 3.9, which adds an unregularized bias.\nAs before, finding the water level γ reduces to finding minimax-optimal values of p∗, ξ∗ and b∗. The characterization of such solutions is similar to that in the case without an unregularized bias. In particular, for a fixed value of b, we may still think about “pouring water into a basin”, except that the height of the basin is now ci + yib, rather than ci.\nWhen b is not fixed it is easier to think of two basins, one containing the positive examples, and the other the negative examples. These basins will be filled with water of a total volume of nν, to a common water level γ. The relative heights of the two basins are determined by b: increasing b will raise the basin containing the positive examples, while lowering that containing the negative examples by the same amount. This is illustrated in Figure 4.\nIt remains only to determine what characterizes a\nminimax-optimal value of b. Let k+ and k− be the number of elements covered by water in the positive and negative basins, respectively, for some b. If k+ > k−, then raising the positive basin and lowering the negative basin by the same amount (i.e. increasing b) will raise the overall water level, showing that b is not optimal. Hence, for an optimal b, water must cover an equal number of indices in each basin. Similar reasoning shows that an optimal p∗ must place equal probability mass on each of the two classes.\nOnce more, the resulting problem is amenable to a divide-and-conquer approach. The water level γ and bias b will be found in O(n) time by Algorithm 3, provided that the partition function chooses the median as the pivot."
    }, {
      "heading" : "C. Proofs of Lemmas 3.1 and 3.2",
      "text" : "Lemma 3.1. For any w, let p∗, ξ∗ be minimax optimal for Equation 3.1. Then\n∑n i=1 p ∗ i yiΦ (xi) is a supergra-\ndient of f(w) at w.\nProof. By the definition of f , for any v ∈ Rd:\nf (w + v) =\nmax ξ 0,1T ξ≤nν min p∈∆n\nn ∑\ni=1\npi (yi 〈w + v,Φ (xi)〉+ ξi)\nSubstituting the particular value p∗ for p can only in-\ncrease the RHS, so:\nf (w + v) ≤ max ξ 0,1T ξ≤nν\nn ∑\ni=1\np∗i (yi 〈w + v,Φ (xi)〉+ ξi)\n≤ max ξ 0,1T ξ≤nν\nn ∑\ni=1\np∗i (yi 〈w,Φ (xi)〉+ ξi)\n+\nn ∑\ni=1\np∗i yi 〈v,Φ (xi)〉\nBecause p∗ is minimax-optimal at w:\nf (w + v) ≤f (w) + n ∑\ni=1\np∗i yi 〈v,Φ (xi)〉\n≤f (w) + 〈 v, n ∑\ni=1\np∗i yiΦ (xi)\n〉\nSo ∑n i=1 p ∗ i yiΦ (xi) is a supergradient of f .\nLemma 3.2. For any T, δ > 0, after T iterations of the Stochastic Batch Perceptron, with probability at least 1− δ, the average iterate w̄ = 1T ∑T t=1 w (t) (corresponding to ᾱ = 1T ∑T t=1 α (t)), satisfies: f (w̄) ≥ sup‖w‖≤1 f (w) −O (√ 1 T log 1 δ ) .\nProof. Define h = − 1r f , where f is as in Equation 3.1. Then the stated update rules constitute an instance of Zinkevich’s algorithm, in which steps are taken in the direction of stochastic subgradients g(t) of h at w(t) =\n∑n i=1 αiyiΦ (xi).\nThe claimed result follows directly from Zinkevich (2003, Theorem 1) combined with an online-to-batch conversion analysis in the style of Cesa-Bianchi et al. (2001, Lemma 1).\nAlgorithm 1 Stochastic gradient ascent algorithm for optimizing the kernelized version of Problem 2.3, as described in Section 3.3. Here, ei is the ith standard unit basis vector. The find gamma subroutine finds the “water level” γ from the vector of responses c and total volume nν.\noptimize ( n : N, x1, . . . , xn : R d, y1, . . . , yn : {±1} , T0 : N, T : N, ν : R+,K : Rd × Rd → R+ )\n1 η0 := 1/ √ maxi K (xi, xi); 2 α(0) := 0n; c(0) := 0n; r0 := 0; 3 for t := 1 to T 4 ηt := η0/ √ t; 5 γ := find gamma ( c(t−1), nν ) ; 6 sample i ∼ uniform {\nj : c (t−1) j < γ\n}\n;\n7 α(t) := α(t−1) + ηtei; 8 r2t := r 2 t−1 + 2ηtc (t−1) i + η 2 tK (xi, xi); 9 for j = 1 to n\n10 c (t) j := c (t−1) j + ηtyiyjK (xi, xj); 11 if (rt > 1) then 12 α(t) := (1/rt)α (t); c(t) := (1/rt) c (t); rt := 1; 13 ᾱ := 1T ∑T t=1 α (t); c̄ := 1T ∑T t=1 c\n(t); γ := find gamma (c̄, nν); 14 return ᾱ/γ;"
    }, {
      "heading" : "D. Data-Laden Analyses",
      "text" : "We’ll begin by presenting a bound on the sample size n required to guarantee good generalization performance (in terms of the 0/1 loss) for a classifier which is ǫ-suboptimal in terms of the empirical hinge loss. The following result, which follows from Srebro et al. (2010, Theorem 1), is a vital building block of the bounds derived in the remainder of this appendix:\nLemma D.1. Consider the expected 0/1 and hinge losses:\nL0/1 (w) = Ex,y [ 1y〈w,x〉≤0 ]\nL (w) = Ex,y [max (0, 1− y 〈w, x〉)]\nLet u be an arbitrary linear classifier, and suppose that we sample a training set of size n, with n given by the following equation, for parameters B ≥ ‖u‖, ǫ > 0 and δ ∈ (0, 1):\nn = Õ\n\n  (L (u) + ǫ ǫ )\n( B + √\nlog 1δ\n)2\n+ rB log 1δ\nǫ\n\n \n(D.1) where r ≥ ‖x‖ is an upper bound on the radius of the data. Then, with probability 1− δ over the i.i.d. training sample xi, yi : i ∈ {1, . . . , n}, uniformly for all linear classifiers w satisfying:\n‖w‖ ≤ B L̂ (w) − L̂ (u) ≤ ǫ\nwhere L̂ is the empirical hinge loss:\nL̂ (w) = 1 n\nn ∑\ni=1\nmax (0, 1− yi 〈w, xi〉)\nwe have that:\nL̂ (u) ≤ L (u) + ǫ L0/1 (w) ≤ L̂ (u) + ǫ\nand in particular that:\nL0/1 (w) ≤ L (u) + 2ǫ\nIn the remainder of this appendix, we will apply the above result to derive generalization bounds on the performance of the various algorithms under consideration, in the data-laden setting."
    }, {
      "heading" : "D.1. Stochastic Batch Perceptron",
      "text" : "We will here present a more careful derivation of the main result of Section 3.5, bounding the generalization performance of the SBP.\nTheorem D.2. Let u be an arbitrary linear classifier in the RKHS, let ǫ > 0 be given, and suppose that K (x, x) ≤ r2 with probability 1. There exist values of the training size n, iteration count T and parameter ν such that Algorithm 1 finds a solution w =\n∑n i=1 αiyiΦ (xi) satisfying:\nL0/1 (w) ≤ L (u) + ǫ\nAlgorithm 2 Divide-and-conquer algorithm for finding the “water level” γ from an array of responses C and total volume nν. The partition function chooses a pivot value from the array it receives as an argument (the median would be ideal), places all values less than the pivot at the start of the array, all values greater at the end, and returns the index of the pivot in the resulting array.\nfind gamma (C : Rn, nν : R) 1 lower := 1; upper := n; 2 lower max := −∞; lower sum := 0; 3 while lower < upper 4 while lower < upper; 5 middle := partition(C [lower : upper]); 6 middle max := max (lower max,C [lower : (middle− 1)]); 7 middle sum := lower sum+ ∑\nC [lower : (middle− 1)]; 8 if middle max · (middle− 1)−middle sum ≥ nν then 9 upper := middle− 1;\n10 else 11 lower := middle; lower max := middle max; lower sum := middle sum; 12 return (nν − lower max · (lower − 1) + lower sum) / (lower − 1) + lower max;\nwhere L0/1 and L are the expected 0/1 and hinge losses, respectively, after performing the following number of kernel evaluations:\n#K = Õ\n(\n(L (u) + ǫ ǫ )3 r3 ‖u‖4 ǫ log2 1 δ\n)\nwith the size of the support set of w (the number nonzero elements in α) satisfying:\n#S = O\n(\n(L (u) + ǫ ǫ\n)2\nr2 ‖u‖2 log 1 δ\n)\nthe above statements holding with probability 1− δ.\nProof. For a training set of size n, where:\nn = Õ ((L (u) + ǫ ǫ ) rB2 ǫ log 1 δ )\ntaking B = 2 ‖u‖ in Lemma D.1 gives that L̂ (u) ≤ L (u) + ǫ and L0/1 (w) ≤ L (u) + 2ǫ with probability 1− δ over the training sample, uniformly for all linear classifiers w such that ‖w‖ ≤ B and L̂ (w)−L̂ (u) ≤ ǫ, where L̂ is the empirical hinge loss. We will now show that these inequalities are satisfied by the result of Algorithm 1. Define:\nŵ∗ = argmin w:‖w‖≤‖u‖ L̂ (w)\nBecause ŵ∗ is a Pareto optimal solution of the bicriterion objective of Problem 2.1, if we choose the parameter ν to the slack-constrained objective (Problem 2.3) such that ‖ŵ∗‖ ν = L̂ (ŵ∗), then the optimum of the slack-constrained objective will be equivalent to\nŵ∗ (Lemma 2.1). As was discussed in Section 3.5, We will use Lemma 3.2 to find the number of iterations T required to satisfy Equation 3.7 (with u = ŵ∗). This yields that, if we perform T iterations of Algorithm 1, where T satisfies the following:\nT ≥ O\n\n\n(\nL̂ (ŵ∗) + ǫ ǫ\n)2\nr2 ‖ŵ∗‖2 log 1 δ\n\n (D.2)\nthen the resulting solution w = w̄/γ will satisfy:\n‖w‖ ≤ 2 ‖ŵ∗‖ L̂ (w)− L̂ (ŵ∗) ≤ ǫ\nwith probability 1− δ. That is:\n‖w‖ ≤ 2 ‖ŵ∗‖ ≤ B\nand:\nL̂ (w) ≤ L̂ (ŵ∗) + ǫ ≤ L̂ (u) + ǫ\nThese are precisely the bounds on ‖w‖ and L̂ (w) which we determined (at the start of the proof) to be necessary to permit us to apply Lemma D.1. Each of the T iterations requires n kernel evaluations, so the product of the bounds on T and n bounds the number of kernel evaluations (we may express Equation D.2 in terms of L (u) and ‖u‖ instead of L̂ (ŵ∗) and ‖ŵ∗‖, since L̂ (ŵ∗) ≤ L̂ (u) ≤ L (u) + ǫ and ‖ŵ∗‖ ≤ ‖u‖). Because each iteration will add at most one new element to the support set, the size of the support set is bounded by the number of iterations, T .\nThis discussion has proved that we can achieve suboptimality 2ǫ with probability 1− 2δ with the given #K and #S. Because scaling ǫ and δ by 1/2 only changes the resulting bounds by constant factors, these results apply equally well for suboptimality ǫ with probability 1− δ."
    }, {
      "heading" : "D.2. Pegasos / SGD on L̂",
      "text" : "If w is the result of a call to the Pegasos algorithm (Shalev-Shwartz et al., 2011) without a projection step, then the analysis of Kakade & Tewari (2009, Corollary 7) permits us to bound the suboptimality relative to an arbitrary reference classifier u, with probability 1− δ, as:\n(\nλ 2 ‖w‖2 + L̂ (w)\n) − ( λ\n2 ‖u‖2 + L̂ (u)\n)\n≤ (D.3)\n84r2 logT\nλT log\n1\nδ\nEquation D.3 implies that, if one performs the following number of iterations, then the resulting solution will be ǫ/2-suboptimal in the regularized objective, with probability 1− δ:\nT = Õ\n(\n1 ǫ · r\n2\nλ log\n1\nδ\n)\nHere, ǫ bounds the suboptimality not of the empirical hinge loss, but rather of the regularized objective (hinge loss + regularization). Although the\ndependence on 1/ǫ is linear, accounting for the λ dependence results in a bound which is not nearly good as the above appears. To see this, we’ll follow Shalev-Shwartz & Srebro (2008) by decomposing the suboptimality in the empirical hinge loss as:\nL̂ (w)− L̂ (u) = ǫ 2 − λ 2 ‖w‖2 + λ 2 ‖u‖2\n≤ ǫ 2 + λ 2 ‖u‖2\nIn order to have both terms bounded by ǫ/2, we choose λ = ǫ/ ‖u‖2, which reduces the RHS of the above to ǫ. Continuing to use this choice of λ, we next decompose the squared norm of w as:\nλ 2 ‖w‖2 = ǫ 2 − L̂ (w) + L̂ (u) + λ 2 ‖u‖2\n≤ ǫ 2 + L̂ (u) + λ 2 ‖u‖2\n‖w‖2 ≤ 2 ( L̂ (u) + ǫ ǫ ) ‖u‖2\nHence, we will have that:\n‖w‖2 ≤ 2 ( L̂ (u) + ǫ ǫ ) ‖u‖2 (D.4)\nL̂ (w) − L̂ (u) ≤ ǫ with probability 1 − δ, after performing the following number of iterations:\nT = Õ\n(\nr2 ‖u‖2 ǫ2 log 1 δ\n)\n(D.5)\nThere are two ways in which we will use this bound on T to find bound on the number of kernel evaluations required to achieve some desired regularization error. The easiest is to note that the bound of Equation D.5 exceeds that of Lemma D.1, so that if we take T = n, then with high probability, we’ll achieve generalization error 2ǫ after Tn = T 2 kernel evaluations:\n#K = Õ\n(\nr4 ‖u‖4 ǫ4 log2 1 δ\n)\n(D.6)\nBecause we take the number of iterations to be precisely the same as the number of training examples, this is essentially the online stochastic setting.\nAlternatively, we may combine our bound on T with Lemma D.1. This yields the following bound on the generalization error of Pegasos in the data-laden batch setting.\nTheorem D.3. Let u be an arbitrary linear classifier in the RKHS, let ǫ > 0 be given, and suppose that K (x, x) ≤ r2 with probability 1. There exist values of the training size n, iteration count T and parameter ν such that kernelized Pegasos finds a solution w = ∑n\ni=1 αiyiΦ (xi) satisfying:\nL0/1 (w) ≤ L (u) + ǫ\nwhere L0/1 and L are the expected 0/1 and hinge losses, respectively, after performing the following number of kernel evaluations:\n#K = Õ\n(\n(L (u) + ǫ ǫ )2 r3 ‖u‖4 ǫ3 log2 1 δ\n)\nwith the size of the support set of w (the number nonzero elements in α) satisfying:\n#S = Õ\n(\nr2 ‖u‖2 ǫ2 log 1 δ\n)\nthe above statements holding with probability 1− δ.\nProof. Same proof technique as in Theorem D.2.\nBecause of the extra term in the bound on ‖w‖ in Equation D.4, theorem D.3 gives a bound which is worse by a factor of (L (u) + ǫ) /ǫ than what we might have hoped to recover. When ǫ ≪ L (u), this extra factor results in the bound going as 1/ǫ5 rather than 1/ǫ4. We need to use Equation D.6 to get a 1/ǫ4 bound in this case.\nAlthough this bound on the generalization performance of Pegasos is not quite what we expected, for\nthe related algorithm which performs SGD on the following objective:\nmin w∈Rd\n1\nn\nn ∑\ni=1\nℓ (yi 〈w,Φ (xi)〉)\nsubject to: ‖w‖2 ≤ B2\nthe same proof technique yields the desired bound (i.e. without the extra (L (u) + ǫ) /ǫ factor). This is the origin of the “SGD on L̂” row in Table 1."
    }, {
      "heading" : "D.3. Perceptron",
      "text" : "Analysis of the venerable online Perceptron algorithm is typically presented as a bound on the number of mistakes made by the algorithm in terms of the hinge loss of the best classifier—this is precisely the form which we consider in this document, despite the fact that the online Perceptron does not optimize any scalarization of the bi-criterion SVM objective of Problem 2.1. Interestingly, the performance of the Perceptron matches that of the SBP, as is shown in the following theorem:\nTheorem D.4. Let u be an arbitrary linear classifier in the RKHS, let ǫ > 0 be given, and suppose that K (x, x) ≤ r2 with probability 1. There exists a value of the training size n such that when the Perceptron algorithm is run for a single “pass” over the dataset, the result is a solution w =\n∑n i=1 αiyiΦ (xi) satisfying:\nL0/1 (w) ≤ L (u) + ǫ\nwhere L0/1 and L are the expected 0/1 and hinge losses, respectively, after performing the following number of kernel evaluations:\n#K = Õ\n(\n(L (u) + ǫ ǫ )3 r4 ‖u‖4 ǫ 1 δ\n)\nwith the size of the support set of w (the number nonzero elements in α) satisfying:\n#S = O\n(\n(L (u) + ǫ ǫ\n)2\nr2 ‖u‖2 1 δ\n)\nthe above statements holding with probability 1− δ.\nProof. If we run the online Perceptron algorithm for a single pass over the dataset, then Corollary 5 of (Shalev-Shwartz, 2007) gives the following mistake bound, for M being the set of iterations on which a\nmistake is made:\n|M| ≤ ∑\ni∈M ℓ (yi 〈u,Φ (xi)〉) (D.7)\n+ r ‖u‖ √ ∑\ni∈M ℓ (yi 〈u,Φ (xi)〉) + r2 ‖u‖2\nn ∑\ni=1\nℓ0/1 (yi 〈wi,Φ (xi)〉) ≤ n ∑\ni=1\nℓ (yi 〈u,Φ (xi)〉)+\n+ r ‖u‖\n√ √ √ √ n ∑\ni=1\nℓ (yi 〈u,Φ (xi)〉) + r2 ‖u‖2\nHere, ℓ is the hinge loss and ℓ0/1 is the 0/1 loss. Dividing through by n:\n1\nn\nn ∑\ni=1\nℓ0/1 (yi 〈wi,Φ (xi)〉) ≤ 1\nn\nn ∑\ni=1\nℓ (yi 〈u,Φ (xi)〉)\n+ r ‖u‖√\nn\n√ √ √ √ 1\nn\nn ∑\ni=1\nℓ (yi 〈u,Φ (xi)〉) + r2 ‖u‖2\nn\nIf we suppose that the xi, yis are i.i.d., and that w ∼ Unif (w1, . . . , wn) (this is a “sampling” online-to-batch conversion), then:\nE [ L0/1 (w) ] ≤ L (u) + r ‖u‖√ n √ L (u) + r 2 ‖u‖2 n\nHence, the following will be satisfied:\nE [ L0/1 (w) ] ≤ L (u) + ǫ (D.8)\nwhen:\nn ≤ O ( (L (u) + ǫ ǫ ) r2 ‖u‖2 ǫ )\nThe expectation is taken over the random sampling of w. The number of kernel evaluations performed by the ith iteration of the Perceptron will be equal to the number of mistakes made before iteration i. This quantity is upper bounded by the total number of mistakes made over n iterations, which is given by the\nmistake bound of equation D.7:\n|M| ≤nL (u) + r ‖u‖ √ nL (u) + r2 ‖u‖2\n≤O (( 1\nǫ (L (u) + ǫ ǫ ) L (u)\n+\n√\n1\nǫ (L (u) + ǫ ǫ ) L (u) + 1 ) r2 ‖u‖2 )\n≤O (( (L (u) + ǫ ǫ )2 − (L (u) + ǫ ǫ )\n+\n√\n(L (u) + ǫ ǫ\n)2\n− (L (u) + ǫ\nǫ\n)\n+ 1\n\n\n·r2 ‖u‖2 )\n≤O ( (L (u) + ǫ ǫ )2 r2 ‖u‖2 )\nThe number of mistakes |M| is necessarily equal to the size of the support set of the resulting classifier. Substituting this bound into the number of iterations:\n#K =n |M|\n≤O ( (L (u) + ǫ ǫ )3 r4 ‖u‖4 ǫ )\nThis holds in expectation, but we can turn this into a high-probability result using Markov’s inequality, resulting in in a δ-dependence of 1δ .\nAlthough this result has a δ-dependence of 1/δ, this is merely a relic of the simple online-to-batch conversion which we use in the analysis. Using a more complex algorithm (e.g. Cesa-Bianchi et al. (2001)) would likely improve this term to log 1δ ."
    }, {
      "heading" : "E. Convergence rates of dual optimization methods",
      "text" : "In this section we discuss existing analyses of dual optimization methods. We first underscore possible gaps between dual sub-optimality and primal suboptimality. Therefore, to relate existing analyzes in the literature of the dual sub-optimality, we must find a way to connect between the dual sub-optimality and primal sub-optimality. We do so using a result due to Scovel et al. (2008), and based on this result, we derive convergence rates on the primal sub-optimality.\nThroughout this section, the “SVM problem” is taken to be the regularized objective of Problem 2.2. We\ndenote the primal objective by:\nP (w) = λ 2 ‖w‖2 + 1 n\nn ∑\ni=1\nℓ(yi 〈w, xi, )〉\nThe dual objective can be written as:\nD(α) = λ\n\n\nn ∑\ni=1\nαi − 1\n2\nn ∑\ni,j=1\nαiαjQij\n\n\nwhere Qij = yiyj 〈xi, xj〉, and the dual constraints are α ∈ [0, 1/(λn)]n. Finally, by strong duality we have:\nP ∗ = argmax w\nP (w) = argmax α∈[0,1/(λn)]n\nD(α) = D∗"
    }, {
      "heading" : "E.1. Dual gap vs. Primal gap",
      "text" : "Several authors analyzed the convergence rate of dual optimization algorithms. For example, Hsieh et al. (2008); Collins et al. (2008) analyzed the convergence rate of SDCA and Chen et al. (2006) analyzed the convergence rate of SMO-type dual decomposition methods. In both cases, the number of iterations required so that the dual sub-optimality will be at most ǫ is analyzed. This is not satisfactory since our goal is to understand how many iterations are required to achieve a primal sub-optimality of at most ǫ. Indeed, the following lemma shows that a guarantee on a small dual sub-optimality might yield a trivial guarantee on the primal sub-optimality.\nLemma E.1. For every ǫ > 0, there exists a SVM problem with a dual solution α that is ǫ-accurate, while the corresponding primal solution, w = ∑\ni αiyixi, is at least (1 − ǫ) sub-optimal. Furthermore, the distribution is such that there exists u with ‖u‖ = 1 and L(u) = 0, while L(w) = 1 and L0,1(w) = 1/2.\nProof. Fix some u with ‖u‖ = 1 and choose any distribution such that L(u) = 0. Take a sample of size n from this distribution. A reasonable choice for the regularization parameter of SVM in this case is to set λ = 2ǫ. We have: P ∗ ≤ P (u) = λ2 ‖u‖2 = ǫ. Now, for α = 0 we have D∗ − D(α) = P ∗ − 0 ≤ ǫ. Therefore, the dual sub-optimality of α = 0 is at most ǫ. On the other hand, the corresponding primal solution is w = 0, which gives P (0) − P ∗ = 1 − P ∗ ≥ 1 − ǫ. Furthermore, L(0) = 1 and L0,1(0) = 1/2, assuming that we break ties at random.\nIn an attempt to connect between dual and primal sub-optimality, Scovel et al. (2008) derived approximate duality theorems. This was used by Hush et al. (2006, Theorem 2) to show the following:\nTheorem E.2. (Hush et al., 2006, Theorem 2) To achieve ǫp sub-optimality in the primal, it suffices to require a sub-optimality in the dual of ǫ ≤ λ ǫ 2 p\n118 .\nThere is no contradiction to Lemma E.1 above since in the proof of the lemma we set λ = 2ǫ, which yields ǫp ≥ 1.\nE.2. Analyzing the primal sub-optimality of dual methods\nChen et al. (2006) derived the linear convergence of SMO-type algorithms. However, the analysis takes the following form:\nThere are c < 1 and k̄, such that for all k ≥ k̄ it holds that D(α(k+1)) −D∗ ≤ c(D(α(k)) − D∗).\nIn the above, α(k) is the dual solution after performing k iterations, and D∗ is the optimal dual solution.\nThis type of analysis is not satisfactory since k̄ can be extremely large and c can be extremely close to 1. As an extreme example, suppose that k̄ is exponential in n. Then, in any practical implementation of the method, we will never reach the regime in which the linear convergence result holds. As a less extreme example, suppose that k̄ ≥ n2. It follows that we might need to calculate the entire Gram matrix before the linear convergence analysis kicks in. To make more satisfactory statements, we therefore seek convergence analyses which demonstrate good performance not only asymptotically, but also for reasonably small values of k.\nHush et al. (2006) combined explicit convergence rate analysis of the dual sub-optimality of certain decomposition methods with Theorem E.2. The end result is an algorithm with a bound of O(n) on the number of dual iterations, and a total number of kernel evaluations at training time of O(n2). It also follows that the number of support vectors can be order of n.\nHsieh et al. (2008) analyzed the convergence rate of SDCA and derived a bound on the duality suboptimality after performing T iterations. Translating their results to our notation and ignoring low order terms we obtain:\nǫD ≤ n\nT + n\n( (λ/2)‖α∗‖2 + P ∗ ) .\nwhere α∗ is such that w∗ = ∑ i α ∗ i yixi. Combining this with Theorem E.2 yields that the number of iterations, according to this analysis, should be at least\nT ≥ Ω ( nP ∗\nλǫ2P\n)\n.\nSo, even if we set ǫP = P ∗ we still need\nT ≥ Ω ( n\nλǫP\n)\n.\nEach iteration of SDCA cost roughly the same as a single iteration of Pegasos. However, Pegasos needs order of 1/(λǫP ) iterations, while according to the analysis above, SDCA requires factor of n more iterations. We suspect that this analysis is not tight.\nAlgorithm 3 Divide-and-conquer algorithm for finding the “water level” γ and bias b from an array of labels y, array of responses C and total volume nν, for a problem with an unregularized bias. The partition function is as in Algorithm 2.\nfind gamma and bias (y : {±1}n , C : Rn, nν : R) 1 C+ := {C[i] : y[i] = +1}; n+ := |C+|; lower+ := 1; upper+ := n+; lower max+ := −∞; lower sum+ := 0; 2 C− := {C[i] : y[i] = −1}; n− := |C−|; lower− := 1; upper− := n−; lower max− := −∞; lower sum− := 0; 3 middle+ := partition(C+ [lower+ : upper+]); 4 middle− := partition(C− [lower− : upper−]); 5 middle max+ := max (C [lower+ : (middle+ − 1)]); middle sum+ := ∑C [lower+ : (middle+ − 1)]; 6 middle max− := max (C [lower− : (middle− − 1)]); middle sum− := ∑C [lower− : (middle− − 1)]; 7 while (lower+ < upper+) or (lower− < upper−) 8 direction+ := 0; direction− := 0; 9 if middle+ < lower− then direction+ = 1;\n10 else if middle+ > upper− then direction+ = −1; 11 if middle− < lower+ then direction− = 1; 12 else if middle− > upper+ then direction− = −1; 13 if direction+ = direction− = 0 then 14 volume+ := middle max+ · (middle+ − 1)−middle sum+; 15 volume− := middle max− · (middle− − 1)−middle sum−; 16 if volume+ + volume− ≥ nν then 17 if middle+ > middle− then direction+ = −1; 18 else if middle− > middle+ then direction− = −1; 19 else if upper+ − lower+ > upper− − lower− then direction+ = −1; 20 else direction− = −1; 21 else 22 if middle+ < middle− then direction+ = 1; 23 else if middle− < middle+ then direction− = 1; 24 else if upper+ − lower+ > upper− − lower− then direction+ = 1; 25 else direction− = 1; 26 if direction+ 6= 0 then 27 if direction+ > 0 then upper+ := middle+ − 1; 28 else lower+ := middle+; lower max+ := middle max+; lower sum+ := middle sum+; 29 middle+ := partition(C+ [lower+ : upper+]); 30 middle max+ := max (lower max+, C [lower+ : (middle+ − 1)]); 31 middle sum+ := lower sum+ + ∑\nC [lower+ : (middle+ − 1)]; 32 if direction− 6= 0 then 33 if direction− > 0 then upper− := middle− − 1; 34 else lower− := middle−; lower max− := middle max−; lower sum− := middle sum−; 35 middle− := partition(C− [lower− : upper−]); 36 middle max− := max (lower max−, C [lower− : (middle− − 1)]); 37 middle sum− := lower sum− + ∑\nC [lower− : (middle− − 1)]; 38 // at this point lower+ = lower− = upper+ = upper− 39 ∆γ := (nν + lower sum+ + lower sum−) / (lower+ − 1)− lower max+ − lower max−; 40 if lower+ < n+ then ∆γ+ := min (∆γ, C+[lower+]− lower max+) else ∆γ+ := ∆γ; 41 if lower− < n− then ∆γ− := min (∆γ, C−[lower−]− lower max−) else ∆γ− := ∆γ; 42 γ+ := lower max+ + 0.5 · (∆γ +∆γ+ −∆γ−); γ− := lower max− + 0.5 · (∆γ −∆γ+ +∆γ−); 43 γ := 0.5 · (γ+ + γ−); b := 0.5 · (γ− − γ+); 44 return (γ, b);"
    } ],
    "references" : [ {
      "title" : "The tradeoffs of large scale learning",
      "author" : [ "L. Bottou", "O. Bousquet" ],
      "venue" : "In NIPS’08,",
      "citeRegEx" : "Bottou and Bousquet,? \\Q2008\\E",
      "shortCiteRegEx" : "Bottou and Bousquet",
      "year" : 2008
    }, {
      "title" : "On the generalization ability of on-line learning algorithms",
      "author" : [ "N. Cesa-Bianchi", "A. Conconi", "C. Gentile" ],
      "venue" : "IEEE Trans. on Inf. Theory,",
      "citeRegEx" : "Cesa.Bianchi et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Cesa.Bianchi et al\\.",
      "year" : 2001
    }, {
      "title" : "LIBSVM: a library for support vector machines",
      "author" : [ "Chang", "C-C", "Lin", "C-J" ],
      "venue" : null,
      "citeRegEx" : "Chang et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Chang et al\\.",
      "year" : 2001
    }, {
      "title" : "Working set selection using second order information for training support vector machines",
      "author" : [ "Fan", "R-E", "Chen", "P-S", "Lin", "C-J" ],
      "venue" : null,
      "citeRegEx" : "Fan et al\\.,? \\Q1889\\E",
      "shortCiteRegEx" : "Fan et al\\.",
      "year" : 1889
    }, {
      "title" : "Beating SGD: Learning SVMs in sublinear time",
      "author" : [ "E. Hazan", "T. Koren", "N. Srebro" ],
      "venue" : "In NIPS’11,",
      "citeRegEx" : "Hazan et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Hazan et al\\.",
      "year" : 2011
    }, {
      "title" : "A dual coordinate descent method for large-scale linear SVM",
      "author" : [ "Hsieh", "C-J", "Chang", "K-W", "Lin", "S.S. Keerthi", "S. Sundararajan" ],
      "venue" : "In ICML’08,",
      "citeRegEx" : "Hsieh et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Hsieh et al\\.",
      "year" : 2008
    }, {
      "title" : "QP algorithms with guaranteed accuracy and run time for support vector machines",
      "author" : [ "D. Hush", "P. Kelly", "C. Scovel", "I. Steinwart" ],
      "venue" : null,
      "citeRegEx" : "Hush et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Hush et al\\.",
      "year" : 2006
    }, {
      "title" : "Making large-scale support vector machine learning practical",
      "author" : [ "T. Joachims" ],
      "venue" : null,
      "citeRegEx" : "Joachims,? \\Q1998\\E",
      "shortCiteRegEx" : "Joachims",
      "year" : 1998
    }, {
      "title" : "On the generalization ability of online strongly convex programming algorithms",
      "author" : [ "S.M. Kakade", "A. Tewari" ],
      "venue" : "In NIPS’09,",
      "citeRegEx" : "Kakade and Tewari,? \\Q2009\\E",
      "shortCiteRegEx" : "Kakade and Tewari",
      "year" : 2009
    }, {
      "title" : "Condensed vector machines: learning fast machine for large data",
      "author" : [ "D D Nguyen", "K. Matsumoto", "Y. Takishima", "K. Hashimoto" ],
      "venue" : "Trans. Neur. Netw.,",
      "citeRegEx" : "Nguyen et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Nguyen et al\\.",
      "year" : 2010
    }, {
      "title" : "Random features for large-scale kernel machines",
      "author" : [ "A. Rahimi", "B. Recht" ],
      "venue" : "In NIPS’07,",
      "citeRegEx" : "Rahimi and Recht,? \\Q2007\\E",
      "shortCiteRegEx" : "Rahimi and Recht",
      "year" : 2007
    }, {
      "title" : "Online Learning: Theory, Algorithms, and Applications",
      "author" : [ "S. Shalev-Shwartz" ],
      "venue" : "PhD thesis,",
      "citeRegEx" : "Shalev.Shwartz,? \\Q2007\\E",
      "shortCiteRegEx" : "Shalev.Shwartz",
      "year" : 2007
    }, {
      "title" : "SVM optimization: Inverse dependence on training set size",
      "author" : [ "S. Shalev-Shwartz", "N. Srebro" ],
      "venue" : "In ICML’08,",
      "citeRegEx" : "Shalev.Shwartz and Srebro,? \\Q2008\\E",
      "shortCiteRegEx" : "Shalev.Shwartz and Srebro",
      "year" : 2008
    }, {
      "title" : "Pegasos: Primal Estimated sub-GrAdient SOlver for SVM",
      "author" : [ "S. Shalev-Shwartz", "Y. Singer", "N. Srebro", "A. Cotter" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Shalev.Shwartz et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Shalev.Shwartz et al\\.",
      "year" : 2011
    }, {
      "title" : "Smoothness, low-noise and fast rates",
      "author" : [ "N. Srebro", "K. Sridharan", "A. Tewari" ],
      "venue" : "In NIPS’10,",
      "citeRegEx" : "Srebro et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Srebro et al\\.",
      "year" : 2010
    }, {
      "title" : "Solving large scale linear prediction problems using stochastic gradient descent algorithms",
      "author" : [ "T. Zhang" ],
      "venue" : "In ICML’04,",
      "citeRegEx" : "Zhang,? \\Q2004\\E",
      "shortCiteRegEx" : "Zhang",
      "year" : 2004
    }, {
      "title" : "Online convex programming and generalized infinitesimal gradient ascent",
      "author" : [ "M. Zinkevich" ],
      "venue" : "In ICML’03,",
      "citeRegEx" : "Zinkevich,? \\Q2003\\E",
      "shortCiteRegEx" : "Zinkevich",
      "year" : 2003
    }, {
      "title" : "Dual gap vs. Primal gap Several authors analyzed the convergence rate of dual optimization algorithms",
      "author" : [ "D(α) = D∗ E" ],
      "venue" : "For example, Hsieh et al",
      "citeRegEx" : "E.1.,? \\Q2008\\E",
      "shortCiteRegEx" : "E.1.",
      "year" : 2008
    }, {
      "title" : "analyzed the convergence rate of SMO-type dual decomposition methods. In both cases, the number of iterations required so that the dual sub-optimality will be at most ǫ is analyzed",
      "author" : [ "SDCA", "Chen" ],
      "venue" : null,
      "citeRegEx" : "SDCA and Chen,? \\Q2006\\E",
      "shortCiteRegEx" : "SDCA and Chen",
      "year" : 2006
    }, {
      "title" : "combined explicit convergence rate analysis of the dual sub-optimality of certain decomposition methods with Theorem E.2. The end result is an algorithm with a bound of O(n) on the number",
      "author" : [ "k. Hush" ],
      "venue" : null,
      "citeRegEx" : "Hush,? \\Q2006\\E",
      "shortCiteRegEx" : "Hush",
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 13,
      "context" : "The SBP is fundamentally different from Pegasos (Shalev-Shwartz et al., 2011) and other stochastic gradient approaches to the problem of training SVMs, in",
      "startOffset" : 48,
      "endOffset" : 77
    }, {
      "referenceID" : 4,
      "context" : "In particular, we use the “slack constrained” scalarized optimization problem introduced by Hazan et al. (2011) where we seek to maximize the classification margin, subject to a constraint on the total amount of “slack”, i.",
      "startOffset" : 92,
      "endOffset" : 112
    }, {
      "referenceID" : 11,
      "context" : "In order to compare the SBP runtime to the runtime of other SVM optimization algorithms, which typically work on different scalarizations of the bi-criterion problem, we follow Bottou & Bousquet (2008); Shalev-Shwartz & Srebro (2008) and compare the runtimes required to ensure a generalization error of L∗ + ǫ, assuming the existence of some unknown predictor u with norm ‖u‖ and expected hinge loss L∗.",
      "startOffset" : 203,
      "endOffset" : 234
    }, {
      "referenceID" : 4,
      "context" : "We instead consider the “slack constrained” scalarization (Hazan et al., 2011), where we maximize the “margin” subject to a constraint of ν on the total allowed “slack”, corresponding to the average error.",
      "startOffset" : 58,
      "endOffset" : 78
    }, {
      "referenceID" : 10,
      "context" : "2, we follow Bottou & Bousquet (2008); Shalev-Shwartz & Srebro (2008), and analyze the runtime required to achieve a desired generalization performance, instead of that to achieve a certain optimization accuracy on the empirical optimization problem.",
      "startOffset" : 39,
      "endOffset" : 70
    }, {
      "referenceID" : 4,
      "context" : "Following Hazan et al. (2011), and based on the generalization guarantees of Srebro et al.",
      "startOffset" : 10,
      "endOffset" : 30
    }, {
      "referenceID" : 4,
      "context" : "Following Hazan et al. (2011), and based on the generalization guarantees of Srebro et al. (2010), using a sample of size:",
      "startOffset" : 10,
      "endOffset" : 98
    }, {
      "referenceID" : 4,
      "context" : "SIMBA Recently, Hazan et al. (2011) presented SIMBA, a method for training linear SVMs based on the same “slack constrained” scalarization (Problem 2.",
      "startOffset" : 16,
      "endOffset" : 36
    }, {
      "referenceID" : 13,
      "context" : "Pegasos and SGD on L̂(w) Pegasos (Shalev-Shwartz et al., 2011) is a SGD method optimizing the regularized scalarization of Problem 2.",
      "startOffset" : 33,
      "endOffset" : 62
    }, {
      "referenceID" : 15,
      "context" : "(Zhang, 2004)).",
      "startOffset" : 0,
      "endOffset" : 13
    }, {
      "referenceID" : 7,
      "context" : "Dual Decomposition Methods Many of the most popular packages for optimizing kernel SVMs, including LIBSVM (Chang & Lin, 2001) and SVM-Light (Joachims, 1998), use dualdecomposition approaches.",
      "startOffset" : 140,
      "endOffset" : 156
    }, {
      "referenceID" : 6,
      "context" : "To the best of our knowledge, the most satisfying analysis for a dual decomposition method is the one given in Hush et al. (2006). In terms of learning runtime, this analysis yields a runtime of Õ (",
      "startOffset" : 111,
      "endOffset" : 130
    }, {
      "referenceID" : 5,
      "context" : "1 (Hsieh et al., 2008).",
      "startOffset" : 2,
      "endOffset" : 22
    }, {
      "referenceID" : 5,
      "context" : "The advantage here is that we do not need to use all of the responses at each iteration, so that if it is easy to calculate responses on-demand, as in the case of linear SVMs, each SDCA iteration can be calculated in time O(d) (Hsieh et al., 2008).",
      "startOffset" : 227,
      "endOffset" : 247
    }, {
      "referenceID" : 1,
      "context" : "(Cesa-Bianchi et al., 2001)).",
      "startOffset" : 0,
      "endOffset" : 27
    }, {
      "referenceID" : 1,
      "context" : "(Cesa-Bianchi et al., 2001)), and is therefore valid only for a single pass over the data.",
      "startOffset" : 0,
      "endOffset" : 27
    }, {
      "referenceID" : 13,
      "context" : "We compared to Pegasos (Shalev-Shwartz et al., 2011), SDCA (Hsieh et al.",
      "startOffset" : 23,
      "endOffset" : 52
    }, {
      "referenceID" : 5,
      "context" : ", 2011), SDCA (Hsieh et al., 2008), and SMO (Platt, 1998) with a second order heuristic for working point selection (Fan et al.",
      "startOffset" : 14,
      "endOffset" : 34
    }, {
      "referenceID" : 3,
      "context" : ", 2008), and SMO (Platt, 1998) with a second order heuristic for working point selection (Fan et al., 2005). These approaches work on the regularized formulation of Problem 2.2 or its dual (Problem 4.1). To enable comparison, the parameter ν for the SBP was derived from λ as ‖ŵ∗‖ ν = 1 n ∑n i=1 l (yi 〈w∗,Φ (xi)〉), where ŵ∗ is the known (to us) optimum. We first compared the methods on a SVM formulation without an unregularized bias, since Pegasos and SDCA do not naturally handle one. So that this comparison would be implementation-independent, we measure performance in terms of the number of kernel evaluations. As can be seen in Figure 2, the SBP outperforms Pegasos and SDCA, as predicted by the upper bounds. The SMO algorithm has a dramatically different performance profile, in line with the known analysis: it makes relatively little progress, in terms of generalization error, until it reaches a certain critical point, after which it converges rapidly. Unlike the other methods, terminating SMO early in order to obtain a cruder solution does not appear to be advisable. We also compared to the online Perceptron algorithm. Although use of the Perceptron is justified for nonseparable data only if run for a single pass over the training set, we did continue running for multiple passes. The Perceptron’s generalization performance is similar to that of the SBP for the first epoch, but the SBP continues improving over additional passes. As discussed in Section 4.5, the Perceptron is unsafe and might overfit after the first epoch, an effect which is clearly visible on the Adult dataset. To give a sense of actual runtime, we compared our implementation of the SBP to the SVM package LIBSVM, running on an Intel E7500 processor. We Source code is available from http://ttic.uchicago.edu/~cotter/projects/SBP allowed an unregularized bias (since that is what LIBSVM uses), and used the parameters in Table 2. For these experiments, we replaced the Reuters dataset with the version of the Forest dataset used by Nguyen et al. (2010), using their parameters.",
      "startOffset" : 90,
      "endOffset" : 2049
    }, {
      "referenceID" : 13,
      "context" : "Pegasos / SGD on L̂ If w is the result of a call to the Pegasos algorithm (Shalev-Shwartz et al., 2011) without a projection step, then the analysis of Kakade & Tewari (2009, Corollary 7) permits us to bound the suboptimality relative to an arbitrary reference classifier u, with probability 1− δ, as:",
      "startOffset" : 74,
      "endOffset" : 103
    }, {
      "referenceID" : 11,
      "context" : "To see this, we’ll follow Shalev-Shwartz & Srebro (2008) by decomposing the suboptimality in the empirical hinge loss as:",
      "startOffset" : 26,
      "endOffset" : 57
    }, {
      "referenceID" : 11,
      "context" : "If we run the online Perceptron algorithm for a single pass over the dataset, then Corollary 5 of (Shalev-Shwartz, 2007) gives the following mistake bound, for M being the set of iterations on which a",
      "startOffset" : 98,
      "endOffset" : 120
    }, {
      "referenceID" : 1,
      "context" : "Cesa-Bianchi et al. (2001)) would likely improve this term to log 1 δ .",
      "startOffset" : 0,
      "endOffset" : 27
    }, {
      "referenceID" : 5,
      "context" : "For example, Hsieh et al. (2008); Collins et al.",
      "startOffset" : 13,
      "endOffset" : 33
    }, {
      "referenceID" : 5,
      "context" : "For example, Hsieh et al. (2008); Collins et al. (2008) analyzed the convergence rate of SDCA and Chen et al.",
      "startOffset" : 13,
      "endOffset" : 56
    }, {
      "referenceID" : 5,
      "context" : "For example, Hsieh et al. (2008); Collins et al. (2008) analyzed the convergence rate of SDCA and Chen et al. (2006) analyzed the convergence rate of SMO-type dual decomposition methods.",
      "startOffset" : 13,
      "endOffset" : 117
    }, {
      "referenceID" : 5,
      "context" : "Hush et al. (2006) combined explicit convergence rate analysis of the dual sub-optimality of certain decomposition methods with Theorem E.",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 5,
      "context" : "Hsieh et al. (2008) analyzed the convergence rate of SDCA and derived a bound on the duality suboptimality after performing T iterations.",
      "startOffset" : 0,
      "endOffset" : 20
    } ],
    "year" : 2012,
    "abstractText" : "We present a novel approach for training kernel Support Vector Machines, establish learning runtime guarantees for our method that are better then those of any other known kernelized SVM optimization approach, and show that our method works well in practice compared to existing alternatives.",
    "creator" : "LaTeX with hyperref package"
  }
}