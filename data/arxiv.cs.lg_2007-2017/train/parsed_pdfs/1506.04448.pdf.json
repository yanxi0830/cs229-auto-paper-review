{
  "name" : "1506.04448.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Fast and Guaranteed Tensor Decomposition via Sketching",
    "authors" : [ "Yining Wang", "Hsiao-Yu Tung" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "Keywords: Tensor CP decomposition, count sketch, randomized methods, spectral methods, topic modeling"
    }, {
      "heading" : "1 Introduction",
      "text" : "In many data-rich domains such as computer vision, neuroscience and social networks consisting of multimodal and multi-relational data, tensors have emerged as a powerful paradigm for handling the data deluge. An important operation with tensor data is its decomposition, where the input tensor is decomposed into a succinct form. One of the popular decomposition methods is the CANDECOMP/PARAFAC (CP) decomposition, also known as canonical polyadic decomposition [12, 5], where the input tensor is decomposed into a succinct sum of rank-1 components. The CP decomposition has found numerous applications in data mining [4, 18, 20], computational neuroscience [10, 21], and recently, in statistical learning for latent variable models [1, 29, 27, 6]. For latent variable modeling, these methods yield consistent estimates under mild conditions such as non-degeneracy and require only polynomial sample and computational complexity [1, 29, 27, 6].\nGiven the importance of tensor methods for large-scale machine learning, there has been an increasing interest in scaling up tensor decomposition algorithms to handle gigantic real-world data tensors [26, 23, 8, 16, 14, 2, 28]. However, the previous works fall short in many ways, as described subsequently. In this paper, we design and analyze efficient randomized tensor methods using ideas from sketching [22]. The idea is to maintain a low-dimensional sketch of an input tensor and then perform implicit tensor decomposition using existing methods such as tensor power updates, alternating least squares or online tensor updates. We obtain the fastest decomposition methods for both sparse and dense tensors. Our framework can easily handle\nar X\niv :1\n50 6.\n04 44\n8v 1\n[ st\nat .M\nL ]\nmodern machine learning applications with billions of training instances, and at the same time, comes with attractive theoretical guarantees.\nOur main contributions are as follows:\nEfficient tensor sketch construction: We propose efficient construction of tensor sketches when the input tensor is available in factored forms such as in the case of empirical moment tensors, where the factor components correspond to rank-1 tensors over individual data samples. We construct the tensor sketch via efficient FFT operations on the component vectors. Sketching each rank-1 component takes O(n + b log b) operations where n is the tensor dimension and b is the sketch length. This is much faster than the O(np) complexity for brute force computations of a pth-order tensor. Since empirical moment tensors are available in the factored form with N components, where N is the number of samples, it takes O((n + b log b)N) operations to compute the sketch.\nImplicit tensor contraction computations: Almost all tensor manipulations can be expressed in terms of tensor contractions, which involves multilinear combinations of different tensor fibres [19]. For example, tensor decomposition methods such as tensor power iterations, alternating least squares (ALS), whitening and online tensor methods all involve tensor contractions. We propose a highly efficient method to directly compute the tensor contractions without forming the input tensor explicitly. In particular, given the sketch of a tensor, each tensor contraction can be computed in O(n + b log b) operations, regardless of order of the source and destination tensors. This significantly accelerates the brute-force implementation that requires O(np) complexity for pth-order tensor contraction. In addition, in many applications, the input tensor is not directly available and needs to be computed from samples, such as the case of empirical moment tensors for spectral learning of latent variable models. In such cases, our method results in huge savings by combining implicit tensor contraction computation with efficient tensor sketch construction.\nNovel colliding hashes for symmetric tensors: When the input tensor is symmetric, which is the case for empirical moment tensors that arise in spectral learning applications, we propose a novel colliding hash design by replacing the Boolean ring with the complex ring C to handle multiplicities. As a result, it makes the sketch building process much faster and avoids repetitive FFT operations. Though the computational complexity remains the same, the proposed colliding hash design results in significant speed-up in practice by reducing the actual number of computations.\nTheoretical and empirical guarantees: We show that the quality of the tensor sketch does not depend on sparseness, uniform entry distribution, or any other properties of the input tensor. On the other hand, previous works assume specific settings such as sparse tensors [23, 8, 16], or tensors having entries with similar magnitude [26]. Such assumptions are unrealistic, and in practice, we may have both dense and spiky tensors, for example, unordered word trigrams in natural language processing. We prove that our proposed randomized method for tensor decomposition does not lead to any significant degradation of accuracy.\nExperiments on synthetic and real-world datasets show highly competitive results. We demonstrate a 10x to 100x speed-up over exact methods for decomposing dense, high-dimensional tensors. For topic modeling, we show a significant reduction in computational time over existing spectral LDA implementations with small performance loss. In addition, our proposed algorithm outperforms collapsed Gibbs sampling when running time is constrained. We also show that if a Gibbs sampler is initialized with our output topics, it converges within several iterations and outperforms a randomly initialized Gibbs sampler run for much more iterations. Since our proposed method is efficient and avoids local optima, it can be used to accelerate the slow burn-in phase in Gibbs sampling.\nRelated Works: There have been numerous works on deploying efficient tensor decomposition methods [26, 23, 8, 16, 14, 2, 28]. Most of these works except [26, 2] implement the alternating least squares (ALS) algorithm [12, 5]. However, this is extremely expensive since the above works run the ALS method in\nthe input space, and require O(n3) operations to execute one least squares step on a n-dimensional (dense) tensor. Thus, such implementations are only suited for extremely sparse tensors.\nAn alternative method is to first reduce the dimension of the input tensor through procedures such as whitening to O(k) dimension, where k is the tensor rank, and then carry out ALS in the dimension-reduced space on k×k×k tensor [13]. This results in significant reduction of computational complexity when the rank is small (k n). Nonetheless, in practice, such complexity is still prohibitively high as k could be several thousands in many settings. To make matters even worse, when the tensor corresponds to empirical moments computed from samples, such as in spectral learning of latent variable models, it is actually much slower to construct the reduced dimension k × k × k tensor from training data than to decompose it, since the number of training samples is typically very large. Another alternative is to carry out online tensor decomposition, as opposed to batch operations in the above works. Such methods are extremely fast [14], but can suffer from high variance. The sketching ideas developed in this paper will improve our ability to handle larger sizes of mini-batches and therefore result in reduced variance in online tensor methods.\nAnother alternative method is to consider a randomized sampling of the input tensor in each iteration of tensor decomposition [26, 2]. However, such methods can be expensive due to I/O calls and are sensitive to the sampling distribution. In particular, [26] employs uniform sampling, which is incapable of handling tensors with spiky elements. Though non-uniform sampling is adopted in [2], it requires an additional pass over the training data to compute the sampling distribution. In contrast, our sketch based method takes only one pass of the data."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "Tensor, tensor product and tensor decomposition A 3rd order tensor 1 T of dimension n has n3 entries. Each entry can be represented as Tijk for i, j, k ∈ {1, · · · , n}. For an n × n × n tensor T and a vector u ∈ Rn, we define two forms of tensor products (contractions) as follows:\nT(u,u,u) = n∑ i,j,k=1 Ti,j,kuiujuk; T(I,u,u) =  n∑ j,k=1 T1,j,kujuk, · · · , n∑ j,k=1 Tn,j,kujuk  . Note that T(u,u,u) ∈ R and T(I,u,u) ∈ Rn. For two complex tensors A,B of the same order and dimension, its inner product is defined as 〈A,B〉 := ∑ lAlBl, where l takes the value of all tuples that\nindex the tensors. The Frobenius norm of a tensor is simply ‖A‖F = √ 〈A,A〉.\nFor a 3rd order tensor T ∈ Rn×n×n its rank-k CP decomposition involves values {λi}ki=1 ⊆ R and vectors {ai}ki=1, {bi}ki=1, {ci}ki=1 ⊆ Rn such that the residual ∥∥∥T−∑ki=1 λiai ⊗ bi ⊗ ci∥∥∥2\nF is minimized.\nHere R = a ⊗ b ⊗ c is a 3rd order tensor defined as Rijk = aibjck. Additional notations are defined in Table 1 and Appendix F.\nRobust tensor power method It was proposed in [1] and was shown to provably succeed if the input tensor is a noisy perturbation of the sum of k rank-1 tensors whose base vectors are orthogonal. Fix an input tensor T ∈ Rn×n×n, The basic idea is to randomly generate L initial vectors and perform T power update steps: û = T(I,u,u)/‖T(I,u,u)‖2. The vector that results in the largest eigenvalue T(u,u,u) is then kept and subsequent eigenvectors can be obtained via deflation. If implemented naively, the algorithm takes\n1Though we mainly focus on 3rd order tensors in this work, extension to higher order tensors is easy.\nAlgorithm 1 Efficient sketching of factored and empirical moment tensors 1: Input: Tensor T = ∑N i=1 aiui ⊗ vi ⊗wi, hash length b, number of sketches B.\n2: Initialize: hash functions h(m)1 , h (m) 2 , h (m) 3 , ξ (m) 1 , ξ (m) 2 , ξ (m) 3 for m = 1, · · · , B; s (m) T = 0. 3: for m ∈ 1, · · · , B, i ∈ {1, · · ·N} do 4: Compute s(m)1,i (t) = ∑ h (m) 1 (j)=t ξ (m) 1 (j)[ui]j and s (m) 2,i (t), s (m) 3,i (t) analogously. 5: Update: s(m)T ← s (m) T + ai · F−1(F(s (m) 1,i ◦ F(s (m) 2,i ) ◦ F(s (m) 3,i )). 3ai is defined in Line 1. 6: Output: B sketches: s(1)T , · · · , s (B) T .\nO(kn3LT ) time to run 2, requiring O(n3) storage. In addition, in certain cases when a second-order moment matrix is available, the tensor power method can be carried out on a k × k × k whitened tensor [1], thus improving the time complexity by avoiding dependence on the ambient dimension n. Apart from the tensor power method, other algorithms such as Alternating Least Squares (ALS, [12, 5]) and Stochastic Gradient Descent (SGD, [14]) have also been applied to tensor CP decomposition."
    }, {
      "heading" : "3 Fast tensor decomposition via sketching",
      "text" : "In this section we first introduce tensor sketching [22] and show how sketches can be computed efficiently for factored or empirical moment tensors. We then show how to run tensor power method directly on the sketch with reduced computational complexity. In addition, when the input tensor is symmetric (i.e., Tijk the same for all permutations of i, j, k) we propose a novel “colliding hash” design, which speeds up the sketch building process. Due to space limits we only consider the robust tensor power method in the main text. Methods and experiments for sketching based ALS method are presented in Appendix C.\nTo avoid confusions, we emphasize that n is used to denote the dimension of the tensor to be decomposed, which is not necessarily the same as the dimension of the original data tensor. Indeed, once whitening is applied n could be as small as the intrinsic dimension k of the original data tensor."
    }, {
      "heading" : "3.1 Tensor sketch",
      "text" : "Tensor sketch was proposed in [22] as a generalization of count sketch [7]. For a tensor T of dimension n1 × · · · × np, random hash functions h1, · · · , hp : [n] → [b] with Prhj [hj(i) = t] = 1/b for every i ∈ [n], j ∈ [p], t ∈ [b] and random Bernoulli variables ξ1, · · · , ξp : [n]→ {+1,−1} with Prξj [ξj(i) = 1] = Prξj [ξj(i) = −1] = 1/2, the tensor sketch sT : [b]→ R is defined as\nsT(t) = ∑\nH(i1,··· ,ip)=t\nξ1(i1) · · · ξp(ip)Ti1,··· ,ip , (1)\nwhere H(i1, · · · , ip) = (h1(i1) + · · · + hp(ip)) mod b. The corresponding recovery rule is T̂i1,··· ,ip = ξ1(i1) · · · ξp(ip)sT(H(i1, · · · , ip)). For accurate recovery, H needs to be 2-wise independent, which is achieved by independently selecting h1, · · · , hp from a 2-wise independent hash family [25]. The following proposition upper bounds the recovery error in terms of hash length b and tensor Frobenious norm ‖T‖F . Its proof is deferred to Appendix E.1.\nProposition 1. Fix i1, · · · , ip. For every > 0 the following holds:\nPr H,ξ [∣∣T̂i1,··· ,ip −Ti1,··· ,ip ∣∣ ≥ ] ≤ ‖T‖2F /(b 2). (2)"
    }, {
      "heading" : "3.2 Efficient sketching of empirical moment tensors",
      "text" : "2L is usually set to be a linear function of k and T is logarithmic in n; see Theorem 5.1 in [1]. 3F and F−1 stand for the FFT and inverse FFT operators.\nWe present efficient algorithms to sketch an empirical moment tensor. The proposed method scales linearly with tensor dimension, which is much more efficient than explicitly constructing the data tensor that takes cubic time in the worst case. The main idea is to decompose an empirical moment tensor into the sum of many rank-1 components and then apply FFT for each component."
    }, {
      "heading" : "3.2.1 Sketching a rank-1 tensor",
      "text" : "For a rank-1 tensor T = u⊗ v⊗w with u,v,w ∈ Rn, its b-dimensional tensor sketch sT can be computed efficiently via the following expression: sT = s1,u ∗ s2,v ∗ s3,w = F−1(F(s1,u) ◦ F(s1,u) ◦ F(s1,u)), (3) where ∗ denotes convolution and ◦ stands for element-wise vector product. s1,u(t) = ∑ h1(i)=t\nξ1(i)ui is the count sketch of u and s2,v, s3,w are defined similarly. F and F−1 denote the Fast Fourier Transform (FFT) and its inverse operator. By applying FFT, we reduce the convolution computation into element-wise product evaluation in the Fourier space. Therefore, sT can be computed using O(n + b log b) operations, where the O(b log b) term arises from FFT evaluations."
    }, {
      "heading" : "3.2.2 Extension to factored and empirical moment tensors",
      "text" : "For a tensor T with known rank factorization T = ∑N i=1 aiui ⊗ vi ⊗wi, we can efficiently compute its tensor sketch sT by directly applying techniques in Sec. 3.2.1 because the sketching operator is linear; that is, sλA+µB = λsA + µsB for arbitrary scalars λ, µ and tensors A,B. Consequently, computing sT takes O(N(n+ b log b)) operations, which is linear in tensor dimension n. On the other hand, most empirical moment tensors appeared in spectral learning of latent variable models do have known rank factorizations. For example, a 3rd-order empirical moment Ê[x⊗3] can be written as Ê[x⊗3] = 1N ∑N i=1 x ⊗3 i , where {xi}Ni=1 are the training data points. Pseudocode for efficient sketch computation of factored and empirical moment tensors is listed in Alg 1. We compute B independent sketches and output the median of the results. Such schemes were shown to effectively reduce the approximation error from sketching and also result in exponentially decaying tails for failure probability [7]. Furthermore, when training data are truly abundant it helps to apply sketching on mini-batches of training data, which keeps the computational cost small and yet has reduced variance compared to purely online methods with batch size equals one [14]."
    }, {
      "heading" : "3.3 Fast robust tensor power method",
      "text" : "We are now ready to present the fast robust tensor power method, the main algorithm of this paper. The computational bottleneck of the original robust tensor power method is the computation of two tensor products: T(I,u,u) and T(u,u,u). A naive implementation requires O(n3) operations. In this section, we show how to speed up computation of these products. We show that given the sketch of an input tensor T, one can approximately compute both T(I,u,u) and T(u,u,u) in O(b log b+ n) steps, where b is the hash length.\nBefore going into details, we explain the key idea behind our fast tensor product computation. For any two tensors A,B, its inner product 〈A,B〉 can be approximated by 5\n〈A,B〉 ≈ 〈sA, sB〉. (4) Eq. (4) immediately results in a fast approximation procedure of T(u,u,u) because T(u,u,u) = 〈T,X〉 where X = u⊗ u⊗ u is a rank one tensor, whose sketch can be built in O(n+ b log b) time by Sec. 3.2.1. Consequently, the product can be approximately computed usingO(n+b log b) operations if the tensor sketch of T is available. For tensor product of the form T(I,u,u). The ith coordinate in the result can be expressed as 〈T,Yi〉where Yi = ei⊗u⊗u; ei = (0, · · · , 0, 1, 0, · · · , 0) is the ith indicator vector. We can then apply Eq. (4) to approximately compute 〈T,Yi〉 efficiently. However, this method is not completely satisfactory\n4<(·) denotes the real part of a complex number. med(·) denotes the median. 5All approximations will be theoretically justified in Section 4 and Appendix E.2.\nAlgorithm 2 Fast robust tensor power method\nPLAIN SKETCH PLAIN+WHITENING SKETCH+WHITENING preprocessing: general tensors - O(n3) O(kn3) O(n3) preprocessing: factored tensors\nO(Nn3) O(N(n+ b log b)) O(N(nk + k3)) O(N(nk + b log b))with N components per tensor contraction time O(n3) O(n+ b log b) O(k3) O(k + b log b)\nbecause it requires sketching n rank-1 tensors (Y1 through Yn), which results in O(n) FFT evaluations by Eq. (3). Below we present a proposition that allows us to use only O(1) FFTs to approximate T(I,u,u).\nProposition 2. 〈sT, s1,ei ∗ s2,u ∗ s3,u〉 = 〈F−1(F(sT) ◦ F(s2,u) ◦ F(s3,u)), s1,ei〉.\nProposition 2 is proved in Appendix E.1. The main idea is to “shift” all terms not depending on i to the left side of the inner product and eliminate the inverse FFT operation on the right side so that sei contains only one nonzero entry. As a result, we can computeF−1(F(sT)◦F(s2,u)◦F(s3,u)) once and read off each entry of T(I,u,u) in constant time. In addition, the technique can be further extended to symmetric tensor sketches, with details deferred to Appendix B due to space limits. When operating on an n-dimensional tensor, The algorithm requires O(kLT (n + Bb log b)) running time (excluding the time for building s̃T̄) and O(Bb) memory, which significantly improves the O(kn3LT ) time and O(n3) space complexity over the brute force tensor power method. Here L, T are algorithm parameters for robust tensor power method. Previous analysis shows that T = O(log k) and L = poly(k), where poly(·) is some low order polynomial function. [1]\nFinally, Table 2 summarizes computational complexity of sketched and plain tensor power method."
    }, {
      "heading" : "3.4 Colliding hash and symmetric tensor sketch",
      "text" : "For symmetric input tensors, it is possible to design a new style of tensor sketch that can be built more efficiently. The idea is to design hash functions that deliberately collide symmetric entries, i.e., (i, j, k), (j, i, k), etc. Consequently, we only need to consider entries Tijk with i ≤ j ≤ k when building tensor sketches. An intuitive idea is to use the same hash function and Rademacher random variable for each order, that is, h1(i) = h2(i) = h3(i) =: h(i) and ξ1(i) = ξ2(i) = ξ3(i) =: ξ(i). In this way, all permutations of (i, j, k) will collide with each other. However, such a design has an issue with repeated entries because ξ(i) can only take ±1 values. Consider (i, i, k) and (j, j, k) as an example: ξ(i)2ξ(k) = ξ(j)2ξ(k) with probability 1 even if i 6= j. On the other hand, we need E[ξ(a)ξ(b)] = 0 for any pair of distinct 3-tuples a and b.\nTo address the above-mentioned issue, we extend the Rademacher random variables to the complex domain and consider all roots of zm = 1, that is, Ω = {ωj}m−1j=0 where ωj = ei 2πj m . Suppose σ(i) is a Rademacher random variable with Pr[σ(i) = ωi] = 1/m. By elementary algebra, E[σ(i)p] = 0 whenever m is relative prime to p or m can be divided by p. Therefore, by setting m = 4 we avoid collisions of repeated entries in a 3rd order tensor. More specifically, The symmetric tensor sketch of a symmetric tensor T ∈ Rn×n×n can be defined as\ns̃T(t) := ∑\nH̃(i,j,k)=t\nTi,j,kσ(i)σ(j)σ(k), (5)\nwhere H̃(i, j, k) = (h(i) + h(j) + h(k)) mod b. To recover an entry, we use\nT̂i,j,k = 1/κ · σ(i) · σ(j) · σ(k) · s̃T(H(i, j, k)), (6) where κ = 1 if i = j = k; κ = 3 if i = j or j = k or i = k; κ = 6 otherwise. For higher order tensors, the coefficients can be computed via the Young tableaux which characterizes symmetries under the permutation group. Compared to asymmetric tensor sketches, the hash function h needs to satisfy stronger independence conditions because we are using the same hash function for each order. In our case, h needs to be 6-wise independent to make H̃ 2-wise independent. The fact is due to the following proposition, which is proved in Appendix E.1.\nProposition 3. Fix p and q. For h : [n]→ [b] define symmetric mapping H̃ : [n]p → [b] as H̃(i1, · · · , ip) = h(i1) + · · ·+ h(ip). If h is (pq)-wise independent then H is q-wise independent.\nThe symmetric tensor sketch described above can significantly speed up sketch building processes. For a general tensor with M nonzero entries, to build s̃T one only needs to consider roughly M/6 entries (those Tijk 6= 0 with i ≤ j ≤ k). For a rank-1 tensor u⊗3, only one FFT is needed to build F(s̃); in contrast, to compute Eq. (3) one needs at least 3 FFT evaluations.\nFinally, in Appendix B we give details on how to seamlessly combine symmetric hashing and techniques in previous sections to efficiently construct and decompose a tensor."
    }, {
      "heading" : "4 Error analysis",
      "text" : "In this section we provide theoretical analysis on approximation error of both tensor sketch and the fast sketched robust tensor power method. We mainly focus on symmetric tensor sketches, while extension to asymmetric settings is trivial. Due to space limits, all proofs are placed in the appendix."
    }, {
      "heading" : "4.1 Tensor sketch concentration bounds",
      "text" : "Theorem 1 bounds the approximation error of symmetric tensor sketches when computing T(u,u,u) and T(I,u,u). Its proof is deferred to Appendix E.2.\nTheorem 1. Fix a symmetric real tensor T ∈ Rn×n×n and a real vector u ∈ Rn with ‖u‖2 = 1. Suppose ε1,T (u) ∈ R and ε2,T (u) ∈ Rn are estimation errors of T(u,u,u) and T(I,u,u) using B independent symmetric tensor sketches; that is, ε1,T (u) = T̂(u,u,u) − T(u,u,u) and ε2,T (u) = T̂(I,u,u) − T(I,u,u). If B = Ω(log(1/δ)) then with probability ≥ 1− δ the following error bounds hold:∣∣ε1,T (u)∣∣ = O(‖T‖F /√b); ∣∣ [ε2,T (u)]i ∣∣ = O(‖T‖F /√b), ∀i ∈ {1, · · · , n}. (7) In addition, for any fixed w ∈ Rn, ‖w‖2 = 1 with probability ≥ 1− δ we have\n〈w, ε2,T (u)〉2 = O(‖T‖2F /b). (8)"
    }, {
      "heading" : "4.2 Analysis of the fast tensor power method",
      "text" : "We present a theorem analyzing robust tensor power method with tensor sketch approximations. A more detailed theorem statement along with its proof can be found in Appendix E.3.\nTheorem 2. Suppose T̄ = T + E ∈ Rn×n×n where T = ∑k i=1 λiv ⊗3 i with an orthonormal basis {vi}ki=1, λ1 > · · · > λk > 0 and ‖E‖ = . Let {(λ̂i, v̂i)}ki=1 be the eigenvalue/eigenvector pairs obtained by Algorithm 2. Suppose = O(1/(λ1n)), T = Ω(log(n/δ) + log(1/ ) maxi λi/(λi − λi−1)) and L grows linearly with k. Assume the randomness of the tensor sketch is independent among tensor product evaluations. If B = Ω(log(n/δ)) and b satisfies\nb = Ω ( max { −2‖T‖2F\n∆(λ)2 , δ−4n2‖T‖2F r(λ)2λ21\n}) (9)\nwhere ∆(λ) = mini(λi − λi−1) and r(λ) = maxi,j>i(λi/λj), then with probability ≥ 1− δ there exists a permutation π over [k] such that\n‖vπ(i) − v̂i‖2 ≤ , |λπ(i) − λ̂i| ≤ λi /2, ∀i ∈ {1, · · · , k} (10) and ‖T− ∑k i=1 λ̂iv̂ ⊗3 i ‖ ≤ c for some constant c.\nTheorem 1 shows that the sketch length b can be set as o(n3) to provably approximately decompose a 3rdorder tensor with dimension n. Theorem 1 together with time complexity comparison in Table 2 shows that the sketching based fast tensor decomposition algorithm has better computational complexity over brute-force implementation. One potential drawback of our analysis is the assumption that sketches are independently built for each tensor product (contraction) evaluation. This is an artifact of our analysis and we conjecture that it can be removed by incorporating recent development of differentially private adaptive query framework [9]."
    }, {
      "heading" : "5 Experiments",
      "text" : "We demonstrate the effectiveness and efficiency of our proposed sketch based tensor power method on both synthetic tensors and real-world topic modeling problems. Experimental results involving the fast ALS method are presented in Appendix C.3. All methods are implemented in C++ and tested on a single machine with 8 Intel X5550@2.67Ghz CPUs and 32GB memory. For synthetic tensor decomposition we use only a single thread; for fast spectral LDA 8 to 16 threads are used."
    }, {
      "heading" : "5.1 Synthetic tensors",
      "text" : "In Table 5 we compare our proposed algorithms with exact decomposition methods on synthetic tensors. Let n = 1000 be the dimension of the input tensor. We first generate a random orthonormal basis {vi}ni=1 and then set the input tensor T as T = normalize( ∑n i=1 λiv ⊗3 i ) + E, where the eigenvalues λi satisfy λi = 1/i. The normalization step makes ‖T‖2F = 1 before imposing noise. The Gaussian noise matrix E is symmetric with Eijk ∼ N (0, σ/n1.5) for i ≤ j ≤ k and noise-to-signal level σ. Due to time constraints, we only compare the recovery error and running time on the top 10 recovered eigenvectors of the full-rank input tensor T. Both L and T are set to 30. Table 3 shows that our proposed algorithms achieve reasonable\napproximation error within a few minutes, which is much faster then exact methods. A complete version (Table 5) is deferred to Appendix A."
    }, {
      "heading" : "5.2 Topic modeling",
      "text" : "We implement a fast spectral inference algorithm for Latent Dirichlet Allocation (LDA [3]) by combining tensor sketching with existing whitening technique for dimensionality reduction. Implementation details are provided in Appendix D. We compare our proposed fast spectral LDA algorithm with baseline spectral methods and collapsed Gibbs sampling (using GibbsLDA++ [24] implementation) on two real-world datasets: Wikipedia and Enron. Dataset details are presented in A Only the most frequent V words are kept and the vocabulary size V is set to 10000. For the robust tensor power method the parameters are set to L = 50 and T = 30. For ALS we iterate until convergence, or a maximum number of 1000 iterations is reached. α0 is set to 1.0 and B is set to 30.\nObtained topic models Φ ∈ RV×K are evaluated on a held-out dataset consisting of 1000 documents randomly picked out from training datasets. For each testing document d, we fit a topic mixing vector π̂d ∈ RK by solving the following optimization problem: π̂d = argmin‖π‖1=1,π≥0‖wd −Φπ‖2,wherewd is the empirical word distribution of document d. The per-document log-likelihood is then defined as Ld = 1 nd ∑nd i=1 ln p(wdi), where p(wdi) = ∑K k=1 π̂kΦwdi,k. Finally, the average Ld over all testing documents is reported. Figure 1 shows the held-out negative log-likelihood for fast spectral LDA under different hash lengths b. We can see that as b increases, the performance approaches the exact tensor power method because sketching approximation becomes more accurate. On the other hand, Table 6 shows that fast spectral LDA runs much faster than exact tensor decomposition methods while achieving comparable performance on both datasets.\nFigure 2 compares the convergence of collapsed Gibbs sampling with different number of iterations and fast spectral LDA with different hash lengths on Wikipedia dataset. For collapsed Gibbs sampling, we set α = 50/K and β = 0.1 following [11]. As shown in the figure, fast spectral LDA achieves comparable heldout likelihood while running faster than collapsed Gibbs sampling. We further take the dictionary Φ output by fast spectral LDA and use it as initializations for collapsed Gibbs sampling (the word topic assignments z are obtained by 5-iteration Gibbs sampling, with the dictionary Φ fixed). The resulting Gibbs sampler converges much faster: with only 3 iterations it already performs much better than a randomly initialized Gibbs sampler run for 100 iterations, which takes 10x more running time.\nWe also report performance of fast spectral LDA and collapsed Gibbs sampling on a larger dataset in Table 4. The dataset was built by crawling 1,085,768 random Wikipedia pages and a held-out evaluation set was built by randomly picking out 1000 documents from the dataset. Number of topics k is set to 200 or 300, and after getting topic dictionary Φ from fast spectral LDA we use 2-iteration Gibbs sampling to obtain word topic assignments z. Table 4 shows that the hybrid method (i.e., collapsed Gibbs sampling initialized by spectral LDA) achieves the best likelihood performance in a much shorter time, compared to a randomly initialized Gibbs sampler."
    }, {
      "heading" : "Appendix A Supplementary experimental results",
      "text" : "The Wikipedia dataset is built by crawling all documents in all subcategories within 3 layers below the science category. The Enron dataset is from the Enron email corpus [17]. After usual cleaning steps, the Wikipedia dataset has 114, 274 documents with an average 512 words per document; the Enron dataset has 186, 501 emails with average 91 words per email."
    }, {
      "heading" : "Appendix B Fast tensor power method via symmetric sketching",
      "text" : "In this section we show how to do fast tensor power method using symmetric tensor sketches. More specifically, we explain how to approximately compute T(u,u,u) and T(I,u,u) when colliding hashes are used.\nFor symmetric tensors A and B, their inner product can be approximated by 〈A,B〉 ≈ 〈s̃A, s̃B̃〉, (11)\nwhere B̃ is an “upper-triangular” tensor defined as\nB̃i,j,k = { Bi,j,k, if i ≤ j ≤ k; 0, otherwise. (12)\nNote that in Eq. (11) only the matrix B is “truncated”. We show this gives consistent estimates of 〈A,B〉 in Appendix E.2.\nRecall that T(u,u,u) = 〈T,X〉 where X = u ⊗ u ⊗ u. The symmetric tensor sketch s̃X̃ can be computed as\ns̃X̃ = 1 6 s̃⊗3u + 1 2 s̃2,u◦u ∗ s̃u + 1 3 s̃3,u◦u◦u, (13)\nwhere s̃2,u◦u(t) = ∑ 2h(i)=t σ(i) 2u2i and s̃3,u◦u◦u(t) = ∑ 3h(i)=t σ(i) 3u3i . As a result,\nT(u,u,u) ≈ 1 6 〈F(s̃T),F(s̃u) ◦ F(s̃u) ◦ F(s̃u)〉+ 1 2 〈F(s̃T),F(s̃2,u◦u) ◦ F(s̃u)〉+ 1 3 〈s̃T, s̃3,u◦u◦u〉.\n(14) For T(I,u,u) recall that [T(I,u,u)]i = 〈T,Yi〉 where Yi = ei ⊗ u ⊗ u. We first symmetrize it by defining Zi = ei ⊗u⊗u+u⊗ ei ⊗u+u⊗u⊗ ei. 6 The sketch of Z̃i can be subsequently computed as\ns̃Z̃i = 1 2 s̃u ∗ s̃u ∗ s̃ei + 1 2 s̃2,u◦u ∗ s̃ei + s̃2,ei◦u ∗ s̃u + s̃3,ei◦u◦u. (15)\nConsequently, T(I,u,u) ≈ 〈 F−1 ( F(s̃T) ◦ F(s̃u) ) , s̃2,ei◦u 〉 + 1\n6\n〈 F−1 ( F(s̃T) ◦ F(s̃u) ◦ F(s̃u) ) , s̃ei 〉 + 1\n6\n〈 F−1 ( F(s̃T) ◦ F(s̃2,u◦u) ) , s̃ei 〉 + 〈s̃T, s̃3,ei◦u◦u〉. (16)\nNote that all of s̃ei , s̃2,ei◦u and s̃3,ei◦u◦u have exactly one nonzero entries. So we can pre-compute all terms on the left sides of inner products in Eq. (16) and then read off the values for each entry in T(I,u,u)."
    }, {
      "heading" : "Appendix C Fast ALS: method and simulation result",
      "text" : "In this section we describe how to use tensor sketching to accelerate the Alternating Least Squares (ALS) method for tensor CP decomposition. We also provide experimental results on synthetic data and compare our fast ALS implementation with the Matlab tensor toolbox [?, ?], which is widely considered to be the state-of-the-art for tensor decomposition.\nC.1 Alternating Least Squares Alternating Least Squares (ALS) is a popular method for tensor CP decompositions [19]. The algorithm maintains λ ∈ Rk, A,B,C ∈ Rn×k and iteratively perform the following update steps:\nÂ = T(1)(C B)(C>C ◦B>B)†. (17)\nB̂ = T(1)(Â C)(Â>Â ◦C>C)†;\nĈ = T(1)(B̂ Â)(B̂>B̂ ◦ Â>Â)†.\nAfter each update, λ̂r is set to ‖ar‖2 (or ‖br‖2, ‖cr‖2) for r = 1, · · · , k and the matrix A (or B,C) is normalized so that each column has unit norm. The final low-rank approximation is obtained by ∑k i=1 λ̂iâi ⊗ b̂i ⊗ ĉi.\nThere is no guarantee that ALS converges or gives a good tensor decomposition. Nevertheless, it works reasonably well in most applications [19]. In general ALS requiresO(T (n3k+k3)) computations andO(n3) storage, where T is the number of iterations.\nC.2 Accelerated ALS via sketching Similar to robust tensor power method, the ALS algorithm can be significantly accelerated by using the idea of sketching as shown in this work. However, for ALS we cannot use colliding hashes because though the input tensor T is symmetric, its CP decomposition is not since we maintain three different solution matrices A,B and C. As a result, we roll back to asymmetric tensor sketches defined in Eq. (1). Recall that given A,B,C ∈ Rn×k we want to compute\nÂ = T(1)(C B)(C>C ◦B>B)†. (18) 6As long as A is symmetric, we have 〈A,Yi〉 = 〈A,Zi〉/3.\nAlgorithm 3 Fast ALS method\nResidual norm No. of wrong vectors Running time (min.) log2(b): 12 13 14 15 16 12 13 14 15 16 12 13 14 15 16\nσ = .0"
    }, {
      "heading" : "1 B = 20 .71 .41 .25 .17 .12 10 9 7 6 4 .11 .22 .49 1.1 2.4",
      "text" : "B = 30 .50 .34 .21 .14 .11 9 8 7 5 3 .17 .33 .75 1.6 3.5 B = 40 .46 .28 .17 .10 .07 9 8 6 5 1 .23 .45 1.0 2.2 4.7 Exact† .07 1 22.8\nσ = .1 B = 20 .88 .50 .35 .28 .23 10 8 7 6 6 .13 .32 .78 1.5 3.2 B = 30 .78 .44 .30 .24 .21 9 8 7 5 6 .21 .50 1.1 2.2 4.7 B = 40 .56 .38 .28 .19 .16 9 8 6 4 2 .29 .69 1.5 3.5 6.3 Exact† .17 2 32.3\n†Calling cp als in Matlab tensor toolbox. It is run for exactly T = 30 iterations.\nWhen k is much smaller than the ambient tensor dimension n the computational bottleneck of Eq. (18) is T(1)(C B), which requires O(n3k) operations. Below we show how to use sketching to speed up this computation.\nLet x ∈ Rn2 be one row in T(1) and consider (C B)>x. It can be shown that [15][ (C B)>x ] i\n= b>i Xci, ∀i = 1, · · · , k, (19) where X ∈ Rn×n is the reshape of vector x. Subsequently, the product T(1)(C B) can be re-written as\nT(1)(C B) = [T(I, b1, c1); · · · ; T(I, bk, ck)]. (20) Using Proposition 2 we can compute each of T(I, bi, ci) in O(n+ b log b) iterations. Note that in general bi 6= ci, but Proposition 2 still holds by replacing one of the two su sketches. As a result, T(1)(C B) can be computed in O(k(n + b log b)) operations once sT is computed. The pseudocode of fast ALS is listed in Algorithm 3. Its time complexity and space complexity are O(T (k(n+Bb log b) + k3)) (excluding the time for building sT) and O(Bb), respectively.\nC.3 Simulation results We compare the performance of fast ALS with a brute-force implementation under various hash length settings on synthetic datasets in Table 7. Settings for generating the synthetic dataset is exactly the same as in Section 5.1. We use the cp als routine in Matlab tensor toolbox as the reference brute-force implementation of ALS. For fair comparison, exactly T = 30 iterations are performed for both plain and accelerated ALS algorithms. Table 7 shows that when sketch length b is not too small, fast ALS achieves comparable accuracy with exact methods while being much faster in terms of running time.\nAlgorithm 4 Fast spectral LDA 1: Input: Unlabeled documents, V , K, α0, B, b. 2: Compute empirical moments M̂1 and M̂2 defined in Eq. (21,22). 3: [U,S,V]← truncatedSVD(M̂2, k); Wik ← Uik√σk . 4: Build B tensor sketches of M̂3(W,W,W). 5: Find CP decomposition {λi}ki=1,A = B = C = {vi}ki=1 of M̂3(W,W,W) using either fast tensor\npower method or fast ALS method. 6: Output: estimates of prior parameters α̂i = 4α0(α0+1)(α0+2)2λ2i and topic distributions µ̂i = α0+2 2 λi(W †)>vi."
    }, {
      "heading" : "Appendix D Spectral LDA and fast spectral LDA",
      "text" : "Latent Dirichlet Allocation (LDA, [3]) is a powerful tool in topic modeling. In this section we first review the LDA model and introduce the tensor decomposition method for learning LDA models, which was proposed in [1]. We then provide full details of our proposed fast spectral LDA algorithm. Pseudocode for fast spectral LDA is listed in Algorithm 4.\nD.1 LDA and spectral LDA LDA models a collection of documents by a topic dictionary Φ ∈ RV×K and a Dirichlet priorα ∈ Rk, where V is the vocabulary size and k is the number of topics. Each column in Φ is a probability distribution (i.e., non-negative and sum to one) representing the word distribution of a particular topic. For each document d, a topic mixing vector hd ∈ Rk is first sampled from a Dirichlet distribution parameterized by α. Afterwards, words in document d i.i.d. sampled from a categorical distribution parameterized by Φhd.\nA spectral method for LDA based on 3rd-order robust tensor decomposition was proposed in [1] to provably learn LDA model parameters from a polynomial number of training documents. Let x ∈ RV represent a single word; that is, for word w we have xw = 1 and xw′ = 0 for all w′ 6= w. Define first, second and third order moments M1,M2 and M3 as follows:\nM1 = E[x1]; (21) M2 = E[x1 ⊗ x2]− α0\nα0 + 1 M1 ⊗M1; (22)\nM3 = E[x1 ⊗ x2 ⊗ x3]− α0\nα0 + 2 (E[x1 ⊗ x2 ⊗M1] + E[x1 ⊗M1 ⊗ x2] + E[M1 ⊗ x1 ⊗ x2])\n+ 2α20\n(α0 + 1)(α0 + 2) M1 ⊗M1 ⊗M1. (23) Here α0 = ∑ k αk is assumed to be a known quantity. Using elementary algebra it can be shown that\nM2 = 1\nα0(α0 + 1) k∑ i=1 αiµiµ > i ; (24)\nM3 = 2\nα0(α0 + 1)(α0 + 2) k∑ i=1 αiµi ⊗ µi ⊗ µi. (25)\nTo extract topic vectors {µi}ki=1 from M2 and M3, a simultaneous diagonalization procedure is carried out. More specifically, the algorithm first finds a whitening matrix W ∈ RV×K with orthonormal columns such that W>M2W = IK×K . In practice, this step can be completed by performing a truncated SVD on M2, M2 = UKΣKVK , and set Wik = Uik/ √ Σkk. Afterwards, tensor CP decomposition is performed on the whitened third order moment M3(W,W,W) 7 to obtain a set of eigenvectors {vk}Kk=1. The topic vectors {µk}Kk=1 can be subsequently obtained by multiplying {vk}Kk=1 with the pseudoinverse of W. Note 7For a tensor T ∈ RV×V×V and a matrix W ∈ RV×k , the product Q = T(W,W,W) ∈ Rk×k×k is defined as Qi1,i2,i3 =∑V j1,j2,j3=1 Tj1,j2,j3Wj1,i1Wj2,i2Wj3,i3 .\nthat Eq. (21,22,23) are defined in exact word moments. In practice we use empirical moments (e.g., word frequency vector and co-occurrence matrix) to approximate these exact moments.\nD.2 Fast spectral LDA To further accelerate the spectral method mentioned in the previous section, it helps to first identify computational bottlenecks of spectral LDA. In general, the computation of M̂1, M̂2 and the whitening step are not the computational bottleneck when V is not too large and each document is not too long. The bottleneck comes from the computation of (the sketch of) M̂3(W,W,W) and its tensor decomposition. By Eq. (23), the computation of M̂3(W,W,W) reduces to computing M̂⊗31 (W,W,W), Ê[x1 ⊗ x2 ⊗ M̂1](W,W,W), 8 and Ê[x1 ⊗ x2 ⊗ x3](W,W,W). The first term M̂⊗31 (W,W,W) poses no particular challenge as it can be written as (W>M̂1)⊗3. Its sketch can then be efficiently obtained by applying techniques in Section 3.2. In the remainder of this section we focus on efficient computation of the sketch of the other two terms mentioned above.\nWe first show how to efficiently sketching Ê[x1 ⊗ x2 ⊗ x3](W,W,W) given the whitening matrix W and D training documents. Let TÊ[x1 ⊗ x2 ⊗ x3](W,W,W) denote the whitened k × k × k tensor to be sketched and write T = ∑D d=1 Td, where Td is the contribution of the dth training document to T. By definition, Td can be expressed as Td = Nd(W,W,W), where W is the V × k whitening matrix and Nd is the V × V × V empirical moment tensor computed on the dth document. More specifically, for i, j, k ∈ {1, · · · , V } we have\nNd,ijk = 1\nmd(md − 1)(md − 2)  ndi(ndj − 1)(ndk − 2), i = j = k; ndi(ndi − 1)ndk, i = j, j 6= k; ndindj(ndj − 1) j = k, i 6= j; ndi(ndi − 1)ndj , i = k, i 6= j; ndindjndk, otherwise.\nHere md is the length (i.e., number of words) of document d and nd ∈ RV is the corresponding word count vector. Previous straightforward implementation require at least O(k3 + mdk2) operations per document to build the tensor T and O(k4LT ) to decompose it [29, 28], which is prohibitively slow for real-world applications. In section 3 we discussed how to decompose a tensor efficiently once we have its sketch. We now show how to build the sketch of T efficiently from document word counts {nd}Dd=1.\nBy definition, Td can be decomposed as\nTd = p ⊗3 − V∑ i=1 ni(wi ⊗wi ⊗ p+wi ⊗ p⊗wi+p⊗wi ⊗wi) + V∑ i=1 2niw ⊗3 i , (26)\nwhere p = Wn and wi ∈ Rk is the ith row of the whitening matrix W. A direct implementation is to sketch each of the low-rank components in Eq. (26) and compute their sum. Since there are O(md) tensors, building the sketch of Td requires O(md) FFTs, which is unsatisfactory. However, note that {wi}Vi=1 are fixed and shared across documents. So when scanning the documents we maintain the sum of ni and nip and add the incremental after all documents are scanned. In this way, we only need O(1) FFT per document with an additional O(V ) FFTs. Since the total number of documents D is usually much larger than V , this provides significant speed-ups over the naive method that sketches each term in Eq. (26) independently. As a result, the sketch of T can be computed in O(k( ∑ dmd) + (D+ V )b log b) operations, which is much more\nefficient than the O(k2( ∑ dmd) +Dk\n3) brute-force computation. We next turn to the term Ê[x1 ⊗ x2 ⊗ M̂1](W,W,W). Fix a document d and let p = Wnd. Define\nq = WM̂1. By definition, the whitened empirical moment can be decomposed as\nÊ[x1 ⊗ x2 ⊗ M̂1](W,W,W) = V∑ i=1 nip⊗ p⊗ q, (27)\n8and also Ê[x1 ⊗ M̂1 ⊗ x2](W,W,W), Ê[M̂1 ⊗ x1 ⊗ x2](W,W,W) by symmetry.\nNote that Eq. (27) is very similar to Eq. (26). Consequently, we can apply the same trick (i.e., adding p and nip up before doing sketching or FFT) to compute Eq. (27) efficiently."
    }, {
      "heading" : "Appendix E Proofs",
      "text" : "E.1 Proofs of some technical propositions\nProof of Proposition 1. Fix i1, · · · , ip ∈ {1, · · · , n}. By definition, T̂i1,··· ,ip can be written as T̂i1,··· ,ip = ∑\ni′1,··· ,i′p∈[n]\nξ1(i1)ξ1(i ′ 1) · · · ξp(ip)ξp(i′p)Ti′1,··· ,i′pδ(i, i ′),\nwhere δ(i, i′) = 1 if H(i1, · · · , ip) = H(i′1, · · · , i′p) and δ(i, i ′) = 0 otherwise. Therefore, EH,ξ[T̂i1,··· ,ip ] = ∑\ni′1,··· ,i′p∈[n]\nTi′1,··· ,i′p · Eξ[ξ1(i1)ξ1(i ′ 1) · · · ξp(ip)ξp(i′p)] · Eh[δ(i, i ′)]\n= Ti1,··· ,ip . (28) Here for the last equation we used the fact that ξj , ξ′j are independent and furthermore E[ξj(i)ξj(i′)] = 1 if i = j and E[ξj(i)ξj(i′)] = 0 otherwise. Consequently, we have shown that T̂i1,··· ,ip is an unbiased estimator of the true value Ti1,··· ,ip .\nWe next turn to bound the variance of T̂i1,··· ,ip . Let i = (i1, · · · , ip), i ′ = (i′1, · · · , i′p) and i ′′ = (i′′1 , · · · , i′′p). Define ξ(i) = ξ1(i1) · · · ξp(ip). We then have\nEH,ξ[T̂2i ] = ∑\ni′,i′′∈[n]\nEξ[ξ(i′)ξ(i′′)] · EH [δ(i, i′)δ(i, i′′)] ·Ti′Ti′′\n= ∑ i′∈[n] E[δ(i, i′)] ·T2i′\n= T2i + 1\nb ∑ i′ 6=i T2i′\n≤ T2i + ‖T‖2F b .\nHere in the second equation we apply E[ξ(i′)ξ(i′′)] = δ(i′, i′′) and the third equation holds due to\nE[δ(i, i′)] = Pr H\n[H(i1, · · · , ip) = H(i′1, · · · , i′p)] = { 1, i = i′; 1/b, i 6= i′.\nConsequently,\nVH,ξ[T̂i1,··· ,ip ] ≤ ‖T‖2F b . (29)\nFinally, combining Eq. (28) and (29) and applying Chebyshev’s inequality we obtain\nPr H,ξ [∣∣T̂i1,··· ,ip −Ti1,··· ,ip ∣∣ > ] ≤ ‖T‖2Fb 2 for every > 0.\nProof of Proposition 3. We prove the proposition for the case q = 2 (i.e., H̃ is 2-wise independent). This suffices for our purpose in this paper and generalization to q > 2 cases is straightforward. For notational simplicity we omit all modulo operators. Consider two p-tuples l = (l1, · · · , lp) and l′ = (l′1, · · · , l′p) such that l 6= l′. Since H̃ is permutation invariant, we assume without loss of generality that for some s < p and 1 ≤ i ≤ s we have li = l′i. Fix t, t′ ∈ [b]. We then have\nPr[H̃(l) = t ∧ H̃(l′) = t′] = ∑ a ∑ h(l1)+···+h(ls)=a Pr[h(l1) + · · ·+ h(ls) = a]\n· ∑\nrs+1+···+rp=t−a r′s+1+···+r ′ p=t ′−a\nPr[h(ls+1) = r1 ∧ · · · ∧ h(lp) = rp ∧ h(l′s+1) = r′1 ∧ · · · ∧ h(l′p) = r′p]. (30)\nSince h is 2p-wise independent, we have Pr[h(l1) + · · ·+ h(ls) = a] = ∑\nr1+···+rs=a Pr[h(l1) = r1 ∧ · · ·h(ls) = rs] = bs−1 ·\n1 bs = 1 b ;\n∑ rs+1+···+rp=t−a r′s+1+···+r ′ p=t−a Pr[h(ls+1) = r1 ∧ · · · ∧ h(lp) = rp ∧ h(l′s+1) = r′1 ∧ · · · ∧ h(l′p) = r′p]\n= b2(p−s−1) · 1 b2(p−s) = 1 b2 .\nSumming everything up we get Pr[H̃(l) = t ∧ H̃(l′) = t′] = 1/b2, which is to be demonstrated.\nProof of Proposition 2. Since both FFT and inverse FFT preserve inner products, we have 〈sT, s1,u ∗ s2,u ∗ s3,ei〉 = 〈F(sT),F(s1,u) ◦ F(s2,u) ◦ F(s3,ei)〉\n= 〈F(sT) ◦ F(s1,u) ◦ F(s2,u),F(s3,ei)〉 = 〈F−1(F(sT) ◦ F(s1,u) ◦ F(s2,u)), s3,ei〉.\nE.2 Analysis of tensor sketch approximation error Proofs of Theorem 1 is based on the following two key lemmas, which states that 〈s̃A, s̃B̃〉 is a consistent estimator of the true inner product 〈A,B〉; furthermore, the variance of the estimator decays linearly with the hash length b. The lemmas are interesting in their own right, providing useful tools for proving approximation accuracy in a wide range of applications when colliding hash and symmetric sketches are used.\nLemma 1. Suppose A,B ∈ ⊗pRn are two symmetric real tensors and let s̃A, s̃B̃ ∈ Cb be the symmetric tensor sketches of A and B̃. That is,\ns̃A(t) = ∑\nH̃(i1,··· ,ip)=t\nσi1 · · ·σipAi1,··· ,ip ; (31)\ns̃B̃(t) = ∑\nH̃(i1,··· ,ip)=t i1≤···≤ip\nσi1 · · ·σipBi1,··· ,ip . (32)\nAssume H̃(i1, · · · , ip) = (h(i1) + · · · + h(ip)) mod b are drawn from a 2-wise independent hash family. Then the following holds:\nEh,σ [ 〈s̃A, s̃B̃〉 ] = 〈A,B〉, (33)\nVh,σ [ 〈s̃A, s̃B̃〉 ] ≤ 4 p‖A‖2F ‖B‖2F b . (34)\nLemma 2. Following notations and assumptions in Lemma 1. Let {Ai}mi=1 and {Bi}mi=1 be symmetric real n× n× n tensors and fix real vector w ∈ Rm. Then we have\nE ∑ i,j wiwj〈s̃Ai , s̃B̃j 〉  = ∑ i,j wiwj〈Ai,Bj〉; (35)\nV ∑ i,j wiwj〈s̃Ai , s̃B̃j 〉  ≤ 4p‖w‖4(maxi ‖Ai‖2F )(maxi ‖Bi‖2F ) b . (36)\nProof of Lemma 1. We first define some notations. Let l = (l1, · · · , lp) ∈ [d]p be a p-tuple denoting a multiindex. Define Al := Al1,··· ,lp and σ(l) := σl1 · · ·σlp . For l, l\n′ ∈ [n]p, define δ(l, l′) = 1 if h(l1) + · · · + h(lp) ≡ h(l′1) + · · · + h(l′p)( mod b) and δ(l, l\n′) = 0 otherwise. For a p-tuple l ∈ [n]p, let L(l) ∈ [n]p denote the p-tuple obtained by re-ordering indices in l in ascending order. Let M(l) ∈ Nb denote the “expanded version” of l. That is, [M(l)]i denote the number of occurrences of the index i in l. By definition, ‖M(l)‖1 = p. Finally, by definition B̃l′ = Bl′ if l′ = L(l′) and B̃l′ = 0 otherwise.\nEq. (33) is easy to prove. By definition and linearity of expectation we have E[〈s̃A, s̃B̃〉] = ∑ l,l′ δ(l, l′)σ(l)Alσ̄(l ′)B̃l′ . (37)\nNote that δ and σ are independent and Eσ[σ(l)σ(l′)] = {\n1, if L(l) = L(l′); 0, otherwise. (38)\nAlso δ(l, l′) = 1 with probability 1 whenever L(l) = L(l′). Note that B̃l′ = 0 whenever l′ 6= L(l′). Consequently,\nE[〈s̃A, s̃B̃〉] = ∑ l∈[n]p AlB̃L(l) = 〈A,B〉. (39)\nFor the variance, we have the following expression for E[〈s̃A, s̃B̃〉 2]:\nE[〈s̃A, s̃B̃〉 2] = ∑ l,l′,r,r′ E[δ(l, l′)δ(r, r′)] · E[σ(l)σ̄(l′)σ̄(r)σ(r′)] ·AlArB̃l′B̃r′ (40)\n=: ∑\nl,l′,r,r′\nE[t(l, l′, r, r′)]. (41)\nWe remark that E[σ(l)σ̄(l′)σ̄(r)σ(r′)] = 0 ifM(l)−M(l′) 6=M(r)−M(r′). In the remainder of the proof we will assume thatM(l)−M(l′) =M(r)−M(r′). This can be further categorized into two cases:\nCase 1: l′ = L(l) and r′ = L(r). By definition E[σ(l)σ̄(l′)σ(r)σ̄(r′)] = 1 and E[δ(l, l′)δ(r, r′)] = 1. Subsequently E[t(l, l′, r, r′)] = AlArB̃l′B̃r′ and hence∑\nl,r,l′=L(l),r′=L(r) E[t(l, l′, r, r′)] = ∑ l,r AlArBlBr = 〈A,B〉2. (42)\nCase 2: l′ 6= L(l) or r′ 6= L(r). SinceM(l)−M(l′) =M(r)−M(r′) 6= 0 we have E[δ(l, l′)δ(r, r′)] = 1/b because h is a 2-wise independent hash function. In addition, E[|σ(l)σ̄(l′)σ(r)σ̄(r′)|] ≤ 1.\nTo enumerate all (l, l′, r, r′) tuples that satisfy the colliding condition M(l) − M(l′) = M(r) − M(r′) 6= 0, we fix 9 ‖M(l) −M(l′)‖1 = 2q and fix q positions each in l and r (for l′ and r′ the positions of these indices are automatically fixed because indices in l′ and r′ must be in ascending order). Without loss of generality assume the fixed q positions for both l and r are the first q indices. The 4-tuple (l, r, l′, r′) with ‖M(l)−M(l′)‖1 = 2q can then be enumerated as follows:∑\nl,r,l′,r′\nM(l)−M(l′)=M(r)−M(r′) ‖M(l)−M(l′)‖1=2q\nt(l, l′, r, r′)\n= ∑ i∈[n]q ∑ j∈[n]q ∑ l∈[n]p−q\nr∈[n]p−q\nt(i ◦ l,L(j ◦ l), i ◦ r,L(j ◦ r))\n9Note that sum(M(l)) = sum(M(l′)) and hence ‖M(l) −M(l′)‖1 must be even. Furthermore, the sum of positive entries in (M(l)−M(l′)) equals the sum of negative entries.\n≤ 1 b ∑ i,j∈[n]q\nl,r∈[n]p−q\nAi◦lAi◦rBj◦lBj◦r\n= 1\nb ∑ i,j∈[n]q 〈A(ei1 , · · · , eiq , I, · · · , I),B(ej1 , · · · , ejq , I, · · · , I)〉2\n≤ 1 b ∑ i,j∈[n]q ‖A(ei1 , · · · , eiq , I, · · · , I)‖2F ‖B(ej1 , · · · , ejq , I, · · · , I)‖2F\n= ‖A‖2F ‖B‖2F\nb . (43)\nHere ◦ denotes concatenation, that is, i ◦ l = (i1, · · · , iq, l1, · · · , lp−q) ∈ [n]p. The fourth equation is Cauchy-Schwartz inequality. Finally note that there are no more than 4p ways of assigning q positions to l and l′ each. Combining Eq. (42) and (43) we get\nV[〈s̃A, s̃B̃〉] = E[〈s̃A, s̃B̃〉 2]− 〈A,B〉2 ≤ 4 p‖A‖2F ‖B‖2F b ,\nwhich completes the proof.\nProof of Lemma 2. Eq. (35) immediately follows Eq. (31) by adding everything together. For the variance bound we cannot use the same argument because in general the m2 random variables are neither independent nor uncorrelated. Instead, we compute the variance by definition. First we compute the expected square term as follows:\nE  ∑\ni,j\nwiwj〈s̃Ai , s̃B̃j 〉\n2 \n= ∑\ni,j,i′,j′ l,l′,r,r′\nwiwjwi′wj′ · E[δ(l, l′)δ(r, r′)] · E[σ(l)σ̄(l′)σ̄(r)σ(r′)] · [Ai]l[Ai′ ]r[B̃j ]l′ [B̃j′ ]r′ . (44)\nDefine X = ∑ i wiAi and Y = ∑ i wiBi. The above equation can then be simplified as\nE  ∑\ni,j\nwiwj〈s̃Ai , s̃B̃j 〉\n2  = ∑\nl,l′,r,r′\nE[δ(l, l′)δ(r, r′)] · E[σ(l)σ̄(l′)σ̄(r)σ(r′)] ·XlXrỸl′Ỹr′ . (45)\nApplying Lemma 1 we have\nV ∑ i,j wiwj〈s̃Ai , s̃B̃j 〉  ≤ 4p‖X‖2F ‖Y‖2F b . (46)\nFinally, note that ‖X‖2F = ∑ i,j wiwj〈Ai,Aj〉 ≤ ∑ i,j wiwj‖Ai‖F ‖Aj‖F ≤ ‖w‖2 max i ‖Ai‖2F . (47)\nWith Lemma 1 and 2, we can easily prove Theorem 1.\nProof of Theorem 1. First we prove the ε1(u) bound. Let A = T and B = u⊗3. Note that ‖A‖F = ‖T‖F and ‖B‖F = ‖u‖2 = 1. Note that [T(I,u,u)]i = T(ei,u,u). Next we consider ε2(u) and let A = T, B = ei ⊗ u ⊗ u. Again we have ‖A‖F = ‖T‖F and ‖B‖F = 1. A union bound over all i = 1, · · · , n yields the result. For the inequality involving w we apply Lemma 2.\nE.3 Analysis of fast robust tensor power method In this section, we prove Theorem 3, a more refined version of Theorem 2 in Section 4.2. We structure the section by first demonstrating the convergence behavior of noisy tensor power method, and then show how error accumulates with deflation. Finally, the overall bound is derived by combining these two parts.\nE.3.1 Recovering the principal eigenvector\nDefine the angle between two vectors v and u to be θ (v,u) . First, in Lemma 3 we show that if the initialization vector u0 is randomly chosen from the unit sphere, then the angle θ between the iteratively updated vector ut and the largest eigenvector of tensor T, v1, will decrease to a point that tan θ (v1,ut) < 1. Afterwards, in Lemma 4, we use a similar approach as in [?] to prove that the error between the final estimation and the ground truth is bounded.\nSuppose T is the exact low-rank ground truth tensor and Each noisy tensor update can then be written as ũt+1 = T(I,ut,ut) + ε̃(ut), (48)\nwhere ε̃(ut) = E(I,ut,ut) + ε2,T (ut) is the noise coming from statistical and tensor sketch approximation error.\nBefore presenting key lemmas, we first define γ-separation, a concept introduced in [1].\nDefinition 1 (γ-separation, [1]). Fix i∗ ∈ [k], u ∈ Rn and γ > 0. u is γ-separated with respect to vi∗ if the following holds:\nλi∗〈u,vi∗〉 − max i∈[k]\\{i∗} λi〈u,vi〉 ≥ γλi∗〈u,vi∗〉. (49)\nLemma 3 analyzes the first phase of the noisy tensor power algorithm. It shows that if the initialization vector u0 is γ-separated with respect to v1 and the magnitude of noise ε̃(ut) is small at each iteration t, then after a short number of iterations we will have inner product between ut and v1 at least a constant.\nLemma 3. Let {v1,v2, · · · ,vk} and {λ1, λ2, · · · , λk} be eigenvectors and eigenvalues of tensor T ∈ Rn×n×n, where λ1 |〈v1,u0〉| = max\ni∈[k] λi |〈vi,u0〉| . Denote V = (v1, · · · ,vk) ∈ Rn×k as the matrix for\neigenvectors. Suppose that for every iteration t the noise satisfies∣∣〈vi, ε̃(ut)〉∣∣ ≤ 1 ∀ i ∈ [n] and ∥∥V>ε̃(ut)∥∥ ≤ 2; (50) suppose also the initialization u0 is γ-separated with respect to v1 for some γ ∈ (0.5, 1). If tan θ (v1,u0) > 1, and\n1 ≤ min\n( 1\n4 maxi∈[k] λi\nλ1 + 2\n, 1− (1 + α)/2\n2\n) λ1 〈v1,u0〉2 and 2 ≤\n1− (1 + α)/2 2 √ 2(1 + α) λ1 |〈v1,u0〉| (51)\nfor some α > 0, then for a small constant ρ > 0, there exists a T > log1+α (1 + ρ) tan θ (v1,u0) such that after T iteration, we have tan θ (v1,uT ) < 11+ρ ,\nProof. Let ũt+1 = T (I,ut,ut) + ε̃(ut) and ut+1 = ũt+1/ ‖ũt+1‖ . For α ∈ (0, 1), we try to prove that there exists a T such that for t > T\n1\ntan θ (v1,ut+1) = |〈v1,ut+1〉|( 1− 〈v1,ut+1〉2 )1/2 = |〈v1, ũt+1〉|( n∑ i=2 〈vi, ũt+1〉2 )1/2 ≥ 1. (52)\nFirst we examine the numerator. Using the assumption ∣∣〈vi, ε̃(ut)〉∣∣ ≤ 1 and the fact that 〈vi, ũt+1〉 = λi 〈vi,ut〉2 + 〈vi, ε̃(ut)〉, we have |〈vi, ũt+1〉| ≥ λi 〈vi,ut〉2 − 1 ≥ |〈vi,ut〉| (λi |〈vi,ut〉| − 1/ |〈vi,ut〉|) . (53) For the denominator, by Hölder’s inequality we have( n∑ i=2 〈vi, ũt+1〉2 )1/2 = ( n∑ i=2 ( λi 〈vi,ut〉2 + 〈vi, ε̃(ut)〉 )1/2) (54)\n≤ ( n∑ i=2 λ2i 〈vi,ut〉 4 )1/2 + ( n∑ i=2 〈vi, ε̃(ut)〉2 )1/2\n(55)\n≤ max i 6=1 λi |〈vi,ut〉| ( n∑ i=2 〈vi,ut〉2 )1/2 + 2 (56)\n≤ ( 1− 〈v1,ut〉2 )1/2(\nmax i 6=1\nλi |〈vi,ut〉|+ 2/ ( 1− 〈v1,ut〉2 )1/2)\n(57)\nEquation (53) and (54) yield 1\ntan θ (v1,ut+1) ≥ |〈v1,ut〉|( 1− 〈v1,ut〉2 )1/2 λ1 |〈v1,ut〉| − 1/ |〈v1,ut〉|\nmax i 6=1\nλi |〈vi,ut〉|+ 2/ ( 1− 〈v1,ut〉2 )1/2 (58)\n= 1\ntan θ (v1,ut)\nλ1 |〈v1,ut〉| − 1/ |〈v1,ut〉|\nmax i 6=1\nλi |〈vi,ut〉|+ 2/ ( 1− 〈v1,ut〉2 )1/2 (59)\nTo prove that the second term is larger than 1 +α, we first show that when t = 0, the inequality holds. Since the initialization vector is a γ−separated vector, we have\nλ1 |〈v1,u0〉| −max i∈[k] λi |〈vi,u0〉| ≥ γλ1 |〈v1,u0〉| , (60)\nmax i∈[k]\nλi |〈vi,u0〉| ≤ (1− γ)λ1 |〈v1,u0〉| ≤ 0.5λ1 |〈v1,u0〉| , (61)\nthe last inequality holds since γ > 0.5. Note that we assume tan θ (v1,u0) > 1 and hence 〈v1,u0〉2 < 0.5. Therefore,\n2 ≤ 1− (1 + α)/2 2 √ 2(1 + α) λ1 |〈v1,u0〉| ≤\n( 1− 〈v1,u0〉2 )1/2 (1− (1 + α)/2)\n2(1 + α) λ1 |〈v1,u0〉| . (62)\nThus, for t = 0, using the condition for 1 and 2 we have λ1 |〈vi,u0〉| − 1/ |〈vi,u0〉|\nmax i6=1\nλi |〈vi,u0〉|+ 2/ ( 1− 〈v1,u0〉2 )1/2 ≥ λ1 |〈vi,u0〉| − 1/ |〈vi,u0〉| 0.5λ1 |〈v1,u0〉|+ 2/ ( 1− 〈v1,u0〉2 )1/2 ≥ 1 + α.\n(63)\nThe result yields 1/ tan θ (v1,u1) > (1+α)/ tan θ (v1,u0) . This also indicates that |〈v1,u1〉| > |〈v1,u0〉| , which implies that\n1 ≤ min\n( 1\n4 maxi∈[k] λi\nλ1 + 2\n, 1− (1 + α)/2\n2\n) λ1 〈v1,ut〉2 and 2 ≤\n1− (1 + α)/2 2 √ 2(1 + α) λ1 |〈v1,ut〉| (64)\nalso holds for t = 1. Next we need to make sure that for t ≥ 0 max i 6=1 λi |〈vi,ut〉| ≤ 0.5λ1 |〈v1,ut〉| . (65)\nIn other words, we need to show that λ1|〈v1,ut〉|max i6=1 λi|〈vi,ut〉| ≥ 2. From Equation (61), for t = 0, λ1|〈v1,ut〉| max i6=1 λi|〈vi,ut〉| ≥ 1 1−γ ≥ 2. For every i ∈ [k], |〈vi, ũt+1〉| ≤ λi |〈vi,ut〉|2 + 1 ≤ |〈vi,ut〉| (λi |〈vi,ut〉|+ 1/ |〈vi,ut〉|) . (66) With equation (53), we have\nλ1 |〈v1,ut+1〉| λi |〈vi,ut+1〉| = λ1 |〈v1, ũt+1〉| λi |〈vi, ũt+1〉|\n≥ λ1 |〈v1,ut〉|\n( λ1 |〈v1,ut〉| − 1|〈v1,ut〉| ) λi |〈vi,ut〉| ( λi |〈vi,ut〉| − 1|〈vi,ut〉| ) (67)\n= ( λ1 |〈v1,ut〉| λi |〈vi,ut〉| )2 1− 1 λ1〈v1,ut〉2\n1 + λiλ1 1 λ1〈v1,ut〉2 ( λ1|〈v1,ut〉| λi|〈vi,ut〉| )2 (68) ≥ ( λ1 |〈v1,ut〉| λi |〈vi,ut〉| )2 1− 1 λ1〈v1,ut〉2\n1 + max i∈[k] λi\nλ1 1 λ1〈v1,ut〉2 ( λ1|〈v1,ut〉| λi|〈vi,ut〉| )2 (69) = 1− 1 λ1〈v1,ut〉2\n1( λ1|〈v1,ut〉| λi|〈vi,ut〉| )2 + maxi∈[k] λiλ1 1λ1〈v1,ut〉2 . (70)\nLet κ = maxi∈[k] λiλ1 . For t = 0, with conditions on 1 the following holds:\nλ1 |〈v1,u1〉| λi |〈vi,u1〉| ≥ 1− 1 λ1〈v1,u0〉2\n1( λ1|〈v1,u0〉| λi|〈vi,u0〉| )2 + maxi∈[k] λiλ1 1λ1〈v1,u0〉2 . (71)\n≥ 1− 14κ+2 1 4 + κ 4κ+2 = 2 (72)\nWith the two conditions stated in Equation (64), following the same step in (63), we have 1tan θ(v1,u2) ≥ (1 + α) 1tan θ(v1,u1) . By induction, 1 tan θ(v1,ut+1)\n≥ (1 + α) 1tan θ(v1,t) . for t ≥ 0. Subsequently, 1\ntan θ (v1, uT ) ≥ (1 + α)T 1 tan θ (v1,u0) . (73)\nFinally, we complete the proof by setting T > log1+α (1 + ρ) tan θ (v1,u0).\nNext, we present Lemma 4, which analyzes the second phase of the noisy tensor power method. The second phase starts with tan θ(v1,u0) < 1, that is, the inner product of v1 and u0 is lower bounded by 1/2.\nLemma 4. Let v1 be the principal eigenvector of a tensor T and let u0 be an arbitrary vector in Rd that satisfies tan θ(v1,u0) < 1. Suppose at every iteration t the noise satisfies\n4‖ε̃(ut)‖ ≤ (λ1 − λ2) and 4 ∣∣〈v1, ε̃(ut)〉∣∣ ≤ (λ1 − λ2) cos2 θ (v1,u0) (74)\nfor some < 1. Then with high probability there exists T = O (\nλ1 λ1−λ2 log(1/ )\n) such that after T iteration\nwe have tan θ (v1,uT ) ≤ .\nProof. Define ∆ := λ1−λ24 and X := v ⊥ 1 . We have the following chain of inequalities: tan θ (v1,T (I,u,u) + ε̃(u)) ≤ ∥∥XT (T (I,u,u) + ε̃(u))∥∥∥∥vT1 (T (I,u,u) + ε̃(u))∥∥ (75)\n≤ ∥∥XTT (I,u,u)∥∥+ ∥∥VT ε̃(u)∥∥∥∥vT1 T (I,u,u)∥∥− ∥∥vT1 ε̃(u)∥∥ (76)\n≤ λ2 ∥∥XTu∥∥2 + ‖ε̃(u)‖\nλ1 ∣∣vT1 u∣∣2 − ∣∣v>1 ε̃(u)∣∣ (77)\n= ∥∥XTu∥∥2∣∣vT1 u∣∣2 λ2\nλ1 − |v>1 ε̃(u)| |v>1 u|2\n+\n‖ε̃(u)‖ |v>1 u|2 λ1 − ∣∣v>1 ε̃(u)∣∣ |v>1 u|2\n(78)\n≤ tan2 θ(v1,u) λ2\nλ2 + 3∆ +\n∆ ( 1 + tan2 θ (v1,u) ) λ2 + 3∆\n(79)\n≤ max ( , λ2 + ∆\nλ2 + 2∆ tan2 θ (v1,u)\n) (80)\n≤ max ( , λ2 + ∆\nλ2 + 2∆ tan θ (v1,u)\n) (81)\nThe second step follows by triangle inequality. For u = u0, using the condition tan (v1,u0) < 1 we obtain tan θ (v1,u1) ≤ max ( , λ2 + ∆\nλ2 + 2∆ tan2 θ (v1,u)\n) ≤ max ( , λ2 + ∆\nλ2 + 2∆ tan θ (v1,u)\n) (82)\nSince λ2+∆ λ2+2∆ ≤ max ( λ2 λ2+∆ , ) ≤ (λ2/λ1)1/4 < 1, we have\ntan θ (v1,u1) = tan θ (v1,T (I,u0,u0) + ε̃(ut)) ≤ max ( , (λ2/λ1) 1/4 tan θ (v1,u0) ) < 1. (83)\nBy induction, tan θ (v1,ut+1) = tan θ (v1,T (I,ut,ut) + ε̃(ut)) ≤ max ( , (λ2/λ1) 1/4 tan θ (v1,ut) ) < 1.\nfor every t. Eq. (81) then yields tan θ (v1,uT ) ≤ max ( ,max , (λ2/λ1) L/4 tan θ (v1,u0) ) . (84)\nConsequently, after T = log(λ2/λ1)−1/4(1/ ) iterations we have tan θ (v1,uT ) ≤ .\nLemma 5. Suppose v1 is the principal eigenvector of a tensor T and let u0 ∈ Rn. For some α, ρ > 0 and < 1, if at every step, the noise satisfies\n‖ε̃(ut)‖ ≤ λ1 − λ2\n4 and ∣∣〈v1, ε̃(ut)〉∣∣ ≤ min( 1 4\nmaxi∈[k] λi λ1\n+ 2 λ1, 1− (1 + α)/2 2 √ 2(1 + α) λ1\n) 1\nτ2n , (85)\nthen with high probability there exists an T = O (\nlog1+α (1 + ρ) τ √ n+ λ1λ1−λ2 log(1/ )\n) such that after T\niterations we have ∥∥(I − uTuTT )v1∥∥ ≤ .\nProof. By Lemma 2.5 in [?], for any fixed orthonormal matrix V and a random vectoru, we have maxi∈[K] tan θ(vi,u) ≤ τ √ n with all butO(τ−1 +e−Ω(d)) probability. Using the fact that cos θ (v1,u0) ≥ 1/(1+tan θ (v1,u0)) ≥\n1 τ √ n , the following bounds on the noise level imply the conditions in Lemma 3:∥∥VT ε̃(ut)∥∥ ≤ 1− (1 + α)/2\n2 √ 2(1 + α)τ √ n and ∣∣〈v1, ε̃(ut)〉∣∣ ≤ min ( 1\n4 maxi∈[k] λi\nλ1 + 2\nλ1, 1− (1 + α)/2\n2 λ1\n) 1\nτ2n , ∀t.\nNote that ∣∣〈v1, ε̃(ut)〉∣∣ ≤ 1−(1+α)/22√2(1+α) λ1 1τ2n implies the first bound in Eq. (86). In Lemma 4, we assume tan θ (v1,u0) < 1 and prove that for every ut, tan θ (v1,ut) < 1, which is equivalent to saying that at every step, cos θ (v1,ut) > 1√2 . By plugging the inequality into the second condition in Lemma 4, we have\n|〈v1, ε̃(ut)〉| ≤ (λ1−λ2)8 . The lemma then follows by the fact that ∥∥(I − uTuT T )v1∥∥ = sin θ (uT ,v1) ≤ tan θ (uT ,v1) ≤ .\nE.3.2 Deflation\nIn previous sections we have upper bounded the Euclidean distance between the estimated and the true principal eigenvector of an input tensor T. In this section, we show that error introduced from previous tensor power updates can also be bounded. As a result, we obtain error bounds between the entire set of base vectors {vi}ki=1 and their estimation {v̂i}ki=1.\nLemma 6. Let {v1,v2, · · · ,vk} and {λ1, λ2, · · · , λk} be orthonormal eigenvectors and eigenvalues of an input tensor T . Define λmax := maxi∈[k] λi. Suppose {v̂i}ki=1 and {λ̂i}ki=1 are estimated eigenvector/eigenvalue pairs. Fix ≥ 0 and any t ∈ [k]. If∣∣λ̂i − λi∣∣ ≤ λi /2, and ‖ûi − ui‖ ≤ (86) for all i ∈ [t], then for any unit vector u the following holds:∥∥∥∥∥ t∑ i=1 [ λv⊗3i − λ̂iv̂ ⊗3 i ] (I,u,u) ∥∥∥∥∥ 2 ≤4 (2.5λmax + (λmax + 1.5) )2 2 + 9(1 + /2)2λ2max 4 (87)\n+ 8(1 + /2)2λ2max 2 (88) ≤50λ2max 2. (89)\nProof. Following similar approaches in [1], Lemma B.5, we define v̂⊥ = v̂i − (v>i v̂i)vi and Di =[ λv⊗3i − λ̂iv̂ ⊗3 i ] . Di(I,u,u) can then be written as the sum of scaled vi and v>i products as follows:\nDi (I,u,u) =λi(u >vi) 2vi − λ̂i(u>v̂i)2v̂i (90)\n=λi(u >vi) 2vi − λ̂i(u> ( v̂⊥i + (v > i v̂i)vi ) )2 ( v̂⊥ + (v>i v̂i)vi ) (91)\n= (( λi − λ̂i(v>i v̂i)3 ) (u>vi) 2 − 2λ̂i(u>v̂⊥i )(v>i v̂i)2(u>vi)− λ̂i(v>i v̂i)(u>v̂ ⊥) ) vi\n− λ̂i ∥∥∥v̂⊥i ∥∥∥((u>vi)(v>i v̂i) + u>v̂⊥i )(v̂⊥i /∥∥∥v̂⊥i ∥∥∥) (92)\nSuppose Ai and Bi are coefficients of vi and ( v̂⊥i / ∥∥∥v̂⊥i ∥∥∥), respectively. The summation of Di can be bounded as ∥∥∥∥∥ t∑ i=1 Di (I,u,u) ∥∥∥∥∥ 2 = ∥∥∥∥∥ t∑ i=1 Aivi − t∑ i=1 Bi ( v̂⊥i / ∥∥∥v̂⊥i ∥∥∥) ∥∥∥∥∥ 2\n2\n≤2 ∥∥∥∥∥ t∑ i=1 Aivi ∥∥∥∥∥ 2 + 2 ∥∥∥∥∥ t∑ i=1 Bi ( v̂⊥i / ∥∥∥v̂⊥i ∥∥∥) ∥∥∥∥∥ 2 ≤ t∑ i=1 A2i + 2 ( t∑ i=1 |Bi|\n)2 We then try to upper bound |Ai|.\n|Ai| ≤ ∣∣∣(λi − λ̂i(v>i v̂i)3) (u>vi)2 − 2λ̂i(u>v̂⊥i )(v>i v̂i)2(u>vi)− λ̂i(v>i v̂i)(u>v̂⊥)∣∣∣ (93) ≤ ( λi ∣∣1− (v>i v̂i)3∣∣+ ∣∣∣λi − λ̂i∣∣∣ (v>i v̂i)3) (u>vi)2 + 2(λi + ∣∣∣λi − λ̂i∣∣∣) ‖v̂i − vi‖ ∣∣u>vi∣∣\n+ ( λi + ∣∣∣λi − λ̂i∣∣∣) ‖v̂i − vi‖2 (94) ≤ ( 1.5 ‖vi − v̂i‖2 + ∣∣∣λi − λ̂i∣∣∣+ 2(λi + ∣∣∣λi − λ̂i∣∣∣) ‖vi − v̂i‖) ∣∣u>vi∣∣\n+ ( λi + ∣∣∣λi − λ̂i∣∣∣) ‖v̂i − vi‖2 (95) ≤ (2.5λi + (λi + 1.5) )\n∣∣u>vi∣∣+ (1 + /2)λi 2 (96) Next, we bound |Bi| in a similar manner.\n|Bi| = ∣∣∣λ̂i ∥∥∥v̂⊥i ∥∥∥((u>vi)(v>i v̂i) + u>v̂⊥i )∣∣∣ (97) ≤2 ( λi + ∣∣∣λi − λ̂i∣∣∣) ∥∥∥v̂⊥i ∥∥∥((u>vi)2 + ∥∥∥v̂⊥i ∥∥∥2) (98)\n≤2(1 + /2)λi (u>vi)2 + 2(1 + /2)λi 3 (99)\nCombining everything together we have∥∥∥∥∥ t∑ i=1 Di (I,u,u) ∥∥∥∥∥ 2 ≤2 t∑ i=1 A2i + 2 ( t∑ i=1 |Bi| )2 (100)\n≤ t∑ i=1 4 (5λi + (λi + 1.5)) 2 2 ∣∣u>vi∣∣2 + 4(1 + /2)2λ2i 4\n+ 2 ( t∑ i=1 2(1 + /2)λi (u >vi) 2 + 2(1 + /2)λi 3 )2 (101)\n≤4 (2.5λmax + (λmax + 1.5) )2 2 t∑ i=1 ∣∣u>vi∣∣2 + 4(1 + /2)2λ2max 4 + 2 ( 2(1 + /2)λmax\nt∑ i=1 (u>vi) 2 + 2(1 + /2)λmax 3\n)2 (102)\n≤4 (2.5λmax + (λmax + 1.5) )2 2 + 9(1 + /2)2λ2max 4 + 8(1 + /2)2λ2max 2. (103)\nE.3.3 Main Theorem\nIn this section we present and prove the main theorem that bounds the reconstruction error of fast robust tensor power method under appropriate settings of the hash length b and number of independent hashes B. The theorem presented below is a more detailed version of Theorem 2 presented in Section 4.2.\nTheorem 3. Let T̄ = T + E ∈ Rn×n×n, where T = ∑k i=1 λiv ⊗3 i and {vi}ki=1 is an orthonormal basis. Suppose (v̂1, λ̂1), (v̂1, λ̂1), · · · (v̂k, λ̂k) is the sequence of estimated eigenvector/eigenvalue pairs obtained using the fast robust tensor power method. Assume ‖E‖ = . There exists constant C1, C2, C3, α, ρ, τ ≥ 0 such that the following holds: if\n≤ C1 1\nnλmax , and T = C2\n( log1+α (1 + ρ) τ √ n+\nλ1 λ1 − λ2 log(1/ )\n) , (104)\nand√ ln(L/ log2(k/η))\nln(k) ·\n( 1− ln (lnL/ log2(k/η)) + C3\n4 ln (L/ log2(k/η)) −\n√ ln(8)\nln(L/ log2(k/η))\n) ≥ 1.02 ( 1 + √ ln(4)\nln(k)\n) .\n(105)\nSuppose the tensor sketch randomness is independent among all tensor product evaluations. IfB = Ω(log(n/τ)) and the hash length b is set to\nb ≥  ‖T‖ 2 F τ 4n2 min (\n1 4 maxi∈[k](λi/λ1)+2 λ1, 1−(1+α)/2 2 √ 2(1+α) λ1\n)2 , 16 −2‖T‖2Fmini∈[k] (λi − λi−1)2 , −2 ‖T‖2F  (106)\nwith probability at least 1− (η + τ−1 + e−n), there exists a permutation π on k such that∥∥vπ(j) − v̂i∥∥ ≤ , ∣∣∣λπ(j) − λ̂j∣∣∣ ≤ λπ(j) 2 , and ∥∥∥∥∥∥T− k∑ j=1 λ̂j v̂ ⊗3 j ∥∥∥∥∥∥ ≤ c , (107) for some absolute constant c.\nProof. We prove that at the end of each iteration i ∈ [k], the following conditions hold • 1. For all j ≤ i, ∣∣vπ(j) − v̂j∣∣ ≤ and ∣∣∣λπ(j) − λ̂j∣∣∣ ≤ λi 2\n• 2. The tensor error satisfies∥∥∥∥∥∥ T̃−∑\nj≤i\nλ̂j v̂ ⊗3 j − ∑ j≥i+1 λπ(j)v ⊗3 π(j)  (I,u,u) ∥∥∥∥∥∥ ≤ 56 (108)\nFirst, we check the case when i = 0. For the tensor error, we have∥∥∥∥∥∥ T̃− K∑\nj=1\nλπ(j)v ⊗3 π(j)  (I,u,u) ∥∥∥∥∥∥ = ‖ε(u)‖ ≤ ‖ε2,T (u)‖+ ‖E (I,u,u)‖ ≤ + = 2 . (109)\nThe last inequality follows Theorem 1 with the condition for b. Next, Using Lemma 5, we have that∥∥vπ(1) − v̂1∥∥ ≤ . (110) In addition, conditions for hash length b and Theorem 1 yield∣∣∣λπ(1) − λ̂1∣∣∣ ≤ ‖ε1,T (v1)‖+ ‖T(v̂1 − v1, v̂1 − u, v̂1 − v1)‖ ≤ λi − λi−1\n4 + 3 ‖T‖F ≤ λi 2 (111)\nThus, we have proved that for i = 1 both conditions hold. Assume the conditions hold up to i = t − 1 by induction. For the tth iteration, the following holds:∥∥∥∥∥∥ T̃−∑ j≤t λ̂j v̂ ⊗3 j − ∑ j≥t+1 λπ(j)v ⊗3 π(j)  (I,u,u) ∥∥∥∥∥∥\n≤ ∥∥∥∥∥∥ T̃− K∑\nj=1\nλπ(j)v ⊗3 π(j)  (I,u,u) ∥∥∥∥∥∥+ ∥∥∥∥∥∥ t∑\nj=1\nλ̂j v̂ ⊗3 j − λπ(j)v⊗3π(j) ∥∥∥∥∥∥ ≤ +√50λmax . For the last inequality we apply Lemma 6. Since the condition is satisfied, Lemma 5 yields∥∥vπ(t+1) − v̂t+1∥∥ ≤ . (112) Finally, conditions for hash length b and Theorem 1 yield∣∣∣λπ(t+1) − λ̂t+1∣∣∣ ≤ ‖ε1,T (v1)‖+ ‖T(v̂t − v1, v̂1 − u, v̂1 − v1)‖\n≤ λi − λi−1 4 + 3 ‖T‖F ≤ λi 2 (113)"
    }, {
      "heading" : "Appendix F Summary of notations for matrix/vector products",
      "text" : "We assume vectors a, b ∈ Cn are indexed starting from 0; that is, a = (a0, a1, · · · , an−1) and b = (b0, b1, · · · , bn−1). Matrices A,B and tensors T are still indexed starting from 1.\nElement-wise product For a, b ∈ Cn, the element-wise product (Hadamard product) a◦b ∈ Rn is defined as\na ◦ b = (a0b0, a1b1, · · · , an−1bn−1). (114)\nConvolution For a, b ∈ Cn, their convolution a ∗ b ∈ Cn is defined as\na ∗ b =  ∑ (i+j) mod n=0 aibj , ∑ (i+j) mod n=1 aibj , · · · , ∑ (i+j) mod n=n−1 aibj  . (115)\nInner product For a, b ∈ Cn, their inner product is defined as\n〈a, b〉 = n∑ i=1 aibi, (116)\nwhere bi denotes the complex conjugate of bi. For tensors A,B ∈ Cn×n×n, their inner product is defined similarly as\n〈A,B〉 = n∑\ni,j,k=1\nAi,j,kBi,j,k. (117)\nTensor product For a, b ∈ Cn, the tensor product a⊗b can be either an n×n matrix or a vector of length n2. For the former case, we have\na⊗ b =  a0b0 a0b1 · · · a0bn−1 a1b0 a1b1 · · · a1bn−1 ... ... . . . ...\nan−1b0 an−1b1 · · · an−1bn−1  . (118) If a⊗ b is a vector, it is defined as the expansion of the output matrix. That is,\na⊗ b = (a0b0, a0b1, · · · , a0bn−1, a1b0, a1b1, · · · , an−1bn−1). (119) Suppose T is an n× n× n tensor and matrices A ∈ Rn×m1 , B ∈ Rn×m2 and C ∈ Rn×m3 . The tensor\nproduct T(A,B,C) is an m1 ×m2 ×m3 tensor defined by\n[T(A,B,C)]i,j,k = n∑ i′,j′,k′=1 Ti′,j′,k′Ai′,iBj′,jCk′,k. (120)\nKhatri-Rao product For A,B ∈ Cn×m, their Khatri-Rao product A B ∈ Cn2×m is defined as A B = (A(1) ⊗B(1),A(2) ⊗B(2), · · · ,A(m) ⊗B(m)), (121)\nwhere A(i) and B(i) denote the ith rows of A and B.\nMode expansion For a tensor T of dimension n× n× n, its first mode expansion T(1) ∈ Rn×n is defined as\nT(1) =  T1,1,1 T1,1,2 · · · T1,1,n T1,2,1 · · · T1,n,n T2,1,1 T2,1,2 · · · T2,1,n T2,2,1 · · · T2,n,n ... ... ... ... ... ...\n... Tn,1,1 Tn,1,2 · · · Tn,1,n Tn,2,1 · · · Tn,n,n  . (122) The mode expansions T(2) and T(3) can be similarly defined."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : "<lb>Tensor CANDECOMP/PARAFAC (CP) decomposition has wide applications in statistical learning of<lb>latent variable models and in data mining. In this paper, we propose fast and randomized tensor CP de-<lb>composition algorithms based on sketching. We build on the idea of count sketches, but introduce many<lb>novel ideas which are unique to tensors. We develop novel methods for randomized computation of tensor<lb>contractions via FFTs, without explicitly forming the tensors. Such tensor contractions are encountered in<lb>decomposition methods such as tensor power iterations and alternating least squares. We also design novel<lb>colliding hashes for symmetric tensors to further save time in computing the sketches. We then combine<lb>these sketching ideas with existing whitening and tensor power iterative techniques to obtain the fastest al-<lb>gorithm on both sparse and dense tensors. The quality of approximation under our method does not depend<lb>on properties such as sparsity, uniformity of elements, etc. We apply the method for topic modeling and<lb>obtain competitive results.<lb>",
    "creator" : "LaTeX with hyperref package"
  }
}