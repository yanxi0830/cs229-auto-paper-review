{
  "name" : "1005.2243.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Huan Xu", "Shie Mannor" ],
    "emails" : [ "huan.xu@mail.utexas.edu", "shie@technion.ee.ac.il" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n00 5.\n22 43\nv1 [\ncs .L\nG ]\n1 3\nWe derive generalization bounds for learning algorithms based on their robustness: the property that if a testing sample is “similar” to a training sample, then the testing error is close to the training error. This provides a novel approach, different from the complexity or stability arguments, to study generalization of learning algorithms. We further show that a weak notion of robustness is both sufficient and necessary for generalizability, which implies that robustness is a fundamental property for learning algorithms to work."
    }, {
      "heading" : "1. Introduction",
      "text" : "The key issue in the task of learning from a set of observed samples is the estimation of the risk (i.e., generalization error) of learning algorithms. Typically, its empirical measurement (i.e., training error) provides an optimistically biased estimation, especially when the number of training samples is small. Several approaches have been proposed to bound the deviation of the risk from its empirical measurement, among which methods based on uniform convergence and stability are most widely used.\nUniform convergence of empirical quantities to their mean (e.g., Vapnik and Chervonenkis,\n1974, 1991) provides ways to bound the gap between the expected risk and the empirical risk by the complexity of the hypothesis set. Examples to complexity measures are the VapnikChervonenkis (VC) dimension (e.g., Vapnik and Chervonenkis, 1991; Evgeniou et al., 2000), the fat-shattering dimension (e.g., Alon et al., 1997; Bartlett, 1998), and the Rademacher complexity (Bartlett and Mendelson, 2002; Bartlett et al., 2005). Another well-known approach is based on stability. An algorithm is stable if its output remains “similar” for different sets of training samples that are identical up to removal or change of a single sample. The first results that relate stability to generalizability track back to Devroye and Wagner (1979a) and Devroye and Wagner (1979b). Later, McDiarmid’s (McDiarmid, 1989), concentration inequalities facilitated new bounds on generalization error (e.g., Bousquet and Elisseeff, 2002; Poggio et al., 2004; Mukherjee et al., 2006).\nIn this paper we explore a different approach which we term algorithmic robustness. Briefly speaking, an algorithm is robust if its solution has the following property: it achieves “similar” performance on a testing sample and a training sample that are “close”. This notion of robustness is rooted in robust optimization (Ben-tal and Nemirovski, 1998; Ben-Tal and Nemirovski, 1999; Bertsimas and Sim, 2004) where a decision maker aims to find a solution x that minimizes a (parameterized) cost function f(x, ξ) with the knowledge that the unknown true parameter ξ may deviate from the observed parameter ξ̂. Hence, instead of solving minx f(x, ξ̂) one solves minx[maxξ̃∈∆ f(x, ξ̃)], where ∆ includes all possible realizations of ξ. Robust optimization was introduced in machine learning tasks to handle exogenous noise (e.g., Bhattacharyya et al., 2004; Shivaswamy et al., 2006; Globerson and Roweis, 2006), i.e., the learning algorithm only has access to inaccurate observation of training samples. Later on, Xu et al. (2009b,a) showed that both Support Vector Machine(SVM) and Lasso have robust optimization interpretation, i.e., they can be reformulated as\nmin h∈H max (δ1,··· ,δn)∈∆\nn ∑\ni=1\nl(h, zi + δi),\nfor some ∆. Here zi are the observed training samples and l(·, ·) is the loss function (hingeloss for SVM, and squared loss for Lasso), which means that SVM and Lasso essentially minimize the empirical error under the worst possible perturbation. Indeed, as the authors of Xu et al. (2009b,a) showed, this reformulation leads to requiring that the loss of a sample “close” to zi is small, which further implies statistical consistency of these two algorithms. In this paper we adopt this approach and study the (finite sample) generalization ability of learning algorithms by investigating the loss of learned hypotheses on samples that slightly deviate from training samples.\nOf special interest is that robustness is more than just another way to establish generalization bounds. Indeed, we show that a weaker notion of robustness is a necessary and sufficient condition of (asymptotic) generalizability of (general) learning algorithms. While it is known having a finite VC-dimension (Vapnik and Chervonenkis, 1991) or equivalently being CVEEEloo stable (Mukherjee et al., 2006) is necessary and sufficient for the Empirical Risk Minimization (ERM) to generalize, much less is known in the general case. Recently, Shalev-Shwartz et al. (2009) proposed a weaker notion of stability that is necessary and sufficient for a learning algorithm to be consistent and generalizing, provided that the problem itself is learnable. However, learnability requires that the convergence rate is uniform with respect to all distributions, and is hence a fairly strong assumption. In particular, the standard supervised learning setup where the hypothesis set is the set of measurable functions is not learnable since no algorithm can achieve a uniform convergence rate (cf Devroye et al., 1996). Indeed, as the authors of Shalev-Shwartz et al. (2009) stated, for supervised learning problem learnability is equivalent to the generalizability of ERM, and hence reduce to the aforementioned results on ERM algorithms.\nIn particular, our main contributions are the following:\n1. We propose a notion of algorithmic robustness. Algorithmic robustness is a desired\nproperty for a learning algorithm since it implies a lack of sensitivity to (small) disturbances in the training data.\n2. Based on the notion of algorithmic robustness, we derive generalization bound for IID\nsamples as well as samples drawn according to a Markovian chain.\n3. To illustrate the applicability of the notion of algorithmic robustness, we provide some\nexamples of robust algorithms, including SVM, Lasso, feed-forward neural networks and PCA.\n4. We propose a weaker notion of robustness and show that it is both necessary and\nsufficient for a learning algorithm to generalize. This implies that robustness is an essential property needed for a learning algorithm to work.\nNote that while stability and robustness are similar on an intuitive level, there is a difference between the two: stability requires that nearly identical training sets with a single sample removed lead to similar prediction rules, whereas robustness requires that a prediction rule has comparable performance if tested on a sample close to a training sample.\nThis paper is organized as follows. We define the notion of robustness in Section 2, and prove generalization bounds for robust algorithms in Section 3. In Section 4 we propose a relaxed notion of robustness, which is termed as pseudo-robustness, and show corresponding generalization bounds. Examples of learning algorithms that are robust or pseudo-robust are provided in Section 5. Finally, we show that robustness is necessary and sufficient for generalizability in Section 6."
    }, {
      "heading" : "1.1 Preliminaries",
      "text" : "We consider the following general learning model: a set of training samples are given, and the goal is to pick a hypothesis from a hypothesis set. Unless otherwise mentioned, throughout this paper the size of training set is fixed as n. Therefore, we drop the dependence of parameters on the number of training samples, while it should be understood that parameters may vary with the number of training samples. We use Z and H to denote the set from which each sample is drawn, and the hypothesis set, respectively. Throughout the paper we use s to denote the training sample set consists of n training samples (s1, · · · , sn). A learning algorithm A is thus a mapping from Zn to H. We use As to represent the hypothesis learned (given training set s). For each hypothesis h ∈ H and a point z ∈ Z, there is an associated loss l(h, z). We ignore the issue of measurability and further assume that l(h, z) is non-negative and upper-bounded uniformly by a scalar M .\nIn the special case of supervised learning, the sample space can be decomposed as Z = Y × X , and the goal is to learn a mapping from X to Y, i.e., to predict the ycomponent given x-component. We hence use As(x) to represent the prediction of x ∈ X if trained on s. We call X the input space and Y the output space. The output space can\neither be Y = {−1,+1} for a classification problem, or Y = R for a regression problem. We use |x and |y to denote the x-component and y-component of a point. For example, si|x is the x-component of si. To simplify notations, for a scaler c, we use [c] + to represent its non-negative part, i.e., [c]+ , max(0, c).\nWe recall the following standard notion of covering number from van der Vaart and Wellner\n(2000).\nDefinition 1 (cf. van der Vaart and Wellner (2000)) For a metric space S, ρ and T ⊂ S we say that T̂ ⊂ S is an ǫ-cover of T , if ∀t ∈ T , ∃t̂ ∈ T̂ such that ρ(t, t̂) ≤ ǫ. The ǫcovering number of T is\nN (ǫ, T, ρ) = min{|T̂ | : T̂ is an ǫ− cover of T}."
    }, {
      "heading" : "2. Robustness of Learning Algorithms",
      "text" : "Before providing a precise definition of what we mean by “robustness” of an algorithm, we provide some motivating examples which share a common property: if a testing sample is close to a training sample, then the testing error is also close, a property we will later formalize as “robustness”.\nWe first consider large-margin classifiers: Let the loss function be l(As, z) = 1(As(z|x) 6=\nz|y). Fix γ > 0. An algorithm As has a margin γ if for j = 1, · · · , n\nAs(x) = As(sj|x); ∀x : ‖x− sj|x‖2 < γ.\nThat is, any training sample is at least γ away from the classification boundary.\nExample 1 Fix γ > 0 and put K = 2N (γ/2,X , ‖ · ‖2). If As has a margin γ, then Z can be partitioned into K disjoint sets, denoted by {Ci} K i=1, such that if sj and z ∈ Z belong to a same Ci, then |l(As, sj)− l(As, z)| = 0.\nProof By definition of covering number, we can partition X into N (γ/2,X , ‖ · ‖2) subsets (denoted X̂i) such that each subset has a diameter less or equal to γ. Further, Y can be partitioned to {−1} and {+1}. Thus, we can partition Z into 2N (γ/2,X , ‖ · ‖2) subsets such that if z1, z2 belong to a same subset, then y1|y = y2|y and ‖x1|y − x2|y‖ ≤ γ. By definition of margin, this guarantees that if sj and z ∈ Z belong to a same Ci, then |l(As, sj)− l(As, z)| = 0.\nThe next example is a linear regression algorithm. Let the loss function be l(As, z) = |z|y −As(z|x)|, and let X be a bounded subset of R m and fix c > 0. The norm-constrained linear regression algorithm is\nAs = min w∈Rm:‖w‖2≤c\nn ∑\ni=1\n|si|y − w ⊤si|x|, (1)\ni.e., minimizing the empirical error among all linear classifiers whose norm is bounded.\nExample 2 Fix ǫ > 0 and put K = N (ǫ/2,X , ‖·‖2)×N (ǫ/2,Y, |·|). Consider the algorithm as in (1). The set Z can be partitioned into K disjoint sets, such that if sj and z ∈ Z belong to a same Ci, then\n|l(As, sj)− l(As, z)| ≤ (c+ 1)ǫ.\nProof Similarly to the previous example, we can partition Z toN (ǫ/2,X , ‖·‖2)×N (ǫ/2,Y, |· |) subsets, such that if z1, z2 belong to a same Ci, then ‖z1|x−z2|x‖2 ≤ ǫ, and |z1|y−z2|y| ≤ ǫ. Since ‖w‖2 ≤ c, we have\n|l(w, z1)− l(w(s), z2)| = ∣ ∣ ∣ |z1|y − w ⊤z1|x| − |z2|y − w ⊤z2|x| ∣ ∣ ∣\n≤ ∣ ∣\n∣ (z1|y − w ⊤z1|x)− (z2|y − w ⊤z2|x)\n∣ ∣ ∣\n≤|z1|y − z2|y|+ ‖w‖2‖z1|x − z2|x‖2\n≤(1 + c)ǫ,\nwhenever z1, z2 belong to a same Ci.\nThe two motivating examples both share a property: we can partition the sample set into finite subsets, such that if a new sample falls into the same subset as a testing sample, then the loss of the former is close to the loss of the latter. We call an algorithm having this property “robust.”\nDefinition 2 Algorithm A is (K, ǫ(s)) robust if Z can be partitioned into K disjoint sets, denoted as {Ci} K i=1, such that ∀s ∈ s,\ns, z ∈ Ci, =⇒ |l(As, s)− l(As, z)| ≤ ǫ(s). (2)\nIn the definition, both K and the partition sets {Ci} K i=1 do not depend on the training set s. Note that the definition of robustness requires that (2) holds for every training sample. Indeed, we can relax the definition, so that the condition needs only hold for a subset of training samples. We call an algorithm having this property “pseudo robust”. See Section 4 for details."
    }, {
      "heading" : "3. Generalization of Robust Algorithms",
      "text" : "In this section we investigate generalization property of robust algorithms. In particular, in the following subsections we derive PAC bounds for robust algorithms under three different conditions: (1) The ubiquitous learning setup where the samples are i.i.d. and the goal of learning is to minimize expected loss. (2) The learning goal is to minimize quantile loss. (3) The samples are generated according to a (Doeblin) Markovian chain. Indeed, the fact that we can provide results in (2) and (3) indicates the fundamental nature of robustness as a property of learning algorithms."
    }, {
      "heading" : "3.1 IID samples and expected loss",
      "text" : "In this section, we consider the standard learning setup, i.e., the sample set s consists of n i.i.d. samples generated by an unknown distribution µ, and the goal of learning is to minimize expected test loss. Let l̂(·) and lemp(·) denote the expected error and the training error, i.e.,\nl̂(As) , Ez∼µl(As, z); lemp(As) , 1\nn\n∑\nsi∈s\nl(As, si).\nRecall that the loss function l(·, ·) is upper bounded by M .\nTheorem 3 If s consists of n i.i.d. samples, and A is (K, ǫ(s))-robust, then for any δ > 0, with probability at least 1− δ,\n∣ ∣ ∣ l̂(As)− lemp(As) ∣ ∣ ∣ ≤ ǫ(s) +M\n√\n2K ln 2 + 2 ln(1/δ)\nn .\nProof LetNi be the set of index of points of s that fall into the Ci. Note that (|N1|, · · · , |NK |) is an IID multinomial random variable with parameters n and (µ(C1), · · · , µ(CK)). The following holds by the Breteganolle-Huber-Carol inequality (cf Proposition A6.6 of van der Vaart and Wellner, 2000):\nPr\n{\nK ∑\ni=1\n∣ ∣ ∣ ∣ |Ni|\nn − µ(Ci)\n∣ ∣ ∣ ∣ ≥ λ\n}\n≤ 2K exp( −nλ2\n2 ).\nHence, the following holds with probability at least 1− δ,\nK ∑\ni=1\n∣ ∣ ∣ ∣ |Ni|\nn − µ(Ci)\n∣ ∣ ∣ ∣ ≤\n√\n2K ln 2 + 2 ln(1/δ)\nn . (3)\nWe have ∣\n∣ ∣ l̂(As)− lemp(As)\n∣ ∣ ∣\n=\n∣ ∣ ∣ ∣ ∣ K ∑\ni=1\nE ( l(As, z)|z ∈ Ci ) µ(Ci)− 1\nn\nn ∑\ni=1\nl(As, si)\n∣ ∣ ∣ ∣ ∣\n(a) ≤\n∣ ∣ ∣ ∣ ∣ K ∑\ni=1\nE ( l(As, z)|z ∈ Ci ) |Ni|\nn −\n1 n\nn ∑\ni=1\nl(As, si)\n∣ ∣ ∣ ∣ ∣\n+\n∣ ∣ ∣ ∣ ∣ K ∑\ni=1\nE ( l(As, z)|z ∈ Ci ) µ(Ci)− K ∑\ni=1\nE ( l(As, z)|z ∈ Ci ) |Ni|\nn\n∣ ∣ ∣ ∣ ∣\n(b) ≤\n∣ ∣ ∣ ∣ ∣ ∣ 1 n K ∑\ni=1\n∑\nj∈Ni\nmax z2∈Ci |l(As, sj)− l(As, z2)|\n∣ ∣ ∣ ∣ ∣ ∣ + ∣ ∣ ∣ ∣ ∣ max z∈Z |l(As,z)| K ∑\ni=1\n∣ ∣ ∣ |Ni|\nn − µ(Ci)\n∣ ∣ ∣\n∣ ∣ ∣ ∣ ∣\n(c) ≤ǫ(s) +M K ∑\ni=1\n∣ ∣ ∣ ∣ |Ni|\nn − µ(Ci)\n∣ ∣ ∣ ∣ ,\n(4)\nwhere (a), (b), and (c) are due to the triangle inequality, the definition of Ni, and the definition of ǫ(s) and M , respectively. Note that the right-hand-side of (4) is upper-bounded\nby ǫ(s)+M\n√\n2K ln 2+2 ln(1/δ) n with probability at least 1−δ due to (3). The theorem follows.\nTheorem 3 requires that we fix a K a priori. However, it is often worthwhile to consider adaptive K. For example, in the large-margin classification case, typically the margin is known only after s is realized. That is, the value of K depends on s. Because of this dependency, we needs a generalization bound that holds uniformly for all K.\nCorollary 4 If s consists of n i.i.d. samples, and A is (K, ǫK(s)) robust for all K ≥ 1, then for any δ > 0, with probability at least 1− δ,\n∣ ∣ ∣ l̂(As)− lemp(As) ∣ ∣ ∣ ≤ inf\nK≥1\n\nǫK(s) +M\n√\n2K ln 2 + 2 ln K(K+1)δ n\n\n .\nProof Let\nE(K) ,\n \n\n∣ ∣ ∣ l̂(As)− lemp(As) ∣ ∣ ∣ > ǫK(s) +M\n√\n2K ln 2 + 2 ln K(K+1)δ n\n \n\n.\nFrom Theorem 3 we have Pr(E(K)) ≤ δ/(K(K + 1)) = δ/K − δ/(K + 1). By the union bound we have\nPr\n \n\n⋃\nK≥1\nE(K)\n \n\n≤ ∑\nK≥1\nPr (E(K)) ≤ ∑\nK≥1\n[\nδ\nK −\nδ\nK + 1\n]\n= δ,\nand the corollary follows.\nIf ǫ(s) does not depend on s, we can sharpen the bound given in Corollary 4.\nCorollary 5 If s consists of n i.i.d. samples, and A is (K, ǫK) robust for all K ≥ 1, then for any δ > 0, with probability at least 1− δ,\n∣ ∣ ∣ l̂(As)− lemp(As) ∣ ∣ ∣ ≤ inf\nK≥1\n\nǫK +M\n√\n2K ln 2 + 2 ln 1δ n\n\n .\nProof The right hand side does not depend on s, and hence the optimal K∗. Therefore, plugging K∗ into Theorem 3 establishes the corollary."
    }, {
      "heading" : "3.2 Quantile Loss",
      "text" : "So far we considered the standard expected loss setup. In this section we consider some less extensively investigated loss functions, namely quantile value and truncated expectation (see the following for precise definitions). These loss functions are of interest because they are less sensitive to the presence of outliers than the standard average loss (Huber, 1981).\nDefinition 6 For a non-negative random variable X, the β-quantile value is\nQβ(X) , inf { c ∈ R : Pr ( X ≤ c ) ≥ β } .\nThe β-truncated mean is\nTβ(X) ,\n \n\nE [ X · 1(X < Qβ(X)) ]\nif Pr [ X = Qβ(X) ] = 0;\nE [ X · 1(X < Qβ(X)) ] + β−Pr\n[ X<Qβ(X) ]\nPr [ X=Qβ(X) ] Qβ(X) otherwise.\nIn words, the β−quantile loss is the smallest value that is larger or equal to X with probability at least β. The β-truncated mean is the contribution to the expectation of the leftmost β fraction of the distribution. For example, suppose X is supported on {c1, · · · , c10} (c1 < c2 < · · · < c10) and the probability of taking each value equals 0.1. Then the 0.63-quantile loss of X is c7, and the 0.63-truncated mean of X equals 0.1( ∑6 i=1 ci +0.3c7).\nGiven h ∈ H, β ∈ (0, 1), and a probability measure µ on Z, let\nQ(h, β, µ) , Qβ(l(h, z)); where: z ∼ µ;\nand\nT (h, β, µ) , Tβ(l(h, z)); where: z ∼ µ;\ni.e., the β-quantile value and β-truncated mean of the (random) testing error of hypothesis h if the testing sample follows distribution µ. We have the following theorem that is a special case of Theorem 13, hence we omit the proof.\nTheorem 7 (Quantile Value & Truncated Mean) Suppose s are n i.i.d. samples drawn\naccording to µ, and denote the empirical distribution of s by µemp. Let λ0 =\n√\n2K ln 2+2 ln(1/δ) n .\nIf 0 ≤ β − λ0 ≤ β + λ0 ≤ 1 and A is (K, ǫ(s)) robust, then with probability at least 1 − δ, the followings hold\n(I) Q (As, β − λ0, µemp)− ǫ(s) ≤ Q (As, β, µ) ≤ Q (As, β + λ0, µemp) + ǫ(s);\n(II) T (As, β − λ0, µemp)− ǫ(s) ≤ T (As, β, µ) ≤ T (As, β + λ0, µemp) + ǫ(s).\nIn words, Theorem 7 essentially means that with high probability, the β-quantile value/truncated mean of the testing error (recall that the testing error is a random variable) is (approximately) bounded by the (β±λ0)-quantile value/truncated mean of the empirical error, thus providing a way to estimate the quantile value/truncated expectation of the testing error based on empirical observations."
    }, {
      "heading" : "3.3 Markovian samples",
      "text" : "The robustness approach is not restricted to the IID setup. In many applications of interest, such as reinforcement learning and time series forecasting, the IID assumption is violated. In such applications there is a time driven process that generates samples that depend on the previous samples (e.g., the observations of a trajectory of a robot). Such a situation can be modeled by stochastic process such as a Markov processes. In this section we establish similar result to the IID case for samples that are drawn from a Markov chain. The state space can be general, i.e., it is not necessarily finite or countable. Thus, a certain ergodic structure of the underlying Markov chain is needed. We focus on chains that converge to equilibrium exponentially fast and uniformly in the initial condition. It is known that this is equivalent to the class of of Doeblin chains (Meyn and Tweedie, 1993). Recall the following definition (cf Meyn and Tweedie, 1993; Doob, 1953)).\nDefinition 8 A Markov chain {zi} ∞ i=1 on a state space Z is a Doeblin chain (with α and T ) if there exists a probability measure ϕ on Z, α > 0, an integer T ≥ 1 such that\nPr(zT ∈ H|z0 = z) ≥ αϕ(H); ∀measureable H ⊆ Z; ∀z ∈ Z.\nThe class of Doeblin chains is probably the “nicest” class of general state-space Markov chains. We notice that such assumption is not overly restrictive, since by requiring that an ergodic theorem holds for all bounded functions uniformly in the initial distribution itself implies that a chain is Doeblin (Meyn and Tweedie, 1993). In particular, an ergodic chain defined on a finite state-space is a Doeblin chain.\nIndeed, the Doeblin chain condition guarantees that an invariant measure π exists. Furthermore, we have the following lemma adapted from Theorem 2 of Glynn and Ormoneit (2002).\nLemma 9 Let {zi} be a Doeblin chain as in Definition 8. Fix a function f : Z → R such that ‖f‖∞ ≤ C. Then for n > 2CT/ǫα the following holds\nPr\n(\n1 n\nn ∑\ni=1\nf(zi)−\n∫\nZ f(z)π(dz)s ≥ ǫ\n)\n≤ exp\n(\n− α2(nǫ− 2CT/α)2\n2nC2T 2\n)\n.\nThe following is the main theorem of this section that establishes a generalization bound for robust algorithms with samples drawn according to a Doeblin chain.\nTheorem 10 Let s = {s1, · · · , sn} be the first n outputs of a Doeblin chain with α and T such that n > 2T/α, and suppose that A is (K, ǫ(s))-robust. Then for any δ > 0, with probability at least 1− δ,\n∣ ∣ ∣ l̂(As)− lemp(As) ∣ ∣ ∣ ≤ ǫ(s) +M\n(\n8T 2(K ln 2 + ln(1/δ))\nα2n\n)1/4\n.\nProof We prove the following slightly stronger statement:\n∣ ∣ ∣ l̂(As)− lemp(As) ∣ ∣ ∣ ≤ ǫ(s) +M\n√\nT\nαn\n√\n√\n2n(K ln 2 + ln(1/δ)) + 2. (5)\nLet λ0 = √ T αn\n√\n√ 2n(K ln 2 + ln(1/δ)) + 2, we have that λ0 > √ 2T/αn. Since n > 2T/α,\nwe have n > √ 2Tn/α, which leads to\nn > 2T\nα √ 2T/αn >\n2T\nαλ0 .\nLet Ni be the set of index of points of s that fall into the Ci. Consider the set of functions\nH = {1(x ∈ H)|H = ⋃\ni∈I Ci; ∀I ⊆ {1, · · · ,K}}, i.e., the set of indicator functions of all\ndifferent unions of Ci. Then |H| = 2 K . Furthermore, fix a h0 ∈ H,\nPr(\nK ∑\nj=1\n∣ ∣ ∣ ∣ |Nj |\nn − π(Cj)\n∣ ∣ ∣ ∣ ≥ λ)\n=Pr {\nsup h∈H\n[ 1\nn\nn ∑\ni=1\nh(si)− Eπh(s)] ≥ λ }\n≤2KPr[ 1\nn\nn ∑\ni=1\nh0(si)− Eπh0(s) ≥ λ].\nSince ‖h0‖∞ = 1, we can apply Lemma 9 to get for n > 2T/λα\nPr[ 1\nn\nn ∑\ni=1\nh0(si)− Eπh0(s) ≥ λ] ≤ exp\n(\n− α2(nλ2 − 2T/α)2\n2nT 2\n)\n.\nSubstitute in λ0,\nPr( K ∑\nj=1\n∣ ∣ ∣ ∣ |Nj|\nn − π(Cj)\n∣ ∣ ∣ ∣ ≥ λ0) ≤ 2 K exp ( − α2(nλ20 − 2T/α) 2\n2nT 2\n)\n= δ.\nThus, (5) follows by an identical argument as the proof of Theorem 3.\nTo complete the proof of the theorem, note that n > 2T/α implies n ≥ 2, hence √\n2n(K ln 2 + ln(1/δ)) ≥ 2. Therefore,\n√\nT\nαn\n√\n√\n2n(K ln 2 + ln(1/δ)) + 2 ≤\n√\nT\nαn\n√\n2 √ 2n(K ln 2 + ln(1/δ))\n=\n(\n8T 2(K ln 2 + ln(1/δ))\nα2n\n)1/4\n,\nand the theorem follows."
    }, {
      "heading" : "4. Pseudo Robustness",
      "text" : "In this section we propose a relaxed definition of robustness that accounts for the case where Equation (2) holds for most of training samples, as opposed to Definition 6 where Equation (2) holds for all training samples. Recall that the size of training set is fixed as n.\nDefinition 11 Algorithm A is (K, ǫ(s), n̂) pseudo robust if Z can be partitioned into K disjoint sets, denoted as {Ci} K i=1, and a subset of training samples ŝ with |ŝ| = n̂ such that ∀s ∈ ŝ,\ns, z ∈ Ci, =⇒ |l(As, s)− l(As, z)| ≤ ǫ(s).\nObserve that (K, ǫ(s))-robust is equivalent to (K, ǫ(s), n) pseudo robust.\nTheorem 12 If s consists of n i.i.d. samples, and A is (K, ǫ(s), n̂) pseudo robust, then for any δ > 0, with probability at least 1− δ,\n∣ ∣ ∣ l̂(As)− lemp(As) ∣ ∣ ∣ ≤ n̂\nn ǫ(s) +M\n(\nn− n̂\nn +\n√\n2K ln 2 + 2 ln(1/δ)\nn\n)\n.\nProof Let Ni and N̂i be the set of indices of points of s and ŝ that fall into the Ci, respectively. Similarly to the proof of Theorem 3, we note that (|N1|, · · · , |NK |) is an IID multinomial random variable with parameters n and (µ(C1), · · · , µ(CK)). And hence due to Breteganolle-Huber-Carol inequality, the following holds with probability at least 1− δ,\nK ∑\ni=1\n∣ ∣ ∣ ∣ |Ni|\nn − µ(Ci)\n∣ ∣ ∣ ∣ ≤\n√\n2K ln 2 + 2 ln(1/δ)\nn . (6)\nFurthermore, we have ∣\n∣ ∣ l̂(As)− lemp(As)\n∣ ∣ ∣\n=\n∣ ∣ ∣ ∣ ∣ K ∑\ni=1\nE ( l(As, z)|z ∈ Ci ) µ(Ci)− 1\nn\nn ∑\ni=1\nl(As, si)\n∣ ∣ ∣ ∣ ∣\n≤\n∣ ∣ ∣ ∣ ∣ K ∑\ni=1\nE ( l(As, z)|z ∈ Ci ) |Ni|\nn −\n1 n\nn ∑\ni=1\nl(As, si)\n∣ ∣ ∣ ∣ ∣\n+\n∣ ∣ ∣ ∣ ∣ K ∑\ni=1\nE ( l(As, z)|z ∈ Ci ) µ(Ci)− K ∑\ni=1\nE ( l(As, z)|z ∈ Ci ) |Ni|\nn\n∣ ∣ ∣ ∣ ∣\n≤\n∣ ∣ ∣ ∣ ∣ ∣ 1 n K ∑\ni=1\n[ |Ni| × E ( l(As, z)|z ∈ Ci ) − ∑\nj∈N̂i\nl(As, sj)− ∑\nj∈Ni,j 6∈N̂i\nl(As, sj) ]\n∣ ∣ ∣ ∣ ∣ ∣\n+\n∣ ∣ ∣ ∣ ∣ max z∈Z |l(As,z)| K ∑\ni=1\n∣ ∣ ∣ |Ni|\nn − µ(Ci)\n∣ ∣ ∣\n∣ ∣ ∣ ∣ ∣ .\nNote that due to the triangle inequality as well as the assumption that the loss is nonnegative and upper bounded by M , the right-hand side can be upper bounded by ∣\n∣ ∣ ∣ ∣ ∣ 1 n K ∑\ni=1\n∑\nj∈N̂i\nmax z2∈Ci |l(As, sj)− l(As, z2)|\n∣ ∣ ∣ ∣ ∣ ∣ + ∣ ∣ ∣ ∣ ∣ ∣ 1 n K ∑\ni=1\n∑\nj∈Ni,j 6∈N̂i\nmax z2∈Ci |l(As, sj)− l(As, z2)|\n∣ ∣ ∣ ∣ ∣ ∣\n+M K ∑\ni=1\n∣ ∣ ∣ ∣ |Ni|\nn − µ(Ci)\n∣ ∣ ∣ ∣\n≤ n̂\nn ǫ(s) +\nn− n̂\nn M +M\nK ∑\ni=1\n∣ ∣ ∣ ∣ |Ni|\nn − µ(Ci)\n∣ ∣ ∣ ∣ .\nwhere the inequality holds due to definition of Ni and N̂i. The theorem follows by applying (6).\nSimilarly, Theorem 7 can be generalized to the pseudo robust case. The proof is lengthy\nand hence postponed to Appendix A.1.\nTheorem 13 (Quantile Value & Truncated Expectation) Suppose s has n samples drawn i.i.d. according to µ, and denote the empirical distribution of s as µemp. Let λ0 = √\n2K ln 2+2 ln(1/δ) n . Suppose 0 ≤ β − λ0 − (n − n̂)/n ≤ β + λ0 + (n − n̂)/n ≤ 1 and A is\n(K, ǫ(s), n̂) pseudo robust. Then with probability at least 1− δ, the followings hold\n(I) Q\n(\nAs, β − λ0 − n− n̂\nn , µemp\n)\n− ǫ(s)\n≤ Q (As, β, µ) ≤ Q\n(\nAs, β + λ0 + n− n̂\nn , µemp\n)\n+ ǫ(s);\n(II) T\n(\nAs, β − λ0 − n− n̂\nn , µemp\n)\n− ǫ(s)\n≤ T (As, β, µ) ≤ T\n(\nAs, β + λ0 + n− n̂\nn , µemp\n)\n+ ǫ(s)."
    }, {
      "heading" : "5. Examples of Robust Algorithms",
      "text" : "In this section we provide some examples of robust algorithms. The proofs of the examples can be found in Appendix. Our first example is Majority Voting (MV) classification (cf Section 6.3 of Devroye et al., 1996) that partitions the input space X and labels each partition set according to a majority vote of the training samples belonging to it.\nExample 3 (Majority Voting) Let Y = {−1,+1}. Partition X to C1, · · · , CK , and use C(x) to denote the set to which x belongs. A new sample xa ∈ X is labeled by\nAs(xa) ,\n{\n1, if ∑\nsi∈C(xa) 1(si|y = 1) ≥\n∑\nsi∈C(xa) 1(si|y = −1);\n−1, otherwise.\nIf the loss function is l(As, z) = f(z|y,As(z|x)) for some function f , then MV is (2K, 0) robust.\nMV algorithm has a natural partition of the sample space that makes it robust. Another class of robust algorithms are those that have approximately the same testing loss for testing samples that are close (in the sense of geometric distance) to each other, since we can partition the sample space with norm balls. The next theorem states that an algorithm is robust if two samples being close implies that they have similar testing error.\nTheorem 14 Fix γ > 0 and metric ρ of Z. Suppose A satisfies\n|l(As, z1)− l(As, z2)| ≤ ǫ(s), ∀z1, z2 : z1 ∈ s, ρ(z1, z2) ≤ γ,\nand N (γ/2,Z, ρ) < ∞. Then A is ( N (γ/2,Z, ρ), ǫ(s) ) -robust.\nProof Let {c1, · · · , cN (γ/2,Z,ρ)} be a γ/2-cover of Z. whose existence is guaranteed by the definition of covering number. Let Ĉi = {z ∈ Z|ρ(z, ci) ≤ γ/2}, and Ci = Ĉi ⋂ ( ⋃i−1 j=1 Ĉj )c . Thus, C1, · · · , CN (γ/2,Z,ρ) is a partition of Z, and satisfies\nz1, z2 ∈ Ci =⇒ ρ(z1, z2) ≤ ρ(z1, ci) + ρ(z2, ci) ≤ γ.\nTherefore,\n|l(As, z1)− l(As, z2)| ≤ ǫ(s), ∀z1, z2 : z1 ∈ s, ρ(z1, z2) ≤ γ,\nimplies\nz1 ∈ s z1, z2 ∈ Ci =⇒ |l(As, z1)− l(As, z2)| ≤ ǫ(s),\nand the theorem follows.\nTheorem 14 immediately leads to the next example: if the testing error given the output of an algorithm is Lipschitz continuous, then the algorithm is robust.\nExample 4 (Lipschitz continuous functions) If Z is compact w.r.t. metric ρ, l(As, ·) is Lipschitz continuous with Lipschitz constant c(s), i.e.,\n|l(As, z1)− l(As, z2)| ≤ c(s)ρ(z1, z2), ∀z1, z2 ∈ Z,\nthen A is ( N (γ/2,Z, ρ), c(s)γ ) -robust for all γ > 0.\nTheorem 14 also implies that SVM, Lasso, feed-forward neural network and PCA are robust, as stated in Example 5 to Example 8. The proofs are deferred to Appendix A.3 to A.6.\nExample 5 (Support Vector Machine) Let X be compact. Consider the standard SVM formulation (Cortes and Vapnik, 1995; Schölkopf and Smola, 2002)\nMinimize:w,d c‖w‖ 2 H +\n1 n\nn ∑\ni=1\nξi\ns. t. 1− si|y[〈w, φ(si|x)〉+ d] ≤ ξi;\nξi ≥ 0.\nHere φ(·) is a feature mapping, ‖ · ‖H is its RKHS kernel, and k(·, ·) is the kernel function. Let l(·, ·) be the hinge-loss, i.e., l ( (w, d), z )\n= [1− z|y(〈w,φ(z|x)〉+d)] +, and define fH(γ) ,\nmaxa,b∈X ,‖a−b‖2≤γ ( k(a,a)+k(b,b)−2k(a,b) ) . If k(·, ·) is continuous, then for any γ > 0, fH(γ) is finite, and SVM is (2N (γ/2,X , ‖ · ‖2), √ fH(γ)/c) robust.\nExample 6 (Lasso) Let Z be compact and the loss function be l(As, z) = |z|y − As(z|x)|. Lasso (Tibshirani, 1996), which is the following regression formulation:\nmin w\n: 1\nn\nn ∑\ni=1\n(si|y − w ⊤si|x) 2 + c‖w‖1, (7)\nis ( N (γ/2,Z, ‖ · ‖∞), (Y (s)/c + 1)γ ) -robust for all γ > 0, where Y (s) , 1n ∑n i=1 si|y 2 .\nExample 7 (Feed-forward Neural Networks) Let Z be compact and the loss function be l(As, z) = |z|y − As(z|x)|. Consider the d-layer neural network (trained on s), which is the following predicting rule given an input x ∈ X\nx0 := z|x\n∀v = 1, · · · , d− 1 : xvi := σ(\nNv−1 ∑\nj=1\nwv−1ij x v−1 j ); i = 1, · · · , Nv;\nAs(x) := σ(\nNd−1 ∑\nj=1\nwd−1j x d−1 j );\nIf there exists α, β such that the d-layer neural network satisfying that |σ(a)−σ(b)| ≤ β|a−b|, and ∑Nv\nj=1 |w v ij | ≤ α for all v, i, then it is\n(\nN (γ/2,Z, ‖ · ‖∞), α dβdγ\n)\n-robust, for all γ > 0.\nWe remark that in Example 7, the number of hidden units in each layer has no effect on the robustness of the algorithm and consequently the bound on the testing error. This indeed agrees with Bartlett (1998), where the author showed (using a different approach based on fat-shattering dimension) that for neural networks, the weight plays a more important role than the number of hidden units.\nThe next example considers an unsupervised learning algorithm, namely the principal component analysis. We show that it is robust if the sample space is bounded. Note that, this does not contradict with the well known fact that the principal component analysis is sensitive to outliers which are far away from the origin.\nExample 8 (Principal Component Analysis (PCA)) Let Z ⊂ Rm, such that maxz∈Z ‖z‖2 ≤ B. If the loss function is l((w1, · · · , wd), z) = ∑d k=1(w ⊤ k z) 2, then finding the first d principal components, which solves the following optimization problem of w1, · · · , wd ∈ R m,\nMaximize:\nn ∑\ni=1\nd ∑\nk=1\n(w⊤k si) 2\nSubject to: ‖wk‖2 = 1, k = 1, · · · , d;\nw⊤i wj = 0, i 6= j.\nis (N (γ/2,Z, ‖ · ‖2), 2dγB)-robust.\nThe last example is large-margin classification, which is a generalization of Example 1. We need the following standard definition (e.g., Bartlett, 1998) of the distance of a point to a classification rule.\nDefinition 15 Fix a metric ρ of X . Given a classification rule ∆ and x ∈ X , the distance of x to ∆ is\nD(x,∆) , inf{c ≥ 0|∃x′ ∈ X : ρ(x, x′) ≤ c,∆(x) 6= ∆(x′)}.\nA large margin classifier is a classification rule such that most of the training samples\nare “far away” from the classification boundary.\nExample 9 (Large-margin classifier) If there exist γ and n̂ such that\nn ∑\ni=1\n1 ( D(si|x,As) > γ ) ≥ n̂,\nthen algorithm A is (2N (γ/2,X , ρ), 0, n̂) pseudo robust, provided that N (γ/2,X , ρ) < ∞.\nNote that if we take ρ to be the Euclidean norm, and let n̂ = n, then we recover Example 1."
    }, {
      "heading" : "6. Necessity of Robustness",
      "text" : "Thus far we have considered finite sample generalization bounds of robust algorithms. We now turn to asymptotic analysis, i.e., we are given an increasing set of training samples s = (s1, s2, · · · ) and tested on an increasing set of testing samples t = (t1, t2, · · · ). We use s(n) and t(n) to denote the first n elements of training samples and testing samples respectively. For succinctness, we let L(·, ·) to be the average loss given a set of samples, i.e., for h ∈ H,\nL(h, t(n)) ≡ 1\nn\nn ∑\ni=1\nl(h, ti).\nWe show in this section that robustness is an essential property of successful learning. In particular, a (weaker) notion of robustness characterizes generalizability, i.e., a learning algorithm generalizes if and only if it is weakly robust. To make this precise, we define the notion of generalizability and weak robustness first.\nDefinition 16 1. A learning algorithm A generalizes w.r.t. s if\nlim sup n\n{\nEt\n( l(As(n), t) ) − L(As(n), s(n)) } ≤ 0.\n2. A learning algorithm A generalize w.p. 1 if it generalize w.r.t. almost every s.\nWe remark that the proposed notion of generalizability differs slightly from the standard one in the sense that the latter requires that the empirical risk and the expected risk converges in mean, while the proposed notion requires convergence w.p.1. It is straightforward that the proposed notion implies the standard one.\nDefinition 17 1. A learning algorithm A is weakly robust w.r.t s if there exists a\nsequence of {Dn ⊆ Z n} such that Pr(t(n) ∈ Dn) → 1, and\nlim sup n\n{\nmax ŝ(n)∈Dn\n[ L(As(n), ŝ(n))−L(As(n), s(n)) ]\n}\n≤ 0.\n2. A learning algorithm A is a.s. weakly robust if it is robust w.r.t. almost every s.\nWe briefly comment on the definition of weak robustness. Recall that the definition of robustness requires that the sample space can be partitioned into disjoint subsets such that if a testing sample belongs to the same partitioning set of a training sample, then they have similar loss. Weak robustness generalizes such notion by considering the average loss of testing samples and training samples. That is, if for a large (in the probabilistic sense) subset of Zn, the testing error is close to the training error, then the algorithm is weakly robust. It is easy to see, by Breteganolle-Huber-Carol lemma, that if for any fixed ǫ > 0 there exists K such that A is (K, ǫ) robust, then A is weakly robust.\nWe now establish the main result of this section: weak robustness and generalizability\nare equivalent.\nTheorem 18 An algorithm A generalizes w.r.t. s if and only if it is weakly robust w.r.t. s.\nProof We prove the sufficiency of weak robustness first. When A is weakly robust w.r.t. s, by definition there exists {Dn} such that for any δ, ǫ > 0, there exists N(δ, ǫ) such that for all n > N(δ, ǫ), Pr(t(n) ∈ Dn) > 1− δ, and\nsup ŝ(n)∈Dn L(As(n), ŝ(n))− L(As(n), s(n)) < ǫ. (8)\nTherefore, the following holds for any n > N(δ, ǫ),\nEt\n( l(As(n), t) ) − L(As(n), s(n))\n=Et(n)\n( L(As(n), t(n)) ) − L(As(n), s(n))\n=Pr(t(n) 6∈ Dn)E ( L(As(n), t(n))|t(n) 6∈ Dn ) +Pr(t(n) ∈ Dn)E ( L(As(n), t(n))|t(n) ∈ Dn )\n− L(As(n), s(n))\n≤δM + sup ŝ(n)∈Dn\n{ L(As(n), ŝ(n))− L(As(n), s(n)) } ≤ δM + ǫ.\nHere, the first equality holds by i.i.d. of t(n), and the second equality holds by conditional expectation. The inequalities hold due to the assumption that the loss function is upper bounded by M , as well as (8).\nWe thus conclude that the algorithm A generalizes for s, because ǫ, δ can be arbitrary. Now we turn to the necessity of weak robustness. First, we establish the following\nlemma.\nLemma 19 Given s, if algorithm A is not weakly robust w.r.t. s, then there exists ǫ∗, δ∗ > 0 such that the following holds for infinitely many n,\nPr ( L(As(n), t(n)) ≥ L(As(n), s(n)) + ǫ ∗ ) ≥ δ∗. (9)\nProof We prove the lemma by contradiction. Assume that such ǫ∗ and δ∗ do not exist. Let ǫv = δv = 1/v for v = 1, 2 · · · , then there exists a non-decreasing sequence {N(v)} ∞ v=1 such that for all v, if n ≥ N(v) then Pr ( L(As(n), t(n)) ≥ L(As(n), s(n)) + ǫv ) < δv. For each n, define the following set:\nDvn , {ŝ(n)|L(As(n), ŝ(n))−L(As(n), s(n)) < ǫv}.\nThus, for n ≥ N(v) we have\nPr(t(n) ∈ Dvn) = 1− Pr ( L(As(n), t(n)) ≥ L(As(n), s(n)) + ǫv ) > 1− δv .\nFor n ≥ N(1), define Dn , D v(n) n , where: v(n) , max ( v|N(t) ≤ n; v ≤ n ) . Thus for all n ≥ N(1) we have that Pr(t(n) ∈ Dn) > 1 − δv(n) and supŝ(n)∈Dn L(As(n), ŝ(n)) − L(As(n), s(n)) < ǫv(n). Note that v(n) ↑ ∞, it follows that δv(n) → 0 and ǫv(n) → 0. Therefore, Pr(t(n) ∈ Dn) → 1, and\nlim sup n→∞\n{\nsup ŝ(n)∈Dn\nL(As(n), ŝ(n))−L(As(n), s(n)) } ≤ 0.\nThat is, A is weakly robust w.r.t. s, which is a desired contradiction.\nWe now prove the necessity of weak robustness. Recall that l(·, ·) is uniformly bounded. Thus by Hoeffding’s inequality we have that for any ǫ, δ, there exists n∗ such that for any n > n∗, with probability at least 1 − δ, we have ∣ ∣\n∣ 1 n ∑n i=1 l(As(n), ti) − Et(l(As(n), t))\n∣ ∣ ∣ ≤ ǫ.\nThis implies that\nL(As(n), t(n))− Etl(As(n), t) Pr −→ 0. (10)\nSince algorithm A is not robust, Lemma 19 implies that (9) holds for infinitely many n. This, combined with Equation (10) implies that for infinitely many n,\nEtl(As(n), t) ≥ L(As(n), s(n)) + ǫ∗\n2 ,\nwhich means that A does not generalize. Thus, the necessity of weak robustness is established.\nTheorem 18 immediately leads to the following corollary.\nCorollary 20 An algorithm A generalizes w.p. 1 if and only if it is a.s. weakly robust."
    }, {
      "heading" : "7. Discussion",
      "text" : "In this paper we investigated the generalization ability of learning algorithm based on their robustness: the property that if a testing sample is “similar” to a training sample, then its loss is close to the training error. This provides a novel approach, different from the complexity or stability argument, in studying the performance of learning algorithms. We further showed that a weak notion of robustness characterizes generalizability, which implies that robustness is a fundamental property for learning algorithms to work.\nBefore concluding the paper, we outline several directions for future research.\n• Adaptive partition: In Definition 2 when the notion of robustness was introduced, we\nrequired that the partitioning of Z into K sets is fixed. That is, regardless of the training sample set, we partition Z into the same K sets. A natural and interesting question is what if such fixed partition does not exist, while instead we can only partition Z intoK sets adaptively, i.e., for different training set we will have a different partitioning of Z. Adaptive partition setup can be used to study algorithms such as k-NN. Our current proof technique does not straightforwardly extend to such a setup, and we would like to understand whether a meaningful generalization bound under this weaker notion of robustness can be obtained.\n• Mismatched datasets: One advantage of algorithmic robustness framework is the abil-\nity to handle non-standard learning setups. For example, in Section 3.2 and 3.3 we derived generalization bounds for quantile loss and for samples drawn from a Markovian chain, respectively. A problem of the same essence is the mismatched datasets, where the training samples are generated according to a distribution slightly different from that of the testing samples, e.g., the two distributions may have a small K-L divergence. We conjecture that in this case a generalization bound similar to Theorem 3 would be possible, with an extra term depending on the magnitude of the difference of the two distributions.\n• Outlier removal: One possible reason that the training samples is generated differently\nfrom the testing sample is outlier corruption. It is often the case that the training sample set is corrupted by some outliers. In addition, algorithms designed to be outlier resistent abound in the literature (e.g., Huber, 1981; Rousseeuw and Leroy, 1987). The robust framework may provide a novel approach in studying both the generalization ability and the outlier resistent property of these algorithms. In particular, the results reported in Section 3.2 can serve as a starting point of future research in this direction.\n• Consistency: We addressed in this paper the relationship between robustness and gen-\neralizability. An equally important feature of learning algorithms is consistency: the property that a learning algorithm guarantees to recover the global optimal solution as the number of training data increases. While it is straightforward that if an algorithm\nminimizes the empirical error asymptotically and also generalizes (or equivalently is weakly robust), then it is consistent, much less is known for a necessary condition for an algorithm to be consistent. It is certainly interesting to investigate the relationship between consistency and robustness, and in particular whether robustness is necessary for consistency, at least for algorithms that asymptotically minimize the empirical error.\n• Other robust algorithms: The proposed robust approach considers a general learning\nsetup. However, except for PCA, the algorithms investigated in Section 5 all belong to the supervised learning setting. One natural extension is to investigate other robust unsupervised and semi-supervised learning algorithms. One difficulty is that compared to supervised learning case, the analysis of unsupervised/semi-supervised learning algorithms can be challenging, due to the fact that many of them are random iterative algorithms (e.g., k-means)."
    }, {
      "heading" : "Appendix A. Proofs",
      "text" : ""
    }, {
      "heading" : "A.1 Proof of Theorem 13",
      "text" : "We observe the following properties of quantile value and truncated mean:\n1. If X is supported on R+ and β1 ≥ β2, then\nQβ1(X) ≥ Qβ2(X); Tβ1(X) ≥ Tβ2(X).\n2. If Y stochastically dominates X, i.e., Pr(Y ≥ a) ≥ Pr(X ≥ a) for all a ∈ R, then for\nany β,\nQβ(Y ) ≥ Qβ(X); Tβ(Y ) ≥ Tβ(X).\n3. The β-truncated mean of empirical distribution of nonnegative (x1, · · · , xn) is given\nby\nmin α:0≤αi≤1/n, ∑n i=1 αi≤β\nn ∑\ni=1\nαixi.\nBy definition of pseudo-robustness, Z can be partitioned into K disjoint sets, denoted\nas {Ci} K i=1, and a subset of training samples ŝ with |ŝ| = n̂ such that\nz1 ∈ ŝ, z1, z2 ∈ Ci, =⇒ |l(As, z1)− l(As, z2)| ≤ ǫ(s); ∀s.\nLet Ni be the set of index of points of s that fall into the Ci. Let E be the event that\nthe following holds:\nK ∑\ni=1\n∣ ∣ ∣ ∣ |Ni|\nn − µ(Ci)\n∣ ∣ ∣ ∣ ≤\n√\n2K ln 2 + 2 ln(1/δ)\nn .\nFrom the proof of Theorem 3, Pr(E) ≥ 1 − δ. Hereafter we restrict the discussion to the case when E holds.\nDenote\nvj = argmin z∈Cj l(As, z).\nBy symmetry, without loss of generality we assume that 0 ≤ l(As, v1) ≤ l(As, v2) ≤ · · · ≤ l(As, vK) ≤ M . Define a set of samples s̃ as\ns̃i =\n{\nsi if si ∈ ŝ; vj if si 6∈ ŝ, si ∈ Cj.\nDefine discrete probability measures µ̂ and µ̃, supported on {v1, · · · , vK} as\nµ̂({vj}) = µ(Cj); µ̃({vj}) = |Nj |\nn .\nFurther, let µ̃emp denote the empirical distribution of sample set s̃.\nProof of (I): Observe that µ stochastically dominates µ̂, hence\nQ(As, β, µ̂) ≤ Q(As, β, µ). (11)\nAlso by definition of Q(·) and µ̂,\nQ(As, β, µ̂) = vk∗ ; where: k ∗ = min{k :\nk ∑\ni=1\nµ̂(vi) ≥ β}.\nLet s be the set of all samples si such that si ∈ ŝ, and si ∈ Cj for some j ≤ k ∗. Observe that\n∀si ∈ ŝ : l(As, si) ≤ vk∗ + ǫ(s) = Q(As, β, µ̂) + ǫ(s). (12)\nNote that E implies\n1 n\nk∗ ∑\nj=1\n∑\nsi∈Cj\n1 ≥ k∗ ∑\nj=1\nµ(Cj)− λ0 = k ∑\nj=1\nµ̂(vj)− λ0 ≥ β − λ0.\nSince As is pseudo robust, we have\n1 n ∑\nsi 6∈ŝ\n= n− n̂\nn .\nTherefore\n1 n\nk∗ ∑\nj=1\n∑\nsi∈s,si∈Cj\n1 ≥ 1\nn\nk∗ ∑\nj=1\n∑\nsi∈Cj\n1− 1\nn\n∑\nsi 6∈ŝ\n1 ≥ β − λ0 − n− n̂\nn .\nThus, s is a subset of s of at least n(β − λ0 − (n− n̂)/n) elements. Thus (11) and (12) lead to\nQ(As, β − λ0 − (n− n̂)/n, µemp) ≤ max{si : si ∈ s} ≤ Q(As, β, µ) + ǫ(s).\nThus, we establish the left inequality. The proof of the right one is identical and hence omitted.\nProof of (II): The proof constitutes four steps. Step 1: Observe that µ stochastically dominates µ̂, hence\nT (As, β, µ̂) ≤ T (As, β, µ).\nStep 2: We prove that\nT (As, β − λ0, µ̃) ≤ T (As, β, µ̂).\nNote that t E implies for all j, we have\nµ̃({v1, · · · , vj})− λ0 ≤ µ̂({v1, · · · , vj}),\nTherefore, there uniquely exists a non-negative integer j∗ and a c∗ ∈ [0, 1) such that\nµ̂({v1, · · · , vj∗}) + c ∗µ̂({vj∗+1}) = β,\nand define\nβ̂ =\nj∗ ∑\ni=1\nmin(µ̃({vi}), µ̂({vi})) + c ∗ min(µ̃({vj∗+1}), µ̂({vj∗+1})), (13)\nthen we have β̂ ≥ β − λ0, which leads to\nT (As, β − λ0, µ̃) ≤ T (As, β̂, µ̃)\n(a) ≤\nj∗ ∑\ni=1\nl(As, vi)min(µ̃({vi}), µ̂({vi})) + c ∗l(As, vj∗+1)min(µ̃({vj∗+1}), µ̂({vj∗+1}))\n≤\nj∗ ∑\ni=1\nl(As, vi)µ̂({vi}) + c ∗l(As, vj∗+1)µ̂({vj∗+1}) = T (As, β, µ̂),\nwhere (a) holds because Equation (13) essentially means that T (As, β̂, µ̃) is a weighted sum with total weights equals to β̂, which puts more weights on small terms, and hence is smaller.\nStep 3: We prove that\nT (As, β − λ0, µ̃emp)− ǫ(s) ≤ T (As, β − λ0, µ̃).\nLet t̃ be a set of n samples, such that Nj of them are vj for j = 1, · · · ,K. Observe that µ̃ is the empirical distribution of t̃. Further note that there is a one-to-one mapping between samples in s̃ and that in t̃ such that each pair (say s̃i, t̃i) of samples belongs to the same Cj. By definition of s̃ this guarantees that |l(As, s̃i)− l(As, t̃i)| ≤ ǫ(s), which implies\nT (As, β − λ0, µ̃emp)− ǫ(s) ≤ T (As, β − λ0, µ̃).\nStep 4: We prove that\nT (As, β − λ0 − n− n̂\nn , µemp) ≤ T (As, β − λ0, µ̃emp).\nLet I = {i : si = s̃i}), the following holds:\nn ∑\ni=1\nαil(As, s̃i) ≥ ∑\ni∈I\nαil(As, s̃i) = ∑\ni∈I\nαil(As, si); ∀α : 0 ≤ αi ≤ 1\nn ;\nn ∑\ni=1\nαi = β − λ0.\nNote that |{i 6∈ I}| = n − n̂, then ∑ i∈I αi ≥ β − λ0 − n−n̂ n . Thus we have ∀α : 0 ≤ αi ≤ 1 n ; ∑n i=1 αi = β − λ0,\n∑\ni∈I\nαil(As, si) ≥ min α′:0≤α′i≤ 1 n , ∑n i=1 α ′ i≤β−λ0− n−n̂ n\nn ∑\ni=1\nα′il(As, si) = T (As, β − λ0, µ̃emp).\nTherefore,\nn ∑\ni=1\nαil(As, s̃i) ≥ T (As, β − λ0 − n− n̂\nn , µemp); ∀α : 0 ≤ αi ≤\n1 n ;\nn ∑\ni=1\nαi = β − λ0.\nMinimization over α on both side. We proved\nT (As, β − λ0 − n− n̂\nn , µemp) ≤ T (As, β − λ0, µ̃emp).\nCombining all four steps, we proved the left inequality, i.e.,\nT (As, β − λ0 − n− n̂\nn , µemp)− ǫ(s) ≤ T (As, β, µ).\nThe right inequality can be proved identically and hence omitted."
    }, {
      "heading" : "A.2 Proof of Example 3",
      "text" : "We can partition Z as {−1}×C1, · · · , {−1}×CK , {+1}×C1, · · · , {+1}×CK . Consider za, zb that belong to a same set, then za|y = zb|y, and ∃i such that za|x, zb|x ∈ Ci, which by the definition of Majority Voting algorithm implies that As(za|x) = As(zb|x). Thus, we have\nl(As, za) = f(za|y,As(za|x)) = f(zb|y,As(zb|x)) = l(As, zb).\nHence MV is (2K, 0)-robust."
    }, {
      "heading" : "A.3 Proof of Example 5",
      "text" : "The existence of fH(γ) follows from the compactness of X and continuity of k(·, ·).\nTo prove the robustness of SVM, let (w∗, d∗) be the solution given training data s. To avoid notation clutter, let yi = si|y and xi = si|x. Thus, we have (due to optimality of w∗, d∗)\nc‖w∗‖2H + 1\nn\nn ∑\ni=1\n[1− yi(〈w ∗, φ(xi)〉+ d ∗)]+ ≤ c‖0‖2H + 1\nn\nn ∑\ni=1\n[1− yi(〈0, φ(xi)〉+ 0)] + = 1,\nwhich implies ‖w∗‖H ≤ √ 1/c. Let c1, · · · , cN (γ/2,X ,‖·‖2) be a γ/2-cover of X (recall that X is compact), then we can partition Z as 2N (γ/2,X , ‖ · ‖2) sets, such that if (y1, x1) and (y2, x2) belongs to the same set, then y1 = y2 and ‖x1 − x2‖2 ≤ γ/2.\nFurther observe that if y1 = y2 and ‖x1 − x2‖2 ≤ γ/2, then\n|l ( (w∗, d∗), z1 ) − l ( (w∗, d∗), z2) ) |\n= ∣ ∣[1− y1(〈w ∗, φ(x1)〉+ d ∗)]+ − [1− y2(〈w ∗, φ(x2)〉+ d ∗)]+ ∣ ∣ ≤ |〈w∗, φ(x1)− φ(x2)〉| ≤ ‖w∗‖H √ 〈φ(x1)− φ(x2), φ(x1)− φ(x2)〉 ≤ √\nfH(γ)/c.\nHere the last inequality follows from the definition of fH. Hence, the example holds by Theorem 14."
    }, {
      "heading" : "A.4 Proof of Example 6",
      "text" : "It suffices to show the following lemma, which establish that loss of Lasso solution is Liptschitz continuous.\nLemma 21 If w∗(s) is the solution of Lasso given training set s, then\n|l(w∗(s), za)− l(w ∗(s), zb)| ≤\n[ 1\nnc\nn ∑\ni=1\nsi|y 2 + 1\n]\n‖za − zb‖∞.\nProof For succinctness we let yi = si|y, xi = si|x for i = 1, · · · , n. Similarly, we let ya(b) = za(b)|y and xa(b) = za(b)|x. Since w ∗(s) is the solution of Lasso, we have (due to optimality)\n1 n\nn ∑\ni=1\n(yi − x ⊤ i w ∗(s))2 + c‖w∗(s)‖1 ≤ 1\nn\nn ∑\ni=1\n(yi − x ⊤ i 0) 2 + c‖0‖1 = 1\nn\nn ∑\ni=1\nyi 2,\nwhich implies ‖w∗‖1 ≤ 1 nc ∑n i=1 yi 2. Therefore,\n|l(w∗(s), za)− l(w ∗(s), zb)| = ||ya − w ∗(s)xa| − |yb −w ∗(s)xb||\n≤ |(ya −w ∗(s)xa)− (yb − w ∗(s)xb)| ≤|ya − yb|+ ‖w ∗(s)‖1‖xa − xb‖∞ ≤(‖w∗(s)‖1 + 1)‖za − zb‖∞\n= [ 1\nnc\nn ∑\ni=1\nyi 2 + 1\n]\n‖za − zb‖∞.\nHere the first two inequalities holds from triangular inequality, and the last inequality holds due to z = (x, y)."
    }, {
      "heading" : "A.5 Proof of Example 7",
      "text" : "To see why the example holds, it suffices to show the following lemma, which establishes that the neural network mentioned is Lipschitz continuous. For simplicity, we write the prediction given x ∈ X as NN(x).\nLemma 22 Fixed α, β, if a d-layer neural network satisfying that |σ(a)− σ(b)| ≤ β|a− b|, and ∑Nv\nj=1 |w v ij | ≤ α for all v, i, then the following holds:\n|l(As, z)− l(As, ẑ)| ≤ (1 + α dβd)‖z − ẑ‖∞.\nProof Let xvi and x̂ v i be the output of the i th unit of the vth layer for samples z and ẑ respectively. Let xv and x̂v be the vector such that the ith elements are xvi and x̂ v i respectively. From ∑Nv\ni=1 |w v i | ≤ α we have\n|xvi − x̂ v i | =\n∣ ∣ ∣ ∣ ∣ ∣ σ( Nv ∑\nj=1\nwvijx v−1 i )− σ(\nNv ∑\nj=1\nwvijx̂ v−1 j )\n∣ ∣ ∣ ∣ ∣ ∣\n≤ β\n∣ ∣ ∣ ∣ ∣ ∣ Nv ∑\nj=1\nwvijx v−1 i −\nNv ∑\nj=1\nwvijx̂ v−1 j\n∣ ∣ ∣ ∣ ∣ ∣\n≤ βα‖xv−1 − x̂v−1‖∞.\nHere, the first inequality holds from the Lipschitz condition of σ, and the second inequality holds from ∑Nv\nj=1 |w v ij| ≤ α. Iterating over d layers, we have\n|NN(z|x)−NN(ẑ|x)| = |x d − x̂d| ≤ αdβd‖x− x̂‖∞,\nwhich implies\n|l(As, z)− l(As, ẑ)| = ∣ ∣|z|y −NN(z|x)| − |ẑ|y −NN(ẑ|x)| ∣ ∣\n≤‖z|y − ẑ|y|+ |NN(z|x)−NN(ẑ|x)| ≤(1 + αdβd)‖z − ẑ‖∞.\nThis proves the lemma."
    }, {
      "heading" : "A.6 Proof of Example 8",
      "text" : "We show that the loss to PCA is Lipschitz continuous, and then apply Theorem 14.\nLet (w∗1(s), · · · , w ∗ d(s)) be the solution of PCA trained on s. Thus we have\n|l((w∗1(s), · · · , w ∗ d(s)), za)− l((w ∗ 1(s), · · · , w ∗ d(s)), zb)|\n=\n∣ ∣ ∣ ∣ ∣ d ∑\nk=1\n(w∗k(s) ⊤za)\n2 − d ∑\nk=1\n(w∗k(s) ⊤zb) 2\n∣ ∣ ∣ ∣ ∣\n≤ d ∑\nk=1\n∣ ∣ ∣ [w∗k(s) ⊤za − w ∗ k(s) ⊤zb][w ∗ k(s) ⊤za + w ∗ k(s) ⊤zb] ∣ ∣ ∣\n≤2dB‖za − zb‖2,\nwhere the last inequality holds because ‖w∗k(s)‖2 = 1 and ‖za‖, ‖zb‖ ≤ B. Hence, the example holds by Theorem 14."
    }, {
      "heading" : "A.7 Proof of Example 9",
      "text" : "Set ŝ as\nŝ , {si ∈ s|D(si,As) > γ}.\nAnd let c1, · · · , cN (γ/2,X ,ρ) be a γ/2 cover of X . Thus, we can partition Z to 2N (γ/2,X , ρ) subsets {Ci}, such that if\nz1, z2 ∈ Ci; =⇒ y1 = y2; & ρ(x1, x2) ≤ γ.\nThis implies that:\nz1 ∈ ŝ, z1, z2 ∈ Ci; =⇒ y1 = y2; As(x1) = As(x2); =⇒ l(As, z1) = l(As, z2).\nBy definition, A is (2N (γ/2,X , ρ), 0, n̂) pseudo robust."
    } ],
    "references" : [ {
      "title" : "Scale-sensitive dimension, uniform convergence, and learnability",
      "author" : [ "N. Alon", "S. Ben-David", "N. Cesa-Bianchi", "D. Haussler" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "Alon et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Alon et al\\.",
      "year" : 1997
    }, {
      "title" : "The sample complexity of pattern classification with neural networks: The size of the weight is more important than the size of the network",
      "author" : [ "P.L. Bartlett" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "Bartlett.,? \\Q1998\\E",
      "shortCiteRegEx" : "Bartlett.",
      "year" : 1998
    }, {
      "title" : "Rademacher and Gaussian complexities: Risk bounds and structural results",
      "author" : [ "P.L. Bartlett", "S. Mendelson" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Bartlett and Mendelson.,? \\Q2002\\E",
      "shortCiteRegEx" : "Bartlett and Mendelson.",
      "year" : 2002
    }, {
      "title" : "Local Rademacher complexities",
      "author" : [ "P.L. Bartlett", "O. Bousquet", "S. Mendelson" ],
      "venue" : "The Annals of Statistics,",
      "citeRegEx" : "Bartlett et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Bartlett et al\\.",
      "year" : 2005
    }, {
      "title" : "Robust convex optimization",
      "author" : [ "A. Ben-tal", "A. Nemirovski" ],
      "venue" : "Mathematics of Operations Research,",
      "citeRegEx" : "Ben.tal and Nemirovski.,? \\Q1998\\E",
      "shortCiteRegEx" : "Ben.tal and Nemirovski.",
      "year" : 1998
    }, {
      "title" : "The price of robustness",
      "author" : [ "D. Bertsimas", "M. Sim" ],
      "venue" : "Operations Research,",
      "citeRegEx" : "Bertsimas and Sim.,? \\Q1999\\E",
      "shortCiteRegEx" : "Bertsimas and Sim.",
      "year" : 1999
    }, {
      "title" : "Support vector networks",
      "author" : [ "Cortes", "V.N. Vapnik" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Cortes and Vapnik.,? \\Q2002\\E",
      "shortCiteRegEx" : "Cortes and Vapnik.",
      "year" : 2002
    }, {
      "title" : "Markov Chains and Stochastic Stability",
      "author" : [ "S.P. Meyn", "R.L. Tweedie" ],
      "venue" : null,
      "citeRegEx" : "1989",
      "shortCiteRegEx" : "1989",
      "year" : 1993
    }, {
      "title" : "Learning with Kernels",
      "author" : [ "B. Schölkopf", "A.J. Smola" ],
      "venue" : null,
      "citeRegEx" : "Schölkopf and Smola.,? \\Q2002\\E",
      "shortCiteRegEx" : "Schölkopf and Smola.",
      "year" : 2002
    }, {
      "title" : "Learnability and stability in the general learning setting",
      "author" : [ "S. Shalev-Shwartz", "O. Shamir", "N. Srebro", "K. Sridharan" ],
      "venue" : "In Proceedings of 22nd Annual Conference of Learning Theory,",
      "citeRegEx" : "Shalev.Shwartz et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Shalev.Shwartz et al\\.",
      "year" : 2009
    }, {
      "title" : "Second order cone programming approaches for handling missing and uncertain data",
      "author" : [ "P.K. Shivaswamy", "C. Bhattacharyya", "A.J. Smola" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Shivaswamy et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Shivaswamy et al\\.",
      "year" : 2006
    }, {
      "title" : "Regression shrinkage and selection via the Lasso",
      "author" : [ "R. Tibshirani" ],
      "venue" : "Journal of the Royal Statistical Society, Series B,",
      "citeRegEx" : "Tibshirani.,? \\Q1996\\E",
      "shortCiteRegEx" : "Tibshirani.",
      "year" : 1996
    }, {
      "title" : "Weak Convergence and Empirical Processes",
      "author" : [ "A.W. van der Vaart", "J.A. Wellner" ],
      "venue" : null,
      "citeRegEx" : "Vaart and Wellner.,? \\Q2000\\E",
      "shortCiteRegEx" : "Vaart and Wellner.",
      "year" : 2000
    }, {
      "title" : "The necessary and sufficient conditions for consistency in the empirical risk minimization method",
      "author" : [ "V.N. Vapnik", "A. Chervonenkis" ],
      "venue" : "Pattern Recognition and Image Analysis,",
      "citeRegEx" : "Vapnik and Chervonenkis.,? \\Q1991\\E",
      "shortCiteRegEx" : "Vapnik and Chervonenkis.",
      "year" : 1991
    }, {
      "title" : "Robust regression and Lasso",
      "author" : [ "H. Xu", "C. Caramanis", "S. Mannor" ],
      "venue" : "Advances in Neural Information Processing Systems",
      "citeRegEx" : "Xu et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Xu et al\\.",
      "year" : 2009
    }, {
      "title" : "Robustness and regularization of support vector machines",
      "author" : [ "H. Xu", "C. Caramanis", "S. Mannor" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Xu et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Xu et al\\.",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : ", 2000), the fat-shattering dimension (e.g., Alon et al., 1997; Bartlett, 1998), and the Rademacher complexity (Bartlett and Mendelson, 2002; Bartlett et al.",
      "startOffset" : 38,
      "endOffset" : 79
    }, {
      "referenceID" : 2,
      "context" : ", 1997; Bartlett, 1998), and the Rademacher complexity (Bartlett and Mendelson, 2002; Bartlett et al., 2005).",
      "startOffset" : 55,
      "endOffset" : 108
    }, {
      "referenceID" : 3,
      "context" : ", 1997; Bartlett, 1998), and the Rademacher complexity (Bartlett and Mendelson, 2002; Bartlett et al., 2005).",
      "startOffset" : 55,
      "endOffset" : 108
    }, {
      "referenceID" : 0,
      "context" : ", Alon et al., 1997; Bartlett, 1998), and the Rademacher complexity (Bartlett and Mendelson, 2002; Bartlett et al., 2005). Another well-known approach is based on stability. An algorithm is stable if its output remains “similar” for different sets of training samples that are identical up to removal or change of a single sample. The first results that relate stability to generalizability track back to Devroye and Wagner (1979a) and Devroye and Wagner (1979b).",
      "startOffset" : 2,
      "endOffset" : 432
    }, {
      "referenceID" : 0,
      "context" : ", Alon et al., 1997; Bartlett, 1998), and the Rademacher complexity (Bartlett and Mendelson, 2002; Bartlett et al., 2005). Another well-known approach is based on stability. An algorithm is stable if its output remains “similar” for different sets of training samples that are identical up to removal or change of a single sample. The first results that relate stability to generalizability track back to Devroye and Wagner (1979a) and Devroye and Wagner (1979b). Later, McDiarmid’s (McDiarmid, 1989), concentration inequalities facilitated new bounds on generalization error (e.",
      "startOffset" : 2,
      "endOffset" : 463
    }, {
      "referenceID" : 4,
      "context" : "This notion of robustness is rooted in robust optimization (Ben-tal and Nemirovski, 1998; Ben-Tal and Nemirovski, 1999; Bertsimas and Sim, 2004) where a decision maker aims to find a solution x that minimizes a (parameterized) cost function f(x, ξ) with the knowledge that the unknown true parameter ξ may deviate from the observed parameter ξ̂.",
      "startOffset" : 59,
      "endOffset" : 144
    }, {
      "referenceID" : 10,
      "context" : "Robust optimization was introduced in machine learning tasks to handle exogenous noise (e.g., Bhattacharyya et al., 2004; Shivaswamy et al., 2006; Globerson and Roweis, 2006), i.",
      "startOffset" : 87,
      "endOffset" : 174
    }, {
      "referenceID" : 13,
      "context" : "While it is known having a finite VC-dimension (Vapnik and Chervonenkis, 1991) or equivalently being CVEEEloo stable (Mukherjee et al.",
      "startOffset" : 47,
      "endOffset" : 78
    }, {
      "referenceID" : 9,
      "context" : "Recently, Shalev-Shwartz et al. (2009) proposed a weaker notion of stability that is necessary and sufficient for a learning algorithm to be consistent and generalizing, provided that the problem itself is learnable.",
      "startOffset" : 10,
      "endOffset" : 39
    }, {
      "referenceID" : 9,
      "context" : "Recently, Shalev-Shwartz et al. (2009) proposed a weaker notion of stability that is necessary and sufficient for a learning algorithm to be consistent and generalizing, provided that the problem itself is learnable. However, learnability requires that the convergence rate is uniform with respect to all distributions, and is hence a fairly strong assumption. In particular, the standard supervised learning setup where the hypothesis set is the set of measurable functions is not learnable since no algorithm can achieve a uniform convergence rate (cf Devroye et al., 1996). Indeed, as the authors of Shalev-Shwartz et al. (2009) stated, for supervised learning problem learnability is equivalent to the generalizability of ERM, and hence reduce to the aforementioned results on ERM algorithms.",
      "startOffset" : 10,
      "endOffset" : 632
    }, {
      "referenceID" : 12,
      "context" : "We recall the following standard notion of covering number from van der Vaart and Wellner (2000). Definition 1 (cf.",
      "startOffset" : 72,
      "endOffset" : 97
    }, {
      "referenceID" : 12,
      "context" : "We recall the following standard notion of covering number from van der Vaart and Wellner (2000). Definition 1 (cf. van der Vaart and Wellner (2000)) For a metric space S, ρ and T ⊂ S we say that T̂ ⊂ S is an ǫ-cover of T , if ∀t ∈ T , ∃t̂ ∈ T̂ such that ρ(t, t̂) ≤ ǫ.",
      "startOffset" : 72,
      "endOffset" : 149
    }, {
      "referenceID" : 8,
      "context" : "Consider the standard SVM formulation (Cortes and Vapnik, 1995; Schölkopf and Smola, 2002) Minimize:w,d c‖w‖ 2 H + 1 n n ∑",
      "startOffset" : 38,
      "endOffset" : 90
    }, {
      "referenceID" : 11,
      "context" : "Lasso (Tibshirani, 1996), which is the following regression formulation: min w : 1 n n ∑",
      "startOffset" : 6,
      "endOffset" : 24
    }, {
      "referenceID" : 1,
      "context" : "This indeed agrees with Bartlett (1998), where the author showed (using a different approach based on fat-shattering dimension) that for neural networks, the weight plays a more important role than the number of hidden units.",
      "startOffset" : 24,
      "endOffset" : 40
    } ],
    "year" : 2010,
    "abstractText" : "We derive generalization bounds for learning algorithms based on their robustness: the property that if a testing sample is “similar” to a training sample, then the testing error is close to the training error. This provides a novel approach, different from the complexity or stability arguments, to study generalization of learning algorithms. We further show that a weak notion of robustness is both sufficient and necessary for generalizability, which implies that robustness is a fundamental property for learning algorithms to work.",
    "creator" : "LaTeX with hyperref package"
  }
}