{
  "name" : "1506.04422.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Fast Incremental Gaussian Mixture Model - Submission to PLOS Journals",
    "authors" : [ "Rafael Pinto", "Paulo Engel" ],
    "emails" : [ "rcpinto@inf.ufrgs.br", "engel@inf.ufrgs.br" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 6.\n04 42\n2v 1\n[ cs\n.L G\n] 1\n4 Ju\nThis work builds upon previous efforts in online incremental learning, namely the Incremental Gaussian Mixture Network (IGMN). The IGMN is capable of learning from data streams in a single-pass by improving its model after analyzing each data point and discarding it thereafter. Nevertheless, it suffers from the scalability point-of-view, due to its asymptotic time complexity of O ( NKD3 )\nfor N data points, K Gaussian components and D dimensions, rendering it inadequate for high-dimensional data. In this paper, we manage to reduce this complexity to O ( NKD2 )\nby deriving formulas for working directly with precision matrices instead of covariance matrices. The final result is a much faster and scalable algorithm which can be applied to high dimensional tasks. This is confirmed by applying the modified algorithm to high-dimensional classification datasets."
    }, {
      "heading" : "1 Introduction",
      "text" : "The Incremental Gaussian Mixture Network (IGMN) [?,?] is a supervised algorithm which approximates the EM algorithm [?]. It creates and continually adjusts a probabilistic model consistent to all sequentially presented data, after each data point presentation, and without the need to store any past data points. Its learning process is aggressive, meaning that only a single scan through the data is necessary to obtain a consistent model.\nIGMN adopts a Gaussian mixture model of distribution components that can be expanded to accommodate new information from an input data point, or reduced if spurious components are identified along the learning process. Each data point assimilated by the model contributes to the sequential update of the model parameters based on the maximization of the likelihood of the data. The parameters are updated through the accumulation of relevant information extracted from each data point.\nThe IGMN is capable of supervised learning, simply by assigning any of its input vector elements as outputs (any element can be used to predict any other element, like autoassociative neural networks [?]). This feature is useful for simultaneous learning of forward and inverse kinematics, as well as for simultaneous learning of a value function and a policy in reinforcement learning [?].\nHowever, the IGMN suffers from cubic time complexity due to matrix inversion operations and determinant computations. Its time complexity is of O ( NKD3 ) , where\nPLOS 1/8\nN is the number of data points, K is the number of Gaussian components and D is the problem dimension. It makes the algorithm prohibitive for high-dimensional tasks (like visual tasks) and thus of limited use. One solution would be to use diagonal covariance matrices, but this decreases the quality of the results, as already reported in previous work [?,?]. In this work, we propose the use of rank-one updates for both inverse matrices and determinants applied to full covariance matrices, thus reducing the time complexity to O ( NKD2 )\nfor learning while keeping the quality of a full covariance matrix solution.\nFor the specific case of the IGMN algorithm, to the best of our knowledge, this has not been tried before, although we can find similar efforts for related algorithms. In [?], rank-one updates were applied to an iterated linear discriminant analysis algorithm in order to decrease the complexity of the algorithm. Rank-one updates were also used in [?], where Gaussian models are employed for feature selection. Finally, in [?], the same kind of optimization was applied to Maximum Likelihood Linear Transforms (MLLT).\nThe next Section describes the algorithm in more detail with the latest improvements to date. Section 3 describes our improvements to the algorithm. Section 4 shows the experiments and results obtained from both versions of the IGMN for comparison, and Section 5 finishes this work with concluding remarks."
    }, {
      "heading" : "2 Incremental Gaussian Mixture Network",
      "text" : "In the next subsections we describe the current version of the IGMN algorithm."
    }, {
      "heading" : "2.1 Learning",
      "text" : "The algorithm starts with no components, which are created as necessary (see subsection 2.2). Given input x (a single instantaneous data point), the IGMN algorithm processing step is as follows. First, the squared Mahalanobis distance d2(x, j) for each component j is computed:\nd2M (x, j) = (x− µj)TC−1j (x − µj) (1)\nwhere µj is the j th component mean, Cj its full covariance matrix . If any d 2(x, j) is smaller than than χ2D,1−β (the 1− β percentile of a chi-squared distribution with D degrees-of-freedom, where D is the input dimensionality and β is a user defined meta-parameter, e.g., 0.1), an update will occur, and posterior probabilities are calculated for each component as follows:\np(x|j) = 1 (2π)D/2 √ |Cj | exp\n(\n−1 2 d2M (x, j)\n)\n(2)\np(j|x) = p(x|j)p(j) K ∑\nk=1\np(x|k)p(k) ∀j (3)\nwhere K is the number of components. Now, parameters of the algorithm must be updated according to the following equations:\nvj(t) = vj(t− 1) + 1 (4)\nspj(t) = spj(t− 1) + p(j|x) (5)\nPLOS 2/8\nej = x− µj(t− 1) (6)\nωj = p(j|x) spj\n(7)\n∆µj = ωjej (8)\nµj(t) = µj(t− 1) + ∆µj (9)\ne∗j = x− µj(t) (10)\nCj(t) = (1 − ωj)Cj(t− 1) + ωje∗je∗Tj −∆µj∆µTj (11)\np(j) = spj\nM ∑\nq=1\nspq\n(12)\nwhere spj and vj are the accumulator and the age of component j, respectively, and p(j) is its prior probability."
    }, {
      "heading" : "2.2 Creating New Components",
      "text" : "If the update condition in the previous subsection is not met, then a new component j is created and initialized as follows:\nµj = x; spj = 1; vj = 1; p(j) = 1\nK ∑\ni=1\nspi\n; Cj = σ 2 iniI\nwhere K already includes the new component and σini can be obtained by:\nσini = δstd(x) (13)\nwhere δ is a manually chosen scaling factor (e.g., 0.01) and std is the standard deviation of the dataset. Note that the IGMN is an online and incremental algorithm and therefore it may be the case that we do not have the entire dataset to extract descriptive statistics. In this case the standard deviation can be just an estimation (e.g., based on sensor limits from a robotic platform), without impacting the algorithm."
    }, {
      "heading" : "2.3 Removing Spurious Components",
      "text" : "A component j is removed whenever vj > vmin and spj < spmin, where vmin and spmin are manually chosen (e.g., 5.0 and 3.0, respectively). In that case, also, p(k) must be adjusted for all k ∈ K, k 6= j, using (12). In other words, each component is given some time vmin to show its importance to the model in the form of an accumulation of its posterior probabilities spj .\nPLOS 3/8"
    }, {
      "heading" : "2.4 Inference",
      "text" : "In the IGMN, any element can be predicted by any other element. This is done by reconstructing data from the target elements (xt, a slice of the entire input vector x) by estimating the posterior probabilities using only the given elements (xi, also a slice of the entire input vector x), as follows:\np(j|xi) = p(xi|j)p(j)\nM ∑\nq=1\np(xi|q)p(q) ∀j (14)\nIt is similar to (3), except that it uses a modified input vector xi with the target elements xt removed from calculations. After that, xt can be reconstructed using the conditional mean equation:\nx̂t =\nM ∑\nj=1\np(j|xi)(µj,t +Cj,tiC−1j,i (xi − µj,i)) (15)\nwhere Cj,ti is the submatrix of the jth component covariance matrix associating the unknown and known parts of the data, Cj,i is the submatrix corresponding to the known part only and µj,i is the jth’s component mean without the element corresponding to the target element."
    }, {
      "heading" : "3 Fast IGMN",
      "text" : "One of the contributions of this work lies in the fact that Equation 1 (the squared Mahalanobis distance) requires a matrix inversion, which has a asymptotic time\ncomplexity of O ( D3 ) , for D dimensions (O ( Dlog27+O ( 1 ) ) for the Strassen algorithm or at best O ( D2.3728639 )\nwith the most recent algorithms to date [?]). This renders the entire IGMN algorithm as impractical for high-dimension tasks. Here we show how to work directly with the inverse of covariance matrix (also called the precision or concentration matrix) for the entire procedure, therefore avoiding costly inversions.\nFirstly, let us denote C−1 = Λ, the precision matrix. Our task is to adapt all equations involving C to instead use Λ.\nWe now proceed to adapt Equation 11 (covariance matrix update). This equation can be seen as a sequence of two rank-one updates to the C matrix, as follows:\nC̄j(t) = (1− ωj)Cj(t− 1) + ωje∗je∗Tj (16)\nCj(t) = C̄j(t)−∆µj∆µTj (17) This allows us to apply the Sherman-Morrison formula [?]:\n(A+ uvT )−1 = A−1 − A −1uvTA−1\n1 + vTA−1u (18)\nThis formula shows how to update the inverse of a matrix plus a rank-one update. For the second update, which subtracts, the formula becomes:\n(A− uvT )−1 = A−1 + A −1uvTA−1\n1− vTA−1u (19)\nIn the context of IGMN, we have A = (1 − ω)Cj(t− 1) = (1− ω)Λ−1j (t− 1) and u = v = √ ωe∗ for the first update, while for the second one we have A = C̄j(t) and\nPLOS 4/8\nu = v = ∆µj . Rewriting 18 and 19 we get (for the sake of compactness, assume all subscripts for Λ and ∆µ to be j):\nΛ̄(t) = Λ(t− 1) 1− ω −\nω (1−ω)2Λ(t− 1)e∗e∗TΛ(t− 1)\n1 + ω1−ωe ∗TΛ(t− 1)e∗ (20)\nΛ(t) = Λ̄(t) + Λ̄(t)∆µ∆µT Λ̄(t)\n1−∆µT Λ̄(t)∆µ (21)\nThese two equations allow us to update the precision matrix directly, eliminating the need for the covariance matrix C. They have O ( N2 )\ncomplexity due to matrix-vector products.\nFollowing on the adaptation of the IGMN equations, Equation 1 (the squared Mahalanobis distance) allows for a direct substituion, yielding the following new equation:\nd2M (x, j) = (x− µj)TΛj(x− µj) (22) which now has a O ( N2 )\ncomplexity, since there is no matrix inversion as the original equation. After removing the cubic complexity from this step, the determinant computation will be dealt with next.\nSince the determinant of the inverse of a matrix is simply the inverse of the determinant, it is sufficient to invert the result. But computing the determinant itself is also a O ( D3 )\noperation, so we will instead perform rank-one updates using the Matrix Determinant Lemma [?], which states the following:\n|A+ uvT | = |A|(1 + vTA−1u) (23) |A− uvT | = |A|(1− vTA−1u) (24)\nSince the IGMN covariance matrix update involves a rank-two update, adding a term and then subtracting one, both rules must be applied in sequence, similar to what has been done with the Λ equations. Equations 16 and 17 may be reused here, together with the same substitutions previously showed, leaving us with the following new equations for updating the determinant (again, j subscripts were dropped):\n|C̄(t)| = (1− ω)D|C(t− 1)| ( 1 + ω\n1− ω e ∗TΛ(t− 1)e∗\n)\n(25)\n|C(t)| = |C̄(t)|(1 −∆µT Λ̄(t)∆µ) (26) This was the last source of cubic complexity, which is now quadratic. Finishing the adaptation in the learning part of the algorithm, we just need to\ndefine the initialization for Λ for each component. What previously was Cj = σ 2 iniI now becomes Λj = σ −2 iniI, the inverse of the variances of the dataset. Since this matrix is diagonal, there are no costly inversions involved. And for initializing the determinant |C|, just set it to ∏σ2ini, which again takes advantage of the initial diagonal matrix to avoid costly operations. Note that we keep the precision matrix Λ, but the determinant of the covariance matrix C instead. See algorithms 1 to 3 for a summary of the new learning algorithm (excluding pruning, for brevity).\nFinally, the inference Equation 15 must also be updated in order to allow the IGMN to work in supervised mode. This can be accomplished by the use of a block matrix decomposition (note that here C is just another sub-matrix, not the covariance matrix as used before):\nPLOS 5/8\nAlgorithm 1 Fast IGMN Learning\nInput: δ,β,X K > 0, σ−1ini = (δstd(X))\n−1,M = ∅ for all input data vector x ∈ X do if K = 0 or ∃j, d2M (x, j) < χ2D,1−β then update(x)\nelse\nM ← M ∪ create(x) end if\nend for\nAlgorithm 2 update\nInput: x\nfor all Gaussian component j ∈ M do Compute equations 1 to 12 substituting 1 for 22 and 11 for 20 and 21 Compute equations 25 and 26 end for\nΛ =\n[\nA B C D\n]−1\n=\n[\nX Y Z W\n]\n= [\n(A−BD−1C)−1 −A−1B(D−CA−1B)−1 −D−1C(A−BD−1C)−1 (D−CA−1B)−1\n]\nHere, according to Equation 15, we need C and A−1. But since the terms that constitute these sub-matrices are relative to the original covariance matrix (which we do not have), they must be extracted from the precision matrix directly. Looking at the decomposition, it is clear that YW−1 = −A−1B = −CA−1 (the terms between parenthesis in Y and W cancel each other, while B = CT due to symmetry). So Equation 15 can be rewritten as:\nx̂t =\nM ∑\nj=1\np(j|xi)(µj,t −YW−1(xi − µj,i)) (27)\nwhere Y and W can be extracted directly from Λ. However, we still need to compute the inverse of W. So we can say that this particular implementation has O ( NKD2 ) complexity for learning and O ( NKD3 )\nfor inference. The reason for us to not worry about that is that d = i+ o, where i is the number of inputs and o is the number of outputs. The inverse computation acts only upon the output portion of the matrix. Since, in general, o ≪ i (in many cases even o = 1), the impact is minimal, and the same applies to the YW−1 product. In fact, Weka (the data mining platform used in this work [?]) allows for only 1 output, leaving us with just scalar operations."
    }, {
      "heading" : "4 Experiments",
      "text" : "In order to evaluate the performance of the proposed algorithm, 11 classification tasks (Table 1) were given to the original and improved IGMN algorithms (δ = 1 and β = 0, so a single component was created for each run and we could focus on speed ups only due to dimensionality). Results were obtained from 2-fold cross-validation and statistical significances came from paired t-tests with p = 0.05.\nThis experiment was meant to verify that both IGMN implementations produce exactly the same results, which was confirmed, as well as to show that the proposed\nPLOS 6/8\nAlgorithm 3 create\nInput: x\nK ← K + 1 return new Gaussian component K with µK = x, ΛK = σ −1 iniI, |CK | = |ΛK |−1, spj = 1, vj = 1, p(j) = 1\nK ∑\nk=1\nspi\nimprovements really deliver the expected speed up (the Weka packages for both variations of the IGMN algorithm can be found at http://www.inf.ufrgs.br/~rcpinto). This was also confirmed, as can be seen in tables 2 and 3 (note that the experiments were divided into training and test phases just for comparison purposes, but IGMN is in fact an online algorithm; also note that standard deviations were rounded to 3 decimal places and, in fact, there are not any null standard deviations in the results). Our improved algorithm could deliver a speed up of 2 orders of magnitude in training time (learning) for the CIFAR-10 subset, which follows our expectations according to the new time complexity. Datasets with less dimensions could benefit from the improvements too, albeit in a smaller scale, which was also expected. The other confirmation came from the testing times (inference): they were also improved, since the inverse matrix computation was eliminated from the probability density equation, which is also necessary for inference, and the matrix multiplications and inversions are actually scalar operations, having no impact. In fact, the speed up for inference was around 3 orders of magnitude for the CIFAR-10 subset.\nAlthough not the focus of this work, we could also observe the accuracy of the IGMN algorithm on the tested datasets in comparison to other algorithms available in the Weka software, like Support Vector Machines (SVM) and the state-of-the-art\nPLOS 7/8\nDropout Neural Networks [?] (with 50 hidden neurons, 50% dropout for the hidden layer and 20% dropout for the input layer; the specific implementation can be found at https://github.com/amten/NeuralNetwork). It was statistically similar to them with β = 0.001 (now more than one Gaussian component was allowed) and tuning the δ parameter by 2-fold cross-validation using 3 different values (0.01, 0.1 and 1), but with the additional benefit of a single-scan through data, allowing it to operate on data streams. Results are shown in table 4 (note that, for this experiment, a smaller subset of CIFAR-10 was used, in order to compensate for the higher computational requirements of more Gaussian components)."
    }, {
      "heading" : "5 Conclusion",
      "text" : "We have shown how to work directly with precision matrices in the IGMN algorithm, avoiding costly matrix inversions by performing rank-one updates. The determinant computations were also avoided using a similar method, effectively eliminating any source of cubic complexity for the learning algorithm. This resulted in substantial speed ups for high-dimensional datasets, turning the IGMN into a good option for this kind of tasks. The inference operation still has cubic complexity, but we argue that it has a much smaller impact on the total runtime of the algorithm, since the number of outputs is usually much smaller than the number of inputs. This was confirmed for one-dimensional outputs, which require only scalar operations.\nIn general, we could see that the fast IGMN is a good option for supervised learning, with low runtimes and good accuracy after adjusting the two main meta-parameters β and δ. It should be noted that this is achieved with a single-pass through the data, making it also a valid option for data streams.\nPLOS 8/8"
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "This work builds upon previous efforts in online incremental learning, namely the Incremental Gaussian Mixture Network (IGMN). The IGMN is capable of learning from data streams in a single-pass by improving its model after analyzing each data point and discarding it thereafter. Nevertheless, it suffers from the scalability point-of-view, due to its asymptotic time complexity of O ( NKD ) for N data points, K Gaussian components and D dimensions, rendering it inadequate for high-dimensional data. In this paper, we manage to reduce this complexity to O ( NKD ) by deriving formulas for working directly with precision matrices instead of covariance matrices. The final result is a much faster and scalable algorithm which can be applied to high dimensional tasks. This is confirmed by applying the modified algorithm to high-dimensional classification datasets.",
    "creator" : "LaTeX with hyperref package"
  }
}