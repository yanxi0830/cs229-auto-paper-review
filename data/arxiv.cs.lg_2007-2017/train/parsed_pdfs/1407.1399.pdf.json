{
  "name" : "1407.1399.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Generalized Higher-Order Tensor Decomposition via Parallel ADMM",
    "authors" : [ "Fanhua Shang", "Yuanyuan Liu", "James Cheng" ],
    "emails" : [ "jcheng}@cse.cuhk.edu.hk;", "yyliu@se.cuhk.edu.hk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 7.\n13 99\nv1 [\ncs .N\nA ]\n5 J\nul 2\n01 4"
    }, {
      "heading" : "Introduction",
      "text" : "The term tensor used in the context of this paper refers to a multi-dimensional array, also known as a multi-way or multi-mode array. For example, if X ∈ RI1×I2×I3 , then we say X is a third-order tensor, where order is the number of ways or modes of the tensor. Thus, vectors and matrices are first-order and second-order tensors, respectively. Higher-order tensors arise in a wide variety of application areas, such as machine learning (Tomioka and Suzuki, 2013; Signoretto et al., 2014), computer vision (Liu et al., 2009), data mining (Yilmaz et al., 2011; Morup, 2011; Narita et al., 2012; Liu et al., 2014), numerical linear algebra (Lathauwer et al., 2000a; 2000b), and so on. Especially, with the rapid development of modern computer technology in recent years, tensors are becoming increasingly ubiquitous such as multi-channel images and videos, and have become increasingly popular (Kolda and Bader, 2009). When working with high-order tensor data, various new computational\nCopyright c© 2014, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nchallenges arise due to the exponential increase in time and memory space complexity when the number of orders increases. This is called the curse of dimensionality. In practice, the underlying tensor is often low-rank, even though the actual data may not be due to noise or arbitrary errors. Essentially, the major component contained in the given tensor is often governed by a relatively small number of latent factors.\nOne standard tool to alleviate the curse is tensor decomposition. Decomposition of high-order tensors into a small number of factors has been one of the main tasks in multi-way data analysis, and commonly takes two forms: Tucker decomposition (Tucker, 1966) and CANDECOMP/PARAFAC (CP) (Harshman, 1970) decomposition. There are extensive studies in the literature for finding the Tucker decomposition and the CP decomposition for higherorder tensors (Kolda and Bader, 2009). In those tensor decomposition methods, their goal is to (approximately) reconstruct the input tensor as a sum of simpler components with the hope that these simpler components would reveal the latent structure of the data. However, existing tensor decomposition methods face three major challenges: rank selection, outliers and gross corruptions, and computational efficiency. Since the Tucker and CP decomposition methods are based on least-squares approximation, they are also very sensitive to outliers and gross corruptions (Goldfarb and Qin, 2014). In addition, the performance of those methods is usually sensitive to the given ranks of the involved tensor (Liu et al., 2009). To address the problems, we propose two robust and parallel higher-order tensor decomposition methods with trace norm regularization.\nRecently, much attention has been drawn to the low-rank tensor recovery problem, which arises in a number of realword applications, such as 3D image recovery, video inpainting, hyperspectral data recovery, and face reconstruction. Compared with matrix-based analysis methods, tensorbased multi-linear data analysis has shown that tensor models are capable of taking full advantage of the high-order structure to provide better understanding and more precision. The key idea of low-rank tensor completion and recovery methods is to employ matrix trace norm minimization (also known as the nuclear norm, which is the convex surrogate of the rank of the involved matrix). In addition, there are some theoretical developments that guarantee reconstruction\nof a low-rank tensor from partial measurements or grossly corrupted observations via solving the trace norm minimization problem under some reasonable conditions (Tomioka et al., 2011; Shi et al., 2013). Motivated by the recent progress in tensor completion and recovery, one goal of this paper is to extend the trace norm regularization to robust higherorder tensor decomposition.\nDifferent from existing tensor decomposition methods, we first propose a parallel trace norm regularized tensor decomposition method, which can automatically determine the number of factors in each mode through our optimization scheme. In other words, this method does not require the rank of each mode to be specified beforehand. In addition, by considering the low-rank structure of the observed tensor and further improving the scalability of our convex method, we analyze the equivalent relationship of the trace norm between a low-rank tensor and its core tensor. Then, we cast the non-convex trace norm regularized higher-order orthogonal iteration model into a weighted combination of multiple much-smaller-scale matrix trace norm minimization. Moreover, we design two parallel alternating direction methods of multipliers (ADMM) to solve the proposed problems, which are shown to be fast, insensitive to initialization and robust to noise and/or outliers with extensive experiments."
    }, {
      "heading" : "Notations and Related Work",
      "text" : "We first introduce the notations, and more details can be seen in Kolda and Bader (2009). An N th-order tensor is denoted by a calligraphic letter, e.g., T ∈ RI1×I2×···×IN , and its entries are denoted by ti1···in···iN , where in ∈ {1, · · · , In} for 1 ≤ n ≤ N . Fibers are the higher-order analogue of matrix rows and columns. The mode-n fibers are vectors ti1···in−1in+1···iN that are obtained by fixing the values of {i1, · · · , iN}\\in.\nThe mode-n unfolding, also known as matricization, of an N th-order tensor T is denoted by T(n) ∈ RIn×Πj 6=nIj and arranges the mode-n fibers to be the columns of the resulting matrix T(n) such that the mode-n fiber becomes the row index and all other (N − 1) modes become the column indices. The tensor element (i1, i2, · · · , iN) is mapped to the matrix element (in, j), where\nj = 1 +\nN∑\nk=1,k 6=n\n(ik − 1)Jk with Jk = k−1∏\nm=1,m 6=n\nIm.\nThe inner product of two same-sized tensors A ∈ RI1×I2× ···×IN and B ∈ RI1×I2×···×IN is the sum of the product of their entries, < A,B >=∑\ni1,···iN ai1···iN bi1···iN . The Frobenius norm of an N th-\norder T is defined as:\n‖T ‖F :=\n√√√√ I1∑\ni1=1\n· · · IN∑\niN=1\nt2i1···iN .\nLet A and B be two matrices of size m × n and p × q, respectively. The Kronecker product of two matrices A and B, denoted by A⊗B, is an mp× nq matrix given by:\nA⊗B = [aijB]mp×nq.\nThe n-mode matrix product of a tensor T with a matrix U ∈ R\nJ×In , denoted by T ×n U ∈ RI1×···In−1×J×In+1×···×IN , is defined as:\n(T ×n U)i1···in−1jin+1···iN = In∑\nin=1\nti1i2···iNujin ."
    }, {
      "heading" : "Tensor Decomposition",
      "text" : "We will review two popular models for tensor decomposition, i.e., the Tucker decomposition and the CANDECOMP/PARAFAC (CP) decomposition. It is well known that finding the CP decomposition with the minimum tensor rank is a hard problem, and there is no straightforward algorithm for computing the rank for higher-order tensors (Hillar and Lim, 2013). The Tucker decomposition decomposes a given tensor T into a core tensor multiplied by a factor matrix along each mode as follows:\nT = G ×1 U1 ×2 · · · ×N UN , (1)\nwhere Un ∈ RIn×Rn are the factor matrices, which can be thought of as the principal components in each mode, and the entries of the core tensor G ∈ RR1×R2···×RN show the level of interaction between the different components. Since the decomposition rank Rn (n = 1, · · · , N) is in general much smaller than In (n = 1, · · · , N), the core tensor G can be thought of as a low-rank version of T (e.g., the Tucker decomposition of a third-order tensor is illustrated in Figure 1). In this sense, the storage of the Tucker decomposition form can be significantly smaller than that of the original tensor. Moreover, unlike the rank of the tensor, Rn, i.e., the mode-n rank (n = 1, · · · , N), is the rank of the mode-n unfolding, and is clearly computable. Hence, we are particularly interested in extending the Tucker decomposition for tensor analysis.\nIf the factor matrices of the Tucker decomposition are constrained orthogonal, the decomposition form is referred to as the higher-order singular value decomposition (HOSVD, Lathauwer et al., 2000a) or higher-order orthogonal iteration (HOOI, Lathauwer et al., 2000b), where the latter leads to the estimation of best rank(R1, R2, . . . , RN ) approximations while the truncation of HOSVD may achieve a good rank-(R1, R2, . . . , RN ) approximation but in general not the best possible one (Lathauwer et al., 2000b). Therefore, HOOI is the most widely used tensor decomposition method (Kolda and Bader, 2009), and takes the following form\nmin G,Un\n‖T − G ×1 U1 ×2 · · · ×N UN‖ 2 F ,\ns.t., UTn Un = IRn , n = 1, · · · , N. (2)"
    }, {
      "heading" : "Convex Tensor Decomposition Method",
      "text" : ""
    }, {
      "heading" : "Convex Tensor Decomposition Model",
      "text" : "Given a tensor T , our goal is to find a low-rank tensor X , in order to minimize the Frobenius norm of their difference as follows:\nmin X\n1 2 ‖X − T ‖2F . (3)\nDifferent from the matrix case, the low-rank tensor estimation problem (3) is in general hard to solve (Narita et al., 2012). Following the progress in tensor completion, we cast it into a (weighted) trace norm minimization problem:\nmin X\nN∑\nn=1\n‖X(n)‖tr + λ\n2 ‖X − T ‖2F , (4)\nwhere ‖X(n)‖tr denotes the trace norm of the unfolded matrix X(n), i.e., the sum of its singular values, λ > 0 is a regularization parameter. For handling the unbalanced target tensor, we briefly introduce the preselected weights αn ≥ 0 (satisfying ∑ n αn = 1) to the trace norm term in (4)."
    }, {
      "heading" : "Parallel Optimization Algorithm",
      "text" : "Due to the interdependent matrix trace norm terms, the proposed tensor decomposition model (4) is very difficult to solve. Thus, we introduce some auxiliary variables Mn into the model (4) and reformulate it into the following equivalent form:\nmin X ,{Mn}\nN∑\nn=1\n‖Mn,(n)‖tr + λ\n2 ‖X − T ‖2F ,\ns.t., Mn = X , n = 1, · · · , N.\n(5)\nIn the following, we will design a parallel alternating direction method of multipliers (ADMM) for solving the problem (5). The algorithm decomposes the original problem into smaller subproblems and solves them individually in parallel at each iteration. The parallel ADMM for the problem (5) is derived by minimizing the augmented Lagrange function Lµ with respect to (X , {Mn}) in parallel, and then updating the multiplier tensor Yn. But the parallelization is likely to diverge, therefore, it is necessary to modify the common algorithm in a certain way to guarantee its convergence. Several variants of parallel ADMM have been proposed in He (2009) and Deng et al., (2013) by taking additional correction steps at every iteration. Similar to Deng et al., (2013), we add some proximal terms to each subproblems and attach a relaxation parameter γ > 0 for the update of the penalty parameter µ > 0.\nComputing {Mk+1n , n = 1, · · · , N}: By keeping all other variables fixed, the optimal Mkn is the solution to the following problem:\nmin Mn\n‖Mn, (n)‖tr + µ\n2 ‖Mn −X\nk + Ykn/µ‖ 2 F\n+ τn 2 ‖Mn −M k n‖ 2 F ,\n(6)\nAlgorithm 1 Solving problem (5) via parallel ADMM Input: Given T , λ, and µ. Initialize: M0n = X\n0 = Y0n = 0, ∀n ∈ {1, · · · , N}. 1: while not converged do 2: for n = 1, · · · , N do 3: Update Mk+1n by (7),\nwhere UnSnV Tn = µX k(n)−Y k (n)+τnM k (n) µ+τn .\n4: end for 5: Update X k+1 by (9). 6: for n = 1, · · · , N do 7: Yk+1n = Y k n + γµ(M k+1 n −X\nk+1). 8: end for 9: Check the convergence condition,\n‖X k+1 − T ‖F < Tol. 10: end while 11: G = X k+1 ×1 UT1 · · · ×N U T N . Output: X k, G, and Un, n = 1, · · · , N .\nwhere τn > 0 is a constant for the proximal term ‖Mn − Mkn‖ 2 F . Following (Cai et al., 2010), we obtain a closedform solution to the problem (6) via the following proximal operator of the trace norm:\nMk+1n = refold(prox 1 µ+τn\n( µX k(n) − Y k (n) + τnM k (n)\nµ+ τn )),\n(7) where refold(·) denotes the refolding of the matrix into a tensor, i.e., the reverse process of unfolding.\nComputing X k+1: The optimal X k+1 with all other variables fixed is the solution to the following problem:\nmin X\nλ 2 ‖X − T ‖2F +\nN∑\nn=1\nµ 2 ‖Mkn −X + Y k n/µ‖ 2 F\n+ τN+1 2 ‖X − X k‖2F ,\n(8)\nwhere τN+1 > 0 is a constant for the proximal term ‖X −X k‖2F . Since the problem (8) is a smooth convex optimization problem, it is easy to show that the optimal solution to (8) is given by\nX k+1 =\n∑N n=1(µM k n + Y k n) + λT + τN+1X k\nNµ+ λ+ τN+1 . (9)\nBased on the description above, we develop a parallel ADMM algorithm for the convex tensor decomposition (CTD) problem (5), as outlined in Algorithm 1. In Algorithm 1, we use a Jacobi-type scheme to update (N + 1) blocks of variables, {M1, · · · ,MN} and X . By the definition f(M1, · · · ,MN ) := ∑N n=1 ‖Mn,(n)‖tr and g(X ) := λ 2 ‖X − T ‖ 2 F , it is easy to verify that the problem (5) and Algorithm 1 satisfy the convergence conditions in Deng et al., (2013).\nTheorem 1 Let τi > µ( N2−γ − 1), i = 1, . . . , N + 1. Then the sequence {Mk1 , · · · ,M k N ,X\nk} generated by Algorithm 1 converges to an optimal solution {M∗1, · · · ,M ∗ N ,X ∗} of\nthe problem (5). Hence, the sequence {X k} converges to an optimal solution to the low-rank tensor decomposition problem (4).\nOur convex Tucker decomposition method employs matrix trace norm regularization and uses the singular value decomposition (SVD) in Algorithm 1, which becomes a little slow or even not applicable for large-scale problems. Motivated by this, we will propose a scalable non-convex lowrank tensor decomposition method."
    }, {
      "heading" : "Non-Convex Tensor Decomposition Method",
      "text" : "Several researchers (Keshavan et al., 2010; Wen et al., 2012) have provided some matrix rank estimation strategies to compute some good values (r1, r2, . . . , rN ) for the N-rank of the involved tensor. Thus, we only set some relatively large integers (R1, R2, . . . , RN ) such that Rn ≥ rn, n = 1, · · · , N .\nTheorem 2 Let X ∈ RI1×I2×···×IN with N -rank= (r1, r2, · · · , rN ) and G ∈ RR1×R2×···×RN satisfy X = G ×1 U1 · · · ×N UN , and UTn Un = IRn , n = 1, 2, · · · , N , then\n‖X(n)‖tr = ‖G(n)‖tr, n = 1, 2, · · · , N. (10)\nThe proof of Theorem 2 can be found in the supplemental material. According to the theorem, it is cleat that although the core tensor G of size (R1, R2, · · · , RN ) has much smaller sizes than the original tensor X (usually, Rn ≪ In, n = 1, 2, · · · , N ), their trace norm is identical. In other words, each unfolding G(n) ∈ RRn×Πj 6=nRj of the core tensor G has much smaller sizes than that of the original tensor, X(n) ∈ RIn×Πj 6=nIj . Therefore, we use the trace norm of each unfolding of the core tensor to replace that of the original tensor."
    }, {
      "heading" : "Generalized HOOI Model with Trace Norm Penalties",
      "text" : "According to the analysis above, our trace norm regularized HOOI model is formulated into the following form:\nmin G,{Un}\nN∑\nn=1\n‖G(n)‖tr + λ\n2 ‖T − G ×1 U1 · · · ×N UN‖\n2 F ,\ns.t., UTn Un = IRn , n = 1, 2, · · · , N. (11)\nThe core tensor trace norm regularized HOOI model (11), also called Generalized HOOI, can alleviate the SVD computational burden of large unfolded matrices involved in the convex Tucker decomposition problem (4). Furthermore, we use the trace norm regularization term in (11) to promote the robustness of the rank selection, while the original Tucker decomposition method is usually sensitive to the given ranks (R1, R2, · · · , RN ) (Liu et al., 2009). Due to the interdependent matrix trace norm terms, we apply the variablesplitting technique and introduce some auxiliary variables Gn ∈ RRn×Πj 6=nRj into our model (11), and then reformu-\nlate the model (11) into the following equivalent form:\nmin G,{Un,Gn}\nN∑\nn=1\n‖Gn‖tr + λ\n2 ‖T − G ×1 U1 · · · ×N UN‖\n2 F ,\ns.t., Gn = G(n), U T n Un = IRn , n = 1, 2, · · · , N.\n(12)"
    }, {
      "heading" : "Parallel Optimization Procedure",
      "text" : "In this part, we will also propose a parallel ADMM algorithm to solve the problem (12).\nUpdating {Gk+1, Uk+11 , · · · , U k+1 N }: The optimization problem with respect to G and {U1, · · · , UN} is formulated as follows:\nmin G,{Un}\nN∑\nn=1\nµ 2 ‖G(n) −G k n + Y k n /µ‖ 2 F\n+ λ\n2 ‖T − G ×1 U1 · · · ×N UN‖\n2 F .\n(13)\nFollowing (Lathauwer et al., 2000b), it is sufficient to determine the matrices {U1, · · · , UN} for the optimization of the problem (13). For any estimate of these matrices, the optimal solution with respect to G is given by the following theorem.\nTheorem 3 For given matrices {U1, · · · , UN}, the optimal core tensor G to the optimization problem (13) is given by\nGk+1 = λ\nλ+Nµ T ×1 (U\nk 1 ) T · · · ×N (U k N ) T\n+ µ\nλ+Nµ\nN∑\nn=1\nrefold(Gkn − Y k n /µ).\n(14)\nThe proof of Theorem 3 can be found in the supplemental material. In the following, we design a generalized higher order orthogonal iteration scheme for solving {U1, · · · , UN} that is an alternating least squares (ALS) approach to solve the rank-(R1, . . . , RN ) problem. Analogous with Theorem 4.2 in Lathauwer et al., (2000b), we first state that the minimization problem (13) can be formulated as follows.\nTheorem 4 Assume a real N th-order tensor T ∈ R\nI1×I2×...IN . Then the minimization of the problem (13) over the matrices U1, . . . , UN having orthonormal columns is equivalent to the maximization of the following problem\nh(U1, . . . , UN) = 〈T , G ×1 U1 · · · ×N UN 〉. (15)\nThe proof of Theorem 4 can be found in the supplemental material. According to the theorem, a generalized higherorder orthogonal iteration scheme is proposed to solve the problem (15) that solves Un, n = 1, . . . , N by fixing other variables Uj , j 6= n in parallel. Imagine that the matrices {U1, . . . , Un−1, Un+1, . . . , UN} are fixed and that the optimization problem (13) is thought of as a quadratic expression in the components of the matrix Un that is being optimized. Considering that the matrix having orthonormal columns, we have\nh = trace((Uk+1n ) TT(n)W T n ), (16)\nwhere trace(A) denotes the trace of the matrix A, and\nWn = G(n)[(U k 1 ) T · · · ⊗ (Ukn−1) T\n⊗ (Ukn+1) T · · · ⊗ (UkN )\nT ]. (17)\nThis is actually the well-known orthogonal procrustes problem (Nick, 1995), whose global optimal solution is given by the singular value decomposition of T(n)WTn , i.e.,\nUk+1n = Ûn(V̂n) T , (18)\nwhere Ûn and V̂n are obtained by SVD of T(n)WTn . Repeating the procedure above in parallel for different modes leads to an alternating least squares scheme for solving the maximization of the problem (15).\nUpdating {Gk+11 , · · · , G k+1 N }: By keeping all other variables fixed, Gk+1n is updated by solving the following problem:\nmin Gn\n‖Gn‖tr + µ\n2 ‖Gn−G\nk (n)−Y k n /µ‖ 2 F + τn 2 ‖Gn−G k n‖ 2 F .\n(19) Similar to the problem (6), it is easy to obtain a closed-form solution to the problem (19):\nGk+1n = prox1/(µ+τn)( µGk(n) + Y k n + τnG k n\nµ+ τn ). (20)\nFrom (20), it is clear that only some smaller sized matrices (µGk(n) + Y k n + τnG k n)/(µ + τn) ∈ R\nRn×Πj 6=nRj need to perform SVD. Thus, our non-convex trace norm regularized method has a significantly lower computational complexity with O( ∑ n R 2 n ×Πj 6=nRj), while the computational complexity of our convex algorithm for the problem (4) is O( ∑ n I 2 n ×Πj 6=nIj) at each iteration.\nBased on the analysis above, we develop a parallel ADMM algorithm for solving the low-rank non-convex tensor decomposition (NCTD) problem (11), as outlined in Algorithm 2. Our algorithm is essentially a Jacobi-type scheme of ADMM, and is well suited for parallel and distributed computing and hence is particularly attractive for solving certain large-scale problems. Moreover, the update strategy of Gauss-Seidel version of ADMM is easily implemented. This algorithm can be accelerated by adaptively changing µ. An efficient strategy (Lin et al., 2011) is to let µ0 = µ (initialized in Algorithm 1 and Algorithm 2) and increase µk iteratively by µk+1 = ρµk, where ρ ∈ (1.0, 1.1] in general and µ0 is a small constant. Moreover, the stability and efficiency of our NCTD method can be validated in the experimental section."
    }, {
      "heading" : "Complexity Analysis",
      "text" : "We now discuss the time complexity of our NCTD algorithm. For the problem (11), the main running time of our NCTD algorithm is consumed by performing SVD for the proximal operator and some multiplications. The time complexity of performing the proximal operator in (20) is O1 := O( ∑ R2nΠj 6=nRj). The time complexity of some\nmultiplication operators is O2 := O( ∑\nInRnΠj 6=nIj +∑ RnΠj 6=nIjRj) and O3 := O( ∑ R2nIn). Thus, the total time complexity of our NCTD method is O(T (O1 + O2 + O3)), where T is the number of iterations.\nAlgorithm 2 Solving problem (11) via Parallel ADMM Input: T , the tensor ranks (R1, R2, · · · , RN ), and λ. Initialize: Y 0n = 0, G 0 n = 0, U 0 n = rand(In, Rn), µ\n0 = 10−4, µmax = 1010, ρ = 1.05, and Tol = 10−5.\n1: while not converged do 2: Update Gk+1 by (14). 3: for n = 1, · · · , N do 4: Update Uk+1n by (18); 5: Update Gk+1n by (20); 6: Update the multiplier Y k+1n by\nY k+1n = Y k n + γµ k(Gk+1(n) −G k+1 n ).\n7: end for 8: Update µk+1 by µk+1 = min(ρµk, µmax). 9: Check the convergence condition,\nmax{‖Gk+1(n) −G k+1 n ‖F , n = 1, · · · , N} < Tol.\n10: end while Output: G and Un, n = 1, · · · , N ."
    }, {
      "heading" : "Experimental Results",
      "text" : "In this section, we evaluate both the effectiveness and efficiency of our methods for solving tensor decomposition problems using both synthetic and real-world data. All experiments were performed on an Intel(R) Core (TM) i5-4570 (3.20 GHz) PC running Windows 7 with 8GB main memory."
    }, {
      "heading" : "Synthetic Data",
      "text" : "In this part, we generated a low-rank N th-order tensor T ∈ RI1×I2···×IN , which was used as the ground truth data. The tensor data followed the Tucker model, i.e., T = G ×1 U1 · · · ×N UN , where the core tensor G ∈ Rr×r···×r and the factor matrices Un were generated with i.i.d. standard Gaussian entries. The order of the tensors varied from three to four, and the rank r was set to {5, 10, 20}. Finally, we decomposed the input tensor T + δ∆ by our CTD and NCTD methods and the state-of-the-art algorithms including HOSVD (Vannieuwenhoven et al., 2012), HOOI (Lathauwer et al., 2000b), Mixture (Tomioka et al., 2013) and ADMM (Gandy et al., 2011), where ∆ is a noise tensor with independent normally distributed entries, and δ is set to 0.02.\nWe set the tensor ranks Rn = ⌊1.2r⌋, n = 1, . . . , N and Tol = 10−5 for all these algorithms. We set the regularization parameter λ = 100 for our methods. Other parameters of Mixture, ADMM, HOSVD and HOOI are set to their default values. The relative square error (RSE) of the estimated tensor X is given by RSE = ‖X −T ‖F/‖T ‖F . The average experimental results (RSE and time cost) of 50 independent runs are shown in Table 1, where the order of tensor data varies from three to four. From the results shown in Table 1, we can see that our methods can yield much more accurate solutions, and outperform their individual competitors, HOSVD, HOOI, Mixture and ADMM, in terms of both RSE and efficiency.\nA phase transition plot uses greyscale colors to depict how likely a certain kind of low-rank tensors can be recovered by these algorithms for a range of different given ranks and noise variances δ. Phase transition plots are important means\nto compare the performance of different tensor estimation methods. If the relative error RSE ≤ 10−2, the estimation is regarded as successful. Figure 2 depicts the phase transition plots of HOSVD, HOOI, CTD and NCTD on the third-order tensor data with the rank r = 10, where the given tensor ranks Rn, n = 1, 2, 3 varied from 10 to 50 with increment 4 and δ from 0 to 0.05 with increment 0.005. For each setting, 50 independent trials were run. From the experimental results shown in Figure 2, we can see that CTD and NCTD perform significantly better than HOSVD and HOOI."
    }, {
      "heading" : "MRI Data",
      "text" : "This part compares our CTD and NCTD methods, HOSVD and HOOI on a 181×217×181 brain MRI data used in (Liu et al., 2009). This data set is approximately low-rank: for the three mode unfoldings, the numbers of singular values larger\nthan 1% of the largest one are 17, 21, and 17, respectively. Figure 3 shows the average relative errors and running times of ten independent trials for each setting of the given ranks. From the results, we see that our CTD and NCTD methods consistently attain much lower relative errors than those by HOSVD and HOOI. Moreover, our NCTD method is usually faster than the other methods."
    }, {
      "heading" : "Conclusions",
      "text" : "In this paper we first proposed a convex trace norm regularized tensor decomposition method, which can automatically determine the number of factors in each mode through our optimization scheme. In addition, by considering the lowrank structure of input tensors, we analyzed the equivalence relationship of the trace norm between a low-rank tensor and its core tensor. Then, we cast the non-convex tensor decomposition model into a weighted combination of multiple much-smaller-scale matrix trace norm minimization. Finally, we developed two efficient parallel ADMM algorithms for solving the proposed problems. Convincing experimental results demonstrate that our regularized formulation is reasonable, and our methods are robust to noise or outliers. Moreover, our tensor decomposition methods can handle some tensor recovery problems, such as tensor completion, and low-rank and sparse tensor decomposition."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We thank the reviewers for their useful comments that have helped improve the paper significantly. The first and third authors are supported by the CUHK Direct Grant No. 4055017 and Microsoft Research Asia Grant 6903555."
    }, {
      "heading" : "Convergence Behaviors of Our Algorithms",
      "text" : "We also study the convergence behaviors of our CTD and NCTD algorithms on the synthetic tensor data of size 200× 200 × 200 with the given ranks, R1 = R2 = R3 = 20, as shown in Figure 1, where the ordinate is the residual of max{‖Gk(n) −G k n‖F , n = 1, · · · , N} or ‖X k −T ‖F , or the relative change of X k, and the abscissa denotes the number of iterations. Moreover, we also provide the convergence results of HOOI. We can observe that the relative change or the residual of CTD and NCTD algorithms drops much quickly, and converges much fast within 50 iterations. Especially, the relative change or the residual of CTD and NCTD drops much more quickly than HOOI."
    }, {
      "heading" : "Rank Estimation",
      "text" : "In this part, we evaluate the ability of our CTD method to estimate the tensor ranks, as shown in Figure 2. As in the experimental section, we randomly generated T of size 200×200×200with the tensor ranks r1 = r2 = r3 = r =10 or 20. From Figure 2, we see that our CTD method can accurately estimate the rank of each mode unfolding of the tensor."
    }, {
      "heading" : "Robustness Against Outliers",
      "text" : "Figure 3 depicts the phase transition plots of HOSVD, HOOI, CTD and NCTD on the third-order tensor data with rank r = 10, where the given tensor ranks Rn, n = 1, 2, 3 varied from 10 to 50 with increment 4 and the error sparsity ratio ‖∆‖0/ΠnIn from 0 to 0.05 with increment 0.005. We generated ∆ as a sparse tensor whose non-zero entries are independent and uniformly distributed in the range [−1, 1], and whose support is chosen uniformly at random. For each setting, 50 independent trials were run. From the experi-\nmental results shown in Figure 3, it is clear that our methods, CTD and NCTD, significantly outperform HOSVD and HOOI."
    }, {
      "heading" : "APPENDIX A",
      "text" : "Proof of Theorem 2: Before giving a proof of Theorem 2, we will first present some properties of matrices and tensors in the following.\nProperty 1: Let U ∈ Rm×p, S ∈ Rp×q , and V ∈ Rn×q, then\n‖USV T ‖tr = ‖S‖tr,\nwhere UTU = Ip and V TV = Iq . Property 2: Let A ∈ Rm×n, B ∈ Rp×q, and C and D are two matrices of suitable sizes, then we have the following results: (I). (A⊗B)⊗ C = A⊗ (B ⊗ C). (II). (A⊗B)(C ⊗D) = AC ⊗BD. (III). (A⊗B)T = AT ⊗BT .\nProperty 3: Let X = G×1U1×2 · · ·×N UN , where X ∈ R\nI1×I2···×IN , G ∈ RR1×R2···×RN , and Un ∈ RIn×Rn , n = 1, . . . , N , then\nX(n) = UnG(n)(UN ⊗ . . . Un+1 ⊗ Un−1 . . .⊗ U1) T .\nProof of Theorem 2: According to Property 3, we have\n‖X(n)‖tr = ‖UnG(n)(UN ⊗ . . . Un+1 ⊗Un−1 . . .⊗U1) T ‖tr.\nLet Pn = UN ⊗ . . . Un+1 ⊗Un−1 . . .⊗U1 and UTn Un = IRn , n = 1, . . . , N , and according to Properties 2 and 3, we have the following conclusion:\nPTn Pn\n=(UN ⊗ . . .⊗ Un+1 ⊗ Un−1 ⊗ . . .⊗ U1) T (UN ⊗ . . .⊗\nUn+1 ⊗ Un−1 ⊗ . . .⊗ U1),\n=(UTN ⊗ . . .⊗ U T n+1 ⊗ U T n−1 ⊗ . . .⊗ U T 1 )(UN ⊗ . . .⊗\nUn+1 ⊗ Un−1 ⊗ . . .⊗ U1),\n=(UTN ⊗ . . .⊗ U T n+1 ⊗ U T n−1 ⊗ . . .⊗ U T 2 )(UN⊗\n. . .⊗ Un+1 ⊗ Un−1 ⊗ . . .⊗ U2)⊗ (U T 1 U1),\n=(UTN ⊗ . . .⊗ U T n+1 ⊗ U T n−1 ⊗ . . .⊗ U T 2 )(UN⊗\n. . .⊗ Un+1 ⊗ Un−1 ⊗ . . .⊗ U2)⊗ I1,\n...\n=IN ⊗ . . . In+1 ⊗ In−1 ⊗ . . . I2 ⊗ I1,\n=Ĩn,\nwhere In ∈ RRn×Rn , n = 1, . . . , N, Ĩn ∈ RJn×Jn , and Jn = Πj 6=nRj .\nAccording to Property 1, and PTn Pn = Ĩn, we have\n‖X(n)‖tr = ‖UnG(n)(UN ⊗ . . . Un+1 ⊗ Un−1 . . .⊗ U1) T ‖tr\n= ‖G(n)‖tr.\nThis completes the proof."
    }, {
      "heading" : "APPENDIX B",
      "text" : ""
    }, {
      "heading" : "Proof of Theorem 3:",
      "text" : "The optimization problem (13) with respect to G is written by\n(21) min G\nJ(G) = N∑\nn=1\nµk\n2 ‖G(n) −G\nk n + Y k n /µ k‖2F\n+ λ\n2 ‖T − G ×1 U\nk 1 · · · ×N U k N‖ 2 F .\nThe problem (21) above is a smooth convex optimization problem, thus we can obtain the derivative of the function J in the following form:\n(22)\n∂J ∂G =λ(G − T ×1 (U k 1 ) T · · · ×N (U k N ) T )\n+ N∑\nn=1\nµk(G − refold(Gkn − Y k n /µ k))\n=(Nµk + λ)G − µk N∑\nn=1\nrefold(Gkn − Y k n /µ k)\n− λT ×1 (U k 1 ) T · · · ×N (U k N) T ,\nwhere refold(·) denotes the refolding of the matrix into a tensor.\nLet ∂J∂G =0, and\n(23)\nM = T ×1 (U k 1 ) T · · · ×N (U k N) T ,\nN = N∑\nn=1\nrefold(Gkn − Y k n /µ k),\nthe optimal solution to (21) is given by\n(24)\nG∗ = λ\nλ+Nµk T ×1 (U\nk 1 ) T · · · ×N (U k N ) T\n+ µk\nλ+Nµk\nN∑\nn=1\nrefold(Gkn − Y k n /µ k),\n= λ\nλ+Nµk M+\nµk\nλ+Nµk N .\nThis completes the proof."
    }, {
      "heading" : "APPENDIX C",
      "text" : ""
    }, {
      "heading" : "Proof of Theorem 4:",
      "text" : "Let\n(25) H(G, {Un}) =\nN∑\nn=1\nµk‖G(n) −G k n + Y k n /µ k‖2F\n+λ‖T − G ×1 U1 · · · ×N UN‖ 2 F ,\nthen the closed-form solution of (25) with respect to G can be obtained by (14), and it can be rewritten as\nG∗ = 1\nλ+Nµk (λM + µkN ).\nHence, we have\n(26)\nH(G∗, {Un})\n=\nN∑\nn=1\nµk‖G∗(n) −G k n + Y k n /µ k‖2F + λ‖T ‖ 2 F + λ‖G ∗‖2F\n− 2λ〈T ,G∗ ×1 U1 · · · ×N UN〉,\n=η − 2λh(U1, U2, . . . , UN),\nwhere η = ∑N\nn=1 µ k‖G∗(n) −G k n + Y k n /µ k‖2F + λ‖T ‖ 2 F +\nλ‖G∗‖2F is a constant, and\nh(U1, U2, . . . , UN ) = 〈T ,G ∗ ×1 U1 · · · ×N UN〉.\nCombination with the results above proves the theorem. This completes the proof."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2014,
    "abstractText" : "Higher-order tensors are becoming prevalent in many<lb>scientific areas such as computer vision, social network<lb>analysis, data mining and neuroscience. Traditional ten-<lb>sor decomposition approaches face three major chal-<lb>lenges: model selecting, gross corruptions and compu-<lb>tational efficiency. To address these problems, we first<lb>propose a parallel trace norm regularized tensor de-<lb>composition method, and formulate it as a convex op-<lb>timization problem. This method does not require the<lb>rank of each mode to be specified beforehand, and can<lb>automatically determine the number of factors in each<lb>mode through our optimization scheme. By considering<lb>the low-rank structure of the observed tensor, we ana-<lb>lyze the equivalent relationship of the trace norm be-<lb>tween a low-rank tensor and its core tensor. Then, we<lb>cast a non-convex tensor decomposition model into a<lb>weighted combination of multiple much smaller-scale<lb>matrix trace norm minimization. Finally, we develop<lb>two parallel alternating direction methods of multipli-<lb>ers (ADMM) to solve our problems. Experimental re-<lb>sults verify that our regularized formulation is effective,<lb>and our methods are robust to noise or outliers. Introduction<lb>The term tensor used in the context of this paper refers to<lb>a multi-dimensional array, also known as a multi-way or<lb>multi-mode array. For example, if X ∈ R123 , then<lb>we say X is a third-order tensor, where order is the num-<lb>ber of ways or modes of the tensor. Thus, vectors and ma-<lb>trices are first-order and second-order tensors, respectively.<lb>Higher-order tensors arise in a wide variety of application ar-<lb>eas, such as machine learning (Tomioka and Suzuki, 2013;<lb>Signoretto et al., 2014), computer vision (Liu et al., 2009),<lb>data mining (Yilmaz et al., 2011; Morup, 2011; Narita et<lb>al., 2012; Liu et al., 2014), numerical linear algebra (Lath-<lb>auwer et al., 2000a; 2000b), and so on. Especially, with<lb>the rapid development of modern computer technology in<lb>recent years, tensors are becoming increasingly ubiquitous<lb>such as multi-channel images and videos, and have become<lb>increasingly popular (Kolda and Bader, 2009). When work-<lb>ing with high-order tensor data, various new computational Copyright c<lb>© 2014, Association for the Advancement of Artificial<lb>Intelligence (www.aaai.org). All rights reserved.<lb>challenges arise due to the exponential increase in time and<lb>memory space complexity when the number of orders in-<lb>creases. This is called the curse of dimensionality. In prac-<lb>tice, the underlying tensor is often low-rank, even though<lb>the actual data may not be due to noise or arbitrary errors.<lb>Essentially, the major component contained in the given ten-<lb>sor is often governed by a relatively small number of latent<lb>factors.<lb>One standard tool to alleviate the curse is tensor de-<lb>composition. Decomposition of high-order tensors into<lb>a small number of factors has been one of the main<lb>tasks in multi-way data analysis, and commonly takes two<lb>forms: Tucker decomposition (Tucker, 1966) and CANDE-<lb>COMP/PARAFAC (CP) (Harshman, 1970) decomposition.<lb>There are extensive studies in the literature for finding the<lb>Tucker decomposition and the CP decomposition for higher-<lb>order tensors (Kolda and Bader, 2009). In those tensor de-<lb>composition methods, their goal is to (approximately) re-<lb>construct the input tensor as a sum of simpler components<lb>with the hope that these simpler components would reveal<lb>the latent structure of the data. However, existing tensor de-<lb>composition methods face three major challenges: rank se-<lb>lection, outliers and gross corruptions, and computational<lb>efficiency. Since the Tucker and CP decomposition meth-<lb>ods are based on least-squares approximation, they are also<lb>very sensitive to outliers and gross corruptions (Goldfarb<lb>and Qin, 2014). In addition, the performance of those meth-<lb>ods is usually sensitive to the given ranks of the involved ten-<lb>sor (Liu et al., 2009). To address the problems, we propose<lb>two robust and parallel higher-order tensor decomposition<lb>methods with trace norm regularization.<lb>Recently, much attention has been drawn to the low-rank<lb>tensor recovery problem, which arises in a number of real-<lb>word applications, such as 3D image recovery, video in-<lb>painting, hyperspectral data recovery, and face reconstruc-<lb>tion. Compared with matrix-based analysis methods, tensor-<lb>based multi-linear data analysis has shown that tensor mod-<lb>els are capable of taking full advantage of the high-order<lb>structure to provide better understanding and more preci-<lb>sion. The key idea of low-rank tensor completion and recov-<lb>ery methods is to employ matrix trace norm minimization<lb>(also known as the nuclear norm, which is the convex surro-<lb>gate of the rank of the involved matrix). In addition, there are<lb>some theoretical developments that guarantee reconstruction of a low-rank tensor from partial measurements or grossly<lb>corrupted observations via solving the trace norm minimiza-<lb>tion problem under some reasonable conditions (Tomioka et<lb>al., 2011; Shi et al., 2013). Motivated by the recent progress<lb>in tensor completion and recovery, one goal of this paper<lb>is to extend the trace norm regularization to robust higher-<lb>order tensor decomposition.<lb>Different from existing tensor decomposition methods,<lb>we first propose a parallel trace norm regularized tensor de-<lb>composition method, which can automatically determine the<lb>number of factors in each mode through our optimization<lb>scheme. In other words, this method does not require the<lb>rank of each mode to be specified beforehand. In addition,<lb>by considering the low-rank structure of the observed tensor<lb>and further improving the scalability of our convex method,<lb>we analyze the equivalent relationship of the trace norm be-<lb>tween a low-rank tensor and its core tensor. Then, we cast<lb>the non-convex trace norm regularized higher-order orthog-<lb>onal iteration model into a weighted combination of multiple<lb>much-smaller-scale matrix trace norm minimization. More-<lb>over, we design two parallel alternating direction methods of<lb>multipliers (ADMM) to solve the proposed problems, which<lb>are shown to be fast, insensitive to initialization and robust<lb>to noise and/or outliers with extensive experiments. Notations and Related Work<lb>We first introduce the notations, and more details can be seen<lb>in Kolda and Bader (2009). An N th-order tensor is denoted<lb>by a calligraphic letter, e.g., T ∈ R12N , and its<lb>entries are denoted by ti1···in···iN , where in ∈ {1, · · · ,<lb>In}<lb>for 1 ≤ n ≤ N . Fibers are the higher-order analogue of<lb>matrix rows and columns. The mode-n fibers are vectors<lb>ti1···in−1in+1···iN that are obtained by fixing the values of<lb>{i1, · · · ,<lb>iN}\\in.<lb>The mode-n unfolding, also known as matricization, of an<lb>N th-order tensor T is denoted by T(n) ∈ Rnj 6=nIj and<lb>arranges the mode-n fibers to be the columns of the result-<lb>ing matrix T(n) such that the mode-n fiber becomes the row<lb>index and all other (N − 1) modes become the column in-<lb>dices. The tensor element (i1, i2, · · · , iN) is mapped to the<lb>matrix element (in, j), where",
    "creator" : "LaTeX with hyperref package"
  }
}