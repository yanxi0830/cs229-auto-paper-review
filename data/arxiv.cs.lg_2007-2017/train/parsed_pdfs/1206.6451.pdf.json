{
  "name" : "1206.6451.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "The Greedy Miser: Learning under Test-time Budgets",
    "authors" : [ "Zhixiang (Eddie) Xu", "Kilian Q. Weinberger", "Olivier Chapelle" ],
    "emails" : [ "XUZX@CSE.WUSTL.EDU", "KILIAN@WUSTL.EDU", "OLIVIER@CHAPELLE.CC" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "The past decade has witnessed how the field of machine learning has established itself as a necessary component in several multi-billion-dollar industries. The applications range from web-search engines (Zheng et al., 2008), over product recommendation (Fleck et al., 1996), to email and web spam filtering (Weinberger et al., 2009). The realworld industrial setting introduces an interesting new problem to machine learning research: computational resources must be budgeted and costs must be strictly accounted for during test-time. Imagine an algorithm that is executed 10 million times per day. If a new feature improves the accuracy by 3%, but also increases the running time by 1s per execution, that would require the project manager to purchase 58 days of additional cpu time per day.\nAt its core, this problem is an inherent tradeoff between accuracy and test-time computation. The test-time compu-\nAppearing in Proceedings of the 29 th International Conference on Machine Learning, Edinburgh, Scotland, UK, 2012. Copyright 2012 by the author(s)/owner(s).\ntation consists of two components: 1. the actual running time of the algorithm; 2. the time required for feature extraction.\nIn this paper, we propose a novel algorithm that makes this trade-off explicit and considers the feature extraction cost during training in order to minimize cpu usage during testtime. We first state the (non-continuous) global objective which explicitly trades off feature cost and accuracy, and relax it into a continuous loss function. Subsequently, we derive an update rule that shows the resulting loss lends itself naturally to greedy optimization with stage-wise regression (Friedman, 2001).\nWhile algorithms such as (Viola & Jones, 2002) directly attack the problem of fast evaluation for visual object detection, in most machine learning application domains, such as web-search ranking or email-spam filtering, analysis and algorithms for on-demand feature-cost amortization are still in their early stages.\nDifferent from previous approaches (Lefakis & Fleuret, 2010; Saberian & Vasconcelos, 2010; Pujara et al., 2011; Chen et al., 2012), our algorithm does not build cascades of classifiers. Instead, the cost/accuracy tradeoff is pushed into the training and selection of the weak classifiers. The resulting learning algorithm is much simpler than any prior work, as it is a variant of regular stage-wise regression, and yet leads to superior test-time performance. We evaluate our algorithm’s efficacy on two real world data sets from very different application domains: scene recognition in images and ranking of web-search documents. Its accuracy matches that of the unconstrained baseline (with unlimited resources) while achieving an order of magnitude reduction of test-time cost. Because of its simplicity, high accuracy and drastic test-time cost-reduction we believe our approach to be of strong practical value for a wide range of problems."
    }, {
      "heading" : "2. Related Work",
      "text" : "Previous work on cost-sensitive learning appears in the context of many different applications. Most prominently, Viola & Jones (2002) greedily train a cascade of weak classifiers with Adaboost (Schapire, 1999) for visual object recognition. Cambazoglu et al. (2010) propose a cascade framework explicitly for web-search ranking. They learn a set of additive weak classifiers using gradient boosting, and remove data points during test-time using proximity scores. Although their algorithm requires almost no extra training cost, the improvement is typically limited. Lefakis & Fleuret (2010) and Dundar & Bi (2007) learn a softcascade, which re-weights inputs based on their probability of passing all stages. Different from our method, they employ a global probabilistic model, do not explicitly incorporate feature extraction costs and are restricted to binary classification problems. Saberian & Vasconcelos (2010) also learn classifier cascades. In contrast to prior work, they learn all cascades levels simultaneously in a greedy fashion. Unlike our approach, all of these algorithms focus on learning of cascades and none explicitly focus on individual feature costs.\nTo consider the feature cost, Gao & Koller (2011) published an algorithm to dynamically extract features during test-time. Raykar et al. (2010) learn classifier cascades, but they group features by their costs and restrict classifiers at each stage to only use a small subset. Pujara et al. (2011) suggest the use of sampling to derive a cascade of classifiers with increasing cost for email spam filtering. Most recently, Chen et al. (2012) introduce Cronus, which explicitly considers the feature extraction cost during training and constructs a cascade to encourage removal of unpromising data points early-on. At each stage, they optimize the coefficients of the weak classifiers to minimize the classification error and trees/features extraction costs. We pursue a very different (orthogonal) approach and do not optimize the cascade stages globally. Instead, we strictly incorporate the feature cost into the weak learners. Moreover, as our algorithm is a variant of stage-wise regression, it can operate naturally in both regression and multi-class classification scenarios. (Simultaneous with this publication, Grubb & Bagnell (2012) also proposed a complementary approach to incorporate feature cost into gradient boosting.)"
    }, {
      "heading" : "3. Notation and Setup",
      "text" : "Our training data consist of n input vectors {x1, . . . ,xn}∈ Rd with corresponding labels {y1, . . . , yn} ∈ Y drawn from an unknown distributionD. Labels can be continuous (regression) or categorial (binary or multi-class classification). We assume that each feature α has an acquisition cost cα > 0 during its initial retrieval. Once a feature has been acquired its subsequent retrieval is free (or set to a small\nconstant).\nFurther, we are provided an arbitrary continuous loss function ` and aim to learn a linear predictorHβ(x) = β>h(x) to minimize the loss function,\nmin β `(β), (1)\nwithin some test-time cost budget, which will be defined in the following section. One example for ` is the squaredloss\n`sq(β) = 1\n2n n∑ i=1 (Hβ(xi)− yi)2 , (2)\nbut other losses, for example the multi-class logloss (Hastie et al., 2009), are equally suitable. The mapping x → h(x) is a non-linear transformation of the input data that allows the linear classifier to produce nonlinear decision boundaries in the original input space. Typically, the mapping h can be performed implicitly through the kernel-trick (Schölkopf, 2001) or explicitly through, for example, the boosting-trick (Friedman, 2001; Rosset et al., 2004; Chapelle et al., 2010). In this paper we use the latter approach with limited-depth regression trees (Breiman, 1984). More precisely, h(xi) = [h1(xi), . . . , hT (xi)]>, ht ∈ H where H is the set of all possible regression trees of some limited depth b (e.g. b = 4) and T = |H|. The resulting feature space is extremely high dimensional and the weight-vector β is always kept to be correspondingly sparse. Because regression trees are negation closed (i.e. for each h ∈ H we also have−h ∈ H) we assume throughout this paper w.l.o.g. that β ≥ 0. Finally, we define a binary matrix F ∈ {0, 1}d×T in which an entry Fαt = 1 if and only if the regression tree ht ∈H splits on feature α somewhere within its tree."
    }, {
      "heading" : "4. Method",
      "text" : "In this section, we formalize the optimization problem of test-time computational cost, and then intuitively state our algorithm. We follow the setup introduced in (Chen et al., 2012), formalizing the test-time computational cost of evaluating the classifier H for a given weight-vector β.\nTest-time computational cost. There are two factors that contribute to this cost: The function evaluation cost of all trees ht with βt > 0 and the feature extraction cost for all features that are used in these trees. Let e > 0 be the cost to evaluate one tree ht if all features were previously extracted. With this notation, both costs can be expressed in a single function as\nc(β) = e‖β‖0 + d∑\nα=1\ncα ∥∥∥∥∥ T∑ t=1 Fαtβt ∥∥∥∥∥ 0 , (3)\nwhere the l0-norm for scalars is defined as ‖a‖0 → {0, 1} with ‖a‖0 = 1 if and only if a 6= 0. The first term captures the function-evaluation costs and the second term captures the feature costs of all used features. If we combine (1) with (3) we obtain our overall optimization problem\nmin β `(β), subject to: c(β) ≤ B, (4)\nwhere B≥ 0 denotes some pre-defined budget that cannot be exceeded during test-time.\nAlgorithm. In the remainder of this paper we derive an algorithm to approximately minimize (4). For better clarity, we first give an intuitive overview of the resulting method in this paragraph. Our algorithm is based on stage-wise regression, which learns an additive classifier Hβ(x) =∑m t=1 βtht(x) that aims to minimize the loss function (4). 1 During iteration t, the greedy Classification and Regression Tree (CART) algorithm (Breiman, 1984) is used to generate a new tree ht, which is added to the classifier Hβ.\nSpecifically, CART generates a limited-depth regression tree ht ∈ H by greedily minimizing an impurity function, g : H→R+0 . Typical choices for g are the squared loss (2) or the label entropy (Hastie et al., 2009). CART minimizes the impurity function g by recursively splitting the data set on a single feature per tree-node. We propose an impurity function which on the one hand approximates the negative gradient of ` with the squared-loss, such that adding the resulting tree ht minimizes `, and on the other hand penalizes the initial extraction of features by their cost cα. To capture this initial extraction cost, we define an auxiliary variable φα ∈ {0, 1} indicating if feature α has already been extracted (φα = 0) in previous trees, or not (φα = 1). We update the vector φ after generating each tree, setting the corresponding entry for used features α to φα := 0. Our impurity function in iteration t becomes\ng(ht)= 1\n2 ∑ i ( − ∂` ∂H(xi) −ht(xi) )2 +λ d∑ α=1 φαcαFαt,\n(5) where λ trades off the loss with the cost.\nTo combine the trees ht into a final classifier Hβ, our algorithm follows the steps of regular stage-wise regression with a fixed step-size η > 0. As our algorithm is based on a greedy optimiser, and is stingy with respect to featureextraction, we refer to it as the Greedy Miser (short miser). Algorithm (1) shows a pseudo-code implementation.\n1Here, w.l.o.g. the trees inH are conveniently re-ordered such that exactly the first m trees have non-zero weight βt.\nAlgorithm 1 Greedy Miser in pseudo-code Require: D = {(xi, yi)}ni=1, step-size η, iterations m H = 0 for t = 1 to m do ht ← Use CART to greedily minimize (5). H ← H + ηht. For each feature α used in ht, set φα ← 0.\nend for Return H"
    }, {
      "heading" : "5. Algorithm Derivation",
      "text" : "In this section, we derive a connection between (4) and our miser algorithm by showing that miser approximately solves a relaxed version of the optimization problem."
    }, {
      "heading" : "5.1. Relaxation",
      "text" : "The optimization as stated in eq. (4) is non-continuous, because of the l0-norm in the cost term—and hard to optimize. We start by introducing minor relaxations to both terms in (3) to make it better behaved.\nAssumptions. Our optimization algorithm (for details see section 5.2) performs coordinate descent and — starting from β=0 — increments one dimension of β by η>0 in each iteration. Because of the extremely high dimensionality (which is dictated by the number of all possible regression trees that can be represented within the accuracy of the computer) and the comparably tiny number of iterations (≤ 5000) it is reasonable to assume that one dimension is never incremented twice. In other words, the weight vector β is extremely sparse and (up to re-scaling by 1η ) binary: 1 ηβ ∈ {0, 1}T .\nTree-evaluation cost. The l0-norm is often relaxed into the convex and continuous l1-norm. In our scenario, this is particularly attractive, because if 1ηβ is binary, then the re-scaled l1 norm is identical to the l0 norm—and the relaxation is exact. We use this approach for the first term:\ne‖β‖0 −→ e\nη ‖β‖1. (6)\nFeature cost. In the case of the feature cost, the l1 norm is not a good approximation of the original l0-norm, because features are re-used many times, in different trees. Using the l1-norm would imply that features that are used more often would be penalized more than features that are only used once. This contradicts our assumption that features become free after their initial construction.\nWe therefore define a new function q, which is a re-scaled\nand amputated version of the `1-norm:\nq(x) = { |xη | for |x| ∈ [0, η) 1 for |x| ∈ [η,∞). (7)\nThis penalty function q behaves like the regular `1 norm when |x| is small, but is capped to a constant when x ≥ η. With this definition, our relaxation of the feature-cost term becomes:\nd∑ α=1 cα ∥∥∥∥∥ T∑ t=1 Fαtβt ∥∥∥∥∥ 0 −→ d∑ α=1 cαq ( T∑ t=1 Fαtβt ) . (8)\nSimilar to the previous case, if 1ηβ is binary, this relaxation is exact. This holds because in (8) all arguments of q are non-negative multiples of η (as Fαt ∈ {0, 1} and βt ∈ {0, η}) and it is easy to see from the definition of q that for all k = 0, 1, . . . , we have q(kη) = ‖kη‖0.\nContinuous cost-term. To simplify the optimization, we split the budget into two terms B = Bt + Bf—the treeevaluation budget and the feature extraction budget—and re-write (4) with the two penalties (6) and (8) as two individual constraints. If we use the Lagrangian formulation, with Lagrange multiplier λ (up to re-scaling), for the feature cost constraint and the explicit constraint formulation for the tree-evaluation cost, we obtain our final optimization problem:\nmin β `(β) + λ d∑ α=1 cαq (∑ t Fαtβt ) (9)\ns.t. 1\nη ‖β‖1 ≤ Bt e ."
    }, {
      "heading" : "5.2. Optimization",
      "text" : "In this section we describe how miser, our adaptation of stage-wise regression (Friedman, 2001), finds a (local) solution to the optimization problem in (9).\nSolution path. We follow the approach from Rosset et al. (2004) and find a solution path for (9) for evenly spaced tree-evaluation budgets, ranging from B′t = 0 to B ′ t =Bt. Along the path we iteratively increment B′t by η. We repeatedly solve the intermediate optimization problem by warm-starting (9) with the previous solution and allowing the weight vector to change by η,\nmin δ≥0\nL(β+δ)︷ ︸︸ ︷ `(β + δ) + λ\nd∑ α=1 cαq (∑ t Fαt(βt + δt) ) , (10)\ns.t. ‖δ‖1 ≤ η.\nEach iteration, we update the weight vector β := β + δ.\nTaylor approximation. The Taylor expansion of L is defined as\nL(β + δ) = L(β) + 〈∇L(β), δ〉+O(δ2). (11) If η is sufficiently small2, and because |δ| ≤ η, we can use the dominating linear term in (11) to approximate the optimization in (10) as\nmin δ≥0 〈∇L(β), δ〉, s.t. ‖δ‖1 ≤ η. (12)\nCoordinate descent. The optimization (12) can be reduced to identifying the direction of steepest descent. Let ∇L(β)t denote the gradient w.r.t. the tth dimension, and let us define\nt∗ = argmin t ∇L(β)t, (13)\nto be the gradient dimension of steepest descent. Because H is negation closed, we have ∇L(β)t∗ = −‖∇L(β)‖∞. (If ∇L(β)t∗ = 0 we are done, so we focus on the case when it is <0.) With Hölder’s inequality we can derive the following lower bound of the inner product in (12),\n〈∇L(β), δ〉 ≥ −|〈∇L(β), δ〉| ≥ −‖∇L(β)‖∞‖δ‖1 ≥ η∇L(β)t∗ . (14)\nWe can now construct a vector δ∗ for which (14) holds as equality, which implies that it must be the optimal solution to (12). This is the case if we set δ∗t∗ = η and δ ∗ 6=t∗ = 0. Consequently, we can find the solution path with steepest coordinate descent under step-size η.\nGradient derivation. The gradient ∇L(β)t consists of two parts, the gradient of the loss ` and the gradient of the feature-cost term. For the latter, we need the gradient of q ( ∑ t Fαtβt), which, according to its definition in (7), is\nnot well-defined if ∑ t Fαtβt = η. As our optimization algorithm can only increase βt, we derive this gradient from the right, yielding\n∇q (∑\nt\nFαtβt\n) = { 1 ηFαt | ∑ t Fαtβt| < η\n0 |∑t Fαtβt| ≥ η. (15) Note that the condition |∑t Fαtβt|<η is true if and only if feature α is not used in any trees with βt>0. Let us define φα = {0, 1} with φα = 1 iff feature | ∑ t Fαtβt|<η. We can then express the gradient of L (with a slight abuse of notation) as\n∇L(β)t := ∂` ∂βt + λ η d∑ α=1 cαφαFαt. (16)\n2Please note that we see this as a true approximation, and do not expect η to be infinitesimally small—which would cause the number of steps (and therefore trees) to become too large for practical use.\nApplying the chain rule, we can decompose the first term in (16), ∂`∂βt , into two parts: the derivatives w.r.t. the current prediction Hβ(xi), and the partial derivatives of Hβ(xi) w.r.t. βt. This results in\n∇L(β)t= n∑ i=1\n∂`\n∂Hβ(xi)\n∂Hβ(xi) ∂βt + λ η d∑ α=1 cαφαFαt.\n(17)\nAsHβ(xi)=β>h(xi) is linear, we have ∂Hβ(xi) ∂βt\n=ht(xi). If we define ri = − ∂`∂Hβ(xi) , which we can easily compute for every xi, we can re-phrase (17) as\n∇L(β)t= n∑ i=1 −riht(xi) + λ η d∑ α=1 cαφαFαt. (18)\nThe Greedy Miser. For simplicity, we restrict H to only normalized regression-trees (i.e. ∑ i h 2 t (xi) = 1), which\nallows us to add two constant terms 12 ∑ i h 2 t (xi) and r 2 i to (18) without affecting the outcome of the minimization in (13), as both are independent of t. This completes the binomial equation and we obtain a quadratic form:\nht=argmin ht∈H\n1\n2 n∑ i (ri − ht(xi))2+λ′ d∑ α=1 cαφαFαt,\n(19)\nwith λ′ = λη . Note that (19) is exactly what miser minimizes in (5), which concludes our derivation.\nMeta-parameters. The meta-parameters of miser are surprisingly intuitive. The maximum number of iterations, m, is tightly linked to the tree-evaluation budget Bt. The optimal solution of (12) must satisfy the equality ‖δ∗‖1 = η (unless ∇L= 0, in which case a local minimum has been reached and the algorithm would terminate). As ‖β‖1 is exactly increased by η in each iteration, it can be expressed in terms of the number of iterationsm of the algorithm, and we obtain 1η‖β‖1 = m. Consequently, in order to satisfy the l1 constraint in (9), we must limit to the number of iterations to m ≤ Bte . The parameter λ′ corresponds directly to the feature-budget Bf . The algorithm is not particularly sensitive to the exact step-size η, and throughout this paper we set it to η=0.1."
    }, {
      "heading" : "6. Results",
      "text" : "We conduct experiments on two benchmark tasks from very different domains: the Yahoo Learning to Rank Challenge data set (Chapelle & Chang, 2011) and the scene recognition data set from Lazebnik et al. (2006).\nYahoo Learning to Rank. The Yahoo data set contains document/query pairs with label values from {0, 1, 2, 3, 4},\nwhere 0 means the document is irrelevant to the query, and 4 means highly relevant. In total, it has 473134, 71083, 165660, training, validation, and testing pairs. As this is a regression task, we use the squared-loss as our loss function `. Although the data set is representative for a web-search ranking training data set, in a real world test setting, there are many more irrelevant data points. Usually, for each query, only a few documents are relevant, and the other hundreds of thousands are completely irrelevant. Therefore, we follow the convention of Chen et al. (2012) and replicate each irrelevant data point (label value is 0) 10 times.\nEach feature in the data set has an acquisition cost. The feature costs are discrete values in the set {1, 5, 10, 20, 50, 100, 150}. The unit of these costs is approximately the time to evaluate a feature. The cheapest features (cost value is 1) are those that can be acquired by looking up a table (such as the statistics of a given document), whereas the most expensive ones (such as BM25FSD described in Broder et al. (2010)), typically involve term proximity scoring.\nTo evaluate the performance on this task, we follow the typical convention and use Normalized Discounted Cumulative Gain (NDCG@5) (Järvelin & Kekäläinen, 2002), as it places stronger emphasis on retrieving relevant documents within a large set of irrelevant documents.\nLoss/cost trade-off. Figure 1 (left) shows the traces (dashed lines) of the NDCG@5/cost generated by repeatedly adding trees to the predictor until 3000 trees in total — essentially depicting the results under increasing treeevaluation budgets Bt. The different traces are obtained under varying values of the feature-cost trade-off parameter λ. The baseline, stage-wise regression (Friedman, 2001), is equivalent to miser with λ = 0 and is essentially building trees without any cost consideration. The red circles indicate the iteration with the highest NDCG@5 value on the validation data set. The graph shows, that under increased λ (the solid red line), the NDCG@5 ranking accuracy of miser drops very gradually, while the test-time cost is reduced drastically (compared to λ=0).\nComparison with prior work. In addition to stage-wise regression, we also compare against Stage-wise regression feature subsets, Early Exit (Cambazoglu et al., 2010) and Cronus (Chen et al., 2012). Stage-wise regression feature subsets is a natural extension to stage-wise regression. We group all features according to the feature cost, and gradually use more expensive feature groups. The curve is generated by only using features whose cost≤ 1, 20, 100, 200. Early Exit, proposed by Cambazoglu et al. (2010), trains trees identical to stage-wise regression—however, it reduces the average test-time cost by removing unpromising documents early-on during test-time. Among all methods\nof early-exit the authors suggested, we plot the best performing one (Early Exit Using Proximity Threshold). We introduce an early exit every 10 trees (300 in total), and at the ith early-exit, we remove all test-inputs that have a score of at least (300−i)s299 lower than the fifth best input (where s is a parameter regulating the pruning aggressiveness). The overall improvement over stage-wise regression is limited because the cost is dominated by the feature acquisition, rather than tree computation. It is worth pointing out that the cascade-based approaches of Early-Exits and Cronus are actually complementary to miser and future work should combined them.\nSince Cronus does not scale to the full data set, we use the subset of the Yahoo data from Chen et al. (2012) of 141397, 146769, 184968, training, validation and testing points respectively. In comparison to Cronus, which requires O(mn) memory, miser requires no significant operational memory besides the data and scales easily to millions of data points. Figure 1 (right) depicts the tradeoff curves, of miser and competing algorithms, between the test-time cost and generalization error. We generate the curves by varying the feature-cost trade-off λ (or the pruning parameter s for Early-Exits). For each setting we choose the iteration that has the best validation NDCG@5 score. The graph shows that all algorithms manage to match the unconstrained cost-results of stage-wise regression. However, the trade-off curve of miser stays consistently above that of Cronus and Early Exits, leading to better ranking accuracy at lower test-time cost. In fact, miser can almost match the ranking accuracy of stage-wise regression with 1/10 of the cost, whereas Cronus reduces the cost only to 1/4 and Early-Exits to 1/2.\nFeature extraction. To investigate what effect the featurecost trade-off parameter λ has on the classifier’s feature choices, Figure 2 visualizes what type of features are extracted by miser as λ increases. For this visualization, we group features by cost and show what fraction of features in each group are extracted. The legend in the right indicates the cost of a feature group and the number of features that fall into it (in the parentheses). We plot the feature fraction at the best performing iteration based on the validation set. With λ=0, miser does not consider the feature cost when building trees, and thus extracts a variety of expensive features. As λ increases, it extracts fewer expensive features and re-uses more cheap features (cα = 1). It is interesting to point out that across all different miser settings, a few\nexpensive features (cost≥150) are always extracted within early iterations. This highlights a great advantage of miser over some other cascade algorithms (Raykar et al., 2010), which learn cascades with pre-assigned feature costs and cannot extract good but expensive features until the very end.\nScene Recognition. The Scene-15 data set (Lazebnik et al., 2006) is from a very different data domain. It contains 4485 images from 15 scene classes and the task is to classify images according to scene. Figure 4 shows one example image for each scene category. We follow the procedure used by Lazebnik et al. (2006); Li et al. (2010), randomly sampling 100 images from each class, resulting in 1500 training images. From the remaining 2985 images, we randomly sample 20 images from each class as validation, and leave the rest 2685 for test.\nWe use a diverse set of visual descriptors varying in computation time and accuracy: GIST, spatial HOG, Local Binary Pattern, self-similarity, texton histogram, geometric texton, geometric texton, geometric color, and Object Bank (Li et al., 2010). The authors from Object Bank apply 177 object detectors to each image, where each object detector works independently of each other. We treat each object detector as an independent descriptor and end up with a total of 184 different visual descriptors.\nWe split the training data 30/70 and use the smaller subset to construct a kernel and train 15 one-vs-all SVMs for each descriptor. We use the predictions of these SVMs on the larger subset as the features of miser (totaling d=184×15= 2760 features.) As loss function `, we use the multi-class log-loss (Hastie et al., 2009) and maintain 15 tree-ensemble classifiers H1, . . . ,H15, one for each class. During each\niteration, we construct 15 regression trees (depth 3) and update all classifiers. For a given image, each classifier’s (normalized) output represents the probability of this data point belonging to one class.\nWe compute the feature-extraction-cost as the cpu-time required for the computation for the visual descriptor, the kernel construction and the SVM evaluation. Each visual descriptor is used by 15 one-vs-all features. The moment any one of these features is used, we set the feature extraction cost of all other features that are based on the same visual descriptor to only the SVM evaluation time (e.g. if the first HOG-based feature is used, the cost of all other HOGbased features is reduced to the time required to evaluate the SVM). Figure 3 summarizes the results on the Scene-15 data set. As baseline we use stage-wise regression (Friedman, 2001) and an SVM with the averaged kernel of all descriptors. We also apply stage-wise regression with Early Exits. As this is multi-class classification instead of regression we introduce an early exit every 10 trees (300 in total), and we remove test-inputs whose maximum classlikelihood is greater than a threshold s. We generate the curve of early exit by gradually increasing the value for s. The last baseline is original vision features with `1 regularization, and we notice that its accuracy never exceeds 0.74, and therefore we do not plot it. The miser curve is generated by varying loss/feature-cost trade-off λ. For each setting we choose the iteration that has the best validation accuracy, and all results are obtained by averaging over 10 randomly generated training/testing splits.\nBoth, multiple-kernel SVM and stage-wise regression achieve high accuracy, but their need to extract all features significantly increases their cost. Early Exit has only limited improvement due to the inability to select a few expensive but important features in early iterations. As before, miser champions the cost/accuracy trade-off and its accuracy drops gently with increasing λ.\nAll experiments (on both data sets) were conducted on a desktop with dual 6-core Intel i7 cpus with 2.66GHz. The training time for miser requires comparable amount of time\nas stage-wise regression (about 80 minutes for the full Yahoo data set and 12 minutes for Scene-15.)"
    }, {
      "heading" : "7. Conclusion",
      "text" : "Accounting for the operational cost of machine learning algorithms is a crucial problem that appears throughout current and potential applications of machine learning. We believe that understanding and controlling this trade-off will become a fundamental part of machine-learning research in the near future. This paper introduces a natural extension to stage-wise regression (Friedman, 2001), which incorporates feature cost during training. The resulting algorithm, the Greedy Miser, is simple to implement, naturally scales to large data sets and outperforms previously most costeffective classifiers.\nFuture work includes combining our approach with Early Exits (Cambazoglu et al., 2010) or cascade based learning methods such as (Chen et al., 2012)."
    }, {
      "heading" : "8. Acknowledgements",
      "text" : "KQW and ZX would like to thank NIH for their support through grant U01 1U01NS073457-01."
    } ],
    "references" : [ {
      "title" : "Classification and regression trees",
      "author" : [ "L. Breiman" ],
      "venue" : "Chapman & Hall/CRC,",
      "citeRegEx" : "Breiman,? \\Q1984\\E",
      "shortCiteRegEx" : "Breiman",
      "year" : 1984
    }, {
      "title" : "Exploiting site-level information to improve web search",
      "author" : [ "A. Broder", "E. Gabrilovich", "V. Josifovski", "G. Mavromatis", "D. Metzler", "J. Wang" ],
      "venue" : "In CIKM",
      "citeRegEx" : "Broder et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Broder et al\\.",
      "year" : 2010
    }, {
      "title" : "Early exit optimizations for additive machine learned ranking systems",
      "author" : [ "B.B. Cambazoglu", "H. Zaragoza", "O. Chapelle", "J. Chen", "C. Liao", "Z. Zheng", "J. Degenhardt" ],
      "venue" : "In ICDM,",
      "citeRegEx" : "Cambazoglu et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Cambazoglu et al\\.",
      "year" : 2010
    }, {
      "title" : "Yahoo! learning to rank challenge overview",
      "author" : [ "O. Chapelle", "Y. Chang" ],
      "venue" : "In JMLR Workshop and Conference Proceedings,",
      "citeRegEx" : "Chapelle and Chang,? \\Q2011\\E",
      "shortCiteRegEx" : "Chapelle and Chang",
      "year" : 2011
    }, {
      "title" : "Boosted multi-task learning",
      "author" : [ "O. Chapelle", "P. Shivaswamy", "S. Vadrevu", "K. Weinberger", "Y. Zhang", "B. Tseng" ],
      "venue" : "Machine Learning, pp",
      "citeRegEx" : "Chapelle et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Chapelle et al\\.",
      "year" : 2010
    }, {
      "title" : "Classifier cascade for minimizing feature evaluation cost",
      "author" : [ "Chen", "Minmin", "Xu", "Zhixiang", "Weinberger", "Kilian Q", "Chapelle", "Olivier" ],
      "venue" : "In AISTATS",
      "citeRegEx" : "Chen et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2012
    }, {
      "title" : "Joint optimization of cascaded classifiers for computer aided detection",
      "author" : [ "M.M. Dundar", "J. Bi" ],
      "venue" : "IEEE Conference on Computer Vision and Pattern Recognition,",
      "citeRegEx" : "Dundar and Bi,? \\Q2007\\E",
      "shortCiteRegEx" : "Dundar and Bi",
      "year" : 2007
    }, {
      "title" : "Finding naked people",
      "author" : [ "M. Fleck", "D. Forsyth", "C. Bregler" ],
      "venue" : "Computer Vision—ECCV’96, pp",
      "citeRegEx" : "Fleck et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Fleck et al\\.",
      "year" : 1996
    }, {
      "title" : "Greedy function approximation: a gradient boosting machine",
      "author" : [ "J.H. Friedman" ],
      "venue" : "Annals of Statistics, pp. 1189–1232,",
      "citeRegEx" : "Friedman,? \\Q2001\\E",
      "shortCiteRegEx" : "Friedman",
      "year" : 2001
    }, {
      "title" : "Active classification based on value of classifier",
      "author" : [ "Gao", "Tianshi", "Koller", "Daphne" ],
      "venue" : "K.Q. (eds.),",
      "citeRegEx" : "Gao et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Gao et al\\.",
      "year" : 2011
    }, {
      "title" : "Speedboost: Anytime prediction with uniform near-optimality",
      "author" : [ "Grubb", "Alex", "Bagnell", "Drew" ],
      "venue" : "In AISTATS",
      "citeRegEx" : "Grubb et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Grubb et al\\.",
      "year" : 2012
    }, {
      "title" : "The elements of statistical learning",
      "author" : [ "Hastie", "Trevor", "Tibshirani", "Robert", "Friedman", "JH (Jerome H" ],
      "venue" : null,
      "citeRegEx" : "Hastie et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Hastie et al\\.",
      "year" : 2009
    }, {
      "title" : "Cumulated gain-based evaluation of IR techniques",
      "author" : [ "K. Järvelin", "J. Kekäläinen" ],
      "venue" : "ACM Transactions on Information Systems (TOIS),",
      "citeRegEx" : "Järvelin and Kekäläinen,? \\Q2002\\E",
      "shortCiteRegEx" : "Järvelin and Kekäläinen",
      "year" : 2002
    }, {
      "title" : "Beyond bags of features: Spatial pyramid matching for recognizing natural scene categories",
      "author" : [ "S. Lazebnik", "C. Schmid", "J. Ponce" ],
      "venue" : "In Computer Vision and Pattern Recognition,",
      "citeRegEx" : "Lazebnik et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Lazebnik et al\\.",
      "year" : 2006
    }, {
      "title" : "Object bank: A highlevel image representation for scene classification and semantic feature sparsification",
      "author" : [ "L.J. Li", "H. Su", "E.P. Xing", "L. Fei-Fei" ],
      "venue" : null,
      "citeRegEx" : "Li et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Li et al\\.",
      "year" : 2010
    }, {
      "title" : "Using classifier cascades for scalable e-mail classification",
      "author" : [ "J. Pujara", "H. Daumé III", "L. Getoor" ],
      "venue" : "CEAS",
      "citeRegEx" : "Pujara et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Pujara et al\\.",
      "year" : 2011
    }, {
      "title" : "Designing efficient cascaded classifiers: tradeoff between accuracy and cost",
      "author" : [ "V.C. Raykar", "B. Krishnapuram", "S. Yu" ],
      "venue" : "In SIGKDD",
      "citeRegEx" : "Raykar et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Raykar et al\\.",
      "year" : 2010
    }, {
      "title" : "Boosting as a regularized path to a maximum margin classifier",
      "author" : [ "S. Rosset", "J. Zhu", "T. Hastie" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "Rosset et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Rosset et al\\.",
      "year" : 2004
    }, {
      "title" : "Boosting Classifier Cascades",
      "author" : [ "Saberian", "Mohammad", "Vasconcelos", "Nuno" ],
      "venue" : "NIPS 23,",
      "citeRegEx" : "Saberian et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Saberian et al\\.",
      "year" : 2010
    }, {
      "title" : "A brief introduction to boosting",
      "author" : [ "R.E. Schapire" ],
      "venue" : "In International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Schapire,? \\Q1999\\E",
      "shortCiteRegEx" : "Schapire",
      "year" : 1999
    }, {
      "title" : "The kernel trick for distances",
      "author" : [ "B. Schölkopf" ],
      "venue" : "NIPS, pp",
      "citeRegEx" : "Schölkopf,? \\Q2001\\E",
      "shortCiteRegEx" : "Schölkopf",
      "year" : 2001
    }, {
      "title" : "Robust real-time object detection",
      "author" : [ "P. Viola", "M. Jones" ],
      "venue" : "International Journal of Computer Vision,",
      "citeRegEx" : "Viola and Jones,? \\Q2002\\E",
      "shortCiteRegEx" : "Viola and Jones",
      "year" : 2002
    }, {
      "title" : "Feature hashing for large scale multitask learning",
      "author" : [ "K.Q. Weinberger", "A. Dasgupta", "J. Langford", "A. Smola", "J. Attenberg" ],
      "venue" : "ICMl",
      "citeRegEx" : "Weinberger et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Weinberger et al\\.",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : ", 2008), over product recommendation (Fleck et al., 1996), to email and web spam filtering (Weinberger et al.",
      "startOffset" : 37,
      "endOffset" : 57
    }, {
      "referenceID" : 22,
      "context" : ", 1996), to email and web spam filtering (Weinberger et al., 2009).",
      "startOffset" : 41,
      "endOffset" : 66
    }, {
      "referenceID" : 8,
      "context" : "Subsequently, we derive an update rule that shows the resulting loss lends itself naturally to greedy optimization with stage-wise regression (Friedman, 2001).",
      "startOffset" : 142,
      "endOffset" : 158
    }, {
      "referenceID" : 15,
      "context" : "Different from previous approaches (Lefakis & Fleuret, 2010; Saberian & Vasconcelos, 2010; Pujara et al., 2011; Chen et al., 2012), our algorithm does not build cascades of classifiers.",
      "startOffset" : 35,
      "endOffset" : 130
    }, {
      "referenceID" : 5,
      "context" : "Different from previous approaches (Lefakis & Fleuret, 2010; Saberian & Vasconcelos, 2010; Pujara et al., 2011; Chen et al., 2012), our algorithm does not build cascades of classifiers.",
      "startOffset" : 35,
      "endOffset" : 130
    }, {
      "referenceID" : 19,
      "context" : "Most prominently, Viola & Jones (2002) greedily train a cascade of weak classifiers with Adaboost (Schapire, 1999) for visual object recognition.",
      "startOffset" : 98,
      "endOffset" : 114
    }, {
      "referenceID" : 2,
      "context" : "Cambazoglu et al. (2010) propose a cascade framework explicitly for web-search ranking.",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 2,
      "context" : "Cambazoglu et al. (2010) propose a cascade framework explicitly for web-search ranking. They learn a set of additive weak classifiers using gradient boosting, and remove data points during test-time using proximity scores. Although their algorithm requires almost no extra training cost, the improvement is typically limited. Lefakis & Fleuret (2010) and Dundar & Bi (2007) learn a softcascade, which re-weights inputs based on their probability of passing all stages.",
      "startOffset" : 0,
      "endOffset" : 351
    }, {
      "referenceID" : 2,
      "context" : "Cambazoglu et al. (2010) propose a cascade framework explicitly for web-search ranking. They learn a set of additive weak classifiers using gradient boosting, and remove data points during test-time using proximity scores. Although their algorithm requires almost no extra training cost, the improvement is typically limited. Lefakis & Fleuret (2010) and Dundar & Bi (2007) learn a softcascade, which re-weights inputs based on their probability of passing all stages.",
      "startOffset" : 0,
      "endOffset" : 374
    }, {
      "referenceID" : 2,
      "context" : "Cambazoglu et al. (2010) propose a cascade framework explicitly for web-search ranking. They learn a set of additive weak classifiers using gradient boosting, and remove data points during test-time using proximity scores. Although their algorithm requires almost no extra training cost, the improvement is typically limited. Lefakis & Fleuret (2010) and Dundar & Bi (2007) learn a softcascade, which re-weights inputs based on their probability of passing all stages. Different from our method, they employ a global probabilistic model, do not explicitly incorporate feature extraction costs and are restricted to binary classification problems. Saberian & Vasconcelos (2010) also learn classifier cascades.",
      "startOffset" : 0,
      "endOffset" : 677
    }, {
      "referenceID" : 14,
      "context" : "Raykar et al. (2010) learn classifier cascades, but they group features by their costs and restrict classifiers at each stage to only use a small subset.",
      "startOffset" : 0,
      "endOffset" : 21
    }, {
      "referenceID" : 14,
      "context" : "Pujara et al. (2011) suggest the use of sampling to derive a cascade of classifiers with increasing cost for email spam filtering.",
      "startOffset" : 0,
      "endOffset" : 21
    }, {
      "referenceID" : 5,
      "context" : "Most recently, Chen et al. (2012) introduce Cronus, which explicitly considers the feature extraction cost during training and constructs a cascade to encourage removal of unpromising data points early-on.",
      "startOffset" : 15,
      "endOffset" : 34
    }, {
      "referenceID" : 5,
      "context" : "Most recently, Chen et al. (2012) introduce Cronus, which explicitly considers the feature extraction cost during training and constructs a cascade to encourage removal of unpromising data points early-on. At each stage, they optimize the coefficients of the weak classifiers to minimize the classification error and trees/features extraction costs. We pursue a very different (orthogonal) approach and do not optimize the cascade stages globally. Instead, we strictly incorporate the feature cost into the weak learners. Moreover, as our algorithm is a variant of stage-wise regression, it can operate naturally in both regression and multi-class classification scenarios. (Simultaneous with this publication, Grubb & Bagnell (2012) also proposed a complementary approach to incorporate feature cost into gradient boosting.",
      "startOffset" : 15,
      "endOffset" : 734
    }, {
      "referenceID" : 11,
      "context" : "but other losses, for example the multi-class logloss (Hastie et al., 2009), are equally suitable.",
      "startOffset" : 54,
      "endOffset" : 75
    }, {
      "referenceID" : 20,
      "context" : "Typically, the mapping h can be performed implicitly through the kernel-trick (Schölkopf, 2001) or explicitly through, for example, the boosting-trick (Friedman, 2001; Rosset et al.",
      "startOffset" : 78,
      "endOffset" : 95
    }, {
      "referenceID" : 8,
      "context" : "Typically, the mapping h can be performed implicitly through the kernel-trick (Schölkopf, 2001) or explicitly through, for example, the boosting-trick (Friedman, 2001; Rosset et al., 2004; Chapelle et al., 2010).",
      "startOffset" : 151,
      "endOffset" : 211
    }, {
      "referenceID" : 17,
      "context" : "Typically, the mapping h can be performed implicitly through the kernel-trick (Schölkopf, 2001) or explicitly through, for example, the boosting-trick (Friedman, 2001; Rosset et al., 2004; Chapelle et al., 2010).",
      "startOffset" : 151,
      "endOffset" : 211
    }, {
      "referenceID" : 4,
      "context" : "Typically, the mapping h can be performed implicitly through the kernel-trick (Schölkopf, 2001) or explicitly through, for example, the boosting-trick (Friedman, 2001; Rosset et al., 2004; Chapelle et al., 2010).",
      "startOffset" : 151,
      "endOffset" : 211
    }, {
      "referenceID" : 0,
      "context" : "In this paper we use the latter approach with limited-depth regression trees (Breiman, 1984).",
      "startOffset" : 77,
      "endOffset" : 92
    }, {
      "referenceID" : 5,
      "context" : "We follow the setup introduced in (Chen et al., 2012), formalizing the test-time computational cost of evaluating the classifier H for a given weight-vector β.",
      "startOffset" : 34,
      "endOffset" : 53
    }, {
      "referenceID" : 0,
      "context" : "1 During iteration t, the greedy Classification and Regression Tree (CART) algorithm (Breiman, 1984) is used to generate a new tree ht, which is added to the classifier Hβ.",
      "startOffset" : 85,
      "endOffset" : 100
    }, {
      "referenceID" : 11,
      "context" : "Typical choices for g are the squared loss (2) or the label entropy (Hastie et al., 2009).",
      "startOffset" : 68,
      "endOffset" : 89
    }, {
      "referenceID" : 8,
      "context" : "In this section we describe how miser, our adaptation of stage-wise regression (Friedman, 2001), finds a (local) solution to the optimization problem in (9).",
      "startOffset" : 79,
      "endOffset" : 95
    }, {
      "referenceID" : 17,
      "context" : "We follow the approach from Rosset et al. (2004) and find a solution path for (9) for evenly spaced tree-evaluation budgets, ranging from B′ t = 0 to B ′ t =Bt.",
      "startOffset" : 28,
      "endOffset" : 49
    }, {
      "referenceID" : 13,
      "context" : "We conduct experiments on two benchmark tasks from very different domains: the Yahoo Learning to Rank Challenge data set (Chapelle & Chang, 2011) and the scene recognition data set from Lazebnik et al. (2006).",
      "startOffset" : 186,
      "endOffset" : 209
    }, {
      "referenceID" : 5,
      "context" : "Therefore, we follow the convention of Chen et al. (2012) and replicate each irrelevant data point (label value is 0) 10 times.",
      "startOffset" : 39,
      "endOffset" : 58
    }, {
      "referenceID" : 1,
      "context" : "The cheapest features (cost value is 1) are those that can be acquired by looking up a table (such as the statistics of a given document), whereas the most expensive ones (such as BM25FSD described in Broder et al. (2010)), typically involve term proximity scoring.",
      "startOffset" : 201,
      "endOffset" : 222
    }, {
      "referenceID" : 8,
      "context" : "The baseline, stage-wise regression (Friedman, 2001), is equivalent to miser with λ = 0 and is essentially building trees without any cost consideration.",
      "startOffset" : 36,
      "endOffset" : 52
    }, {
      "referenceID" : 2,
      "context" : "In addition to stage-wise regression, we also compare against Stage-wise regression feature subsets, Early Exit (Cambazoglu et al., 2010) and Cronus (Chen et al.",
      "startOffset" : 112,
      "endOffset" : 137
    }, {
      "referenceID" : 5,
      "context" : ", 2010) and Cronus (Chen et al., 2012).",
      "startOffset" : 19,
      "endOffset" : 38
    }, {
      "referenceID" : 2,
      "context" : "In addition to stage-wise regression, we also compare against Stage-wise regression feature subsets, Early Exit (Cambazoglu et al., 2010) and Cronus (Chen et al., 2012). Stage-wise regression feature subsets is a natural extension to stage-wise regression. We group all features according to the feature cost, and gradually use more expensive feature groups. The curve is generated by only using features whose cost≤ 1, 20, 100, 200. Early Exit, proposed by Cambazoglu et al. (2010), trains trees identical to stage-wise regression—however, it reduces the average test-time cost by removing unpromising documents early-on during test-time.",
      "startOffset" : 113,
      "endOffset" : 483
    }, {
      "referenceID" : 8,
      "context" : "Stage−wise regression (Friedman, 2001) Stage−wise regression feature subsets Early exit (Cambazoglu et.",
      "startOffset" : 22,
      "endOffset" : 38
    }, {
      "referenceID" : 5,
      "context" : "Since Cronus does not scale to the full data set, we use the subset of the Yahoo data from Chen et al. (2012) of 141397, 146769, 184968, training, validation and testing points respectively.",
      "startOffset" : 91,
      "endOffset" : 110
    }, {
      "referenceID" : 16,
      "context" : "This highlights a great advantage of miser over some other cascade algorithms (Raykar et al., 2010), which learn cascades with pre-assigned feature costs and cannot extract good but expensive features until the very end.",
      "startOffset" : 78,
      "endOffset" : 99
    }, {
      "referenceID" : 13,
      "context" : "The Scene-15 data set (Lazebnik et al., 2006) is from a very different data domain.",
      "startOffset" : 22,
      "endOffset" : 45
    }, {
      "referenceID" : 13,
      "context" : "The Scene-15 data set (Lazebnik et al., 2006) is from a very different data domain. It contains 4485 images from 15 scene classes and the task is to classify images according to scene. Figure 4 shows one example image for each scene category. We follow the procedure used by Lazebnik et al. (2006); Li et al.",
      "startOffset" : 23,
      "endOffset" : 298
    }, {
      "referenceID" : 13,
      "context" : "The Scene-15 data set (Lazebnik et al., 2006) is from a very different data domain. It contains 4485 images from 15 scene classes and the task is to classify images according to scene. Figure 4 shows one example image for each scene category. We follow the procedure used by Lazebnik et al. (2006); Li et al. (2010), randomly sampling 100 images from each class, resulting in 1500 training images.",
      "startOffset" : 23,
      "endOffset" : 316
    }, {
      "referenceID" : 14,
      "context" : "We use a diverse set of visual descriptors varying in computation time and accuracy: GIST, spatial HOG, Local Binary Pattern, self-similarity, texton histogram, geometric texton, geometric texton, geometric color, and Object Bank (Li et al., 2010).",
      "startOffset" : 230,
      "endOffset" : 247
    }, {
      "referenceID" : 11,
      "context" : ") As loss function `, we use the multi-class log-loss (Hastie et al., 2009) and maintain 15 tree-ensemble classifiers H, .",
      "startOffset" : 54,
      "endOffset" : 75
    }, {
      "referenceID" : 8,
      "context" : "As baseline we use stage-wise regression (Friedman, 2001) and an SVM with the averaged kernel of all descriptors.",
      "startOffset" : 41,
      "endOffset" : 57
    }, {
      "referenceID" : 8,
      "context" : "This paper introduces a natural extension to stage-wise regression (Friedman, 2001), which incorporates feature cost during training.",
      "startOffset" : 67,
      "endOffset" : 83
    }, {
      "referenceID" : 2,
      "context" : "Future work includes combining our approach with Early Exits (Cambazoglu et al., 2010) or cascade based learning methods such as (Chen et al.",
      "startOffset" : 61,
      "endOffset" : 86
    }, {
      "referenceID" : 5,
      "context" : ", 2010) or cascade based learning methods such as (Chen et al., 2012).",
      "startOffset" : 50,
      "endOffset" : 69
    } ],
    "year" : 2012,
    "abstractText" : "As machine learning algorithms enter applications in industrial settings, there is increased interest in controlling their cpu-time during testing. The cpu-time consists of the running time of the algorithm and the extraction time of the features. The latter can vary drastically when the feature set is diverse. In this paper, we propose an algorithm, the Greedy Miser, that incorporates the feature extraction cost during training to explicitly minimize the cpu-time during testing. The algorithm is a straightforward extension of stagewise regression and is equally suitable for regression or multi-class classification. Compared to prior work, it is significantly more cost-effective and scales to larger data sets.",
    "creator" : "LaTeX with hyperref package"
  }
}