{
  "name" : "1307.6769.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Streaming Variational Bayes",
    "authors" : [ "Tamara Broderick", "Nicholas Boyd", "Andre Wibisono", "Ashia C. Wilson", "Michael I. Jordan" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "(A)synchronous computation of a Bayesian posterior. The framework makes streaming updates to the estimated posterior according to a user-specified approximation primitive function. We demonstrate the usefulness of our framework, with variational Bayes (VB) as the primitive, by fitting the latent Dirichlet allocation model to two large-scale document collections. We demonstrate the advantages of our algorithm over stochastic variational inference (SVI), both in the single-pass setting SVI was designed for and in the streaming setting, to which SVI does not apply."
    }, {
      "heading" : "1 Introduction",
      "text" : "Large, streaming data sets are increasingly the norm in science and technology. While simple descriptive statistics can often be readily computed with a constant number of operations for each data point in the streaming setting, without the need to revisit past data or have advance knowledge of future data, this is generally not the case for the complex, hierarchical models that practitioners often have in mind when they collect such large data sets. Significant progress on scalable learning procedures has been made in recent years [e.g., 1, 2], but the underlying models remain simple and the inferential framework is generally non-Bayesian. The advantages of the Bayesian paradigm (e.g., hierarchical modeling, coherent treatment of uncertainty) currently seem out of reach in the setting of Big Data.\nAn exception to this statement is provided by recent work by [3–5], who have shown that a class of mean-field variational inference methods known as variational Bayes (VB) [6] can be usefully deployed for large-scale data sets. They\nar X\niv :1\n30 7.\n67 69\nv1 [\nst at\n.M L\n] 2\n5 Ju\nhave applied their approach to the domain of topic modeling of document collections, an area where there is a major need to develop scalable inference algorithms. The method, referred to as stochastic variational inference (SVI) combines VB with stochastic gradient descent. The objective function for SVI is the variational lower bound on the marginal likelihood that is traditionally used in VB, and the idea is to apply stochastic gradient descent to this objective. The problem is that this objective is based on the conceptual existence of a full data set involving D data points (i.e., documents in the topic model setting) for a fixed value of D. Although the stochastic gradient is computed for a single data point (document) at a time, the posterior being targeted is a posterior for D data points. This value of D must be specified in advance, and is used by the algorithm at each step. Posteriors for D′ data points, for D′ 6= D, are not obtained as part of the analysis.\nWe view this lack of a link between the number of documents that have been processed thus far and the posterior that is being targeted as undesirable in many settings involving streaming data, and in this paper we aim at an approximate Bayesian inference algorithm that is scalable like SVI, but is also truly a streaming procedure, in that it yields an approximate posterior for each processed collection of D′ data points—and not just some pre-specified “final” number of data points D. We achieve this by returning to the classical perspective of Bayesian updating, where the recursive application of Bayes theorem provides a sequence of posteriors, not a sequence of approximations to a fixed posterior. To this classical recursive perspective we bring the VB framework—our updates are not exact Bayesian updates but rather are variational approximations. This is similar in spirit to assumed density filtering or expectation propagation [7–9], but each step of those methods involves a moment-matching step that can be computationally costly for models such as topic models. We are able to avoid the moment-matching step via the use of VB. We also note other related work in this general vein: MCMC approximations have been explored by [10], and VB or VB-like approximations have also been explored by [11, 12].\nAlthough the empirical success of SVI is the main motivation for our work, we also note that a return to the classical framework of recursive Bayesian updating is motivated by recent developments in computer architectures, which permit distributed and asynchronous computations in addition to streaming computations. As we will show, a streaming VB algorithm also naturally lends itself to distributed and asynchronous implementations."
    }, {
      "heading" : "2 Streaming, distributed, asynchronous Bayesian up-",
      "text" : "dating"
    }, {
      "heading" : "2.1 Streaming Bayesian updating",
      "text" : "Consider data x1, x2, . . . generated iid according to a distribution p(x | Θ) and assume that a prior p(Θ) has also been specified. Then Bayes theorem gives us the posterior distribution of Θ given a collection of S data points, C1 := (x1, . . . , xS):\np(Θ | C1) = p(C1)−1 p(C1 | Θ) p(Θ),\nwhere p(C1 |Θ) = p(x1, . . . , xS |Θ) = ∏S\ns=1 p(xs |Θ). Suppose we have seen and processed b−1 collections, sometimes called minibatches, of data. Given the posterior p(Θ | C1, . . . , Cb−1), we can calculate the posterior after the bth minibatch:\np(Θ | C1, . . . , Cb) ∝ p(Cb | Θ) p(Θ | C1, . . . , Cb−1). (1)\nThat is, we treat the posterior after b − 1 minibatches as the new prior for the incoming data points. If we can save the posterior from b − 1 minibatches and calculate the normalizing constant for the bth posterior, repeated application of Eq. (1) is streaming; it automatically gives us the new posterior without needing to revisit old data points.\nIn complex models, it is often infeasible to calculate the posterior exactly, and an approximation must be used. Suppose that, given a prior p(Θ) and data minibatch C, we have an approximation algorithm A that calculates an approximate posterior q: q(Θ) = A(C, p(Θ)). Then, setting q0(Θ) = p(Θ), one way to recursively calculate an approximation to the posterior is\np(Θ | C1, . . . , Cb) ≈ qb(Θ) = A (Cb, qb−1(Θ)) . (2)\nWhen A yields the posterior from Bayes theorem, this calculation is exact. This approach already differs from that of [3–5], which we will see (Sec. 3.2) directly approximates p(Θ | C1, . . . , CB) for fixed B without making intermediate approximations for b strictly between 1 and B."
    }, {
      "heading" : "2.2 Distributed Bayesian updating",
      "text" : "The sequential updates in Eq. (2) handle streaming data in theory, but in practice, theA calculation might take longer than the time interval between minibatch\narrivals or simply take longer than desired. Parallelizing computations increases algorithm throughput. And posterior calculations need not be sequential. Indeed,\np(Θ | C1, . . . , CB) ∝ [ B∏ b=1 p(Cb | Θ) ] p(Θ) ∝ [ B∏ b=1 p(Θ | Cb) p(Θ)−1 ] p(Θ)\n(3)\nThat is, we can calculate the individual minibatch posteriors p(Θ | Cb), perhaps in parallel, and then combine them to find the full posterior p(Θ | C1, . . . , CB).\nGiven an approximating algorithmA as above, the corresponding approximate update would be\np(Θ | C1, . . . , CB) ≈ q(Θ) ∝ [ B∏ b=1 A(Cb, p(Θ)) p(Θ)−1 ] p(Θ), (4)\nfor some approximating distribution q, provided the normalizing constant for the right-hand side of Eq. (4) can be computed.\nVariational inference methods are generally based on the exponential family representations [6], and we will make that assumption here. In particular, we suppose p(Θ) ∝ exp{ξ0 ·T (Θ)}; that is, p(Θ) is an exponential family distribution for Θ with sufficient statistic T (Θ) and natural parameter ξ0. We suppose further that A always returns a distribution in the same exponential family; in particular, we suppose that there exists some parameter ξb such that\nqb(Θ) ∝ exp{ξb · T (Θ)} for qb(Θ) = A(Cb, p(Θ)). (5)\nWhen we make these two assumptions, the update in Eq. (4) becomes\np(Θ | C1, . . . , CB) ≈ q(Θ) ∝ exp {[ ξ0 +\nB∑ b=1 (ξb − ξ0)\n] · T (Θ) } , (6)\nwhere the normalizing constant is readily obtained. In what follows we use the shorthand ξ ← A(C, ξ0) to denote thatA takes as input a minibatch C and a prior with exponential family parameter ξ0 and that it returns a distribution in the same exponential family with parameter ξ.\nSo, to approximate p(Θ | C1, . . . , CB), we first calculate ξb via the approximation primitive A for each minibatch Cb; note that these calculations may be performed in parallel. Then we sum together the quantities ξb− ξ0 across b, along\nwith the initial ξ0 from the prior, to find the final exponential family parameter to the full posterior approximation q. We previously saw that the general Bayes sequential update can be made streaming by iterating with the old posterior as the new prior (Eq. (2)). Similarly, here we see that the full posterior approximation q is in the same exponential family as the prior, so one may iterate these parallel computations to arrive at a parallelized algorithm for streaming posterior computation.\nWe emphasize that while these updates are reminiscent of prior-posterior conjugacy, it is actually the approximate posteriors and single, original prior that we assume belong to the same exponential family. It is not necessary to assume any conjugacy in the generative model itself nor that any true intermediate or final posterior take any particular limited form."
    }, {
      "heading" : "2.3 Asynchronous Bayesian updating",
      "text" : "Performing B computations in parallel can in theory speed up algorithm running time by a factor of B, but in practice it is often the case that a single computation thread takes longer than the rest. Waiting for this thread to finish diminishes potential gains from distributing the computations. This problem can be ameliorated by making computations asynchronous. In this case, processors known as workers each solve a subproblem. When a worker finishes, it reports its solution to a single master processor. If the master gives the worker a new subproblem without waiting for the other workers to finish, it can decrease downtime in the system.\nOur asynchronous algorithm is in the spirit of Hogwild! [1]. To present the algorithm we first describe an asynchronous computation that we will not use in practice, but which will serve as a conceptual stepping stone. Note in particular that the following scheme makes the computations in Eq. (6) asynchronous. Have each worker continuously iterate between three steps: (1) collect a new minibatch C, (2) compute the local approximate posterior ξ ← A(C, ξ0), and (3) return ∆ξ := ξ − ξ0 to the master. The master, in turn, starts by assigning the posterior to equal the prior: ξ(post) ← ξ0. Each time the master receives a quantity ∆ξ from any worker, it updates the posterior synchronously: ξ(post) ← ξ(post) + ∆ξ. If A returns the exponential family parameter of the true posterior (rather than an approximation), then the posterior at the master is exact by Eq. (4).\nA preferred asynchronous computation works as follows. The master initializes its posterior estimate to the prior: ξ(post) ← ξ0. Each worker continuously iterates between four steps: (1) collect a new minibatch C, (2) copy the master posterior value locally ξ(local) ← ξ(post). (3) compute the local approximate pos-\nterior ξ ← A(C, ξ(local)), and (4) return ∆ξ := ξ − ξ(local) to the master. Each time the master receives a quantity ∆ξ from any worker, it updates the posterior synchronously: ξ(post) ← ξ(post) + ∆ξ.\nThe key difference between the first and second frameworks proposed above is that, in the second, the latest posterior is used as a prior. This latter framework is more in line with the streaming update of Eq. (2) but introduces a new layer of approximation. Since ξ(post) might change at the master while the worker is computing ∆ξ, it is no longer the case that the posterior at the master is exact when A returns the exponential family parameter of the true posterior. Nonetheless we find that the latter framework performs better in practice, so we focus on it exclusively in what follows.\nWe refer to our overall framework as SDA-Bayes, which stands for (S)treaming, (D)istributed, (A)synchronous Bayes. The framework is intended to be general enough to allow a variety of local approximations A, but in the current paper our preferred local approximation will be VB."
    }, {
      "heading" : "3 Case study: latent Dirichlet allocation",
      "text" : "In order to use SDA-Bayes, one needs to specify: (1) a prior on the global parameter(s) Θ and (2) a posterior-approximating algorithm A. In what follows, we consider examples of both choices in the context of latent Dirichlet allocation (LDA) [13]. LDA models the content of D documents in a corpus. Themes potentially shared by multiple documents are described by topics. The unsupervised learning problem is to learn the topics as well as discover which topics occur in which documents.\nMore formally, each topic (ofK total topics) is a distribution over the V words in the vocabulary: βk = (βkv)Vv=1. Each document is an admixture of topics. The words in document d are assumed to be exchangeable. Each word wdn belongs to a latent topic zdn chosen according to a document-specific distribution of topics θd = (θdk) K k=1. The full generative model, with Dirichlet priors for βk and θd conditioned on respective parameters ηk and α, appears in [13]. To see that this model fits our specification in Sec. 2, consider the set of global parameters Θ = β. Each document wd = (wd,n) Nd n=1 is distributed iid conditioned on the global topics. The full collection of data is a corpus C = w = (wd)Dd=1 of documents. The posterior for LDA, p(β, θ, z | C, η, α), is equal to the following\nexpression up to proportionality:\n∝ [ K∏ k=1 Dirichlet(βk | ηk) ] · [ D∏ d=1 Dirichlet(θd | α) ] · [ D∏ d=1 Nd∏ n=1 θdzdnβzdn,wdn ] . (7)\nThe posterior for just the global parameters p(β | C, η, α) can be obtained from p(β, θ, z |C, η, α) by integrating out the local, document-specific parameters θ, z. As is common in complex models, Eq. (7) is intractable to compute and so must be approximated."
    }, {
      "heading" : "3.1 Posterior-approximation algorithms",
      "text" : "To apply SDA-Bayes to LDA, we use the prior specified by the generative model. It remains to choose a posterior-approximation algorithm A. We consider two possibilities here: variational Bayes (VB) and expectation propagation (EP). Both primitives take Dirichlet distributions as priors for β and both return Dirichlet distributions for the approximate posterior of the topic parameters β; thus the prior and approximate posterior are in the same exponential family. Hence both VB and EP can be utilized as a choice for A in the SDA-Bayes framework.\nMean-field variational Bayes. We use the shorthand pD for Eq. (7), the posterior given D documents. We assume the approximating distribution, written qD for shorthand, takes the form\nqD(β, θ, z | λ, γ, φ) = [ K∏ k=1 qD(βk | λk) ] · [ D∏ d=1 qD(θd | γd) ]\n· [ D∏ d=1 Nd∏ n=1 qD(zdn | φdwdn) ] (8)\nfor parameters (λkv), (γdk), (φdv) with k ∈ {1, . . . , K}, v ∈ {1, . . . , V }, d ∈ {1, . . . , D}. Moreover, we set qD(βk | λk) = DirichletV (βk | λk), qD(θd | γd) = DirichletK(θd | γd), and qD(zdn | φdwdn) = CategoricalK(zdn | φdwdn). The subscripts on Dirichlet and Categorical indicate the dimensions of the distributions (and of the parameters).\nThe problem of VB is to find the best approximating qD, defined as the collection of variational parameters λ, γ, φ that minimize the KL divergence from the true posterior: KL (qD ‖ pD). Even finding the minimizing parameters is a difficult optimization problem. Typically the solution is approximated by coordinate\ndescent in each parameter [6, 13] as in Alg. 1. The derivation of VB for LDA can be found in [4, 13].\nExpectation propagation. An EP [7] algorithm for approximating the LDA posterior appears in Alg. 4 of Sup. Mat. A. Alg. 4 differs from [14], which does not provide an approximate posterior for the topic parameters, and is instead our own derivation. Our version of EP, like VB, learns factorized Dirichlet distributions over topics."
    }, {
      "heading" : "3.2 Other single-pass algorithms for approximate LDA posteriors",
      "text" : "The algorithms in Sec. 3.1 pass through the data multiple times and require storing the data set in memory—but are useful as primitives for SDA-Bayes in the context of the processing of minibatches of data. Next, we consider two algorithms that pass through a data set just one time (single pass) and to which we compare in the evaluations (Sec. 4).\nStochastic variational inference. VB uses coordinate descent to find a value of qD, Eq. (8), that locally minimizes the KL divergence KL (qD ‖ pD). Stochastic variational inference (SVI) [3, 4] is exactly the application of a particular version of stochastic gradient descent to the same optimization problem. While stochastic gradient descent can often be viewed as a streaming algorithm, the optimization problem itself here depends on D via pD, the posterior on D data points. We see that, as a result, D must be specified in advance, appears in each step of SVI (see Alg. 2), and is independent of the number of data points actually processed by the algorithm. SVI is single-pass, though, and therefore has constant memory requirements. We also note that two new parameters, τ0 > 0 and κ ∈ (0.5, 1], appear in SVI, beyond those in VB, to determine a learning rate ρt as a function of iteration t: ρt := (τ0 + t)−κ.\nSufficient statistics. On each round of VB (Alg. 1), we update the local parameters for all documents and then compute λkv ← ηkv + ∑D d=1 φdvkndv. An alternative single-pass (and indeed streaming) option would be to update the local parameters for each minibatch of documents as they arrive and then add the corresponding terms φdvkndv to the current estimate of λ for each document d in the minibatch. This essential idea has been proposed previously for models other than LDA by [11, 12] and forms the basis of what we call the sufficient statistics update algorithm (SSU): Alg. 3. This algorithm is equivalent to SDA-Bayes with A chosen to be a single iteration over the global variable λ of VB (i.e., updating\nλ exactly once instead of iterating until convergence)."
    }, {
      "heading" : "4 Evaluation",
      "text" : "We compare SDA-Bayes with VB and EP primitives to SVI and SSU."
    }, {
      "heading" : "4.1 Performance measure",
      "text" : "We follow [4] (and further [15, 16]) in evaluating our algorithms by computing (approximate) predictive probability. Under this metric, a higher score is better, as a better model will assign a higher probability to the held-out words.\nWe calculate predictive probability by first setting aside held-out testing documentsC(test) from the full corpus and then further setting aside a subset of held-out testing words Wd,test in each testing document d. The remaining (training) documents C(train) are used to estimate the global parameter posterior q(β), and the remaining (training) words Wd,train within the dth testing document are used to estimate the document-specific parameter posterior q(θd).1 To calculate predictive probability, an approximation is necessary since we do not know the predictive distribution—just as we seek to learn the posterior distribution. Specifically, we calculate the normalized predictive distribution and report “log predictive probability” as ∑\nd∈C(test) log p(Wd,test | C(train),Wd,train)∑ d∈C(test) |Wd,test|\n=\n∑ d∈C(test) ∑ wtest∈Wd,test log p(wtest | C\n(train),Wd,train)∑ d∈C(test) |Wd,test| ,\nwhere we use the approximation\np(wtest | C(train),Wd,train)\n= ∫ β ∫ θd ( K∑ k=1 θdkβkwtest ) p(θd | Wd,train, β) p(β | C(train)) dθd dβ\n≈ ∫ β ∫ θd ( K∑ k=1 θdkβkwtest ) q(θd) q(β) dθd dβ = K∑ k=1 Eq[θdk] Eq[βkwtest ].\n1 In all cases, we estimate q(θd) for evaluative purposes using VB since direct EP estimation takes prohibitively long."
    }, {
      "heading" : "4.2 Experiments",
      "text" : "To facilitate comparison with SVI, we use the full Wikipedia corpus of [5] (rather than the subset Wikipedia corpus of [3]) and the Nature corpus of [3] for our experiments. These two corpuses represent a range of sizes (3,611,558 training documents for Wikipedia and 351,525 for Nature) as well as different types of topics. We expect words in Wikipedia to represent an extremely broad range of topics whereas we expect words in Nature to focus more on the sciences. We further use the vocabularies of [3, 5] and SVI code available online at [17]. We hold out 10,000 Wikipedia documents and 1,024 Nature documents (not included in the counts above) for testing. In all cases, we fit an LDA model with K = 100 topics and hyperparameters chosen as: ∀k, αk = 1/K, ∀(k, v), ηkv = 1.\nFor both Wikipedia and Nature, we set the parameters in SVI according to the values of the parameters described in Table 1 of [3] (minibatch size 4,096, number of documents D correctly set in advance, step size parameters κ = 0.5 and τ0 = 64). We give single-thread SDA-Bayes and SSU the same minibatch size. Performance and timing results are shown in Table 1, where we can see that SVI and single-thread SDA-Bayes have comparable performance, while SSU performs much worse. SVI is faster than single-thread SDA-Bayes.\nFull SDA-Bayes improves performance and run time. We handicap SDABayes in the above comparisons by utilizing just a single thread. In Table 1, we also report performance of SDA-Bayes with 32 threads and a minibatch size of 256.\nFig. 2 shows the performance of SDA-Bayes when we run with {1, 2, 4, 8, 16, 32} threads. To generate these figures, we use a minibatch size of 512 for Wikipedia and 128 for Nature. We can see from the figures that log predictive probability improves, and run time decreases, as the number of threads increase. We also tried a parallel version of the algorithm (synchronous); Fig. 2 indicates that most of the speedup and performance improvement come from parallelizing—which is theoretically justified by Eq. (3) when A is Bayes rule. Our experiments indicate that our Hogwild!-style asynchrony does not hurt performance. In general, a practitioner might prefer asynchrony since it is more robust to node failures.\nSVI is sensitive to the choice of total data size D. The evaluations above are for a single posterior over D data points. Of greater concern to us in this work is the evaluation of algorithms in the streaming setting. We have seen that SVI is designed to find the posterior for a particular, pre-chosen number of data points D. In practice, when we run SVI on the full data set but change the input value of D in the algorithm, we can see degradations in performance. In particular, we try values of D equal to {0.01, 0.1, 1, 10, 100} times the true D in Fig. 3(a) for the Wikipedia data set and in Fig. 3(d) for the Nature data set.\nA practitioner in the streaming setting will typically not know D in advance, and the figures illustrate that an estimate may not be sufficient. Even in the case where D is known in advance, it is reasonable to imagine a new influx of further data. One might need to run SVI again from the start (and, in so doing, revisit the first data set) to obtain the desired performance.\nSDA-Bayes is less sensitive to minibatch size than SVI is. Like SVI, SDABayes acquires data in minibatches. We see from Figs. 3(b) and 3(e) that performance is affected by minibatch size for both SVI and SDA-Bayes; we try sizes {16, 64, 256, 1024, 4096} for both algorithms. However, performance of SDABayes is roughly the same across all minibatch sizes tried here. By contrast, SVI performance degrades rapidly for smaller minibatch sizes. Not only does this result suggest a sensitivity for SVI that may require careful choices before run time but it is also problematic if learning the model in smaller data increments is desired in a practical setting.\nSVI is sensitive to learning step size. [3, 5] use cross-validation to tune stepsize parameters (τ0, κ) in the stochastic gradient descent component of the SVI algorithm. This cross-validation requires multiple runs over the data and thus is not suited to the streaming setting. Figs. 3(c) and 3(f) demonstrate that the parameter choice does indeed affect algorithm performance. In these figures, we keep minibatch size at 4,096 and D at the true training data size.\nWe note that, in the Wikipedia case (Fig. 3(c)), we find better SVI performance\nfor parameters (τ0, κ) = (64, 1) than for the reported optimal (τ0, κ) = (64, 0.5) in [3]. The former case is comparable to that of 32-SDA in Table 1. The discrepancy may stem from the fact that [3] ran on a subset of 100,000 documents, and here we use the full Wikipedia corpus. Recent work has suggested a way to update (τ0, κ) adaptively during an SVI run [18].\nEP is not suited to LDA. Earlier attempts to apply EP to the LDA model in the non-streaming setting have had mixed success, with [19] in particular finding that EP performance can be poor for LDA and, moreover, EP requires “unrealistic intermediate storage requirements.” We found this to also be true in the streaming setting. We were not able to obtain competitive results with EP; based on an 8- thread implementation of SDA-Bayes with an EP primitive2, after over 91 hours on Wikipedia (and 6.7× 104 data points), log predictive probability had stabilized at around −7.95 and, after over 97 hours on Nature (and 9.7 × 104 data points), log predictive probability had stabilized at around −8.02. Although SDA-Bayes with the EP primitive is not effective for LDA, it remains to seen whether this combination may be useful in other domains where EP is known to be effective."
    }, {
      "heading" : "5 Discussion",
      "text" : "We have introduced SDA-Bayes, a framework for streaming, distributed, asynchronous computation of an approximate Bayesian posterior. Our framework makes streaming updates to the estimated posterior according to a user-specified approximation primitive. We have demonstrated the usefulness of our framework, with variational Bayes as the primitive, by fitting the latent Dirichlet allocation topic model to the Wikipedia and Nature corpora. We have demonstrated the advantages of our algorithm over stochastic variational inference and the sufficient statistics update algorithm, particularly with respect to the key issue of obtaining approximations to posterior probabilities based on the number of documents seen thus far, not posterior probabilities for a fixed number of documents."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We are grateful to Matt Hoffman for useful discussions and advice. We thank Matt Hoffman, Chong Wang, and John Paisley for generously sharing their code and data. T. Broderick is supported by the Berkeley Fellowship. N. Boyd is supported\n2We chose 8 threads since any fewer was too slow to get results and anything larger created too high of a memory demand on our system.\nby a Hertz Foundation Google Fellowship. A. C. Wilson is supported by the Chancellor’s Fellowship at UC Berkeley. This research is supported in part by NSF CISE Expeditions award CCF-1139158 and DARPA XData Award FA875012-2-0331, and gifts from Amazon Web Services, Google, SAP, Blue Goji, Cisco, Clearstory Data, Cloudera, Ericsson, Facebook, General Electric, Hortonworks, Intel, Microsoft, NetApp, Oracle, Samsung, Splunk, VMware and Yahoo!. This material is based upon work supported in part by the Office of Naval Research under contract/grant number N00014-11-1-0688."
    }, {
      "heading" : "A Expectation Propagation",
      "text" : "Our expectation propagation (EP) algorithm for LDA learns a posterior for both the document-specific topic mixing proportions (θd)Dd=1 and the topic distributions over words (βk)Kk=1. By contrast, the algorithm in [14] learns only the former and so is not appropriate to the model in Sec. 3.\nFor consistency, we also follow [14] in making a distinction between token and type word updates, where a token refers to a particular word instance and a type refers to all words with the same vocabulary value. Let C = (wd)Dd=1 denote the set of documents that we observe, and for each word v in the vocabulary, let ndv denote the number of times v appears in document d.\nCollapsed posterior. We begin by collapsing (i.e., integrating out) the word assignments z in the posterior (7) of LDA. We can express the collapsed posterior as\np(β, θ | C, η, α)\n∝ [ K∏ k=1 DirichletV (βk | ηk) ] · D∏ d=1 [ DirichletK(θd | α) · V∏ v=1 ( K∑ k=1 θdk βkv )ndv] .\nFor each document-word pair (d, v), consider approximating the term ∑K\nk=1 θdkβkv above by [\nK∏ k=1 DirichletV (βk | χkdv + 1V )\n] · DirichletK(θd | ζdv + 1K),\nwhere χkdv ∈ RV , ζdv ∈ RK , and 1M is a vector of all ones of length M . This proposal serves as inspiration for taking the approximating variational distribution for p(β, θ | C, η, α) to be of the form\nq(β, θ | λ, γ) := [ K∏ k=1 q(βk | λk) ] · D∏ d=1 q(θd | γd), (9)\nwhere q(βk | λk) = Dirichlet(βk | λk) and q(θd | γd) = Dirichlet(θd | γd), with the parameters\nλk = ηk + D∑ d=1 V∑ v=1 ndvχkdv, γd = α + V∑ v=1 ndvζdv, (10)\nand the constraints λk ∈ RV+ and γd ∈ RK+ for each k and d. We assume this form in the remainder of the analysis and write q(β, θ | χ, ζ) for q(β, θ | λ, γ), where χ = (χkdv), ζ = (ζdv).\nOptimization problem. We seek to find the optimal parameters (χ, ζ) by minimizing the (reverse) KL divergence:\nmin χ,ζ\nKL (p(β, θ | C, η, α) ‖ q(β, θ | χ, ζ)) .\nThis joint minimization problem is not tractable, and the idea of EP is to proceed iteratively by fixing most of the factors in Eq. (9) and minimizing the KL divergence over the parameters related to a single word.\nMore formally, suppose we already have a set of parameters (χ, ζ). Consider a document d and word v that occurs in document d (i.e., ndv ≥ 1). We start by removing the component of q related to (d, v) in Eq. (9). Following [7], we subtract out the effect of one occurrence of word v in document d, but at the end of this process we update the distribution on the type level. In doing so, we use the following shorthand for the remaining global parameters:\nλ \\(d,v) k = λk − χkdv = ηk + (ndv − 1)χkdv + ∑ (d′,v′):(d′,v′)6=(d,v) nd′v′χkd′v′\nγ \\(d,v) d = γd − ζdv = α + (ndv − 1)ζdv + ∑ v′:v′ 6=v ndv′ζdv′ .\nWe replace this removed part of q by the term ∑K\nk=1 θdkβkv, which corresponds to the contribution of one occurrence of word v in document d to the true posterior p. Call the resulting normalized distribution q̃dv, so\nq̃dv(β, θ | λ\\(d,v), γ\\d, γ\\(d,v)d )\n∝ [ K∏ k=1 Dirichlet(βk | λ\\(d,v)k ) ] · [∏ d′ 6=d Dirichlet(θd′ | γd′) ]\n· Dirichlet(θd | γ\\(d,v)d ) · K∑ k=1 θdk βkv.\nWe obtain an improved estimate of the posterior q by updating the parameters from (λ, γ) to (λ̂, γ̂), where\n(λ̂, γ̂) = arg min λ′,γ′\nKL ( q̃dv(β, θ | λ\\(d,v), γ\\d, γ\\(d,v)d ) ‖ q(β, θ | λ ′, γ′) ) . (11)\nSolution to the optimization problem. First, note that for d′ : d′ 6= d, we have γ̂d′ = γd′ .\nNow consider the index d chosen on this iteration. Since β and θ are Dirichletdistributed under q, the minimization problem in Eq. (11) reduces to solving the moment-matching equations [7, 20]\nEq̃dv [log βku] = Eλ̂k [log βku] for 1 ≤ k ≤ K, 1 ≤ u ≤ V, Eq̃dv [log θdk] = Eγ̂d [log θdk] for 1 ≤ k ≤ K.\nThese can be solved via Newton’s method though [7] recommends solving exactly for the first and “average second” moments of βku and θdk, respectively, instead. We choose the latter approach for consistency with [7]; our own experiments also suggested taking the approach of [7] was faster than Newton’s method with no noticeable performance loss. The resulting moment updates are\nλ̂ku =\n∑V y=1 ( Eq̃dv [β2ky]− Eq̃dv [βky] )∑V y=1 ( Eq̃dv [βky]2 − Eq̃dv [β2ky]\n) · Eq̃dv [βku] (12) γ̂dk = ∑K j=1 ( Eq̃dv [θ2dj]− Eq̃d,n [θdj]\n)∑K j=1 ( Eq̃dv [θdj]2 − Eq̃dv [θ2dj]\n) · Eq̃dv [θdk]. (13) We then set (χkdv)Kk=1 and ζdv such that the new global parameters (λk) K k=1 and γd are equal to the optimal parameters (λ̂k)Kk=1 and γ̂d. The resulting algorithm is presented as Alg. 4.\nThe results in the main text (Sec. 4.2) are reported for Alg. 4. We also tried a slightly modified EP algorithm that makes token-level updates to parameter values, rather than type-level updates. This modified version iterates through each word placeholder in document d; that is, through pairs (d, n) rather than pairs (d, v) corresponding to word values. Since there are always at least as many (d, n) pairs as (d, v) pairs with ndv ≥ 1 (and usually many more of the former), the modified algorithm requires many more iterations. In practice, we find better experimental performance for the modified EP algorithm in terms of log predictive probability as a function of number of data points in the training set seen so far: e.g., leveling off at about −7.96 for Nature vs. −8.02. However, the modified algorithm is also much slower, and still returns much worse results than SDA-Bayes or SVI, so we do not report these results in the main text.\nAlgorithm 4: EP for LDA Input: Data C = (wd)Dd=1; hyperparameters η, α Output: λ Initialize ∀(k, d, v), χkdv ← 0 and ζdv ← 0 while (χ, ζ) not converged do\nforeach (d, v) with ndv ≥ 1 do /* Variational distribution without the word\ntoken (d, v) */ ∀k, λ\\(d,v)k ← ηk + (ndv − 1)χkdv + ∑ (d′,v′)6=(d,v) nd′v′χkd′v′ γ \\(d,v) d ← α + (ndv − 1)ζdv + ∑ v′ 6=v ndv′ζdv′ If any of λ\\(d,v)ku or γ \\(d,v) dk are non-positive, skip updating this (d, v) /* Variational parameters from moment-matching */ ∀(k, u), compute λ̂ku from Eq. (12) ∀k, compute γ̂dk from Eq. (13) /* Type-level updates to parameter values */\n∀k, χkdv ← n−1dv ( λ̂k − λ\\(d,v)k ) + ( 1− n−1dv ) χkdv\nζdv ← n−1dv ( γ̂d − γ\\(d,v)d ) + ( 1− n−1dv ) ζdv Other χ, ζ remain unchanged\n/* Global variational parameters */ ∀k, λk ← ηk + ∑D\nd=1 ∑V v=1 ndvχkdv"
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "<lb>We present SDA-Bayes, a framework for (S)treaming, (D)istributed,<lb>(A)synchronous computation of a Bayesian posterior. The framework makes<lb>streaming updates to the estimated posterior according to a user-specified<lb>approximation primitive function. We demonstrate the usefulness of our<lb>framework, with variational Bayes (VB) as the primitive, by fitting the la-<lb>tent Dirichlet allocation model to two large-scale document collections. We<lb>demonstrate the advantages of our algorithm over stochastic variational in-<lb>ference (SVI), both in the single-pass setting SVI was designed for and in<lb>the streaming setting, to which SVI does not apply.",
    "creator" : "LaTeX with hyperref package"
  }
}