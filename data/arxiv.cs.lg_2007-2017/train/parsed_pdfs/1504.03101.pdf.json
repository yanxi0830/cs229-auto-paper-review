{
  "name" : "1504.03101.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Convex Learning of Multiple Tasks and their Structure",
    "authors" : [ "Carlo Ciliberto", "Youssef Mroueh", "Tomaso Poggio", "Lorenzo Rosasco" ],
    "emails" : [ "(cciliber@mit.edu)", "(tp@ai.mit.edu)", "(lrosasco@mit.edu)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 4.\n03 10\n1v 2\n[ cs\n.L G\n] 1"
    }, {
      "heading" : "1 Introduction",
      "text" : "Current machine learning systems achieve remarkable results in several challenging tasks, but are limited by the amount of human supervision required. Leveraging similarity among different problems is widely acknowledged to be a key approach to reduce the need for supervised data. Indeed, this idea is at the basis of multi-task learning, where the joint solution of different problems (tasks) has the potential to exploit tasks relatedness (structure) to improve learning accuracy. This idea has motivated a variety of methods, including frequentist [25, 3, 4] and Bayesian methods (see e.g. [1] and references therein), with connections to structured learning [6, 34]. The focus of our study is the development of a general regularization framework to learn multiple tasks as well as their structure. Following [25, 15] we consider a setting where tasks are modeled as the components of a vector-valued function and their\n∗Laboratory for Computational and Statistical Learning, Istituto Italiano di Tecnologia, Via Morego, 30, 16100, Genova, Italy, (cciliber@mit.edu)\n†Poggio Lab, Massachusetts Institute of Technology, Massachusetts Ave. 77, 02139, Cambridge, MA, USA (tp@ai.mit.edu)\n‡DIBRIS, Università di Genova, Via Dodecaneso, 35, 16146, Genova, Italy, (lrosasco@mit.edu)\nstructure corresponds to the choice of suitable functional spaces. Exploiting the theory of reproducing kernel Hilbert spaces for vector-valued functions (RKHSvv) [25], we consider and analyze a flexible regularization framework, within which a variety of previously proposed approaches can be recovered as special cases, see e.g. [19, 24, 26, 37, 14, 31]. Our main technical contribution is a unifying study of the minimization problem corresponding to such a regularization framework. More precisely, we devise an optimization approach that can efficiently compute a solution and for which we prove convergence under weak assumptions. Our approach is based on a barrier method that is combined with block coordinate descent techniques [33, 30]. In this sense our analysis generalizes the results in [3] for which a low-rank assumption was considered; however the extension is not straightforward, since we consider a much larger class of regularization schemes (any convex penalty). Up to our knowledge, this is the first result in multi-task learning proving the convergence of alternating minimization schemes for such a general family of problems. The RKHSvv setting allows to naturally deal both with linear and non-linear models and the approach we propose provides a general computational framework for learning output kernels as formalized in [14]. The rest of the paper is organized as follows: in Sec 2 we review basic ideas of regularization in RKHSvv. In Sec. 2.3 we discuss the equivalence of different approaches to encode known structures among multiple tasks. In Sec. 3 we discuss a general framework for learning multiple tasks and their relations where we consider a wide family of structure-inducing penalties and study an optimization strategy to solve them. This setting allows us, in Sec. 4, to recover several previous methods as special cases. Finally in Sec. 5 we evaluate the performance of the optimization method proposed.\nNotation. With Sn++ ⊂ Sn+ ⊂ Sn ⊂ Rn×n we denote respectively the space of positive definite, positive semidefinite (PSD) and symmetric n×n real-valued matrices. On denotes the space of orthonormaln×n matrices. For any square matrix M ∈ Rn×n and p ≥ 1, we denote by ‖M‖p = ( ∑n i=1 σi(M)\np)1/p the p-Schatten norm of M , where σi(M) is the i-th largest singular value of M . For any M ∈ Rn×m, M⊤ denotes the transpose of M . For any PSD matrix A ∈ Sn+, A† denotes the pseudoinverse of A. We denote by In ∈ Sn++ the n × n identity matrix. The notation Ran(M) ⊆ Rm identifies the range of columns of a matrix M ∈ Rm×n."
    }, {
      "heading" : "2 Background",
      "text" : "We study the problem of jointly learning multiple tasks by modeling individual taskpredictors as the components of a vector-valued function. Let us assume to have T supervised scalar learning problems (or tasks), each with a “training” set of inputoutput observations St = {(xit, yit)}nti=1 with xit ∈ X input space and yit ∈ Y output space1. Given a loss function L : R × R → R+ that measures the per-task prediction\n1To avoid clutter in the notation, we have restricted ourselves to the typical situation where all tasks share same input and output spaces, i.e. Xt = X and Yt ⊆ R.\nerrors, we want to solve the following joint regularized learning problem\nminimize f∈H\nT∑\nt=1\n1\nnt\nnt∑\ni=1\nL(y(t)i , ft(x (t) i )) + λ‖f‖2H (1)\nwhere H is an Hilbert space of vector-valued functions f : X → YT with scalar components ft : X → Y . In order to define a suitable space of hypotheses H, in this section we briefly recall concepts from the theory of reproducing kernel Hilbert spaces for vector-valued functions (RKHSvv) and corresponding regularization theory, which plays a key role in our work. In particular, we focus on a class of reproducing kernels (known as separable kernels) that can be designed to encode specific tasks structures (see [15, 2] and Sec. 2.3). Interestingly, separable kernels are related to ideas such as defining a metric on the output space or a label encoding in multi-label problems (see Sec. 2.3)\nRemark 2.1 (Multi-task and multi-label learning). Multi-label learning is a class of supervised learning problems in which the goal is to associate input examples with a label or a set of labels chosen from a discrete set. In general, due to discrete nature of the output space, these problems cannot be solved directly; hence, a so-called surrogate problem is often introduced, which is computationally tractable and whose solution allows to recover the solution of the original problem [32, 7, 28]. Multi-label learning and multi-task learning are strongly related. Indeed, surrogate problems typically consist in a set of distinct supervised learning problems (or tasks) that are solved simultaneously and therefore have a natural formulation in the multitask setting. For instance, in multi-class classification problems the “One vs All” strategy is often adopted, which consists in solving a set of multiple binary classification problems, one for each class."
    }, {
      "heading" : "2.1 Learning Multiple Tasks with RKHSvv",
      "text" : "In the scalar setting, reproducing kernel Hilbert spaces have already been proved to be a powerful tool for machine learning applications. Interestingly, the theory of RKHSvv and corresponding Tikhonov regularization scheme follow closely the derivation in the scalar case.\nDefinition 2.2. Let (H, 〈·, ·〉H) be a Hilbert space of functions from X to RT . A symmetric, positive definite, matrix-valued function Γ : X × X → RT×T is called a reproducing kernel for H if for all x ∈ X , c ∈ RT and f ∈ H we have that Γ(x, ·)c ∈ H and the following reproducing property holds 〈f(x), c〉RT = 〈f,Γ(x, ·)c〉H.\nIn analogy to the scalar setting, it can be proved (see [25]) that the Representer Theorem holds also for regularization in RKHSvv. In particular we have that any solution of the learning problem introduced in Eq. (1) can be written in the form\nf(x) =\nT∑\nt=1\nnt∑\ni=1\nΓ(x, x (t) i )c (t) i (2)\nwith c(t)i ∈ RT coefficient vectors. The choice of kernel Γ induces a joint representation of the inputs as well as a structure among the output components [1]; In the rest of the paper we will focus on so-called separable kernels, where these two aspects are factorized. In Section 3, we will see how separable kernels provide a natural way to learn the tasks structure as well as the tasks."
    }, {
      "heading" : "2.2 Separable Kernels",
      "text" : "Separable (reproducing) kernels are functions of the formΓ(x, x′) = k(x, x′)A ∀x, x′ ∈ X where k : X × X → R is a scalar reproducing kernel and A ∈ ST+ is a positive semi-definite (PSD) matrix. In this case, the representer theorem allows to rewrite problem (1) in a more compact matrix notation as\nminimize C∈Rn×T\nV (Y,KCA) + λ tr(AC⊤KC). (P)\nHere Y ∈ Rn×T is a matrix with n = ∑Tt=1 nt rows containing the output points; K ∈ Sn+ is the empirical kernel matrix associated to k and V : Rn×T × Rn×T → R+ generalizes the loss in (1) and consists in a linear combination of the entry-wise application of L. Notice that this formulation accounts also the situation where not all training outputs y(t) are observed when a given input x ∈ X is provided: in this case the functional V weights 0 the loss values of those entries of Y (and the associated entries of KCA) that are not available in training. Finally, the second term in (P) follows by observing that, for all f ∈ H of the form f(·) = ∑ni=1 k(xi, ·)Aci, the squared norm can be written as ‖f‖2H = ∑n i,j k(xi, xj)c ⊤ i Acj = tr(AC⊤KC) where C ∈ Rn×T is the matrix with i-th row corresponding to the coefficient vector ci ∈ RT of f . Notice that we have re-ordered the index i to be in {1, . . . , n} to ease the notation."
    }, {
      "heading" : "2.3 Incorporating Known Tasks Structure",
      "text" : "Separable kernels provide a natural way to incorporate the task structure when the latter is known a priori. This strategy is quite general and indeed in the following we comment on how the matrix A can be chosen to recover several multi-task methods previously proposed in contexts such as regularization, coding/embeddings or output metric learning, postponing a more detailed discussion in the supplementary material. These observations motivate the extension in Sec. 3 of the learning problem (P) to a setting where it is possible to infer A from the data.\nRegularizers. Tasks relations can be enforced by devising suitable regularizers [15]. Interestingly, for a large class of such methods it can be shown that this is equivalent to the choice of the matrix A (or rather its pseudoinverse) [25]. If we consider the squared norm of a function f = ∑n i=1 k(xi, ·)Aci ∈ H we have (see [15])\n‖f‖2H = T∑\nt,s=1\nA†ts〈ft, fs〉Hk (3)\nwhere At is the t-th column of A, Hk is the RKHS associated to the scalar kernel k and ft = ∑n i=1 k(xi, ·)A⊤t ci ∈ Hk is the t-th component of f . The above equation suggests to interpret A† as the matrix that models the structural relations between tasks by directly coupling different predictors. For instance, by setting A† = IT + γ(11⊤)/T , with 1 ∈ RT the vector of all 1s, we have that the parameter γ controls the variance∑T\nt=1 ‖f̄−ft‖2Hk of the tasks with respect to their mean f̄ = 1 T ∑T t=1 ft. If we have access to some notion of similarity among tasks in the form of a graph with adjacency matrix W ∈ ST , we can consider the regularizer∑Tt,s=1 Wt,s‖ft−fs‖2Hk+γ ∑T t ‖ft‖2Hk which corresponds to A† = L+ γIT with L the graph Laplacian induced by W .\nOutput Metric. A different approach to model tasks relatedness consists in choosing a suitable metric on the output space to reflect the tasks structure [24]. Clearly a change of metric on the output space with the standard inner product 〈y, y′〉RT between two output points y, y′ ∈ YT corresponds to the choice of a different inner product 〈y, y′〉Θ = 〈y, θy′〉RT for some positive definite matrix Θ ∈ ST++. Indeed this can be direct related to the choice of a suitable separable kernel. In particular, for the least squares loss function a direct equivalence holds between choosing a metric deformation associated to a Θ ∈ ST++ and a separable kernel k(·, ·)IT or use the canonical metric (i.e. with Θ = IT the identity) and kernel k(·, ·)Θ. The details of this equivalence can be found in the supplementary material.\nOutput Representation. The tasks structure can also be modeled by designing an ad-hoc embedding for the output space. This approach is particularly useful for multilabel scenarios, where output embedding can be designed to encode complex structures such as (e.g. trees, strings, graphs, etc.) [17, 21, 11]. Interestingly in these cases, or more generally whenever the embedding map L : YT → Ỹ , from the original to the new output space, is linear, then it is possible to show that the learning problem with new code is equivalent to (1) for a suitable choice of separable kernel with A = L⊤L. We refer again to the supplementary material for the details of this equivalence."
    }, {
      "heading" : "3 Learning the Tasks and their Structure",
      "text" : "Clearly, an interesting setting occurs when knowledge of the tasks structure is not available and therefore it is not possible to design a suitable separable kernel. In this case a favorable approach is to infer the tasks relations directly from the data. To this end we propose to consider the following extension of problem (P)\nminimize C∈Rn×T ,A∈ST\n+\nV (Y,KCA) + λtr(AC⊤KC) + F (A), (Q)\nwhere the penalty F : ST+ → R+ is designed to learn specific tasks structures encoded in the matrix A. The above regularization is general enough to encompass a large number of previously proposed approaches by simply specifying a choice of the scalar kernel and the penalty F . A detailed discussion of these connections is postponed to Section 4. In this section, we focus on computational aspects. Throughout,\nwe restrict ourselves to convex loss functions V and convex (and coercive) penalties F . In this case, the objective function in (Q) is separately convex in C and A but not jointly convex. Hence, block coordinate methods, which are often used in practice, e.g. alternating minimization over C and A, are not guaranteed to converge to a global minimum. Our study provides a general framework to provably compute a solution to problem (Q). First, In Section 3.1, we prove our main results providing a characterization of the solutions of Problem (Q) and studying a barrier method to cast their computation as a convex optimization problem. Second, in Section 3.2, we discuss how block coordinate methods can be naturally used to solve such a problem, analyze their convergence properties and discuss some general cases of interest."
    }, {
      "heading" : "3.1 Characterization of Minima and A Barrier Method",
      "text" : "We begin, in Section 3.1.1, providing a characterization of the solutions to Problem (Q) by showing that it has an equivalent formulation in terms of the minimization of a convex objective function, namely Problem (R). Depending on the behavior of the objective function on the boundary of the optimization domain, Problem (R) might not be solved using standard optimization techniques. This possible issue motivates the introduction, in Section 3.1.2, of a barrier method; a family of “perturbated” convex programs is introduced whose solutions are shown to converge to those of Problem (R) (and hence of the original (Q)).\n3.1.1 An Equivalent formulation for (Q) The objective functional in (Q) is not convex, therefore in principle it is hard to find a global minimizer. As it turns out however, it is possible to circumvent this issue and efficiently find a global solution to (Q). The following result represents a first step in this direction.\nTheorem 3.1. Let K ∈ Sn+ and consider the convex set\nC = { (C,A) ∈ Rn×T × ST+ | Ran(C⊤KC) ⊆ Ran(A) } .\nThen, for any F : ST+ → R+ convex and coercive, problem\nminimize (C,A) ∈ C\nV (Y,KC) + λtr ( A†C⊤KC ) + F (A) (R)\nhas convex objective function and it is equivalent to (Q). In particular, the two problems achieve the same minimum value and, given a solution (CR, AR) for (R), the couple (CRA † R, AR) is a minimizer for (Q). Vice-versa, given a solution (CQ, AQ) for (Q), the couple (CQAQ, AQ) is a minimizer for (R). The above result highlights a remarkable connection between the problems (Q) (non-convex) and (R) (convex). In particular, we have the following Corollary, which provides us with a useful characterization of the local minimizers of problem (Q). Corollary 3.2. Let Q : Rn×T × ST+ → R be the objective function of problem (Q). Then, every local minimizer for Q on the open set Rn×T × ST++ is also a global minimizer.\nCorollary 3.2 follows from Theorem 3.1 and the fact that, on the restricted domain R\nn×T × ST++, the map Q is the combination of the objective functional of (R) and the invertible function (C,A) 7−→ (CA,A). Moreover, if Q is differentiable, i.e. V and the penalty F are differentiable, this is exactly the definition of a convexifiable function, which in particular implies invexity [12]. The latter property ensures that, in the differentiable case, all the stationary points (rather than only local minimizers) are global minimizers. This result was originally proved in [14] for the special case of V the least-squares loss and F (·) = ‖ · ‖2F the Frobenius norm; Here we have proved its generalization to all convex losses V and penalties F . We end this section adding two comments. First, we note that, while the objective function in Problem (R) is convex, the corresponding minimization problem might not be a convex program (in the sense that the feasible set C is not identified by a set of linear equalities and non-linear convex inequalities [9]). Second, Corollary (3.2) holds only on the interior of the minimization domain Rn×T ×ST+ and does not characterize the behavior of the target functional on its boundary. In fact, one can see that both issues can be tackled defining a perturbed objective functional having a suitable behavior on the boundary of the minimization domain. This is the key motivation for the barrier method we discuss in the next section.\n3.1.2 A Barrier Method to Optimize (R)\nHere we propose a barrier approach inspired by the work in [3] by introducing a perturbation of problem (R) that enforces the objective functions to be equal to +∞ on the boundary of Rn×T × ST+. As a consequence, each perturbed problem can be solved as a convex optimization constrained on a closed cone. The latter comment is made more precise in the following result that we prove in the supplementary material.\nTheorem 3.3. Consider the family of optimization problems\nminimize C∈Rn×T ,\nA∈ST+\nV (Y,KC) + λtr(A−1(C⊤KC + δ2IT )) + F (A) (Sδ)\nwith IT ∈ ST++ the identity matrix. Then, for each δ > 0 the problem (Sδ) admits a minimum. Furthermore, the set of minimizers for (Sδ) converges to the set of minimizers for (R) as δ tends to zero. More precisely, given any sequence δm > 0 such that δm → 0 and a sequence of minimizers (Cm, Am) ∈ Rn×T × ST+ for (Sδ), there exists a sequence (C∗m, A ∗ m) ∈ Rn×T × ST+ of minimizers for (R) such that ‖Cm − C∗m‖F + ‖Am −A∗m‖F → 0 as m → +∞.\nThe barrier δ2tr(A−1) is fairly natural and can be seen as preconditioning of the problem leading to favorable computations. The proposed barrier method is similar in spirit to the approach developed in [3] and indeed Theorem 3.3 and next Corollary 3.4 are a generalization over the two main results in [3] to any convex penaltyF on the cone of PSD matrices. However, notice that since we are considering a much wider family of penalties (than the trace norm as in [3]) our results cannot directly derived from those in [3]. In the next section we discuss how to compute the solution of Problem (Sδ) considering a block coordinate approach.\nAlgorithm 1 CONVEX MULTI-TASK LEARNING\nInput: K,Y, ǫ tolerance, δ perturbation parameter, S objective functional of (Sδ), V loss, F structure penalty. Initialize: (C,A) = (C0, A0), t = 0 repeat\nCt+1 ← SUPERVISEDSTEP (V,K, Y, Ct, At) At+1 ← UNSUPERVISEDSTEP(F,K, δ, Ct+1, At) t ← t+ 1\nuntil |S(Ct+1, At+1)− S(Ct, At)| < ǫ"
    }, {
      "heading" : "3.2 Block Coordinate Descent Methods",
      "text" : "The characteristic block variable structure of the objective function in problem (Sδ), suggests that it might be beneficial to use block coordinate methods (BCM) (see [8]) to solve it. Here with BCM we identify a large class of methods that, in our setting, iterate steps of an optimization on C, with A fixed, followed by an optimization of A, for C fixed. A meta block coordinate algorithm to solve (Sδ) is reported in in Algorithm 1. Here we interpret each optimization step over C as a supervised step, and each optimization step over A as a an unsupervised step (in the sense that it involves the inputs but not the outputs). Indeed, when the structure matrix A is fixed, problem (R) boils down to the standard supervised multi-task learning frameworks where a priori knowledge regarding the tasks structure is available. Instead, when the coefficient matrix C is fixed, the problem of learning A can be interpreted as an unsupervised setting in which the goal is to actually find the underlying task structure [23]. Several optimization methods can be used as procedures for both SUPERVISEDSTEP and UNSUPERVISEDSTEP in Algorithm 1. In particular, a first class of methods is called Block Coordinate Descent (BCD) and identifies a wide class of iterative methods that perform (typically inexact) minimization of the objective function one block of variables at the time. Different strategies to choose which direction minimize at each step have been proposed: pre-fixed cyclic order, greedy search [30] or randomly, according to a predetermined distribution [29]. For a review of several BCD algorithms we refer the reader to [30] and references therein. A second class of methods is called alternating minimization and corresponds to the situation where at each step in Algorithm 1 and exact minimization is performed. This latter approach is favorable when a closed form solution exists for at least one block of variables (see Section 3.2.1) and has been studied extensively in [33] in the abstract setting where an oracle provides a block-wise minimizer at each iteration. The following Corollary describes the convergence properties of BCD and Alternate minimization sequences provided by applying Algorithm 1 to (Sδ).\nCorollary 3.4. Let the Problem (Sδ) be defined as in Theorem 3.3 then:\n(a) Alternating Minimization: Let the two procedures in Algorithm 1 each provide a block-wise minimizer of the functional with the other block held fixed. Then every limiting point of a minimization sequence provided by Algorithm 1, is a\nglobal minimizer for (Sδ).\n(b) Block Coordinate Descent: Let the two procedures in Algorithm 1 each consist in a single step of a first order optimization method (e.g. Projected Gradient Descent, Proximal methods, etc.). Then every limiting point of a minimizing sequence provided by Algorithm 1 is a global minimizer for (Sδ).\nCorollary (3.4) follows by applying previous results on BCD and Alternate minimization. In particular, for the proof of part (a) we refer to Theorem 4.1 in [33], while for part (b) we refer to Theorem 2 in [30]. In the following we discuss the actual implementation of both SUPERVISED and UNSUPERVISED procedures in the case where V is chosen to be least-squares loss and the penalty F to be a spectral p-Schatten norm. This should provide the reader with a practical example of how the meta-algorithm introduced in this section can be specialized to a specific multi-task learning setting.\nRemark 3.5. (Convergence of Block Coordinate Methods) Several works in multitask learning have proposed some form of BCM strategy to solve the learning problem. However, up to our knowledge, so far only the authors in [3] have considered the issue of convergence to a global optimum. Their results where proved for a specific choice of structure penalty in a framework similar to that of problem (R) (see Section 4) but do not extend straightforwardly to other settings. Corollary 3.4 aims to fill this gap, providing convergence guarantees for block coordinate methods for a large class of multi-task learning problems."
    }, {
      "heading" : "3.2.1 Closed Form solutions for Alternating Minimization: Examples",
      "text" : "Here we focus on the alternating minimization case and discuss some settings in which it is possible to obtain a closed form solution for the procedures SUPERVISEDSTEP and UNSUPERVISEDSTEP.\n(SUPERVISEDSTEP) Least Square Loss. When the loss function V is chosen to be least squares (i.e. V (Y, Z) = ‖Y − Z‖2F for any two matrices Y, Z ∈ Rn×m) and the structure matrix A is fixed, a closed form solution for the coefficient matrix C returned by the SUPERVISEDSTEP procedure can be easily derived (see for instance [1]):\nvec(C) = (IT ⊗K + λA−1 ⊗ In)−1vec(Y ).\nHere, the symbol ⊗ denotes the Kronecker product, while the notation vec(M) ∈ Rnm for a matrix M ∈ Rn×m identifies the concatenation of its columns in a single vector. In [26] the authors proposed a faster approach to solve this problem in closed form based on Sylvester’s method.\n(UNSUPERVISEDSTEP) p-Schatten penalties. We consider the case in which F is chosen to be a spectral penalty of the form F (·) = ‖ · ‖pp with p ≥ 1. Also in this setting the optimization problem has a closed form solution, as shown in the following.\nProposition 3.6. Let the penalty of problem (Sδ) be F = ‖ · ‖pp with p ≥ 1. Then, for any C ∈ Rn×T fixed, the optimization problem (Sδ) in the block variable A has a minimizer of the form\nAδC = p+1 √ (C⊤KC + δ2IT )/λ. (4)\nProposition 3.6 generalizes a similar result originally proved in in [3] for the special case p = 1 and provides an explicit formula for the UNSUPERVISEDSTEP of Algorithm 1. We report the proof in the supplementary material."
    }, {
      "heading" : "4 Previous Work: Comparison and Discussion",
      "text" : "The framework introduced in problem (Q) is quite general and accounts for several choices of loss function and task-structural priors. Section 3 has been mainly devoted to derive efficient and generic optimization procedures; in this section we focus our analysis on the modeling aspects, investigating the impact of different structure penalties on the multi-task learning problem. In particular, we will briefly review some multi-task learning method previously proposed, discussing how they can be formulated as special cases of problem (Q) (or, equivalently, (R)).\nSpectral Penalties. The penalty F = ‖ · ‖2F was considered in [14], together with a least squares loss function and the non convex problem (Q) is solved directly by alternating minimization. However, as pointed out in Sec. 3, solving the non convex problem (although invex, see the discussion on Corollary 3.2) directly could in principle become problematic when the alternating minimization sequence gets close to the boundary of Rn×T ×ST++. A related idea is that of consideringF (A) = tr(A) (i.e. the 1-Schatten norm). This latter approach can shown to be equivalent to the Multi-Task Feature Learning setting of [3] (see supplementary material).\nCluster Tasks Learning. In [19], the authors studied a multi-task setting where tasks are assumed to be organized in a fixed number r of unknown disjoint clusters. While\nthe original formulation was conceived for linear setting, it can be easily extended to non-linear kernels and cast in our framework. Let E ∈ {0, 1}T×r be the binary matrix whose entry Est has value 1 or 0 depending on whether task s is in cluster t or not. Set M = I − E†E⊤, and U = 1T 11⊤. In [19] the authors considered a regularization setting of the form of (R) where the structure matrix A is parametrized by the matrix M in order to reflect the cluster structure of the tasks. More precisely:\nA−1(M) = ǫMU + ǫB(M − U) + ǫW (I −M)\nwhere the first term characterizes a global penalty on the average of all tasks predictors, the second term penalizes the between-clusters variance, and the third term controls the tasks variance within each cluster. Clearly, it would be ideal to identify an optimal matrix A(M) minimizing problem (R). However, M belongs to a discrete non convex set, therefore authors propose a convex relaxation by constraining M to be in a convex set Sc = {M ∈ ST+, 0 M I, tr(M) = r}. In our notations F (A) is therefore the indicator function over the set of all matrices A = A(M) such that M ∈ Sc. The authors propose a pseudo gradient descent method to solve the problem jointly.\nConvex Multi-task Relation Learning. Starting from a multi-task Gaussian Process setting, in [37], authors propose a model where the covariance among the coefficient vectors of the T individual tasks is controlled by a matrix A ∈ ST++ in the form of a prior. The initial maximum likelihood estimation problem is relaxed to a convex optimization with target functional of the form\n‖Y −KC‖2F + λ1 tr(C⊤KC) + λ2 tr(A−1C⊤KC) (5)\nconstrained to the set A = {A | A ∈ ST++, tr(A) = 1). This setting is equivalent to problem (R) (by choosing F to be the indicator function of A) with the addition of the term tr(C⊤KC).\nNon-Convex Penalties. Often times, interesting structural assumptions cannot be cast in a convex form and indeed several works have proposed non-convex penalties to recover interpretable relations among multiple tasks. For instance [2] requires A to be a graph Laplacian, or [13] imposes a low-rank factorization of A in two smaller matrices. In [27, 22] different sparsity models are proposed. Interestingly, most of these methods can be naturally cast in the form of problem (Q) or (R). Unfortunately our analysis of the barrier method does not necessarily hold also in these settings and therefore Alternating Minimization is not guaranteed to lead to a stationary point."
    }, {
      "heading" : "5 Experiments",
      "text" : "We empirically evaluated the efficacy of the block coordinate optimization strategy proposed in this paper on both artificial and real datasets. Synthetic experiments were performed to assess the computational aspects of the approach, while we evaluated the quality of solutions found by the system on realistic settings."
    }, {
      "heading" : "5.1 Computational Times",
      "text" : "As discussed in Sec. 4, several methods previously proposed in the literature, such as Multi-task Cluster Learning (MTCL) [19] and Multi-task Feature Learning (MTFL [3]]), can be formulated as special cases of problem (Q) or (R). It is natural to compare the proposed alternating minimization strategy with the optimization solution originally proposed for each method. To assess the system’s performance with respect to varying dimensions of the feature space and an increasing number of tasks, we chose to perform this comparison in an artificial setting. We considered a linear setting where the input data lie in Rd and are distributed according to a normal distribution with zero mean and identity covariance matrix. T linear models wt ∈ Rd for t = 1, . . . , T were then generated according to a normal distribution in order to sample T distinct training sets, each comprising of 30 examples (x\n(t) i , y (t) i ) such that y (t) i = 〈wt, x (t) i 〉 + ǫ with ǫ Gaussian noise with zero mean and 0.1 standard deviation. On these learning problems we compared the computational performance of our alternating minimization strategy and the original optimization algorithms originally proposed for MTCL and MTFL and for which the code has been made available by the authors’. In our algorithm we used A0 = I identity matrix as initialization for the alternating minimization procedure. We used a least-squares loss for all experiments. Figure 1 reports the comparison of computational times of alternating minimization and the original methods to converge to the same minima (of respectively the functional of MTCL and MTFL). We considered two settings: one where the number of tasks was fixed to T = 100 and d increased from 5 to 150 and a second one wher d was fixed to 100 and T varied bewteen 5 and 150. To account for statistical stability we repeated the experiments for each couple (T, d) and different choices of hyperparameters while generating a new random datasets at each time. We can make two observations from these results: 1) in the setting where T is kept fixed we observe a linear increase in the computational times for both original MTCL and MTFL methods, while alternating minimization is almost constant with respect to the input space dimension. 2) When d is fixed and the number of tasks increases, all optimization strategies require more time to converge. This shows that in general alternating minimization is a viable option to solve these problems and in particular, when T << min(d, n) – which is often the case in non-linear settings –this method is particularly efficient."
    }, {
      "heading" : "5.2 Real dataset",
      "text" : "We assessed the benefit of adopting multi-task learning approaches on two real dataset. In particular we considered the following algorithms: Single Task Learning (STL) as a baseline, Multi-task Feature Learning (MTFL) [3], Multi-task Relation Learning (MTRL) [37], Output Kernel Learning (OKL) [14]. We used least squares loss for all experiments.\nSarcos. Sarcos2 is a regression dataset designed to evaluate machine learning solutions for inverse dynamics problems in robotics. It consists in a collection of 21- dimensional inputs, i.e. the joint positions, velocities and acceleration of a robotic arm with 7 degrees of freedom and 7 outputs (the tasks), which report the corresponding torques measured at each joint. For each task, we randomly sampled 50, 100, 150 and 200 training examples while we kept a test set of 5000 examples in common for all tasks. We used a linear kernel and performed 5-fold crossvalidation to find the best regularization parameter according to the normalized mean squared error (nMSE) of predicted torques. We averaged the results over 10 repetitions of these experiments. The results, reported in Table 1, show clearly that to adopt a multi-task approach in this setting is favorable; however, in order to quantify more clearly such improvement, we report in Table 1 also the normalized improvement (nI) over single-task learning (STL). For each multi-task method MTL, the normalized improvement nI(MTL) is computed as the average\nnI(MTL) = 1\nnexp\nnexp∑\ni=1\nnMSEi(STL)− nMSEi(MTL)√ nMSEi(STL) · nMSEi(MTL)\nover all the nexp = 10 experiments of the normalized differences between the nMSE achieved by respectively the STL approach and the given multi-task method MTL.\n15-Scenes. 15-Scenes3 is a dataset designed for scene recognition, consisting in a 15- class classification problem. We represented images using LLC coding [35] and trained the system on a training set comprising 50, 100 and 150 examples per class. The test set consisted in 7500 images evenly divided with respect to the 15 scenes. Table 2 reports\n2urlhttp://www.gaussianprocess.org/gpml/data/ 3http://www-cvr.ai.uiuc.edu/ponce grp/data/\nthe mean classification accuracy on 20 repetitions of the experiments. It can be noticed that while all multi-task approach seem to achieve approximately similar performance, these are consistently outperforming the STL baseline."
    }, {
      "heading" : "6 Conclusions",
      "text" : "We have studied a general multi-task learning framework where the tasks structure can be modeled compactly in a matrix. For a wide family of models, the problem of jointly learning the tasks and their relations can be cast as a convex program, generalizing previous results for special cases [3, 14]. Such an optimization can be naturally approached by block coordinate minimization, which can be seen as alternating between supervised and unsupervised learning steps optimizing respectively the tasks or their structure. We evaluated our method real data, confirming the benefit of multi-task learning when tasks share similar properties. From an optimization perspective, future work will focus on studying the theoretical properties of block coordinate methods, in particular regarding convergence rates. Indeed, the empirical evidence we report suggests that similar strategies can be remarkably efficient in the multi-task setting. From a modeling perspective, future work will focus on studying wider families of matrix-valued kernels, overcoming the limitations of separable ones. Indeed, this would allow to account also for structures in the interaction space between the input and output domains jointly, which is not the case for separable models."
    }, {
      "heading" : "Appendix",
      "text" : ""
    }, {
      "heading" : "Imposing Known Structure on the Tasks",
      "text" : ""
    }, {
      "heading" : "Coding and Embedding",
      "text" : "A common approach to encode knowledge of the tasks relations consists in mapping the output space YT in a new Ỹ ⊆ Rℓ and then solve ℓ independent standard learning problems (e.g. RLS, SVM, Boosting, etc. [17]) or a single one with a joint loss (e.g. Ranking [21]) using the mapped outputs as training observation. The goal is to implicitly exploit the structure of the new space to enforce known (or desired) relations among tasks.\nThe most popular setting for these embedding (or coding) methods is multi-class classification since in several realistic learning problems, classes can be organized in informative structures such as hierarchies or trees. Interestingly, due to the symbolic nature of the classes representation as canonical basis of RT , nonlinear embeddings are not particularly meaningful in classification contexts. Indeed the literature on coding methods for multi-task learning has been mainly concerned with the design of linear operators L : YT → Ỹ [17]. In the following we show that a tight connection exists between coding methods and our multi-task learning setting.\nFor a fixed linear operator L ∈ Rℓ×T , we can solve the “coded” problem using the notation of (P) and a kernel of the form Γ = kIℓ with Iℓ the ℓ × ℓ identity matrix (“independent tasks” kernel)\nminimize C̃∈Rn×ℓ V (Ỹ ,KC̃) + λ tr(C̃⊤KC̃) (6)\nFrom the Representer theorem we know that the solution of (6) will have the form f(x) = ∑n i=1 k(x, xi)c̃i = ∑n i=1 k(x, xi)Lci, for some ci ∈ RT and c̃i = Lci ∈ L(RT ). Therefore, we can constrain (6) on matrices C̃ = CL with C ∈ Rn×T , implying that the best solution for (6) belongs to the set of functions f = L ◦ g ∈ HkIℓ with g ∈ HkIT .\nFor those loss functions L that depend only on the inner product between the vectors of prediction and the ground truth (e.g. logistic or hinge [21, 36], see below), the “coded” Problem (6) on Ỹ with kernel kIℓ is equivalent to (P) on Y with kernel kL⊤L. More precisely, if the multi-output loss can be written so that L(ỹ, f(x)) = L(〈ỹ, f(x)〉\nỸ ) for all ỹ ∈ Ỹ and x ∈ X , we have\n〈ỹ, f(x)〉 Ỹ = 〈Ly, Lg(x)〉 Ỹ = 〈y, L⊤Lg(x)〉Y (7)\nwhere y ∈ Y is such that Ly = ỹ and L⊤ denotes the adjoint operator of L (in this case just the transpose matrix since L is a linear operator between vector spaces over the real field). Therefore, the two terms in the functional of (6) become\nV (Ỹ ,KC̃) = V (Y L⊤,KCL⊤) = V (Y,KCL⊤L)\nwhere the last equality makes use of the property in eq. (7), and\ntr(C̃⊤KC̃) = tr(LC⊤KCL⊤) = tr(L⊤LC⊤KC)\nproving the aforementioned equivalence between Problems (6) and (P) by choosing A = L⊤L.\nSemantic Label Sharing In [17] the authors proposed a strategy to solve a large multi-class visual learning problem that exploited the semantic information provided by the WordNet [16] to enforce specific relations among tasks. In particular, by designing a “semantic” distance between classes using the WordNet graph, the authors were able to generate a similarity matrix L ∈ ST+ encoding the most relevant class relations. They used this matrix to map the original outputs (i.e. the canonical basis of R\nT ) into a new basis where euclidean distances between output codes would reflect the semantic ones induced by the WordNet priming. Then they applied a semi-supervised One-Vs-All approach on the new output space."
    }, {
      "heading" : "Output Metric",
      "text" : "In multi-output settings, another approach to implicitly model the tasks relations consists in changing the metric on the output space RT . In particular, we can define a matrix Θ ∈ ST+ and denote the induced inner product on RT as 〈y, y′〉Θ = 〈y,Θy′〉RT for all y, y′ ∈ RT . For loss functions L such as those mentioned in Sec. 6 (e.g. hinge, logistic, etc.) that depend only on the inner product between observations and predictions, we have that for a fixed Θ the new loss is defined as LΘ(y, f(x)) = L(〈y, f(x)〉Θ) = L(〈y,Θf(x)〉RT ) and induces a learning problem of the form\nminimize C∈Rn×T V (Ỹ ,KCΘ) + λ tr(ΘC⊤KC) (8)\nwhich is clearly equivalent to solving (P) choosing the kernel kΘ. Notice that the second term in eq. (8) derives from the observation that with the new metric, the norm in the RKHSvv becomes ‖f‖2kIT = 〈f, f〉kIT = ∑n i,j ∑T t,s k(xi, xj)〈ct, cs〉Θ = tr(ΘC⊤KC) as required.\nmetric learning In [24] the authors proposed a metric learning framework in which both the new metric A (or Θ) and the task predictors were estimated simultaneously. Adopting almost the same notation of Problem (Q), they used the least squares loss and imposed a penalty F (A) = −log(det(A)) on the metric/structure matrix. A further penalty was also imposed on A, in order to enforce specific sparsity patterns. The only difference with our framework is that in [24] the authors do not impose the regularization term tr(AC⊤KC). Notice however that such term allows us to apply Theorem 3.1 and thus obtain the equivalence between (Q) and (R). This is extremely useful from the optimization perspective since, for instance, for the least squares loss and log-determinant penalty mentioned above, Problem (R) is actually convex jointly, which is not the case for the framework in [24].\nLearning the tasks and their structure\nEquivalence with the convex problem\nWe will make use of the following observation Lemma 6.1. Consider K ∈ ST+ andC ∈ Rn×T . Then Ran(C⊤KC) = Ran(C⊤ √ K) = Ran(C⊤K).\nProof. The second equivalence follows directly from the observation that C⊤K = (C⊤ √ K) √ K and C⊤ √ K = C⊤K( √ K)†. Regarding the first equivalence, recall that for any M ∈ RT×n, RT = Ran(M) ⊕ Ker(M), with Ker(M) denoting the null space of M . Therefore we can alternatively prove that Ker(C⊤KC) = Ker(C⊤ √ K). Notice that clearly Ker(C⊤ √ K) ⊆ Ker(C⊤KC). Now, let x ∈ Ker(C⊤KC) so that 0 = x⊤C⊤KCx = x⊤( √ KC)⊤( √ KC)x. This implies that x is a singular vector of ( √ KC) with singular value equal to zero and therefore x ∈ Ker(C⊤ √ K)."
    }, {
      "heading" : "Proof. (Theorem 3.1)",
      "text" : "We need to prove that C is a convex set and that tr(A†C⊤KC) is jointly convex on C. Regarding the first part, notice that for A ∈ ST+ and C ∈ Rn×T the constraint Ran(C⊤KC) ⊆ Ran(A) can be equivalently rewritten as Ker(C⊤KC) ⊇ Ker(A). Therefore, using Lemma 6.1, we can check convexity of C by showing that for any arbitrary couple (A1, C1), (A2, C2) ∈ C and any θ ∈ [0, 1] we have Ker(θA1 + (1 − θ)A2) ⊆ Ker(θC⊤1 K + (1 − θ)C⊤2 K). Let us consider an arbitrary x ∈ Ker(θA1 + (1− θ)A2). We have\n0 = x⊤(θA1 + (1− θ)A2)x = θx⊤A1x+ (1− θ)x⊤A2x.\nSince both A1 and A2 are PSD, the terms x⊤Aix are necessarily non-negative for both i = 1, 2. Hence, from the equation above we have x⊤Aix = 0, which is equivalent to x ∈ Ker(A1) ∩ Ker(A2) ⊆ Ker(C⊤1 K) ∩ Ker(C⊤2 K). This means that x is in the nullspace of both C⊤1 K and C ⊤ 2 K and therefore also in the nullspace of any linear combination of the two. In particular x ∈ Ker(θC⊤1 K + (1− θ)C⊤2 K). The proof for the convexity of tr(A†C⊤KC) has been already pointed out elsewhere (see for instance [5]). For completeness, we provide an simpler derivation of this result which makes use of a Schur’s complement argument and simple algebraic properties in line with [14] to show that the epigraph of the function is convex. Consider A ∈ ST+ and C ∈ Rn×T . From simple properties of the trace we have the equivalence tr(A†C⊤KC) = vec( √ KC)⊤(A† ⊗ IT )vec( √ KC), where ⊗ identifies the Kronecker product and by vec(·) we denote the vectorization operator mapping a matrix M ∈ Rn×m to the concatenation of all its columns vec(M) ∈ Rnm. Since Ran(A) ⊇ Ran(C⊤KC) = Ran(C √ K) we can apply the generalized Schur’s com-\nplement to write the epigraph of f(A,C) = tr(A†C⊤KC) as\nepi f = { (t, A, C) ∣∣ t ≥ tr(A†C⊤KC) = vec(C √ K)⊤(A† ⊗ IT )vec(C √ K), (A,C) ∈ C } =\n= { (t, A, C) ∣∣∣∣ (\nA⊗ IT vec(C √ K)\nvec(C √ K)⊤ t\n) 0,\n(A,C) ∈ C}\nwhere we write X Y for any two symmetric matrices X,Y ∈ Sm if and only if X − Y ∈ Sm+ . Notice that the block components of the matrix in the equation above are all linear with respect to A,C and t and therefore the convexity of epi f follows by directly observing that for any couple (t1, A1, C1), (t2, A2, C2) ∈ epi f , the PSD constraint holds for any convex combination of the two.\nWe finally prove that the mapping between minimizers stated in Theorem (3.1). First notice that for any (C,A) ∈ Rn×T × ST+ we have Q(C,A) = R(CA,A), with (CA,A) ∈ domR since clearly Ran(A) ⊇ Ran(AC⊤KCA). Therefore inf {Q(C,A) |C ∈ R\nn×T , A ∈ ST+} ≥ inf {R(C,A) | (C,A) ∈ C}. Analogously, given a point (C,A) ∈ C we have that R(C,A) = R(CA†A,A) since Ran(C⊤K) ⊆ Ran(A) and thus V (y,KCAA†) = V (y,KC). Therefore R(C,A) = R(CA†A,A) = Q(CA†, A), implying that inf {R(C,A) | (C,A) ∈ C} ≥ inf {Q(C,A) | C ∈ Rn×T , A ∈ ST+} and concluding the proof.\nA Barrier Method to Optimize (R) Proof. (Theorem 3.3) To prove the existence of finite minimizers we need to show that there exists a minimizing sequence for Sδ such that it converges to a point in domSδ = R\nn×T × ST++. To see this, consider a generic minimizing sequence, i.e. a sequence {(Cn, An)}n∈N ⊂ domSδ such that Sδ(Cn, An) → infC,ASδ(C,A). Notice that we can separate Cn in Cn = Ĉn,+C⊥n with Ĉn ∈ Ran(K) the range of the Gram matrix K and C⊥n ∈ Ker(K) its nullspace and that therefore Sδ(Ĉn, An) = Sδ(Cn, An). This implies that the sequence (Ĉn, An) is bounded, since, if it was not, we would have the coercive penalty F or the tr(A−1n Ĉ ⊤ n KĈn) to go to infinity as n grows. But this is not possible since Sδ(Ĉn, An) → infC,ASδ(C,A) < +∞. Therefore (Ĉn, An) admits a converging subsequence. Suppose without loss of generality that (Cn, An) converges to a point (C∗, A∗) ∈ domSδ = Rn×T × ST+. We want to show that (C∗, A∗) is actually in the domSδ = Rn×T × ST++, i.e. that A∗ is positive definite. But this is obvious since δ > 0 and therefore if the An were to converge to a point in ST+\\ST++, we would have that δ2 tr(A−1n ) → +∞ and therefore Sδ(Ĉn, An) → +∞ as n → +∞. Finally, by the continuity of Sδ, we have Sδ(Ĉn, An) → Sδ(C∗, A∗), therefore proving that (C∗, A∗) ∈ argminC,A Sδ(C,A).\nThe second part of the proof requires the following preliminary steps:\n1. minC,AR(C,A) = infA,CS0(C,A) and they have same infimizers.\n2. g(δ) = infA,CSδ(C,A) is continuous (in fact convex) with minimum in 0.\nWe prove the first point in Lemma 6.2, while the second observation follows from the fact that the function g is the point-wise infimum of a jointly convex function over a convex set. This requires to show that δ2tr(A−1) is jointly convex which follows the same reasoning as for the convexity of tr(A−1C⊤KC) in Theorem (3.1).\nLet us consider two sequences δn > 0 and {(Cn, An)}n∈N ⊂ domSδ = Rn×T × ST++ satisfying the hypothesis of the Theorem, i.e. S δn(Cn, An) = minC,AS δn(C,A). We will first prove the result for Cn in the range of the Gram matrix K . Notice that under this requirement, the (Cn, An) are bounded, since, analogously as for the proof above, if they were not we would have the coercive penalty F or the tr(A−1n C ⊤ n KCn) to go to infinity as n grows. But this is not possible since Sδn(Cn, An) → g(0) < +∞. Therefore, by points 1. and 2., g(0) = minC,AR(C,A) and the limit points of (Cn, An) are minimizers for R. This finally implies that there exists a sequence {(C∗n, A∗n)}n∈N ⊆ argminC,AR(C,A) such that ‖Cn − C∗n‖F + ‖An −A∗n‖F tends to zero as n goes to infinity. To see this, suppose by contradiction that it is not true and that there exists a subsequence {(Cnk , Ank)}k∈N and an M > 0 such that ‖Cnk − C∗‖F +‖Ank −A∗‖F > M for all k > 0 and for all (C∗, A∗) ∈ argminC,A R(C,A). Now, since (Cnk , Ank) is a subsequence of (Cn, An), we have that: (i) (Cnk , Ank) is bounded (hence admits a converging subsequence) and (ii) every converging subsequence tends to a minimizer of R. This clearly contradicts the hypothesis.\nNow, consider the general case in which Cn is not in the range of K: notice that similarly as before, Cn can be separated in Cn = Ĉn + C⊥n with Ĉn ∈ Ran(K) the range of K and C⊥n ∈ Ker(K) its nullspace. Clearly, Sδn(Ĉn, An) = Sδn(Cn, An) → g(0) and therefore, from the discussion above we have a sequence {(Ĉ∗n, A∗n)}n∈N ⊆ argminC,AR(C,A) such that ‖Ĉn − Ĉ∗n‖F + ‖An − A∗n‖F → 0 as n → +∞. We can now observe that the sequence (C∗n, A ∗ n) = (Ĉ ∗ n +C ⊥ n , A ∗ n) satisfies the statement of the Theorem: indeed (i) the (C∗n, A ∗ n) are minimizers for R since R(C ∗ n, A ∗ n) = R(Ĉ∗n, A ∗ n) and (ii) ‖Cn − C∗n‖F = ‖Ĉn − Ĉ∗n‖F → 0 for n → +∞.\nLemma 6.2. minA,CR(C,A) = infA,CS0(C,A) and they have same infimizers:\nProof. This fact follows from the observation that for all δ > 0, domSδ = domS0 is equal to the interior of domR and that all minimizers for R belong to domR. To show this second statement we will prove that for any sequence {(Cn, An)}n∈N ⊂ domR and converging to some point (C̄, Ā) ∈ Rn×T × ST+ \\ domR, we have that R(Cn, An) → +∞ as n goes to infinity. For simplicity of notation let us denote B̄ = C̄⊤KC̄ and analogously Bn = C⊤n KCn. Since from hypothesis Ran(Ā) 6⊇ Ran(C̄⊤KC̄) we have that Ker(Ā) 6⊆ Ker(B̄), or, in other words, there exists an eigenvector v̄ for Ā such that v ∈ Ker(A) and ‖B̄v̄‖2 > 0.\nSince the sequence An converges to Ā, we can identify a sequence of eigenvectors vn for An such that vn → v̄ and their associated eigenvalue λn → 0 as n goes to infinity. Notice that we can assume without loss of generality that λn > 0 for all n since λn = 0 would imply vn ∈ Ker(An) ⊆ Ker(Bn) but we have from hypothesis that ‖Bnvn‖2 → ‖B̄v̄‖ > 0. Therefore we have\ntr(A†nBn) ≥ λ−1n v⊤n Bnvn = λ−1n ‖Bnvn‖22 → +∞ as n goes to infinity."
    }, {
      "heading" : "Spectral Regularization",
      "text" : "Proposition 3.6 follows directly from the following result\nProposition 6.3. Let A,M ∈ Sn+ with Ran(A) ⊇ Ran(M), rank(M) = r. Let M = UΣU⊤ be an eigendecomposition of M with U ∈ On and Σ ∈ Sn+ a diagonal matrix with eigenvalues in decreasing order. Then, there exists a matrix A∗ = UΓU⊤ ∈ Sn+ with Γ ∈ Sn+ diagonal with Γi,i = 0 ∀i < r, such that\ntr(A†∗M) = tr(A †M) and ‖A∗‖p ≤ ‖A‖p ∀p ≥ 1 (9)\nwith the equality holding if and only if A∗ = A.\nProof. To keep the notation uncluttered we prove the result for Θ = A†. Consider an eigendecompositionnΘ = SΛS⊤ with S ∈ On and Λ ∈ Sn+ diagonal with eigenvalues in decreasing order. Let us define R = U⊤S ∈ On. Then\ntr(ΘM) = tr(RΛR⊤Σ) = r∑\ni=1\nσi\nn∑\nj=1\nR2ijλj = r∑\ni=1\nσiγi\nwhere σi and λi are respectively the i-th eigenvalues of M and Θ and we have defined γi = ∑n j=1 Rijλj for i ≤ r and γi = 0 otherwise. Hence, if we consider a diagonal matrix Γ ∈ Sn+ such that Γii = γi and set Θ′ = UΓU⊤ we obtain the left equivalence of eq. (9), namely tr(ΘM) = tr(Θ′M). Now, consider the p-Schatten norm of Θ′\n‖(Θ′)†‖p = ( r∑\ni=1\n1\nγpi\n)1/p =   r∑\ni=1 1(∑n j=1 R 2 ijλj )p\n  1/p\n.\nNotice that Rij = U⊤i ·Sj corresponds to the projection of the i-th eigenvector of M on the j-th eigenvector of Θ. Since Ran(Θ) = Ran(A) ⊇ Ran(M), for any eigenvector s ∈ Rn in the nullspace of Θ (i.e. with associated eigenvalue λ = 0), we have that U⊤i · s = 0 for all i ≤ r. Hence, ∀i ≤ r, 1 = R⊤i · Ri = ∑n j=1 R 2 ij = ∑k j=1 R 2 ij , where k = rank(A). Therefore, since the R2ijs add up to 1 and the scalar function (1/x)p is convex in x ∈ R++, we have\nr∑\ni=1 1(∑n j=1 R 2 ijλj\n)p ≤ r∑\ni=1\nk∑\nj=1\nR2ij 1\nλpj ≤\n≤ k∑\nj=1\n1\nλpj\nn∑\ni=1\nR2ij = k∑\nj=1\n1\nλpj = ‖Θ†‖pp\nwhere we have made use of the fact that for all j = 1, . . . , n we have ∑n\ni=1 Rij = R⊤j · Rj = 1. Therefore, ‖(Θ′)†‖p ≤ ‖Θ†‖p. By taking A′ = (Θ′)† we have the desired result.\nApplied to the minimization in problem (R) with C ∈ Rn×T fixed and p-Schatten penalty, Proposition 6.3 states that a minimizerAC ∈ ST+ has the same system of eigenvalues as C⊤KC and their spectrum have same sparsity pattern (i.e. Ran(C⊤KC) = Ran(A)). This observation leads directly to the closed formula to find a A∗ stated in Proposition 3.6.\nProof. (Proposition 3.6) Consider the eigendecomposition C⊤KC = M = UΣU⊤ with U ∈ OT and Σ ∈ ST+ diagonal with the eigenvalues arranged in descending order. We apply Proposition 6.3 and obtain the minimizer A∗ = UΓU⊤ for Γ ∈ ST+ diagonal with same sparsity pattern as Σ. We can rewrite the target function as\nr∑\nt=1\nσt γt + λ γt.\nwhere r = rank(M). Therefore, the optimization problem consists in minimizing the target function above with respect to the γts. This is an unconstrained convex optimization of a differentiable coercive function bounded below and therefore it is sufficient to set the gradient to zero and solve with respect to the γt. It is clear that for each t = 1 . . . r, the minimizer is of the form γt = p+1 √ σt/λ, leading to the desired solution."
    }, {
      "heading" : "Linear Multi-task Learning",
      "text" : "Several works in multi-task learning have focused on linear models where the multioutput predictor f : Rd → RT is parameterized by a matrix W ∈ Rd×T whose columns wt ∈ Rd are associated to the individual task-predictors ft(x) = 〈wt, x〉Rd for any x ∈ Rd. In this tasks structure can be imposed considering suitable matrix penalty Ω : Rd×T → R and regularization schemes of form\nmin. W∈Rd×T V (Y,XW ) + Ω(W ) (10)\nwhere X ∈ Rn×d is the matrix whose rows correspond to the (transposed) input points in the training sets, ordered accordingly to the order in Y 4. We can recognize two main classes of penalty functions. A first class correspond to methods that impose structured sparsity on the input features across the multiple tasks, for instance considering the penalty Ω(·) = ‖ · ‖2,1 [3], which encourages whole rows of W to be simultaneously sparse, see also [20, 38]. A second class corresponds to spectral regularization methods defined by penalties Ω acting on the singular values of W . Examples in this class include methods that impose low-rank assumptions [3] on the tasks, or search after tasks-cluster structures [19]. Ideas related to a combination of the above methods can also be considered [10].\nMost Linear multi-task learning problems of the form (10) with Ω spectral penalty, can be formulated in terms of problem (R) for a suitable choice of F . Indeed it can be\n4Again V would weight with zeros the loss associated to entries for which examples are not available during training\nshown that for several spectral norms, such as the p-schatten norms, the penalty Ω can be written as\nΩ(W ) = inf A∈ST\n++\ntrace(WA−1W⊤) + FΩ(A) ∀W ∈ Rn×T\nHere we report the example of the nuclear norm ‖ · ‖∗, that has already been observed in similar form in [3, 18] and that can be easily derived from Prop. 3.6 for the case p = 1.\n‖W‖∗ = 1\n2 inf\nA∈ST ++\ntrace(WA−1W⊤) + trace(A).\nIndeed, from Prop. (3.6) we have that the solution to the minimization problem is A∗ = √ (W topW ) and therefore, the minimum of such functional will be exactly\ntrace( √ WW⊤) = ‖W‖∗.\nImpose Tasks Relationships by enforcing structure on the feature space\nRelations among tasks can be also modeled by enforcing shared structures on the input space. For instance in [3], the authors generalized a feature selection framework to the multi-task setting by formulating the linear problem\nminimize U∈Od,M∈Rd×T\nV (Y,XUM) + γ‖M‖2,1 (11)\nwhere X ∈ Rn×d is the matrix whose i-th row corresponds to the input vector xi ∈ Rd and the (2, 1)-norm ‖M‖2,1 = ∑d k=1 ‖Mk‖2 is introduced to enforce sparsity among the rows Mk of M . This penalty generalizes feature selection to the multi-task case by directly manipulating the covariance on the input space. However, since input and output distributions are connected by the training data, it is reasonable to expect this process to indirectly affect also the covariance on the output space. Indeed, in this Section we present an interesting result connecting multi-task problems that impose structure on the input covariance and problems that instead aim to control the output covariance (i.e. in the form of (R)). To show this connection, we need to discuss in more detail the work in [3]. Although (11) is not convex, the authors prove that there exists an equivalent convex formulation of the form\nminimize W∈Rd×T ,D∈Sd+,\nRan(D)⊇Ran(W ),tr(D)≤1\nV (Y,XW ) + γ tr(W⊤D†W ). (12)\nThe authors then proceed to generalize this framework to the nonlinear case using the advantages of the RKHS notation. In this setting, the original idea of identifying a low dimensional set of directions in the feature space translates naturally to the problem of finding a small set of orthogonal directions in the Hilbert space. To this end,\nthe authors perform a preprocessing step whose goal is to identify an orthonormal basis of functions ψ1, . . . ψℓ ∈ Hk for set spanned by the k(xi, ·) and define a matrix K̃ ∈ Rn×ℓ such that K̃ij = ψj(xi). A possible way to do this is by considering a eigenvalue decomposition UΣU⊤ of K and taking K̃ = UΣ1/2 (taking out from Σ1/2 the columns equal to zero). It is easy to show that the standard learning problem in RKHS settings can be cast equivalently in this new notation. However, this framework has the further advantage that it can be generalized to take into account the eventuality of a transformation in the feature space, leading to the extension of problem (12) for the non linear case\nminimize B∈Rℓ×T ,D∈Sℓ+,\nRan(D)⊇Ran(B),tr(D)≤1\nV (Y, K̃B) + γ tr(B⊤D†B) (13)\nAs can be noticed, the structure of problem (13) is very similar to the one of problem (R) and indeed, as stated in Corollary 6.5 the two are equivalent when trace regularization is imposed on (R). However, as shown in Theorem 6.4, a more general equivalence holds.\nTheorem 6.4. Let λ > 0, p ≥ 1, Rn×T , {xi, yi}ni=1 ⊂ Rd × RT a set of input-output pairs with y ∈ Rn×T the matrix whose i-th row corresponds to yi. Let ψ1, . . . , ψℓ ∈ Hk be an orthonormal basis for span{k(xi, ·}ni=1 and K̃ ∈ Rn×ℓ with K̃ij = ψj(xi). Then\nminimize B∈Rℓ×T ,D∈Sℓ+, Ran(D)⊇Ran(B)\nS(B,D) = V (Y, K̃B) + tr(B∗D†B) + λ ‖D‖p (T )\nis a convex optimization problem equivalent to (R) with penalty function F (A) = ‖A‖p. In particular the two problems achieve the same minimum and, given a minimizer for one problem it is possible to obtain a solution for the other and vice-versa.\nThe crucial aspect of the proof of Theorem 6.4 (which we prove below) consists in identifying the two mappings that allow to obtain a minimizer for problem (R) from a solution of (T ) and vice-versa. As a corollary of Theorem (6.4) we get the exact equivalence to the problem proposed in [3].\nCorollary 6.5. Problem (13) is equivalent to (T ) for p = 1. In particular the two problems achieve the same minimum for λ = γ2/4. As a consequence of Theorem 6.4 this implies also that (13) is also equivalent to (R) when F (·) = ‖ · ‖1 = tr(·).\nThis result follows from the direct comparison of the minimizers for the problems (T ) (from Proposition 3.6) and (13) (from [3]). Notice, that although equivalent as convex optimizations, it is in general more convenient to solve problems in the form (R) rather than (T ) since in most cases T << ℓ."
    }, {
      "heading" : "Proof. Theorem 6.4.",
      "text" : "From the discussion in [3] we can rewrite problem (R) in the equivalent formulation minimize\nB∈Rℓ×T ,A∈ST+ , Ran(A)⊇Ran(B⊤)\nT (B,A) = V (Y, K̃B) + tr(A†B⊤B) + λ ‖A‖p (U)\nTherefore, to prove Theorem 6.4 it is sufficient to show that problem (T ) and (U) are equivalent. Assume without loss of generality T ≤ ℓ. Consider an arbitrary matrixB ∈ R ℓ×T and a singular value decomposition B = V\n( Σ 0 ) U⊤ where 0 ∈ R(ℓ−T )×T\nidentifies a matrix of all zeros, V ∈ Oℓ, U ∈ OT and Σ ∈ ST+ a diagonal matrix with eigenvalues in descending order. From Propositon 6.3, we obtain that the minimizers of the two functions S(B, ·) and T (B, ·) are unique and can be written respectively in the forms\nDB = V ( ΓD 0 0 0 ) V ⊤ ∈ Sℓ+ and AB = UΓAU⊤ ∈ ST+\nwhere ΓD,ΓA ∈ ST+ have same sparsity pattern as Σ and the zero matrices in the formulation of DB are of appropriate dimension. We can therefore write the minimum value achieved by S(B, ·) as S(B,DB) = V (Y, K̃B)+ tr(Γ†DΣ2) +λ‖ΓD‖p and the minimum achieved by T (B, ·) as T (B,AB) = V (Y, K̃B) + tr(Γ†AΣ2) + λ‖ΓA‖p. In the light of these equations, it can be easily cheked that by setting A(D)B = UΓDU\n⊤ ∈ ST+ we have\nS(B,DB) = T (B,A (D) B ) ≥ T (B,AB)\nwhere the inequality follows from the fact that AB is a minimizer for T (B, ·). Analogously, we can design a matrix D(A)B ∈ Sℓ+ such that T (B,AB) = S(B,D (A) B ) ≥ S(B,DB). Since the minimizers AB and DB are unique, it follows that ΓD = ΓA. In the perspective of this result, we have that for any minimizer (B∗, D∗) ∈ Rℓ×T × Sℓ+ for (T ), the couple (B∗, A(D∗)B∗ ) ∈ Rℓ×T × ST+ is a minimizer for (U) and furthermore, the two functions achieve the same minimum value. The same result holds in the opposite direction."
    } ],
    "references" : [ {
      "title" : "Kernels for vector-valued functions: a review",
      "author" : [ "M. Álvarez", "N. Lawrence", "L. Rosasco" ],
      "venue" : "Foundations and Trends in Machine Learning, 4(3):195–266,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Learning the Graph of Relations Among Multiple Tasks",
      "author" : [ "A. Argyriou", "S. Clémençon", "R. Zhang" ],
      "venue" : "Research report, Oct.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Convex multi-task feature learning",
      "author" : [ "A. Argyriou", "T. Evgeniou", "M. Pontil" ],
      "venue" : "Machine Learning, 73,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "An algorithm for transfer learning in a heterogeneous environment",
      "author" : [ "A. Argyriou", "A. Maurer", "M. Pontil" ],
      "venue" : "ECML/PKDD (1), pages 71–85,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "A spectral regularization framework for multi-task structure learning",
      "author" : [ "A. Argyriou", "C.A. Micchelli", "M. Pontil", "Y. Ying" ],
      "venue" : "J. Platt, D. Koller, Y. Singer, and S. Roweis, editors, Advances in Neural Information Processing Systems 20, pages 25–32. MIT Press, Cambridge, MA,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Predicting structured data",
      "author" : [ "G.H. Bakir", "T. Hofmann", "B. Scholkopf", "A.J. Smola", "B. Taskar", "S.V.N. Vishwanathan" ],
      "venue" : "MIT Press,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Convexity, classification, and risk bounds",
      "author" : [ "P.L. Bartlett", "M.I. Jordan", "J.D. McAuliffe" ],
      "venue" : "Journal of the American Statistical Association, 101(473):138–156,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "On the convergence of block coordinate descent type methods",
      "author" : [ "A. Beck", "L. Tetruashvili" ],
      "venue" : "Technion, Israel Institute of Technology, Haifa, Israel, Tech. Rep,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Convex optimization",
      "author" : [ "S.P. Boyd", "L. Vandenberghe" ],
      "venue" : "Cambridge university press,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Learning incoherent sparse and low-rank patterns from multiple tasks",
      "author" : [ "J. Chen", "J. Liu", "J. Ye" ],
      "venue" : "ACM Transactions on Knowledge Discovery from Data (TKDD), 5(4):22,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "On the learnability and design of output codes for multiclass problems",
      "author" : [ "K. Crammer", "Y. Singer" ],
      "venue" : "In Proceedings of the Thirteenth Annual Conference on Computational Learning Theory, pages 35–46,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Relations between invex properties",
      "author" : [ "B. Craven" ],
      "venue" : "WORLD SCIENTIFIC SERIES IN APPLI- CABLE ANALYSIS, 5:25–34,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Learning output kernels for multi-task problems",
      "author" : [ "F. Dinuzzo" ],
      "venue" : "Neurocomputing, 118:119– 126,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Learning output kernels with block coordinate descent",
      "author" : [ "F. Dinuzzo", "C.S. Ong", "P. Gehler", "G. Pillonetto" ],
      "venue" : "International Conference on Machine Learning,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Learning multiple tasks with kernel methods",
      "author" : [ "T. Evgeniou", "C.A. Micchelli", "M. Pontil" ],
      "venue" : "Journal of Machine Learning Research, pages 615–637,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Wordnet: An electronic lexical database",
      "author" : [ "C. Fellbaum" ],
      "venue" : "1998. MIT Press,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Semantic label sharing for learning with many categories",
      "author" : [ "R. Fergus", "H. Bernal", "Y. Weiss", "A. Torralba" ],
      "venue" : "European Conference on Computer Vision,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Trace lasso: a trace norm regularization for correlated designs",
      "author" : [ "E. Grave", "G.R. Obozinski", "F. Bach" ],
      "venue" : "J. Shawe-Taylor, R. Zemel, P. Bartlett, F. Pereira, and K. Weinberger, editors, Advances in Neural Information Processing Systems 24, pages 2187–2195.",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Clustered multi-task learning: a convex formulation",
      "author" : [ "L. Jacob", "F. Bach", "J.-P. Vert" ],
      "venue" : "Advances in Neural Information Processing Systems,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Decorrelating semantic visual attributes by resisting the urge to share",
      "author" : [ "D. Jayaraman", "F. Sha", "K. Grauman" ],
      "venue" : "CVPR,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Predicting structured objects with support vector machines",
      "author" : [ "T. Joachims", "T. Hofmann", "Y. Yue", "C.-N. Yu" ],
      "venue" : "Commun. ACM, 52(11):97–104, Nov.",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Learning task grouping and overlap in multi-task learning",
      "author" : [ "A. Kumar", "H. Daume III" ],
      "venue" : "arXiv preprint arXiv:1206.6417,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Discovering structure by learning sparse graphs",
      "author" : [ "B.M. Lake", "J.B. Tenenbaum" ],
      "venue" : "Proceedings of the 32nd Cognitive Science Conference,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Block variable selection in multivariate regression and highdimensional causal inference",
      "author" : [ "A. Lozano", "V. Sindhwani" ],
      "venue" : "Advances in Neural Information Processing Systems,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Kernels for multi-task learning",
      "author" : [ "C.A. Micchelli", "M. Pontil" ],
      "venue" : "Advances in Neural Information Processing Systems,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Vector-valued manifold regularization",
      "author" : [ "H.Q. Minh", "V. Sindhwani" ],
      "venue" : "International Conference on Machine Learning,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Multi-category and taxonomy learning: A regularization approach",
      "author" : [ "Y. Mroueh", "T. Poggio", "L. Rosasco" ],
      "venue" : "NIPS Workshop on Challenges in Learning Hierarchical Models: Transfer Learning and Optimization,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Multiclass learning with simplex coding",
      "author" : [ "Y. Mroueh", "T. Poggio", "L. Rosasco", "J.-j. Slotine" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2012
    }, {
      "title" : "Efficiency of coordinate descent methods on huge-scale optimization problems",
      "author" : [ "Y. Nesterov" ],
      "venue" : "SIAM Journal on Optimization, 22(2):341–362,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A unified convergence analysis of block successive minimization methods for nonsmooth optimization",
      "author" : [ "M. Razaviyayn", "M. Hong", "Z.-Q. Luo" ],
      "venue" : "SIAM Journal on Optimization, 23(2):1126–1153,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Scalable matrix-valued kernel learning and high-dimensional nonlinear causal inference",
      "author" : [ "V. Sindhwani", "A.C. Lozano", "H.Q. Minh" ],
      "venue" : "CoRR, abs/1210.4792,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Support vector machines",
      "author" : [ "I. Steinwart", "A. Christmann" ],
      "venue" : "Springer,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Convergence of block coordinate descent method for nondifferentiable minimization",
      "author" : [ "P. Tseng" ],
      "venue" : "Journal of Optimization Theory and Applications, 109:475–494,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Support vector machine learning for interdependent and structured output spaces",
      "author" : [ "I. Tsochantaridis", "T. Hofmann", "T. Joachims", "Y. Altun" ],
      "venue" : "International Conference on Machine Learning,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Locality-constrained linear coding for image classification",
      "author" : [ "J. Wang", "J. Yang", "K. Yu", "F. Lv", "T. Huang", "Y. Gong" ],
      "venue" : "CVPR,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Wsabie: Scaling up to large vocabulary image annotation",
      "author" : [ "J. Weston", "S. Bengio", "N. Usunier" ],
      "venue" : "Proceedings of the Twenty-Second international joint conference on Artificial Intelligence-Volume Volume Three, pages 2764–2770. AAAI Press,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "A convex formulation for learning task relationships in multitask learning",
      "author" : [ "Y. Zhang", "D.-Y. Yeung" ],
      "venue" : "Proceedings of the Twenty-Sixth Conference Annual Conference on Uncertainty in Artificial Intelligence (UAI-10), pages 733–742, Corvallis, Oregon,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Convex multitask learning with flexible task clusters",
      "author" : [ "W. Zhong", "J. Kwok" ],
      "venue" : "J. Langford and J. Pineau, editors, Proceedings of the 29th International Conference on Machine Learning (ICML-12), ICML ’12, pages 49–56, New York, NY, USA, July",
      "citeRegEx" : "38",
      "shortCiteRegEx" : null,
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 24,
      "context" : "This idea has motivated a variety of methods, including frequentist [25, 3, 4] and Bayesian methods (see e.",
      "startOffset" : 68,
      "endOffset" : 78
    }, {
      "referenceID" : 2,
      "context" : "This idea has motivated a variety of methods, including frequentist [25, 3, 4] and Bayesian methods (see e.",
      "startOffset" : 68,
      "endOffset" : 78
    }, {
      "referenceID" : 3,
      "context" : "This idea has motivated a variety of methods, including frequentist [25, 3, 4] and Bayesian methods (see e.",
      "startOffset" : 68,
      "endOffset" : 78
    }, {
      "referenceID" : 0,
      "context" : "[1] and references therein), with connections to structured learning [6, 34].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "[1] and references therein), with connections to structured learning [6, 34].",
      "startOffset" : 69,
      "endOffset" : 76
    }, {
      "referenceID" : 33,
      "context" : "[1] and references therein), with connections to structured learning [6, 34].",
      "startOffset" : 69,
      "endOffset" : 76
    }, {
      "referenceID" : 24,
      "context" : "Following [25, 15] we consider a setting where tasks are modeled as the components of a vector-valued function and their",
      "startOffset" : 10,
      "endOffset" : 18
    }, {
      "referenceID" : 14,
      "context" : "Following [25, 15] we consider a setting where tasks are modeled as the components of a vector-valued function and their",
      "startOffset" : 10,
      "endOffset" : 18
    }, {
      "referenceID" : 24,
      "context" : "Exploiting the theory of reproducing kernel Hilbert spaces for vector-valued functions (RKHSvv) [25], we consider and analyze a flexible regularization framework, within which a variety of previously proposed approaches can be recovered as special cases, see e.",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 18,
      "context" : "[19, 24, 26, 37, 14, 31].",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 23,
      "context" : "[19, 24, 26, 37, 14, 31].",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 25,
      "context" : "[19, 24, 26, 37, 14, 31].",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 36,
      "context" : "[19, 24, 26, 37, 14, 31].",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 13,
      "context" : "[19, 24, 26, 37, 14, 31].",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 30,
      "context" : "[19, 24, 26, 37, 14, 31].",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 32,
      "context" : "Our approach is based on a barrier method that is combined with block coordinate descent techniques [33, 30].",
      "startOffset" : 100,
      "endOffset" : 108
    }, {
      "referenceID" : 29,
      "context" : "Our approach is based on a barrier method that is combined with block coordinate descent techniques [33, 30].",
      "startOffset" : 100,
      "endOffset" : 108
    }, {
      "referenceID" : 2,
      "context" : "In this sense our analysis generalizes the results in [3] for which a low-rank assumption was considered; however the extension is not straightforward, since we consider a much larger class of regularization schemes (any convex penalty).",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 13,
      "context" : "The RKHSvv setting allows to naturally deal both with linear and non-linear models and the approach we propose provides a general computational framework for learning output kernels as formalized in [14].",
      "startOffset" : 199,
      "endOffset" : 203
    }, {
      "referenceID" : 14,
      "context" : "In particular, we focus on a class of reproducing kernels (known as separable kernels) that can be designed to encode specific tasks structures (see [15, 2] and Sec.",
      "startOffset" : 149,
      "endOffset" : 156
    }, {
      "referenceID" : 1,
      "context" : "In particular, we focus on a class of reproducing kernels (known as separable kernels) that can be designed to encode specific tasks structures (see [15, 2] and Sec.",
      "startOffset" : 149,
      "endOffset" : 156
    }, {
      "referenceID" : 31,
      "context" : "In general, due to discrete nature of the output space, these problems cannot be solved directly; hence, a so-called surrogate problem is often introduced, which is computationally tractable and whose solution allows to recover the solution of the original problem [32, 7, 28].",
      "startOffset" : 265,
      "endOffset" : 276
    }, {
      "referenceID" : 6,
      "context" : "In general, due to discrete nature of the output space, these problems cannot be solved directly; hence, a so-called surrogate problem is often introduced, which is computationally tractable and whose solution allows to recover the solution of the original problem [32, 7, 28].",
      "startOffset" : 265,
      "endOffset" : 276
    }, {
      "referenceID" : 27,
      "context" : "In general, due to discrete nature of the output space, these problems cannot be solved directly; hence, a so-called surrogate problem is often introduced, which is computationally tractable and whose solution allows to recover the solution of the original problem [32, 7, 28].",
      "startOffset" : 265,
      "endOffset" : 276
    }, {
      "referenceID" : 24,
      "context" : "In analogy to the scalar setting, it can be proved (see [25]) that the Representer Theorem holds also for regularization in RKHSvv.",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 0,
      "context" : "The choice of kernel Γ induces a joint representation of the inputs as well as a structure among the output components [1]; In the rest of the paper we will focus on so-called separable kernels, where these two aspects are factorized.",
      "startOffset" : 119,
      "endOffset" : 122
    }, {
      "referenceID" : 14,
      "context" : "Tasks relations can be enforced by devising suitable regularizers [15].",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 24,
      "context" : "Interestingly, for a large class of such methods it can be shown that this is equivalent to the choice of the matrix A (or rather its pseudoinverse) [25].",
      "startOffset" : 149,
      "endOffset" : 153
    }, {
      "referenceID" : 14,
      "context" : "If we consider the squared norm of a function f = ∑n i=1 k(xi, ·)Aci ∈ H we have (see [15])",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 23,
      "context" : "A different approach to model tasks relatedness consists in choosing a suitable metric on the output space to reflect the tasks structure [24].",
      "startOffset" : 138,
      "endOffset" : 142
    }, {
      "referenceID" : 16,
      "context" : ") [17, 21, 11].",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 20,
      "context" : ") [17, 21, 11].",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 10,
      "context" : ") [17, 21, 11].",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 11,
      "context" : "V and the penalty F are differentiable, this is exactly the definition of a convexifiable function, which in particular implies invexity [12].",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 13,
      "context" : "This result was originally proved in [14] for the special case of V the least-squares loss and F (·) = ‖ · ‖F the Frobenius norm; Here we have proved its generalization to all convex losses V and penalties F .",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 8,
      "context" : "First, we note that, while the objective function in Problem (R) is convex, the corresponding minimization problem might not be a convex program (in the sense that the feasible set C is not identified by a set of linear equalities and non-linear convex inequalities [9]).",
      "startOffset" : 266,
      "endOffset" : 269
    }, {
      "referenceID" : 2,
      "context" : "Here we propose a barrier approach inspired by the work in [3] by introducing a perturbation of problem (R) that enforces the objective functions to be equal to +∞ on the boundary of R × S +.",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 2,
      "context" : "The proposed barrier method is similar in spirit to the approach developed in [3] and indeed Theorem 3.",
      "startOffset" : 78,
      "endOffset" : 81
    }, {
      "referenceID" : 2,
      "context" : "4 are a generalization over the two main results in [3] to any convex penaltyF on the cone of PSD matrices.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 2,
      "context" : "However, notice that since we are considering a much wider family of penalties (than the trace norm as in [3]) our results cannot directly derived from those in [3].",
      "startOffset" : 106,
      "endOffset" : 109
    }, {
      "referenceID" : 2,
      "context" : "However, notice that since we are considering a much wider family of penalties (than the trace norm as in [3]) our results cannot directly derived from those in [3].",
      "startOffset" : 161,
      "endOffset" : 164
    }, {
      "referenceID" : 7,
      "context" : "The characteristic block variable structure of the objective function in problem (Sδ), suggests that it might be beneficial to use block coordinate methods (BCM) (see [8]) to solve it.",
      "startOffset" : 167,
      "endOffset" : 170
    }, {
      "referenceID" : 22,
      "context" : "Instead, when the coefficient matrix C is fixed, the problem of learning A can be interpreted as an unsupervised setting in which the goal is to actually find the underlying task structure [23].",
      "startOffset" : 189,
      "endOffset" : 193
    }, {
      "referenceID" : 29,
      "context" : "Different strategies to choose which direction minimize at each step have been proposed: pre-fixed cyclic order, greedy search [30] or randomly, according to a predetermined distribution [29].",
      "startOffset" : 127,
      "endOffset" : 131
    }, {
      "referenceID" : 28,
      "context" : "Different strategies to choose which direction minimize at each step have been proposed: pre-fixed cyclic order, greedy search [30] or randomly, according to a predetermined distribution [29].",
      "startOffset" : 187,
      "endOffset" : 191
    }, {
      "referenceID" : 29,
      "context" : "For a review of several BCD algorithms we refer the reader to [30] and references therein.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 32,
      "context" : "1) and has been studied extensively in [33] in the abstract setting where an oracle provides a block-wise minimizer at each iteration.",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 32,
      "context" : "1 in [33], while for part (b) we refer to Theorem 2 in [30].",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 29,
      "context" : "1 in [33], while for part (b) we refer to Theorem 2 in [30].",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 2,
      "context" : "However, up to our knowledge, so far only the authors in [3] have considered the issue of convergence to a global optimum.",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 0,
      "context" : "V (Y, Z) = ‖Y − Z‖F for any two matrices Y, Z ∈ R) and the structure matrix A is fixed, a closed form solution for the coefficient matrix C returned by the SUPERVISEDSTEP procedure can be easily derived (see for instance [1]):",
      "startOffset" : 221,
      "endOffset" : 224
    }, {
      "referenceID" : 25,
      "context" : "In [26] the authors proposed a faster approach to solve this problem in closed form based on Sylvester’s method.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 18,
      "context" : "Figure 1: Comparison of the computational performance of the alternating minimization strategy studied in this paper with respect to the optimization methods proposed for MTCL in [19] and MTFL [3] in the original papers.",
      "startOffset" : 179,
      "endOffset" : 183
    }, {
      "referenceID" : 2,
      "context" : "Figure 1: Comparison of the computational performance of the alternating minimization strategy studied in this paper with respect to the optimization methods proposed for MTCL in [19] and MTFL [3] in the original papers.",
      "startOffset" : 193,
      "endOffset" : 196
    }, {
      "referenceID" : 2,
      "context" : "6 generalizes a similar result originally proved in in [3] for the special case p = 1 and provides an explicit formula for the UNSUPERVISEDSTEP of Algorithm 1.",
      "startOffset" : 55,
      "endOffset" : 58
    }, {
      "referenceID" : 13,
      "context" : "The penalty F = ‖ · ‖F was considered in [14], together with a least squares loss function and the non convex problem (Q) is solved directly by alternating minimization.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 2,
      "context" : "This latter approach can shown to be equivalent to the Multi-Task Feature Learning setting of [3] (see supplementary material).",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 18,
      "context" : "In [19], the authors studied a multi-task setting where tasks are assumed to be organized in a fixed number r of unknown disjoint clusters.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 18,
      "context" : "In [19] the authors considered a regularization setting of the form of (R) where the structure matrix A is parametrized by the matrix M in order to reflect the cluster structure of the tasks.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 36,
      "context" : "Starting from a multi-task Gaussian Process setting, in [37], authors propose a model where the covariance among the coefficient vectors of the T individual tasks is controlled by a matrix A ∈ S ++ in the form of a prior.",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 1,
      "context" : "For instance [2] requires A to be a graph Laplacian, or [13] imposes a low-rank factorization of A in two smaller matrices.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 12,
      "context" : "For instance [2] requires A to be a graph Laplacian, or [13] imposes a low-rank factorization of A in two smaller matrices.",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 26,
      "context" : "In [27, 22] different sparsity models are proposed.",
      "startOffset" : 3,
      "endOffset" : 11
    }, {
      "referenceID" : 21,
      "context" : "In [27, 22] different sparsity models are proposed.",
      "startOffset" : 3,
      "endOffset" : 11
    }, {
      "referenceID" : 18,
      "context" : "4, several methods previously proposed in the literature, such as Multi-task Cluster Learning (MTCL) [19] and Multi-task Feature Learning (MTFL [3]]), can be formulated as special cases of problem (Q) or (R).",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 2,
      "context" : "4, several methods previously proposed in the literature, such as Multi-task Cluster Learning (MTCL) [19] and Multi-task Feature Learning (MTFL [3]]), can be formulated as special cases of problem (Q) or (R).",
      "startOffset" : 144,
      "endOffset" : 147
    }, {
      "referenceID" : 2,
      "context" : "In particular we considered the following algorithms: Single Task Learning (STL) as a baseline, Multi-task Feature Learning (MTFL) [3], Multi-task Relation Learning (MTRL) [37], Output Kernel Learning (OKL) [14].",
      "startOffset" : 131,
      "endOffset" : 134
    }, {
      "referenceID" : 36,
      "context" : "In particular we considered the following algorithms: Single Task Learning (STL) as a baseline, Multi-task Feature Learning (MTFL) [3], Multi-task Relation Learning (MTRL) [37], Output Kernel Learning (OKL) [14].",
      "startOffset" : 172,
      "endOffset" : 176
    }, {
      "referenceID" : 13,
      "context" : "In particular we considered the following algorithms: Single Task Learning (STL) as a baseline, Multi-task Feature Learning (MTFL) [3], Multi-task Relation Learning (MTRL) [37], Output Kernel Learning (OKL) [14].",
      "startOffset" : 207,
      "endOffset" : 211
    }, {
      "referenceID" : 34,
      "context" : "We represented images using LLC coding [35] and trained the system on a training set comprising 50, 100 and 150 examples per class.",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 2,
      "context" : "For a wide family of models, the problem of jointly learning the tasks and their relations can be cast as a convex program, generalizing previous results for special cases [3, 14].",
      "startOffset" : 172,
      "endOffset" : 179
    }, {
      "referenceID" : 13,
      "context" : "For a wide family of models, the problem of jointly learning the tasks and their relations can be cast as a convex program, generalizing previous results for special cases [3, 14].",
      "startOffset" : 172,
      "endOffset" : 179
    } ],
    "year" : 2015,
    "abstractText" : "Reducing the amount of human supervision is a key problem in machine learning and a natural approach is that of exploiting the relations (structure) among different tasks. This is the idea at the core of multi-task learning. In this context a fundamental question is how to incorporate the tasks structure in the learning problem. We tackle this question by studying a general computational framework that allows to encode a-priori knowledge of the tasks structure in the form of a convex penalty; in this setting a variety of previously proposed methods can be recovered as special cases, including linear and non-linear approaches. Within this framework, we show that tasks and their structure can be efficiently learned considering a convex optimization problem that can be approached by means of block coordinate methods such as alternating minimization and for which we prove convergence to the global minimum.",
    "creator" : "LaTeX with hyperref package"
  }
}