{
  "name" : "1411.6591.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Latent Source Model for Online Collaborative Filtering",
    "authors" : [ "Guy Bresler", "George H. Chen", "Devavrat Shah" ],
    "emails" : [ "gbresler@mit.edu", "georgehc@mit.edu", "devavrat@mit.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Recommendation systems have become ubiquitous in our lives, helping us filter the vast expanse of information we encounter into small selections tailored to our personal tastes. Prominent examples include Amazon recommending items to buy, Netflix recommending movies, and LinkedIn recommending jobs. In practice, recommendations are often made via collaborative filtering, which boils down to recommending an item to a user by considering items that other similar or “nearby” users liked. Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].\nMost such systems operate in the “online” setting, where items are constantly recommended to users over time. In many scenarios, it does not make sense to recommend an item that is already consumed. For example, once Alice watches a movie, there’s little point to recommending the same movie to her again, at least not immediately, and one could argue that recommending unwatched movies and already watched movies could be handled as separate cases. Finally, what matters is whether a likable item is recommended to a user rather than an unlikable one. In short, a good online recommendation system should recommend different likable items continually over time.\nar X\niv :1\n41 1.\n65 91\nv1 [\ncs .L\nG ]\n3 1\nO ct\nDespite the success of collaborative filtering, there has been little theoretical development to justify its effectiveness in the online setting. We address this theoretical gap with our two main contributions in this paper. First, we frame online recommendation as a learning problem that fuses the lines of work on sleeping bandits and clustered bandits. We impose the constraint that once an item is consumed by a user, the system can’t recommend the item to the same user again. Our second main contribution is to analyze a cosine-similarity collaborative filtering algorithm. The key insight is our inclusion of two types of exploration in the algorithm: (1) the standard random exploration for probing the space of items, and (2) a novel “joint” exploration for finding different user types. Under our learning problem setup, after nearly log(km) initial time steps, the proposed algorithm achieves near-optimal performance relative to an oracle algorithm that recommends all likable items first. The nearly logarithmic dependence is a result of using the two different exploration types. We note that the algorithm does not know k.\nOutline. We present our model and learning problem for online recommendation systems in Section 2, provide a collaborative filtering algorithm and its performance guarantee in Section 3, and give the proof idea for the performance guarantee in Section 4. An overview of experimental results is given in Section 5. We discuss our work in the context of prior work in Section 6."
    }, {
      "heading" : "2 A Model and Learning Problem for Online Recommendations",
      "text" : "We consider a system with n users and m items. At each time step, each user is recommended an item that she or he hasn’t consumed yet, upon which, for simplicity, we assume that the user immediately consumes the item and rates it +1 (like) or −1 (dislike).1 The reward earned by the recommendation system up to any time step is the total number of liked items that have been recommended so far across all users. Formally, index time by t ∈ {1, 2, . . . }, and users by u ∈ [n] , {1, . . . , n}. Let πut ∈ [m] , {1, . . . ,m} be the item recommended to user u at time t. Let Y (t)ui ∈ {−1, 0,+1} be the rating provided by user u for item i up to and including time t, where 0 indicates that no rating has been given yet. A reasonable objective is to maximize the expected reward r(T ) up to time T :\nr(T ) , T∑ t=1 n∑ u=1 E[Y (T )uπut ] = m∑ i=1 n∑ u=1 E[Y (T )ui ].\nThe ratings are noisy: the latent item preferences for user u are represented by a length-m vector pu ∈ [0, 1]m, where user u likes item i with probability pui, independently across items. For a user u, we say that item i is likable if pui > 1/2 and unlikable if pui < 1/2. To maximize the expected reward r(T ), clearly likable items for the user should be recommended before unlikable ones.\nIn this paper, we focus on recommending likable items. Thus, instead of maximizing the expected reward r(T ), we aim to maximize the expected number of likable items recommended up to time T :\nr (T ) + , T∑ t=1 n∑ u=1 E[Xut] , (1)\nwhere Xut is the indicator random variable for whether the item recommended to user u at time t is likable, i.e., Xut = +1 if puπut > 1/2 and Xut = 0 otherwise. Maximizing r\n(T ) and r(T )+ differ since the former asks that we prioritize items according to their probability of being liked.\nRecommending likable items for a user in an arbitrary order is sufficient for many real recommendation systems such as for movies and music. For example, we suspect that users wouldn’t actually prefer to listen to music starting from the songs that their user type would like with highest probability to the ones their user type would like with lowest probability; instead, each user would listen to songs that she or he finds likable, ordered such that there is sufficient diversity in the playlist to keep the user experience interesting. We target the modest goal of merely recommending likable items, in any order. Of course, if all likable items have the same probability of being liked and similarly for all unlikable items, then maximizing r(T ) and r(T )+ are equivalent.\n1In practice, a user could ignore the recommendation. To keep our exposition simple, however, we stick to this setting that resembles song recommendation systems like Pandora that per user continually recommends a single item at a time. For example, if a user rates a song as “thumbs down” then we assign a rating of −1 (dislike), and any other action corresponds to +1 (like).\nThe fundamental challenge is that to learn about a user’s preference for an item, we need the user to rate (and thus consume) the item. But then we cannot recommend that item to the user again! Thus, the only way to learn about a user’s preferences is through collaboration, or inferring from other users’ ratings. Broadly, such inference is possible if the users preferences are somehow related.\nIn this paper, we assume a simple structure for shared user preferences. We posit that there are k < n different types of users, where users of the same type have identical item preference vectors. The number of types k represents the heterogeneity in the population. For ease of exposition, in this paper we assume that a user belongs to each user type with probability 1/k. We refer to this model as a latent source model, where each user type corresponds to a latent source of users. We remark that there is evidence suggesting real movie recommendation data to be well modeled by clustering of both users and items [21]. Our model only assumes clustering over users.\nOur problem setup relates to some versions of the multi-armed bandit problem. A fundamental difference between our setup and that of the standard stochastic multi-armed bandit problem [23, 8] is that the latter allows each item to be recommended an infinite number of times. Thus, the solution concept for the stochastic multi-armed bandit problem is to determine the best item (arm) and keep choosing it [3]. This observation applies also to “clustered bandits” [9], which like our work seeks to capture collaboration between users. On the other hand, sleeping bandits [15] allow for the available items at each time step to vary, but the analysis is worst-case in terms of which items are available over time. In our setup, the sequence of items that are available is not adversarial. Our model combines the collaborative aspect of clustered bandits with dynamic item availability from sleeping bandits, where we impose a strict structure on how items become unavailable."
    }, {
      "heading" : "3 A Collaborative Filtering Algorithm and Its Performance Guarantee",
      "text" : "This section presents our algorithm COLLABORATIVE-GREEDY and its accompanying theoretical performance guarantee. The algorithm is syntactically similar to the ε-greedy algorithm for multiarmed bandits [22], which explores items with probability ε and otherwise greedily chooses the best item seen so far based on a plurality vote. In our algorithm, the greedy choice, or exploitation, uses the standard cosine-similarity measure. The exploration, on the other hand, is split into two types, a standard item exploration in which a user is recommended an item that she or he hasn’t consumed yet uniformly at random, and a joint exploration in which all users are asked to provide a rating for the next item in a shared, randomly chosen sequence of items. Let’s fill in the details.\nAlgorithm. At each time step t, either all the users are asked to explore, or an item is recommended to each user by choosing the item with the highest score for that user. The pseudocode is described in Algorithm 1. There are two types of exploration: random exploration, which is for exploring the space of items, and joint exploration, which helps to learn about similarity between users. For a pre-specified rate α ∈ (0, 4/7], we set the probability of random exploration to be εR(n) = 1/nα\nAlgorithm 1: COLLABORATIVE-GREEDY Input: Parameters θ ∈ [0, 1], α ∈ (0, 4/7]. Select a random ordering σ of the items [m]. Define\nεR(n) = 1\nnα , and εJ(t) =\n1\ntα .\nfor time step t = 1, 2, . . . , T do With prob. εR(n): (random exploration) for each user, recommend a random item that the user has not rated. With prob. εJ(t): (joint exploration) for each user, recommend the first item in σ that the user has not rated. With prob. 1− εJ(t)− εR(n): (exploitation) for each user u, recommend an item j that the user has not rated and that maximizes score p̃(t)uj , which depends on threshold θ. end\n(decaying with the number of users), and the probability of joint exploration to be εJ(t) = 1/tα (decaying with time).2\nNext, we define user u’s score p̃(t)ui for item i at time t. Recall that we observe Y (t) ui = {−1, 0,+1} as user u’s rating for item i up to time t, where 0 indicates that no rating has been given yet. We define\np̃ (t) ui ,  ∑ v∈Ñ (t)u 1{Y (t)vi = +1}∑ v∈Ñ (t)u 1{Y (t)vi 6= 0} if ∑ v∈Ñ (t)u 1{Y (t)vi 6= 0} > 0,\n1/2 otherwise,\nwhere the neighborhood of user u is given by\nÑ (t)u , {v ∈ [n] : 〈Ỹ (t)u , Ỹ (t)v 〉 ≥ θ|supp(Ỹ (t)u ) ∩ supp(Ỹ (t)v )|},\nand Ỹ (t)u consists of the revealed ratings of user u restricted to items that have been jointly explored. In other words,\nỸ (t) ui =\n{ Y\n(t) ui if item i is jointly explored by time t,\n0 otherwise.\nThe neighborhoods are defined precisely by cosine similarity with respect to jointed explored items. To see this, for users u and v with revealed ratings Ỹ (t)u and Ỹ (t) v , let Ωuv , supp(Ỹ (t) u )∩supp(Ỹ (t)v ) be the support overlap of Ỹ (t)u and Ỹ (t) v , and let 〈·, ·〉Ωuv be the dot product restricted to entries in Ωuv . Then 〈Ỹ (t)u , Ỹ (t)v 〉 |Ωuv| = 〈Ỹ (t)u , Ỹ (t)v 〉Ωuv√\n〈Ỹ (t)u , Ỹ (t)u 〉Ωuv √ 〈Ỹ (t)v , Ỹ (t)v 〉Ωuv ,\nwhich is the cosine similarity of revealed rating vectors Ỹ (t)u and Ỹ (t) v restricted to the overlap of their supports. Thus, users u and v are neighbors if and only if their cosine similarity is at least θ.\nTheoretical performance guarantee. We now state our main result on the proposed collaborative filtering algorithm’s performance with respect to the objective stated in equation (1). We begin with two reasonable, and seemingly necessary, conditions under which our the results will be established.\nA1 No ∆-ambiguous items. There exists some constant ∆ > 0 such that\n|pui − 1/2| ≥ ∆ for all users u and items i. (Smaller ∆ corresponds to more noise.)\nA2 γ-incoherence. There exist a constant γ ∈ [0, 1) such that if users u and v are of different types, then their item preference vectors pu and pv satisfy\n1 m 〈2pu − 1, 2pv − 1〉 ≤ 4γ∆2,\nwhere 1 is the all ones vector. Note that a different way to write the left-hand side is E[ 1m 〈Y ∗u , Y ∗v 〉], where Y ∗u and Y ∗v are fully-revealed rating vectors of users u and v, and the expectation is over the random ratings of items.\nThe first condition is a low noise condition to ensure that with a finite number of samples, we can correctly classify each item as either likable or unlikable. The incoherence condition asks that the different user types are well-separated so that cosine similarity can tease apart the users of different types over time. We provide some examples after the statement of the main theorem that suggest the incoherence condition to be reasonable, allowing E[〈Y ∗u , Y ∗v 〉] to scale as Θ(m) rather than o(m). We assume that the number of users satisfies n = O(mC) for some constant C > 1. This is without loss of generality since otherwise, we can randomly divide the n users into separate population\n2For ease of presentation, we set the two explorations to have the same decay rate α, but our proof easily extends to encompass different decay rates for the two exploration types. Furthermore, the constant 4/7 ≥ α is not special. It could be different and only affects another constant in our proof.\npools, each of size O(mC) and run the recommendation algorithm independently for each pool to achieve the same overall performance guarantee.\nFinally, we define µ, the minimum proportion of likable items for any user (and thus any user type):\nµ , min u∈[n]\n∑m i=1 1{pui > 1/2}\nm .\nTheorem 1. Let δ ∈ (0, 1) be some pre-specified tolerance. Take as input to COLLABORATIVEGREEDY θ = 2∆2(1 + γ) where γ ∈ [0, 1) is as defined in A2, and α ∈ (0, 4/7]. Under the latent source model and assumptions A1 and A2, if the number of users n = O(mC) satisfies\nn = Ω ( km log 1 δ + (4 δ )1/α) ,\nthen for any Tlearn ≤ T ≤ µm, the expected proportion of likable items recommended by COLLABORATIVE-GREEDY up until time T satisfies\nr (T ) + Tn ≥ ( 1− Tlearn T ) (1− δ),\nwhere\nTlearn = Θ\n(( log km∆δ ∆4(1− γ)2 )1/(1−α) + (4 δ )1/α) .\nTheorem 1 says that there are Tlearn initial time steps for which the algorithm may be giving poor recommendations. Afterward, for Tlearn < T < µm, the algorithm becomes near-optimal, recommending a fraction of likable items 1−δ close to what an optimal oracle algorithm (that recommends all likable items first) would achieve. Then for time horizon T > µm, we can no longer guarantee that there are likable items left to recommend. Indeed, if the user types each have the same fraction of likable items, then even an oracle recommender would use up the µm likable items by this time. Meanwhile, to give a sense of how long the learning period Tlearn is, note that when α = 1/2, we have Tlearn scaling as log2(km), and if we choose α close to 0, then Tlearn becomes nearly log(km). In summary, after Tlearn initial time steps, the simple algorithm proposed is essentially optimal.\nTo gain intuition for incoherence condition A2, we calculate the parameter γ for three examples. Example 1. Consider when there is no noise, i.e., ∆ = 12 . Then users’ ratings are deterministic given their user type. Produce k vectors of probabilities by drawing m independent Bernoulli( 12 ) random variables (0 or 1 with probability 12 each) for each user type. For any item i and pair of users u and v of different types, Y ∗ui · Y ∗vi is a Rademacher random variable (±1 with probability 12 each), and thus the inner product of two user rating vectors is equal to the sum of m Rademacher\nrandom variables. Standard concentration inequalities show that one may take γ = Θ (√\nlogm m\n) to\nsatisfy γ-incoherence with probability 1− 1/poly(m). Example 2. We expand on the previous example by choosing an arbitrary ∆ > 0 and making all latent source probability vectors have entries equal to 12 ±∆ with probability 12 each. As before let user u and v are from different type. Now E[Y ∗ui ·Y ∗vi] = (12 + ∆)2 + ( 12 −∆)2− 2( 14 −∆2) = 4∆2 if pui = pvi and E[Y ∗ui · Y ∗vi] = 2( 14 − ∆2) − ( 12 + ∆)2 − ( 12 − ∆)2 = −4∆2 if pui = 1 − pvi. The value of the inner product E[〈Y ∗u , Y ∗v 〉] is again equal to the sum of m Rademacher random variables, but this time scaled by 4∆2. For similar reasons as before, γ = Θ (√ logm m ) suffices to satisfy γ-incoherence with probability 1− 1/poly(m). Example 3. Continuing with the previous example, now suppose each entry is 12 +∆ with probability µ ∈ (0, 1/2) and 12 − ∆ with probability 1 − µ. Then for two users u and v of different types, pui = pvi with probability µ2 + (1 − µ)2. This implies that E[〈Y ∗u , Y ∗v 〉] = 4m∆2(1 − 2µ)2. Again, using standard concentration, this shows that γ = (1−2µ)2 +Θ (√ logm m ) suffices to satisfy γ-incoherence with probability 1− 1/poly(m)."
    }, {
      "heading" : "4 Proof of Theorem 1",
      "text" : "Recall that Xut is the indicator random variable for whether the item πut recommended to user u at time t is likable, i.e., puπut > 1/2. Given assumption A1, this is equivalent to the event that puπut ≥ 12 + ∆. The expected proportion of likable items is\nr (T ) +\nTn =\n1\nTn T∑ t=1 n∑ u=1 E[Xut] = 1 Tn T∑ t=1 n∑ u=1 P(Xut = 1).\nOur proof focuses on lower-bounding P(Xut = 1). The key idea is to condition on what we call the “good neighborhood” event Egood(u, t):\nEgood(u, t) = {\nat time t, user u has ≥ n 5k neighbors from the same user type (“good neighbors”), and ≤ ∆tn 1−α\n10km neighbors from other user types (“bad neighbors”)\n} .\nThis good neighborhood event will enable us to argue that after an initial learning time, with high probability there are at most ∆ as many ratings from bad neighbors as there are from good neighbors.\nThe proof of Theorem 1 consists of two parts. The first part uses joint exploration to show that after a sufficient amount of time, the good neighborhood event Egood(u, t) holds with high probability. Lemma 1. For user u, after\nt ≥ ( 2 log(10kmnα/∆) ∆4(1− γ)2 )1/(1−α)\ntime steps,\nP(Egood(u, t)) ≥ 1− exp ( − n\n8k\n) − 12 exp ( − ∆\n4(1− γ)2t1−α 20\n) .\nIn the above lower bound, the first exponentially decaying term could be thought of as the penalty for not having enough users in the system from the k user types, and the second decaying term could be thought of as the penalty for not yet clustering the users correctly.\nThe second part of our proof to Theorem 1 shows that, with high probability, the good neighborhoods have, through random exploration, accurately estimated the probability of liking each item. Thus, we correctly classify each item as likable or not with high probability, which leads to a lower bound on P(Xut = 1). Lemma 2. For user u at time t, if the good neighborhood event Egood(u, t) holds and t ≤ µm, then\nP(Xut = 1) ≥ 1− 2m exp ( − ∆ 2tn1−α\n40km ) − 1 tα − 1 nα .\nHere, the first exponentially decaying term could be thought of as the cost of not classifying items correctly as likable or unlikable, and the last two decaying terms together could be thought of as the cost of exploration (we explore with probability εJ(t) + εR(n) = 1/tα + 1/nα).\nWe defer the proofs of Lemmas 1 and 2 to Appendices A.1 and A.2. Combining these lemmas and choosing appropriate constraints on the numbers of users and items, we produce the following lemma. Lemma 3. Let δ ∈ (0, 1) be some pre-specified tolerance. If the number of users n and items m satisfy\nn ≥ max { 8k log 4 δ , (4 δ )1/α} ,\nµm ≥ t ≥ max {( 2 log(10kmnα/∆) ∆4(1− γ)2 )1/(1−α) , ( 20 log(96/δ) ∆4(1− γ)2 )1/(1−α) , (4 δ )1/α} ,\nnt1−α ≥ 40km ∆2\nlog (16m\nδ\n) ,\nthen P(Xut = 1) ≥ 1− δ.\nProof. With the above conditions on n and t satisfied, we combine Lemmas 1 and 2 to obtain\nP(Xut = 1) ≥ 1− exp ( − n\n8k\n) − 12 exp ( − ∆\n4(1− γ)2t1−α 20\n) − 2m exp ( − ∆ 2tn1−α\n40km ) − 1 tα − 1 nα ≥ 1− δ 4 − δ 8 − δ 8 − δ 4 − δ 4 = 1− δ.\nTheorem 1 follows as a corollary to Lemma 3. As previously mentioned, without loss of generality, we take n = O(mC). Then with number of users n satisfying\nO(mC) = n = Ω ( km log 1 δ + (4 δ )1/α) ,\nand for any time step t satisfying µm ≥ t ≥ Θ ((\nlog km∆δ ∆4(1− γ)2 )1/(1−α) + (4 δ )1/α) , Tlearn ,\nwe simultaneously meet all of the conditions of Lemma 3. Note that the upper bound on number of users n appears since without it, Tlearn would depend on n (observe that in Lemma 3, we ask that t be greater than a quantity that depends on n). Provided that the time horizon satisfies T ≤ µm, then\nr (T ) +\nTn ≥ 1 Tn T∑ t=Tlearn n∑ u=1 P(Xut = 1) ≥ 1 Tn T∑ t=Tlearn n∑ u=1 (1− δ) = (T − Tlearn)(1− δ) T ,\nyielding the theorem statement."
    }, {
      "heading" : "5 Experimental Results",
      "text" : "We provide only a summary of our experimental results here, deferring full details to Appendix A.3. We simulate an online recommendation system based on movie ratings from the Movielens10m and Netflix datasets, each of which provides a sparsely filled user-by-movie rating matrix with ratings out of 5 stars. Unfortunately, existing collaborative filtering datasets such as the two we consider don’t offer the interactivity of a real online recommendation system, nor do they allow us to reveal the rating for an item that a user didn’t actually rate. For simulating an online system, the former issue can be dealt with by simply revealing entries in the user-by-item rating matrix over time. We address the latter issue by only considering a dense “top users vs. top items” subset of each dataset. In particular, we consider only the “top” users who have rated the most number of items, and the “top” items that have received the most number of ratings. While this dense part of the dataset is unrepresentative of the rest of the dataset, it does allow us to use actual ratings provided by users without synthesizing any ratings. A rigorous validation would require an implementation of an actual interactive online recommendation system, which is beyond the scope of our paper.\nFirst, we validate that our latent source model is reasonable for the dense parts of the two datasets we consider by looking for clustering behavior across users. We find that the dense top users vs. top movies matrices do in fact exhibit clustering behavior of users and also movies, as shown in Figure 1(a). The clustering was found via Bayesian clustered tensor factorization, which was previously shown to model real movie ratings data well [21].\nNext, we demonstrate our algorithm COLLABORATIVE-GREEDY on the two simulated online movie recommendation systems, showing that it outperforms two existing recommendation algorithms Popularity Amongst Friends (PAF) [4] and a method by Deshpande and Montanari (DM) [12]. Following the experimental setup of [4], we quantize a rating of 4 stars or more to be +1 (likable), and a rating less than 4 stars to be −1 (unlikable). While we look at a dense subset of each dataset, there are still missing entries. If a user u hasn’t rated item j in the dataset, then we set the corresponding true rating to 0, meaning that in our simulation, upon recommending item j to user u, we receive 0 reward, but we still mark that user u has consumed item j; thus, item j can no longer be recommended to user u. For both Movielens10m and Netflix datasets, we consider the top n = 200 users and the top m = 500 movies. For Movielens10m, the resulting user-by-rating matrix has 80.7% nonzero entries. For Netflix, the resulting matrix has 86.0% nonzero entries. For an algorithm that\nrecommends item πut to user u at time t, we measure the algorithm’s average cumulative reward up to time T as 1n ∑T t=1 ∑n u=1 Y (T ) uπut , where we average over users. For all four methods, we recommend items until we reach time T = 500, i.e., we make movie recommendations until each user has seen all m = 500 movies. We disallow the matrix completion step for DM to see the users that we actually test on, but we allow it to see the the same items as what is in the simulated online recommendation system in order to compute these items’ feature vectors (using the rest of the users in the dataset). Furthermore, when a rating is revealed, we provide DM both the thresholded rating and the non-thresholded rating, the latter of which DM uses to estimate user feature vectors over time. We discuss choice of algorithm parameters in Appendix A.3. In short, parameters θ and α of our algorithm are chosen based on training data, whereas we allow the other algorithms to use whichever parameters give the best results on the test data. Despite giving the two competing algorithms this advantage, COLLABORATIVE-GREEDY outperforms the two, as shown in Figure 1(b). Results on the Netflix dataset are similar."
    }, {
      "heading" : "6 Discussion and Related Work",
      "text" : "This paper proposes a model for online recommendation systems under which we can analyze the performance of recommendation algorithms. We theoretical justify when a cosine-similarity collaborative filtering method works well, with a key insight of using two exploration types.\nThe closest related work is by Biau et al. [7], who study the asymptotic consistency of a cosinesimilarity nearest-neighbor collaborative filtering method. Their goal is to predict the rating of the next unseen item. Barman and Dabeer [4] study the performance of an algorithm called Popularity Amongst Friends, examining its ability to predict binary ratings in an asymptotic informationtheoretic setting. In contrast, we seek to understand the finite-time performance of such systems. Dabeer [11] uses a model similar to ours and studies online collaborative filtering with a moving horizon cost in the limit of small noise using an algorithm that knows the numbers of user types and item types. We do not model different item types, our algorithm is oblivious to the number of user types, and our performance metric is different. Another related work is by Deshpande and Montanari [12], who study online recommendations as a linear bandit problem; their method, however, does not actually use any collaboration beyond a pre-processing step in which offline collaborative filtering (specifically matrix completion) is solved to compute feature vectors for items.\nOur work also relates to the problem of learning mixture distributions (c.f., [10, 18, 5, 2]), where one observes samples from a mixture distribution and the goal is to learn the mixture components and weights. Existing results assume that one has access to the entire high-dimensional sample or that the samples are produced in an exogenous manner (not chosen by the algorithm). Neither assumption holds in our setting, as we only see each user’s revealed ratings thus far and not the user’s entire preference vector, and the recommendation algorithm affects which samples are observed (by choosing which item ratings are revealed for each user). These two aspects make our setting more challenging than the standard setting for learning mixture distributions. However, our goal is more modest. Rather than learning the k item preference vectors, we settle for classifying them as likable or unlikable. Despite this, we suspect having two types of exploration to be useful in general for efficiently learning mixture distributions in the active learning setting.\nAcknowledgements. This work was supported in part by NSF grant CNS-1161964 and by Army Research Office MURI Award W911NF-11-1-0036. GHC was supported by an NDSEG fellowship."
    }, {
      "heading" : "A Appendix",
      "text" : "Throughout our derivations, if it is clear from context, we omit the argument (t) indexing time, for example writing Yu instead of Yu(t)."
    }, {
      "heading" : "A.1 Proof of Lemma 1",
      "text" : "We reproduce Lemma 1 below for ease of presentation. Lemma 1. For user u, after\nt ≥ ( 2 log(10kmnα/∆) ∆4(1− γ)2 )1/(1−α)\ntime steps,\nP(Egood(u, t)) ≥ 1− exp ( − n\n8k\n) − 12 exp ( − ∆\n4(1− γ)2t1−α 20\n) .\nTo derive this lower bound on the probability that the good neighborhood event Egood(u, t) occurs, we prove four lemmas (Lemmas 4, 5, 6, and 7). Before doing so, we define a constant that will appear several times: β , exp(−∆4(1− γ)2t1−α). We begin by ensuring that enough users from each of the k user types are in the system. Lemma 4. For a user u,\nP (\nuser u’s type has ≤ n 2k\nusers ) ≤ exp ( − n\n8k\n) .\nProof. Let N be the number of users from user u’s type. User types are equiprobable, so N ∼ Bin(n, 1k ). By a Chernoff bound,\nP ( N ≤ n\n2k\n) ≤ exp ( − 1\n2 (nk − n2k )2 n k\n) = exp ( − n\n8k\n) .\nNext, we ensure that sufficiently many items have been jointly explored across all users. This will subsequently be used for bounding both the number of good neighbors and the number of bad neighbors. Lemma 5. After t time steps,\nP(fewer than t1−α/2 jointly explored items) ≤ exp(−t1−α/20).\nProof. Let Zs be the indicator random variable for the event that the algorithm jointly explores at time s. Thus, the number of jointly explored items up to time t is ∑t s=1 Zs. By our choice for the time-varying joint exploration probability εJ , we have P(Zs = 1) = εJ(s) = 1sα and P(Zs = 0) = 1− 1sα . Note that the centered random variable Z̄s = E[Zs]−Zs = 1sα −Zs has zero mean, and |Z̄s| ≤ 1 with probability 1. Then,\nP ( t∑ s=1 Zs < 1 2 t1−α ) = P ( t∑ s=1 Z̄s > t∑ s=1 E[Zs]− 1 2 t1−α ) (i) ≤ P ( t∑ s=1 Z̄s > 1 2 t1−α ) (ii)\n≤ exp ( −\n1 8 t 2(1−α)∑t s=1 E[Z̄2s ] + 1 6 t 1−α\n) (iii) ≤ exp ( −\n1 8 t\n2(1−α)\nt1−α 1−α + 1 6 t 1−α ) = exp ( − 3(1− α)t 1−α\n4(7− α)\n) (iv)\n≤ exp(−t1−α/20),\nwhere step (i) uses the fact that ∑t s=1 E[Zs] = ∑t s=1 1/s\nα ≥ t/tα = t1−α, step (ii) is Bernstein’s inequality, step (iii) uses the fact that ∑t s=1 E[Z̄2s ] ≤ ∑t s=1 E[Z2s ] = ∑t s=1 1/s\nα ≤ t1−α/(1−α), and step (iv) uses the fact that α ≤ 4/7. (We remark that the choice of constant 4/7 isn’t special; changing it would simply modify the constant in the decaying exponentially to potentially no longer be 1/20).\nAssuming that the bad events for the previous two lemmas do not occur, we now provide a lower bound on the number of good neighbors that holds with high probability.\nLemma 6. Suppose that there are no ∆-ambiguous items, that there are more than n2k users of user u’s type, and that all users have rated at least t1−α/2 items as part of joint exploration. For user u, let ngood be the number of “good” neighbors of user u. If β ≤ 110 , then\nP ( ngood ≤ (1− β) n\n4k\n) ≤ 10β.\nWe defer the proof of Lemma 6 to Appendix A.1.1.\nFinally, we verify that the number of bad neighbors for any user is not too large, again conditioned on there being enough jointly explored items.\nLemma 7. Suppose that the minimum number of rated items in common between any pair of users is t1−α/2 and suppose that γ-incoherence holds for some γ ∈ [0, 1). For user u, let nbad be the number of “bad” neighbors of user u. Then\nP(nbad ≥ n √ β) ≤ √ β.\nWe defer the proof of Lemma 7 to Appendix A.1.2.\nWe now prove Lemma 1, which union bounds over the four bad events of Lemmas 4, 5, 6, and 7. Recall that the good neighborhood event Egood(u, t) holds if at time t, user u has more than n5k good neighbors and less than ∆tn 1−α\n10km bad neighbors. By assuming that the four bad events don’t happen, then Lemma 6 tells us that there are more than (1 − β) n4k good neighbors provided that β ≤ 110 . Thus, to ensure that there are more than n5k good neighbors, it suffices to have (1 − β) n4k ≥ n5k , which happens when β ≤ 15 , but we already require that β ≤ 110 . Similarly, Lemma 7 tells us that there are fewer than n √ β bad neighbors, so to ensure that there are fewer than ∆tn 1−α\n10km bad neighbors it suffices to have n √ β ≤ ∆tn1−α10km , which happens when β ≤ ( ∆t10kmnα )2. We can satisfy all constraints on β by asking that β ≤ ( ∆10kmnα )2, which is tantamount to asking that\nt ≥ ( 2 log(10kmnα/∆) ∆4(1− γ)2 )1/(1−α)\nsince β = exp(−∆4(1− γ)2t1−α). Finally, with t satisfying the inequality above, the union bound over the four bad events can be further bounded to complete the proof:\nP(Egood(u, t)) ≥ 1− exp ( − n\n8k\n) − exp(−t1−α/20)− 10β − √ β\n≥ 1− exp ( − n\n8k\n) − 12 exp ( − ∆\n4(1− γ)2t1−α 20\n) ."
    }, {
      "heading" : "A.1.1 Proof of Lemma 6",
      "text" : "We begin with a preliminary lemma that upper-bounds the probability of two users of the same type not being declared as neighbors.\nLemma 8. Suppose that there are no ∆-ambiguous items for any of the user types. Let users u and v be of the same type, and suppose that they have rated at least Γ0 items in common (explored jointly). Then for θ ∈ (0, 4∆2),\nP(users u and v are not declared as neighbors) ≤ exp ( − (4∆\n2 − θ)2 2 Γ0\n) .\nProof. Let us first suppose that users u and v have rated exactly Γ0 items in common. The two users are not declared to be neighbors if 〈Ỹu, Ỹv〉 < θΓ0. Let Ω ⊆ [m] such that |Ω| = Γ0. We have\nE [ 〈Ỹu, Ỹv〉 ∣∣supp(Ỹu) ∩ supp(Ỹv) = Ω] = ∑ i∈Ω E[ỸuiỸvi | Ỹui 6= 0, Ỹvi 6= 0]\n= ∑ i∈Ω (p2ui + (1− pui)2 − 2pui(1− pui))\n= 4 ∑ i∈Ω ( pui − 1 2 )2 . (2)\nSince 〈Ỹu, Ỹv〉 = ∑ i∈Ω ỸuiỸvi is the sum of terms {ỸuiỸvi}i∈Ω that are each bounded within [−1, 1], Hoeffding’s inequality yields\nP ( 〈Ỹu, Ỹv〉 ≤ θΓ0 ∣∣ supp(Ỹu) ∩ supp(Ỹv) = Ω) ≤ exp(− [ equation (2)︷ ︸︸ ︷ 4 ∑ i∈Ω ( pgi − 12 )2−θΓ0]2 2Γ0 ) . (3)\nAs there are no ∆-ambiguous items, ∆ ≤ |pui − 1/2| for all users u and items i. Thus, our choice of θ guarantees that\n4 ∑ i∈Ω ( pui − 1 2 )2 − θΓ0 ≥ 4Γ0∆2 − θΓ0 = (4∆2 − θ)Γ0 ≥ 0. (4)\nCombining inequalities (3) and (4), and observing that the above holds for all subsets Ω of cardinality Γ0, we obtain the desired bound on the probability that users u and v are not declared as neighbors:\nP(〈Ỹu, Ỹv〉 ≤ θΓ0 | |supp(Ỹu) ∩ supp(Ỹv)| = Γ0) ≤ exp ( − (4∆\n2 − θ)2 2 Γ0\n) . (5)\nNow to handle the case that users u and v have jointly rated more than Γ0 items, observe that, with shorthand Γuv , |supp(Ỹu) ∩ supp(Ỹv)|,\nP(u and v not declared neighbors | pu = pv,Γuv ≥ Γ0) = P(〈Ỹu, Ỹv〉 < θΓuv | pu = pv, Γuv ≥ Γ0)\n= P(〈Ỹu, Ỹv〉 ≤ θΓuv,Γuv ≥ Γ0 | pu = pv)\nP(Γuv ≥ Γ0 | pu = pv)\n=\n∑m `=Γ0\nP(〈Ỹu, Ỹv〉 ≤ θ`,Γuv = ` | pu = pv) P(Γuv ≥ Γ0 | pu = pv)\n=\n∑m `=Γ0 [ P(Γuv = ` | pu = pv) ·P(〈Ỹu, Ỹv〉 ≤ θ` | pu = pv,Γuv = `)\n] P(Γuv ≥ Γ0 | pu = pv)\n≤ ∑m `=Γ0 P(Γuv = ` | pu = pv) exp ( − (4∆ 2−θ)2 2 Γ0 ) P(Γuv ≥ Γ0 | pu = pv)\nby inequality (5) = exp ( − (4∆\n2 − θ)2 2 Γ0\n) .\nWe now prove Lemma 6.\nSuppose that the event in Lemma 4 holds. Let G be n2k users from the same user type as user u; there could be more than n2k such users but it suffices to consider n 2k of them. We define an indicator random variable\nGv , 1{users u and v are neighbors} = 1{〈Ỹ (t)u , Ỹ (t)v 〉 ≥ θt1−α/2}.\nThus, the number of good neighbors of user u is lower-bounded by W = ∑ v∈G Gv . Note that the Gv’s are not independent. To arrive at a lower bound for W that holds with high probability, we use Chebyshev’s inequality:\nP(W − E[W ] ≤ −E[W ]/2) ≤ 4Var(W ) (E[W ])2 . (6)\nLet β = exp(−(4∆2 − θ)2Γ0/2) be the probability bound from Lemma 8, where by our choice of θ = 2∆2(1 + γ) and with Γ0 = t1−α/2, we have β = exp(−∆4(1− γ)2t1−α). Applying Lemma 8, we have E[W ] ≥ (1− β) n2k , and hence\n(E[W ])2 ≥ (1− 2β) n 2\n4k2 . (7)\nWe now upper-bound Var(W ) = ∑ v∈G Var(Gv) + ∑ v 6=w Cov(Gv, Gw).\nSince Gv = G2v , Var(Gv) = E[Gv]− E[Gv]2 = E[Gv]︸ ︷︷ ︸\n≤1\n(1− E[Gv]) ≤ β,\nwhere the last step uses Lemma 8.\nMeanwhile,\nCov(Gv, Gw) = E[GvGw]− E[Gv]E[Gw] ≤ 1− (1− β)2 ≤ 2β. Putting together the pieces,\nVar(W ) ≤ n 2k · β + n 2k · ( n 2k − 1 ) · 2β ≤ n 2 2k2 · β. (8)\nPlugging (7) and (8) into (6) gives\nP(W − E[W ] ≤ −E[W ]/2) ≤ 8β 1− 2β ≤ 10β,\nprovided that β ≤ 110 . Thus, ngood ≥W ≥ E[W ]/2 ≥ (1− β) n4k with probability at least 1− 10β."
    }, {
      "heading" : "A.1.2 Proof of Lemma 7",
      "text" : "We begin with a preliminary lemma that upper-bounds the probability of two users of different types being declared as neighbors. Lemma 9. Let users u and v be of different types, and suppose that they have rated at least Γ0 items in common via joint exploration. Further suppose γ-incoherence is satisfied for γ ∈ [0, 1). If θ ≥ 4γ∆2, then\nP(users u and v are declared to be neighbors) ≤ exp ( − (θ − 4γ∆ 2)2\n2 Γ0\n) .\nProof. As with the proof of Lemma 8, we first analyze the case where users u and v have rated exactly Γ0 items in common. Users u and v are declared to be neighbors if 〈Ỹu, Ỹv〉 ≥ θΓ0. We now crucially use the fact that joint exploration chooses these Γ0 items as a random subset of the m items. For our random permutation σ of m items, we have 〈Ỹu, Ỹv〉 =\n∑Γ0 i=1 Ỹu,σ(i)Ỹv,σ(i) =∑Γ0\ni=1 Yu,σ(i)Yv,σ(i), which is the sum of terms {Yu,σ(i)Yv,σ(i)}Γ0i=1 that are each bounded within [−1, 1] and drawn without replacement from a population of all possible items. Hoeffding’s inequality (which also applies to the current scenario of sampling without replacement [14]) yields\nP ( 〈Ỹu, Ỹv〉 ≥ θΓ0 | pu 6= pv ) ≤ exp ( − ( θΓ0 − E[〈Ỹu, Ỹv〉 | pu 6= pv] )2 2Γ0 ) . (9)\nBy γ-incoherence and our choice of θ, θΓ0 − E [ 〈Ỹu, Ỹv〉 | pu 6= pv ] ≥ θΓ0 − 4γ∆2Γ0 = (θ − 4γ∆2)Γ0 ≥ 0. (10)\nAbove, we used the fact that Γ0 randomly explored items are a random subset ofm items, and hence E [\n1 Γ 0 〈Ỹu, Ỹv〉\n] = E [ 1 m 〈Yu, Yv〉 ] ,\nwith Yu, Yv representing the entire (random) vector of preferences of u and v respectively.\nCombining inequalities (9) and (10) yields\nP ( 〈Ỹu, Ỹv〉 ≥ θΓ0 | pu 6= pv ) ≤ exp ( − (θ − 4γ∆ 2)2\n2 Γ0\n) .\nA similar argument as the ending of Lemma 8’s proof establishes that the bound holds even if users u and v have jointly explored more than Γ0 items.\nWe now prove Lemma 7.\nLet β = exp(−(θ− 4γ∆2)2Γ0/2) be the probability bound from Lemma 9, where by our choice of θ = 2∆2(1 + γ) and with Γ0 = t1−α/2, we have β = exp(−∆4(1− γ)2t1−α). By Lemma 9, for a pair of users u and v with at least t1−α/2 items jointly explored, the probability that they are erroneously declared neighbors is upper-bounded by β.\nDenote the set of users of type different from u by B, and write nbad = ∑ v∈B 1{u and v are declared to be neighbors},\nwhence E[nbad] ≤ nβ. Markov’s inequality gives\nP(nbad ≥ n √ β) ≤ E[nbad]\nn √ β ≤ nβ n √ β\n= √ β ,\nproving the lemma."
    }, {
      "heading" : "A.2 Proof of Lemma 2",
      "text" : "We reproduce Lemma 2 below. Lemma 2. For user u at time t, if the good neighborhood event Egood(u, t) holds and t ≤ µm, then\nP(Xut = 1) ≥ 1− 2m exp ( − ∆ 2tn1−α\n40km ) − 1 tα − 1 nα .\nWe begin by checking that when the good neighborhood event Egood(u, t) holds for user u, the items have been rated enough times by the good neighbors. Lemma 10. For user u at time t, suppose that the good neighborhood event Egood(u, t) holds. Then for a given item i,\nP ( item i has ≤ tn 1−α\n10km ratings from good neighbors of u\n) ≤ exp ( − tn 1−α\n40km\n) .\nProof. The number of user u’s good neighbors who have rated item i stochastically dominates a Bin( n5k , εR(n)t m ) random variable, where εR(n)t m = t mnα (here, we have critically used the lower bound on the number of good neighbors user u has when the good neighborhood event Egood(u, t) holds). By a Chernoff bound,\nP ( Bin ( n\n5k ,\nt\nmnα\n) ≤ tn 1−α\n10km\n) ≤ exp ( − 1\n2\n( tn 1−α 5km − tn 1−α 10km ) 2\ntn1−α\n5km\n) ≤ exp ( − tn 1−α\n40km\n) .\nNext, we show a sufficient condition for which the algorithm correctly classifies every item as likable or unlikable for user u.\nLemma 11. Suppose that there are no ∆-ambiguous items. For user u at time t, suppose that the good neighborhood event Egood(u, t) holds. Provided that every item i ∈ [m] has more than tn 1−α\n10km\nratings from good neighbors of user u, then with probability at least 1 − m exp(−∆2tn1−α20km ), we have that for every item i ∈ [m],\np̃ui > 1\n2 if item i is likable by user u,\np̃ui < 1\n2 if item i is unlikable by user u.\nProof. Let A be the number of ratings that good neighbors of user u have provided. Suppose item i is likable by user u. Then when we condition on A = a0 , d tn 1−α 10km e, p̃ui stochastically dominates\nqui , Bin(a0, pui) a0 + ∆a0 = Bin(a0, pui) (1 + ∆)a0 ,\nwhich is the worst-case variant of p̃ui that insists that all ∆a0 bad neighbors provided rating “−1” for likable item i (here, we have critically used the upper bound on the number of bad neighbors user u has when the good neighborhood event Egood(u, t) holds). Then\nP(qui ≤ 1\n2 | A = a0) = P\n( Bin(a0, pui) ≤\n(1 + ∆)a0 2 ∣∣∣∣ A = a0) = P ( a0pui − Bin(a0, pui) ≥ a0 ( pui − 1\n2 − ∆ 2 ) ∣∣∣∣ A = a0) (i)\n≤ exp ( − 2a0 ( pui − 1\n2 − ∆ 2 )2) (ii)\n≤ exp ( − 1\n2 a0∆\n2 )\n(iii) ≤ exp ( − ∆ 2tn1−α\n20km\n) ,\nwhere step (i) is Hoeffding’s inequality, step (ii) follows from item i being likable by user u (i.e., pui ≥ 12 + ∆), and step (iii) is by our choice of a0. Conclude then that\nP(p̃ui ≤ 1\n2 | A = a0) ≤ exp\n( − ∆ 2tn1−α\n20km\n) .\nFinally,\nP ( p̃ui ≤ 1\n2 ∣∣∣ A ≥ tn1−α 10km ) = ∑∞ a=a0 P(A = a)P(p̃ui ≤ 12 | A = a) P(A ≥ tn1−α10km )\n≤ ∑∞ a=a0\nP(A = a) exp(−∆2tn1−α20km ) P(A ≥ tn1−α10km )\n= exp ( − ∆ 2tn1−α\n20km\n) .\nA similar argument holds for when item i is unlikable. Union-bounding over all m items yields the claim.\nWe now prove Lemma 2. First off, provided that t ≤ µm, we know that there must still exist an item likable by user u that user u has yet to consume. For user u at time t, supposing that event Egood(u, t) holds, then every item has been rated more than tn 1−α\n10km times by the good neighbors of user u with probability at least 1 − m exp(− tn1−α40km ). This follows from union-bounding over the m items with Lemma 10. Applying Lemma 11, and noting that we only exploit with probability 1− εJ(t)− εR(n) = 1− 1/tα − 1/nα, we finish the proof:\nP(Xut = 1) ≥ 1−m exp ( − tn 1−α\n40km\n) −m exp ( − ∆ 2tn1−α\n20km ) − 1 tα − 1 nα\n≥ 1− 2m exp ( − ∆ 2tn1−α\n40km ) − 1 tα − 1 nα ."
    }, {
      "heading" : "A.3 Experimental Results",
      "text" : "We demonstrate our algorithm COLLABORATIVE-GREEDY on two datasets, showing that they have comparable performance and that they both outperform two existing recommendation algorithms Popularity Amongst Friends (PAF) [4] and Deshpande and Montanari’s method (DM) [12]. At each time step, PAF finds nearest neighbors (“friends”) for every user and recommends to a user the “most popular” item, i.e., the one with the most number of +1 ratings, among the user’s friends. DM doesn’t do any collaboration beyond a preprocessing step that computes item feature vectors via matrix completion. Then during online recommendation, DM learns user feature vectors over time with the help of item feature vectors and recommends an item to each user based on whether it aligns well with the user’s feature vector.\nWe simulate an online recommendation system based on movie ratings from the Movielens10m and Netflix datasets, each of which provides a sparsely filled user-by-movie rating matrix with ratings out of 5 stars. Unfortunately, existing collaborative filtering datasets such as the two we consider don’t offer the interactivity of a real online recommendation system, nor do they allow us to reveal the rating for an item that a user didn’t actually rate. For simulating an online system, the former issue can be dealt with by simply revealing entries in the user-by-item rating matrix over time. We address the latter issue by only considering a dense “top users vs. top items” subset of each dataset. In particular, we consider only the “top” users who have rated the most number of items, and the “top” items that have received the most number of ratings. While this dense part of the dataset is unrepresentative of the rest of the dataset, it does allow us to use actual ratings provided by users without synthesizing any ratings.\nAn initial question to ask is whether the dense movie ratings matrices we consider could be reasonably explained by our latent source model. We automatically learn the structure of these matrices using the method by Grosse et al. [13] and find Bayesian clustered tensor factorization (BCTF) to accurately model the data. This finding isn’t surprising as BCTF has previously been used to model movie ratings data [21]. BCTF effectively clusters both users and movies so that we get structure such as that shown in Figure 1(a) for the Movielens10m “top users vs. top items” matrix. Our latent source model could reasonably model movie ratings data as it only assumes clustering of users.\nFollowing the experimental setup of [4], we quantize a rating of 4 stars or more to be +1 (likeable), and a rating of 3 stars or less to be −1 (unlikeable). While we look at a dense subset of each dataset, there are still missing entries. If a user u hasn’t rated item j in the dataset, then we set the corresponding true rating to 0, meaning that in our simulation, upon recommending item j to user u, we receive 0 reward, but we still mark that user u has consumed item j; thus, item j can no longer be recommended to user u. For both Movielens10m and Netflix datasets, we consider the top n = 200 users and the top m = 500 movies. For Movielens10m, the resulting user-by-rating matrix has 80.7% nonzero entries. For Netflix, the resulting matrix has 86.0% nonzero entries. For an algorithm that recommends item πut to user u at time t, we measure the algorithm’s average cumulative reward up to time T as\n1\nn T∑ t=1 n∑ u=1 Y (T )uπut ,\nwhere we average over users.\nFor all methods, we recommend items until we reach time T = 500, i.e., we make movie recommendations until each user has seen all m = 500 movies. We disallow the matrix completion step for DM to see the users that we actually test on, but we allow it to see the the same items as what is in the simulated online recommendation system in order to compute these items’ feature vectors (using the rest of the users in the dataset). Furthermore, when a rating is revealed, we provide DM both the thresholded rating and the non-thresholded rating, the latter of which DM uses to estimate user feature vectors over time.\nParameters θ and α for and COLLABORATIVE-GREEDY are chosen using training data: We sweep over the two parameters on training data consisting of 200 users that are the “next top” 200 users, i.e., ranked 201 to 400 in number movie ratings they provided. For simplicity, we discretize our search space to θ ∈ {0.0, 0.1, . . . , 1.0} and α ∈ {0.1, 0.2, 0.3, 0.4, 0.5}. We choose the parameter setting achieving the highest area under the cumulative reward curve. For both Movielens10m and Netflix datasets, this corresponded to setting θ = 0.0 and α = 0.5 for COLLABORATIVE-GREEDY.\nIn contrast, the parameters for PAF and DM are chosen to be the best parameters for the test data among a wide range of parameters. The results are shown in Figure 2. We find that our algorithm COLLABORATIVE-GREEDY outperforms PAF and DM. We remark that the curves are roughly concave, which is expected since once we’ve finished recommending likeable items (roughly around time step 300), we end up recommending mostly unlikeable items until we’ve exhausted all the items."
    } ],
    "references" : [ {
      "title" : "A preliminary study on a recommender system for the million songs dataset challenge",
      "author" : [ "Fabio Aiolli" ],
      "venue" : "In Proceedings of the Italian Information Retrieval Workshop,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2013
    }, {
      "title" : "Tensor decompositions for learning latent variable",
      "author" : [ "Anima Anandkumar", "Rong Ge", "Daniel Hsu", "Sham M. Kakade", "Matus Telgarsky" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2012
    }, {
      "title" : "Finite-time analysis of the multiarmed bandit problem",
      "author" : [ "Peter Auer", "Nicolò Cesa-Bianchi", "Paul Fischer" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2002
    }, {
      "title" : "Analysis of a collaborative filter based on popularity amongst neighbors",
      "author" : [ "Kishor Barman", "Onkar Dabeer" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2012
    }, {
      "title" : "Polynomial learning of distribution families",
      "author" : [ "Mikhail Belkin", "Kaushik Sinha" ],
      "venue" : "In Foundations of Computer Science (FOCS),",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2010
    }, {
      "title" : "The million song dataset",
      "author" : [ "Thierry Bertin-Mahieux", "Daniel P.W. Ellis", "Brian Whitman", "Paul Lamere" ],
      "venue" : "In Proceedings of the 12th International Conference on Music Information Retrieval",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2011
    }, {
      "title" : "Statistical analysis of k-nearest neighbor collaborative recommendation",
      "author" : [ "Gérard Biau", "Benoı̂t Cadre", "Laurent Rouvière" ],
      "venue" : "The Annals of Statistics,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2010
    }, {
      "title" : "Regret analysis of stochastic and nonstochastic multi-armed bandit problems",
      "author" : [ "Sébastien Bubeck", "Nicolò Cesa-Bianchi" ],
      "venue" : "Foundations and Trends in Machine Learning,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2012
    }, {
      "title" : "Learning mixtures of product distributions using correlations and independence",
      "author" : [ "Kamalika Chaudhuri", "Satish Rao" ],
      "venue" : "In Conference on Learning Theory,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2008
    }, {
      "title" : "Adaptive collaborating filtering: The low noise regime",
      "author" : [ "Onkar Dabeer" ],
      "venue" : "In IEEE International Symposium on Information Theory, pages 1197–1201,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2013
    }, {
      "title" : "Linear bandits in high dimension and recommendation",
      "author" : [ "Yash Deshpande", "Andrea Montanari" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2013
    }, {
      "title" : "Exploiting compositionality to explore a large space of model structures",
      "author" : [ "Roger B. Grosse", "Ruslan Salakhutdinov", "William T. Freeman", "Joshua B. Tenenbaum" ],
      "venue" : "In Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2012
    }, {
      "title" : "Probability inequalities for sums of bounded random variables",
      "author" : [ "Wassily Hoeffding" ],
      "venue" : "Journal of the American statistical association,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1963
    }, {
      "title" : "Regret bounds for sleeping experts and bandits",
      "author" : [ "Robert Kleinberg", "Alexandru Niculescu-Mizil", "Yogeshwer Sharma" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2010
    }, {
      "title" : "The BellKor solution to the Netflix grand prize. http://www.netflixprize.com/ assets/GrandPrize2009_BPC_BellKor.pdf",
      "author" : [ "Yehuda Koren" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2009
    }, {
      "title" : "Amazon.com recommendations: item-to-item collaborative filtering",
      "author" : [ "Greg Linden", "Brent Smith", "Jeremy York" ],
      "venue" : "IEEE Internet Computing,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2003
    }, {
      "title" : "Settling the polynomial learnability of mixtures of gaussians",
      "author" : [ "Ankur Moitra", "Gregory Valiant" ],
      "venue" : "Proceedings of the 51st Annual IEEE Symposium on Foundations of Computer Science,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2010
    }, {
      "title" : "The pragmatic theory solution to the netflix grand prize",
      "author" : [ "Martin Piotte", "Martin Chabbert" ],
      "venue" : "http:// www.netflixprize.com/assets/GrandPrize2009_BPC_PragmaticTheory.pdf,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2009
    }, {
      "title" : "Grouplens: An open architecture for collaborative filtering of netnews",
      "author" : [ "Paul Resnick", "Neophytos Iacovou", "Mitesh Suchak", "Peter Bergstrom", "John Riedl" ],
      "venue" : "In Proceedings of the 1994 ACM Conference on Computer Supported Cooperative Work, CSCW",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1994
    }, {
      "title" : "Modelling relational data using bayesian clustered tensor factorization",
      "author" : [ "Ilya Sutskever", "Ruslan Salakhutdinov", "Joshua B. Tenenbaum" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2009
    }, {
      "title" : "Reinforcement Learning: An Introduction",
      "author" : [ "Richard S. Sutton", "Andrew G. Barto" ],
      "venue" : null,
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1998
    }, {
      "title" : "On the Likelihood that one Unknown Probability Exceeds",
      "author" : [ "William R. Thompson" ],
      "venue" : "Another in View of the Evidence of Two Samples. Biometrika,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1933
    } ],
    "referenceMentions" : [ {
      "referenceID" : 18,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 15,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 162,
      "endOffset" : 166
    }, {
      "referenceID" : 14,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 233,
      "endOffset" : 245
    }, {
      "referenceID" : 17,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 233,
      "endOffset" : 245
    }, {
      "referenceID" : 0,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 287,
      "endOffset" : 290
    }, {
      "referenceID" : 5,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 335,
      "endOffset" : 338
    }, {
      "referenceID" : 0,
      "context" : "The ratings are noisy: the latent item preferences for user u are represented by a length-m vector pu ∈ [0, 1], where user u likes item i with probability pui, independently across items.",
      "startOffset" : 104,
      "endOffset" : 110
    }, {
      "referenceID" : 19,
      "context" : "We remark that there is evidence suggesting real movie recommendation data to be well modeled by clustering of both users and items [21].",
      "startOffset" : 132,
      "endOffset" : 136
    }, {
      "referenceID" : 21,
      "context" : "A fundamental difference between our setup and that of the standard stochastic multi-armed bandit problem [23, 8] is that the latter allows each item to be recommended an infinite number of times.",
      "startOffset" : 106,
      "endOffset" : 113
    }, {
      "referenceID" : 7,
      "context" : "A fundamental difference between our setup and that of the standard stochastic multi-armed bandit problem [23, 8] is that the latter allows each item to be recommended an infinite number of times.",
      "startOffset" : 106,
      "endOffset" : 113
    }, {
      "referenceID" : 2,
      "context" : "Thus, the solution concept for the stochastic multi-armed bandit problem is to determine the best item (arm) and keep choosing it [3].",
      "startOffset" : 130,
      "endOffset" : 133
    }, {
      "referenceID" : 13,
      "context" : "On the other hand, sleeping bandits [15] allow for the available items at each time step to vary, but the analysis is worst-case in terms of which items are available over time.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 20,
      "context" : "The algorithm is syntactically similar to the ε-greedy algorithm for multiarmed bandits [22], which explores items with probability ε and otherwise greedily chooses the best item seen so far based on a plurality vote.",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 0,
      "context" : "Algorithm 1: COLLABORATIVE-GREEDY Input: Parameters θ ∈ [0, 1], α ∈ (0, 4/7].",
      "startOffset" : 56,
      "endOffset" : 62
    }, {
      "referenceID" : 19,
      "context" : "The clustering was found via Bayesian clustered tensor factorization, which was previously shown to model real movie ratings data well [21].",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 3,
      "context" : "Next, we demonstrate our algorithm COLLABORATIVE-GREEDY on the two simulated online movie recommendation systems, showing that it outperforms two existing recommendation algorithms Popularity Amongst Friends (PAF) [4] and a method by Deshpande and Montanari (DM) [12].",
      "startOffset" : 214,
      "endOffset" : 217
    }, {
      "referenceID" : 10,
      "context" : "Next, we demonstrate our algorithm COLLABORATIVE-GREEDY on the two simulated online movie recommendation systems, showing that it outperforms two existing recommendation algorithms Popularity Amongst Friends (PAF) [4] and a method by Deshpande and Montanari (DM) [12].",
      "startOffset" : 263,
      "endOffset" : 267
    }, {
      "referenceID" : 3,
      "context" : "Following the experimental setup of [4], we quantize a rating of 4 stars or more to be +1 (likable), and a rating less than 4 stars to be −1 (unlikable).",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 6,
      "context" : "[7], who study the asymptotic consistency of a cosinesimilarity nearest-neighbor collaborative filtering method.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 3,
      "context" : "Barman and Dabeer [4] study the performance of an algorithm called Popularity Amongst Friends, examining its ability to predict binary ratings in an asymptotic informationtheoretic setting.",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 9,
      "context" : "Dabeer [11] uses a model similar to ours and studies online collaborative filtering with a moving horizon cost in the limit of small noise using an algorithm that knows the numbers of user types and item types.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 10,
      "context" : "Another related work is by Deshpande and Montanari [12], who study online recommendations as a linear bandit problem; their method, however, does not actually use any collaboration beyond a pre-processing step in which offline collaborative filtering (specifically matrix completion) is solved to compute feature vectors for items.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 8,
      "context" : ", [10, 18, 5, 2]), where one observes samples from a mixture distribution and the goal is to learn the mixture components and weights.",
      "startOffset" : 2,
      "endOffset" : 16
    }, {
      "referenceID" : 16,
      "context" : ", [10, 18, 5, 2]), where one observes samples from a mixture distribution and the goal is to learn the mixture components and weights.",
      "startOffset" : 2,
      "endOffset" : 16
    }, {
      "referenceID" : 4,
      "context" : ", [10, 18, 5, 2]), where one observes samples from a mixture distribution and the goal is to learn the mixture components and weights.",
      "startOffset" : 2,
      "endOffset" : 16
    }, {
      "referenceID" : 1,
      "context" : ", [10, 18, 5, 2]), where one observes samples from a mixture distribution and the goal is to learn the mixture components and weights.",
      "startOffset" : 2,
      "endOffset" : 16
    } ],
    "year" : 2014,
    "abstractText" : "Despite the prevalence of collaborative filtering in recommendation systems, there has been little theoretical development on why and how well it works, especially in the “online” setting, where items are recommended to users over time. We address this theoretical gap by introducing a model for online recommendation systems, cast item recommendation under the model as a learning problem, and analyze the performance of a cosine-similarity collaborative filtering method. In our model, each of n users either likes or dislikes each of m items. We assume there to be k types of users, and all the users of a given type share a common string of probabilities determining the chance of liking each item. At each time step, we recommend an item to each user, where a key distinction from related bandit literature is that once a user consumes an item (e.g., watches a movie), then that item cannot be recommended to the same user again. The goal is to maximize the number of likable items recommended to users over time. Our main result establishes that after nearly log(km) initial learning time steps, a simple collaborative filtering algorithm achieves essentially optimal performance without knowing k. The algorithm has an exploitation step that uses cosine similarity and two types of exploration steps, one to explore the space of items (standard in the literature) and the other to explore similarity between users (novel to this work).",
    "creator" : "LaTeX with hyperref package"
  }
}