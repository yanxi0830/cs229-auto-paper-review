{
  "name" : "1404.3862.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Optimizing the CVaR via Sampling",
    "authors" : [ "Aviv Tamar", "Yonatan Glassner", "Shie Mannor" ],
    "emails" : [ "yglasner}@tx.technion.ac.il,", "shie@ee.technion.ac.il" ],
    "sections" : [ {
      "heading" : null,
      "text" : "1 Introduction Conditional Value at Risk (CVaR; Rockafellar and Uryasev, 2000) is an established risk measure that has found extensive use in finance among other fields. For a random payoff R, whose distribution is parameterized by a controllable parameter θ, the α-CVaR is defined as the expected payoff over the α% worst outcomes of Z:\nΦ(θ) = Eθ [R∣R ≤ να(θ)] ,\nwhere να(θ) is the α-quantile ofR. CVaR optimization aims to find a parameter θ that maximizes Φ(θ).\nWhen the payoff is of the structure R = fθ(X), where fθ is a deterministic function, and X is random but does not depend on θ, CVaR optimization may be formulated as a stochastic program, and solved using various approaches (Rockafellar and Uryasev 2000; Hong and Liu 2009; Iyengar and Ma 2013). Such a payoff structure is appropriate for certain domains, such as portfolio optimization, in which the investment strategy generally does not affect the asset prices. However, in many important domains, for example queueing systems, resource allocation, and reinforcement learning, the tunable parameters also control the distribution of the random outcomes. Since existing CVaR optimization methods are not suitable for such cases, and due to increased interest in risk-sensitive optimization recently in these domains (Tamar, Di Castro, and Mannor 2012;\nCopyright © 2015, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nPrashanth and Ghavamzadeh 2013), there is a strong incentive to develop more general CVaR optimization algorithms.\nIn this work, we propose a CVaR optimization approach that is applicable when θ also controls the distribution of X . The basis of our approach is a new formula that we derive for the CVaR gradient ∂Φ(θ)\n∂θ in the form of a conditional\nexpectation. Based on this formula, we propose a samplingbased estimator for the CVaR gradient, and use it to optimize the CVaR by stochastic gradient descent.\nIn addition, we analyze the bias of our estimator, and use the result to prove convergence of the stochastic gradient descent algorithm to a local CVaR optimum. Our method allows us to consider CVaR optimization in new domains. As an example, we consider a reinforcement learning application, and learn a risk-sensitive controller for the game of Tetris. To our knowledge, CVaR optimization for such a domain is beyond the reach of existing approaches. Considering Tetris also allows us to easily interpret our results, and show that we indeed learn sensible policies.\nWe remark that in certain domains, CVaR is often not maximized directly, but used as a constraint in an optimization problem of the form maxθ Eθ[R] s.t. Φ(θ) ≥ b. Extending our approach to such problems is straightforward, using standard penalty method techniques (see, e.g., Tamar, Di Castro, and Mannor, 2012, and Prashanth and Ghavamzadeh, 2013, for a such an approach with a varianceconstrained objective), since the key component for these methods is the CVaR gradient estimator we provide here. Another appealing property of our estimator is that it naturally incorporates importance sampling, which is important when α is small, and the CVaR captures rare events.\nRelated Work Our approach is similar in spirit to the likelihood-ratio method (LR; Glynn, 1990), that estimates the gradient of the expected payoff. The LR method has been successfully applied in diverse domains such as queueing systems, inventory management, and financial engineering (Fu 2006), and also in reinforcement learning (RL; Sutton and Barto, 1998), where it is commonly known as the policy gradient method (Baxter and Bartlett 2001; Peters and Schaal 2008). Our work extends the LR method to estimating the gradient of the CVaR of the payoff.\nClosely related to our work are the studies of Hong and Liu (2009) and Scaillet (2004), who proposed perturbation\nar X\niv :1\n40 4.\n38 62\nv4 [\nst at\n.M L\n] 2\n2 N\nov 2\n01 4\nanalysis style estimators for the gradient of the CVaR, for the setting mentioned above, in which θ does not affect the distribution of X . Indeed, their gradient formulae are different than ours, and do not apply in our setting.\nLR gradient estimators for other risk measures have been proposed by Borkar (2001) for exponential utility functions, and by Tamar, Di Castro, and Mannor (2012) for mean– variance. These measures, however, consider a very different notion of risk than the CVaR. For example, the mean– variance measure is known to underestimate the risk of rare, but catastrophic events (Agarwal and Naik 2004).\nRisk-sensitive optimization in RL is receiving increased interest recently. A mean-variance criterion was considered by Tamar, Di Castro, and Mannor (2012) and Prashanth and Ghavamzadeh (2013). Morimura et al. (2010) consider the expected return, with a CVaR based risk-sensitive policy for guiding the exploration while learning. Their method, however, does not scale to large problems. Borkar and Jain (2014) optimize a CVaR constrained objective using dynamic programming, by augmenting the state space with the accumulated reward. As such, that method is only suitable for a finite horizon and a small state-space, and does not scale-up to problems such as the Tetris domain we consider. A function approximation extension of (Borkar and Jain 2014) is mentioned, using a three time scales stochastic approximation algorithm. In that work, three different learning rates are decreased to 0, and convergence is determined by the slowest one, leading to an overall slow convergence. In contrast, our approach requires only a single learning rate. Recently, Prashanth (2014) used our gradient formula of Proposition 2 (from a preliminary version of this paper) in a two time-scale stochastic approximation scheme to show convergence of CVaR optimization. Besides providing the theoretical basis for that work, our current convergence result (Theorem 5) obviates the need for the extra time-scale, and results in a simpler and faster algorithm.\n2 A CVaR Gradient Formula In this section we present a new LR-style formula for the gradient of the CVaR. This gradient will be used in subsequent sections to optimize the CVaR with respect to some parametric family. We start with a formal definition of the CVaR, and then present a CVaR gradient formula for 1- dimensional random variables. We then extend our result to the multi-dimensional case.\nLet Z denote a random variable with a cumulative distribution function (C.D.F.) FZ(z) = Pr(Z ≤ z). For convenience, we assume that Z is a continuous random variable, meaning that FZ(z) is everywhere continuous. We also assume that Z is bounded. Given a confidence level α ∈ (0,1), the α-Value-at-Risk, (VaR; or α-quantile) of Z is denoted να(Z), and given by\nνα(Z) = F −1 Z (α) ≐ inf {z ∶ FZ(z) ≥ α} . (1)\nThe α-Conditional-Value-at-Risk of Z is denoted by Φα(Z) and defined as the expectation of the α fraction of the worst outcomes of Z\nΦα(Z) = E [Z ∣Z ≤ να(Z)] . (2)\nWe next present a formula for the sensitivity of Φα(Z) to changes in FZ(z)."
    }, {
      "heading" : "2.1 CVaR Gradient of a 1-Dimensional Variable",
      "text" : "Consider again a random variable Z, but now let its probability density function (P.D.F.) fZ(z; θ) be parameterized by a vector θ ∈ Rk. We let να(Z; θ) and Φα(Z; θ) denote the VaR and CVaR of Z as defined in Eq. (1) and (2), when the parameter is θ, respectively.\nWe are interested in the sensitivity of the CVaR to the parameter vector, as expressed by the gradient ∂\n∂θj Φα(Z; θ).\nIn all but the most simple cases, calculating the gradient analytically is intractable. Therefore, we derive a formula in which ∂\n∂θj Φα(Z; θ) is expressed as a conditional expecta-\ntion, and use it to calculate the gradient by sampling. For technical convenience, we make the following assumption: Assumption 1. Z is a continuous random variable, and bounded in [−b, b] for all θ.\nWe also make the following smoothness assumption on να(Z; θ) and Φα(Z; θ) Assumption 2. For all θ and 1 ≤ j ≤ k, the gradients ∂να(Z;θ) ∂θj and ∂Φα(Z;θ) ∂θj exist and are bounded.\nNote that since Z is continuous, Assumption 2 is satisfied whenever ∂\n∂θj fZ(z; θ) is bounded. Relaxing Assumptions 1\nand 2 is possible, but involves technical details that would complicate the presentation, and is left to future work. The next assumption is standard in LR gradient estimates Assumption 3. For all θ, z, and 1 ≤ j ≤ k, we have that ∂fZ(z;θ) ∂θj /fZ(z; θ) exists and is bounded.\nIn the next proposition we present a LR-style sensitivity formula for Φα(Z; θ), in which the gradient is expressed as a conditional expectation. In Section 3 we shall use this formula to suggest a sampling algorithm for the gradient. Proposition 1. Let Assumptions 1, 2, and 3 hold. Then\n∂Φα(Z;θ)\n∂θj =Eθ[\n∂logfZ(Z; θ)\n∂θj (Z−να(Z; θ))∣Z ≤να(Z;θ)].\nProof. Define the level-setDθ ={z ∈ [−b, b] ∶ z ≤ να(Z; θ)} . By definition,Dθ ≡ [−b, να(Z; θ)], and ∫z∈Dθ fZ (z; θ)dz = α. Taking a derivative and using the Leibniz rule we obtain\n0 = ∂\n∂θj ∫\nνα(Z;θ)\n−b fZ (z; θ)dz\n= ∫\nνα(Z;θ)\n−b\n∂fZ (z; θ)\n∂θj dz +\n∂να(Z; θ)\n∂θj fZ (να(Z; θ); θ) .\n(3)\nBy definition (2) we have Φα(Z; θ) = ∫z∈Dθ fZ(z;θ)z α dz = α−1 ∫ να(Z;θ) −b fZ (z; θ) zdz. Now, taking a derivative and using the Leibniz rule we obtain\n∂\n∂θj Φα(Z; θ) =α\n−1 ∫\nνα(Z;θ)\n−b\n∂fZ (z; θ)\n∂θj zdz\n+α−1 ∂να(Z; θ)\n∂θj fZ(να(Z; θ); θ) να(Z; θ).\n(4)\nRearranging, and plugging (3) in (4) we obtain ∂ ∂θj Φα(Z; θ) = α −1 ∫ να(Z;θ) −b ∂fZ(z;θ) ∂θj (z − να(Z; θ))dz. Finally, using the likelihood ratio trick – multiplying and dividing by fZ (z; θ) inside the integral, which is justified due to Assumption 3, we obtain the required expectation.\nLet us contrast the CVaR LR formula of Proposition 1 with the standard LR formula for the expectation (Glynn 1990) ∂\n∂θj Eθ[Z] = Eθ [∂log fZ(Z;θ) ∂θj (Z − b)], where the\nbaseline b could be any arbitrary constant. Note that in the CVaR case the baseline is specific, and, as seen in the proof, accounts for the sensitivity of the level-set Dθ. Quite surprisingly, this specific baseline turns out to be exactly the VaR, να(Z; θ), which, as we shall see later, also leads to an elegant sampling based estimator.\nIn a typical application, Z would correspond to the performance of some system, such as the profit in portfolio optimization, or the total reward in RL. Note that in order to use Proposition 1 in a gradient estimation algorithm, one needs access to ∂\n∂θj log fZ(Z; θ): the sensitiv-\nity of the performance distribution to the parameters. Typically, the system performance is a complicated function of a high-dimensional random variable. For example, in RL and queueing systems, the performance is a function of a trajectory from a stochastic dynamical system, and calculating its probability distribution is usually intractable. The sensitivity of the trajectory distribution to the parameters, however, is often easy to calculate, since the parameters typically control how the trajectory is generated. We shall now generalize Proposition 1 to such cases. The utility of this generalization is further exemplified in Section 5, for the RL domain."
    }, {
      "heading" : "2.2 CVaR Gradient Formula – General Case",
      "text" : "Let X = (X1,X2, . . . ,Xn) denote an n−dimensional random variable with a finite support [−b, b]n, and let Y denote a discrete random variable taking values in some countable set Y . Let fY (y; θ) denote the probability mass function of Y , and let fX∣Y (x∣y; θ) denote the probability density function of X given Y . Let the reward function r be a bounded mapping from [−b, b]n × Y to R, and consider the random variable R ≐ r(X, Y ). We are interested in a formula for ∂ ∂θj\nΦα(R; θ). We make the following assumption, similar to Assumptions 1, 2, and 3. Assumption 4. The reward R is a continuous random variable for all θ. Furthermore, for all θ and 1 ≤ j ≤ k, the gradients ∂\n∂θj να(R; θ) and ∂∂θj Φα(R; θ) are well defined and\nbounded. In addition ∂log fX∣Y (x∣y;θ) ∂θj and ∂log fY (y;θ) ∂θj\nexist and are bounded for all x, y, and θ.\nDefine the level-set Dy;θ = {x ∈ [−b, b]n ∶ r(x, y) ≤ να(R; θ)} . We require some smoothness of the function r, that is captured by the following assumption on Dy;θ. Assumption 5. For all y and θ, the set Dy;θ may be written as a finite sum of Ly;θ disjoint, closed, and connected componentsDiy;θ, each with positive measure:Dy;θ =∑ Ly;θ i=1 D i y;θ.\nAssumption 5 may satisfied, for example, when r(x, y) is Lipschitz in x for all y ∈ Y . We now present a sensitivity formula for Φα(R; θ). Proposition 2. Let Assumption 4 and 5 hold. Then\n∂\n∂θj Φα(R; θ) = Eθ [(\n∂log fY (Y ; θ)\n∂θj +\n∂log fX∣Y (X∣Y ; θ)\n∂θj )(R − να(R; θ))∣R ≤ να(R; θ)] .\nThe proof of Proposition 2 is similar in spirit to the proof of Proposition 1, but involves some additional difficulties of applying the Leibnitz rule in a multidimensional setting. It is given in (?). We reiterate that relaxing Assumptions 4 and 5 is possible, but is technically involved, and left for future work. In the next section we show that the formula in Proposition 2 leads to an effective algorithm for estimating ∂ ∂θj Φα(R; θ) by sampling.\n3 A CVaR Gradient Estimation Algorithm The sensitivity formula in Proposition 2 suggests a natural Monte–Carlo (MC) estimation algorithm. The method, which we label GCVaR (Gradient estimator for CVaR), is described as follows. Let x1, y1 . . . ,xN , yN be N samples drawn i.i.d. from fX,Y (x, y; θ), the joint distribution of X and Y . We first estimate να(R; θ) using the empirical αquantile1 ṽ\nṽ = inf z F̂ (z) ≥ α, (5)\nwhere F̂ (z) is the empirical C.D.F. of R: F̂ (z) ≐ 1 N ∑ N i=1 1r(xi,yi)≤z. The MC estimate of the gradient ∆j;N ≈\n∂ ∂θj Φα(R; θ) is given by\n∆j;N = 1\nαN\nN\n∑ i=1\n( ∂log fY (yi; θ) ∂θj + ∂log fX∣Y (xi∣yi; θ) ∂θj )×\n×(r(xi, yi) − ṽ)1r(xi,yi)≤ṽ. (6)\nIt is known that the empirical α-quantile is a biased estimator of να(R; θ). Therefore, ∆j;N is also a biased estimator of ∂\n∂θj Φα(R; θ). In the following we analyze and bound\nthis bias. We first show that ∆j;N is a consistent estimator. The proof is similar to the proof of Theorem 4.1 in (Hong and Liu 2009), and given in the supplementary material. Theorem 3. Let Assumption 4 and 5 hold. Then ∆j;N → ∂ ∂θj Φα(R; θ) w.p. 1 as N →∞.\nWith an additional smoothness assumption we can explicitly bound the bias. Let fR(⋅; θ) denote the P.D.F. of R, and define the function g(β; θ) ≐ Eθ[(∂log fY (Y ;θ)\n∂θj + ∂log fX∣Y (X∣Y ;θ) ∂θj )(R−να(R; θ))∣R = β].\nAssumption 6. For all θ, fR(⋅; θ) and g(⋅; θ) are continuous at να(R; θ), and fR(να(R; θ); θ) > 0.\n1Algorithmically, this is equivalent to first sorting the r(xi, yi)’s in ascending order, and then selecting ṽ as the ⌈αN⌉ term in the sorted list.\nAlgorithm 1 GCVaR"
    }, {
      "heading" : "1: Given:",
      "text" : "• CVaR level α • A reward function r(x, y) ∶ Rn ×Y → R • Derivatives ∂\n∂θj of the probability mass function fY (y; θ)\nand probability density function fX∣Y (x∣y; θ)\n• An i.i.d. sequence x1, y1, . . . ,xN , yN ∼ fX,Y (x, y; θ). 2: Set rs1, . . . , r s N = Sort (r(x1, y1), . . . , r(xN , yN)) 3: Set ṽ = rs⌈αN⌉ 4: For j = 1, . . . , k do\n∆j;N = 1\nαN\nN\n∑ i=1\n( ∂log fY (yi; θ) ∂θj + ∂log fX∣Y (xi∣yi; θ) ∂θj )×\n×(r(xi, yi) − ṽ)1r(xi,yi)≤ṽ\n5: Return:∆1;N , . . . ,∆k;N\nAssumption 6 is similar to Assumption 4 of (Hong and Liu 2009), and may be satisfied, for example, when ∂log fX∣Y (x∣y;θ)\n∂θj is continuous and r(x, y) is Lipschitz in x.\nThe next theorem shows that the bias is O(N−1/2). The proof, given in the supplementary material, is based on separating the bias to a term that is bounded using a result of Hong and Liu (2009), and an additional term that we bound using well-known results for the bias of empirical quantiles.\nTheorem 4. Let Assumptions 4, 5, and 6 hold. Then E [∆j;N ] − ∂∂θj Φα(R; θ) is O(N −1/2).\nAt this point, let us again contrast GCVaR with the standard LR method. One may naively presume that applying a standard LR gradient estimator to the α% worst samples would work as a CVaR gradient estimator. This corresponds to applying the GCVaR algorithm without subtracting the ṽ baseline from the reward in (6). Theorems 3 and 4 show that such an estimator would not be consistent. In fact, in the supplementary material we give an example where the gradient error of such an approach may be arbitrarily large.\nIn the sequel, we use GCVaR as part of a stochastic gradient descent algorithm for CVaR optimization. An asymptotically decreasing gradient bias, as may be established from Theorem 3, is necessary to guarantee convergence of such a procedure. Furthermore, the bound of Theorem 4 will allow us to quantify how many samples are needed at each iteration for such convergence to hold."
    }, {
      "heading" : "Variance Reduction by Importance Sampling",
      "text" : "For very low quantiles, i.e., α close to 0, the GCVaR estimator would suffer from a high variance, since the averaging is effectively only over αN samples. This is a well-known issue in sampling based approaches to VaR and CVaR estimation, and is often mitigated using variance reduction techniques such as Importance Sampling (IS; Rubinstein and Kroese, 2011; Bardou, Frikha, and Pagès, 2009). In IS, the variance of a MC estimator is reduced by using samples\nfrom a different sampling distribution, and suitably modifying the estimator to keep it unbiased. It is straightforward to incorporate IS into LR gradient estimators in general, and to our GCVaR estimator in particular. Due to space constraints, and since this is fairly standard textbook material (e.g., Rubinstein and Kroese, 2011), we provide the full technical details in the supplementary material. In our empirical results we show that using IS indeed leads to significantly better performance.\n4 CVaR Optimization In this section, we consider the setting of Section 2.2, and aim to solve the CVaR optimization problem:\nmax θ∈Rk Φα(R; θ). (7)\nFor this goal we propose CVaRSGD: a stochastic gradient descent algorithm, based on the GCVaR gradient estimator. We now describe the CVaRSGD algorithm in detail, and show that it converges to a local optimum of (7).\nIn CVaRSGD, we start with an arbitrary initial parameter θ0 ∈ Rk. The algorithm proceeds iteratively as follows. At each iteration i of the algorithm, we first sample ni i.i.d. realizations x1, y1, . . . , xni , yni of the random variables X and Y , from the distribution fX,Y (x, y; θi). We then apply the GCVaR algorithm to obtain an estimate ∆j;ni of ∂ ∂θj Φα(R; θ i), using the samples x1, y1, . . . , xni , yni . Finally, we update the parameter according to\nθi+1j = Γ (θ i j + i∆j;ni) , (8)\nwhere i is a positive step size, and Γ ∶ Rk → Rk is a projection to some compact set Θ with a smooth boundary. The purpose of the projection is to facilitate convergence of the algorithm, by guaranteeing that the iterates remain bounded (this is a common stochastic approximation technique; Kushner and Yin, 2003). In practice, if Θ is chosen large enough so that it contains the local optima of Φα(R; θ), the projection would rarely occur, and would have a negligible effect on the algorithm. Let Γ̂θ(ν) ≐ limδ→0 Γ(θ+δν)−θ δ\ndenote an operator that, given a direction of change ν to the parameter θ, returns a modified direction that keeps θ within Θ. Consider the following ordinary differential equation:\nθ̇ = Γ̂θ (∇Φα(R; θ)) , θ(0) ∈ Θ. (9)\nLet K denote the set of all asymptotically stable equilibria of (9). The next theorem shows that under suitable technical conditions, the CVaRSGD algorithm converges to K almost surely. The theorem is a direct application of Theorem 5.2.1 of Kushner and Yin (2003), and given here without proof.\nTheorem 5. Consider the CVaRSGD algorithm (8). Let Assumptions 4, 5, and 6 hold, and assume that Φα(R; θ) is continuously differentiable in θ. Also, assume that ∑∞i=1 i = ∞, ∑ ∞ i=1 2 i < ∞, and that ∑ ∞ i=1 i ∣E [∆j;ni] − ∂∂θj Φα(R; θ i)∣ < ∞ w.p. 1 for all j. Then θi → K almost surely.\nNote that from the discussion in Section 3, the requirement ∑∞i=1 i ∣E [∆j;ni] − ∂∂θj Φα(R; θ\ni)∣ < ∞ implies that we must have limi→∞ ni =∞. However, the rate of ni could be very slow, for example, using the bound of Theorem 4 the requirement may be satisfied by choosing i = 1/i and ni = (log i) 4.\n5 Application to Reinforcement Learning In this section we show that the CVaRSGD algorithm may be used in an RL policy-gradient type scheme, for optimizing performance criteria that involve the CVaR of the total return. We first describe some preliminaries and our RL setting, and then describe our algorithm.\nWe consider an episodic2 Markov Decision Problem (MDP) in discrete time with a finite state space S and a finite action space A. At time t ∈ {0,1,2, . . .} the state is st, and an action at is chosen according to a parameterized policy πθ, which assigns a distribution over actions fa∣h(a∣h; θ) according to the observed history of states ht = s0, . . . , st. Then, an immediate random reward ρt ∼ fρ∣s,a(ρ∣s, a) is received, and the state transitions to st+1 according to the MDP transition probability fs′∣s,a(s′∣s, a). We denote by ζ0 the initial state distribution and by s∗ a terminal state, and we assume that for all θ, s∗ is reached w.p. 1.\nFor some policy πθ, let s0, a0, ρ0, s1, a1, ρ1, . . . , sτ denote a state-action-reward trajectory from the MDP under that policy, that terminates at time τ , i.e., sτ = s∗. The trajectory is a random variable, and we decompose3 it into a discrete part Y ≐ s0, a0, s1, a1, . . . , s∗ and a continuous part X ≐ ρ0, ρ1, . . . , ρτ−1. Our quantity of interest is the total reward along the trajectory R ≐ ∑τt=0 ρt. In standard RL, the objective is to find the parameter θ that maximizes the expected return V (θ) = Eθ [R]. Policy gradient methods (Baxter and Bartlett 2001; Marbach and Tsitsiklis 1998; Peters and Schaal 2008) use simulation to estimate ∂V (θ)/∂θj , and then perform stochastic gradient ascent on the parameters θ. In this work we are risk-sensitive, and our goal is to maximize the CVaR of the total return J(θ) ≐ Φα(R; θ). In the spirit of policy gradient methods, we estimate ∂J(θ)/∂θj from simulation, using GCVaR, and optimize θ using CVaRSGD. We now detail our approach.\nFirst, it is well known (Marbach and Tsitsiklis 1998) that by the Markov property of the state transitions:\n∂ log fY (Y ; θ) /∂θ = τ−1 ∑ t=0 ∂ log fa∣h(at∣ht; θ)/∂θ. (10)\nAlso, note that in our formulation we have\n∂ log fX∣Y (xi∣yi; θ) /∂θ = 0, (11)\nsince the reward does not depend on θ directly. To apply CVaRSGD in the RL setting, at each iteration i of the algorithm we simulate ni trajectories x1, y1, . . . , xni , yni 2Also known as a stochastic shortest path (Bertsekas 2012). 3This decomposition is not restrictive, and used only to illustrate the definitions of Section 2. One may alternatively consider a continuous state space, or discrete rewards, so long as Assumptions 4, 5, and 6 hold.\nof the MDP using policy πθi (each xk and yk here together correspond to a single trajectory, as realizations of the random variables X and Y defined above). We then apply the GCVaR algorithm to obtain an estimate ∆j;ni of ∂J(θ)/∂θj , using the simulated trajectories x1, y1, . . . , xni , yni , Eq. (10), and Eq. (11). Finally, we update the policy parameter according to Eq. (8). Note that due to Eq. (10), the transition probabilities of the MDP, which are generally not known to the decision maker, are not required for estimating the gradient using GCVaR. Only policy-dependent terms are required.\nWe should remark that for the standard RL criterion V (θ), a Markov policy that depends only on the current state suffices to achieve optimality (Bertsekas 2012). For the CVaR criterion this is not necessarily the case. Bäuerle and Ott (2011) show that under certain conditions, an augmentation of the current state with a function of the accumulated reward suffices for optimality. In our simulations, we used a Markov policy, and still obtained useful and sensible results.\nAssumptions 4, 5, and 6, that are required for convergence of the algorithm, are reasonable for the RL setting, and may be satisfied, for example, when fρ∣s,a(ρ∣s, a) is smooth, and ∂ log fa∣h(a∣h; θ)/∂θj is well defined and bounded. This last condition is standard in policy gradient literature, and a popular policy representation that satisfies it is softmax action selection (Sutton et al. 2000; Marbach and Tsitsik-\nlis 1998), given by fa∣h(a∣h; θ) = exp(φ(h,a)\n⊺ θ)\n∑a′ exp(φ(h,a′) ⊺θ) , where\nφ(h, a) ∈ Rk are a set of k features that depend on the history and action.\nIn some RL domains, the reward takes only discrete values. While this case is not specifically covered by the theory in this paper, one may add an arbitrarily small smooth noise to the total reward for our results to hold. Since such a modification has negligible impact on performance, this issue is of little importance in practice. In our experiments the reward was discrete, and we did not observe any problem."
    }, {
      "heading" : "5.1 Experimental Results",
      "text" : "We examine Tetris as a test case for our algorithms. Tetris is a popular RL benchmark that has been studied extensively. The main challenge in Tetris is its large state space, which necessitates some form of approximation in the solution technique. Many approaches to learning controllers for Tetris are described in the literature, among them are approximate value iteration (Tsitsiklis and Van Roy 1996), policy gradients (Kakade 2001; Furmston and Barber 2012), and modified policy iteration (Gabillon, Ghavamzadeh, and Scherrer 2013). The standard performance measure in Tetris is the expected number of cleared lines in the game. Here, we are interested in a risk-averse performance measure, captured by the CVaR of the total game score. Our goal in this section is to compare the performance of a policy optimized for the CVaR criterion versus a policy obtained using the standard policy gradient method. As we will show, optimizing the CVaR indeed produces a different policy, characterized by a risk-averse behavior. We note that at present, the best results in the literature (for the standard performance measure) were obtained using a modified policy iteration approach (Gabillon, Ghavamzadeh, and Scherrer 2013), and\nnot using policy gradients. We emphasize that our goal here is not to compete with those results, but rather to illustrate the application of CVaRSGD. We do point out, however, that whether the approach of Gabillon, Ghavamzadeh, and Scherrer (2013) could be extended to handle a CVaR objective is currently not known.\nWe used the regular 10 × 20 Tetris board with the 7 standard shapes (a.k.a. tetrominos). In order to induce risksensitive behavior, we modified the reward function of the game as follows. The score for clearing 1,2,3 and 4 lines is 1,4,8 and 16 respectively. In addition, we limited the maximum number of steps in the game to 1000. These modifications strengthened the difference between the risk-sensitive and nominal policies, as they induce a tradeoff between clearing many ’single’ lines with a low profit, or waiting for the more profitable, but less frequent, ’batches’.\nWe used the softmax policy, with the feature set of Thiery and Scherrer (2009). Starting from a fixed policy parameter θ0, which was obtained by running several iterations of standard policy gradient (giving both methods a ’warm start’), we ran both CVaRSGD and standard policy gradient4 for enough iterations such that both algorithms (approximately) converged. We set α = 0.05 and N = 1000.\nIn Fig. 1A and Fig. 1B we present the average return V (θ) and CVaR of the return J(θ) for the policies of both algorithms at each iteration (evaluated by MC on independent trajectories). Observe that for CVaRSGD, the average return has been compromised for a higher CVaR value.\nThis compromise is further explained in Fig. 1C, where we display the reward distribution of the final policies. It may be observed that the left-tail distribution of the CVaR policy is significantly lower than the standard policy. For the risk-sensitive decision maker, such results are very important, especially if the left-tail contains catastrophic outcomes, as is common in many real-world domains, such as finance. To better understand the differences between the policies, we compare the final policy parameters θ in\n4Standard policy gradient is similar to CVaRSGD when α = 1. However, it is common to subtract a baseline from the reward in order to reduce the variance of the gradient estimate. In our experiments, we used the average return < r > as a baseline, and our gradient estimate was 1\nN ∑ N i=1 ∂log fY (yi;θ) ∂θj (r(xi, yi)− < r >).\nFig. 1D. The most significant difference is in the parameter that corresponds to the Board Well feature. A well is a succession of unoccupied cells in a column, such that their left and right cells are both occupied. The controller trained by CVaRSGD has a smaller negative weight for this feature, compared to the standard controller, indicating that actions which create deep-wells are repressed. Such wells may lead to a high reward when they get filled, but are risky as they heighten the board.\nTo demonstrate the importance of IS in optimizing the CVaR when α is small, we choseα = 0.01, andN = 200, and compared CVaRSGD against its IS version, IS CVaRSGD, described in the supplementary material. As Fig. 1E shows, IS GCVaRSGD converged significantly faster, improving the convergence rate by more than a factor of 2. The full details are provided in the supplementary material.\n6 Conclusion and Future Work We presented a novel LR-style formula for the gradient of the CVaR performance criterion. Based on this formula, we proposed a sampling-based gradient estimator, and a stochastic gradient descent procedure for CVaR optimization that is guaranteed to converge to a local optimum. To our knowledge, this is the first extension of the LR method to the CVaR performance criterion, and our results extend CVaR optimization to new domains.\nWe evaluated our approach empirically in an RL domain: learning a risk-sensitive policy for Tetris. To our knowledge, such a domain is beyond the reach of existing CVaR optimization approaches. Moreover, our empirical results show that optimizing the CVaR indeed results in useful risksensitive policies, and motivates the use of simulation-based optimization for risk-sensitive decision making.\nAcknowledgments The authors thank Odalric-Ambrym Maillard for many helpful discussions. The research leading to these results has received funding from the European Research Council under the European Union’s Seventh Framework Program (FP/2007-2013) / ERC Grant Agreement n. 306638.\nReferences [2004] Agarwal, V., and Naik, N. Y. 2004. Risks and portfolio deci-\nsions involving hedge funds. Review of Financial Studies 17(1):63– 98.\n[2009] Bardou, O.; Frikha, N.; and Pagès, G. 2009. Computing var and cvar using stochastic approximation and adaptive unconstrained importance sampling. Monte Carlo Methods and Applications 15(3):173–210.\n[2011] Bäuerle, N., and Ott, J. 2011. Markov decision processes with average-value-at-risk criteria. Mathematical Methods of Operations Research 74(3):361–379.\n[2001] Baxter, J., and Bartlett, P. L. 2001. Infinite-horizon policygradient estimation. JAIR 15:319–350.\n[2012] Bertsekas, D. P. 2012. Dynamic Programming and Optimal Control, Vol II. Athena Scientific, 4th edition.\n[2014] Borkar, V., and Jain, R. 2014. Risk-constrained Markov decision processes. IEEE TAC PP(99):1–1.\n[2001] Borkar, V. S. 2001. A sensitivity formula for risk-sensitive cost and the actor–critic algorithm. Systems & Control Letters 44(5):339–346.\n[2002] Boyan, J. A. 2002. Technical update: Least-squares temporal difference learning. Machine Learning 49(2):233–246.\n[1981] David, H. 1981. Order Statistics. A Wiley publication in applied statistics. Wiley.\n[1973] Flanders, H. 1973. Differentiation under the integral sign. The American Mathematical Monthly 80(6):615–627.\n[2006] Fu, M. C. 2006. Gradient estimation. In Henderson, S. G., and Nelson, B. L., eds., Simulation, volume 13 of Handbooks in Operations Research and Management Science. Elsevier. 575 – 616.\n[2012] Furmston, T., and Barber, D. 2012. A unifying perspective of parametric policy search methods for Markov decision processes. In NIPS.\n[2013] Gabillon, V.; Ghavamzadeh, M.; and Scherrer, B. 2013. Approximate dynamic programming finally performs well in the game of tetris. In NIPS.\n[1990] Glynn, P. W. 1990. Likelihood ratio gradient estimation for stochastic systems. Communications of the ACM 33(10):75–84.\n[1996] Glynn, P. W. 1996. Importance sampling for monte carlo estimation of quantiles. In Mathematical Methods in Stochastic Simulation and Experimental Design: Proceedings of the 2nd St. Petersburg Workshop on Simulation, 180–185.\n[2009] Hong, L. J., and Liu, G. 2009. Simulating sensitivities of conditional value at risk. Management Science.\n[2013] Iyengar, G., and Ma, A. 2013. Fast gradient descent method for mean-cvar optimization. Annals of Operations Research 205(1):203–212.\n[2001] Kakade, S. 2001. A natural policy gradient. In NIPS. [2003] Kushner, H., and Yin, G. 2003. Stochastic approximation\nand recursive algorithms and applications. Springer Verlag. [1998] Marbach, P., and Tsitsiklis, J. N. 1998. Simulation-based\noptimization of Markov reward processes. IEEE Transactions on Automatic Control 46(2):191–209.\n[2010] Morimura, T.; Sugiyama, M.; Kashima, H.; Hachiya, H.; and Tanaka, T. 2010. Nonparametric return distribution approximation for reinforcement learning. In ICML, 799–806.\n[2008] Peters, J., and Schaal, S. 2008. Reinforcement learning of motor skills with policy gradients. Neural Networks 21(4):682– 697.\n[2013] Prashanth, L., and Ghavamzadeh, M. 2013. Actor-critic algorithms for risk-sensitive mdps. In NIPS.\n[2014] Prashanth, L. 2014. Policy gradients for CVaR-constrained MDPs. In International Conference on Algorithmic Learning Theory.\n[2000] Rockafellar, R. T., and Uryasev, S. 2000. Optimization of conditional value-at-risk. Journal of risk 2:21–42.\n[2011] Rubinstein, R. Y., and Kroese, D. P. 2011. Simulation and the Monte Carlo method. John Wiley & Sons.\n[2004] Scaillet, O. 2004. Nonparametric estimation and sensitivity analysis of expected shortfall. Mathematical Finance.\n[1998] Sutton, R. S., and Barto, A. G. 1998. Reinforcement learning: An introduction. Cambridge Univ Press.\n[2000] Sutton, R. S.; McAllester, D.; Singh, S.; and Mansour, Y. 2000. Policy gradient methods for reinforcement learning with function approximation. In NIPS.\n[2012] Tamar, A.; Di Castro, D.; and Mannor, S. 2012. Policy gradients with variance related risk criteria. In ICML.\n[2009] Thiery, C., and Scherrer, B. 2009. Improvements on learning tetris with cross entropy. International Computer Games Association Journal 32.\n[1996] Tsitsiklis, J. N., and Van Roy, B. 1996. Feature-based methods for large scale dynamic programming. Machine Learning 22(1- 3):59–94.\nA Proof of Proposition 2 Proof. The main difficulty in extending the proof of Proposition 1 to this case is in applying the Leibnitz rule in a multidimensional case. Such an extension is given by (Flanders 1973), which we now state.\nWe are given an n−dimensional θ−dependent chain (field of integration) Dθ in Rn. We also have an exterior differential n−form whose coefficients are θ-dependent:\nω = f(x, θ)dx1 ∧⋯ ∧ dxn\nThe general Leibnitz rule5 is given by ∂\n∂θ ∫ Dθ ω = ∫ ∂Dθ v ⌟ ω + ∫ Dθ\n∂ω ∂θ (12)\nwhere v denotes the vector field of velocities ∂ ∂θ x of Dθ, and v⌟ω denotes the interior product between v and ω (see (Flanders 1973) for more details). We now write the CVaR explicitly as\nΦα(R; θ) = 1\nα ∑ y∈Y fY (y; θ)∫ x∈Dy;θ fX∣Y (x∣y; θ)r(x, y)dx\n= 1\nα ∑ y∈Y\nfY (y; θ) Ly;θ\n∑ i=1 ∫ x∈Di y;θ\nfX∣Y (x∣y; θ)r(x, y)dx,\ntherefore\n∂\n∂θj Φα(R; θ) =\n1 α ∑ y∈Y ∂fY (y; θ) ∂θj\nLy;θ\n∑ i=1 ∫ x∈Di y;θ\nfX∣Y (x∣y; θ)r(x, y)dx\n+ 1\nα ∑ y∈Y\nfY (y; θ) Ly;θ\n∑ i=1\n∂\n∂θj ∫ x∈Di\ny;θ\nfX∣Y (x∣y; θ)r(x, y)dx\n(13)\nWe now treat each Diy;θ in the last sum separately. Let X denote the set [−b, b] n over which X is defined. Obviously, Diy;θ ⊂ X .\nWe now make an important observation. By definition of the level-set Diy;θ, and since it is closed by Assumption 5, for every x ∈ ∂Diy;θ we have that either (a) r(x, y) = να(R; θ), (14) or\n(b) x ∈ ∂X , and r(x, y) < να(R; θ). (15)\nWe write ∂Diy;θ = ∂D i,a y;θ + ∂D i,b y;θ where the two last terms correspond to the two possibilities in (14) and (15).\nWe now claim that for the boundary term ∂Di,by;θ, we have\n∫ ∂Di,b\ny;θ\nv ⌟ ω = 0. (16)\nTo see this, first note that by definition of X , the boundary ∂X is smooth and has a unique normal vector at each point, except for a set of measure zero (the corners of X ). Let ∂D̃i,by;θ denote the set of all points in ∂D i,b y;θ for which a unique normal vector exists. For each x ∈ ∂D̃i,by;θ we let v⊥ and v∥ denote the normal and tangent (with respect to ∂X ) elements of the velocity ∂ ∂θ x at x, respectively. Thus, v = v⊥ + v∥.\nFor some > 0 let d denote the set {x ∈ ∂D i,b y;θ ∶ r(x, y) < να(R; θ) − }. From Assumption 4 we have that ∂ ∂θj να(R; θ) is bounded, therefore there exists δ( ) > 0 such that for all θ′ that satisfy ∥θ − θ′∥ < δ( ) we have ∣να(R; θ′) − να(R; θ)∣ < , and therefore d ∈ ∂D\ni,b y;θ′ . Since this holds for every > 0, we conclude that a small change in θ does not change ∂D i,b y;θ, and\ntherefore we have v⊥ = 0, ∀x ∈ ∂D̃ i,b y;θ.\nFurthermore, by definition of the interior product we have\nv∥ ⌟ ω = 0.\n5The formula in (Flanders 1973) is for a more general case whereDθ is not necessarily n−dimensional. That formula includes an additional term ∫Dθ v ⌟ dxω, where dx is the exterior derivative, which cancels in our case.\nTherefore we have\n∫ ∂Di,b\ny;θ\nv ⌟ ω = ∫ ∂D̃i,b\ny;θ\nv ⌟ ω = ∫ ∂D̃i,b\ny;θ\nv∥ ⌟ ω = 0,\nand the claim follows. Now, let ωy = fX∣Y (x∣y; θ)r(x, y)dx1 ∧⋯ ∧ dxn. Using (12), we have\n∂\n∂θj ∫ x∈Di\ny;θ\nωy = ∫ ∂Di\ny;θ v ⌟ ωy + ∫ Di y;θ\n∂ωy\n∂θ\n= ∫ ∂Di,a\ny;θ v ⌟ ωy + ∫ Di y;θ\n∂ωy\n∂θ\n(17)\nwhere the last equality follows from (16) and the definition of v. Let ω̃y = fX∣Y (x∣y; θ)dx1 ∧⋯ ∧ dxn. By the definition of Dy;θ we have that for all θ\nα = ∑ y∈Y fY (y; θ)∫ Dy;θ ω̃y,\ntherefore, by taking a derivative, and using (16) we have\n0 = ∂\n∂θj\n⎛ ⎝ ∑ y∈Y fY (y; θ)∫ Dy;θ ω̃y ⎞ ⎠ =∑ y∈Y ∂fY (y; θ) ∂θj ∫ Dy;θ ω̃y\n+ ∑ y∈Y\nfY (y; θ) Ly;θ\n∑ i=1 (∫ ∂Di,a y;θ v ⌟ ω̃y + ∫ Di y;θ\n∂ω̃y\n∂θ )\n(18)\nFrom (14), and linearity of the interior product we have\n∫ ∂Di,a\ny;θ\nv ⌟ ωy = να(R; θ)∫ ∂Di,a\ny;θ\nv ⌟ ω̃y,\ntherefore, plugging in (18) we have\n∑ y∈Y\nfY (y; θ) Ly;θ\n∑ i=1 ∫ ∂Di,a y;θ v ⌟ ωy = − να(R; θ)∑ y∈Y\nfY (y; θ) Ly;θ\n∑ i=1 ∫ Di y;θ\n∂ω̃y\n∂θ\n− να(R; θ)∑ y∈Y\n∂fY (y; θ)\n∂θj ∫ Dy;θ\nω̃y\n(19)\nNow, note that from (13) and (17) we have\n∂\n∂θj Φα(R; θ) =\n1 α ∑ y∈Y ∂fY (y; θ) ∂θj\nLy;θ\n∑ i=1 ∫ x∈Di y;θ\nωy\n+ 1\nα ∑ y∈Y\nfY (y; θ) Ly;θ\n∑ i=1 ∫ Di y;θ\n∂ωy\n∂θ\n+ 1\nα ∑ y∈Y\nfY (y; θ) Ly;θ\n∑ i=1 ∫ ∂Di,a y;θ\nv ⌟ ωy,\nand by plugging in (19) we obtain\n∂\n∂θj Φα(R; θ) =\n1 α ∑ y∈Y ∂fY (y; θ) ∂θj\nLy;θ\n∑ i=1 ∫ Di y;θ\nωy − να(R; θ)ω̃y\n+ 1\nα ∑ y∈Y\nfY (y; θ) Ly;θ\n∑ i=1 ∫ Di y;θ\n∂ωy\n∂θ − να(R; θ)\n∂ω̃y\n∂θ .\nFinally, using the standard likelihood ratio trick – multiplying and dividing by fY (y; θ) inside the first sum, and multiplying and dividing by fX∣Y (x∣y; θ) inside the second integral we obtain the required expectation.\nB Proof of Theorem 3 Proof. Let ν = να(R; θ). To simplify notation, we also introduce the functions h1(x, y) ≐ ( ∂log fY (y;θ)\n∂θj + ∂log fX∣Y (x∣y;θ) ∂θj ) r(x, y), and h2(x, y) ≐ ( ∂log fY (y;θ) ∂θj + ∂log fX∣Y (x∣y;θ) ∂θj ). Thus we have\n∆j;N = 1\nαN\nN\n∑ i=1 (h1(xi, yi) − h2(xi, yi)ṽ)1r(xi,yi)≤ṽ\n= 1\nαN\nN\n∑ i=1 (h1(xi, yi) − h2(xi, yi)ν)1r(xi,yi)≤ν\n+ 1\nαN\nN\n∑ i=1 (h1(xi, yi) − h2(xi, yi)ν) (1r(xi,yi)≤ṽ − 1r(xi,yi)≤ν)\n+ (ν − ṽ) 1\nαN\nN ∑ i=1 h2(xi, yi) (1r(xi,yi)≤ṽ)\n(20)\nWe furthermore let D(x, y) ≐ h1(x, y) − h2(x, y)ν. Note that by Assumption 4, D is bounded. By Proposition 2, and the strong law of large numbers, we have that w.p. 1\n1\nαN\nN\n∑ i=1\n(h1(xi, yi) − h2(xi, yi)ν)1r(xi,yi)≤ν → ∂\n∂θj Φα(R; θ). (21)\nWe now show that the two additional terms in (20) vanish as N →∞. By Hölder’s inequality\n∣ 1\nN\nN ∑ i=1 D(xi, yi) (1r(xi,yi)≤ṽ − 1r(xi,yi)≤ν)∣ ≤ ( 1 N N ∑ i=1 ∣D(xi, yi)∣ 2 )\n0.5\n⋅ ( 1\nN\nN\n∑ i=1\n∣1r(xi,yi)≤ṽ − 1r(xi,yi)≤ν ∣ 2 )\n0.5\n, (22)\nand ( 1 N ∑ N i=1 ∣D(xi, yi)∣ 2 )\n0.5 is bounded. Also, note that\n1\nN\nN\n∑ i=1\n∣1r(xi,yi)≤ṽ − 1r(xi,yi)≤ν ∣ 2 =\n1\nN\nN\n∑ i=1 ∣1r(xi,yi)≤ṽ − 1r(xi,yi)≤ν ∣\n= (1ṽ≤ν − 1ν≤ṽ) 1\nN\nN\n∑ i=1 (1r(xi,yi)≤ṽ − 1r(xi,yi)≤ν)\nBy Proposition 4.1 of (Hong and Liu 2009), we have that w.p. 1\n(1ṽ≤ν − 1ν≤ṽ) 1\nN\nN\n∑ i=1 (1r(xi,yi)≤ṽ − 1r(xi,yi)≤ν)→ 0.\nBy the continuous mapping theorem, we thus have that w.p. 1\n( 1\nN\nN\n∑ i=1\n∣1r(xi,yi)≤ṽ − 1r(xi,yi)≤ν ∣ 2 )\n0.5\n→ 0,\ntherefore, using Eq. (22) we have that w.p. 1\n1\nN\nN ∑ i=1 D(xi, yi) (1r(xi,yi)≤ṽ − 1r(xi,yi)≤ν)→ 0. (23)\nWe now turn to the last sum in (20). by Assumption 4, h2 is bounded, and therefore 1αN ∑ N i=1 h2(xi, yi) (1r(xi,yi)≤ṽ) is bounded. It is well-known (David 1981) that the sample-quantile is a consistent estimator, thus ν − ṽ → 0, and therefore\n(ν − ṽ) 1\nαN\nN ∑ i=1 h2(xi, yi) (1r(xi,yi)≤ṽ)→ 0. (24)\nPlugging (21), (23), and (24) in (20) gives the stated result.\nC Proof of Theorem 4 We follow the notation of Section B.\nIn our analysis we use a result of (Hong and Liu 2009), which we now state. Let x1, y1, . . . ,xN , yN be N samples drawn i.i.d. from fX,Y (x, y; θ).\nTheorem 6. (Theorem 4.2 of (Hong and Liu 2009)) Let Assumption 6, and the assumptions required for Proposition 2 hold. Let\n∆̄N = 1\nαN\nN ∑ i=1 D(xi, yi) ⋅ 1r(xi,yi)≤ṽ.\nThen E [∆̄N ] − ∂∂θj Φα(R; θ) is o(N −1/2).\nIn the original theorem of (Hong and Liu 2009), D is defined differently, corresponding to the perturbation analysis type gradient estimator. However, the proof of the theorem follows through also with our definition of D, and using Proposition 2.\nWe are now ready to prove Theorem 4.\nProof. From Eq. (20) we have\nE [∆j;N ] − ∂\n∂θj Φα(R; θ) =E [\n1\nαN\nN ∑ i=1 D(xi, yi) ⋅ 1r(xi,yi)≤ṽ]\n+E [(ν − ṽ) 1\nαN\nN ∑ i=1 h2(xi, yi) (1r(xi,yi)≤ṽ)] .\n(25)\nThe first term in the r.h.s. of Eq. (25) is o(N−1/2) by Theorem 6. We now bound the second term. Let h̄2 denote a bound on h2, which, by Assumption 4, is finite. Note that we have ∣ 1N ∑ N i=1 h2(xi, yi) (1r(xi,yi)≤ṽ)∣ ≤ h̄2 with probability 1. Therefore,\nE [(ν − ṽ) 1\nαN\nN ∑ i=1 h2(xi, yi) (1r(xi,yi)≤ṽ)] ≤ E [∣ν − ṽ∣ ∣ 1 αN N ∑ i=1 h2(xi, yi) (1r(xi,yi)≤ṽ)∣] ≤ h̄2 α E [∣ν − ṽ∣] .\nWe will show that E [∣ν − ṽ∣] is O(N−1/2). It is well-known (David 1981) that the empirical α−quantile may be written as follows:\nṽ = ν − F̂R(ν) − α\nfR(ν) + R̃, (26)\nwhere F̂R(⋅) is the empirical C.D.F. of R, and R̃ is O(N−1/2) in probability. Thus, we have\nE [∣ν − ṽ∣] ≤ fR(ν)−1 (E [∣F̂R(ν) − α∣] +E [∣R̃∣]) . (27)\nNote that since R is bounded, ṽ is also bounded, and it is clear from Eq. (26) that R̃ is bounded, and therefore uniformly integrable. Since R̃ is also O(N−1/2) in probability, we conclude that E [∣R̃∣] is O(N−1/2). Let yi ≐ 1r(xi,yi)≤ν . Then by definition, the empirical C.D.F. satisfies\nF̂R(ν) = 1\nN\nN ∑ i=1 yi,\nand the yi’s are i.i.d., and satisfy E[yi] = α, and Var[yi] = α(1 − α). Observe that\n0 ≤ Var [∣F̂R(ν) − α∣] = E [∣F̂R(ν) − α∣ 2 ] − (E [∣F̂R(ν) − α∣]) 2 ,\ntherefore\nE [∣F̂R(ν) − α∣] ≤ √ E [∣F̂R(ν) − α∣ 2 ],\nbut\nE [∣F̂R(ν) − α∣ 2 ] = Var [F̂R(ν)] =\nα(1 − α)\nN ,\ntherefore E [∣F̂R(ν) − α∣] is O(N−1/2). From Eq. (27) we thus have that E [∣ν − ṽ∣] is O(N−1/2), which completes the proof.\nD Example: the Importance of the VaR Baseline in GCVaR Here we show that the subtraction of the VaR baseline from the reward in GCVaR (Eq. (6)) is crucial, and without it the error in the gradient estimate may be arbitrarily large.\nConsider the following example, in the setting of proposition 1: Z ∼ Normal(θ,1), and α = 0.5. The true CVaR gradient is constant:\n∂\n∂θj Φα(Z;θ) = Eθ [\n∂logfZ(Z; θ)\n∂θj (Z − να(Z; θ))∣Z ≤να(Z;θ)] = 1,\nwhile the term due to the baseline is\nEθ [ ∂logfZ(Z; θ)\n∂θj (−να(Z; θ))∣Z ≤να(Z;θ)] = −\n√ 2\nπ θ,\nwhich is unbounded in θ. Thus, we have that Eθ [∂logfZ(Z;θ)\n∂θj (Z)∣Z ≤να(Z;θ)] = 1 + √ 2 π θ, meaning that a naive estimator without the baseline may\nhave an arbitrarily large error, and, for θ < − √ π 2 , would even point in the opposite direction!\nE Importance Sampling For very low quantiles, i.e., α close to 0, the estimator GCVaR of Eq. (6) would have a high variance, since the averaging is effectively only over αN samples. In order to mitigate this problem, we now propose an importance sampling procedure for estimating ∂\n∂θj Φα(R; θ).\nImportance sampling (IS; (Rubinstein and Kroese 2011)) is a general procedure for reducing the variance of Monte–Carlo (MC) estimates. We first describe it in a general context, and then give the specific implementation for the CVaR sensitivity estimator."
    }, {
      "heading" : "E.1 Background",
      "text" : "Consider the following general problem. We wish to estimate the expectation l = E [H(X)] where X is a random variable with P.D.F. f(x), and H(x) is some function. The MC solution is given by l̂ = 1\nN ∑ N i=1H(xi), where xi ∼ f are drawn i.i.d.\nThe IS method aims to reduce the variance of the MC estimator by using a different sampling distribution for the samples xi. Assume we are given a sampling distribution g(x), and that g dominates f in the sense that g(x) = 0⇒ f(x) = 0. We let Ef and Eg denote expectations w.r.t. f and g, respectively. Observe that l = Ef [H(X)] = Eg [H(X) f(X)g(X) ] ,and we thus define the IS estimator l̂IS as\nl̂IS = 1\nN\nN ∑ i=1 H(xi) f(xi) g(xi) , (28)\nwhere the xi’s are drawn i.i.d., and now xi ∼ g. Obviously, selecting an appropriate g such that l̂IS indeed has a lower variance than l̂ is the heart of the problem. One approach is by the variance minimization method (Rubinstein and Kroese 2011). Here, we are given a family of distributions g(x;ω) parameterized by ω, and we aim to find an ω that minimizes the variance V (ω) = Varxi∼g(⋅;ω) (l̂IS). A straightforward calculation shows that V (ω) = Ef [H(X)2 f(X) g(X;ω)] − l 2, and since l does not depend on ω, we are left with the optimization problem minω Ef [H(X)2 f(X)g(X;ω)] , which is typically solved approximately, by solving the sampled average approximation (SAA)\nmin ω\n1\nNSAA\nNSAA\n∑ i=1\n[H(xi) 2 f(xi)\ng(xi;ω) ] , (29)\nwhere xi ∼ f are i.i.d. Numerically, the SAA may be solved using (deterministic) gradient descent, by noting that ∂∂ω ( f(xi) g(xi;ω)) = − f(xi) g(xi;ω) ∂ ∂ω log g(xi;ω).\nThus, in order to find an IS distribution g from a family of distributions g(x;ω), we draw NSAA samples from the original distribution f , and solve the SAA (29) to obtain the optimal ω. We now describe how this procedure is applied for estimating the CVaR sensitivity ∂\n∂θj Φα(R; θ).\nE.2 IS Estimate for CVaR Sensitivity We recall the setting of Proposition 2, and assume that in addition to fX,Y (x, y; θ) we have access to a family of distributions gX,Y (x, y; θ,ω) parameterized by ω. We follow the procedure outlined above and, using Proposition 2, set\nHj(X, Y ) = 1 α ( ∂log fY (Y ; θ) ∂θj + ∂log fX∣Y (X∣Y ; θ) ∂θj )(R − να(R; θ))1R≤να(R;θ).\nHowever, since να(R; θ) is not known in advance, we need a procedure for estimating it in order to plug it into Eq. (28). The empirical quantile ṽ of Eq. (5) is not suitable since it uses samples from fX,Y (x, y; θ). Thus, we require an IS estimator for να(R; θ) as well. Such was proposed by Glynn (1996). Let F̂IS(z) denote the IS empirical C.D.F. of R: F̂IS(z) ≐ 1 N ∑ N i=1 fX,Y (xi,yi;θ) gX,Y (xi,yi;θ,ω)1r(xi,yi)≤z. Then, the IS empirical VaR is given by\nṽIS = inf z F̂IS(z) ≥ α. (30)\nWe also need to modify the variance minimization method, as we are not estimating a scalar function but a gradient in Rk. We assume independence between the elements, and replace H(xi)2 in Eq. (29) with ∑kj=1Hj(xi)\n2. Let us now state the estimation procedure explicitly. We first drawNSAA i.i.d. samples from fX,Y (x, y; θ), and find a suitable\nω by solving the following equivalent of (29)\nmin ω\n1\nNSAA\nNSAA\n∑ i=1 ⎡ ⎢ ⎢ ⎢ ⎣ k ∑ j=1 Hj(xi, yi) 2 fX,Y (xi, yi; θ) gX,Y (xi, yi; θ,ω) ⎤ ⎥ ⎥ ⎥ ⎦ , (31)\nwith Hj(X, Y ) = 1α ( ∂log fY (Y ;θ) ∂θj + ∂log fX∣Y (X∣Y ;θ) ∂θj ) (r(X, Y ) − ṽ)1r(X,Y )≤ṽ , where ṽ is given in (5).\nWe then run the IS GCVaR algorithm, as follows. We draw N i.i.d. samples x1, y1, . . . ,xN , yN from gX,Y (x, y; θ,ω). The IS estimate of the CVaR gradient ∆ISj;N is given by\n∆ISj;N = 1\nαN\nN\n∑ i=1\n( ∂log fY (yi; θ) ∂θj + ∂log fX∣Y (xi∣yi; θ) ∂θj ) fX,Y (xi, yi; θ)(r(xi, yi) − ṽIS)1r(xi,yi)≤ṽIS gX,Y (xi, yi; θ,ω) , (32)\nwhere ṽIS is given in (30).\nAlgorithm 2 IS GCVaR"
    }, {
      "heading" : "1: Given:",
      "text" : "• CVaR level α • A reward function r(x, y) ∶ Rn⊗Y → R→ R • A density function fX,Y (x, y; θ) • A density function gX,Y (x, y; θ) • A sequence x1, y1, . . . ,xN , yN ∼ gX,Y , i.i.d. 2: Set xs1, y s 1 . . . ,x s N , y s N = Sort (x1, y1, . . . ,xN , yN) by r(x, y) 3: For i = 1, . . . ,N do\nL(i) = i\n∑ j=1\nfX,Y (x s j , y s j ; θ) /gX,Y (x s j , y s j ; θ)\n4: Set l = arg miniL(i) ≥ α 5: Set ṽIS = r(xsl , y s l ) 6: For j = 1, . . . , k do\n∆ISj;N = 1\nαN\nN\n∑ i=1\n( ∂log fY (yi; θ) ∂θj + ∂log fX∣Y (xi∣yi; θ) ∂θj ) fX,Y (xi, yi; θ)(r(xi, yi) − ṽIS)1r(xi,yi)≤ṽIS gX,Y (xi, yi; θ) ,\n7: Return:∆IS1;N , . . . ,∆ IS k;N\nNote that in our SAA program for finding ω, we estimate να using crude Monte Carlo. In principle, IS may also be used for that estimate as well, with an additional optimization process for finding a suitable sampling distribution. However, a typical application of the CVaR gradient is in optimization of θ by stochastic gradient descent. There, one only needs to update ω intermittently, therefore a large sample size NSAA is affordable and IS is not needed.\nSo far, we have not discussed how the parameterized distribution family gX,Y (x, y; θ,ω) is obtained. While there are some standard approaches such as exponential tilting (Rubinstein and Kroese 2011), this task typically requires some domain knowledge. For the RL domain, we present a heuristic method for selecting gX,Y (x, y; θ,ω)."
    }, {
      "heading" : "E.3 CVaR Policy Gradient with Importance Sampling",
      "text" : "As explained earlier, when dealing with small values of α, an IS scheme may help reduce the variance of the CVaR gradient estimator. In this section, we apply the IS estimator to the RL domain. As is typical in IS, the main difficulty is finding a suitable sampling distribution, and actually sampling from it. In RL, a natural method for modifying the trajectory distribution is by modifying the MDP transition probabilities. We note, however, that by such our method actually requires access to a simulator of this modified MDP. In many applications a simulator of the original system is available anyway, thus modifying it should not be a problem.\nConsider the RL setting of Section 5, and denote the original MDP by M . The P.D.F. of a trajectory {X,Y } from the MDP M , where, as defined in the main text Y ≐ s0, a0, s1, a1, . . . , sτ ,X ≐ ρ0, ρ1, . . . , ρτ−1 is given by\nfX,Y (x, y; θ) = ζ0(s0) τ−1 ∏ t=0 fa∣s(at∣st; θ)fρ∣s,a(ρ∣st, at)fs′∣s,a(st+1∣st, at).\nConsider now an MDP M̂ that is similar to the original MDP M but with transition probabilities f̂s′∣s,a(s′∣s, a;ω), where ω is some controllable parameter. We will later specify f̂s′∣s,a(s′∣s, a;ω) explicitly, but for now, observe that the P.D.F. of a trajectory {X,Y } from the MDP M̂ is given by\ngX,Y (x, y; θ,ω) = ζ0(s0) τ−1 ∏ t=0 fa∣s(at∣st; θ)fρ∣s,a(ρ∣st, at)f̂s′∣s,a(st+1∣st, at;ω).\nand therefore fX,Y (x, y; θ)\ngX,Y (x, y; θ,ω) = τ−1 ∏ t=0 fs′∣s,a(st+1∣st, at) f̂s′∣s,a(st+1∣st, at;ω) . (33)\nUsing Eq. (10), Eq. (33), and the fact that ∂ log fX∣Y (xi∣yi; θ)/∂θ=0 in our formulation, the IS GCVaR algorithm may be used to obtain the IS estimated gradient ∆ISj;N , which may then be used instead of ∆j;N in the parameter update equation (8).\nWe now turn to the problem of choosing the transition probabilities f̂s′∣s,a(s′∣s, a;ω) in the MDP M̂ , and propose a heuristic approach that is suitable for the RL domain. We first observe that by definition, the CVaR takes into account only the ‘worst’ trajectories for a given policy, therefore a suitable IS distribution should give more weight to such bad outcomes in some sense. The difficulty is how to modify the transition probabilities, which are defined per state, such that the whole trajectory will be ‘bad’. We note that this difficulty is in a sense opposite to the action selection problem: how to choose an action at each state such that the long-term reward is high. Action selection is a fundamental task in RL, and has a very elegant solution, which inspires our IS approach.\nA standard approach to action selection is through the value-function V (s) (Sutton and Barto 1998), which assigns to each state s its expected long term outcome E [B∣s0 = s] under the current policy. Once the value function is known, the ‘greedy selection’ rule selects the action that maximizes the expected value of the next state. The intuition behind this rule is that since V (s) captures the long-term return from s, states with higher values lead to better trajectories, and should be preferred. By a similar reasoning, we expect that encouraging transitions to low-valued states will produce worse trajectories. We thus propose the following heuristic for the transition probabilities f̂s′∣s,a(s′∣s, a;ω). Assume that we have access to an approximate value function Ṽ (s) for each state. We propose the following IS transitions for M̂\nf̂s′∣s,a(s ′ ∣s, a;ω) =\nfs′∣s,a(s ′∣s, a) exp (−ωṼ (s′; θ))\n∑y fs′∣s,a(y∣s, a) exp (−ωṼ (y; θ)) . (34)\nNote that increasing ω encourages transitions to low value states, thus increasing the probability of ‘bad’ trajectories. Obtaining an approximate value function for a given policy has been studied extensively in RL literature, and many efficient solutions for this task are known, such as LSTD (Boyan 2002) and TD(λ) (Sutton and Barto 1998). Here, we don’t restrict ourselves to a specific method."
    }, {
      "heading" : "E.4 Empirical Results with Importance Sampling",
      "text" : "We report the full details about the experimental results with importance sampling mentioned in the main text.\nFig. 2 demonstrates the importance of IS in optimizing the CVaR when α is small. We chose α = 0.01, and N = 200, and compared the naive GCVaR against IS GCVaR. As our value function approximation, we exploited the fact that the soft-max policy uses φ(s, a) ⊺ θ as a sort of state-action value function, and therefore set Ṽ (s) = maxa φ(s, a) ⊺\nθ. We chose ω using SAA, with trajectories from the initial policy θ0. We observe that IS GCVaR converges significantly faster than GCVaR, due to the lower variance in gradient estimation."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2014,
    "abstractText" : "Conditional Value at Risk (CVaR) is a prominent risk measure that is being used extensively in various domains. We develop a new formula for the gradient of the CVaR in the form of a conditional expectation. Based on this formula, we propose a novel sampling-based estimator for the gradient of the CVaR, in the spirit of the likelihood-ratio method. We analyze the bias of the estimator, and prove the convergence of a corresponding stochastic gradient descent algorithm to a local CVaR optimum. Our method allows to consider CVaR optimization in new domains. As an example, we consider a reinforcement learning application, and learn a risksensitive controller for the game of Tetris.",
    "creator" : "LaTeX with hyperref package"
  }
}