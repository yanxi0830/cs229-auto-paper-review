{
  "name" : "1306.0514.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Riemannian metrics for neural networks II: recurrent networks and learning symbolic data sequences",
    "authors" : [ "Yann Ollivier" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n30 6.\n05 14\nv4 [\ncs .N\nE ]\n3 F\neb 2\nHere we introduce a training procedure using a gradient ascent in a Riemannian metric: this produces an algorithm independent from design choices such as the encoding of parameters and unit activities. This metric gradient ascent is designed to have an algorithmic cost close to backpropagation through time for sparsely connected networks.\nWe use this procedure on gated leaky neural networks (GLNNs), a variant of recurrent neural networks with an architecture inspired by finite automata and an evolution equation inspired by continuous-time networks.\nGLNNs trained with a Riemannian gradient are demonstrated to effectively capture a variety of structures in synthetic problems: basic block nesting as in context-free grammars (an important feature of natural languages, but difficult to learn), intersections of multiple independent Markov-type relations, or long-distance relationships such as the distant-XOR problem.\nThis method does not require adjusting the network structure or initial parameters: the network used is a sparse random graph and the initialization is identical for all problems considered.\nThe problem considered here is to learn a probabilistic model for an observed sequence of symbols (x0, . . . , xt, . . .) over a finite alphabet A. Such a model can be used for prediction, compression, or generalization.\nHidden Markov models (HMMs) are frequently used in such a setting. However, the kind of algorithmic structures HMMs can represent is limited because of the underlying finite automaton structure. Examples of simple sequential data that cannot be, or cannot conveniently be, represented by HMMs are discussed below; for instance, subsequence insertions, or intersections of multiple independent constraints.\nRecurrent neural networks (RNNs) are an alternative with higher modelling power. However, their training comes with its own limitations; in particular, picking long-distance dependencies remains problematic [BSF94, HS97, Jae02]. Techniques to deal with this problem include long short-term memory (LSTM) networks [HS97] or echo state networks (ESN) [Jae02].\nHere we use a new training procedure which realizes a gradient ascent using a suitable Riemannian metric, instead of backpropagation, at a small computational cost. Moreover, we use gated leaky neural networks (GLNNs), a variation on the RNN architecture. More precisely:\n• Rather than standard backpropagation through time, for training the model we use a gradient inspired by Riemannian geometry, using metrics for neural networks as introduced in [Oll13], adapted to a recurrent context. This makes learning less sensitive to arbitrary design choices, and provides a substantial improvement in learning speed and quality. An important point is doing so while keeping a scalable algorithm. Here the asymptotic algorithmic complexity is identical to backpropagation through time for sparsely connected networks.\n• In GLNNs, at each time in the production of a sequence of symbols, the neural network weights depend on the symbol last produced (“gated” units). This is inspired by finite automata in which the next state depends both on the current state and the currently produced symbol, and allows for an easy representation of automaton-like structures. Such “gated” models have already been used, e.g., in [SMH11], and arguably the LSTM architecture.\n• The dynamics of GLNNs is modified in a way inspired by continuoustime (or “leaky”) neural networks: the connection weights between the units control the variation of the activation levels, rather than directly setting the activation levels at the next step. This provides an integrating effect and is efficient, for instance, at modelling some hierarchical, context-free-grammar–like structures in which an internal state must be held constant while something else is happening.\nMuch of this text is devoted to the derivation of Riemannian metrics for recurrent networks. Indeed, we believe the use of a proper gradient is a major ingredient for an effective learning procedure. The standard gradient ascent update over a parameter θ can be seen as a way to increase the value of a function f(θ) while changing as least as possible the numerical value θ:\nθ′ = θ + η ∂f\n∂θ ⇒ θ′ ≈ argmax\nθ′\n{\nf(θ′)− 1 2η ∥ ∥θ − θ′ ∥ ∥\n2 }\n(1)\nfor small enough learning rates η (where ≈ means “up to O(η2) when η → 0”). The norm ‖θ − θ′‖ depends on how the parameters are cast as a set of\nreal numbers. If, instead, one uses a measure of distance between θ and θ′ depending on what the network does, rather than how the numbers in θ and θ′ differ, the penalty for moving θ in different directions becomes different and hopefully yields better learning. One possible benefit, for instance, is self-adaptation of the cost of moving θ in certain directions, depending on the current behavior of the network. Another benefit is invariance of the learning procedure from a number of designing choices, such as using a logistic or tanh activation function, or scaling the values of parameters (choices which affect the conventional gradient ascent).\nThe primary example of an invariant gradient ascent is Amari’s natural gradient, which amounts to replacing ‖θ − θ′‖2 with the Kullback–Leibler divergence KL(Prθ || Prθ′) between the distributions defined by the network (seen as a probabilistic model of the data). However, the natural gradient comes at a great algorithmic cost. “Hessian-free” techniques [Mar10, MS11, MS12] allow to approximate it to some extent and have yielded good results, but are still quite computationally expensive.\nHere we build two metrics for recurrent neural networks having some of the key properties of the natural gradient, but at a computational cost closer to that of backpropagation through time. The resulting algorithm is first presented in Section 2 in its final form. The algorithm might look arbitrary at first sight, but is theoretically well-grounded; in Sections 3.1–3.5 we derive it step by step from the principles in [Oll13] adapted to a recurrent setting.\nThis construction builds on the Riemannian geometry framework for neural networks from [Oll13]. The activities of units in the network are assumed to belong to a manifold: intuitively, they represent “abstract quantities” representable by numbers, but no preferred correspondence with R is fixed. This forces us to write only invariant algorithms which do not depend on the chosen numerical representation of the activities. Such algorithms are more impervious to design choices (e.g., changing the activation function from logistic to tanh has no effect); as a consequence, if they work well on one problem, they will tend to work well on rewritings of the same problem using different numerical representations. Thus, such algorithms are more “agnostic” as to physical meaning of the activities of the units (activation levels, activation frequencies, log-frequencies, ...).\nRemark 1. The three changes introduced above with respect to standard RNNs are independent and can be used separately. For instance, the metrics can be used for any network architecture.\nRemark 2. The approach is not specific to symbolic sequences: instead of transition parameters τijxt depending on the latest symbol xt, one can use transition weights which depend on the components of the latest input vector xt.\nRemark 3. The gradient update proposed is independent of the training example management scheme (batch, online, small batches, stochastic gradient. . . ).\nRemark 4. The algorithm presented here is quadratic in network connectivity (number of connections per unit), and we have used it with very sparse networks (as few as 3 connections per unit), which apparently perform well. For non-sparse networks, a version with complexity linear in the number of connections, but with fewer invariance properties, is presented at the end of Section 2.\nExamples. Let us present a few examples of data that we have found can be efficiently learned by GLNNs. Other techniques that have been used to deal with such sequences include long short-term memory (LSTM) networks [HS97] (see for instance [Gra13] for a recent application using stacked LSTMs for text modelling) and echo state networks (ESN) [Jae02]. Here we do not have to engineer a particular network structure or to have prior knowledge of the scale of time correlations for initialization: in our experiments the network is a sparse random graph and parameter initialization is the same for all problems.\nExample 1 illustrates a type of operation frequent in natural languages (and artificial programming languages): in the course of a sequence, a subsequence is inserted, then the main sequence resumes back exactly where it was interrupted. This kind of structure is impossible to represent within a Markovian model, and is usually modelled with context-free grammars (the learning of which is still problematic).\nIn this example, the main sequence is the Latin alphabet. Sometimes a subsequence is inserted which spells out the digits from 0 to 9. In this subsequence, sometimes a subsubsequence is inserted containing nine random (to prevent rote learning) capital letters (Example 1).\nabcdefghijklmnopqrs(01[HSATXUEUZ]2[OYNFIWWOR]345[ZYMBOMYBZ]6789)tuvwxyz\nabcde(01234567[FFRLCMKVI]89)fghijklmnopqrstuvwxyz\n...\nExample 1: Inserting subsequences, a simple context-free grammar.\nHere the difficulty, both for HMMs and recurrent neural networks trained by ordinary backpropagation through time, is in starting again at the right point after the interruption caused by the subsequence.\nExample 2 is a pathological synthetic problem traditionally considered among the hardest for recurrent neural networks (although it can be represented by a simple finite automaton): the distant XOR problem. In a random binary sequence, two positions are marked at random (here with the symbol X), and the binary symbol at the end of each line is the logical\nXOR of the two random bits following the X marks. Use of the XOR function prevents detecting a correlation between the XOR result and any one of the two arguments.\n1 1 1 0 0X1 1X1 1 1 1 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1=0\n0X1X0 1 1 0 1 0 1 1 1 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0=1\n...\nExample 2: Long-distance XOR.\nOn this example, apparently the best performance for RNNs is obtained in [MS11]: with 100 random bits on each line, the failure rate is about 75%, where “failure” means that a run examines more than 50 million examples before reaching an error rate below 1% [MS11, legend of Figure 3].\nExample 3 is synthetic music notation (here in LilyPond format1), meant to illustrate the intersection of several independent constraints. Successive musical bars are separated by a | symbol. Each bar is a succession of notes separated by spaces, where each note is made of a pitch (a, b, c, ...) and value (4 for a quarter note, 2 for a half note, 4. for a dotted quarter note, etc.). In each bar, a hidden variable with three possible values determines a harmony which restricts the possible pitches used in this bar. Harmonies in successive bars follow a specific deterministic pattern. Additionally, in each bar, the successive durations are taken from a finite set of possibilities (rhythms commonly encountered in waltzes). Rhythm is chosen independently from pitch and harmony. The resulting probability distribution is the intersection of all these constraints.\nc2 c4 | f4. a8 c4 | g4 b4 g8 d8 | g4. g8 g4 | e4 c4 c4 | ...\nExample 3: Synthetic music.\nThis example can be represented as a Markov chain, but only using a huge state space. The “correct” representation of the constraints is more compact, which allows for efficient learning, whereas a Markov representation would essentially need to see every possible combination of rhythm and pitches to learn the underlying structure.\nExample 4 is the textbook example of sequences that cannot be represented by a finite automaton (thus also excluding an HMM): sequences of the form anbn. The sequence alternates blocks of random length containing only a’s and only b’s, with the constraint that the length of a b-block is equal to the length of the a-block preceding it. The blocks are separated with newlines.\nSeen as a temporal sequence, this exhibits long-term dependencies, especially if the block lengths used in the training sequence are long. GLNNs\n1http://lilypond.org/\naaaaaaa\nbbbbbbb\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\naaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbbbbbbbbbbbbbbbb\n...\nExample 4: anbn\nare found to be able to learn this model within minutes with a training set of as few as 10 examples with the block lengths ranging in the thousands.\nExperiments for each of these examples are given in Section 4, both for GLNNs and more traditional RNNs: a GLNN or RNN network is trained on a single (long) training sequence2 and evaluated on an independent validation sequence, for a given computation time. More experiments attempt to isolate the respective contributions of the three changes introduced (leakiness, gatedness, and Riemannian training). Hidden Markov models, LSTMs, and classical text compression methods are included as a baseline.\nThe code for these experiments can be downloaded at http://www.yann-ollivier.org/rech/code/"
    }, {
      "heading" : "1 Definition of the models",
      "text" : ""
    }, {
      "heading" : "1.1 Generative models for sequential data",
      "text" : "A generative model for symbolic sequences is a model which produces an infinite random sequence of symbols (x0, . . . , xt, . . .) over a finite alphabet A. The model depends on a set of internal parameters θ: each θ defines a probability distribution Prθ((xt)t=0,1,...) over the set of infinite sequences. Given an actual training sequence (xt), the goal of learning is to find the value of θ that maximizes the probability of the training sequence (xt):\nθ = argmax θ Prθ((xt)t=0,1,...) = argmax θ log Prθ((xt)t=0,1,...) (2)\n= argmax θ\n∑\nt\nlog Prθ(xt|x0x1 . . . xt−1) (3)\nwhere the latter sum can usually be computed step by step. This value of θ is then used for prediction of future observations, generation of new similar sequences, or compression of the training sequence.\n2We chose a single long training sequence rather than several short sequences, first, to avoid giving the algorithms a hint about the time scales at play; second, because in some of the problems presented here, there are no marked cuts (music example), or finding the relevant cuts is part of the game (anbn example); third, because having several training sequences is not always relevant, e.g., if there is a single temporal stream of data.\nThe generative models considered here work in an iterative way. At each time step t, the system has an internal state. This internal state is used to compute a probability distribution πt over the alphabet. The symbol xt printed at time t is drawn from this distribution πt. Then the new internal state as time t+1 is a deterministic or random function of the internal state at time t together with the symbol xt just printed.\nComputing the probability of an actual training sequence (xt) can be done iteratively, by computing the probability π0 assigned by the model to the first symbol x0, then revealing the actual value of x0, using this x0 to compute the internal state at time 1, which is used to compute the probabilistic distribution of x1, etc. (forward pass).\nIn a variant of the problem, only some of the symbols in the sequence (xt) have to be predicted, while the others are given “for free”. For instance, in a classification task the sequence (xt) might be of the form y0z0y1z1y2z2 . . . where for each instance yi we have to predict the corresponding label zi. In this case the problem is to find the θ maximizing the probability of those symbols to be predicted:\nθ = argmax θ\n∑\nt\nχt log Prθ(xt|x0x1 . . . xt−1) (4)\nwhere\nχt =\n{\n1 if xt is to be predicted, 0 otherwise. (5)"
    }, {
      "heading" : "1.2 Recurrent neural network models",
      "text" : "We now present the recurrent network models discussed in this work. These include ordinary recurrent neural networks (RNNs), gated neural networks (GNNs), and leaky GNNs (GLNNs).\nNeural network–based models use a finite oriented graph N , the network, over a set of units. The internal state is a real-valued function over N (the activities), and edges in the graph indicate which units of the network at time t contribute to the computation of the state of units at time t+ 1.\nAt each time step t, each unit i in the network N has an activation level ati ∈ R. As is usual for neural networks, we include a special, alwaysactivated unit i = 0 with at0 ≡ 1, used to represent the so-called “biases”. The activation levels at time t are used to compute the output of the network at time t and the activation levels at time t + 1. This transition function is different for RNNs, GNNs, and GLNNs, as defined below (Sections 1.2.1– 1.2.3).\nFor the output of the network we always use the softmax function: each unit i ∈ N (including i = 0) has time-independent writing weights wix for each symbol x in the alphabet A. At each time, the network outputs a\nrandom symbol x ∈ A with probabilities given by the exponential of the writing weights weighted by the activation levels at that time:\nπt(x) := e ∑ i at i wix\n∑ y∈A e ∑ i at i wiy\n(6)\nwhere πt(x) is the probability to print x ∈ A. This allows any active unit to sway the result by using a large enough weight. One effect of this “nonlinear voting” is to easily represent intersections of constraints: If an active unit puts high weight on a subset of the alphabet, and another active unit puts high weight on another subset of the alphabet, only the symbols in the intersection of these subsets will have high probability.\nThus, given the activities (ati)i∈N at time t, the network prints a random symbol xt drawn from πt. Then the network uses its current state and its own output xt to compute the activities at time t + 1: the (a t+1 i ) are a deterministic function of both the (ati)i∈N and xt. Given the writing weights wix, the model-specific transition function (depending on model-specific transition parameters τ), and the initial activation levels a0i , the model produces a random sequence of symbols x0, x1, . . . , xt, . . .. Given a training sequence (xt), the goal of training is to find parameters wix, τ and a0i maximizing the probability to print (xt):\nPr((xt)t=0,...,T−1) = T−1 ∏\nt=0\nπt(xt) (7)\nThe parameters θ = (w, τ, a0) can be trained by gradient ascent θ ← θ+ η ∂ log Pr(x)\n∂θ . The gradient of the (log-)probability to print (xt) with respect to\nthe parameters can be computed by the standard backpropagation through time technique [RHW87, Jae02]. Appendix B describes backpropagation through time for the GLNN model (Proposition 11).\nHowever, here we will use gradient ascents in suitable, non-trivial metrics ‖θ − θ′‖ given by a symmetric, positive-definite matrix M(θ). The corresponding gradient ascent will take the form θ ← θ + ηM(θ)−1 ∂ log Pr(x)\n∂θ\n(see Section 3.1). These metrics are built in Sections 3.3–3.5 to achieve reparametrization invariance at a reasonable computational cost, based on ideas from [Oll13].\nWe first give the full specification for the three neural network models used."
    }, {
      "heading" : "1.2.1 Recurrent Neural Networks",
      "text" : "In this article we use the following transition function to compute the RNN activation levels at step t+ 1 (see for instance [Jae02]):\nV t+1j := ρjxt + ∑\ni\nτija t i (8)\nat+1j := s(V t+1 j ), (9)\nwhere s is a fixed activation function, xt ∈ A is the symbol printed at time t, and the sum runs over all edges ij in the network. The sum also includes the always-activated unit i = 0 to represent “biases”3.\nThe parameters to be trained are the input parameters ρjxt and the transition parameters τij. The parameter ρixt can equivalently be thought of as a connection weight from an input unit activated when reading xt.\nTwo standard choices for the activation function are the logistic function s(V ) := eV /(1 + eV ) = 1/(1 + e−V ) and the hyperbolic tangent s(V ) := tanh(V ). Actually the two are related: one is obtained from the other by an affine transform of V and a. Traditional learning procedures would yield different results for these two choices. With the training procedures below using an invariant metric, using the tanh function instead of the logistic function would result in the same learning trajectory so that this choice is indifferent. To fix ideas, the experiments were implemented using tanh."
    }, {
      "heading" : "1.2.2 Gated Neural Networks",
      "text" : "GNNs are an extension of recurrent neural networks, in which the neural network transition function governing the new activations depends on the last symbol written. This is inspired by finite automata. Such models have also been used in [SMH11], the main difference being the non-linear softmax function (6) we use for the output.\nIn GNNs the activation levels at step t+ 1 are given by\nV t+1j := ∑\ni\nati τijxt (10)\nat+1j := s(V t+1 j ), (11)\nwhere s is the same activation function as in RNNs. The sum includes the always-activated unit i = 0.\nIn the above, xt ∈ A is the symbol printed at step t, and the parameters τijx are the transition weights from unit i to unit j given context x ∈ A: contrary to RNNs, τijx depends on the current signal x. This amounts\n3Biases are actually redundant in this case: the bias τ0i at unit i has the same effect as adding τ0i to all the input weights ρix for all symbols x, since at any time, one and exactly one symbol is active. Still, since backpropagation is not parametrization-invariant, using or not using these biases has an effect on learning.\nto having an RNN with different parameters τ for each symbol x in the alphabet. (This is not specific to discrete-valued sequences here: a continuous vector-valued signal xt with components x k t could trigger the use of ∑\nk x k t τijk as transition coefficients at time t.)\nHidden Markov models are GNNs with linear activation function [Bri90]: if we set s(V ) := V and if τijx is set to (HMM probability that unit i prints symbol x)× (HMM transition probability from i to j), then the GNN transition (10) yields the update equation for the HMM forward probabilities4. If, in addition, we\nreplace the softmax output (6) with a linear output πt(x) :=\n∑\ni at i wix\n∑\ni at i\nwhere\nwix is the HMM probability to write x in state i, then the GNN model exactly reduces to the HMM model.5\nGNNs have more parameters than standard recurrent networks, because each edge carries a parameter for each letter in the alphabet. This can be a problem for very large alphabets (e.g., when each symbol represents a word of a natural language): even storing the parameters can become costly. This is discussed in [SMH11], where a factorization technique is applied to alleviate this problem."
    }, {
      "heading" : "1.2.3 Gated Leaky Neural Networks",
      "text" : "Gated leaky neural networks are a variation over GNNs which allow for better handling of some distant temporal dependencies. They are better understood by a detour through continuous-time models. In GNNs we have V t+1j = ∑ i τijxta t i. One possible way to define a continuous-time analogue is to set dV tj dt = ∑\ni\nτijxta t i (12)\nand set atj = s(V t j ) as before. See [Jae02] for “continuous-time” or “leaky” neural networks. This produces an “integration effect”: units become activated when a certain signal xt occurs, and stay activated until another event occurs. Importantly, the transition coefficient τiixt from i to i itself provides a feedback control. For this reason, in our applications, loops i → i are always included in the graph of the network.\nHere, contrary to the models in [Jae02], the differential equation is written over V which results in a slightly different equation for the activity a.6\n4More precisely ati becomes the probability to have emitted y0, . . . , yt−1 and be in state i at time t, i.e., the HMM probabilities right before emitting xt but after the t − 1 → t state transition.\n5Conversely, any system of the form at+1 = F (at, xt) and law(xt+1) = G(a t+1), can be viewed as a Markov process on the infinite continuous space in which (at, xt) take values. 6Making V rather than a the leaky variable comes from looking for the simplest possible nonlinear dynamics in the context of differential geometry for neural networks [Oll13]. In full generality, if the activity unit j is a point aj in a manifold Aj , the continuous-time\nGated leaky neural networks are obtained by the obvious time discretization of this evolution equation. This is summed up in the following definition.\nDefinition 5. A gated leaky neural network (GLNN) is a network as above, subjected to the evolution equation\nV t+1j := V t j +\n∑\ni\nτijxta t i, a t j := s(V t j ) (13)\n(where the sum includes the always-activated unit i = 0). The probability to output symbol x at time t is given by\nπt(x) := e ∑ i at i wix\n∑ y∈A e ∑ i at i wiy\n(14)\nAppendix A provides a further discussion of the integrating effect by studying the linearized regime. This is useful to gain an intuition into GLNN behavior and to obtain a sensible parameter initialization."
    }, {
      "heading" : "2 An algorithm for GLNN training",
      "text" : "In Section 3 we expose theoretical principles along which to build Riemannian algorithms for RNN, GNN and GLNN training. For convenience, we first collect here the explicit form of the final algorithm obtained for GLNNs, and discuss its algorithmic cost.\nThe derivatives of the log-likelihood of the training data with respect to the writing and transition weights, can be computed using backpropagation through time adapted to GLNNs (Appendix B). These derivatives are turned into a parameter update\nθ ← θ + ηM(θ)−1 ∂ log Pr(x) ∂θ\n(15)\nthrough a suitable metric M(θ). We present two algorithmically efficient choices for M : the recurrent backpropagated metric (RBPM) and the recurrent unitwise outer product metric (RUOP metric).\ndynamics will be daj/dt = Fj((ai)i→j , xt) where Fj is a vector field on Aj depending on the activitives of units connected to j and on the current signal xt. Looking for dynamics with a simple form, it makes sense to assume that the vector-field–valued function Fj is the product of a fixed vector field F 0j times a real-valued function of the of the ai, and that the latter decomposes as a sum of the influences of individual units i, namely: Fj((ai)i→j , xt) = ( ∑\ni fi(ai, xt))F\n0 j . For one-dimensional activitives, if F 0 j does not vanish,\nthere always exists a particular chart of the manifold Aj , unique up to an affine transform, in which F 0j is constant: we call this chart Vj . Further assuming that fi(ai, xt) decomposes as a product of a function of xt and a function of ai, namely fi(ai, xt) = τi(xt)gi(ai), we can set ai := gi(ai), and we obtain the dynamics (12). Both variables V and a are thus recovered uniquely up to affine transform, respectively, as the variable that makes the time evolution uniform and the variable that makes the contribution of incoming units additive.\nFor the update of the writing weights wix, we use the quasi-diagonal reduction [Oll13, Sect. 2.3] of the Hessian or Fisher information matrix (the two coincide in this case) as the metric. Quasi-diagonal reduction is a process producing an update with algorithmic cost close to using only the diagonal of the matrix, yet has some of the reparametrization invariance properties of the full matrix. The expression for this metric on wix is worked out in Section 3.2.\nThe metricM used for updating the transition weights τijx is built in Sections 3.3–3.5. First, in Section 3.3 we build a metric on recurrent networks from any metric on feedforward networks. This involves “time-unfolding” [RHW87, Jae02] the recurrent network to view it as a feedforward network with T times as many units (T being the length of the training data), and then summing the feedforward metric over time (Definition 6). In Sections 3.4 and 3.5 we carry out this procedure explicitly for two feedforward metrics described in [Oll13]: this yields the RUOP metric and the RBPM, respectively.\nBefore starting the gradient ascent, the parameters of the network are initialized so that at startup, the activation of each unit over time is a random linear combination of the symbols xt observed in the recent past. As this latter point provides interesting insight into the behavior of GLNNs, we discuss it in Appendix A.\nAlgorithm description. Training consists in adjusting the writing weights wix, transition weights τijx, and starting values V 0 i (used by the network at t = 0), to increase the log-likelihood of the training sequence (xt)t under the model.\nThe variable χt encodes which symbols in the sequence have to be predicted: it is set to 1 if the symbol xt has to be predicted, and to 0 if xt is given. Namely, the problem to be solved is\nargmax w,τ,V 0\n∑\nt\nχt log πt(xt) (16)\nwhere πt is the probability attributed by the network to the next symbol knowing x0, . . . , xt−1.\nFor simplicity we work with a single (long) training sequence (xt)t=0,...,T−1; the algorithm can be extended in a straightforward manner to cover the case of several training examples, or mini-batches of training sequences (as in a stochastic gradient algorithm), simply by summing the gradients W , G and the metrics h̃, M̃ below over the training examples.\nThe procedure alternates between a gradient step with respect to the wix, and a gradient step with respect to the τijx and V 0 i , with two distinct learning rates ηw and ητ . We describe these two steps in turn. It is important to start with an update of wix, otherwise the metric at startup may be singular.\nIn the following expressions, all sums over units i in the network N include the always-activated unit i = 0 with at0 ≡ 1.\nGradient update for the writing weights wix. This is done according to the following steps.\n1. Forward pass: Compute the activations of the network over the training sequence (xt)t=0,...,T−1, using the GLNN evolution equations in Definition 5.\n2. Compute the partial derivatives with respect to the writing weights:\nWiy = ∑\nt\nχt a t i (1xt=y − πt(y)) (17)\n3. Compute the following terms of the Hessian (or Fisher information matrix) of the log-likelihood with respect to w, using\nhyii = εy + T−1 ∑\nt=0\nχt (a t i) 2πt(y)(1− πt(y)), i ∈ N , y ∈ A (18)\nhy0i = T−1 ∑\nt=0\nχt a t i πt(y)(1 − πt(y)), i 6= 0, y ∈ A (19)\nwhere εy is a dampening term to avoid divisions by 0. We set εy to the frequency of y in the training sequence plus the machine epsilon.\n4. Update the weights using the quasi-diagonal reduction of the inverse Hessian:\nwiy ←wiy + ηw Wiy −W0yhy0i/hy00 hyii − (h y 0i) 2/hy00 i 6= 0 (20)\nw0y ←w0y + ηw\n\n W0y hy00 − ∑\ni6=0\nhy0i hy00 Wiy −W0yhy0i/hy00 hyii − (hy0i)2/hy00\n\n (21)\n(These formulas may look surprising, but they amount to using weighted covariances over time between desired output and activity of unit i, rather than just sums over time [Oll13, Sect. 1.1]; the constant terms are transferred to the always-activated unit.)\nGradient update for the transition weights τijx. This goes as follows.\n1. Forward pass: Compute the activations of the network over the training sequence (xt)t=0,...,T−1, using the GLNN evolution equations in Definition 5.\n2. Backward pass: Compute the backpropagated values Bti for each unit i 6= 0 using\nBti = B t+1 i + s ′(V ti )\n χt ( wixt − ∑ yπt(y)wiy ) + ∑\nj\nτijxtB t+1 j\n\n (22)\ninitialized with BTj = 0. This is the derivative of data log-likelihood with respect to V ti . Here s ′ is the derivative of the activation function.\n3. Compute the following “modulus” m̃ti for each unit i 6= 0 at each time t. In the RUOP variant, simply set\nm̃ti = (B t i) 2 (23)\nIn the RBPM variant, set by induction from t+ 1 to t:\nm̃ti = s ′(V ti ) 2\n χt ( ∑ yπt(y)w 2 iy − ( ∑ yπt(y)wiy) 2 ) + ∑\nj 6=i\n(τijxt) 2 m̃t+1j\n\n\n+ (\n1 + τiixts ′(V ti ) )2 m̃t+1i\n(24)\ninitialized with m̃Ti = 0.\n4. For each unit j 6= 0, for each symbol y ∈ A, compute the following vector G\n(jy) i and matrix M̃ (jy) ii′ indexed by the units i with i → j in\nthe network N , including i, i′ = 0.\nG (jy) i =\nT−1 ∑\nt=0\n1xt=y a t i B t+1 j (25)\n(this is the derivative of the log-likelihood with respect to τijx) and\nM̃ (jy) ii′ =\nT−1 ∑\nt=0\n1xt=y a t i a t i′ m̃ t+1 j (26)\nDampen the matrix M̃ (jy) ii′ by adding ε to the diagonal (we use ε = 1 which is small compared to the T terms in the sum making up M̃).\n5. Set G(jy) ← (M̃ (jy))−1G(jy) (27)\nand update the transition weights with\nτijy ← τijy + ητ G(jy)i (28)\nfor each j 6= 0 and y ∈ A.\n6. Update the starting values V 0j with\nV 0j ← V 0j + ητ B0j /(m̃0j + ε) (29)\n(this is obtained by analogy: this would be the update of τijy with i = 0 and y a special dummy symbol read at startup—consistently with the fact that m̃0j and B 0 j have not been used to update τ).\nInitialization of the parameters. At startup, the network N is chosen as an oriented random graph with d distinct edges from each unit i, always including a loop i → i. For the tanh activation function, the parameters are set up as follows (see the derivation in Appendix A):\nw0y ← log νy, wiy ← 0 (i 6= 0), (30)\nwhere νy =\n∑\nt χt 1xt=y ∑\nt χt\nis the frequency of symbol y among symbols to be\npredicted in the training data (this way the initial model is an i.i.d. sequence with the correct frequencies). The transition parameters are set so that each unit’s activation reflects a random linear combination of the signal in some time range, as computed in Appendix A from the linearization of the network dynamics, namely\nτiiy ← −α, τijy ← 0 (i 6= j, i 6= 0) (31)\nand τ0jy ← βj +\nµj 4 (ujy − ∑ y′ ν̃y′ujy′) (32)\nwhere the ujy are independent random variables uniformly distributed in\n[0; 1], ν̃y =\n∑\nt 1xt=y\nT is the frequency of symbol y in the data, and where\nµj = 1/(j + 1), α = 1/2, βj = − √ α(α− µj) (33)\nfor unit j (j > 1) are adjusted to control the effective memory7 of the integrating effect at unit j (see Appendix A). These values apply to the tanh activation function. The initial activation values are set to V 0j = s\n−1(βj/α) with s−1 the inverse of the activation function.\n7In particular, any foreknowledge of the time scale(s) of dependencies in the sequence may be used to choose relevant values for µj . With our choice, from Appendix A the time scale for unit j is O(j) at startup, though it may change freely during learning. Multiple time scales for recurrent networks can be found in several places, e.g., [HB95, KGGS14].\nLearning rate control. Gradient ascents come with a guarantee of improvement at each step if the learning rate is small enough. Here we test at each step whether this is the case: If an update of the parameter decreases data log-likelihood, the update is cancelled, the corresponding learning rate (ηw or ητ ) is divided by 2, and the update is tried again. On the contrary, if the update improves data log-likelihood, the corresponding learning rate is multiplied by 1.1. This is done separately for the writing weights and transition weights. This is a primitive, less costly form of line search8.\nAt startup the value ηw = ητ = 1/N (with N the number of units) seems to work well in practice (based on the idea that if each unit adapts its writing weights by O(1/N) then the total writing probabilities will change by O(1)).\nComputational complexity. If the network connectivity d (number of edges i → j per unit j) is not too large, the cost of the steps above is comparable to that of ordinary backpropagation through time.\nLet N be the network size (number of units), A the alphabet size, T the length of the training data, and d the maximum number of edges i → j per unit j in the network.\nThe cost of one forward pass is O(NTd) for computing the activities and O(NTA) for computing the output probabilities. The cost of computing the quantities Wiy is O(NTA) as well, as is the cost of computing the Hessian values hy. Applying the update of w costs O(NA). Thus the cost of the w update is O(NT (d+A)).\nComputing the backpropagated values Btj costs O(NT (d+A)). The cost of computing the backpropagated modulus m̃ti is identical.\nThe cost of computing the gradients G (jy) i is O(NTd) (note that each time t contributes for only one value of y, namely y = xt, so that there is no A factor).\nThe costliest operation is filling the matrices M̃ (jy) ii′ . For a fixed j and y this matrix is of size d× d. Computing the entries takes time O(Td2) for each j, hence a total cost of O(NTd2). (Once more, each time t contributes for only one value of y so that there is no A factor.) Inverting the matrix has a cost of O(Nd3): as this requires no sum over t, this is generally negligible if T ≫ d.\nThus, the overall cost (if T ≫ d) of one gradient step is O(NT (d2 +A)). This suggests using d ≈ √ A. In particular if d = O( √ A) the overall cost is the same as backpropagation through time. If network connectivity is large, there is the possibility to use the quasidiagonal reduction of the matrices M̃ , as described in [Oll13, Sect. 2.3]. This\n8Experimentally, this leads to some slight oscillating behavior when the learning rate gets past the optimal value (as is clear for a quadratic minimum). This might be overcome by averaging consecutive gradient steps.\nrequires computing only the terms M̃ (jy) ii′ with i = i ′ or i = 0. This removes the d2 factor and also allows for O(d) inversion, as follows.\nNon-sparse networks: quasi-diagonal reduction. The algorithm above must maintain a matrix of size d×d for each unit i, where d is the number of units j pointing to i in the network. When d is large this is obviously costly. The quasi-diagonal reduction process [Oll13, Sect. 2.3] provides a procedure linear in d while keeping most invariance properties of the algorithm. This is the procedure already used for the writing weights wiy in (20)–(21). Essentially, at each unit j, the signals received from units i → j are considered to be mutually orthogonal, except for those coming from the always-activated unit i = 0. Thus only the terms M̃ii and M̃0i of the matrix are used. The update of the transition parameters τijy becomes as follows.\n1. For each unit j ∈ N and each symbol y ∈ A, compute the vector G(jy) as before. Compute only the terms M̃\n(jy) 00 , M̃ (jy) ii , and M̃ (jy) 0i of the\nmatrix M̃ (jy) in (26). Dampen the diagonal terms M̃ (jy) 00 and M̃ (jy) ii as before.\n2. Update the transition weights τijy with\nτijy ←τijy + ητ G\n(jy) i −G (jy) 0 M̃ (jy) 0i /M̃ (jy) 00\nM̃ (jy) ii − (M̃ (jy) 0i ) 2/M̃ (jy) 00\ni 6= 0 (34)\nτ0jy ←τ0jy + ητ\n\n\nG (jy) 0 M̃ (jy) 00 − ∑ i6=0 M̃ (jy) 0i M̃ (jy) 00 G (jy) i −G (jy) 0 M̃ (jy) 0i /M̃ (jy) 00 M̃ (jy) ii − (M̃ (jy) 0i ) 2/M̃ (jy) 00\n\n\n(35)"
    }, {
      "heading" : "3 Constructing invariant algorithms for recurrent",
      "text" : "networks\nWe now give the main ideas behind the construction of the algorithm above. The approach is not specific to GLNNs and is also valid for classical recurrent networks."
    }, {
      "heading" : "3.1 Gradients and metrics",
      "text" : "Backpropagation performs a simple gradient ascent over parameter space to train a network. However, for GLNNs (at least), this does not work well. One reason is that gradient ascent trajectories depend on the chosen numerical representation of the parameters. For instance, a non-orthogonal change of basis in parameter space will yield different learning trajectories; yet such changes can result from simple changes in data representation (see the introduction of [Oll13]).\nThis is clear from the following viewpoint. Given a real-valued function f to be maximized depending on a vector-valued parameter θ, the gradient ascent update\nθ′ = θ + η ∂f\n∂θ (36)\nwith learning rate η, can be viewed, for small η, as a maximization of f penalized by the change in θ, namely\nθ′ ≈ argmax θ′\n{\nf(θ′)− 1 2η ∥ ∥θ − θ′ ∥ ∥\n2 }\n(37)\nwhere the equality holds up to an approximation O(η2) for small η. The term ‖θ − θ′‖2 defines a “cost” of changing θ.\nClearly, different ways to represent the parameter θ as a vector will yield different costs ‖θ − θ′‖2. For instance, a linear change of basis for θ amounts to replacing ‖θ − θ′‖2 with (θ− θ′)⊤M(θ− θ′) with M a symmetric, positivedefinite matrix. The associated gradient update will then be\nθ′ = θ + ηM−1 ∂f\n∂θ (38)\nwhich is the general form of a gradient ascent when no privileged norm or basis is chosen for the parameter vector θ. Moreover, in general the matrix M may depend on the current value of θ, defining a (Riemannian) metric in which the norm of an infinitesimal change θ → θ + δθ of the parameter θ is\n‖δθ‖2 = δθ⊤M(θ)δθ (39)\nThe gradient ascent update defined by such a metric is thus\nθ′ = θ + ηM(θ)−1 ∂f\n∂θ (40)\nA suitable choice ofM can greatly improve learning, by changing the cost of moving into various directions. Amari, in particular, advocated the use of the “natural gradient” for learning of probabilistic models: this is a norm ‖θ − θ′‖2nat which depends on the behavior of the probability distribution represented by θ, i.e., the output probabilities of the network, rather than on the way θ is decomposed as a set of numbers. Thus the natural gradient provides invariance with respect to some arbitrary design choices. (As a consequence, learning does not depend on whether a logistic or tanh is used as the activation function, for instance, since one can be changed into the other by a change of variables.)\nIn [Oll13] we introduced several metrics for feedforward neural networks sharing this key feature of the natural gradient, at a lesser computational cost. The main idea is to define the metric according to what the network does, rather than the numerical values of the parameters. We now show how these can be used to build invariant metrics for recurrent networks."
    }, {
      "heading" : "3.2 The Fisher metric on the output units and writing weights",
      "text" : "Whole-sequence Fisher metric and conditional Fisher metric. Metrics for neural networks first rely on choosing a metric on the output of the network [Oll13]. Here the network’s output is interpreted as a probability distribution on the sequence (xt) printed by the network. Amari’s natural gradient and the metrics we use are both based on the Fisher metric [AN00] on the space of probability distributions. One way to define the Fisher metric is as an infinitesimal Kullback–Leibler divergence between two infinitesimally close probability distributions on the same set.\nFor recurrent neural networks, there is a choice as to which probability distribution should be considered. One can either view the network as defining a probability distribution Pr over all output sequences (x0, . . . , xt, . . .), or equivalently as defining a sequence of conditional probability distributions πt for the next symbol xt knowing the previous symbols. Thus there are two ways to define a divergence on the parameter θ based on Kullback–Leibler divergences for finite-length output sequences (xt)06t6T . One is\nD1(θ, θ ′) := KL(Prθ(x0, . . . , xt, . . .) || Prθ′(x0, . . . , xt, . . .)) (41)\nwhere Prθ is the probability distribution over the set of all sequences (x0, . . . , xt, . . .) defined by the network with parameter θ. The other depends on the actual training sequence x and is\nD2(θ, θ ′) :=\n∑\nt\nKL(Prθ(xt|x0, . . . , xt−1) || Prθ′(xt|x0, . . . , xt−1)) (42)\n= ∑\nt\nKL ( πt ||π′t )\n(43)\nwhere πt (resp. π ′ t) is the probability distribution on the next symbol xt defined by the network with parameter θ (resp. θ′) knowing past observations x0, . . . , xt−1.\nArguably, D2 is more adapted to prediction or (online) compression, while D1 is better suited for generalization and learning. For instance, if the actual training sequence starts with the letter a, a gradient ascent based on D2 will not care how a change of θ affects the probability of sequences starting with a b.\nAssuming that the training sequence (xt) has actually been sampled from Prθ and is long enough, and under reasonable stationarity and ergodicity assumptions for Prθ, D2 should be a reasonable approximation of D1. 9\n9Indeed one has D1 = Ex∼Prθ ln Prθ(x) Pr\nθ′ (x)\n= Ex∼Prθ ln\n∏\nt Prθ(xt|x0...xt−1)\n∏\nt Pr θ′ (xt|x0...xt−1)\n=\n∑\nt Ex∼Prθ ln\nPrθ(xt|x0...xt−1) Pr θ′ (xt|x0...xt−1) = ∑ t E(x0...xt−1)∼PrθExt∼Prθ(xt|x0...xt−1) ln Prθ(xt|x0...xt−1) Pr θ′ (xt|x0...xt−1) =\n∑\nt E(x0...xt−1)∼PrθKL(Prθ(xt|x0 . . . xt−1) || Prθ′(xt|x0 . . . xt−1)) so that if averaging over t in the actual training sequence is a good approximation of averaging over t for a Prθ-random sequence, then D1 and D2 are close.\nHowever, in a learning situation, it may not be reasonable to assume that (xt) is a sample from Prθ until the training of θ is finished. So we do not assume that D1 ≈ D2.\nAlgorithmically, when an actual training sequence x is given, the conditional divergenceD2 is much easier to work with, because it can be computed in linear time, whereas computing D1 would require summing over all possible sequences, or using a Monte Carlo approximation and sampling a large number of sequences.\nFor these reasons, we will define a metric based on D2, i.e., on the Fisher metric on the successive individual distributions πt.\nFisher metric on the output units. At each time step, the output of the network is a probability distribution over the alphabet A. The set of these probability distributions is naturally endowed with the Fisher metric: the square distance between two infinitesimally close probability distributions π and π + δπ is\n‖δπ‖2nat := 2KL(π ||π + δπ) (44)\n= ∑\nx∈A\n(δπ(x))2\nπ(x) = Ex∼π(δ log π(x))\n2 (45)\nat second order, where δ log π(x) = δπ(x)/π(x) is the resulting variation of log π(x).\nIn the networks we consider, at each step the distribution πt for the next symbol is given by a softmax output\nπt(x) = e ∑ i at i wix\n∑ y∈A e ∑ i at i wiy\n(46)\nfor each x in the alphabet A. Let us set Ety := ∑ i a t iwiy, so that πt(y) = eE t y/ ∑ e Et\ny′ . Then the norm ‖δπt‖nat of a change δπt resulting from a change δEt in the values of Et is, by standard arguments for exponential families, found to be\n‖δπt‖2nat = ∑\ny\nπt(y)(δE t y) 2 − ∑\ny,y′\nπt(y)πt(y ′)δEtyδE t y′ (47)\n(see Appendix C). By a property of exponential families, this is also, for any y′′, the Hessian of − log πt(y′′) with respect to the variables Et. In particular, in this situation, for the parameters w, the natural gradient with learning rate 1 coincides with the Newton method.\nMetric over the writing coefficients. We can now compute the natural metric over the writing coefficients wix. Let δwix be an infinitesimal change\nin the parameters wix: this creates a change δπt in the distribution πt, for all t. By the discussion above, we are interested in the quantity\n∑\nt\n‖δπt‖2nat (48)\nChanging the writing weights wix does not change the activities of units in the network. Consequently, we have δEty = ∑ i a t iδwiy. Thus the above yields ∑\nt\n‖δπt‖2nat = ∑\nt\n∑\ny,y′\n∑\ni,i′\nπt(y ′)(1y′=y′′ − πt(y′′))atiati′ δwiyδwi′y′ (49)\nso that the metric ∑ t ‖δπt‖2nat over the parameters wiy is given by the Fisher matrix\nIwiywi′y′ = ∑\nt\nπt(y ′)(1y′=y′′ − πt(y′′))atiati′ (50)\nwhich is also, up to sign, the Hessian of the log-likelihood of the training sequence with respect to the parameters w.\nThis is a full matrix whose inversion can be costly. The update of the parameters wiy given in Section 2 corresponds to the quasi-diagonal inverse of this metric, whose only non-zero terms correspond to y = y′ and i = i′ or i = 0. By [Oll13, Sect. 2.3], the quasi-diagonal inverse respects invariance under affine reparametrization of the activities of each unit."
    }, {
      "heading" : "3.3 Invariant metrics for recurrent networks",
      "text" : "The natural gradient arising from the whole-network Fisher metric is algorithmically costly to compute for neural networks (though the “Hessianfree” conjugate gradient method introduced in [Mar10, MS11, MS12] approximates it). We now introduce metrics for recurrent networks that enjoy some of the main properties of the Fisher metric (in particular, invariance with respect to a number of transformations of the parameters or of the activities), at a computational cost close to that of backpropagation through time.\nAny invariant metric for feedforward networks can be used to build an invariant metric for recurrent networks, by first “time-unfolding” the network as in backpropagation through time [RHW87, Jae02], and then by defining the norm of a change of parameters of the recurrent network as a sum over time of the norms of corresponding changes of parameters at each time in the time-unfolded network, as follows.\nA recurrent neural network with n units, working on an input of length T , can be considered as an ordinary feedforward neural network with nT units with shared parameters [RHW87, Jae02]. We will refer to it as the timeunfolded network. In the time-unfolded network, a unit is a pair (i, t) with i a unit in the original network and t a time. The unit (i, t) directly influences\nthe units (j, t+1) where i → j is an edge of the recurrent network. We also consider the output distribution πt at time t as a (probability distribution– valued) output unit of the time-unfolded network, directly influenced by all time-unfolded units (i, t).\nIf all time-unfolded units (i, t) use the same parameters θi as the corresponding unit i in the recurrent network, then the behaviors of the timeunfolded and recurrent networks coincide. Thus, let us introduce dummy time-dependent parameters θti for unit (i, t) of the time-unfolded network, and decide that the original parameter θi for unit i in the recurrent network is a “meta-parameter” of the time-unfolded network, which sets all dummy parameters to θti = θi.\nWe are now ready to build a metric on recurrent networks from a metric ‖·‖ on feedforward networks. A variation δθ of the parameters of the recurrent network determines a variation δθt of the (dummy) parameters of the time-unfolded network, which is an ordinary feedforward network. Thus we can simply set\n‖δθ‖2 := ∑\nt\n∥ ∥ ∥δθt ∥ ∥ ∥ 2 (51)\nwhere for each t, δθt is a variation of the parameters of an ordinary feedforward network, for which we can use the norm ∥ ∥δθt ∥\n∥. If the metric used on the time-unfolded network is reparametrizationinvariant, then so will be the metric on the recurrent network (since its definition does not use any choice of coordinates).\nUsing this definition for ‖δθ‖ is actually the same as making independent gradient updates δθt for each θt based on the metric ∥ ∥δθt ∥\n∥, then projecting the resulting update onto the subspace where the value of θt does not depend on t (where the projection is orthogonal in the metric ‖·‖). Equivalently, this amounts to making independent updates for each θt and then finding the time-independent update δθ minimizing ∑\nt\n∥ ∥δθt − δθ ∥ ∥ 2 .10\nThus, we can use any of the metrics mentioned in [Oll13] for feedforward networks. Two will be of particular interest here, but other choices are possible; in particular, in case network connectivity is high, quasi-diagonal reduction [Oll13, Sect. 2.3] should be used.\nDefinition 6. Let ‖·‖ff be a metric for feedforward networks. The recurrent metric associated with ‖·‖ff is the metric for recurrent network parameters defined by\n‖δθ‖2rff := ∑\nt\n∥ ∥ ∥δθt ∥ ∥ ∥ 2\nff (52)\n10For these equivalent interpretations, one has to assume that there is more than one training sequence. Indeed, for typical choices of the feedforward network metric ∥ ∥δθt ∥ ∥, with only one training sequence the metric ∥ ∥δθt ∥ ∥ on each individual θt is only of rank one, hence the corresponding update of θt is ill-defined. On the other hand, even with only one training sequence, the metric on δθ is generally full-rank, being a sum over time of rank-one metrics.\nnamely, by summing over time the metric ‖·‖ff on the time-unfolded network. The recurrent backpropagated metric (RBPM) is the norm ‖·‖rbp on a recurrent network associated with the backpropagated metric ‖·‖bp on the time-unfolded network.\nThe recurrent unitwise outer product metric (RUOP metric) is the norm ‖·‖ruop associated with the unitwise outer product metric ‖·‖uop on the timeunfolded network.\nThe latter two metrics are described in more detail below. Both of them are “unitwise” in the sense that the incoming parameters to a unit are orthogonal to the incoming parameters to other units, so that the incoming parameters to different units can be treated independently. (Given a unit k in the network, we call incoming parameters to k the parameters directly influencing the activity of unit k, namely, the weights of edges leading to k and the bias of k.)\nRemark 7. We shall use these metrics only for the transition parameters τ of recurrent networks and GLNNs. For the writing parameters w, the Hessian, or equivalently the Fisher metric, is easily computed (Section 3.2) and there is no reason not to use it.\nRemark 8 (Multiple training sequences). Definition 6 is given for a single training sequence (xt). In the case of multiple training sequences, one has to first compute the metric for each sequence separately (since the time-unfolded networks are different if the training sequences have different lengths) and then define a metric by averaging the square norm ‖δθ‖2rff over the training dataset, as in [Oll13]. There is a choice to be made as to whether training sequences of different lengths should be given equal weights or weights proportional to their lengths; the relevant choice arguably depends on the situation at hand.\nRemark 9 (Natural metric and recurrent natural metric). The natural metric of a recurrent network is defined in its own right and should not be confused with the recurrent-natural metric obtained by applying Definition 6 to the natural metric of the time-unfolded network. For the natural metric of the recurrent network, the norm of a change of parameter δθ is the norm of the change it induces on the network outputs πt. For the recurrent-natural metric, the square norm of δθ is the sum over time t, of the square norm of the change induced on the output by a change δθt = δθ of the dummy parameter θt, so that the influence of δθ is decomposed as the sum of its influences on each dummy parameter δθt considered independently. (Still, the influence of θt on the output at times t′ > t is taken into account.) Explicitly, if πt is the network output at time t, then the natural norm is ‖δθ‖2nat = ∑ t ∥ ∥ ∥ ∂πt ∂θ δθ ∥ ∥ ∥ 2 where ‖·‖ is the norm on the outputs πt. De-\ncomposing ∂πt ∂θ = ∑ t′6t ∂πt\n∂θt ′ this is\n∑\nt\n∥ ∥ ∥ ∥ ( ∑ t′6t ∂πt\n∂θt ′\n)\nδθ\n∥ ∥ ∥ ∥ 2 . On the other hand\nthe recurrent-natural norm is ‖δθ‖2rnat = ∑ t′\n∥ ∥ ∥δθt ′ ∥ ∥ ∥ 2\nnat =\n∑ t′ ∑ t>t′\n∥ ∥ ∥ ∥ ∂πt\n∂θt ′ δθ\n∥ ∥ ∥ ∥ 2\nwhich is generally different and accounts for fewer cross-time dependencies.\nWe now turn to obtaining more explicit forms of these metrics for the case of GLNNs. We describe, in turn, the RUOP metric and the RBPM. For simplicity we will assume that all symbols in the sequence have to be predicted (χt ≡ 1). Section 2 includes the final formulas for the general case."
    }, {
      "heading" : "3.4 The recurrent unitwise outer product metric",
      "text" : "Let us now describe the recurrent unitwise outer product metric (RUOP metric) in more detail.\nWe briefly recall the definition of the (non-recurrent) unitwise outer product metric. Suppose we have a loss function L depending on a parameter θ, and moreover that L decomposes as a sum or average L = Ex∈Dℓ(x) of a loss function ℓ over individual data samples x in a dataset D. The outer products of the differentials ∂ℓ(x)\n∂θ , averaged over x, provide a metric on θ,\nnamely, Ex∈D ∂ℓ(x) ∂θ ⊗ ∂ℓ(x) ∂θ given by the matrix\nCij = Ex∈D ∂ℓ(x)\n∂θi\n∂ℓ(x)\n∂θj (53)\nThis is the outer product (OP) metric on θ. The associated gradient ascent for L, with step size θ, is thus θ ← θ + ηC−1 ∂L ∂θ\n, and this gradient direction is parametrization-invariant. (One must be careful that scaling L by a factor λ will result in scaling this gradient step by 1/λ, which is counter-intuitive, thus step-size for this gradient must be carefully adjusted.)\nWhen the loss function ℓ is the logarithmic loss ℓ(x) = log Prθ(y|x) of a probabilistic model Prθ(y|x), as is the case for feedforward networks with y the desired output for x, then the OP metric Ex∈D ∂ log Prθ(y|x) ∂θ ⊗ ∂ log Prθ(y|x) ∂θ\nis a well-known approximation to the Fisher metric (for the latter, y would be sampled from the output of the network seen as a probability distribution, instead of using only the target value of y). In this context it has been used for a long time [APF00, RMB07]—sometimes under the name “natural gradient”, though it is in fact distinct from the Fisher metric, see discussion in [PB13] and [Oll13].\nThe OP metric has the following unique property: For a given increment δL in the value of L, the OP gradient step is the one for which the increment is most uniformly spread over all samples x ∈ D, in the sense that the variance Varx∈D δℓ(x) is minimal [Oll13, Prop. 15].\nFor feedforward networks, the OP metric is given by a full matrix on parameter space. This is computationally unacceptable for large networks; a more manageable version is the unitwise OP metric (UOP metric), in which\nthe incoming parameters for each unit are made orthogonal [Oll13]. The unitwise OP metric is still invariant under reparametrization of the activities of each unit. This decomposition is also used in [RMB07] (together with a further low-rank approximation in each block which breaks invariance).\nThe recurrent UOP metric is obtained from the UOP metric by Definition 6, through summing over time in the time-unfolded network. Let i be a unit in the recurrent network, and let θi be the set of incoming parameters to i. A change δθi in θi results in a change δθ t i of all the dummy parameters θti of units (i, t) in the time-unfolded network. The square norm of δθi in the RUOP metric is, by definition (52), the sum over t of the square norms of δθti in the UOP metric of the time-unfolded network.\nFor each t and each unit i, the unitwise OP metric on the dummy parameter θti is given by the outer product square of the associated change of the objective function log Prθ(x), namely, the outer product square of ∂ log Prθ(x)\n∂θt i\n.\nNow θti is a dummy parameter of the time-unfolded network, and is used exactly once during computation of the network activities, namely, only at time t to compute the activity V ti and a t i = s(V t i ) of unit i. Thus we have\n∂ log Prθ(x)\n∂θti =\n∂ log Prθ(x)\n∂V ti\n∂V ti ∂θti = Bti ∂V ti ∂θti\n(54)\nwhere the derivatives Bti := ∂ log Prθ(x)\n∂V t i\nare computed in the usual way by\nbackpropagation through time (Appendix B).\nThe partial derivative ∂V t i\n∂θt i\nis readily computed from the evolution equa-\ntion defining the network: for instance, for GLNNs, the evolution equation of the time-unfolded network (using dummy parameters) is V ti = V t−1 i + ∑\nj τ t jixt−1 at−1j , so that the derivative of V t i w.r.t. the parameter τ t jiy is\n1y=xt−1a t−1 j .\nThe unitwise OP metric for the dummy parameter θti is given by the\nouter product square of ∂ logPrθ(x) ∂θt\ni\n, which by the above is (Bti) 2 ∂V\nt i ∂θt i ⊗ ∂V t i ∂θt i .\nThis has to be summed over time to find the recurrent UOP metric for the true parameter θi. So in the end, the RUOP metric for the incoming parameters θi at unit i is given for each i by the matrix\nM̃ (i) kk′ =\n∑\nt\n(Bti ) 2 ∂V\nt i\n∂(θti)k ∂V ti ∂(θti)k′\n(55)\nwhere (θti)k denotes the k-th component of the parameter θ t i , and where the derivative is with respect to the dummy parameter θti used only at time t. For GLNNs, this results in the expression given in the algorithm of Section 2: In the end, for the GLNN transition parameter θ = (τjiy)j,i,y, using that ∂V ti /∂τ t jiy = 1y=xt−1a t−1 j , the recurrent UOP metric is\n‖δθ‖2ruop = ∑\ni\n∑\nj,j′\n∑\nt\n(Bt+1i ) 2atja t j′ δτ t jixt δτ tj′ixt (56)\nThe same expression holds for GNNs (but B has a different expression).\nThe form of the metric. Thus, we find that the RUOP metric on τ is given by a symmetric matrix with the following properties. These remarks also hold for the other metric we use, the RBPM below.\nFirst, different units i are orthogonal (there are no cross-terms between δτjix and δτj′i′x′ for i 6= i′).\nSecond, for GNNs and GLNNs, different symbols x are independent: the transition parameters τijx and τijx′ with x 6= x′ are mutually orthogonal in the RUOP metric, i.e., there are no cross-terms for x 6= x′. This is because, at any given time t, only the parameters τjixt using the currently read symbol xt contribute to the evolution equation. This results in a separate matrix M̃ (ix) for each pair ix in the final algorithm, reducing computational burden.\nOn the other hand, for RNNs with the evolution equation at+1i = s(ρixt+ ∑\njτjia t j), there is no such block decomposition because the transition parameters τij have non-trivial scalar product with all the input parameters ρix for all x; thus, handling this metric would be quadratic in alphabet size. If alphabet size is large, one solution is to restrict input to a subset of units. Another is to use quasi-diagonal reduction [Oll13, Sect. 2.3] to obtain a more lightweight but still invariant algorithm; this was tested in Section 4.\nThird, different units j and j′ connected to the same unit i are not independent. (In particular, the “biases” τ0ix corresponding to the alwaysactivated unit j = 0, aj ≡ 1 are not orthogonal to the other transition weights.) The cross-term between δτjix and δτj′ix is\n∑\nt\n1xt=xa t ja t j′(B t+1 i ) 2 (57)\nBesides, the derivative of log-likelihood with respect to τjix is ∑ t 1xt=xa t jB t+1 i (Proposition 11), and the gradient step is obtained by applying the inverse of the matrix above to this derivative. This problem has an interesting structure. Indeed, vectors obtained as M−1G where M is a matrix of the form Mjk = ∑ t a t ja t kc t, and G of the form Gj = ∑ t a t jY\nt, are weighted leastsquare regression problems: M−1G gives the best way to write the vector Y t/ct, seen as a function of t, as a linear combination of the family atj , seen as functions of t. This is the “best-fit” interpretation [Oll13, Section 3.3].\nThus, using metrics of this form, each unit i in the network combines the signals from its incoming units j in an optimal way to match a desired change in activity (given by Bti ) over time. The two metrics presented here, RUOP and RBPM, differ by the choice of the weighting ct.\nRemark 10 (UOP metric and recurrent UOP metric). The recurrent unitwise OP metric should not be confused with the unitwise OP metric applied to the recurrent network, which is defined in its own right but unsuitable for several reasons. For instance, with only one training sequence\nx, the OP metric for the recurrent network is simply ∂ log Pr(x) ∂θ ⊗ ∂ log Pr(x) ∂θ\n, which is a rank-1 matrix and thus not invertible. On the other hand, on a single training sequence of length T , the recurrent UOP metric is a sum of T matrices of rank 1. Thus for a recurrent network, ‖·‖ruop 6= ‖·‖uop in general: one is a time sum of outer product squares, the other is the outer product square of a time sum. (Compare Remark 9.) So the recurrent UOP metric performs an averaging of the metric over time rather than over samples, as is expected in a recurrent setting.\nAnother similar-looking metric would be the OP metric associated with the decomposition log Pr(x) = ∑\nt log Pr(xt|x0, . . . , xt−1) = ∑\nt log πt(xt) of the objective function. Such a decomposition gives rise to a metric ∑\nt( ∂ log πx(xt) ∂θ )⊗2. This metric is generally full-rank even for a single training\nsequence. The recurrent OP metric, on the other hand, is ∑ t( ∂ logPr(x) ∂θt )⊗2. So while the recurrent OP is the sum over time of the effect of the dummy time-t parameter θt on the objective function, the metric just introduced is the sum over time of the effect of the parameter θ on the t-th component of the objective function. These are generally different. Computing all partial derivatives ∂ log πx(xt)\n∂θ for all t and θ is algorithmically costlier, which is why\nwe did not use this metric."
    }, {
      "heading" : "3.5 The recurrent backpropagated metric",
      "text" : "We now work out an explicit form for the recurrent backpropagated metric. For a feedforward network, the backpropagated metric (BPM), introduced in [Oll13], is defined as follows. Given a metric on the output units of a network (here the Fisher metric on πt), one can inductively define a metric on every unit by defining the square norm ‖δai‖2bp of a change of activity δai at unit i, as the sum ∑\nj, i→j ‖δaj‖2bp of the square norms of the resulting changes in activity at units j directly influenced by i, thus “backpropagating” the definition of the metric from output units to inner units. The metric ‖δaj‖2bp at unit j is then turned into a metric on the incoming parameters to j, by setting ‖δθj‖2bp := ‖δaj‖ 2 bp with δaj the change of aj resulting from the change δθj. The recurrent BPM is obtained from the BPM by Definition 6, through summing over time in the time-unfolded network. Let i be a unit in the recurrent network, and let θi be the set of incoming parameters to i. A change δθi in θi results in a change δθ t i of all the dummy parameters θ t i of units (i, t) in the time-unfolded network. The square norm of δθi in the RBPM is, by definition (52), the sum over t of the square norms of δθti in the backpropagated metric metric of the time-unfolded network.\nSo let us work out the backpropagated metric in the time-unfolded network. The time-unfolded unit (i, t) directly influences the time-unfolded units (j, t + 1) for all edges i → j in the graph of the original network, and\nit also directly influences the distribution πt at time t. Thus, let δati be an infinitesimal change in the activity of time-unfolded unit (i, t). Let δπt be the resulting change in the probability distribution πt, and δat+1j = ∂at+1 j\n∂at i\nδati the resulting change in the activity of time-unfolded\nunit (j, t+ 1). The BPM is obtained by backwards induction over t\n∥ ∥ ∥δati ∥ ∥ ∥ 2\nbp := ‖δπt‖2nat +\n∑\nj\n∥ ∥ ∥δat+1j ∥ ∥ ∥ 2\nbp (58)\nThe term ‖δπt‖2nat is readily computed from Section 3.2: in the notation above, the change in Ety = ∑ j wjya t j from a change of activity in a t i is δEty = wiyδa t i, so that (47) yields\n‖δπt‖2nat = (δati)2 ( ∑ yπt(y)w 2 iy − ( ∑ yπt(y)wiy) 2 )\n(59)\ni.e., proportional to the πt-variance of wiy (in line with the fact that translating weights does not change output).\nSince activities are one-dimensional, the backpropagated metric is simply proportional to (\nδati )2 , so that we have\n∥ ∥ ∥δati ∥ ∥ ∥ 2\nbp =: mti\n(\nδati\n)2 (60)\nfor some positive number mti, the backpropagated modulus [Oll13]. The definition (58) of the backpropagated metric thus translates as\nmti = ( ∑ yπt(y)w 2 iy − ( ∑ yπt(y)wiy) 2 ) + ∑\nj\n(\n∂at+1j ∂ati\n)2\nmt+1j (61)\n(initialized with mTi = 0), in which one recognizes a source term from the output at time t, and a term transmitted from t+ 1 to t.\nIt is advisable to express the backpropagated metric using the variable V ti\nrather than ati (because the expression for ∂V t+1 j\n∂V t i\nis simpler). The variables\nV and a correspond bijectively to each other, and their variations are related by δati = s ′(V ti )δV t i so that ∥ ∥δati ∥ ∥ bp = m t i ( δati )2 = m̃ti ( δV ti )2 with\nm̃ti := m i t s ′(V ti ) 2 (62)\nfrom which we derive the induction equation for m̃, namely\nm̃ti = s ′(V ti )\n2 ( ∑\nyπt(y)w 2 iy − ( ∑ yπt(y)wiy) 2 ) + ∑\nj\n(\n∂V t+1j ∂V ti\n)2\nm̃t+1j (63)\nin which we can now easily compute the ∂V t+1 j\n∂V t i\nterm from the evolution\nequation defining the recurrent network.\nFor instance, for GLNNs we have V t+1j = V t j + ∑ i τijxts(V t i ) so we find\n∂V t+1j ∂V ti = 1i=j + τijxts ′(V ti ) (64)\nwhich, plugged into the above, yields the explicit equation (24) given in the algorithm description.\nOnce the backpropagated modulus is known, the backpropagated metric on the dummy parameters θti at each unit (i, t) of the time-unfolded network is obtained by ∥\n∥δθti ∥ ∥ bp := ∥ ∥δati ∥ ∥ bp where δa t i =\n∂at i ∂θt i .δθti is the variation of a t i\nresulting from a variation δθti . Thus\n∥ ∥ ∥δθti ∥ ∥ ∥ 2\nbp = mti\n(\n∂ati ∂θti .δθti\n)2\n= m̃ti\n(\n∂V ti ∂θti .δθti\n)2\n(65)\nwhere, as in the case of the RUOP metric above, the derivative ∂V t i\n∂θt i\ncan be\nobtained from the evolution equation defining the network. In components, ∥ ∥δθti ∥ ∥ 2 bp is thus given by a matrix whose kk ′ entry is\nm̃ti ∂V ti ∂(θti)k ∂V ti ∂(θti)k′\n(66)\nwhere (θti)k denotes the k-th component of the incoming parameter θ t i to unit i. A parameter θi of the recurrent network influences all dummy parameters θti for all t. The recurrent backpropagated metric is obtained by summing the backpropagated metric over time as in (52). So in the end the recurrent backpropagated metric for the incoming parameter θi to unit i is given by the matrix\nM̃ (i) kk′ =\n∑\nt\nm̃ti ∂V ti ∂(θti)k ∂V ti ∂(θti)k′\n(67)\nwith (θti)k the k-th component of θ t i , and where the derivative is with respect to the dummy parameter θti used only at time t. For instance, in GLNNs, the incoming parameter to unit i is θi = (τjiy)j,y. The evolution equation V ti = V t−1 i + ∑ j τ t jixt−1 at−1j using the dummy parameters yields ∂V t j\n∂τ t jiy\n= 1xt−1=ya t−1 j . This results in the expression given in the\nalgorithm of Section 2. In the end, for the GLNN parameter θ = (τjiy)j,i,y, the recurrent backpropagated metric is\n‖δθ‖2rbp = ∑\ni\n∑\nj,j′\n∑\nt\nm̃t+1i a t ja t j′ δτjixtδτj′ixt (68)\nThe structure of this metric is the same as for the RUOP metric above, and the same remarks apply (see Section 3.4): incoming parameters to distinct units i are independent; parameters corresponding to distinct symbols\ny 6= y′ are independent for GNNs and GLNNs but not for RNNs; finally, the transition parameters from different units j and j′ incoming to the same unit i are not independent, and the gradient ascent in this metric realizes, at each unit i, a weighted least-square regression on the incoming signals from units j to best match a desired activation profile given by the backpropagation values."
    }, {
      "heading" : "3.6 Invariance of the algorithms",
      "text" : "Amari [Ama98, AN00] pioneered the use of “invariant” algorithms for statistical learning that do not depend on a chosen numerical representation (parametrization) of the parameter space of the model. Invariance can often improve performance; for instance, in the standard RNNs in the experiments below, replacing the standard inverse diagonal Hessian with the (invariant) quasi-diagonal inverse brings performance of RNNs closer to that of GLNNs, at very little computational cost.\nThe gradient ascent presented above is invariant by reparametrization of the activities and by reparametrization of the incoming parameters to each unit (but not by reparametrizations mixing incoming parameters to different units, as the natural gradient is).\nThis stems from its construction using a metric which depends only on the behavior of the network. For instance, using tanh instead of sigmoid activation function and following the same procedure would result in an algorithm with identical learning trajectories.\nHowever, in practice three factors limit this invariance.\n1. The invariance holds, in theory, only for the continuous-time gradient trajectories. The actual gradient steps with non-zero learning rate are only approximately invariant when the learning rate is small. Still, the actual gradient steps are exactly invariant under affine reparametrizations of the parameters and activity (such as changing sigmoid into tanh).\n2. Parameter initialization is done by setting numerical values for the parameters in an explicit numerical representation. Changing parametrization obviously means changing the initial values in the same way. If initialization is based on an intended parametrization-independent behavior at startup, as in Section 2, this is not a problem.\n3. The dampening procedure for matrix inversion (the various ε terms in Section 2) formally breaks invariance. Using a Moore-Penrose pseudoinverse (which is simply the limit ε → 0) does not solve this problem. It would be nice to have a dampening scheme preserving invariance11.\n11Here is a possibility for defining a matrix for the incoming parameters to a unit i, which could be used as dampening the metric at i in an invariant way: Compute a copy"
    }, {
      "heading" : "4 Preliminary experiments",
      "text" : "Here we report a comparison of the performance of GLNNs and more traditional RNNs on some synthetic data examples: the “alphabet with insertion” (Example 1 from the Introduction), synthetic music (Example 3), the distant XOR problem (Example 2), and finally the anbn problem (Example 4). LSTMs are used as an additional benchmark.\nGLNNs were trained with either the recurrent backpropagated metric or the recurrent unitwise outer product metric, as described in Section 2.\nThe reference RNN was trained using traditional (but not naive) techniques as described below. For the distant XOR example, RNN performance is known to be poor unless the “Hessian-free” technique is used [MS11], so we did not test RNN on this example and instead directly compare performance to [MS11].\nReference RNN training. The RNN used as a baseline is described in Section 1.2.1. In particular, both this RNN and GLNNs use a softmax (6) for the probability to produce a symbol x given the internal state of the network.\nRNN training is done via backpropagation through time. As plain backpropagation was too slow, for the parameters wiy the inverse diagonal Hessian (obtained from (18)) is applied to the gradient update, and the learning rate for each ρix is inversely proportional to the frequency of symbol x in the data (thus compensating for the number of terms making up the corresponding gradient, so that rare symbols learn as fast as frequent symbols12). A method similar to RMSprop or Adagrad [DHS11], in which the learning rate for each transition parameter is divided by the root mean square (RMS) average over time of the gradient magnitude, is also reported in Table 1.\nInitialization of the RNN parameters has been set along the same principles as for GLNNs, namely\nw0y ← log νy, τii ← 1− 1/i, ρjy ← 1\n2 (ujy − ∑ y′ ν̃y′ujy′) (69)\nwith u and ν̃ as in Section 2, and with all other weights set to 0, where the symbol frequencies νy and ν̃y are as in Section 2, and the ujy are independent random variables uniformly distributed in [0; 1]. This way, at startup the\nof the metric (RUOP or RBPM) but replacing the actual training sequence (xt) with a randomly generated sequence (e.g., uniform, or a perturbation of (xt)). More copies with more random sequences can be used until one gets a non-degenerate metric. The resulting metric can be multiplied by a small number and used as a dampening term. But this does not solve all problems: for instance, if a unit i has no effect whatsoever on the output given the current parameters, the corresponding metric will vanish. It seems difficult to define a non-zero invariant metric in the latter situation.\n12If ρix is seen as the weight from an input unit activated when symbol x occurs, then this is equivalent to scaling the input unit signals to a given L2 norm over time.\nactivation of each unit is given by a random linear combination of past symbols with weights exponentially decreasing with time, with unit i having a decay time of order i thanks to τii.\nMore combinations of models (RNN, GNN, GLNN) and training methods are reported in Table 1.\nLSTMs. LSTMs [HS97] are included as an additional benchmark. For this we have kept the same overall procedure and simply replaced each RNN cell with an LSTM cell following Eqs. (7)–(11) in [Gra13], and modified the gradient accordingly. We kept the softmax output from the other models (also as used in [Gra13]). The weights were initialized to uniform random values in [−0.1, 0.1] [Gra12, GSS03]. Network construction, network sizes, and CPU time budget were identical to the other models, as described below. Since plain gradient resulted in slow training, we have also included a variant described above for RNNs: using the diagonal Hessian for the writing parameters w, and frequency-adjusted learning rates for the input symbols (equivalent to rescaling the inputs). Still, training is quite slow and from Table 1 it appears that LSTMs are not competitive in this setup13, at least for the computational time budget used here.\nRegularization. When working with discrete alphabets, the problem arises of having probability 0 for certain symbols in certain situations after training; if the trained model is used on a validation set, validation log-likelihood can thus be very low. In our situation this is especially the case near the beginning of the sequence: since the model is trained on only one training sequence and has parameters for the activities at startup, it can frequently learn to start in a specific configuration to reproduce the first few letters of the training sequence. For this reason, a crude regularization procedure was used: before computing log-likelihood of the validation sequence, the prediction πt for the next symbol at time t was replaced with (1− 1t+2 )πt+ 1t+2unifA with unifA the uniform distribution over the alphabet. (This kind of regularization has some backing from information theory.)\nExperimental setup. The same overall procedure (construction of a random graph, learning rate control) has been used for both GLNNs and RNNs as described in Section 2, following nearly identical implementations.\nIn each case, a single14 training sequence (xt) is generated using the exact synthetic model. Another, independent sequence (x′t) is used for validation: we report the log-likelihood (in base 2) of the validation sequence (x′t) using\n13Good performance of LSTMs has been reported for one of the problems we use, the anbn problem [GSS03]. However this involved more samples and small values of n in the training set. With these settings we were able to obtain similar results.\n14see footnote 2\nthe GLNN or RNN trained on (xt). The baseline for performance is the number of random bits used by the exact synthetic model to generate (x′t).\nAs a sanity check, we also report the performance of a well-known, efficient online text prediction method, context tree weighting (CTW): the algorithm is presented with the concatenation of the training and validation sequence, and we report the number of bits used to predict the validation sequence after having read the training sequence.\nThe comparison between GLNNs and RNNs is made for identical computation time on the same machine, for a series of hyper-parameter settings (network size and connectivity). Indeed, as RNNs and GLNNs have different parameter sets, direct comparison for the same network size is difficult. Spanning different network sizes shows the performance each model can attain for a given time budget if the right hyper-parameters are used.\nIn each case, the size of the network was chosen to increase from 4 units to a maximum of 256 or 512 units by increments of a factor √ 2. For each network size, we tested both a sparse network with connectivity d = 3 edges per unit (including a loop at each unit), and a “semi-sparse” network with connectivity d = √ 2#A for GLNNs and d = #A for RNNs, where #A is the alphabet size; this latter choice balances the various contributions to algorithmic complexity (see Section 2). This way, RNNs can take advantage of their lesser computational sensitivity to connectivity d.\nFor each hyper-parameter setting, the corresponding model was allowed to learn for the same time (10 or 30 minutes depending on the example).\nThe experiments were run on a standard laptop computer with an Intel Core i7-3720QM CPU at 2.60GHz 15, using a straightforward implementation in C++.\nThe code for these experiments can be downloaded at http://www.yann-ollivier.org/rech/code/\nLet us now discuss each example in turn.\nAlphabet with insertions. The synthetic generative model is as follows. The training sequence is the concatenation of 1000 lines, separated by a newline symbol. Each line is obtained by writing the 26 lowercase letters of the Latin alphabet, in the standard order, and then inserting (independently) a sub-block after each letter with probability 1/26 for each letter. A subblock starts with an opening parenthesis, followed by the 10 digits from 0 to 9 (in that order), and ends with a closing parenthesis. After each digit in the sub-block, with probability 1/5 a sub-sub-block is inserted, which consists of an opening square bracket, nine random uppercase letters chosen from A–Z, and a closing bracket. Thus a typical line might look like ab(0123[WZPYCPEEH]456789[HYDVTWATR])cdefghijklmnopqrstuvwxyz\n15For technical reasons the experiments for LSTMs and the RMS variant of RNNs were done on a slightly faster machine; an empirically adjusted scaling factor was applied to the corresponding CPU time.\nThe validation sequence has the same law: the concatenation of 1000 independent such lines. Randomization of the innermost blocks prevents rote learning.\nGLNNs and RNNs with a variety of network sizes ranging from 4 to 512 units, as described above, were run for 30 minutes each on the training sequence. The validation sequence log-likelihood is reported in Figure 1 and Table 1.\nGLNNs come more than ten times closer to the true model log-likelihood than RNNs: the best validation log-likelihood for GLNNs is -89,126 bits while that for RNNs is -96,099 bits, compared to -88,482 bits for the true model. Such a difference of roughly 7,000 bits represents roughly 7 bits per line of the training sequence. Note that the cost of representing a letter in the alphabet is log(26)/ log(2) ≈ 4.7 bits: this would be the log-likelihood difference, for each line of the training sequence, between a model that resumes at the correct place in the alphabet after a sub-block insertion, and one that resumes at a random letter.\nThis is confirmed by visual inspection of the models obtained after training. Indeed, since we train generative models, the trained network can be used to generate new sequences, hopefully similar to the training sequence. Doing so with RNNs and GLNNs reveals qualitative differences in the models learned, in line with the difference in performance: After a sub-block has been inserted, GLNNs resume at the correct letter or sometimes one letter off the correct position in the alphabet; on the other hand, RNNs seldom\nresume at the correct position. The remaining small difference in log-likelihood between GLNNs and the true model can, from visual inspection, be attributed to various factors: residual errors like occasional duplicated or omitted letters, or resuming one letter off after an insertion, as well as arguably good generalizations of the training sequence such as having more than one sub-block between two letters or starting a new line with a sub-block.\nThere is no obvious pattern of dissimilar performance between sparse and semi-sparse networks.\nHowever, GLNNs are apparently quite sensitive to overfitting over time: validation log-likelihood increases at first, then steadily decreases as parameter optimization progresses. This phenomenon is also present to a lesser extent for RNNs, but only after much longer training times. Note that for a given network size, GLNNs have more parameters (because each edge has as many parameters as symbols in the alphabet A).\nThis illustrates the importance of using a validation sequence to stop training of GLNNs.\nOne GLNN run exhibits wild variations of validation log-likelihood, for unknown reasons (perhaps a badly invertible matrix M̃ ).\nOn the other hand, surprisingly, GLNNs are less sensitive to overfitting due to a too large network size: while increasing network size past some value results in worse performance for RNNs (lower curves on Figure 1), for GLNNs it seems that the best validation log-likelihood over an optimization trajectory stays the same for a wide range of network sizes.\nRunning RNNs for longer times only partially bridges the gap in performance: RNNs after 4 hours are still seven times farther from the true model than GLNNs are after 30 minutes (with a gain of 2,810 bits of log-likelihood for RNNs). After some time, RNNs slow down considerably or sometimes exhibit the same overfitting phenomenon as GLNNs and their validation performance decreases.\nOverall, the “resume-after-insertion” phenomenon illustrated by this example is well captured by GLNNs.\nSynthetic music. The next example is synthetic music notation, meant to illustrate the intersection of several independent constraints. The training sequence is a succession of musical bars. Successive musical bars are separated by a | symbol and a newline symbol. Each bar is a succession of notes separated by spaces, where each note is made of a pitch (a,b,c,...) and value (4 for a quarter note, 2 for a half note, 4. for a dotted quarter note, etc.). In each bar, a hidden variable determines a harmony with three possible values I, IV, or V. If the harmony is I, every pitch in the bar is taken uniformly at random from the set (“chord”) {c,e,g}; pitches are taken from {c,f,a} if harmony is IV, and from {g,b,d} if harmony is V. Harmonies in\nsuccessive bars follow a specific deterministic pattern: an 8-bar-long cycle I-IV-I-V-I-IV-V-I as encountered in simple tunes. Finally, in each bar, the successive durations are taken from a finite set of 5 rhythmic possibilities (commonly encountered in waltzes), namely: 4-4-4; 2-4; 4.-8-4; 2.; 4-4-8-8. Rhythm is chosen independently from pitch and harmony. See Example 3.\nThe training sequence is made of 2,700 musical bars. The validation sequence is taken independently with the same law.\nGLNNs and RNNs with a variety of network sizes ranging from 4 to 256 units, as described above, were run for 10 minutes each on the training sequence. The validation sequence log-likelihood is reported in Figure 2 and Table 1.\nOnly one RNN run beats the sanity check (CTW). There is a difference of roughly 2,000 bits between the best RNN and best GLNN performance; GLNNs come roughly three times closer to the true model.\nVisual inspection of the output of the networks seen as generative models confirms that this difference is semantically significant: GLNNs correctly learn the rhythmic and harmonic constraints inside each bar, whereas RNNs still display “mistakes”.\nOn the other hand, even GLNNs were not able to learn the underlying 8-bar-long harmonic progression, which was apparently approximated by probabilistic transitions. This is reflected in the remaining gap between the true model and GLNNs.\nRunning an RNN with backpropagation for a longer time (3 hours in-\nstead of 10 minutes) only partially bridged the gap, only bringing RNN an additional 604 bits in log-likelihood. Once more, visual inspection of RNN output revealed a correct learning of the possible set of rhythms, but imperfect learning of the harmonic constraints even inside each musical bar.\nThe pattern of decrease in validation log-likelihood because of overfitting is present but less pronounced than for the alphabet-with-insertions example. Still, on Figure 2 one can notice one GLNN run exhibiting a wild variation of validation log-likelihood at some point. Once more this points out the importance of using validation sets during GLNN training, although using only one training sequence of relatively small size may also play a role here.\nDistant XOR. The setting is taken from [MS11], after [HS97]; here we recast it in a symbolic sequence setting. A parameter T is fixed (T = 100 below), which determines the length of the instances. The training sequence is a concatenation of lines separated by newline symbols. Each line is made of T ′ random bits preceded by whitespaces, where T ′ is taken at random between T and 1.1T . Two of these random bits are preceded by a special symbol X instead of a whitespace. The positions of these two special symbols are taken at random from the intervals J0;T ′/10J and JT ′/10;T ′/2J respectively. At the end of each line, a symbol = is inserted and is followed by a bit giving the XOR result of the two bits following the two X symbols. Example 2 gives a typical training sequence.\nThe goal is to correctly predict the value of the final bit of each line. So in the gradient computation an error term is included only for the bits to be predicted, as in [HS97]. Namely, in the notation of Section 2, we set χt = 1 if and only if xt−1 is the symbol =.\nFor this problem, we did not run the reference RNN and directly compared to the best performance we found in the literature, in [MS11], using “Hessian-free” second-order RNN training. The success rate reported in the latter, for T = 100, is about 25% (proportion of runs achieving a classification error below 1% using at most 50,000 minibatches of 1,000 instances each).\nWe ran eight distinct instances of the problem, each with a different random training and validation sequence. Each such sequence was the concatenation of 10,000 lines as above with T = 100. We used a fully connected network with 10 units. Optimization was run for 1,500 gradient passes over the training sequence (amounting to roughly 12 hours of computation and 750 gradient steps for each of the writing and transition parameters, since we alternate those). We discuss the results for training using the recurrent BPM; the results using the recurrent UOP metric are extremely similar.\nFigure 3 reports two measures of performance on the validation sequence: the log-likelihood score for prediction of the final bit of each line (following the score (4)), and the classification error (equal to 0 if the correct bit value\nis given a probability > 1/2 and to 1 otherwise—this is always bounded by the log-likelihood error) expressed as a percentage.\nThe results are binary: each run either successfully achieves low error rates after enough time, or does not perform better than random prediction.\n4 out of 8 independent runs reached error rates below 1% within less than 1,500 gradient passes over the training set, and 6 out of 8 within 2,000 gradient passes. The sample size is too small to tell for sure that this is better than the success rate in [MS11]. Still, the algorithm is simpler and uses fewer training examples.\nDirect comparison of the algorithmic cost with the approach in [MS11] is difficult, because for each gradient pass the latter can perform up to 300 passes of the conjugate gradient algorithm used in the implicit Hessian computation. For reference, in our approach, each run of the experiment above (1,500 gradient passes on a training sequence of 10,000 lines) takes slightly above 4h of CPU time on an Intel Core i7-3720QM CPU at 2.60GHz using a straightforward C++ implementation (no parallelism, no use of GPUs).\nanbn problem. In this problem, the training sequence is made of lines separated by newlines. The first line is a block of n1 symbols a; the second line is a block of n1 symbols b; the third line contains n2 a, the fourth line contains n2 b, etc. See Example 4.\nIn this experiment, the block lengths n were taken at random in J1024; 2048J\nto build the training and validation sequences. We used training and validation sequences made of only ten anbn blocks. RNNs and GLNNs with sizes ranging from 4 to 64, as described above, were run for 10 minutes each. For each independent run, a new random training sequence and validation sequence was generated. The results are reported in Figure 4 and Table 1.\nThe log-likelihood of a validation sequence under the true model is 10 bits for each block of a (choosing an integer n between 1024 and 2048), after which the length next block of b is known and comes for free. Thus the reference log-likelihood of the whole validation sequence (which contains 10 blocks of each) is 100 bits. However, from only 10 training samples as used here, the exact distribution of the length n cannot reasonably be inferred; a reasonable inference would be, for instance, a geometric law with mean somewhere in this interval. The geometric law with mean 1024+20482 = 1536 has an entropy of about 12 bits instead of 10.\nThus, at best, one can expect a reasonable model to attain an entropy of about 120 bits on the 10-instance-long validation set. On the other hand, a model which would not catch the equality of the sizes of consecutive a and b blocks would require twice as much entropy, i.e., about 240 bits for the validation set. Indeed, the sanity check (CTW) has a log-likelihood of -243.5 bits.\nThe best GLNN log-likelihood value obtained is -129.7 bits, while the best RNN log-likelihood value is -222.4 bits.\nSurprisingly, the best GLNN value was obtained with a network of size 4; a size-23 network came close second at -129.98 bits.\nNot all GLNN runs find the optimum: there is a cluster of runs around -230 bits, presumably corresponding to the model with independent lengths for a and b blocks, and one run (with 64 units) provided aberrant validation log-likelihood after some point because of overfitting.\nVisual inspection of the output of the best trained GLNN runs, used as generative models, shows that consecutive blocks of a and b indeed have the same or very close lengths, with sometimes an error of ±1 on the length. This imperfection would likely disappear with more than ten training sequences.\nThe kind of internal representation used by the GLNN to reach this result is unclear, especially given the small network size: does it build a kind of base-2 counter, does it take advantage of the analog nature of the units’ activities, or something in between?\nInfluence of the various choices. The difference in performance between GLNNs and RNNs above results from various factors: choices in model design (leakiness and gatedness) and in the training method (backpropagation or a Riemannian gradient). We now try to isolate these factors, by testing various combinations of models (RNNs, GNNs and GLNNs) and training methods.\nIn particular, it is possible to apply invariant training methods to RNNs. The recurrent BPM and recurrent UOP metric are well-defined for RNNs. However, contrary to GNNs and GLNNs, the parameters corresponding to different symbols in the alphabet are not mutually orthogonal, and thus, using them directly would result in a complexity quadratic in the alphabet size, which we deem unacceptable. Therefore, we used the quasi-diagonal reductions of these metrics, as defined in [Oll13]. This still provides training methods that are invariant under reparametrization of the activity of each unit.\nEach model and training method was tested as described above, spanning various values of the hyperparameters (network size and connectivity). For each method we report the best performance found over the hyperparameters.\nThe performance reported is the cumulative regret with respect to the true generating model, a standard measure used in sequential prediction contexts. It is defined as the difference between the log-likelihood of the validation data sequence under the true model used to generate the data, and the log-likelihood of the validation data sequence under the trained model.\nWe also included three sanity checks for reference. Two are text compressors known for their performance (CTW as mentioned above, and the file compressor bzip2), for which, to incorporate the effect of training, we\nreport the number of bits used to compress the concatenation of the training and validation sequences minus the number of bits used to compress the training sequence alone.\nThe third sanity check is a hidden Markov model (HMM), trained using a variety of network sizes as for the neural networks.16 The comparison with HMMs is especially interesting, since these are a classical tool for modelling sequential data.\nThe “classical” training method is as described above for RNNs: diagonal inverse Hessian for the writing parameters w, and backpropagation for the transition parameters; for the latter, parameters like ρiy (for RNNs) or τijy (for GNNs and GLNNs) related to a given symbol y have a learning rate divided by the frequency of y in the training sequence (“frequency-adjusted” backpropagation, which compensates for the number of terms making up the corresponding gradient, and, for RNNs, is equivalent to scaling the input signals). Pure backpropagation was tested but is simply too slow.\nThe results are collected in Table 1. From this table it is clear that an invariant method is the first step to improve performance: RNNs trained with an invariant method beat GNNs and GLNNs trained with a non-invariant method.\nStill, the leaky aspect of GLNNs seems to be necessary to bring the best performance in problems with very long dependencies (the alphabet with insertions and the anbn example). On the other hand, on the problem where dependencies are most local (synthetic music), all network models achieve quite comparable results if trained with an invariant method.\nConclusions and perspectives\nThe viability of GLNNs with Riemannian training to capture complex algorithmic dependencies in symbolic data sequences has been established. Metrics inspired by a Riemannian geometric viewpoint, allow us to write invariant algorithms at an algorithmic cost comparable to backpropagation through time for sparsely connected networks.\nThese metrics bring down the necessary number of gradient steps to a few hundreds in the various examples studied. This approach seems to work with small training samples. Better than state-of-the-art performance has been obtained on difficult synthetic problems.\n16Details as follows. Training is done by the expectation-maximization algorithm. The network is obtained, as for the neural networks, by taking an oriented random graph with a given number of edges per node (including loops); this number of edges per node is set to the alphabet size, because this gives an algorithmic complexity similar to that of the neural networks. Initialization of the transition probabilities is by a Dirichlet(1/2, . . . , 1/2) (i.e., Jeffreys) prior on the edges from a node. Initialization of the production probabilities is done by multiplying the actual frequency of each symbol in the sequence to be modelled, by a random uniform([0; 1]) number.\nIn the experiments, the importance of invariance seems to supercede that of model choice: in our tests, any model with an invariant training algorithm did better than any model with a non-invariant one.\nMore experiments are needed to investigate the isolated effect of each feature of this training procedure (memory effect in the definition of GLNNs, gatedness, and the choice of metric). Other issues in need of investigation are the influence of parameter initialization (especially if some expert knowledge on the time scale of dependencies in the data is available) and a better, invariant dampening procedure. It would also be interesting to acquire insight into the dynamical behavior of GLNNs (ergodicity, multiple equilibrium regimes, etc.) and how it is affected by training. Furthermore, the Riemannian approach can in principle be extended to more complex architectures: testing Riemannian methods for LSTMs seems promising.\nFinally, scalable Riemannian training algorithms should be developed for a fully online “lifelong learning” setting where there is a single training sequence which grows with time and where it is not possible to fully store the past states and signal, so that backpropagation through time is excluded."
    }, {
      "heading" : "A Parameter initialization, the linearized regime,",
      "text" : "and integrating effects in GLNNs\nLet us examine the dynamics of a GLNN, and in particular the linearized regime (the regime in which the connection weights are small). This will provide some insight into the time-integrating effect of the model, and also suggest relevant initializations of the parameter values before launching the gradient ascent, as presented in the algorithm above.\nIn the GLNN evolution equation V t+1j = V t j + ∑ i τijxta t i let us isolate the contributions of i = j and of the always-activated unit i = 0. Substituting atj = s(V t j ) and a t 0 ≡ 1 we get\nV t+1j = V t j + τjjxts(V t j ) + τ0jxt +\n∑\ni6=0, i6=j\nτijxta t i (70)\nSince s(V tj ) is an increasing function of V t j , the contribution i = j provides a feedback loop: if τjjx is negative for all x, then the feedback will be negative, whereas positive τjjx would result in perpetual increase of V t j if the other contributions are ignored. Meanwhile, τ0jxt provides the reaction of unit j to the signal xt.\nFor instance, if we set τjjx = −α for all x with α > 0, τ0jx = β for all x, and all other weights τijx to 0, the dynamics is\nV t+1j = V t j − αs(V tj ) + β (71)\nwhich has a fixed point at V tj = V̄ := s −1(β/α), i.e., atj = β/α (assuming β/α lies in the range of the activation function s). The linearized dynamics\naround this fixed point (V tj close to V̄ ) is\nV t+1j − V̄ ≈ (1− αs′(V̄ )) ( V tj − V̄ )\n(72)\nso that if ∣ ∣ ∣1− αs′(V̄ ) ∣ ∣ ∣ < 1 this fixed point is attractive.\nA more interesting choice is to let\nτjjx = −α, τ0jx = β + ερx (73)\nwith small ε, where ρx is chosen to that the average of ρ over the data xt is 0. Then, the value of V t as a function of t and the data can be found by induction using the linearized dynamics:\nV tj ≈ V̄ + ε ∑\nt′<t\n(1− µ)t−t′ρxt′ (74)\nwhere µ := αs′(V̄ ) (75)\nnamely, the activation level V tj is a linear combination of the past values of the signal xt, with weights exponentially decreasing with time at rate (1− µ).\nThis provides insights into reasonable values of the parameter leading to interesting internal dynamics, to be used at the start of the learning procedure. Indeed, negative values of α would lead to unstability, whereas positive values of α presumably stabilize the network. However, values of α above 1/ sup s′ (= 1 for tanh activation) will provide too much feedback, resulting in non-monotonous V t+1 as a function of V t and an oscillating behavior. Indeed we have found that setting α = 1/(2 sup s′), i.e.,\nτjjx = −α = −1/2 (76)\n(for tanh) for all j and x at startup, yields a good behavior of the network. With τjjx and τ0jx as above, the value of (1−µ) controls the effective time window of the integrating effect: data much older than t− t′ ≫ 1 µ has little weight. Thus 1 µ presumably gives the order of magnitude of the distances t−t′ for which the model can reasonably be expected to capture correlations in the data (at least at startup, since µ will change during learning).\nThe value of µ can be directly controlled through β via µ = αs′(V̄ ) = αs′(s−1(β/α)): for the tanh activation function, this yields\nβ = − √ α(α − µ) (77)\nwhich is used to set β from an arbitrary choice for µ. We have found that using different values of µ for different units yields good results. We have used\nµj = 1/(j + 1) (78)\nfor unit number j (starting at j = 1); this yields a characteristic time of order j and seems to perform well.\nFinally, the “reading rates” ρx are taken at random independently for each unit j in the following way. The value of ε must be small enough to ensure that V tj stays close to Vj (otherwise the linear regime assumption is unjustified), namely, that the sum ε ∑\nt′<t(1−µ)t−t ′ ρxt′ stays small. If each\nρ is roughly of size 1, the sum is ε/µ so taking ε somewhat smaller than µ is reasonable. We have used\nε = µ\n4 (79)\nwhich apparently yields good performance. Finally, ρx is taken at random uniformly in [0; 1] for each symbol x (independently for each unit j), and then shifted by a constant so that the average of ρxt over the training data xt is 0 (namely, the constant ∑\nνxρx is removed from each ρx where νx is the frequency of symbol x in the training data)17.\nThe other transition weights τijx, with i 6= 0, i 6= j, were set to 0 at startup.\nThe explicit initialization values described here are specific to the tanh activation function; however, the reasoning extends to any activation function."
    }, {
      "heading" : "B Derivative of the log-likelihood: Backpropaga-",
      "text" : "tion through time for GLNNs\nLet (xt)t=0,...,T−1 be an observed sequence of T symbols in the alphabet A. Here we compute the derivatives of the log-probability that a GLNN prints (xt) with respect to the GLNN parameters, via the standard backpropagation through time technique.\nGiven a training sequence x = (xt), let Pr(x) be the probability that the model prints (x0, . . . , xT−1). Here, for simplicity we assume that all symbols in the sequence have to be predicted (i.e., χt ≡ 1). The algorithm in Section 2 gives the formulas for the general case.\nProposition 11 (log-likelihood derivative for GLNNs). The derivative of the log-probability of a sequence x = (xt)t=0,...,T−1 with respect to the parameters of a gated leaky neural network is given as follows.\nSetting\nBtj := ∂ log Pr(x)\n∂V tj (80)\n17The choice to use a uniform random variable in [0; 1] rather than, e.g., Gaussian random variables, is justified by the feedback mechanism. Indeed since the activation function s ranges in [0; 1], the feedback term −αs(V tj ) is bounded. If an unbounded signal ρxt can occur at each step, it may take a long time to stabilize. Empirically, using Gaussian rather than bounded random variables seems to decrease performance, confirming this viewpoint.\nwe have the backpropagation relation\nBti = B t+1 i + s ′(V ti )\n\nwixt − ∑\ny\nπt(y)wiy + ∑\nj\nτijxtB t+1 j\n\n (81)\n(initialized with BTj := 0). In particular B 0 j gives the derivative with respect to the initial values V 0j at time 0. The derivatives with respect to the writing weights are\n∂ log Pr(x)\n∂wiy =\n∑\nt\nati (1xt=y − πt(y)) (82)\nand the derivatives with respect to the transition weights are\n∂ log Pr(x)\n∂τijy =\n∑\nt\n1xt=y a t iB t+1 j (83)\nThese relations include the always-activated unit i = 0, ai ≡ 1. The meaning of the partial derivative with respect to V tj is the following:\nif, in the equation V t+1j = V t j + ∑ j τijxta t i defining GLNNs, we artificially introduce a term ε ≪ 1 at unit j at time t, namely, V t+1j = V tj + ∑ j τijxta t i+ε for a single unit at a single time, and let the network evolve normally except for this change, then the value of log PT changes by εB t j +O(ε 2).\nProof. Given a training sequence (xt)t=0,...,T−1 of length T , let P0 := 1 and\nPt+1 := πt(xt)Pt (84)\nso that PT is the probability of printing (x0, . . . , xT−1). By definition of πt we have\nlog Pt+1 = logPi + ∑\ni\natiwixt − log ( ∑\ny\ne ∑ i at i wiy\n)\n(85)\nLet us compute the infinitesimal variations of these quantities under an infinitesimal variation δw, δτ of the parameters. Ultimately we are interested in the variation of log PT , to perform gradient ascent on the parameters.\nBy a first-order Taylor expansion, the variation of logPt+1 satisfies\nδ log Pt+1 = δ log Pt + ∑\ni\natiδwixt + ∑\ni\nwixt δa t i\n− ∑\ny\nπt(y)\n(\n∑\ni\natiδwiy + ∑\ni\nwiyδa t i\n) (86)\nand rearranging and substituting\nδati = s ′(V ti )δV t i (87)\nwhere s′ is the derivative of the activation function, this yields\nδ log Pt+1 = δ log Pt + ∑\ni\nati\n(\nδwixt − ∑\ny\nπt(y)δwiy\n)\n+ ∑\ni\n(\nwixt − ∑\ny\nπt(y)wiy\n)\ns′(V ti )δV t i\n(88)\nConsequently, the variation δ log Pt of logPt can be expressed in terms of the variation of logPt−1, the variations of the parameters w and τ , and the variations of the values V t−1j at time t− 1.\nLet us assume, by backward induction, that we can write the differential of log PT with respect to the parameters, as δ log PT =: δ log Pt + ∑\ni\nBti δV t i +\n∑\ni,y\nCtiyδwiy + ∑\ni,j,y\nDtijyδτijy (89)\nFor t = T this is satisfied with BT = CT = DT = 0. Thus Bti represents the backpropagated value at unit i at time t, and C and D will cumulatively compute the gradient of log PT with respect to the parameters w and τ , namely:\n∂ log Pr(x)\n∂wiy = C0iy (90)\nand ∂ log Pr(x)\n∂τijy = D0ijy (91)\nand moreover B0j will contain the derivatives with respect to the initial levels V 0j .\nUsing the evolution equation V t+1j = V t j + ∑ i τijxta t i we find\nδV t+1j = δV t j +\n∑\ni\nδτijxta t i +\n∑\ni\nτijxts ′(V ti )δV t i (92)\nUsing these relations to go from time t + 1 to time t in (89), namely, expressing δ log Pt+1 in terms of δ log Pt and expanding V\nt+1 in terms of V t, we find\nCtiy = C t+1 iy + 1xt=y a t i − πt(y)ati (93)\nDtijy = D t+1 ijy + 1xt=y a t iB t+1 j (94)\nand\nBti = B t+1 i + s ′(V ti )\n\nwixt − ∑\ny\nπt(y)wiy + ∑\nj\nτijxtB t+1 j\n\n (95)\nfrom which the expressions for C0iy and D 0 ijy follow."
    }, {
      "heading" : "C Fisher metric for the output distribution πt",
      "text" : "Let us compute the Fisher norm of the variation δπ of π resulting from a change δEty in the values of E t y = ∑ i a t iwiy. (Such a change in E can result from a change in the writing weights w or the activities a; this will be used to compute the metric on the writing weights and the transition weights, respectively.) The effect of a change δEt on log πt is\nδ log πt(y) = ∑\ny′\n∂ log πt(y)\n∂Ety′ δEty′ (96)\nand the norm of this δπt in Fisher metric is\n‖δπt‖nat = Ey∼πt(δ log πt(y))2 (97)\n= Ey∼πt\n\n\n∑\ny′,y′′\n∂ log πt(y)\n∂Ey′\n∂ log πt(y)\n∂Ey′′ δEty′ δE t y′′\n\n (98)\nBy a standard formula for exponential families of probability distributions we find:\n∂ log πt(y)\n∂Ey′ = 1y=y′ − πt(y′) (99)\nso that\nEy∼πt\n[\n∂ log πt(y)\n∂Ey′\n∂ log πt(y)\n∂Ey′′\n]\n= Ey∼πt [ (1y=y′ − πt(y′))(1y=y′′ − πt(y′′)) ]\n(100)\n= πt(y ′)(1y′=y′′ − πt(y′′)) (101)\n(this is also18 the Hessian of − log πt(y) with respect to the values Et). Consequently, the Fisher metric for πt, expressed in terms of the variations δE t y, is ‖δπt‖2nat = ∑\ny\nπt(y)(δE t y) 2 − ∑\ny,y′\nπt(y)πt(y ′)δEtyδE t y′ (102)"
    } ],
    "references" : [ {
      "title" : "Natural gradient works efficiently in learning",
      "author" : [ "Shun-ichi Amari" ],
      "venue" : "Neural Comput.,",
      "citeRegEx" : "Amari.,? \\Q1998\\E",
      "shortCiteRegEx" : "Amari.",
      "year" : 1998
    }, {
      "title" : "Methods of information geometry, volume 191 of Translations of Mathematical Monographs",
      "author" : [ "Shun-ichi Amari", "Hiroshi Nagaoka" ],
      "venue" : "American Mathematical Society, Providence, RI,",
      "citeRegEx" : "Amari and Nagaoka.,? \\Q2000\\E",
      "shortCiteRegEx" : "Amari and Nagaoka.",
      "year" : 2000
    }, {
      "title" : "Adaptive method of realizing natural gradient learning for multilayer perceptrons",
      "author" : [ "Shun-ichi Amari", "Hyeyoung Park", "Kenji Fukumizu" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "Amari et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Amari et al\\.",
      "year" : 2000
    }, {
      "title" : "Alpha-nets: A recurrent ’neural’ network architecture with a hidden Markov model interpretation",
      "author" : [ "John S. Bridle" ],
      "venue" : "Speech Communication,",
      "citeRegEx" : "Bridle.,? \\Q1990\\E",
      "shortCiteRegEx" : "Bridle.",
      "year" : 1990
    }, {
      "title" : "Learning long-term dependencies with gradient descent is difficult",
      "author" : [ "Y. Bengio", "P. Simard", "P. Frasconi" ],
      "venue" : "Neural Networks, IEEE Transactions on,",
      "citeRegEx" : "Bengio et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Bengio et al\\.",
      "year" : 1994
    }, {
      "title" : "Adaptive subgradient methods for online learning and stochastic optimization",
      "author" : [ "John C. Duchi", "Elad Hazan", "Yoram Singer" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Duchi et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Duchi et al\\.",
      "year" : 2011
    }, {
      "title" : "Sequence transduction with recurrent neural networks",
      "author" : [ "Alex Graves" ],
      "venue" : null,
      "citeRegEx" : "Graves.,? \\Q2012\\E",
      "shortCiteRegEx" : "Graves.",
      "year" : 2012
    }, {
      "title" : "Generating sequences with recurrent neural networks",
      "author" : [ "Alex Graves" ],
      "venue" : null,
      "citeRegEx" : "Graves.,? \\Q2013\\E",
      "shortCiteRegEx" : "Graves.",
      "year" : 2013
    }, {
      "title" : "Learning precise timing with lstm recurrent networks",
      "author" : [ "Felix A. Gers", "Nicol N. Schraudolph", "Jürgen Schmidhuber" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "Gers et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Gers et al\\.",
      "year" : 2003
    }, {
      "title" : "Hierarchical recurrent neural networks for long-term dependencies",
      "author" : [ "Salah El Hihi", "Yoshua Bengio" ],
      "venue" : "Advances in Neural Information Processing Systems 8,",
      "citeRegEx" : "Hihi and Bengio.,? \\Q1995\\E",
      "shortCiteRegEx" : "Hihi and Bengio.",
      "year" : 1995
    }, {
      "title" : "Long short-term memory",
      "author" : [ "Sepp Hochreiter", "Jürgen Schmidhuber" ],
      "venue" : "Neural Computation,",
      "citeRegEx" : "Hochreiter and Schmidhuber.,? \\Q1997\\E",
      "shortCiteRegEx" : "Hochreiter and Schmidhuber.",
      "year" : 1997
    }, {
      "title" : "Tutorial on training recurrent neural networks, covering BPTT, RTRL, EKF and the ‘‘echo state network’",
      "author" : [ "Herbert Jaeger" ],
      "venue" : "Technical Report 159,",
      "citeRegEx" : "Jaeger.,? \\Q2002\\E",
      "shortCiteRegEx" : "Jaeger.",
      "year" : 2002
    }, {
      "title" : "A clockwork RNN",
      "author" : [ "Jan Koutník", "Klaus Greff", "Faustino J. Gomez", "Jürgen Schmidhuber" ],
      "venue" : "In Proceedings of the 31th International Conference on Machine Learning,",
      "citeRegEx" : "Koutník et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Koutník et al\\.",
      "year" : 2014
    }, {
      "title" : "Deep learning via hessian-free optimization",
      "author" : [ "James Martens" ],
      "venue" : "Proceedings of the 27th International Conference on Machine Learning",
      "citeRegEx" : "Martens.,? \\Q2010\\E",
      "shortCiteRegEx" : "Martens.",
      "year" : 2010
    }, {
      "title" : "Training deep and recurrent neural networks with Hessian-free optimization",
      "author" : [ "James Martens", "Ilya Sutskever" ],
      "venue" : "Neural Networks: Tricks of the Trade,",
      "citeRegEx" : "Martens and Sutskever.,? \\Q2012\\E",
      "shortCiteRegEx" : "Martens and Sutskever.",
      "year" : 2012
    }, {
      "title" : "Riemannian metrics for neural networks I: feedforward networks",
      "author" : [ "Yann Ollivier" ],
      "venue" : null,
      "citeRegEx" : "Ollivier.,? \\Q2013\\E",
      "shortCiteRegEx" : "Ollivier.",
      "year" : 2013
    }, {
      "title" : "Learning internal representations by error propagation",
      "author" : [ "D.E. Rumelhart", "G.E. Hinton", "R.J. Williams" ],
      "venue" : null,
      "citeRegEx" : "Rumelhart et al\\.,? \\Q1987\\E",
      "shortCiteRegEx" : "Rumelhart et al\\.",
      "year" : 1987
    }, {
      "title" : "Topmoumoute online natural gradient algorithm",
      "author" : [ "Nicolas Le Roux", "Pierre-Antoine Manzagol", "Yoshua Bengio" ],
      "venue" : null,
      "citeRegEx" : "Roux et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Roux et al\\.",
      "year" : 2007
    } ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : "Recurrent neural networks are powerful models for sequential data, able to represent complex dependencies in the sequence that simpler models such as hidden Markov models cannot handle. Yet they are notoriously hard to train. Here we introduce a training procedure using a gradient ascent in a Riemannian metric: this produces an algorithm independent from design choices such as the encoding of parameters and unit activities. This metric gradient ascent is designed to have an algorithmic cost close to backpropagation through time for sparsely connected networks. We use this procedure on gated leaky neural networks (GLNNs), a variant of recurrent neural networks with an architecture inspired by finite automata and an evolution equation inspired by continuous-time networks. GLNNs trained with a Riemannian gradient are demonstrated to effectively capture a variety of structures in synthetic problems: basic block nesting as in context-free grammars (an important feature of natural languages, but difficult to learn), intersections of multiple independent Markov-type relations, or long-distance relationships such as the distant-XOR problem. This method does not require adjusting the network structure or initial parameters: the network used is a sparse random graph and the initialization is identical for all problems considered. The problem considered here is to learn a probabilistic model for an observed sequence of symbols (x0, . . . , xt, . . .) over a finite alphabet A. Such a model can be used for prediction, compression, or generalization. Hidden Markov models (HMMs) are frequently used in such a setting. However, the kind of algorithmic structures HMMs can represent is limited because of the underlying finite automaton structure. Examples of simple sequential data that cannot be, or cannot conveniently be, represented by HMMs are discussed below; for instance, subsequence insertions, or intersections of multiple independent constraints.",
    "creator" : "gnuplot 4.6 patchlevel 3"
  }
}