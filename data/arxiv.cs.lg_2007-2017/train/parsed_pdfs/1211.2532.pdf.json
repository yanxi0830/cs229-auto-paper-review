{
  "name" : "1211.2532.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Iterative Thresholding Algorithm for Sparse Inverse Covariance Estimation",
    "authors" : [ "Dominique Guillot", "Bala Rajaratnam", "Benjamin T. Rolfs" ],
    "emails" : [ "dguillot@stanford.edu", "brajarat@stanford.edu", "benrolfs@stanford.edu", "arian.maleki@rice.edu", "ianw@stanford.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Datasets from a wide range of modern research areas are increasingly high dimensional, which presents a number of theoretical and practical challenges. A fundamental example is the problem of estimating the covariance matrix from a dataset of n samples {X(i)}ni=1, drawn i.i.d from a p-dimensional, zero-mean, Gaussian distribution with covariance matrix Σ ∈ Sp++, X(i) ∼ Np(0,Σ), where S p ++ denotes the space of p × p symmetric, positive definite matrices. When n ≥ p the maximum likelihood covariance estimator Σ̂ is the sample covariance matrix S = 1\nn ∑n i=1X (i)X(i) T . A problem however arises when n < p, due\n∗Equal contributors.\nar X\niv :1\n21 1.\n25 32\nv3 [\nst at\n.C O\nto the rank-deficiency in S. In this sample deficient case, common throughout several modern applications such as genomics, finance, and earth sciences, the matrix S is not invertible, and thus cannot be directly used to obtain a well-defined estimator for the inverse covariance matrix Ω := Σ−1.\nA related problem is the inference of a Gaussian graphical model ([33, 18]), that is, a sparsity pattern in the inverse covariance matrix, Ω. Gaussian graphical models provide a powerful means of dimensionality reduction in high-dimensional data. Moreover, such models allow for discovery of conditional independence relations between random variables since, for multivariate Gaussian data, sparsity in the inverse covariance matrix encodes conditional independences. Specifically, if X = (Xi) p i=1 ∈ Rp is distributed as X ∼ Np(0,Σ), then (Σ−1)ij = Ωij = 0 ⇐⇒ Xi ⊥⊥ Xj|{Xk}k 6=i,j, where the notation A ⊥⊥ B|C denotes the conditional independence of A and B given the set of variables C (see [33, 18]). If a dataset, even one with n p is drawn from a normal distribution with sparse inverse covariance matrix Ω, the inverse sample covariance matrix S−1 will almost surely be a dense matrix, although the estimates for those Ωij which are equal to 0 may be very small in magnitude. As sparse estimates of Ω are more robust than S−1, and since such sparsity may yield easily interpretable models, there exists significant impetus to perform sparse inverse covariance estimation in very high dimensional low sample size settings.\nBanerjee et al. [1] proposed performing such sparse inverse covariance estimation by solving the `1-penalized maximum likelihood estimation problem,\nΘ∗ρ = arg min Θ∈Sp++ − log det Θ + 〈S,Θ〉+ ρ ‖Θ‖1 , (1)\nwhere ρ > 0 is a penalty parameter, 〈S,Θ〉 = Tr (SΘ), and ‖Θ‖1 = ∑\ni,j |Θij|. For ρ > 0, Problem (1) is strongly convex and hence has a unique solution, which lies in the positive definite cone Sp++ due to the log det term, and is hence invertible. Moreover, the `1 penalty induces sparsity in Θ∗ρ, as it is the closest convex relaxation of the 0 − 1 penalty, ‖Θ‖0 =∑\ni,j I(Θij 6= 0), where I(·) is the indicator function [5]. The unique optimal point of problem (1), Θ∗ρ, is both invertible (for ρ > 0) and sparse (for sufficiently large ρ), and can be used as an inverse covariance matrix estimator.\nIn this paper, a proximal gradient method for solving Problem (1) is proposed. The resulting “graphical iterative shrinkage thresholding algorithm”, or G-ISTA, is shown to converge at a\nlinear rate to Θ∗ρ, that is, its iterates Θt are proven to satisfy∥∥Θt+1 −Θ∗ρ∥∥F ≤ s ∥∥Θt −Θ∗ρ∥∥F , (2) for a fixed worst-case contraction constant s ∈ (0, 1), where ‖·‖F denotes the Frobenius norm. The convergence rate s is provided explicitly in terms of S and ρ, and importantly, is related to the condition number of Θ∗ρ.\nWe also note that methods outside the penalized likelihood framework have been proposed in the context of graphical models. In particular graphical model estimation and related problems has also be undertaken either in the Bayesian or testing frameworks. The reader is referred to the theoretical work of [10, 13, 14, 17, 19, 28], among others, for greater detail.\nThe paper is organized as follows. Section 2 describes prior work related to solution of Problem (1). The G-ISTA algorithm is formulated in Section 3. Section 4 contains the convergence proofs of this algorithm, which constitutes the primary mathematical result of this paper. Numerical results are presented in Section 5, and concluding remarks are made in Section 6."
    }, {
      "heading" : "2 Prior Work",
      "text" : "While several excellent general convex solvers exist (for example, [12] and [4]), these are not always adept at handling high dimensional problems (i.e., p > 1000). As many modern datasets have several thousands of variables, numerous authors have proposed efficient algorithms designed specifically to solve the `1-penalized sparse maximum likelihood covariance estimation problem (1).\nThese can be broadly categorized as either primal or dual methods. Following the literature, we refer to primal methods as those which directly solve Problem (1), yielding a concentration estimate. Dual methods [1] yield a covariance matrix by solving the constrained problem,\nminimize U∈Rp×p\n− log det(S + U)− p\nsubject to ‖U‖∞ ≤ ρ, (3)\nwhere the primal and dual variables are related by Θ = (S + U)−1. Both the primal and dual problems can be solved using block methods (also known as “row by row” methods), which sequentially optimize one row/column of the argument at each step until convergence. The primal and dual block problems both reduce to `1-penalized regressions, which can be\nsolved very efficiently."
    }, {
      "heading" : "2.1 Dual Methods",
      "text" : "A number of dual methods for solving Problem (1) have been proposed in the literature. Banerjee et al. [1] consider a block coordinate descent algorithm to solve the block dual problem, which reduces each optimization step to solving a box-constrained quadratic program. Each of these quadratic programs is equivalent to performing a “lasso” (`1-regularized) regression. Friedman et al. [11] iteratively solve the lasso regression as described in [1], but do so using coordinate-wise descent. Their widely used solver, known as the graphical lasso (glasso) is implemented on CRAN. Global convergence rates of these block coordinate methods are unknown. D’Aspremont et al. [9] use Nesterov’s smooth approximation scheme, which produces an ε-optimal solution in O(1/ε) iterations. A variant of Nesterov’s smooth method is shown to have a O(1/ √ ε) iteration complexity in [20, 21]."
    }, {
      "heading" : "2.2 Primal Methods",
      "text" : "Interest in primal methods for solving Problem (1) has been growing for many reasons. One important reason stems from the fact that convergence within a certain tolerance for the dual problem does not necessarily imply convergence within the same tolerance for the primal.\nYuan and Lin [36] use interior point methods based on the max-det problem studied in [32]. Yuan [37] use an alternating-direction method, while Scheinberg et al. [30] proposes a similar method and show a sublinear convergence rate. Mazumder and Hastie [23] consider blockcoordinate descent approaches for the primal problem, similar to the dual approach taken in [11]. Mazumder and Agarwal [22] also solve the primal problem with block-coordinate descent, but at each iteration perform a partial as opposed to complete block optimization, resulting in a decreased computational complexity per iteration. Convergence rates of these primal methods have not been considered in the literature and hence theoretical guarantees are not available. Hsieh et al. [16] propose a second-order proximal point algorithm, called QUIC, which converges superlinearly locally around the optimum."
    }, {
      "heading" : "3 Methodology",
      "text" : "In this section, the graphical iterative shrinkage thresholding algorithm (G-ISTA) for solving the primal problem (1) is presented. A rich body of mathematical and numerical work\nexists for general iterative shrinkage thresholding and related methods; see, in particular, [3, 8, 24, 25, 26, 31]. A brief description is provided here."
    }, {
      "heading" : "3.1 General Iterative Shrinkage Thresholding (ISTA)",
      "text" : "Iterative shrinkage thresholding algorithms (ISTA) are general first-order techniques for solving problems of the form\nminimize x∈X F (x) := f(x) + g(x), (4)\nwhere X is a Hilbert space with inner product 〈·, ·〉 and associated norm ‖·‖, f : X → R is a continuously differentiable, convex function, and g : X → R is a lower semi-continuous, convex function, not necessarily smooth. The function f is also often assumed to have Lipschitz-continuous gradient ∇f , that is, there exists some constant L > 0 such that\n‖∇f(x1)−∇f(x2)‖ ≤ L ‖x1 − x2‖ (5)\nfor any x1, x2 ∈ X .\nFor a given lower semi-continuous convex function g, the proximity operator of g, denoted by proxg : X → X , is given by\nproxg(x) = arg min y∈X\n{ g(y) + 1\n2 ‖x− y‖2\n} , (6)\nIt is well known (for example, [8]) that x∗ ∈ X is an optimal solution of problem (4) if and only if\nx∗ = proxζg(x ∗ − ζ∇f(x∗)) (7)\nfor any ζ > 0. The above characterization suggests a method for optimizing problem (4) based on the iteration\nxt+1 = proxζtg (xt − ζt∇f(xt)) (8)\nfor some choice of step size, ζt. This simple method is referred to as an iterative shrinkage thresholding algorithm (ISTA). For a step size ζt ≤ 1L , the ISTA iterates xt are known to\nsatisfy\nF (xt)− F (x∗) ' O ( 1\nt\n) ,∀t, (9)\nwhere x∗ is some optimal point, which is to say, they converge to the space of optimal points at a sublinear rate. If no Lipschitz constant L for ∇f is known, the same convergence result still holds for ζt chosen such that\nf(xt+1) ≤ Qζt(xt+1, xt), (10)\nwhere Qζ(·, ·) : X × X → R is a quadratic approximation to f , defined by\nQζ(x, y) = f(y) + 〈x− y,∇f(y)〉+ 1\n2ζ ‖x− y‖2 . (11)\nSee [3] for more details.\n3.2 Graphical Iterative Shrinkage Thresholding (G-ISTA)\nThe general method described in Section 3.1 can be adapted to the sparse inverse covariance estimation Problem (1). Using the notation introduced in Problem (4), define f, g : Sp++ → R by f(X) = − log det(X)+ 〈S,X〉 and g(X) = ρ ‖X‖1. Both are continuous convex functions defined on Sp++. Although the function ∇f(X) = S −X−1 is not Lipschitz continuous over Sp++, it is Lipschitz continuous within any compact subset of S p ++ (See Lemma 2 of the Supplemental section).\nLemma 1 ([1, 20]). The solution of Problem (1), Θ∗ρ, satisfies αI Θ∗ρ βI, for\nα = 1\n‖S‖2 + pρ , β= min\n{ p− αTr(S)\nρ , γ\n} , (12)\nand\nγ =\n{ min{1T |S−1|1, (p− ρ√pα) ‖S−1‖2 − (p− 1)α} if S ∈ S p ++\n21T ∣∣(S + ρ\n2 I)−1 ∣∣1− Tr((S + ρ 2 I)−1) otherwise,\n(13)\nwhere I denotes the p×p dimensional identity matrix and 1 denotes the p-dimensional vector of ones.\nNote that f + g as defined is a continuous, strongly convex function on Sp++. Moreover, by Lemma 2 of the supplemental section, f has a Lipschitz continuous gradient when restricted\nto the compact domain aI Θ bI. Hence, f and g as defined meet the conditions described in Section 3.1.\nThe proximity operator of ρ ‖X‖1 for ρ > 0 is the soft-thresholding operator, ηρ : Rp×p → Rp×p, defined entrywise by\n[ηρ(X)]i,j = sgn(Xi,j) (|Xi,j| − ρ)+ , (14)\nwhere for some x ∈ R, (x)+ := max(x, 0) (see [8]). Finally, the quadratic approximation Qζt of f , as in equation (11), is given by\nQζt(Θt+1,Θt) = − log det(Θt) + 〈S,Θt〉+ 〈Θt+1 −Θt, S −Θ−1t 〉+ 1\n2ζt ‖Θt+1 −Θt‖2F . (15)\nThe G-ISTA algorithm for solving Problem (1) is given in Algorithm 1. As in [3], the algorithm uses a backtracking line search for the choice of step size. The procedure terminates when a pre-specified duality gap is attained. The authors found that an initial estimate of Θ0 satisfying [Θ0]ii = (Sii+ρ) −1 works well in practice. Note also that the positive definite check of Θt+1 during Step (1) of Algorithm 1 is accomplished using a Cholesky decomposition, and the inverse of Θt+1 is computed using that Cholesky factor.\nAlgorithm 1: G-ISTA for Problem (1) input : Sample covariance matrix S, penalty parameter ρ, tolerance ε, backtracking constant c ∈ (0, 1), initial step size ζ1,0, initial iterate Θ0. Set ∆ := 2ε. while ∆ > ε do\n(1) Line search: Let ζt be the largest element of {cjζt,0}j=0,1,... so that for Θt+1 = ηζtρ ( Θt − ζt(S −Θ−1t ) ) , the following are satisfied:\nΘt+1 0 and f(Θt+1) ≤ Qζt(Θt+1,Θt),\nfor Qζt as defined in (15). (2) Update iterate: Θt+1 = ηζtρ ( Θt − ζt(S −Θ−1t ) ) (3) Set next initial step, ζt+1,0. See Section 3.2.1. (4) Compute duality gap:\n∆ = − log det(S + Ut+1)− p− log det Θt+1 + 〈S,Θ〉+ ρ ‖Θt+1‖1 ,\nwhere (Ut+1)i,j = min{max{([Θ−1t+1]i,j − Si,j),−ρ}, ρ}. end output: ε-optimal solution to problem (1), Θ∗ρ = Θt+1."
    }, {
      "heading" : "3.2.1 Choice of initial step size, ζ0",
      "text" : "Each iteration of Algorithm 1 requires an initial step size, ζ0. The results of Section 4 guarantee that any ζ0 ≤ λmin(Θt)2 will be accepted by the line search criteria of Step 1 in the next iteration. However, in practice this choice of step is overly cautious; a much larger step can often be taken. Our implementation of Algorithm 1 chooses the Barzilai-Borwein step [2]. This step, given by\nζt+1,0 = Tr ((Θt+1 −Θt)(Θt+1 −Θt))\nTr ((Θt+1 −Θt)(Θ−1t −Θ−1t+1)) , (16)\nis also used in the SpaRSA algorithm [35], and approximates the Hessian around Θt+1. If a certain number of maximum backtracks do not result in an accepted step, G-ISTA takes the safe step, λmin(Θt) 2. Such a safe step can be obtained from λmax(Θ −1 t ), which in turn can be quickly approximated using power iteration."
    }, {
      "heading" : "4 Convergence Analysis",
      "text" : "In this section, linear convergence of Algorithm 1 is discussed. Throughout the section, Θt (t = 1, 2, . . . ) denote the iterates of Algorithm 1, and Θ∗ρ the optimal solution to Problem (1) for ρ > 0. The minimum and maximum eigenvalues of a symmetric matrix A are denoted by λmin(A) and λmax(A), respectively. Theorem 1. Assume that the iterates Θt of Algorithm 1 satisfy aI Θt bI,∀t for some fixed constants 0 < a < b. If ζt ≤ a2,∀t, then∥∥Θt+1 −Θ∗ρ∥∥F ≤ max{ ∣∣∣∣1− ζtb2 ∣∣∣∣ , ∣∣∣∣1− ζta2\n∣∣∣∣} ∥∥Θt −Θ∗ρ∥∥F . (17) Furthermore,\n1. The step size ζt which yields an optimal worst-case contraction bound s(ζt) is ζ = 2\na−2+b−2 .\n2. The optimal worst-case contraction bound corresponding to ζ = 2 a−2+b−2 is given by\ns(ζ) : = 1− 2 1 + b 2\na2\nProof. A direct proof is given in the appendix. Note that linear convergence of proximal gradient methods for strongly convex objective functions in general has already been proven\n(see Supplemental section).\nIt remains to show that there exist constants a and b which bound the eigenvalues of Θt,∀t. The existence of such constants follows directly from Theorem 1, as Θt lie in the bounded domain {Θ ∈ Sp++ : f(Θ) + g(Θ) < f(Θ0) + g(Θ0)}, for all t. However, it is possible to specify the constants a and b to yield an explicit rate; this is done in Theorem 2.\nTheorem 2. Let ρ > 0, define α and β as in Lemma 1, and assume ζt ≤ α2,∀t. Then the iterates Θt of Algorithm 1 satisfy αI Θt b′I,∀t, with b′ = ∥∥Θ∗ρ∥∥2 + ∥∥Θ0 −Θ∗ρ∥∥F ≤ β + √ p(β + α).\nProof. See the Supplementary section.\nImportantly, note that the bounds of Theorem 2 depend explicitly on the bound of Θ∗ρ, as given by Lemma 1. These eigenvalue bounds on Θt+1, along with Theorem 1, provide a closed form linear convergence rate for Algorithm 1. This rate depends only on properties of the solution.\nTheorem 3. Let α and β be as in Lemma 1. Then for a constant step size ζt := ζ < α 2, the iterates of Algorithm 1 converge linearly with a rate of\ns(ζ) = 1− 2α 2\nα2 + (β + √ p(β − α))2 < 1 (18)\nProof. By Theorem 2, for ζ < α2, the iterates Θt satisfy\nαI Θt (∥∥Θ∗ρ∥∥2 + ∥∥Θ0 −Θ∗ρ∥∥F) I\nfor all t. Moreover, since αI Θ∗ βI, if αI Θ0 βI (for instance, by taking Θ0 = (S + ρI)\n−1 or some multiple of the identity) then this can be bounded as:∥∥Θ∗ρ∥∥2 + ∥∥Θ0 −Θ∗ρ∥∥F ≤ β +√p ∥∥Θ0 −Θ∗ρ∥∥2 (19) ≤ β +√p(β − α). (20)\nTherefore,\nαI Θt (β + √ p(β − α)) I, (21)\nand the result follows from Theorem 1.\nRemark 1. Note that the contraction constant (equation 18) of Theorem 3 is closely related to the condition number of Θ∗ρ,\nκ(Θ∗ρ) = λmax(Θ\n∗ ρ)\nλmin(Θ ∗ ρ) ≤ β α\nas\n1− 2α 2\nα2 + (β + √ p(β − α))2\n≥ 1− 2α 2\nα2 + β2 ≥ 1− 2κ(Θ∗ρ)−2. (22)\nTherefore, the worst case bound becomes close to 1 as the conditioning number of Θ∗ρ increases.\nIt is important to compare the above convergence results to those that have been recently established. In particular, the useful, recent QUIC method [16] warrants a discussion. As soon as the sign pattern of its iterates match that of the true optimum, the non-smooth problem becomes effectively smooth and the QUIC algorithm reduces to a Newton method. At this point, QUIC converges quadratically; however, this is a very local property, and no overall complexity bounds have been specified for QUIC. This can be contrasted with our results, which take advantage of existing bounds on the optimal solution to yield global convergence (i.e., that we can always specify a starting point which meets our conditions). We also note that convergence rates have not been established for the glasso. However, QUIC and glasso can all be very fast in appropriate settings. Each brings a useful addition to the literature by taking advantage of different structural elements (block structure for glasso, second order approaches for QUIC, and conditioning bounds for G-ISTA). We feel there is no silver bullet; each method outperforms the others in certain settings."
    }, {
      "heading" : "5 Numerical Results",
      "text" : "In this section, we provide numerical results for the G-ISTA algorithm. In Section 5.2, the theoretical results of Section 4 are demonstrated. Section 5.3 compares running times of the G-ISTA, glasso [11], and QUIC [16] algorithms. All algorithms were implemented in C++, and run on an Intel i7− 2600k 3.40GHz× 8 core with 16 GB of RAM."
    }, {
      "heading" : "5.1 Synthetic Datasets",
      "text" : "Synthetic data for this section was generated following the method used by [21, 22]. For a fixed p, a p dimensional inverse covariance matrix Ω was generated with off-diagonal entries drawn i.i.d from a uniform(−1, 1) distribution. These entries were set to zero with some fixed probability (in this case, either 0.97 or 0.85 to simulate a very sparse and a somewhat sparse model). Finally, a multiple of the identity was added to the resulting matrix so that the smallest eigenvalue was equal to 1. In this way, Ω was insured to be sparse, positive definite, and well-conditioned. Datsets of n samples were then generated by drawing i.i.d. samples from a Np(0,Ω−1) distribution. For each value of p and sparsity level of Ω, n = 1.2p and n = 0.2p were tested, to represent both the n < p and n > p cases."
    }, {
      "heading" : "5.2 Demonstration of Convergence Rates",
      "text" : "The linear convergence rate derived for G-ISTA in Section 4 was shown to be heavily dependent on the conditioning of the final estimator. To demonstrate these results, G-ISTA was run on a synthetic dataset, as described in Section 5.1, with p = 500 and n = 300. Regularization parameters of ρ = 0.75, 0.1, 0.125, 0.15, and 0.175 were used. Note as ρ increases, Θ∗ρ generally becomes better conditioned. For each value of ρ, the numerical optimum was computed to a duality gap of 10−10 using G-ISTA. These values of ρ resulted in sparsity levels of 81.80%, 89.67%, 94.97%, 97.82%, and 99.11%, respectively. G-ISTA was then run again, and\nthe Frobenius norm argument errors at each iteration were stored. These errors were plotted on a log scale for each value of ρ to demonstrate the dependence of the convergence rate on condition number. See Figure 1, which clearly demonstrates the effects of conditioning."
    }, {
      "heading" : "5.3 Timing Comparisons",
      "text" : "The G-ISTA, glasso, and QUIC algorithms were run on synthetic datasets (real datasets are presented in the Supplemental section) of varying p, n and with different levels of regularization, ρ. All algorithms were run to ensure a fixed duality gap, here taken to be 10−5. This comparison used efficient C++ implementations of each of the three algorithms investigated. The implementation of G-ISTA was adapted from the publicly available C++ implementation of QUIC Hsieh et al. [16]. Running times were recorded and are presented in Table 1. Further comparisons are presented in the Supplementary section.\nRemark 2. The three algorithms variable ability to take advantage of multiple processors is an important detail. The times presented in Table 1 are wall times, not CPU times. The comparisons were run on a multicore processor, and it is important to note that the Cholesky decompositions and inversions required by both G-ISTA and QUIC take advantage of multiple\ncores. On the other hand, the p2 dimensional lasso solve of QUIC and p-dimensional lasso solve of glasso do not. For this reason, and because Cholesky factorizations and inversions make up the bulk of the computation required by G-ISTA, the CPU time of G-ISTA was typically greater than its wall time by a factor of roughly 4. The CPU and wall times of QUIC were more similar; the same applies to glasso."
    }, {
      "heading" : "6 Conclusion",
      "text" : "In this paper, a proximal gradient method was applied to the sparse inverse covariance problem. Linear convergence was discussed, with a fixed closed-form rate. Numerical results have also been presented, comparing G-ISTA to the widely-used glasso algorithm and the newer, but very fast, QUIC algorithm. These results indicate that G-ISTA is competitive, in particular for values of ρ which yield sparse, well-conditioned estimators. The G-ISTA algorithm was very fast on the synthetic examples of Section 5.3, which were generated from well-conditioned models. For poorly conditioned models, QUIC is very competitive. The Supplemental section gives two real datasets which demonstrate this. For many practical applications however, obtaining an estimator that is well-conditioned is important ([29, 34]). To conclude, although second-order methods for the sparse inverse covariance estimation problem have recently been shown to perform well, simple first-order methods cannot be ruled out, as they can also be very competitive in many cases.\nAcknowledgments: Dominique Guillot was supported in part by the National Science Foundation under Grant No. DMS-1106642. Bala Rajaratnam was supported in part by the National Science Foundation under Grant Nos. DMS-0906392 (ARRA), DMS-CMG-1025465, AGS-1003823, DMS-1106642 and grants NSA H98230-11-1-0194, DARPA-YFA N66001-11-14131, and SUWIEVP10-SUFSC10-SMSCVISG0906. Benjamin Rolfs was supported in part by the Department of Energy Office of Science Graduate Fellowship Program DE-AC0506OR23100 (ARRA) and NSF grant AGS-1003823."
    }, {
      "heading" : "A Supplementary material",
      "text" : "A.1 Lipschitz Continuity of ∇f(X)\nLemma 2. For any X, Y ∈ Sp++,\n1 b2 ‖X − Y ‖2 ≤ ∥∥X−1 − Y −1∥∥ 2 ≤ 1 a2 ‖X − Y ‖2 ,\nwhere a = min{λmin(X), λmin(Y )} and b = max{λmax(X), λmax(Y )}.\nProof. To prove the right-hand side inequality, notice that\nX−1 − Y −1 = X−1(Y −X)Y −1.\nThus, ∥∥X−1 − Y −1∥∥ 2 = ∥∥X−1(Y −X)Y −1∥∥ 2\n≤ ∥∥X−1∥∥\n2 ‖X − Y ‖2 ∥∥Y −1∥∥ 2\n= λmax(X −1)λmax(Y −1) ‖X − Y ‖2 = 1\nλmin(X)\n1\nλmin(Y ) ‖X − Y ‖2\n≤ 1 a2 ‖X − Y ‖2 .\nTo prove the left inequality, note first that\nY −X = X(X−1 − Y −1)Y.\nTherefore,\n‖X − Y ‖2 = ∥∥X(X−1 − Y −1)Y ∥∥\n2 ≤ ‖X‖2 ∥∥X−1 − Y −1∥∥ 2 ‖Y ‖2\n= λmax(X)λmax(Y ) ∥∥X−1 − Y −1∥∥\n2 ≤ b2 ∥∥X−1 − Y −1∥∥\n2 .\nThis shows that ∥∥X−1 − Y −1∥∥ 2 ≥ 1 b2 ‖X − Y ‖2 and concludes the proof.\nThe function ∇f(X) = S −X−1 is Lipschitz continuous on any compact domain, since for X, Y ∈ Sp++ such that aI X, Y bI,\n‖∇f(X)−∇f(Y )‖F = ∥∥X−1 − Y −1∥∥\nF ≤ √p ∥∥X−1 − Y −1∥∥\n2\n≤ √ p\na2 ‖X − Y ‖2\n≤ √ p\na2 ‖X − Y ‖F .\nA.2 Proof of Theorem 1\nWe now provide the proof of Theorem 1. Lemma 3. Let Θt be as in Algorithm 1 and let Θ ∗ ρ be the optimal point of problem (1). Also, define\nb := max { λmax(Θt), λmax(Θ ∗ ρ) } , a:= min { λmin(Θt), λmin(Θ ∗ ρ) } .\nThen ∥∥Θt+1 −Θ∗ρ∥∥F ≤ max{ ∣∣∣∣1− ζtb2 ∣∣∣∣ , ∣∣∣∣1− ζta2 ∣∣∣∣} ∥∥Θt −Θ∗ρ∥∥F .\nProof. By construction in Algorithm 1,\nΘt+1 = ηζtρ ( (Θt − ζt(S −Θ−1t ) ) Moreover, as Θ∗ρ is a fixed point of the ISTA iteration [8, Prop. 3.1], it satisfies\nΘ∗ρ = ηζtρ ( Θ∗ρ − ζt(S − (Θ∗ρ)−1) ) .\nThe soft-thresholding operator ηρ(·) is a proximity operator corresponding to ρ ‖·‖1. Since prox operators are non-expansive [8, Lemma 2.2], it follows that:∥∥Θt+1 −Θ∗ρ∥∥F = ∥∥ηζtρ (Θt − ζt(S −Θ−1t ))− ηζtρ (Θ∗ρ − ζt(S − (Θ∗ρ)−1))∥∥F\n≤ ∥∥Θt − ζt(S −Θ−1t )− (Θ∗ρ − ζt(S − (Θ∗ρ)−1))∥∥F\n= ∥∥(Θt + ζtΘ−1t )− (Θ∗ρ + ζt(Θ∗ρ)−1)∥∥F\nTo bound the latter expression, recall that if h : U ⊂ Rn → Rm is a differentiable mapping,\nwith x, y ∈ U , and cx+ (1− c)y ∈ U for all c ∈ [0, 1], then\n‖h(x)− h(y)‖ ≤ sup c∈[0,1] {‖Jh (cx+ (1− c)y)‖ ‖x− y‖}\nwhere Jh(·) is the Jacobian of h. Define hγ : Sp++ → Rp 2 by\nhγ(X) = vec(X) + vec(γX −1),\nwhere vec(·) : Rp×p → Rp2 is the vectorization operator defined by\nvec(A) = (A1,, A2,, . . . , Ap,) T\nwith Ai, the i th row of A. Note that for X ∈ Sp++,\n∂X ∂X = Ip2 and\n∂X−1\n∂X = −X−1 ⊗X−1,\nwhere ⊗ is the Kronecker product and Ip2 is the p2× p2 identity matrix. Then the Jacobian of hγ is given by:\nJhγ (X) = Ip2 − γX−1 ⊗X−1.\nApplication of the mean value theorem to hζt over Zt,c = vec(cΘt + (1 − c)Θ∗ρ), c ∈ [0, 1] yields ∥∥hζt(Θt)− hζt(Θ∗ρ)∥∥F ≤ sup\nc {∥∥Ip2 − ζtZ−1t,c ⊗ Z−1t,c ∥∥2}∥∥vec(Θt)− vec(Θ∗ρ)∥∥2 = sup\nc {∥∥Ip2 − ζtZ−1t,c ⊗ Z−1t,c ∥∥2}∥∥Θt −Θ∗ρ∥∥F . Denoting the eigenvalues of Zt,c for given values of t and c as 0 < γ1 ≤ γ2 ≤ · · · ≤ γp, the eigenvalues of Ip2 − ζtZ−1t,c ⊗ Z−1t,c are {1− ζt(γiγj)−1} p i,j=1. By Weyl’s inequality,\nγp = λmax(Zt,c)≤ max { λmax(Θt), λmax(Θ ∗ ρ) }\nγ1 = λmin(Zt,c)≥ min { λmin(Θt), λmin(Θ ∗ ρ) } ,\nand therefore\nλmin ( Ip2 − ζtZ−1t,c ⊗ Z−1t,c ) = 1− ζt\nγ21 ≥ 1− ζt a2\nλmax ( Ip2 − ζtZ−1t,c ⊗ Z−1t,c ) = 1− ζt\nγ2p ≤ 1− ζt b2 .\nHence,\nsup c {∥∥Ip2 − ζtZ−1t,c ⊗ Z−1t,c ∥∥2} ≤ max{ ∣∣∣∣1− ζtb2 ∣∣∣∣ , ∣∣∣∣1− ζta2 ∣∣∣∣}\nwhich completes the proof.\nIt follows from Lemma 3 that Algorithm 1 converges linearly if\nst(ζt) := max {∣∣∣∣1− ζtb2 ∣∣∣∣ , ∣∣∣∣1− ζta2 ∣∣∣∣} ∈ (0, 1),∀t. (23) Since the minimum of\ns(ζ) = max {∣∣∣∣1− ζa2 ∣∣∣∣ , ∣∣∣∣1− ζb2 ∣∣∣∣} is at ζ = 2\na−2+b−2 , Theorem 1 follows directly from Lemma 3. It now remains to show\nthat the eigenvalues of the G-ISTA iterates remain bounded in eigenvalue. A more general convergence result for strongly convex functions exists in the literature; this result is stated below.\nTheorem 4. Let f be strongly convex with convexity constant µ, and ∇f be Lipschitz continuous with constant L. Then for constant step size 0 < ζ < 2\nL , the iterates of the ISTA\niteration (equation (8)), {xt}t≥0 to minimize f + g as in (4), satisfy\n‖xt+1 − x∗‖F ≤ max {|1− ζL| , |1− ζµ|} ‖xt − x ∗‖F ,\nwhich is to say that they converge linearly with rate max {|1− ζL| , |1− ζµ|}. Furthermore,\n1. The step size which yields an optimal worst-case contraction bound is ζ = 2 µ+L . 2. The optimal worst-case contraction bound corresponding to ζ = 2 µ+L is given by\ns(ζ) : = max {|1− ζL| , |1− ζµ|}\n= 1− 2 1 + µ\nL\n.\nProof. See [7, 26] and references therein.\nA.3 Proof of Theorem 2\nIn this section, the eigenvalues of Θt,∀t are bounded. To begin, the eigenvalues of Θt+ 1 2 := Θt − ζt(S −Θ−1t ) are bounded.\nLemma 4. Let 0 < a < b be given positive constants and let ζt > 0. Assume aI Θt bI. Then the eigenvalues of Θt+ 1 2 := Θt − ζt(S −Θ−1t ) satisfy:\nλmin(Θt+ 1 2 ) ≥\n{ 2 √ ζt − ζtλmax(S) if a ≤ √ ζt ≤ b\nmin ( a+ ζt\na , b+ ζt b ) − ζtλmax(S) otherwise\n(24)\nand\nλmax(Θt+ 1 2 ) ≤ max\n( a+\nζt a , b+ ζt b\n) − ζtλmin(S).\nProof. Denoting the eigenvalue decomposition of Θt by Θt = UΓU T ,\nΘt+ 1 2\n= Θt − ζt(S −Θ−1t ) = UΓUT − ζt(S − UΓ−1UT )\n= U ( Γ− ζt(UTSU − Γ−1) ) UT\nLet Γ = diag(γ1, . . . , γp) with γ1 ≤ · · · ≤ γp. By Weyl’s inequality, the eigenvalues of Θt+ 1 2 are bounded below by\nλi ( Θt+ 1\n2\n) ≥ γi +\nζt γi − ζtλmax(S),\nand bounded above by\nλi ( Θt+ 1\n2\n) ≤ γi +\nζt γi − ζtλmin(S)\nThe function f(x) = x+ ζt x over a ≤ x ≤ b has only one extremum which is a global minimum at x = √ ζt. Therefore,\nmin a≤x≤b x+ ζt x =\n{ 2 √ ζt if a ≤ √ ζt ≤ b\nmin ( a+ ζt\na , b+ ζt b\n) otherwise\n,\nand\nmax a≤x≤b x+ ζt x = max\n( a+\nζt b , b+ ζt b\n) .\nSince a ≤ γ1 ≤ b,\nλmin(Θt+ 1 2 ) ≥ γ1 + ζt γ1 − ζtλmax(S)\n≥ min a≤x≤b\n( x+\nζt x\n) − ζtλmax(S)\n=\n{ 2 √ ζt − ζtλmax(S) if a ≤ √ ζt ≤ b\nmin ( a+ ζt\na , b+ ζt b ) − ζtλmax(S) otherwise\nSimilarly,\nλmax(Θt+ 1 2 ) ≤ γp + ζt γp − ζtλmin(S)\n≤ max a≤x≤b\n( x+\nζt x\n) − ζtλmin(S)\n= max ( a+\nζt a , b+ ζt b\n) − ζtλmin(S).\nIt remains to demonstrate that the soft-thresholded iterates Θt+1 remain bounded in eigenvalue.\nLemma 5. Let 0 < a < b and ζt > 0. Then:\nmin ( a+\nζt a , b+ ζt b\n) = a+\nζt a\nif and only if ζt ≤ ab.\nProof. Under the stated assumptions,\na+ ζt a ≤ b+ ζt b ⇔ ζt\n( 1\na − 1 b\n) ≤ b− a\n⇔ ζt ≤ b− a 1 a − 1 b ⇔ ζt ≤ ab.\nLemma 6. Let A be a symmetric p × p matrix. Then the soft-thresholded matrix η (A) satisfies\nλmin(A)− p ≤ λmin(η (A))\nIn particular, A is positive definite if λmin(A) > p .\nProof. Let\nA := {M ∈Mp : Mi,j ∈ {0, 1,−1}}.\nFor every > 0, the matrix A can be written as\nη (A) = A+ 1A1 + 2A2 + · · ·+ kAk,\nfor some k ≤ ( p 2 ) + p where Ai ∈ A, i > 0 and ∑k i=1 i = . Now let\ncp := max{|λmin(M)| : M ∈ A}.\nThe constant cp is finite since A is a finite set. Since −A ∈ A for every A ∈ A, and since |λmin(−A)| = |λmax(A)|, it follows that\ncp = max{|λmax(M)| : M ∈ A}.\nApplying the Gershgorin circle theorem [see, e.g., 15] gives cp ≤ p. Since p is an eigenvalue of the matrix B such that Bi,j = 1 for all i, j, it follows that cp = p.\nRecursive application of Weyl’s inequality gives that\nλmin (η (A)) ≥ λmin(A)− |λmax(A1)| − · · · − k|λmax(Ak)|\n≥ λmin(A)− cp k∑ i=1 i = λmin(A)− cp .\nRecall from Lemma 1 that the eigenvalues of the optimal solution to problem (1) are bounded below by 1‖S‖2+pρ . The following theorem shows that α = 1 ‖S‖2+pρ is a valid bound to ensure that αI Θt+1 if αI Θt. Lemma 7. Let ρ > 0 and α = 1‖S‖2+pρ < b ′. Assume αI Θt b′ and consider\nΘt+1 = ηζtρ ( Θt − ζt(S −Θ−1t ) )\nThen for every 0 < ζt ≤ α2, αI Θt+1.\nProof. The result follows by combining Lemma 4 and Lemma 6. Notice first that the hypothesis ζt ≤ α2 guarantees that √ ζt /∈ [α, b′]. Also, from Lemma 5, we have\nmin ( α +\nζt α , b′ + ζt b′\n) = α +\nζt α\nsince ζt ≤ α2 ≤ αb′. Hence, by Lemma 4,\nλmin(Θt+ 1 2 ) ≥ min\n( α +\nζt α , b′ + ζt b′\n) − ζtλmax(S)\n= α + ζt α − ζtλmax(S).\nNow, applying Lemma 6 to Θt+1 = ηζtρ(Θt+ 1 2 ), we obtain\nλmin(Θt+1) = λmin ( ηζtρ(Θt+ 1 2 ) )\n≥ λmin(Θt+ 1 2 )− pρζt ≥ α + ζt α − ζtλmax(S)− pρζt.\nWe therefore have αI Θt+1 whenever\nα + ζt α − ζtλmax(S)− pρζt ≥ α.\nThis is equivalent to\nζt\n( 1\nα − λmax(S)− pρ\n) ≥ 0.\nSince ζt > 0, this is equivalent to\n1 α − λmax(S)− pρ ≥ 0.\nReorganizing the terms of the previous equation, we obtain that αI Θt+1 if\nα ≤ 1 λmax(S) + pρ = 1 ‖S‖2 + pρ .\nIt remains to show that the eigenvalues of the iterates Θt remain bounded above, for all t.\nLemma 8. Let α = 1‖S‖2+pρ and let ζt ≤ α 2,∀t. Then the G-ISTA iterates Θt satisfy\nΘt b′I,∀t, with b′ = ∥∥Θ∗ρ∥∥2 + ∥∥Θ0 −Θ∗ρ∥∥F .\nProof. By Lemma 7, αI Θt for every t. As αI Θ∗ (Lemma 1),\nΛ−t := min{λmin(Θt), λmin(Θ∗ρ)}2 ≥ α2.\nfor all t. Also, since Λ+t ≥ Λ−t and ζt ≤ α2,\nmax {∣∣∣∣1− ζtb2 ∣∣∣∣ , ∣∣∣∣1− ζta2 ∣∣∣∣} ≤ 1. Therefore, by Lemma 3,\n‖Θt −Θ∗ρ‖F ≤ ‖Θt−1 −Θ∗ρ‖F .\nApplying this result recursively gives\n‖Θt −Θ∗ρ|F ≤ ‖Θ0 −Θ∗ρ‖F .\nSince ‖ · ‖2 ≤ ‖ · ‖F , we therefore have\n‖Θt‖2 − ‖Θ∗ρ‖2 ≤ ‖Θt −Θ∗ρ‖2 ≤ ‖Θt −Θ∗ρ‖F ≤ ‖Θ0 −Θ∗ρ‖F ,\nand so,\nλmax(Θt) = ‖Θt‖2 ≤ ‖Θ∗ρ‖2 + ‖Θ0 −Θ∗ρ‖F\nwhich completes the proof.\nA.4 Additional timing comparisons\nThis section provides additional synthetic timing comparisions for p = 500 and p = 5000. In addition, two real datasets were investigated. The “estrogen” dataset [27] contains p = 652 dimensional gene expression data from n = 158 breast cancer patients. The “temp” dataset [6] consists of average annual temperature measurements from p = 1732 locations over n = 157 years (1850-2006)."
    } ],
    "references" : [ {
      "title" : "d’Aspremont. Model selection through sparse maximum likelihood estimation for multivarate gaussian or binary data",
      "author" : [ "O. Banerjee", "L. El Ghaoui" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2008
    }, {
      "title" : "Two-Point Step Size Gradient Methods",
      "author" : [ "Jonathan Barzilai", "Jonathan M. Borwein" ],
      "venue" : "IMA Journal of Numerical Analysis,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1988
    }, {
      "title" : "A fast iterative shrinkage-thresholding algorithm for linear inverse problems",
      "author" : [ "Amir Beck", "Marc Teboulle" ],
      "venue" : "SIAM Journal on Imaging Sciences,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2009
    }, {
      "title" : "Templates for convex cone problems with applications to sparse signal recovery",
      "author" : [ "S. Becker", "E.J. Candes", "M. Grant" ],
      "venue" : "Mathematical Programming Computation, 3:165–218,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Convex Optimization",
      "author" : [ "Stephen Boyd", "Lieven Vandenberghe" ],
      "venue" : null,
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2004
    }, {
      "title" : "Uncertainty estimates in regional and global observed temperature changes: A new data set from 1850",
      "author" : [ "P. Brohan", "J.J. Kennedy", "I. Harris", "S.F.B. Tett", "P.D. Jones" ],
      "venue" : "Journal of Geophysical Research, 111,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Convergence rates in forward-backward splitting",
      "author" : [ "George H.G. Chen", "R.T. Rockafellar" ],
      "venue" : "Siam Journal on Optimization,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1997
    }, {
      "title" : "Signal recovery by proximal forwardbackward splitting",
      "author" : [ "Patrick L. Combettes", "Valérie R. Wajs" ],
      "venue" : "Multiscale Modeling & Simulation,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2005
    }, {
      "title" : "First-order methods for sparse covariance selection",
      "author" : [ "Alexandre D’Aspremont", "Onureena Banerjee", "Laurent El Ghaoui" ],
      "venue" : "SIAM Journal on Matrix Analysis and Applications,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2008
    }, {
      "title" : "Hyper-markov laws in the statistical analysis of decomposable graphical models",
      "author" : [ "A.P. Dawid", "S.L. Lauritzen" ],
      "venue" : "Annals of Statistics, 21:1272–1317,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "Sparse inverse covariance estimation with the graphical lasso",
      "author" : [ "J. Friedman", "T. Hastie", "R. Tibshirani" ],
      "venue" : "Biostatistics, 9:432–441,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "CVX: Matlab software for disciplined convex programming, version 1.21",
      "author" : [ "M. Grant", "S. Boyd" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2011
    }, {
      "title" : "Large-scale correlation screening",
      "author" : [ "A. Hero", "B. Rajaratnam" ],
      "venue" : "Journal of the American Statistical Association, 106(496):1540–1552,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Hub discovery in partial correlation graphs",
      "author" : [ "A. Hero", "B. Rajaratnam" ],
      "venue" : "IEEE Transactions on Information Theory, 58(9):6064–6078,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Matrix Analysis",
      "author" : [ "Roger A. Horn", "Charles R. Johnson" ],
      "venue" : null,
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1990
    }, {
      "title" : "Sparse inverse covariance matrix estimation using quadratic approximation",
      "author" : [ "Cho-Jui Hsieh", "Matyas A. Sustik", "Inderjit S. Dhillon", "Pradeep K. Ravikumar" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2011
    }, {
      "title" : "Wishart distributions for decomposable covariance graph models",
      "author" : [ "K. Khare", "B. Rajaratnam" ],
      "venue" : "Annals of Statistics, 39(1):514–555,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Graphical models",
      "author" : [ "S.L. Lauritzen" ],
      "venue" : "Oxford Science Publications. Clarendon Press,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Wishart distributions for decomposable graphs",
      "author" : [ "G. Letac", "H. Massam" ],
      "venue" : "Annals of Statistics, 35(3):1278–1323,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Smooth optimization approach for sparse covariance selection",
      "author" : [ "Zhaosong Lu" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2009
    }, {
      "title" : "Adaptive first-order methods for general sparse inverse covariance selection",
      "author" : [ "Zhaosong Lu" ],
      "venue" : "SIAM Journal on Matrix Analysis and Applications,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2010
    }, {
      "title" : "A flexible, scalable and efficient algorithmic framework for the Primal graphical lasso",
      "author" : [ "Rahul Mazumder", "Deepak K. Agarwal" ],
      "venue" : "Pre-print,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2011
    }, {
      "title" : "The graphical lasso: New insights and alternatives",
      "author" : [ "Rahul Mazumder", "Trevor Hastie" ],
      "venue" : "Pre-print,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2011
    }, {
      "title" : "A method of solving a convex programming problem with convergence rate O(1/k)",
      "author" : [ "Yurii Nesterov" ],
      "venue" : "Soviet Mathematics Doklady,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1983
    }, {
      "title" : "Introductory Lectures on Convex Optimization",
      "author" : [ "Yurii Nesterov" ],
      "venue" : "Kluwer Academic Publishers,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2004
    }, {
      "title" : "Gradient methods for minimizing composite objective function",
      "author" : [ "Yurii Nesterov" ],
      "venue" : "CORE discussion papers, Université catholique de Louvain, Center for Operations Research and Econometrics (CORE),",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2007
    }, {
      "title" : "Integrated modeling of clinical and gene expression information for personalized prediction of disease outcomes",
      "author" : [ "Jennifer Pittman", "Erich Huang", "Holly Dressman", "Cheng-Fang F. Horng", "Skye H. Cheng", "Mei-Hua H. Tsou", "Chii-Ming M. Chen", "Andrea Bild", "Edwin S. Iversen", "Andrew T. Huang", "Joseph R. Nevins", "Mike West" ],
      "venue" : "Proceedings of the National Academy of Sciences of the United States of America,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2004
    }, {
      "title" : "Flexible covariance estimation in graphical models",
      "author" : [ "B. Rajaratnam", "H. Massam", "C. Carvalho" ],
      "venue" : "Annals of Statistics, 36:2818–2849,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "A note on the lack of symmetry in the graphical lasso",
      "author" : [ "Benjamin T. Rolfs", "Bala Rajaratnam" ],
      "venue" : "Computational Statistics and Data Analysis,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2012
    }, {
      "title" : "Sparse inverse covariance selection via alternating linearization methods",
      "author" : [ "Katya Scheinberg", "Shiqian Ma", "Donald Goldfarb" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2010
    }, {
      "title" : "On accelerated proximal gradient methods for convex-concave optimization",
      "author" : [ "Paul Tseng" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2008
    }, {
      "title" : "Determinant maximization with linear matrix inequality constraints",
      "author" : [ "Lieven Vandenberghe", "Stephen Boyd", "Shao-Po Wu" ],
      "venue" : "SIAM Journal on Matrix Analysis and Applications,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 1996
    }, {
      "title" : "Graphical Models in Applied Multivariate Statistics",
      "author" : [ "J. Whittaker" ],
      "venue" : "Wiley,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "Condition number regularized covariance estimation",
      "author" : [ "J. Won", "J. Lim", "S. Kim", "B. Rajaratnam" ],
      "venue" : "Journal of the Royal Statistical Society Series B,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Sparse reconstruction by separable approximation",
      "author" : [ "Stephen J. Wright", "Robert D. Nowak", "Mário A.T. Figueiredo" ],
      "venue" : "IEE Transactions on Signal Processing,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2009
    }, {
      "title" : "Model selection and estimation in the gaussian graphical model",
      "author" : [ "Ming Yuan", "Yi Lin" ],
      "venue" : null,
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2007
    }, {
      "title" : "Alternating direction method of multipliers for covariance selection models",
      "author" : [ "X.M. Yuan" ],
      "venue" : "Journal of Scientific Computing, pages 1–13,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 32,
      "context" : "A related problem is the inference of a Gaussian graphical model ([33, 18]), that is, a sparsity pattern in the inverse covariance matrix, Ω.",
      "startOffset" : 66,
      "endOffset" : 74
    }, {
      "referenceID" : 17,
      "context" : "A related problem is the inference of a Gaussian graphical model ([33, 18]), that is, a sparsity pattern in the inverse covariance matrix, Ω.",
      "startOffset" : 66,
      "endOffset" : 74
    }, {
      "referenceID" : 32,
      "context" : "Specifically, if X = (Xi) p i=1 ∈ R is distributed as X ∼ Np(0,Σ), then (Σ)ij = Ωij = 0 ⇐⇒ Xi ⊥⊥ Xj|{Xk}k 6=i,j, where the notation A ⊥⊥ B|C denotes the conditional independence of A and B given the set of variables C (see [33, 18]).",
      "startOffset" : 223,
      "endOffset" : 231
    }, {
      "referenceID" : 17,
      "context" : "Specifically, if X = (Xi) p i=1 ∈ R is distributed as X ∼ Np(0,Σ), then (Σ)ij = Ωij = 0 ⇐⇒ Xi ⊥⊥ Xj|{Xk}k 6=i,j, where the notation A ⊥⊥ B|C denotes the conditional independence of A and B given the set of variables C (see [33, 18]).",
      "startOffset" : 223,
      "endOffset" : 231
    }, {
      "referenceID" : 0,
      "context" : "[1] proposed performing such sparse inverse covariance estimation by solving the `1-penalized maximum likelihood estimation problem,",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "Moreover, the `1 penalty induces sparsity in Θρ, as it is the closest convex relaxation of the 0 − 1 penalty, ‖Θ‖0 = ∑ i,j I(Θij 6= 0), where I(·) is the indicator function [5].",
      "startOffset" : 173,
      "endOffset" : 176
    }, {
      "referenceID" : 9,
      "context" : "The reader is referred to the theoretical work of [10, 13, 14, 17, 19, 28], among others, for greater detail.",
      "startOffset" : 50,
      "endOffset" : 74
    }, {
      "referenceID" : 12,
      "context" : "The reader is referred to the theoretical work of [10, 13, 14, 17, 19, 28], among others, for greater detail.",
      "startOffset" : 50,
      "endOffset" : 74
    }, {
      "referenceID" : 13,
      "context" : "The reader is referred to the theoretical work of [10, 13, 14, 17, 19, 28], among others, for greater detail.",
      "startOffset" : 50,
      "endOffset" : 74
    }, {
      "referenceID" : 16,
      "context" : "The reader is referred to the theoretical work of [10, 13, 14, 17, 19, 28], among others, for greater detail.",
      "startOffset" : 50,
      "endOffset" : 74
    }, {
      "referenceID" : 18,
      "context" : "The reader is referred to the theoretical work of [10, 13, 14, 17, 19, 28], among others, for greater detail.",
      "startOffset" : 50,
      "endOffset" : 74
    }, {
      "referenceID" : 27,
      "context" : "The reader is referred to the theoretical work of [10, 13, 14, 17, 19, 28], among others, for greater detail.",
      "startOffset" : 50,
      "endOffset" : 74
    }, {
      "referenceID" : 11,
      "context" : "While several excellent general convex solvers exist (for example, [12] and [4]), these are not always adept at handling high dimensional problems (i.",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 3,
      "context" : "While several excellent general convex solvers exist (for example, [12] and [4]), these are not always adept at handling high dimensional problems (i.",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 0,
      "context" : "Dual methods [1] yield a covariance matrix by solving the constrained problem,",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 0,
      "context" : "[1] consider a block coordinate descent algorithm to solve the block dual problem, which reduces each optimization step to solving a box-constrained quadratic program.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 10,
      "context" : "[11] iteratively solve the lasso regression as described in [1], but do so using coordinate-wise descent.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "[11] iteratively solve the lasso regression as described in [1], but do so using coordinate-wise descent.",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 8,
      "context" : "[9] use Nesterov’s smooth approximation scheme, which produces an ε-optimal solution in O(1/ε) iterations.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 19,
      "context" : "A variant of Nesterov’s smooth method is shown to have a O(1/ √ ε) iteration complexity in [20, 21].",
      "startOffset" : 91,
      "endOffset" : 99
    }, {
      "referenceID" : 20,
      "context" : "A variant of Nesterov’s smooth method is shown to have a O(1/ √ ε) iteration complexity in [20, 21].",
      "startOffset" : 91,
      "endOffset" : 99
    }, {
      "referenceID" : 35,
      "context" : "Yuan and Lin [36] use interior point methods based on the max-det problem studied in [32].",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 31,
      "context" : "Yuan and Lin [36] use interior point methods based on the max-det problem studied in [32].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 36,
      "context" : "Yuan [37] use an alternating-direction method, while Scheinberg et al.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 29,
      "context" : "[30] proposes a similar method and show a sublinear convergence rate.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 22,
      "context" : "Mazumder and Hastie [23] consider blockcoordinate descent approaches for the primal problem, similar to the dual approach taken in [11].",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 10,
      "context" : "Mazumder and Hastie [23] consider blockcoordinate descent approaches for the primal problem, similar to the dual approach taken in [11].",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 21,
      "context" : "Mazumder and Agarwal [22] also solve the primal problem with block-coordinate descent, but at each iteration perform a partial as opposed to complete block optimization, resulting in a decreased computational complexity per iteration.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 15,
      "context" : "[16] propose a second-order proximal point algorithm, called QUIC, which converges superlinearly locally around the optimum.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 2,
      "context" : "exists for general iterative shrinkage thresholding and related methods; see, in particular, [3, 8, 24, 25, 26, 31].",
      "startOffset" : 93,
      "endOffset" : 115
    }, {
      "referenceID" : 7,
      "context" : "exists for general iterative shrinkage thresholding and related methods; see, in particular, [3, 8, 24, 25, 26, 31].",
      "startOffset" : 93,
      "endOffset" : 115
    }, {
      "referenceID" : 23,
      "context" : "exists for general iterative shrinkage thresholding and related methods; see, in particular, [3, 8, 24, 25, 26, 31].",
      "startOffset" : 93,
      "endOffset" : 115
    }, {
      "referenceID" : 24,
      "context" : "exists for general iterative shrinkage thresholding and related methods; see, in particular, [3, 8, 24, 25, 26, 31].",
      "startOffset" : 93,
      "endOffset" : 115
    }, {
      "referenceID" : 25,
      "context" : "exists for general iterative shrinkage thresholding and related methods; see, in particular, [3, 8, 24, 25, 26, 31].",
      "startOffset" : 93,
      "endOffset" : 115
    }, {
      "referenceID" : 30,
      "context" : "exists for general iterative shrinkage thresholding and related methods; see, in particular, [3, 8, 24, 25, 26, 31].",
      "startOffset" : 93,
      "endOffset" : 115
    }, {
      "referenceID" : 7,
      "context" : "It is well known (for example, [8]) that x∗ ∈ X is an optimal solution of problem (4) if and only if",
      "startOffset" : 31,
      "endOffset" : 34
    }, {
      "referenceID" : 2,
      "context" : "See [3] for more details.",
      "startOffset" : 4,
      "endOffset" : 7
    }, {
      "referenceID" : 0,
      "context" : "Lemma 1 ([1, 20]).",
      "startOffset" : 9,
      "endOffset" : 16
    }, {
      "referenceID" : 19,
      "context" : "Lemma 1 ([1, 20]).",
      "startOffset" : 9,
      "endOffset" : 16
    }, {
      "referenceID" : 7,
      "context" : "where for some x ∈ R, (x)+ := max(x, 0) (see [8]).",
      "startOffset" : 45,
      "endOffset" : 48
    }, {
      "referenceID" : 2,
      "context" : "As in [3], the algorithm uses a backtracking line search for the choice of step size.",
      "startOffset" : 6,
      "endOffset" : 9
    }, {
      "referenceID" : 1,
      "context" : "Our implementation of Algorithm 1 chooses the Barzilai-Borwein step [2].",
      "startOffset" : 68,
      "endOffset" : 71
    }, {
      "referenceID" : 34,
      "context" : "is also used in the SpaRSA algorithm [35], and approximates the Hessian around Θt+1.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 15,
      "context" : "In particular, the useful, recent QUIC method [16] warrants a discussion.",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 10,
      "context" : "3 compares running times of the G-ISTA, glasso [11], and QUIC [16] algorithms.",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 15,
      "context" : "3 compares running times of the G-ISTA, glasso [11], and QUIC [16] algorithms.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 20,
      "context" : "Synthetic data for this section was generated following the method used by [21, 22].",
      "startOffset" : 75,
      "endOffset" : 83
    }, {
      "referenceID" : 21,
      "context" : "Synthetic data for this section was generated following the method used by [21, 22].",
      "startOffset" : 75,
      "endOffset" : 83
    }, {
      "referenceID" : 15,
      "context" : "[16].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 28,
      "context" : "For many practical applications however, obtaining an estimator that is well-conditioned is important ([29, 34]).",
      "startOffset" : 103,
      "endOffset" : 111
    }, {
      "referenceID" : 33,
      "context" : "For many practical applications however, obtaining an estimator that is well-conditioned is important ([29, 34]).",
      "startOffset" : 103,
      "endOffset" : 111
    } ],
    "year" : 2012,
    "abstractText" : "The `1-regularized maximum likelihood estimation problem has recently become a topic of great interest within the machine learning, statistics, and optimization communities as a method for producing sparse inverse covariance estimators. In this paper, a proximal gradient method (G-ISTA) for performing `1-regularized covariance matrix estimation is presented. Although numerous algorithms have been proposed for solving this problem, this simple proximal gradient method is found to have attractive theoretical and numerical properties. G-ISTA has a linear rate of convergence, resulting in an O(log ε) iteration complexity to reach a tolerance of ε. This paper gives eigenvalue bounds for the G-ISTA iterates, providing a closed-form linear convergence rate. The rate is shown to be closely related to the condition number of the optimal point. Numerical convergence results and timing comparisons for the proposed method are presented. G-ISTA is shown to perform very well, especially when the optimal point is well-conditioned.",
    "creator" : "LaTeX with hyperref package"
  }
}