{
  "name" : "1603.05643.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Variance Reduction for Faster Non-Convex Optimization",
    "authors" : [ "Zeyuan Allen-Zhu", "Elad Hazan" ],
    "emails" : [ "zeyuan@csail.mit.edu", "ehazan@cs.princeton.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "We provide the first improvement in this line of research. Our result is based on the variance reduction trick recently introduced to convex optimization, as well as a brand new analysis of variance reduction that is suitable for non-convex optimization. For objectives that are sum of smooth functions, our first-order minibatch stochastic method converges with an O(1/ε) rate, and is faster than full gradient descent by Ω(n1/3).\nWe demonstrate the effectiveness of our methods on empirical risk minimizations with nonconvex loss functions and training neural nets."
    }, {
      "heading" : "1 Introduction",
      "text" : "Numerous machine learning problems are naturally formulated as non-convex optimization problems. Examples include inference in graphical models, unsupervised learning models such as topic models, dictionary learning, and perhaps most notably, training of deep neural networks. Indeed, non-convex optimization for machine learning is one of the fields’ main research frontiers.\nSince global minimization of non-convex functions is NP-hard, various alternative approaches are applied. For some models, probabilistic and other assumptions on the input can be used to give specially designed polynomial-time algorithms [5, 6, 15].\nHowever, the multitude and diversity of machine learning applications require a robust, generic optimization method that can be applied as a tool rather than reinvented per each specific model. One approach is the design of global non-convex heuristics such as simulated annealing or bayesian optimization. Although believed to fail in the worst case due to known complexity results, such heuristics many times perform well in practice for certain problems.\nAnother approach, which is based on more solid theoretical foundation and is gaining in popularity, is to drop the “global optimality” requirement and attempt to reach more modest solution concepts. The most popular of these is the use of iterative optimization methods to reach a stationary point. The use of stochastic first-order methods is the primary focus of this approach, which has become the most common method for training deep neural nets.\n∗First circulated on this date, and first appeared on arXiv on March 17, 2016.\nar X\niv :1\n60 3.\n05 64\n3v 2\n[ m\nat h.\nO C\n] 2\n5 A\nug 2\nFormally, in this paper we consider the unconstrained minimization problem\nmin x∈Rd\n{ f(x) def = 1\nn\nn∑\ni=1\nfi(x) } , (1.1)\nwhere each fi(x) is differentiable, possibly non-convex, and has L-Lipschitz continuous gradient (a.k.a. L-smooth) for some parameter L > 0.1 Many machine learning/imaging processing problems fall into Problem (1.1), including training neural nets, ERM (empirical risk minimization) with non-convex losses, and many others.\nFollowing the classical benchmark for non-convex optimization (see for instance [13]), we focus on algorithms that can efficiently find an approximate stationary point x satisfying ‖∇f(x)‖2 ≤ ε.\nUnlike convex optimization, a point with small gradient may only be close to a saddle point or a local minimum, rather than the global minimum. Therefore, such an algorithm is usually combined with saddle-point or local-minima escaping schemes, such as genetic algorithms or simulated annealing. More recently, Ge et al. [12] also demonstrated that a simple noise-addition scheme is sufficient for stochastic gradient descent to escape from saddle points.\nHowever, for the general problem (1.1) where smoothness is the only assumption and finding approximate stationary point is the simple goal, the only known theoretical convergence results remain to be that for gradient descent (GD) and stochastic gradient descent (SGD).\n• Given a starting point x0, GD applies an update x′ ← x − 1L∇f(x) with a fixed step length 1/L per iteration. In order to produce an output x that is an ε-approximate stationary point,\nGD needs T = O (L(f(x0)−f(x∗))\nε\n) iterations where x∗ is the global minimizer of f(·). This is\na folklore result in optimization and included for instance in [13].\n• SGD applies an update x′ ← x− η∇fi(x) per iteration, where i chosen uniformly at random from [n] def = {1, 2, . . . , n}. If η is properly tuned, one can obtain an ε-approximate stationary\npoint in T = O ((\nL ε +\nLσ2\nε2\n) ·(f(x0)−f(x∗)) ) iterations, where σ is the variance of the stochastic\ngradient. This result is perhaps first formalized by Ghadimi and Lan [13].\nSince computing the full gradient ∇f(·) is usually n times slower than that of ∇fi(x), each iteration of SGD is usually n times faster than that of GD, but the total number of iterations for SGD is very poor.\nBefore our work, it is an open question to design a first-order method that is faster than both GD and SGD."
    }, {
      "heading" : "1.1 Our Result",
      "text" : "We prove that variance reduction techniques, based on the SVRG method [16], produce an εstationary point in only O (n2/3L(f(x0)−f(x∗))\nε\n) iterations. Since each iteration of SVRG is as fast as\nSGD and n times faster than that of GD, SVRG is guaranteed to be at least Ω(n1/3) times faster than GD. Among first-order methods, this is the first time the performance of GD is outperformed in theory for problem (1.1) without any additional assumption, and also the first time that stochasticgradient based methods are shown to have a non-trivial2 1/ε convergence rate independent of the variance σ2.\n1Even if each fi(x) is not smooth but only Lipschitz continuous, standard smoothing techniques such as Chapter 2.3 of [14] usually turn each fi(x) into a smooth function without sacrificing too much accuracy.\n2Note however, designing a stochastic-gradient method with a trivial 1/ε rate is obvious. For instance, it is\nstraightforward to design such a method that converges in O (nL(f(x0)−f(x∗))\nε\n) iterations. However, this is never\nfaster than GD.\nOur proposed algorithm is very analogous to SVRG of [16]. Recall that SVRG has an outer loop of epochs, where at the beginning of each epoch, SVRG defines a snapshot vector x̃ to be the average vector of the previous epoch,3 and computes its full gradient ∇f(x̃). Each epoch of SVRG consists of m inner iterations, where the choice of m usually depends on the objective’s strong convexity. In each inner iteration inside an epoch, SVRG picks a random i ∈ [n], defines the gradient estimator\n∇̃k def= 1 n\nn∑\nj=1\n∇fj(x̃) +∇fi(xk)−∇fi(x̃) , (1.2)\nand performs an update x′ ← x − η∇̃k for some fixed step length η > 0 across all iterations and epochs.\nIn order to prove our theoretical result in this paper, we make the following changes to SVRG. First, we set the number of inner iterations m as a constant factor times n. Second, we pick the snapshot point to be a non-uniform average of the last m2/3 elements of the previous epoch. Finally, we prove that the average norm ‖∇f(xk)‖2 of the encountered vectors xk across all iterations is small, so it suffices to output xk for a random k.\nOur Technique. To prove our result, we need different techniques from all known results on variance reduction. The key idea used by previous authors is to show that the variance of the gradient estimator ∇̃k is upper bounded by either O(f(xk)−f(x∗)) or O(‖xk−x∗‖2), and therefore it converges to zero for convex functions. This analysis fails to apply in the non-convex setting because gradient-based methods do not converge to the global minimum.\nWe observe in this paper that the variance is upper bounded by O(‖xk − x̃‖2), the squared distance between the current point and the most recent snapshot. By dividing an epoch into m1/3 subepochs of length m2/3, and performing a mirror-descent analysis for each subepoch, we further show that this squared distance is related to the objective decrease f(x̃)−f(xk). This would suffice for proving our theorem: whenever this squared distance is small the objective is decreased by a lot due to the small variance, or otherwise if this squared distance is large we still experience a large objective decrease because it is related to f(x̃)− f(xk). Applications. There are many machine learning problems that fall into category (1.1). To mention just two:\n• Non-Convex Loss in ERM Empirical risk minimization (ERM) problems naturally fall into the category of (1.1) if the loss functions are non-convex. For instance, for binary classification problems, the sigmoid function —or more broadly, any natural smoothed variant of the 0-1 loss function— is not only a more natural choice than artificial ones such as hinge loss, logistic loss, squared loss, but also generalize better in terms of testing accuracy especially when there are outliers [25].\nHowever, since sigmoid loss is non-convex, it was previously considered hard to train an ERM problem with it. Shalev-Shwartz, Shamir and Sridharan [25] showed that this minimization problem is still solvable in the improper learning sense, with the help from kernel methods and gradient descent. However, their theoretical convergence has a poor polynomial dependence on 1/ε and exponential dependence on the smoothness parameter of the loss function.\nOur result in this paper applies to ERM problems with non-convex loss. Suppose we are given n training examples {(a1, `1), . . . (an, `n)}, where each ai ∈ Rd is the feature vector of example i and 3More precisely, SVRG provides two options, one defining x̃ to be the average vector of the previous epoch, and the other defining x̃ to be the last iterate of the previous epoch. While the authors only prove theoretical results for the “average” definition, experimental results suggest that choosing the last iterate is better.\neach li ∈ {−1,+1} is the binary label of example i. By setting φ(t) def= 11+et to be the sigmoid loss function and setting fi(x) def = φ(li〈ai, x〉) + λ2‖x‖2, problem (1.1) becomes `2 ERM with sigmoid loss. We shall demonstrate in our experiment section that, by using SVRG to train ERM with sigmoid loss, its running time is as good as using SVRG to train ERM with other convex loss functions, but the testing accuracy can be significantly better.\n• Neural Network Training neural nets can also be formalized into problem (1.1). For instance, as long as the activation function of each neural node is smooth, say the sigmoid function or a smooth version of the rectified linear unit (ReLU) function (for instance, the softplus alternative), we can define fi(x) to be the training loss with respect to the i-th data input. In this language, computing the stochastic gradient ∇fi(x) for some random i ∈ [n] corresponds to performing one forwardbackward prorogation on the neural net with respect to sample i. We shall demonstrate in our experiment that using SVRG to train neural nets can enjoy a much faster running time comparing to SGD or SVRG."
    }, {
      "heading" : "1.2 Extensions",
      "text" : "Mini-Batch. Our result in this paper trivially extends to the mini-batch setting: if in each iteration we select fi(·) for more than one random indices i, then we can accordingly define the gradient estimator and the result of this paper still holds. Note that the speed up that we obtain in this case comparing to gradient descent is O((n/b)1/3) where b is the mini-batch size. Therefore, the smaller b is the better sequential running time we expect to see (which is also observed in our experiments). Other Smoothness Assumptions. Our result generalizes to the setting when each fi(·) enjoys a different smoothness parameter. In this setting one needs to select a random index i ∈ [n] with a non-uniform distribution in order to obtain a faster running time. Our result also generalizes to the upper-lower smoothness setting. Instead of requiring each fi(·) to be L-smooth, one can assume it is L-upper smooth and l-lower smooth, a notation introduced by [4]; in such a case, faster results can also be obtained using our same proof techniques.\nSum-of-Non-Convex Objectives. Our analogous proof also applies to the sum-of-non-convex setting which is the same Problem (1.1) except f(·) is guaranteed to be σ-strongly convex. Our obtained running time is Õ(n+ √ nL/σ) for SVRG. This is faster than the previous running time on SVRG which is Õ(n+L2/σ2), however, it is not faster than using SVRG+Catalyst which gives Õ(n + n3/4 √ L/ √ σ), see discussion in [4]. We do not include the details about this proof because it does not outperform SVRG+Catalyst.\nOther Variance-Reduction Methods. Our proof generalizes to all variance-reduction methods. However, for brevity we demonstrate it only for the SVRG algorithm."
    }, {
      "heading" : "1.3 Other Related Works",
      "text" : "For convex objectives, finding stationary points (or equivalently the global minimum) for problem (1.1) has received lots of attentions across machine learning and optimization communities; many first-order methods [8, 16, 23, 26] as well as their accelerations [1, 3, 18, 27, 28] have been proposed in the past a few years. Even in the case when f(·) is convex but each fi(·) is non-convex, the problem (1.1) can be solved easily [4, 11, 24].\nAlgorithm 1 Simplified SVRG method in the non-convex setting Input: xφ a starting vector, S number of epochs, m number of iterations per epoch, η step length. 1: x10 ← xφ 2: for s← 1 to S do 3: µ̃← ∇f(xs0) 4: for k ← 0 to m− 1 do 5: Pick i uniformly at random in {1, · · · , n}. 6: ∇̃ ← ∇fi(xsk)−∇fi(xs0) + µ̃ 7: xsk+1 = x s k − η∇̃\n8: end for 9: xs+10 ← xsm\n10: end for 11: return xsk for some random s ∈ {1, 2, . . . , S} and random k ∈ {1, 2, . . . ,m}.\nThe results of Li and Lin [17] and Ghadimi and Lan [13] unify the theory of non-convex and convex optimization in the following sense. They provide general first-order schemes such that, if the parameters are tuned properly, the schemes can converge (1) as fast as gradient descent in terms of finding an approximate stationary point; and (2) as fast as accelerated gradient descent [20] in terms of minimizing the objective if the function is convex. For the class of (1.1), their methods are only as slow as GD; in contrast, in this paper we prove theoretical convergence that is strictly faster than GD, which is both interesting and unknown.\nA few days after the first version of this paper appeared on arXiv, we became aware of another group of authors that have independently obtained essentially the same result [21, 22]. 4"
    }, {
      "heading" : "2 Notations and Algorithm",
      "text" : "A differentiable function f : Rn → R is L-smooth if for all pairs x, y ∈ Rn it satisfies ‖∇f(x) − ∇f(y)‖ ≤ L‖x− y‖. An equivalent definition says for for all x, y ∈ Rn:\n− L 2 ‖x− y‖2 ≤ f(x)− f(y)− 〈∇f(y), x− y〉 ≤ L 2 ‖x− y‖2 . (2.1)\nThe main body of this paper proves our result based on three false simplification assumptions 4.2, 4.3 and 4.4 for the sake of sketching the high-level intuitions and highlighting the differences between our proof and known results. Our formal convergence proof is quite technical and included in the full paper.\nIn this high-level proof, we consider Algorithm 1, a simplified version of our final SVRG method for the non-convex setting. Note that both the snapshot point and the starting iterate xs0 of the s-th epoch have been chosen as the last iterate of the previous epoch in Algorithm 1.\nRemark 2.1. In our final proof, we instead choose xs0 to be a weighted average of the last m 2/3 iterates from the previous epoch. See Algorithm 2 in the full paper. We demonstrate in Section 6 that this also a better choice in practice.\n4These results also address gradient dominated functions, for which our main theorem also applies as follows. A non-convex function f(·) is τ -gradient dominated if f(x)− f(x∗) ≤ τ‖∇f(x)‖2 for every x. Since our main theorem implies one can obtain x satisfying ‖∇f(x)‖2 ≤ 1\n2τ (f(x0) − f(x∗)) using O\n( n + n2/3Lτ ) stochastic gradients, by\nrepeating it log2(1/ε) times, we obtain an ε-minimizer of f(·) in O ( (n+ n2/3Lτ) log(1/ε) ) stochastic gradients.\nThroughout this paper we denote by xsk the k-th iterate of the s-th epoch, by ∇sk = ∇f(xsk) the full gradient at this iterate, and by ∇̃sk = ∇f(xs0)+∇if(xsk)−∇if(xs0) the gradient estimator which clearly satisfies Ei[∇̃sk] = ∇sk. We denote by isk the random index i chosen at iteration k of epoch s. We also denote by (σsk)\n2 def= ‖∇sk − ∇̃sk‖2 the variance of the gradient estimator ∇̃sk. Under these notations, our simplified SVRG algorithm in Algorithm 1 simply performs update xsk+1 ← xsk−η∇̃sk for a fixed step length η > 0 that shall be specified later.\nSince we focus mostly on analyzing a single epoch, when it is clear from the context, we drop the superscript s and denote by xk, ik, ∇k, ∇̃k, σ2k respectively for xsk, isk, ∇sk, ∇̃sk, (σsk)2. We also denote by H2k def = ‖∇k‖22, σ2i:j def = ∑j k=i σ 2 k and H2i:j def = ∑j k=iH2k for notational simplicity."
    }, {
      "heading" : "3 Two Useful Lemmas",
      "text" : "We first observe two simple lemmas. The first one describes the expected objective decrease between two consecutive iterations. This is a standard step that is used in analyzing gradient descent for smooth functions, and we additionally take into account the variance of the gradient estimator.\nLemma 3.1 (gradient descent). If xk+1 = xk − η∇̃k for some gradient estimator ∇̃k satisfying E[∇̃k] = ∇k = ∇f(xk), and if the step length η ≤ 1L , we have\nf(xk)− E[f(xk+1)] ≥ η\n2 ∇2k −\nη2L 2 E [ σ2k ] .\nProof. By the smoothness of the function, we have\nE[f(xk+1)] ≤ f(xk) + E [ 〈∇f(xk), xk+1 − xk〉 ] + E [L 2 ‖xk+1 − xk‖2 ]\n= f(xk)− η‖∇f(xk)‖2 + η2L 2 E [ ‖∇̃k‖2 ] = f(xk)− η‖∇f(xk)‖2 + η2L\n2 E [ ‖∇f(xk)‖2 + ‖∇̃k −∇f(xk)‖2 ] .\nThis immediately yields Lemma 3.1 by using the assumption that η ≤ 1L . The next lemma follows from the classical analysis of mirror descent methods.5 However, we make novel use of it on top of a non-convex but smooth function.\nLemma 3.2 (mirror descent). If xk+1 = xk − η∇̃k for some gradient estimator ∇̃k satisfying E[∇̃k] = ∇k = ∇f(xk), then for every u ∈ Rd it satisfies\nf(xk)− f(u) ≤ η\n2\n( H2k + E[σ2k] ) + ( 1\n2η + L 2\n) ‖xk − u‖2 − 1 2η E [ ‖xk+1 − u‖2 ] .\nProof. We first write the following inequality which follows from classical mirror-descent analysis.\n5Mirror descent is a terminology mostly used in optimization literature, see for instance the textbook [7]. In machine learning contexts, mirror-descent analysis is essentially identical to regret analysis. In our SVRG method, the descent step xsk+1 ← xsk − η∇̃sk can be interpreted as a mirror descent step in the Euclidean space (see for instance [2]), and therefore mirror-descent analysis applies.\nFor every u ∈ Rd, it satisfies\n〈∇k, xk − u〉 = E[〈∇̃k, xk − u〉] = E[〈∇̃k, xk − xk+1〉+ 〈∇̃k, xk+1 − u〉] = E[〈∇̃k, xk − xk+1〉 − 1\n2η ‖xk − xk+1‖2 +\n1\n2η ‖xk − u‖2 −\n1\n2η ‖xk+1 − u‖2]\n≤ E [η 2 ‖∇̃k‖2 + 1 2η ‖xk − u‖2 − 1 2η ‖xk+1 − u‖2 ] . (3.1)\nAbove, 〈∇̃k, xk+1 − u〉 = − 12η‖xk − xk+1‖2 + 12η‖xk − u‖2 − 12η‖xk+1 − u‖2 is known as the threepoint equality of Bregman divergence (in the special case of Euclidean space). The only inequality is because we have 12‖a‖2 + 12‖b‖2 ≥ 〈a, b〉 for any two vectors a, b.\nClassically in convex optimization, one would lower bound the left hand side of (3.1) by f(xk)− f(u) using the convexity of f(·). We take a different path here because our objective f(·) is not convex. Instead, we use the lower smoothness property of function f which is the first inequality in (2.1) to deduce that 〈∇k, xk − u〉 ≥ f(xk)− f(u)− L2 ‖xk − u‖2. Combining this with inequality (3.1), and taking into account E[‖∇̃k‖2] = ‖∇k‖2 + E[σ2k] by the definition of variance, we finish the proof of Lemma 3.2.\nOur main theorem is motivated by the linear-coupling framework [2]. In particular, we linearly couple the above gradient and mirror descent lemmas, together with a variance upper-bound lemma described in the next section."
    }, {
      "heading" : "4 Upper Bounding the Variance",
      "text" : "High-Level Ideas. The key idea behind all variance-reduction literatures (such as SVRG [16], SAGA [8], and SAG [23]) is to prove that the variance E[(σsk)2] decreases as s or k increases. However, the only known technique to achieve so is to upper bound E[(σsk)2] “essentially” by O ( f(xsk) − f(x∗) ) , the objective distance to the minimum. Perhaps the only exception is the work on sum-of-non-convex but strongly-convex objectives [4, 24], where the authors upper bound E[(σsk)2] by O ( ‖xsk − x∗‖2 ) , the squared vector distance to the minimum. Such techniques fail to apply in our non-convex setting, because gradient-descent based methods do not necessarily converge to the global minimum.\nWe take a different path in this paper. We upper bound E[(σsk)2] by O ( ‖xsk−xs0‖2 ) , the squared vector distance between the current vector xsk and the first vector (i.e., the snapshot) x s 0 of the\ncurrent epoch s. This is certainly tighter than O ( ‖xsk − x∗‖2 ) from prior work.6 Moreover, the less we move away from the snapshot, the better upper bound we obtain on the variance. This is conceptually different from all existing literatures.\nFurthermore, we in turn argue that ‖xsk−xs0‖2 is at most some constant times f(xsk)−f(xs0). To prove so, we wish to select u = xs0 in Lemma 3.2 and telescope it for multiple iterations k, ideally for all the iterations k within the same epoch. This is possible for convex objectives but impossible for non-convex ones. More specifically, the ratio between (1/2η+L/2) and (1/2η) can be much larger than 1, preventing us from telescoping more than O(1/ηL) iterations in any meaningful manner (see (4.1)). In contrast, this ratio would be identical to 1 in the convex setting, or even smaller than 1 in the strongly convex setting. For this reason, we define η = 1\nm2/3L , divide each epoch\ninto O(m1/3) subepochs each consisting of O(m2/3) consecutive iterations. Now we can telescope\n6This new technique has also been applied to convex settings recently [1].\nLemma 3.2 for all the iterations within a subepoch because m2/3 ≤ O(1/ηL). Finally, we use vector inequalities (see (4.5)) to combine these upper bounds for sub-epochs into an upper bound on the entire epoch. Technical Details. We choose η = 1m0L for some parameter m0 that divides m. We will set m0 to be m2/3 and the reason will become clear at the end of this section. Define d = m/m0 so an epoch is divided into d sub-epochs.\nWe make the following parameter choices\nDefinition 4.1. Define β0 = 1 and βt def = (1 + ηL)−t = (1 + 1/m0)−t for t = 1, . . . ,m0 − 1. We have 1 ≥ βt ≥ 1/e > 1/3. For each k = 0, 1, . . . ,m − m0, we sum up Lemma 3.2 for iterations k, k + 1, . . . , k + m0 − 1 with multiplicative weights β0, . . . , βm0−1 respectively. The norm square terms shall telescope in this summation, and we arrive at\nm0−1∑\nt=0\nβt ( f(xk+t)− f(u) ) ≤ η\n2\nm0−1∑\nt=0\nβt ( H2k+t + σ2k+t ) + ( 1\n2η + L 2\n) ‖xk − u‖2 −\nβm0−1 2η ‖xk+m0 − u‖2 .\n(4.1)\nSimplification 4.2. Since the weights β0, . . . , βm0−1 are within each other by a constant factor, let us assume for simplicity that they are all equal to 1.\nIf we choose u = xk and assume βt = 1 for all t, we can rewrite (4.1) as\n1\nm0\nm0−1∑\nt=0\n( f(xk+t)− f(xk) ) ≤ η\n2\n1\nm0\n( H2k:k+m0−1 + σ 2 k:k+m0−1 ) − 1\n6ηm0 ‖xk+m0 − xk‖2 . (4.2)\nSimplification 4.3. Since the left hand side of (4.2) is describing the average objective value f(xk), f(xk+1), . . . , f(xk+m0−1) which is hard to analyze, let us assume for simplicity that it can be replaced with the last iteration in this subepoch, that is\nf(xk+m0)− f(xk) ≤ η\n2\n1\nm0\n( H2k:k+m0−1 + σ 2 k:k+m0−1 ) − 1\n6ηm0 ‖xk+m0 − xk‖2 . (4.3)\nUsing the above inequality we provide a novel upper bound on the variance of the gradient estimator:\nEit [ σ2t ] = Eit [∥∥(∇fit(xt)−∇fit(x0) ) − ( ∇f(xt)−∇f(x0) )∥∥2]\n≤ Eit [∥∥∇fit(xt)−∇fit(x0) ∥∥2] ≤ L2‖xt − x0‖2 . (4.4)\nAbove, the first inequality is because for any random vector ζ ∈ Rd, it holds that E‖ζ − Eζ‖2 = E‖ζ‖2 − ‖Eζ‖2, and the second inequality is by the smoothness of each fi(·).\nIn particular, for t = m, we can upper bound σ2m using (4.4) and multiple times of (4.3):\nE[σ2m] ≤ L2E [ ‖xm − x0‖2 ] ≤ L2dE [ ‖xm − xm−m0‖2 + ‖xm−m0 − xm−2m0‖2 + · · ·+ ‖xm0 − x0‖2 ]\n≤ L2dE [ 6ηm0 ( f(x0)− f(xm) ) + 3η2 ( H20:m−1 + σ20:m−1 )] . (4.5)\nAbove, the first inequality follows from the vector inequality ‖v1+· · ·+vd‖2 ≤ d ( ‖v1‖2+· · ·+‖vd‖2 ) , and the second inequality follows from (4.3).\nSimplification 4.4. Suppose that (4.5) holds not only for σ2m but actually for all σ 2 0, . . . , σ 2 m−1, then it satisfies\n1\nm E[σ20:m−1] ≤ L2dE\n[ 6ηm0 ( f(x0)− f(xm) ) + 3η2 ( H20:m−1 + σ20:m−1 )] . (4.6)\nAs long as 3η2L2d ≤ 12m , (4.6) further implies\n1\nm E[σ20:m−1] ≤ 12ηm0L2d · E\n[ f(x0)− f(xm) + η\n2m0 H20:m−1\n] . (4.7)\nThis concludes our goal in this section which is to provide an upper bound (4.7) on the (average) variance by a constant times the objective difference f(x0)− f(xm)."
    }, {
      "heading" : "5 Final Theorem",
      "text" : "By applying the gradient descent guarantee Lemma 3.1 to the entire epoch. We obtain that\nf(x0)− E[f(xm)] ≥ E [η\n2 H20:m−1 −\nη2L\n2 σ20:m−1\n] .\nCombining this with the variance upper bound (4.7), we immediately have\nf(x0)− E[f(xm)] ≥ η\n2 E[H20:m−1]− 6η3m0mL3d · E[f(x0)− f(xm) +\nη\n2m0 H20:m−1] . (5.1)\nIn other words, as long as 6η3m0mL 3d ≤ 12 , we arrive at\nf(x0)− E[f(xm)] ≥ η\n6 E[H20:m−1] . (5.2)\nNote that (5.2) is only for a single epoch and can be written as f(xs0)−E[f(xsm)] ≥ η6E[ ∑m−1\nt=0 ‖∇f(xst )‖2] in the general notation. Therefore, we can telescope it over all epochs s = 1, 2, . . . , S. Since we have chosen xs0, the initial vector in epoch s, to be x s−1 m , the last vector of the previous epoch, we obtain that\n1\nSm\nS∑\ns=1\nm−1∑\nt=0\nE [ ‖∇f(xst )‖2 ] ≤ 6 ηSm (f(x10)− f(xSm)) ≤ 6(f(xφ)−minx f(x)) ηSm .\nAt this point, if we randomly select s ∈ [S] and t ∈ [m] at the end of the algorithm, we conclude that\nE[‖∇f(xst )‖2] ≤ 6(f(xφ)−minx f(x))\nηSm .\n(We remark here that selecting an average iterate to output is a common step also used by GD or SGD for non-convex optimization. This step is often unnecessarily in practice.)\nFinally, let use choose the parameters properly. We simply let m = n be the epoch length. Since we have required 3η2L2d ≤ 12m and 6η3m0mL3d ≤ 12 in the previous section, and both these requirements can be satisfied when m30 ≥ 12m2, we set m0 = Θ(m2/3) = Θ(n2/3). Accordingly η = 1m0L = Θ ( 1 n2/3L ) . In sum,\nTheorem 5.1. Under the simplification assumptions 4.2, 4.3 and 4.4, by choosing m = n and η = Θ ( 1\nn2/3L\n) , the produced output x of Algorithm 1 satisfies that7\nE[‖∇f(x)‖2] ≤ O (L(f(xφ)−minx f(x))\nSn1/3\n) ."
    }, {
      "heading" : "In other words, to obtain a point x satisfying ‖∇f(x)‖2 ≤ ε, the total number of iterations needed",
      "text" : "for Algorithm 1 is\nSn = O (n2/3L(f(xφ)−minx f(x))\nε\n) .\nThe amortized per-iteration complexity of SVRG is at most twice of SGD. Therefore, this is a factor of Ω(n1/3) faster than the full gradient descent method on solving (1.1)."
    }, {
      "heading" : "6 Experiments",
      "text" : ""
    }, {
      "heading" : "6.1 Empirical Risk Minimization with Non-Convex Loss",
      "text" : "We consider binary classification on four standard datasets that can be found on the LibSVM website [10]:\n• the adult (a9a) dataset (32, 561 training samples, 16, 281 testing samples, and 123 features). • the web (w8a) dataset (49, 749 training samples, 14, 951 testing samples, and 300 features). • the rcv1 (rcv1.binary) dataset (20, 242 training samples, 677, 399 testing samples, and 47, 236\nfeatures).\n• the mnist (class 1) dataset (60, 000 training samples, 10, 000 testing samples, and 780 features, Accuracy Experiment. In the first experiment we apply SVRG on training the `2-regularized ERM problem with six loss functions: logistic loss, squared loss, smoothed hinge loss (with smoothing parameters 0.01, 0.1 and 1 resp.), and smoothed zero-one loss (also known as sigmoid loss).8 We wish to see how non-convex loss compares to convex ones in terms of testing accuracy (and thus in terms of the generalization error).\nFor each of the four datasets, we also randomly flip 1/4 fraction, 1/8 fraction, or zero fraction of the training example labels. The purpose of this manipulation is to introduce outliers to the training set. We therefore have 4 × 3 = 12 datasets in total. We choose epoch length m = 2n as suggested by the paper SVRG for ERM experiments, and use the simple Algorithm 1 for both convex and non-convex loss functions.\nWe present the accuracy results partially in Figure 1 (and the full version can be found in Figure 4 in the appendix). The y-axis represents the classification testing accuracy, and the x-axis represents the number of passes to the dataset. (Each iteration of SVRG counts as 1/n pass and the full-gradient computation of SVRG counts as 1 pass.)\nThese plots are produced based on a fair and careful parameter-tuning and parameter-validation procedure that can be described in the following four steps. Step I: for each of the 12 datasets, we partition the training samples randomly into a training set of size 4/5 and a validation set of size\n7Like in SGD, one can easily apply a Markov inequality to conclude that with probability at least 2/3 we have the same asymptotic upper bound on the deterministic quantity ‖∇f(x)‖2.\n8For the sigmoid loss, we scale it properly so that its smoothness parameter is exactly 1. Unlike hinge loss, it is unnecessary to consider sigmoid loss with different smoothness parameters: one can carefully verify that by scaling up or down the weight of the `2 regularizer, it is equivalent to changing the smoothness of the sigmoid loss.\n1/5. Step II: for each of the 12 datasets and each loss function, we enumerate over 10 choices of λ, the regularization parameter. For each λ, we tune SVRG on the training set with different step lengths η and choose the best η that gives the fastest training speed. Step III: for each of the 12 datasets and each loss function, we tune the best λ using the validation set. That is, we use the selected η from Step II to train the linear predictor, and apply it on the validation set to obtain the testing accuracy. We then select the λ that gives the best testing accuracy for the validation set. Step IV: for each of the 12 datasets and each loss function, we apply the validated linear predictor to the testing set and present it in Figure 1 and Figure 4.\nWe make the following observations from this experiment.\n• Although sigmoid loss is only comparable to hinge loss or logistic loss for “no flip” datasets, however, when the input has a lot of outliers (see “flip 1/8” and “flip 1/4”), sigmoid loss is undoubtedly the best choice. Square loss is almost always dominated because it is not necessarily a good choice for binary classification.\n• The running time needed for SVRG on these datasets are quite comparable, regardless of the loss function being convex or not.\nRunning-Time Experiment. In this second experiment, we fix the regularization parameter λ and compare the training objective convergence between SGD and SVRG for sigmoid loss only.9 We choose four different λ per dataset and present our plots partially in Figure 2 (and the full plots can be found in Figure 5 in the appendix). In these plots, the y-axis represents the training objective value, and the x-axis represents the number of passes to the dataset.\nFor a fair comparison we need to tune the step length η for each dataset and each choice of λ. For SGD, we enumerate over polynomial learning rates ηk = α · (1 + k/n)β where k is the number of iterations passed; we have made 10 choices of α, considered β = 0, 0.1, . . . , 1.0, and selected the learning rate that gives a fastest convergence. For SVRG, we first consider the vanilla SVRG using a constant η throughout all iterations, and select the best η that gives the fastest convergence. This curve is presented in dashed blue in Figure 5. We also implement SVRG with polynomial learning rates ηk = α · (1 + k/n)β and tune the best α, β parameters and present the results in dashed black curves in Figure 5.\nWe make the following observations from this experiment.\n• Consistent with theory, SVRG is not necessarily a better choice than SGD for large training error ε. However, SVRG enjoys a very fast convergence especially for small ε.\n• The smaller λ is, the more “non-convex” the objective function becomes. We see that SGD performs more poorer than SVRG in these cases.10 • With only one exception (dataset web with λ = 10−6), choosing a polynomial learning rate does not seem necessary in terms of improving the running time for training ERM problems with non-convex loss.\n• Although not presented in Figure 5, the best-tuned polynomial learning rates for SVRG have smaller exponents β as compared to SGD in each of the 16 plots."
    }, {
      "heading" : "6.2 Neural Network",
      "text" : "We consider the multi-class (in fact, 10-class) classification problem on CIFAR-10 (60, 000 training samples) and MNIST (10, 000 training samples), two standard image datasets for neural net studies. We construct a toy two-layered neural net, with (1) 64 hidden nodes in the first layer, each connecting to a uniformly distributed 4x4 or 5x5 pixel block of the input image and having a smoothed relu (also known as softplus) activation function; (2) 10 output nodes on the second\n9This experiment is the minimization problem with respect to all training samples since there is no need to perform validation.\n10We note that the plots for different values λ are presented with different vertical scales. For instance, at 100 passes of the dataset, the objective difference between SVRG and SGD is more than 2×10−4 for λ = 10−6 on dataset web, but less than 5× 10−6 for λ = 10−3.\nlayer, fully connected to the first layer and each representing one of the ten classification outputs. We consider training such neural networks with the multi-class logistic loss that is a function on the 10 outputs and the correct label. For each of the two datasets, we consider both training the unregularized version, as well as the `2 regularized version with weight 10\n−3 for CIFAR-10 and 10−4 for MNIST, two parameters suggested by [16].\nWe implement two classical algorithms: stochastic gradient descent (SGD) with the best tuned polynomial learning rate and adaptive subGradient method (AdaGrad) of [9, 19] which is essentially SGD but with an adaptive learning rate. We choose a mini-batch size of 100 for both these methods. We consider four variants of SVRG, all of which use epoch length m = 5n/b if b is the mini-batch size: • SVRG-1, the simple Algorithm 1 with a best tuned polynomial learning rate and b = 100. • SVRG-2, our full Algorithm 2 with a best tuned polynomial learning rate and b = 100.11\n• SVRG-3, using adaptive learning rate (similar to AdaGrad) on top of SVRG-2 with b = 100. • SVRG-4, same as SVRG-3 but with b = 16. Our training error performance is presented in Figure 3. We also include the testing accuracy in Figure 6 in the appendix. In these plots the y axis represents the training objective value, and the x axis represents the number of passes to the dataset. Each iteration of SGD or SVRG counts as b/n pass of the dataset, and the snapshot full-gradient computation counts as 1 pass.12 From the plots we clearly see a performance advantage for using SVRG-based algorithms as compared to SGD or AdaGrad. Furthermore, we observe that the following three features on top of SVRG could further improve its running time:\n1. Comparing SVRG-2 with SVRG-1, we see that setting the epoch initial vector to be a weighted average of the last a few iterations of the previous epoch is recommended.\n2. Comparing SVRG-3 with SVRG-2, we see that using adaptive learning rates comparing to tuning the best polynomial learning rate is recommended.\n3. Comparing SVRG-4 with SVRG-3, we see that a smaller mini-batch size is recommended in terms of the total complexity. In contrast, reducing the mini-batch size is discouraged for SGD or AdaGrad because the variance could blow up and the performances would be decreased (this is also observed by our experiment but not included in the plots).\nWe hope that the above observations provide new insights for experimentalists working on deep learning.\n11That is, we set the initial vector of each epoch to be weighted average of the last (m/b)2/3 vectors from the previous epoch.\n12The number of passes to the dataset is a traditional unit for comparing stochastic methods. For ERM problems, it is natural to count each iteration of SVRG as b/n passes of the data rather than 2b/n, because the computation of ∇fi(x̃) is free if one efficiently stores ∇fi(x̃) when the full gradient was computed at x̃. However, after our paper has appeared online, we noticed this measurement may not be fair for SGD on training neural networks, because it is memory-inefficient to store ∇fi(x̃) when fi comes from a large-scale neural network. For this reason, the sequential per-iteration cost of SVRG can be a factor (2 + 1/5)/(1 + 1/5) = 11/6 greater than SGD. Nevertheless, the extra cost on computing ∇fi(x̃) is totally parallelizable (and can be viewed as doubling the mini-batch size), so this may not affect the GPU-based running time of SVRG by that much. We leave it a future work to run SVRG on large-scale network networks because it is beyond the scope of this paper.\nAlgorithm 2 Our full SVRG method in the non-convex setting Input: xφ a starting vector, S number of epochs, m number of iterations per epoch, m0 subepoch length, η step length.\n1: x10 ← xφ 2: for s← 1 to S do 3: µ̃← ∇f(xs0) 4: for k ← 0 to m− 1 do 5: Pick i uniformly at random in {1, · · · , n}. 6: ∇̃ ← ∇fi(xsk)−∇fi(xs0) + µ̃ 7: xsk+1 = x s k − η∇̃ 8: end for 9: Define β0, β1, . . . , βm0−1 following Definition 4.1\n10: Select a random ms ∈ {m,m− 1, . . . ,m−m0 + 1} with probability proportional to { βm0−1, 10\n9 βm0−1,\n10\n9 (βm0−1 + βm0−2), . . . ,\n10\n9 (βm0−1 + · · ·+ β1)\n} .\n11: xs+10 ← xsms . 12: end for 13: return a vector uniformly at random from the set {xst−1 : s ∈ [S], t ∈ [ms]}"
    }, {
      "heading" : "Acknowledgements",
      "text" : "E. Hazan acknowledges support from the National Science Foundation grant IIS-1523815 and a Google research award. Z. Allen-Zhu acknowledges support from a Microsoft research award, no. 0518584.\nAppendix"
    }, {
      "heading" : "A Detailed Proof",
      "text" : "In the detailed proof, we again first concentrating on analyzing a single epoch. We choose as before η = 1m0L for some parameter m0 that divides m. The natural choice of m0 shall become clear at the end of this section, and would be set to around m2/3. Define d = m/m0 so an epoch is divided into d sub-epochs. We denote by x−m0+1 = · · · = x−1 def = x0 for notational convenience, and similarly define ∇−m0+1 = · · · = ∇−1 = ∇̃−m0+1 = · · · = ∇̃−1 = σ−m0+1 = · · · = σ−1 = 0. Throughout this section, we also drop the expectation sign E[·] for notational simplicity.\nOur full algorithm for the non-convex setting is slightly different from our sketched proof, see Algorithm 2. Most importantly, instead of setting the first vector of each epoch to be the last iterate of the previous epoch, we set it to be a non-uniform random iterate in the last subepoch of the previous epoch. This step is crucial for our analysis to hold without the simplification assumptions.\nA.1 Upper Bounding the Variance\nThe following lemma is a simple counterpart to (4.4) in our sketched-proof section. It upper bounds the average variance inside an epoch by the average squared distances between vectors that are m0 iterations away from each other.\nLemma A.1. m−1∑\nt=0\nσ2t ≤ L2d2 m−1∑\nt=0\n‖xt+1 − xt+1−m0‖2\nProof. Recall that we have that for every t ∈ {0, 1, . . . ,m− 1}, we have\nσ2t ≤ L2‖xt − x0‖2 ≤ L2d(‖xt − xt−m0‖2 + ‖xt−m0 − xt−2m0‖2 + · · · )\nSumming this up over all possible t’s, we have\nm−1∑\nt=0\nσ2t ≤ L2d2 m−1∑\nt=0\n‖xt+1 − xt+1−m0‖2 .\nWe emphasize that this analysis relies on our careful choice of x−m0+1 = · · · = x−1 def = x0 which simplifies our notations. We next state a simple variant of Lemma 3.2 that allows negative indices:\nLemma A.2. For every k ∈ {−m0 + 1, . . . ,m−m0}, every t ∈ {0, . . . ,m0− 1}, and every u ∈ Rd, we have\nf(xk+t)− f(u) ≤ η\n2\n( H2k+t + σ2k+t ) + ( 1\n2η + L 2\n) ‖xk+t − u‖2 − 1\n2η ‖xk+t+1 − u‖2\nWe define the same sequence of β0, β1, . . . , βm0−1 as before:\nDefinition A.3. Define β0 = 1 and βt def = (1 + ηL)−t = (1 + 1/m0)−t for t = 1, . . . ,m0 − 1. We have 1 ≥ βt ≥ 1/e > 1/3. By summing up Lemma A.2 with multiplicative ratios βt for each t = 0, 1, . . . ,m0−1, we arrive at the following lemma which is a counterpart of (4.1) in the sketched-proof section.\nLemma A.4. For every k ∈ {−m0 + 1, . . . ,m−m0}, and every u, m0−1∑\nt=0\nβt ( f(xk+t)− f(u) ) ≤ η\n2\nm0−1∑\nt=0\nβt ( H2k+t + σ2k+t ) + ( 1\n2η + L 2\n) ‖xk − u‖2 −\nβm0−1 2η ‖xk+m0 − u‖2\nIn particular, if we select u = xk, we obtain that\nm0−1∑\nt=1\nβt ( f(xk+t)− f(xk) ) ≤ η\n2\nm0−1∑\nt=0\nβt ( H2k+t + σ2k+t ) − 1\n6η ‖xk+m0 − xk‖2 . (A.1)\nThe next lemma sums up (A.1) over all possible values of k. It can be viewed as a weighted, more sophisticated version of (4.6) in our sketched-proof section.\nLemma A.5. As long as m0 ≤ 16η2L2d2 , we have\nβm0−1 ( f(xm−1)− f(x0)− 2ηH20:m−2 )\n+ (βm0−1 + βm0−2) ( f(xm−2)− f(x0)− 2ηH20:m−3 ) + · · · + (β1 + · · ·+ βm0−1) ( f(xm−m0+1)− f(x0)− 2ηH20:m−m0 )\n≤ η 2 βm0−1H2m−1 −\n1\n12ηL2d2\nm−1∑\nt=0\nσ2t .\nProof. By carefully summing up (A.1) for k ∈ {−m0 + 1, . . . ,m−m0}, we have that\nβm0−1f(xm−1) + (βm0−1 + βm0−2)f(xm−2) + · · ·+ (β1 + · · ·+ βm0−1)f(xm−m0+1) − (β1 + · · ·+ βm0−1)f(x−m0+1)− (β2 + · · ·+ βm0−1)f(x−m0+2)− · · · − βm0−1f(x−1)\n≤ η 2\n(m0−1∑\nt=0\nβt )(m−1∑\nt=0\nσ2t ) + η\n2\n(m0−1∑\nt=0\nβt )(m−m0∑\nt=0\nH2t )\n+ η\n2\n( βm0−1H2m−1 + (βm0−1 + βm0−2)H2m−2 + · · ·+ (β1 + · · ·+ βm0−1)H2m−m0+1 )\n− 1 6η\nm−1∑\nt=0\n‖xt+1 − xt+1−m0‖2 .\nUsing the fact that x−m0+1 = · · · = x−1 def = x0, we can rewrite the left hand side and get\nβm0−1 ( f(xm−1)− f(x0) ) + (βm0−1 + βm0−2) ( f(xm−2)− f(x0) ) + · · · + (β1 + · · ·+ βm0−1) ( f(xm−m0+1)− f(x0) )\n≤ η 2\n(m0−1∑\nt=0\nβt )(m−1∑\nt=0\nσ2t ) + η\n2\n(m0−1∑\nt=0\nβt )(m−m0∑\nt=0\nH2t )\n+ η\n2 ( βm0−1H2m−1 + (βm0−1 + βm0−2)H2m−2 + · · ·+ (β1 + · · ·+ βm0−1)H2m−m0+1︸ ︷︷ ︸\n¬\n)\n− 1 6η\nm−1∑\nt=0\n‖xt+1 − xt+1−m0‖2 .\nUsing the specific values of βt’s, we can relax the terms in ¬ above and rewrite the above inequality as\nβm0−1 ( f(xm−1)− f(x0)− 2ηH2m−2 ) + (βm0−1 + βm0−2) ( f(xm−2)− f(x0)− 2ηH2m−3 ) + · · · + (β1 + · · ·+ βm0−1) ( f(xm−m0+1)− f(x0)− 2H2m−m0 )\n≤ η 2\n(m0−1∑\nt=0\nβt )(m−1∑\nt=0\nσ2t ) + η\n2\n(m0−1∑\nt=0\nβt )(m−m0−1∑\nt=0\nH2t )\n︸ ︷︷ ︸ \n+ η\n2 βm0−1H2m−1 −\n1\n6η\nm−1∑\nt=0\n‖xt+1 − xt+1−m0‖2 .\nNow we further relax the terms in  above and further conclude that\nβm0−1 ( f(xm−1)− f(x0)− 2ηH20:m−2 ) + (βm0−1 + βm0−2) ( f(xm−2)− f(x0)− 2ηH20:m−3 ) + · · · + (β1 + · · ·+ βm0−1) ( f(xm−m0+1)− f(x0)− 2ηH20:m−m0 )\n≤ η 2\n(m0−1∑\nt=0\nβt )(m−1∑\nt=0\nσ2t ) + η\n2 βm0−1H2m−1 −\n1\n6η\nm−1∑\nt=0\n‖xt+1 − xt+1−m0‖2\n︸ ︷︷ ︸ ®\n.\nApplying the variance bound Lemma A.1 on the summation ®, we have\nβm0−1 ( f(xm−1)− f(x0)− 2ηH20:m−2 ) + (βm0−1 + βm0−2) ( f(xm−2)− f(x0)− 2ηH20:m−3 ) + · · · + (β1 + · · ·+ βm0−1) ( f(xm−m0+1)− f(x0)− 2ηH20:m−m0 )\n≤ η 2\n(m0−1∑\nt=0\nβt )(m−1∑\nt=0\nσ2t ) + η\n2 βm0−1H2m−1 −\n1\n6ηL2d2\nm−1∑\nt=0\nσ2t .\nFinally, as long as ∑m0−1\nt=0 βt ≤ 16η2L2d2 (which can be satisfied because m0 ≤ 16η2L2d2 ), we have\nβm0−1 ( f(xm−1)− f(x0)− 2ηH20:m−2 ) + (βm0−1 + βm0−2) ( f(xm−2)− f(x0)− 2ηH20:m−3 ) + · · · + (β1 + · · ·+ βm0−1) ( f(xm−m0+1)− f(x0)− 2ηH20:m−m0 )\n≤ η 2 βm0−1H2m−1 −\n1\n12ηL2d2\nm−1∑\nt=0\nσ2t .\nThis finishes the proof of Lemma A.5.\nA.2 Objective Decrease using Gradient Descent\nThe following lemma is a variant of (5.1). However, instead of lower bounding the objective decrease f(x0)−f(xm) for the entire epoch as in the sketched-proof section, we have to carefully lower bound a weighted sum of f(x0)− f(xt) for t ∈ {m,m− 1, . . . ,m−m0 + 1}, in order to make it consistent with the left hand side of Lemma A.5.\nLemma A.6.\nβm0−1 ( f(x0)− f(xm)− η\n2 H20:m−1\n) + βm0−1 ( f(x0)− f(xm−1)− η\n2 H20:m−2\n)\n+ (βm0−1 + βm0−2) ( f(x0)− f(xm−2)− η\n2 H20:m−3\n) + · · ·\n+ (β1 + · · ·+ βm0−1) ( f(x0)− f(xm−m0+1)− η\n2 H20:m−m0\n)\n≥ −η 2Lm0\n2\nm−1∑\nt=0\nσ2t\nProof. For each j = 1, 2, . . . ,m0, by telescoping Lemma 3.1 across iterations k = 0, 1, . . . ,m − j, we arrive at inequality\nf(x0)− f(xm−j+1) ≥ η\n2 H20:m−j −\nη2L\n2\nm−1∑\nt=0\nσ2t .\nNow we write down these m0 inequalities separately, and multiply each of them by a positive weight:\nβm0−1 × { f(x0)− f(xm) ≥ η\n2 H20:m−1 −\nη2L\n2\nm−1∑\nt=0\nσ2t\n}\nβm0−1 × { f(x0)− f(xm−1) ≥ η\n2 H20:m−2 −\nη2L\n2\nm−1∑\nt=0\nσ2t\n}\n(βm0−2 + βm0−1)× { f(x0)− f(xm−2) ≥ η\n2 H20:m−3 −\nη2L\n2\nm−1∑\nt=0\nσ2t\n} · · ·\n(β1 + · · ·+ βm0−1)× { f(x0)− f(xm−m0+1) ≥ η\n2 H20:m−m0 −\nη2L\n2\nm−1∑\nt=0\nσ2t\n}\nSumming these inequalities up, we obtain our desired inequality\nβm0−1 ( f(x0)− f(xm)− η\n2 H20:m−1\n) + βm0−1 ( f(x0)− f(xm−1)− η\n2 H20:m−2\n)\n+ (βm0−1 + βm0−2) ( f(x0)− f(xm−2)− η\n2 H20:m−3\n) + · · ·\n+ (β1 + · · ·+ βm0−1) ( f(x0)− f(xm−m0+1)− η\n2 H20:m−m0\n)\n≥ −η 2Lm20\n2\nm−1∑\nt=0\nσ2t .\nA.3 Final Theorem\nLet us now put together Lemma A.5 and Lemma A.6, and derive the following lemma:\nLemma A.7. As long as 6η3L3m20d 2 = 1/9, we have\nβm0−1 ( f(x0)− f(xm)− η\n4 H20:m−1\n) +\n10βm0−1 9\n( f(x0)− f(xm−1)− η\n4 H20:m−2\n)\n+ 10\n9 (βm0−1 + βm0−2)\n( f(x0)− f(xm−2)− η\n4 H20:m−3\n) + · · ·\n+ 10\n9 (β1 + · · ·+ βm0−1)\n( f(x0)− f(xm−m0+1)− η\n4 H20:m−m0\n) ≥ 0 .\nProof. By directly combining Lemma A.5 and Lemma A.6, we have\nβm0−1 ( f(x0)− f(xm)− η\n2 H20:m−1\n) + βm0−1 ( f(x0)− f(xm−1)− η\n2 H20:m−2\n)\n+ (βm0−1 + βm0−2) ( f(x0)− f(xm−2)− η\n2 H20:m−3\n) + · · ·\n+ (β1 + · · ·+ βm0−1) ( f(x0)− f(xm−m0+1)− η\n2 H20:m−m0\n)\n≥ 12ηL2d2 · η 2Lm20 2 · ( βm0−1 ( f(xm−1)− f(x0)− 2ηH20:m−2 )\n+ (βm0−1 + βm0−2) ( f(xm−2)− f(x0)− 2ηH20:m−3 ) + · · · + (β1 + · · ·+ βm0−1) ( f(xm−m0+1)− f(x0)− 2ηH20:m−m0 ) − η\n2 βm0−1H2m−1\n)\nSuppose we have 12ηL2d2 · η 2Lm20 2 = 6η 3L3m20d 2 = 1/9, then it satisfies that\nβm0−1 ( f(x0)− f(xm)− η\n2 H20:m−1\n) + βm0−1 ( f(x0)− f(xm−1)− η\n2 H20:m−2\n)\n+ (βm0−1 + βm0−2) ( f(x0)− f(xm−2)− η\n2 H20:m−3\n) + · · ·\n+ (β1 + · · ·+ βm0−1) ( f(x0)− f(xm−m0+1)− η\n2 H20:m−m0\n)\n≥ 1 9\n( βm0−1 ( f(xm−1)− f(x0)− 2ηH20:m−2 )\n+ (βm0−1 + βm0−2) ( f(xm−2)− f(x0)− 2ηH20:m−3 ) + · · · + (β1 + · · ·+ βm0−1) ( f(xm−m0+1)− f(x0)− 2ηH20:m−m0 ) − η\n2 βm0−1H2m−1\n)\nAfter rearranging, we have\nβm0−1 ( f(x0)− f(xm)− η\n2 H20:m−1\n) +\n10βm0−1 9\n( f(x0)− f(xm−1)− η\n4 H20:m−2\n)\n+ 10\n9 (βm0−1 + βm0−2)\n( f(x0)− f(xm−2)− η\n4 H20:m−3\n) + · · ·\n+ 10\n9 (β1 + · · ·+ βm0−1)\n( f(x0)− f(xm−m0+1)− η\n4 H20:m−m0\n) ≥ − η\n18 βm0−1H2m−1 .\nAfter relaxing the right hand side, we conclude that\nβm0−1 ( f(x0)− f(xm)− η\n4 H20:m−1\n) +\n10βm0−1 9\n( f(x0)− f(xm−1)− η\n4 H20:m−2\n)\n+ 10\n9 (βm0−1 + βm0−2)\n( f(x0)− f(xm−2)− η\n4 H20:m−3\n) + · · ·\n+ 10\n9 (β1 + · · ·+ βm0−1)\n( f(x0)− f(xm−m0+1)− η\n4 H20:m−m0\n) ≥ 0 .\nThis finishes the proof of Lemma A.7. Lemma A.8 naturally implies that if we select a random stopping vector for this epoch, we have the following corollary which is a counterpart of (5.2) in our sketch-proof section:\nCorollary A.8. If we set ms to be a random variable in {m,m−1, . . . ,m−m0+1}, with probabilities proportional to { βm0−1, 10 9 βm0−1, 10 9 (βm0−1 + βm0−2), . . . , 10 9 (βm0−1 + · · ·+ β1) } , then Lemma A.7 implies that we have\nE [ f(x0)− f(xms)− η\n4 H20:ms−1\n] ≥ 0 .\nNote that Corollary A.8 is only for a single epoch and can be written as\nE[f(xs0)− f(xsms)] ≥ η 4 E [ms−1∑\nt=0\n‖∇f(xst )‖2 ]\nin the general notation. Therefore, we are now ready to telescope it over all the epochs s = 1, 2, . . . , S. Recall that we have chosen xs0, the initial vector in epoch s, to be x s−1 ms−1 , the random stopping vector from the previous epoch. Therefore, we obtain that\n1 m1 + · · ·+mS S∑\ns=1\nms−1∑\nt=0\nE [ ‖∇f(xst )‖2 ] ≤ 4 ηS(m1 + · · ·+mS) ( f(x10)− E[f(xSmS )] )\n≤ O (f(xφ)−minx f(x)\nηSm\n) .\nAt this point, if we select uniformly at random an output vector x from the set {xst−1 : s ∈ [S], t ∈ [ms]}, we conclude that\nE[‖∇f(xst )‖2] ≤ O (f(xφ)−minx f(x)\nηSm\n) .\nFinally, let use choose the parameters properly. We simply let m = n be the epoch length. Since we have required m0 ≤ 16η2L2d2 and 6η3L3m20d2 = 1/9 in Lemma A.5 and Lemma A.7 respectively, and both these requirements can be satisfied when m30 ≥ 54m2, we set m0 = Θ(m2/3) = Θ(n2/3). Accordingly η = 1m0L = O ( 1 n2/3L ) . In sum, Theorem A.9 (Formal statement of Theorem 5.1). By choosing m = n and θ = Θ (\n1 n2/3L\n) , the\nproduced output x of Algorithm 2 satisfies that13\nE[‖∇f(x)‖2] ≤ O (L(f(xφ)−minx f(x))\nSn1/3\n) ."
    }, {
      "heading" : "In other words, to obtain a point x satisfying ‖∇f(x)‖2 ≤ ε, the total number of iterations needed",
      "text" : "for Algorithm 1 is\nSn = O (n2/3L(f(xφ)−minx f(x))\nε\n) .\n13Like in SGD, one can easily apply a Markov inequality to conclude that with probability at least 2/3 we have the same asymptotic upper bound on the deterministic quantity ‖∇f(x)‖2."
    } ],
    "references" : [ {
      "title" : "Katyusha: The First Direct Acceleration of Stochastic Gradient Methods",
      "author" : [ "Zeyuan Allen-Zhu" ],
      "venue" : "ArXiv e-prints,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2016
    }, {
      "title" : "Linear coupling: An ultimate unification of gradient and mirror descent",
      "author" : [ "Zeyuan Allen-Zhu", "Lorenzo Orecchia" ],
      "venue" : "ArXiv e-prints,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2014
    }, {
      "title" : "Even Faster Accelerated Coordinate Descent Using Non-Uniform Sampling",
      "author" : [ "Zeyuan Allen-Zhu", "Peter Richtárik", "Zheng Qu", "Yang Yuan" ],
      "venue" : "In ICML,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2016
    }, {
      "title" : "Improved SVRG for Non-Strongly-Convex or Sum-of-Non- Convex Objectives",
      "author" : [ "Zeyuan Allen-Zhu", "Yang Yuan" ],
      "venue" : "In ICML,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2016
    }, {
      "title" : "A practical algorithm for topic modeling with provable guarantees",
      "author" : [ "Sanjeev Arora", "Rong Ge", "Yonatan Halpern", "David M. Mimno", "Ankur Moitra", "David Sontag", "Yichen Wu", "Michael Zhu" ],
      "venue" : "In ICML,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2013
    }, {
      "title" : "New algorithms for learning incoherent and overcomplete dictionaries",
      "author" : [ "Sanjeev Arora", "Rong Ge", "Ankur Moitra" ],
      "venue" : "In COLT,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2014
    }, {
      "title" : "Lectures on Modern Convex Optimization",
      "author" : [ "Aharon Ben-Tal", "Arkadi Nemirovski" ],
      "venue" : "Society for Industrial and Applied Mathematics,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2013
    }, {
      "title" : "SAGA: A Fast Incremental Gradient Method With Support for Non-Strongly Convex Composite Objectives",
      "author" : [ "Aaron Defazio", "Francis Bach", "Simon Lacoste-Julien" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2014
    }, {
      "title" : "Adaptive subgradient methods for online learning and stochastic optimization",
      "author" : [ "John Duchi", "Elad Hazan", "Yoram Singer" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2011
    }, {
      "title" : "LIBSVM Data: Classification, Regression and Multi-label",
      "author" : [ "Rong-En Fan", "Chih-Jen Lin" ],
      "venue" : null,
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2015
    }, {
      "title" : "Fast and simple PCA via convex optimization",
      "author" : [ "Dan Garber", "Elad Hazan" ],
      "venue" : "ArXiv e-prints,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2015
    }, {
      "title" : "Escaping from saddle points—online stochastic gradient for tensor decomposition",
      "author" : [ "Rong Ge", "Furong Huang", "Chi Jin", "Yang Yuan" ],
      "venue" : "In COLT,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2015
    }, {
      "title" : "Accelerated gradient methods for nonconvex nonlinear and stochastic programming",
      "author" : [ "Saeed Ghadimi", "Guanghui Lan" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2015
    }, {
      "title" : "DRAFT: Introduction to online convex optimimization",
      "author" : [ "Elad Hazan" ],
      "venue" : "Foundations and Trends in Machine Learning,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2015
    }, {
      "title" : "A spectral algorithm for learning hidden markov models",
      "author" : [ "Daniel Hsu", "Sham M. Kakade", "Tong Zhang" ],
      "venue" : "J. Comput. Syst. Sci.,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2012
    }, {
      "title" : "Accelerating stochastic gradient descent using predictive variance reduction",
      "author" : [ "Rie Johnson", "Tong Zhang" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2013
    }, {
      "title" : "Accelerated Proximal Gradient Methods for Nonconvex Programming",
      "author" : [ "Huan Li", "Zhouchen Lin" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2015
    }, {
      "title" : "An Accelerated Proximal Coordinate Gradient Method and its Application to Regularized Empirical Risk Minimization",
      "author" : [ "Qihang Lin", "Zhaosong Lu", "Lin Xiao" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2014
    }, {
      "title" : "Adaptive Bound Optimization for Online Convex Optimization",
      "author" : [ "H. Brendan McMahan", "Matthew Streeter" ],
      "venue" : "In Proceedings of the 23rd Annual Conference on Learning Theory - COLT",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2010
    }, {
      "title" : "Introductory Lectures on Convex Programming Volume: A Basic course, volume I",
      "author" : [ "Yurii Nesterov" ],
      "venue" : "Kluwer Academic Publishers,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2004
    }, {
      "title" : "Stochastic variance reduction for nonconvex optimization",
      "author" : [ "Sashank J. Reddi", "Ahmed Hefny", "Suvrit Sra", "Barnabas Poczos", "Alex Smola" ],
      "venue" : "ArXiv e-prints,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2016
    }, {
      "title" : "Fast incremental method for nonconvex optimization",
      "author" : [ "Sashank J. Reddi", "Suvrit Sra", "Barnabas Poczos", "Alex Smola" ],
      "venue" : "ArXiv e-prints,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2016
    }, {
      "title" : "Minimizing finite sums with the stochastic average gradient",
      "author" : [ "Mark Schmidt", "Nicolas Le Roux", "Francis Bach" ],
      "venue" : "arXiv preprint arXiv:1309.2388,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2013
    }, {
      "title" : "SDCA without Duality",
      "author" : [ "Shai Shalev-Shwartz" ],
      "venue" : "arXiv preprint arXiv:1502.06177,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2015
    }, {
      "title" : "Learning kernel-based halfspaces with the 0-1 loss",
      "author" : [ "Shai Shalev-Shwartz", "Ohad Shamir", "Karthik Sridharan" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2011
    }, {
      "title" : "Stochastic dual coordinate ascent methods for regularized loss minimization",
      "author" : [ "Shai Shalev-Shwartz", "Tong Zhang" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2013
    }, {
      "title" : "Accelerated Proximal Stochastic Dual Coordinate Ascent for Regularized Loss Minimization",
      "author" : [ "Shai Shalev-Shwartz", "Tong Zhang" ],
      "venue" : "In ICML,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2014
    }, {
      "title" : "Stochastic Primal-Dual Coordinate Method for Regularized Empirical Risk Minimization",
      "author" : [ "Yuchen Zhang", "Lin Xiao" ],
      "venue" : "In ICML,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "For some models, probabilistic and other assumptions on the input can be used to give specially designed polynomial-time algorithms [5, 6, 15].",
      "startOffset" : 132,
      "endOffset" : 142
    }, {
      "referenceID" : 5,
      "context" : "For some models, probabilistic and other assumptions on the input can be used to give specially designed polynomial-time algorithms [5, 6, 15].",
      "startOffset" : 132,
      "endOffset" : 142
    }, {
      "referenceID" : 14,
      "context" : "For some models, probabilistic and other assumptions on the input can be used to give specially designed polynomial-time algorithms [5, 6, 15].",
      "startOffset" : 132,
      "endOffset" : 142
    }, {
      "referenceID" : 12,
      "context" : "Following the classical benchmark for non-convex optimization (see for instance [13]), we focus on algorithms that can efficiently find an approximate stationary point x satisfying ‖∇f(x)‖2 ≤ ε.",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 11,
      "context" : "[12] also demonstrated that a simple noise-addition scheme is sufficient for stochastic gradient descent to escape from saddle points.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "This is a folklore result in optimization and included for instance in [13].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 12,
      "context" : "This result is perhaps first formalized by Ghadimi and Lan [13].",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 15,
      "context" : "1 Our Result We prove that variance reduction techniques, based on the SVRG method [16], produce an εstationary point in only O (n2/3L(f(x0)−f(x∗)) ε ) iterations.",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 13,
      "context" : "3 of [14] usually turn each fi(x) into a smooth function without sacrificing too much accuracy.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 15,
      "context" : "Our proposed algorithm is very analogous to SVRG of [16].",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 24,
      "context" : "For instance, for binary classification problems, the sigmoid function —or more broadly, any natural smoothed variant of the 0-1 loss function— is not only a more natural choice than artificial ones such as hinge loss, logistic loss, squared loss, but also generalize better in terms of testing accuracy especially when there are outliers [25].",
      "startOffset" : 339,
      "endOffset" : 343
    }, {
      "referenceID" : 24,
      "context" : "Shalev-Shwartz, Shamir and Sridharan [25] showed that this minimization problem is still solvable in the improper learning sense, with the help from kernel methods and gradient descent.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 3,
      "context" : "Instead of requiring each fi(·) to be L-smooth, one can assume it is L-upper smooth and l-lower smooth, a notation introduced by [4]; in such a case, faster results can also be obtained using our same proof techniques.",
      "startOffset" : 129,
      "endOffset" : 132
    }, {
      "referenceID" : 3,
      "context" : "This is faster than the previous running time on SVRG which is Õ(n+L2/σ2), however, it is not faster than using SVRG+Catalyst which gives Õ(n + n3/4 √ L/ √ σ), see discussion in [4].",
      "startOffset" : 178,
      "endOffset" : 181
    }, {
      "referenceID" : 7,
      "context" : "1) has received lots of attentions across machine learning and optimization communities; many first-order methods [8, 16, 23, 26] as well as their accelerations [1, 3, 18, 27, 28] have been proposed in the past a few years.",
      "startOffset" : 114,
      "endOffset" : 129
    }, {
      "referenceID" : 15,
      "context" : "1) has received lots of attentions across machine learning and optimization communities; many first-order methods [8, 16, 23, 26] as well as their accelerations [1, 3, 18, 27, 28] have been proposed in the past a few years.",
      "startOffset" : 114,
      "endOffset" : 129
    }, {
      "referenceID" : 22,
      "context" : "1) has received lots of attentions across machine learning and optimization communities; many first-order methods [8, 16, 23, 26] as well as their accelerations [1, 3, 18, 27, 28] have been proposed in the past a few years.",
      "startOffset" : 114,
      "endOffset" : 129
    }, {
      "referenceID" : 25,
      "context" : "1) has received lots of attentions across machine learning and optimization communities; many first-order methods [8, 16, 23, 26] as well as their accelerations [1, 3, 18, 27, 28] have been proposed in the past a few years.",
      "startOffset" : 114,
      "endOffset" : 129
    }, {
      "referenceID" : 0,
      "context" : "1) has received lots of attentions across machine learning and optimization communities; many first-order methods [8, 16, 23, 26] as well as their accelerations [1, 3, 18, 27, 28] have been proposed in the past a few years.",
      "startOffset" : 161,
      "endOffset" : 179
    }, {
      "referenceID" : 2,
      "context" : "1) has received lots of attentions across machine learning and optimization communities; many first-order methods [8, 16, 23, 26] as well as their accelerations [1, 3, 18, 27, 28] have been proposed in the past a few years.",
      "startOffset" : 161,
      "endOffset" : 179
    }, {
      "referenceID" : 17,
      "context" : "1) has received lots of attentions across machine learning and optimization communities; many first-order methods [8, 16, 23, 26] as well as their accelerations [1, 3, 18, 27, 28] have been proposed in the past a few years.",
      "startOffset" : 161,
      "endOffset" : 179
    }, {
      "referenceID" : 26,
      "context" : "1) has received lots of attentions across machine learning and optimization communities; many first-order methods [8, 16, 23, 26] as well as their accelerations [1, 3, 18, 27, 28] have been proposed in the past a few years.",
      "startOffset" : 161,
      "endOffset" : 179
    }, {
      "referenceID" : 27,
      "context" : "1) has received lots of attentions across machine learning and optimization communities; many first-order methods [8, 16, 23, 26] as well as their accelerations [1, 3, 18, 27, 28] have been proposed in the past a few years.",
      "startOffset" : 161,
      "endOffset" : 179
    }, {
      "referenceID" : 3,
      "context" : "1) can be solved easily [4, 11, 24].",
      "startOffset" : 24,
      "endOffset" : 35
    }, {
      "referenceID" : 10,
      "context" : "1) can be solved easily [4, 11, 24].",
      "startOffset" : 24,
      "endOffset" : 35
    }, {
      "referenceID" : 23,
      "context" : "1) can be solved easily [4, 11, 24].",
      "startOffset" : 24,
      "endOffset" : 35
    }, {
      "referenceID" : 16,
      "context" : "The results of Li and Lin [17] and Ghadimi and Lan [13] unify the theory of non-convex and convex optimization in the following sense.",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 12,
      "context" : "The results of Li and Lin [17] and Ghadimi and Lan [13] unify the theory of non-convex and convex optimization in the following sense.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 19,
      "context" : "They provide general first-order schemes such that, if the parameters are tuned properly, the schemes can converge (1) as fast as gradient descent in terms of finding an approximate stationary point; and (2) as fast as accelerated gradient descent [20] in terms of minimizing the objective if the function is convex.",
      "startOffset" : 248,
      "endOffset" : 252
    }, {
      "referenceID" : 20,
      "context" : "A few days after the first version of this paper appeared on arXiv, we became aware of another group of authors that have independently obtained essentially the same result [21, 22].",
      "startOffset" : 173,
      "endOffset" : 181
    }, {
      "referenceID" : 21,
      "context" : "A few days after the first version of this paper appeared on arXiv, we became aware of another group of authors that have independently obtained essentially the same result [21, 22].",
      "startOffset" : 173,
      "endOffset" : 181
    }, {
      "referenceID" : 6,
      "context" : "Mirror descent is a terminology mostly used in optimization literature, see for instance the textbook [7].",
      "startOffset" : 102,
      "endOffset" : 105
    }, {
      "referenceID" : 1,
      "context" : "In our SVRG method, the descent step xk+1 ← xk − η∇̃k can be interpreted as a mirror descent step in the Euclidean space (see for instance [2]), and therefore mirror-descent analysis applies.",
      "startOffset" : 139,
      "endOffset" : 142
    }, {
      "referenceID" : 1,
      "context" : "Our main theorem is motivated by the linear-coupling framework [2].",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 15,
      "context" : "The key idea behind all variance-reduction literatures (such as SVRG [16], SAGA [8], and SAG [23]) is to prove that the variance E[(σs k)] decreases as s or k increases.",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 7,
      "context" : "The key idea behind all variance-reduction literatures (such as SVRG [16], SAGA [8], and SAG [23]) is to prove that the variance E[(σs k)] decreases as s or k increases.",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 22,
      "context" : "The key idea behind all variance-reduction literatures (such as SVRG [16], SAGA [8], and SAG [23]) is to prove that the variance E[(σs k)] decreases as s or k increases.",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 3,
      "context" : "Perhaps the only exception is the work on sum-of-non-convex but strongly-convex objectives [4, 24], where the authors upper bound E[(σs k)] by O ( ‖xk − x∗‖2 ) , the squared vector distance to the minimum.",
      "startOffset" : 91,
      "endOffset" : 98
    }, {
      "referenceID" : 23,
      "context" : "Perhaps the only exception is the work on sum-of-non-convex but strongly-convex objectives [4, 24], where the authors upper bound E[(σs k)] by O ( ‖xk − x∗‖2 ) , the squared vector distance to the minimum.",
      "startOffset" : 91,
      "endOffset" : 98
    }, {
      "referenceID" : 0,
      "context" : "Now we can telescope This new technique has also been applied to convex settings recently [1].",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 9,
      "context" : "1 Empirical Risk Minimization with Non-Convex Loss We consider binary classification on four standard datasets that can be found on the LibSVM website [10]: • the adult (a9a) dataset (32, 561 training samples, 16, 281 testing samples, and 123 features).",
      "startOffset" : 151,
      "endOffset" : 155
    }, {
      "referenceID" : 15,
      "context" : "For each of the two datasets, we consider both training the unregularized version, as well as the `2 regularized version with weight 10 −3 for CIFAR-10 and 10−4 for MNIST, two parameters suggested by [16].",
      "startOffset" : 200,
      "endOffset" : 204
    }, {
      "referenceID" : 8,
      "context" : "We implement two classical algorithms: stochastic gradient descent (SGD) with the best tuned polynomial learning rate and adaptive subGradient method (AdaGrad) of [9, 19] which is essentially SGD but with an adaptive learning rate.",
      "startOffset" : 163,
      "endOffset" : 170
    }, {
      "referenceID" : 18,
      "context" : "We implement two classical algorithms: stochastic gradient descent (SGD) with the best tuned polynomial learning rate and adaptive subGradient method (AdaGrad) of [9, 19] which is essentially SGD but with an adaptive learning rate.",
      "startOffset" : 163,
      "endOffset" : 170
    } ],
    "year" : 2016,
    "abstractText" : "We consider the fundamental problem in non-convex optimization of efficiently reaching a stationary point. In contrast to the convex case, in the long history of this basic problem, the only known theoretical results on first-order non-convex optimization remain to be full gradient descent that converges in O(1/ε) iterations for smooth objectives, and stochastic gradient descent that converges in O(1/ε) iterations for objectives that are sum of smooth functions. We provide the first improvement in this line of research. Our result is based on the variance reduction trick recently introduced to convex optimization, as well as a brand new analysis of variance reduction that is suitable for non-convex optimization. For objectives that are sum of smooth functions, our first-order minibatch stochastic method converges with an O(1/ε) rate, and is faster than full gradient descent by Ω(n). We demonstrate the effectiveness of our methods on empirical risk minimizations with nonconvex loss functions and training neural nets.",
    "creator" : "LaTeX with hyperref package"
  }
}