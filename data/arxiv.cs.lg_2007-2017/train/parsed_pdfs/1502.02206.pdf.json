{
  "name" : "1502.02206.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Learning to Search Better than Your Teacher",
    "authors" : [ "Kai-Wei Chang", "Akshay Krishnamurthy", "Alekh Agarwal" ],
    "emails" : [ "KCHANG10@ILLINOIS.EDU", "AKSHAYKR@CS.CMU.EDU", "ALEKHA@MICROSOFT.COM", "HAL@UMIACS.UMD.EDU", "JCL@MICROSOFT.COM" ],
    "sections" : [ {
      "heading" : null,
      "text" : "We provide a new learning to search algorithm, LOLS, which does well relative to the reference policy, but additionally guarantees low regret compared to deviations from the learned policy: a local-optimality guarantee. Consequently, LOLS can improve upon the reference policy, unlike previous algorithms. This enables us to develop structured contextual bandits, a partial information structured prediction setting with many potential applications."
    }, {
      "heading" : "1. Introduction",
      "text" : "In structured prediction problems, a learner makes joint predictions over a set of interdependent output variables and observes a joint loss. For example, in a parsing task, the output is a parse tree over a sentence. Achieving optimal performance commonly requires the prediction of each output variable to depend on neighboring variables. One approach to structured prediction is learning to search (L2S) (Collins & Roark, 2004; Daumé III & Marcu, 2005; Daumé III et al., 2009; Ross et al., 2011; Doppa et al., 2014; Ross & Bagnell, 2014), which solves the problem by:\n1. converting structured prediction into a search problem with specified search space and actions; 2. defining structured features over each state to capture the interdependency between output variables; 3. constructing a reference policy based on training data; 4. learning a policy that imitates the reference policy.\nEmpirically, L2S approaches have been shown to be competitive with other structured prediction approaches both in accuracy and running time (see e.g. Daumé III et al. (2014)). Theoretically, existing L2S algorithms guarantee that if the\nar X\niv :1\n50 2.\n02 20\n6v 2\nlearning step performs well, then the learned policy is almost as good as the reference policy, implicitly assuming that the reference policy attains good performance. Good reference policies are typically derived using labels in the training data, such as assigning each word to its correct POS tag. However, when the reference policy is suboptimal, which can arise for reasons such as computational constraints, nothing can be said for existing approaches.\nThis problem is most obviously manifest in a “structured contextual bandit”1 setting. For example, one might want to predict how the landing page of a high profile website should be displayed; this involves many interdependent predictions: items to show, position and size of those items, font, color, layout, etc. It may be plausible to derive a quality signal for the displayed page based on user feedback, and we may have access to a reasonable reference policy (namely the existing rulebased system that renders the current web page). But, applying L2S techniques results in nonsense—learning something almost as good as the existing policy is useless as we can just keep using the current system and obtain that guarantee. Unlike the full feedback settings, label information is not even available during learning to define a substantially better reference. The goal of learning here is to improve upon the current system, which is most likely far from optimal. This naturally leads to the question: is learning to search useless when the reference policy is poor?\nThis is the core question of the paper, which we address first with a new L2S algorithm, LOLS (Locally Optimal Learning to Search) in Section 2. LOLS operates in an online fashion and achieves a bound on a convex combination of regretto-reference and regret-to-own-one-step-deviations. The first part ensures that good reference policies can be leveraged effectively; the second part ensures that even if the reference policy is very sub-optimal, the learned policy is approximately “locally optimal” in a sense made formal in Section 3.\nLOLS operates according to a general schematic that encompases many past L2S algorithms (see Section 2), including Searn (Daumé III et al., 2009), DAgger (Ross et al., 2011) and AggreVaTe (Ross & Bagnell, 2014). A secondary contribution of this paper is a theoretical analysis of both good and bad ways of instantiating this schematic under a variety of conditions, including: whether the reference policy is optimal or not, and whether the reference policy is in the hypothesis class or not. We find that, while past algorithms achieve good regret guarantees when the reference policy is optimal, they can fail rather dramatically when it is not. LOLS, on the other hand, has superior performance to other L2S algorithms when the reference policy performs poorly but local hill-climbing in policy space is effective. In Section 5, we empirically confirm that LOLS can significantly outperform the reference policy in practice on real-world datasets.\nIn Section 4 we extend LOLS to address the structured contextual bandit setting, giving a natural modification to the algorithm as well as the corresponding regret analysis.\nThe algorithm LOLS, the new kind of regret guarantee it satisfies, the modifications for the structured contextual bandit setting, and all experiments are new here."
    }, {
      "heading" : "2. Learning to Search",
      "text" : "A structured prediction problem consists of an input space X , an output space Y , a fixed but unknown distribution D over X ×Y , and a non-negative loss function `(y∗, ŷ)→ R≥0 which measures the distance between the true (y∗) and predicted (ŷ) outputs. The goal of structured learning is to useN samples (xi,yi) N i=1 to learn a mapping f : X → Y that minimizes the expected structured loss under D.\nIn the learning to search framework, an input x ∈ X induces a search space, consisting of an initial state b (which we will 1The key difference from (1) contextual bandits is that the action space is exponentially large (in the length of trajectories in the search space); and from (2) reinforcement learning is that a baseline reference policy exists before learning starts.\ntake to also encode x), a set of end states and a transition function that takes state/action pairs s, a and deterministically transitions to a new state s′. For each end state e, there is a corresponding structured output ye and for convenience we define the loss `(e) = `(y∗,ye) where y\n∗ will be clear from context. We futher define a feature generating function Φ that maps states to feature vectors in Rd. The features express both the input x and previous predictions (actions). Fig. 1 shows an example search space2.\nAn agent follows a policy π ∈ Π, which chooses an action a ∈ A(s) at each non-terminal state s. An action specifies the next state from s. We consider policies that only access state s through its feature vector Φ(s), meaning that π(s) is a mapping from Rd to the set of actions A(s). A trajectory is a complete sequence of state/action pairs from the starting state b to an end state e. Trajectories can be generated by repeatedly executing a policy π in the search space. Without loss of generality, we assume the lengths of trajectories are fixed and equal to T . The expected loss of a policy J(π) is the expected loss of the end state of the trajectory e ∼ π, where e ∈ E is an end state reached by following the policy3. Throughout, expectations are taken with respect to draws of (x,y) from the training distribution, as well as any internal randomness in the learning algorithm.\nAn optimal policy chooses the action leading to the minimal expected loss at each state. For losses decomposable over the states in a trajectory, generating an optimal policy is trivial given y∗ (e.g., the sequence tagging example in (Daumé III et al., 2009)). In general, finding the optimal action at states not in the optimal trajectory can be tricky (e.g., (Goldberg & Nivre, 2013; Goldberg et al., 2014)).\nFinally, like most other L2S algorithms, LOLS assumes access to a cost-sensitive classification algorithm. A cost-sensitive classifier predicts a label ŷ given an example x, and receives a loss cx(ŷ), where cx is a vector containing the cost for each possible label. In order to perform online updates, we assume access to a no-regret online cost-sensitive learner, which we formally define below.\nDefinition 1. Given a hypothesis classH : X → [K], the regret of an online cost-sensitive classification algorithm which 2Doppa et al. (2014) discuss several approaches for defining a search space. The theoretical properties of our approach do not depend on which search space definition is used. 3Some imitation learning literature (e.g., (Ross et al., 2011; He et al., 2012)) defines the loss of a policy as an accumulation of the costs of states and actions in the trajectory generated by the policy. For simplicity, we define the loss only based on the end state. However, our theorems can be generalized.\nAlgorithm 1 Locally Optimal Learning to Search (LOLS) Require: Dataset {xi,yi}Ni=1 drawn from D and β ≥ 0: a mixture parameter for roll-out.\n1: Initialize a policy π0. 2: for all i ∈ {1, 2, . . . , N} (loop over each instance) do 3: Generate a reference policy πref based on yi. 4: Initialize Γ = ∅. 5: for all t ∈ {0, 1, 2, . . . , T − 1} do 6: Roll-in by executing πini = π̂i for t rounds and reach st. 7: for all a ∈ A(st) do 8: Let πouti =π\nref with probability β, otherwise π̂i. 9: Evaluate cost ci,t(a) by rolling-out with πouti for T − t− 1 steps.\n10: end for 11: Generate a feature vector Φ(xi, st). 12: Set Γ = Γ ∪ {〈ci,t,Φ(xi, st)〉}. 13: end for 14: π̂i+1 ← Train(π̂i,Γ) (Update). 15: end for 16: Return the average policy across π̂0, π̂1, . . . π̂N .\nproduces hypotheses h1, . . . , hM on cost-sensitive example sequence {(x1, c1), . . . , (xM , cM )} is\nRegretCSM = M∑ m=1 cm(hm(xm))−min h∈H M∑ m=1 cm(h(xm)). (1)\nAn algorithm is no-regret if RegretCSM = o(M).\nSuch no-regret guarantees can be obtained, for instance, by applying the SECOC technique (Langford & Beygelzimer, 2005) on top of any importance weighted binary classification algorithm that operates in an online fashion, examples being the perceptron algorithm or online ridge regression.\nLOLS (see Algorithm 1) learns a policy π̂ ∈ Π to approximately minimize J(π),4 assuming access to a reference policy πref (which may or may not be optimal). The algorithm proceeds in an online fashion generating a sequence of learned policies π̂0, π̂1, π̂2, . . .. At round i, a structured sample (xi,yi) is observed, and the configuration of a search space is generated along with the reference policy πref. Based on (xi,yi), LOLS constructs T cost-sensitive multiclass examples using a roll-in policy πini and a roll-out policy π out i . The roll-in policy is used to generate an initial trajectory and the roll-out policy is used to derive the expected loss. More specifically, for each decision point t ∈ [0, T ), LOLS executes πini for t rounds reaching a state st ∼ πini . Then, a cost-sensitive multiclass example is generated using the features Φ(st). Classes in the multiclass example correspond to available actions in state st. The cost c(a) assigned to action a is the difference in loss between taking action a and the best action.\nc(a) = `(e(a))−min a′\n`(e(a′)), (2)\nwhere e(a) is the end state reached with rollout by πouti after taking action a in state st. LOLS collects the T examples from the different roll-out points and feeds the set of examples Γ into an online cost-sensitive multiclass learner, thereby updating the learned policy from π̂i to π̂i+1. By default, we use the learned policy π̂i for roll-in and a mixture policy for roll-out. For each roll-out, the mixture policy either executes πref to an end-state with probability β or π̂i with probability 1 − β. LOLS converts into a batch algorithm with a standard online-to-batch conversion where the final model π̄ is generated by averaging π̂i across all rounds (i.e., picking one of π̂1, . . . π̂N uniformly at random).\n4 We can parameterize the policy π̂ using a weight vector w ∈ Rd such that a cost-sensitive classifier can be used to choose an action based on the features at each state. We do not consider using different weight vectors at different states."
    }, {
      "heading" : "3. Theoretical Analysis",
      "text" : "In this section, we analyze LOLS and answer the questions raised in Section 1. Throughout this section we use π̄ to denote the average policy obtained by first choosing n ∈ [1, N ] uniformly at random and then acting according to πn.We begin with discussing the choices of roll-in and roll-out policies. Table 1 summarizes the results of using different strategies for roll-in and roll-out.\n3.1. The Bad Choices\nAn obvious bad choice is roll-in and roll-out with the learned policy, because the learner is blind to the reference policy. It reduces the structured learning problem to a reinforcement learning problem, which is much harder. To build intuition, we show two other bad cases.\nRoll-in with πref is bad. Roll-in with a reference policy causes the state distribution to be unrealistically good. As a result, the learned policy never learns to correct for previous mistakes, performing poorly when testing. A related discussion can be found at Theorem 2.1 in (Ross & Bagnell, 2010). We show a theorem below.\nTheorem 1. For πini = πref, there is a distribution D over (x,y) such that the induced cost-sensitive regret Regret CS M = o(M) but J(π̄)− J(πref) = Ω(1).\nProof. We demonstrate examples where the claim is true.\nWe start with the case where πouti = π in i = π ref. In this case, suppose we have one structured example, whose search space is defined as in Figure 3(a). From state s1, there are two possible actions: a and b (we will use actions and features interchangeably since features uniquely identify actions here); the (optimal) reference policy takes action a. From state s2, there are again two actions (c and d); the reference takes c. Finally, even though the reference policy would never visit s3, from that state it chooses action f . When rolling in with πref, the cost-sensitive examples are generated only at state s1 (if we take a one-step deviation on s1) and s2 but never at s3 (since that would require a two deviations, one at s1 and one\nat s3). As a result, we can never learn how to make predictions at state s3. Furthermore, under a rollout with πref, both actions from state s1 lead to a loss of zero. The learner can therefore learn to take action c at state s2 and b at state s1, and achieve zero cost-sensitive regret, thereby “thinking” it is doing a good job. Unfortunately, when this policy is actually run, it performs as badly as possible (by taking action e half the time in s3), which results in the large structured regret.\nNext we consider the case where πouti is either the learned policy or a mixture with π ref. When applied to the example in Figure 3(b), our feature representation is not expressive enough to differentiate between the two actions at state s1, so the learned policy can do no better than pick randomly between the top and bottom branches from this state. The algorithm either rolls in with πref on s1 and generates a cost-sensitive example at s2, or generates a cost-sensitive example on s1 and then completes a roll out with πouti . Crucially, the algorithm still never generates a cost-sensitive example at the state s3 (since it would have already taken a one-step deviation to reach s3 and is constrained to do a roll out from s3). As a result, if the learned policy were to choose the action e in s3, it leads to a zero cost-sensitive regret but large structured regret.\nDespite these negative results, rolling in with the learned policy is robust to both the above failure modes. In Figure 3(a), if the learned policy picks action b in state s1, then we can roll in to the state s3, then generate a cost-sensitive example and learn that f is a better action than e. Similarly, we also observe a cost-sensitive example in s3 in the example of Figure 3(b), which clearly demonstrates the benefits of rolling in with the learned policy as opposed to πref.\nRoll-out with πref is bad if πref is not optimal. When the reference policy is not optimal or the reference policy is not in the hypothesis class, roll-out with πref can make the learner blind to compounding errors. The following theorem holds. We state this in terms of “local optimality”: a policy is locally optimal if changing any one decision it makes never improves its performance.\nTheorem 2. For πouti = πref, there is a distribution D over (x,y) such that the induced cost-sensitive regret Regret CS M = o(M) but π̄ has arbitrarily large structured regret to one-step deviations.\nProof. Suppose we have only one structured example, whose search space is defined as in Figure 3(c) and the reference policy chooses a or c depending on the node. If we roll-out with πref, we observe expected losses 1 and 1 + for actions a and b at state s1, respectively. Therefore, the policy with zero cost-sensitive classification regret chooses actions a and d depending on the node. However, a one step deviation (a → b) does radically better and can be learned by instead rolling out with a mixture policy.\nThe above theorems show the bad cases and motivate a good L2S algorithm which generates a learned policy that competes with the reference policy and deviations from the learned policy. In the following section, we show that Algorithm 1 is such an algorithm."
    }, {
      "heading" : "3.2. Regret Guarantees",
      "text" : "Let Qπ(st, a) represent the expected loss of executing action a at state st and then executing policy π until reaching an end state. T is the number of decisions required before reaching an end state. For notational simplicity, we use Qπ(st, π′) as a shorthand forQπ(st, π′(st)), where π′(st) is the action that π′ takes at state st. Finally, we use dtπ to denote the distribution over states at time t when acting according to the policy π. The expected loss of a policy is:\nJ(π) = Es∼dtπ [Q π(s, π)] , (3)\nfor any t ∈ [0, T ]. In words, this is the expected cost of rolling in with π up to some time t, taking π’s action at time t and then completing the roll out with π.\nOur main regret guarantee for Algorithm 1 shows that LOLS minimizes a combination of regret to the reference policy πref and regret its own one-step deviations. In order to concisely present the result, we present an additional definition which captures the regret of our approach:\nδN = 1\nNT N∑ i=1 T∑ t=1 Es∼dtπ̂i [ Qπ out i (s, π̂i)− ( βmin a Qπ ref (s, a) + (1− β) min a Qπ̂i(s, a) )] , (4)\nwhere πouti = βπ ref + (1 − β)π̂i is the mixture policy used to roll-out in Algorithm 1. With these definitions in place, we can now state our main result for Algorithm 1.\nTheorem 3. Let δN be as defined in Equation 4. The averaged policy π̄ generated by running N steps of Algorithm 1 with a mixing parameter β satisfies\nβ(J(π̄)− J(πref)) + (1− β) T∑ t=1 ( J(π̄)−min π∈Π Es∼dtπ̄ [Q π̄(s, π)] )\n≤ TδN .\nIt might appear that the LHS of the theorem combines one term which is constant to another scaling with T . We point the reader to Lemma 1 in the appendix to see why the terms are comparable in magnitude. Note that the theorem does not assume anything about the quality of the reference policy, and it might be arbitrarily suboptimal. Assuming that Algorithm 1 uses a no-regret cost-sensitive classification algorithm (recall Definition 1), the first term in the definition of δN converges to\n`∗ = min π∈Π\n1\nNT N∑ i=1 T∑ t=1 Es∼dtπ̂i [Q πouti (s, π)].\nThis observation is formalized in the next corollary.\nCorollary 1. Suppose we use a no-regret cost-sensitive classifier in Algorithm 1. As N →∞, δN → δclass, where\nδclass = ` ∗ − 1\nNT ∑ i,t Es∼dtπ̂i [ βmin a Qπ ref (s, a) + (1− β) min a Qπ̂i(s, a) ] .\nWhen we have β = 1, so that LOLS becomes almost identical to AGGREVATE (Ross & Bagnell, 2014), δclass arises solely due to the policy class Π being restricted. For other values of β ∈ (0, 1), the asymptotic gap does not always vanish even if the policy class is unrestricted, since `∗ amounts to obtaining minaQπ out i (s, a) in each state. This corresponds to taking a minimum of an average rather than the average of the corresponding minimum values.\nIn order to avoid this asymptotic gap, it seems desirable to have regrets to reference policy and one-step deviations controlled individually, which is equivalent to having the guarantee of Theorem 3 for all values of β in [0, 1] rather than a specific one. As we show in the next section, guaranteeing a regret bound to one-step deviations when the reference policy is arbitrarily bad is rather tricky and can take an exponentially long time. Understanding structures where this can be done more tractably is an important question for future research. Nevertheless, the result of Theorem 3 has interesting consequences in several settings, some of which we discuss next.\n1. The second term on the left in the theorem is always non-negative by definition, so the conclusion of Theorem 3 is at least as powerful as existing regret guarantee to reference policy when β = 1. Since the previous works in this area (Daumé III et al., 2009; Ross et al., 2011; Ross & Bagnell, 2014) have only studied regret guarantees to the reference policy, the quantity we’re studying is strictly more difficult.\n2. The asymptotic regret incurred by using a mixture policy for roll-out might be larger than that using the reference policy alone, when the reference policy is near-optimal. How the combination of these factors manifests in practice is empirically evaluated in Section 5.\n3. When the reference policy is optimal, the first term is non-negative. Consequently, the theorem demonstrates that our algorithm competes with one-step deviations in this case. This is true irrespective of whether πref is in the policy class Π or not.\n4. When the reference policy is very suboptimal, then the first term can be negative. In this case, the regret to one-step deviations can be large despite the guarantee of Theorem 3, since the first negative term allows the second term to be large while the sum stays bounded. However, when the first term is significantly negative, then the learned policy has already improved upon the reference policy substantially! This ability to improve upon a poor reference policy by using a mixture policy for rolling out is an important distinction for Algorithm 1 compared with previous approaches.\nOverall, Theorem 3 shows that the learned policy is either competitive with the reference policy and nearly locally optimal, or improves substantially upon the reference policy."
    }, {
      "heading" : "3.3. Hardness of local optimality",
      "text" : "In this section we demonstrate that the process of reaching a local optimum (under one-step deviations) can be exponentially slow when the initial starting policy is arbitrary. This reflects the hardness of learning to search problems when equipped with a poor reference policy, even if local rather than global optimality is considered a yardstick. We establish this lower bound for a class of algorithms substantially more powerful than LOLS. We start by defining a search space and a policy class. Our search space consists of trajectories of length T , with 2 actions available at each step of the trajectory. We use 0 and 1 to index the two actions. We consider policies whose only feature in a state is the depth of the state in the trajectory, meaning that the action taken by any policy π in a state st depends only on t. Consequently, each policy can be indexed by a bit string of length T . For instance, the policy 0100 . . . 0 executes action 0 in the first step of any trajectory, action 1 in the second step and 0 at all other levels. It is easily seen that two policies are one-step deviations of each other if the corresponding bit strings have a Hamming distance of 1.\nTo establish a lower bound, consider the following powerful algorithmic pattern. Given a current policy π, the algorithm examines the cost J(π′) for all the one-step deviations π′ of π. It then chooses the policy with the smallest cost as its new learned policy. Note that access to the actual costs J(π) makes this algorithm more powerful than existing L2S algorithms, which can only estimate costs of policies through rollouts on individual examples. Suppose this algorithm starts from an initial policy π̂0. How long does it take for the algorithm to reach a policy π̂i which is locally optimal compared with all its one-step deviations? We next present a lower bound for algorithms of this style. Theorem 4. Consider any algorithm which updates policies only by moving from the current policy to a one-step deviation. Then there is a search space, a policy class and a cost function where the any such algorithm must make Ω(2T ) updates before reaching a locally optimal policy. Specifically, the lower bound also applies to Algorithm 1.\nThe result shows that competing with the seemingly reasonable benchmark of one-step deviations may be very challenging from an algorithmic perspective, at least without assumptions on the search space, policy class, loss function, or starting policy. For instance, the construction used to prove Theorem 4 does not apply to Hamming loss."
    }, {
      "heading" : "4. Structured Contextual Bandit",
      "text" : "We now show that a variant of LOLS can be run in a “structured contextual bandit” setting, where only the loss of a single structured label can be observed. As mentioned, this setting has applications to webpage layout, personalized search, and several other domains.\nAt each round, the learner is given an input example x, makes a prediction ŷ and suffers structured loss `(y∗, ŷ). We assume that the structured losses lie in the interval [0, 1], that the search space has depth T and that there are at most K actions available at each state. As before, the algorithm has access to a policy class Π, and also to a reference policy πref. It is important to emphasize that the reference policy does not have access to the true label, and the goal is improving on the reference policy.\nOur approach is based on the -greedy algorithm which is a common strategy in partial feedback problems. Upon receiving an example xi, the algorithm randomly chooses whether to explore or exploit on this example. With probability 1− , the algorithm chooses to exploit and follows the recommendation of the current learned policy. With the remaining probability, the algorithm performs a randomized variant of the LOLS update. A detailed description is given in Algorithm 2.\nWe assess the algorithm’s performance via a measure of regret, where the comparator is a mixture of the reference policy and the best one-step deviation. Let π̄i be the averaged policy based on all policies in I at round i. yie is the predicted label in either step 9 or step 14 of Algorithm 2. The average regret is defined as:\nRegret = 1\nN N∑ i=1 ( E[`(y∗i ,yie)]− βE[`(y∗i ,yieref)]− (1− β) T∑ t=1 min π∈Π Es∼dtπ̄i [Q π̄i(s, π)] ) Recalling our earlier definition of δi (4), we bound on the regret of Algorithm 2 with a proof in the appendix. Theorem 5. Algorithm 2 with parameter satisfies:\nRegret ≤ + 1 N N∑ i=1 δni ,\nAlgorithm 2 Structured Contextual Bandit Learning Require: Examples {xi}Ni=1, reference policy πref, exploration probability and mixture parameter β ≥ 0.\n1: Initialize a policy π0, and set I = ∅. 2: for all i = 1, 2, . . . , N (loop over each instance) do 3: Obtain the example xi, set explore = 1 with probability , set ni = |I|. 4: if explore then 5: Pick random time t ∈ {0, 1, . . . , T − 1}. 6: Roll-in by executing πini = π̂ni for t rounds and reach st. 7: Pick random action at ∈ A(st); let K = |A(st)|. 8: Let πouti = π\nref with probability β, otherwise π̂ni . 9: Roll-out with πouti for T − t− 1 steps to evaluate\nĉ(a) = K`(e(at))1[a = at].\n10: Generate a feature vector Φ(xi, st). 11: π̂ni+1 ← Train(π̂ni , ĉ,Φ(xi, st)). 12: Augment I = I ∪ {π̂ni+1} 13: else 14: Follow the trajectory of a policy π drawn randomly from I to an end state e, predict the corresponding structured output yie. 15: end if 16: end for\nWith a no-regret learning algorithm, we expect δi ≤ δclass + cK √\nlog |Π| i , (5)\nwhere |Π| is the cardinality of the policy class. This leads to the following corollary with a proof in the appendix. Corollary 2. In the setup of Theorem 5, suppose further that the underlying no-regret learner satisfies (5). Then with probability at least 1− 2/(N5K2T 2 log(N |Π|))3,\nRegret = O ( (KT )2/3 3 √ log(N |Π|)\nN + Tδclass\n) ."
    }, {
      "heading" : "5. Experiments",
      "text" : "This section shows that LOLS is able to improve upon a suboptimal reference policy and provides empirical evidence to support the analysis in Section 3. We conducted experiments on the following three applications.\nCost-Sensitive Multiclass classification. For each cost-sensitive multiclass sample, each choice of label has an associated cost. The search space for this task is a binary search tree. The root of the tree corresponds to the whole set of labels. We recursively split the set of labels in half, until each subset contains only one label. A trajectory through the search space is a path from root-to-leaf in this tree. The loss of the end state is defined by the cost. An optimal reference policy can lead the agent to the end state with the minimal cost. We also show results of using a bad reference policy which arbitrarily chooses an action at each state. The experiments are conducted on KDDCup 99 dataset5 generated from a computer network intrusion detection task. The dataset contains 5 classes, 4, 898, 431 training and 311, 029 test instances.\nPart of speech tagging. The search space for POS tagging is left-to-right prediction. Under Hamming loss the trivial optimal reference policy simply chooses the correct part of speech for each word. We train on 38k sentences and test on 11k from the Penn Treebank (Marcus et al., 1993). One can construct suboptimal or even bad reference policies, but under Hamming loss these are all equivalent to the optimal policy because roll-outs by any fixed policy will incur exactly the same loss and the learner can immediately learn from one-step deviations.\n5http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html\nDependency parsing. A dependency parser learns to generate a tree structure describing the syntactic dependencies between words in a sentence (McDonald et al., 2005; Nivre, 2003). We implemented a hybrid transition system (Kuhlmann et al., 2011) which parses a sentence from left to right with three actions: SHIFT, REDUCELEFT and REDUCERIGHT. We used the “non-deterministic oracle” (Goldberg & Nivre, 2013) as the optimal reference policy, which leads the agent to the best end state reachable from each state. We also designed two suboptimal reference policies. A bad reference policy chooses an arbitrary legal action at each state. A suboptimal policy applies a greedy selection and chooses the action which leads to a good tree when it is obvious; otherwise, it arbitrarily chooses a legal action. (This suboptimal reference was the default reference policy used prior to the work on “non-deterministic oracles.”) We used data from the Penn Treebank Wall Street Journal corpus: the standard data split for training (sections 02-21) and test (section 23). The loss is evaluated in UAS (unlabeled attachment score), which measures the fraction of words that pick the correct parent.\nFor each task and each reference policy, we compare 6 different combinations of roll-in (learned or reference) and roll-out (learned, mixture or reference) strategies. We also include SEARN in the comparison, since it has notable differences from LOLS. SEARN rolls in and out with a mixture where a different policy is drawn for each state, while LOLS draws a policy once per example. SEARN uses a batch learner, while LOLS uses online. The policy in SEARN is a mixture over the policies produced at each iteration. For LOLS, it suffices to keep just the most recent one. It is an open research question whether an analogous theoretical guarantee of Theorem 3 can be established for SEARN.\nOur implementation is based on Vowpal Wabbit6, a machine learning system that supports online learning and L2S. For LOLS’s mixture policy, we set β = 0.5. We found that LOLS is not sensitive to β, and setting β to be 0.5 works well in practice. For SEARN, we set the mixture parameter to be 1 − (1 − α)t, where t is the number of rounds and α = 10−5. Unless stated otherwise all the learners take 5 passes over the data.\nTables 2, 3 and 4 show the results on cost-sensitive multiclass classification, POS tagging and dependency parsing, respectively. The empirical results qualitatively agree with the theory. Rolling in with reference is always bad. When the reference policy is optimal, then doing roll-outs with reference is a good idea. However, when the reference policy is suboptimal or bad, then rolling out with reference is a bad idea, and mixture rollouts perform substantially better. LOLS also significantly outperforms SEARN on all tasks.\n6http://hunch.net/˜vw/"
    }, {
      "heading" : "6. Proofs of Main Results",
      "text" : "Lemma 1 (Ross & Bagnell Lemma 4.3). For any two policies, π1, π2:\nJ(π1)− J(π2) = TEt∼U(1,T ),s∼dtπ1 [Q π2(s, π1)−Qπ2(s, π2)] = TEt∼U(1,T ),s∼dtπ2 [Q π1(s, π1)−Qπ1(s, π2)]\nProof. Let πt be a policy that executes π1 in the first t steps and then executes π2 from time steps t + 1 to T . We have J(π1) = J(π T ) and J(π2) = J(π0). Consequently, we can set up the telescoping sum:\nJ(π1)− J(π2) = T∑ t=1 [ J(πt)− J(πt−1) ] = T∑ t=1 [ Es∼dtπ1 [Q π2(st,π1)−Qπ2(st,π2)] ]\n= TEt∼U(1,T ),s∼π1 [Q π2(s, π1)−Qπ2(s, π2)]\nThe second equality in the lemma can be obtained by reversing the roles of π1 and π2 above."
    }, {
      "heading" : "6.1. Proof of Theorem 3",
      "text" : "We start with an application of Lemma 1. Using the lemma, we have:\nJ(π̄)− J(πref) = 1 N ∑ i [ J(π̂i)− J(πref) ] = 1\nN ∑ i [ TEt∼U(1,T ),s∼π̂i [ Qπ ref (s, π̂i)−Qπ ref (s, πref) ]] (6)\nWe also observe that\nT∑ t=1 ( J(π̄)−min π∈Π Es∼dtπ̄ [Q π̄(s, π)] )\n= 1\nN N∑ i=1 T∑ t=1 [ J(π̂i)−min π∈Π Es∼dtπ̂i [Q π̂i(s, π)] ]\n= 1\nN N∑ i=1 T∑ t=1 [ Es∼dtπ̂i [Q π̂i(s, π̂i)]−min π∈Π Es∼dtπ̂i [Q π̂i(s, π)] ]\n≤ 1 N N∑ i=1 T∑ t=1 [ Es∼dtπ̂i [Q π̂i(s, π̂i)−min a Qπ̂i(s, a)] ] . (7)\nCombining the above bounds from Equations 6 and 7, we see that\nβ ( J(π̄)− J(πref) ) + (1− β) T∑ t=1 ( J(π̄)−min π∈Π Es∼dtπ̄ [Q π̄(s, π)] )\n≤ 1 N N∑ i=1 T∑ t=1 Es∼dtπ̂i [ β ( Qπ ref (s, π̂i)−Qπ ref (s, πref) ) + (1− β) ( Qπ̂i(s, π̂i)−min a Qπ̂i(s, a) )] = 1\nN N∑ i=1 T∑ t=1 Es∼dtπ̂i [ Qπ out i (s, π̂i)− βQπ ref (s, πref)− (1− β) min a Qπ̂i(s, a) ] ≤ 1 N N∑ i=1 T∑ t=1 Es∼dtπ̂i [ Qπ out i (s, π̂i)− βmin a Qπ ref (s, a)− (1− β) min a Qπ̂i(s, a) ]"
    }, {
      "heading" : "6.2. Proof of Corollary 1",
      "text" : "The proof is fairly straightforward from definitions. By definition of no-regret, it is immediate that the gap\nN∑ i=1 T∑ t=1 E [ci,t(π̂i(st))− ci,t(π(st))] = o(NT ), (8)\nfor all policies π ∈ Π, where we recall that ci,t is the cost-vector over the actions on round i when we do roll-outs from the tth decision point. Let Ei denote the conditional expectation on round i, conditioned on the previous rounds in Algorithm 1. Then it is easily seen that\nEi[ci,t(a)] = Ei [ `(ei,t(a))−min\na′ `(ei,t(a\n′ )) ] ,\nwith ei,t being the end-state reached on completing the roll-out with the policy πouti on round i, when action a was taken on the decision point t. Recalling that we rolled in following the trajectory of πini , this expectation further simplifies to\nEi[ci,t(a)] = Es∼dtπ̂i\n[ Qπ out i (s, a) ] − Ei [ min a′ `(ei,t(a ′ )) ] .\nNow taking expectations in Equation 8 and combining with the above observation, we obtain that for any policy π ∈ Π,\nN∑ i=1 T∑ t=1 E [ci,t(π̂i(st))− ci,t(π(st))]\n= N∑ i=1 T∑ t=1 Es∼dtπ̂i [ Qπ out i (s, π̂i(s))−Qπ out i (s, π(s)) ] = o(NT ).\nTaking the best policy π ∈ Π and dividing through by NT completes the proof."
    }, {
      "heading" : "6.3. Proof sketch of Theorem 5",
      "text" : "(Sketch only) We decompose the analysis over exploration and exploitation rounds. For the exploration rounds, we bound the regret by its maximum possible value of 1. To control the regret on the exploitation rounds, we focus on the updates performed during exploration.\nThe cost vector ĉ(a) used at an exploration round i satisfies\nEi[ĉ(a)] = Ei [K`(e(at))1[a = at]]\n= Et∼U(0:T−1),s∼dtπ̂ni\n[ Qπ out i (s, a) ] ,\nCorollary 1. Since the cost vector is identical in expectation as that used in Algorithm 1, the proof of theorem 3, which only depends on expectations, can be reused to prove a result similar to theorem 3 for the exploration rounds. That is, letting π̄i to be the averaged policy over all the policies in I at exploration round i, we have the bound\nβ(J(π̄i)− J(πref)) + (1− β) T∑ t=1 ( J(π̄)−min π∈Π Es∼dtπ̄ [Q π̄(s, π)] )\n≤ Tδi,\nwhere δi is as defined in Equation 4.\nOn the exploitation rounds, we can now invoke this guarantee. Recalling that we have ni exploration rounds until round i, the expected regret at an exploitation round i is at most δni . Thus the overall regret of the algorithm is at most\nRegret ≤ + 1 N N∑ i=1 δni ,\nwhich completes the proof."
    }, {
      "heading" : "6.4. Proof of corollary 2",
      "text" : "We start by substituting Equation 5 in the regret bound of Theorem 5. This yields\nRegret ≤ + T N δclass + cKT N N∑ i=1 √ log |Π| ni .\nWe would like to further replace ni with its expectation which is i. However, this does not yield a valid upper bound directly. Instead, we apply a Chernoff bound to the quantity ni, which is a sum of i i.i.d. Bernoulli random variables with mean . Consequently, we have\nP (ni ≤ (1− γ) i) ≤ exp ( −γ 2 i\n2\n) ≤ exp(− i/8),\nfor γ = 1/2. Let i0 = 16 logN/ + 1. Then we can sum the failure probabilities above for all i ≥ i0 and obtain\nN∑ i=i0 P (ni ≤ i/2) ≤ N∑ i=i0 exp(− i/8) ≤ ∞∑ i=i0 exp(− i/8)\n≤ exp(− i0/8) 1− exp(− /8)\n= exp(−2 logN) exp( /8)− 1 ≤ 8 N2 ,\nwhere the last inequality uses 1 + x ≤ exp(x). Consequently, we can now allow a regret of 1 on the first i0 rounds, and control the regret on the remaining rounds using ni ≤ i/2. Doing so, we see that with probability at least 1− 2/(N2 )\nRegret ≤ + i0 N + T N δclass + cKT N N∑ i=1\n√ 2 log |Π|\ni\n≤ + 16 logN + N + T N δclass + 8cKT log |Π| N\nChoosing = (KT )2/3(log(N |Π|)/N)1/3 completes the proof."
    }, {
      "heading" : "6.5. Proof of Theorem 4",
      "text" : "The proof follows from results in combinatorics. The dynamics of algorithms considered here can be thought of as a path through a graph where the vertices are the corners of the boolean hypercube in T dimensions with two vertices at Hamming\ndistance 1 sharing an edge. We demonstrate that there is a cost function such that the algorithm is forced to traverse a long path before reaching a local optimum. Without loss of generality, assume that the algorithm always moves to a one-step deviation with the lowest cost since otherwise longer paths exist.\nTo gain some intuition, first consider T = 3 which is depicted in Figure 4. Suppose the algorithm starts from the policy 000 then moves to the policy 001. If the algorithm picks the best amongst the one-step deviations, we know that J(001) ≤ min{J(000), J(010), J(100)}, placing constraints on the costs of these policies which force the algorithm to not visit any of these policies later. Similarly, if the algorithm moves to the policy 011 next, we obtain a further constraint J(011) < min{J(101), J(001)}. It is easy to check that the only feasible move (corresponding to policies not crossed in Figure 4(c)) which decreases the cost under these constraints is to the policy 111 and then 110, at which point the algorithm attains local optimality since no more moves that decrease the cost are possible. In general, at any step i of the path, the policy π̂i is a one-step deviation of π̂i−1 and at least 2 or more steps away from π̂j for j < i − 1. The policy never moves to a neighbor of an ancestor (excluding the immediate parent) in the path.\nThis property is the key element to understand more generally. Suppose we have a current path π̂1 → π̂2 . . .→ π̂i−1 → π̂i. Since we picked the best neighbor of π̂j as π̂j+1, π̂i+1 cannot be a neighbor of any π̂j for j < i. Consequently, the maximum number of updates the algorithm must make is given by the length of the longest such path on a hypercube, where each vertex (other than start and end) neighbors exactly two other vertices on the path. This is called the snake-inthe-box problem in combinatorics, and arises in the study of error correcting codes. It is shown by Abbott & Katchalski (1988) that the length of longest such path is Θ(2T ). With monotonically decreasing costs for policies in the path and maximal cost for all policies not in the path, the traversal time is Θ(2T ).\nFinally, it might appear that Algorithm 1 is capable of moving to policies which are not just one-step deviations of the currently learned policy, since it performs updates on “mini-batches” of T cost-sensitive examples. However, on this lower bound instance, Algorithm 1 will be forced to follow one-step deviations only due to the structure of the cost function. For instance, from the policy 000 when we assign maximal cost to policies 010 and 100 in our example, this corresponds to making the cost of taking action 1 on first and second step very large in the induced cost-sensitive problem. Consequently, 001 is the policy which minimizes the cost-sensitive loss even when all the T roll-outs are accumulated, implying the algorithm is forced to traverse the same long path to local optimality."
    }, {
      "heading" : "Acknowledgements",
      "text" : "Part of this work was carried out while Kai-Wei, Akshay and Hal were visiting Microsoft Research."
    }, {
      "heading" : "A. Details of cost-sensitive reduction",
      "text" : "In this section we present the details of the reduction to cost-sensitive multiclass classification used in our experimental evaluation. The experiments used the Cost-Sensitive One Against All (CSOAA) classification technique, the pseudocode for which is presented in Algorithm 3. In words, the algorithm takes as input a feature vector xt,i for class i at round t. It then trains a regressor to predict the corresponding costs ct,i given the features. Given a fresh example, the predicted label is the one with the smallest predicted cost. This is a natural extension of the One Against All (OAA) approach for multiclass classification to cost-sensitive settings. Note that this also covers the alternative approach of having a common feature vector, xt,i ≡ zt for all i and instead training K different cost predictors, one for each class. If zt ∈ Rd, one can simply create xt,i ∈ RdK , with xt,i = zt in the ith block and zero elsewhere. Learning a common predictor f on x is now representationally equivalent to learning K separate predictors, one for each class.\nThere is one missing detail in the specification of Algorithm 3, which is the update step. The specifics of this step depend on the form of the function f(x) being used. For instance, if f(x) = wTx, then a simple update rule is to use online ridge regression (see e.g. Section 11.7 in (Cesa-Bianchi & Lugosi, 2006)). Online gradient descent (Zinkevich, 2003) on the squared loss ∑K i=1(f(xt,i) − ct,i)2 is another simple alternative, which can be used more generally. The specific implementation in our experiments uses a more sophisticated variant of online gradient descent with linear functions."
    }, {
      "heading" : "B. Details of Experiments",
      "text" : "Our implementation is based on Vowpal Wabbit (VW) version 7.8 (http://hunch.net/˜vw/). It is available at https://github.com/KaiWeiChang/vowpal_wabbit/tree/icmlexp. For LOLS, we use flags “– search rollin”, “–search rollout”, “–search beta” to set the rollin policy, the rollout policy, and β, respectively. We use “–search interpolation policy –search passes per policy –passes 5” to enable SEARN. The details settings of various VW flags for the three experiments are shown below:\n• POS tagging: we use “–search task sequence –search 45 –holdout off –affix -2w,+2w –search neighbor features - 1:w,1:w -b 28”\n• Dependency parsing: we use “ –search task dep parser –search 12 –holdout off –search history length 3 – search no caching -b 24 –root label 8 –num label 12”\n• Cost-sensitive multiclass: we use “–search task multiclasstask –search 5 –holdout off –mc cost”\nThe data sets used in the experiments are available upon request."
    } ],
    "references" : [ {
      "title" : "On the snake in the box problem",
      "author" : [ "Abbott", "H.L", "M. Katchalski" ],
      "venue" : "Journal of Combinatorial Theory, Series B,",
      "citeRegEx" : "Abbott et al\\.,? \\Q1988\\E",
      "shortCiteRegEx" : "Abbott et al\\.",
      "year" : 1988
    }, {
      "title" : "Learning as search optimization: Approximate large margin methods for structured prediction",
      "author" : [ "Daumé III", "Hal", "Marcu", "Daniel" ],
      "venue" : "In Proceedings of the International Conference on Machine Learning (ICML),",
      "citeRegEx" : "III et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "III et al\\.",
      "year" : 2005
    }, {
      "title" : "Search-based structured prediction",
      "author" : [ "Daumé III", "Hal", "Langford", "John", "Marcu", "Daniel" ],
      "venue" : "Machine Learning Journal,",
      "citeRegEx" : "III et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "III et al\\.",
      "year" : 2009
    }, {
      "title" : "Efficient programmable learning to search",
      "author" : [ "Daumé III", "Hal", "Langford", "John", "Ross", "Stéphane" ],
      "venue" : null,
      "citeRegEx" : "III et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "III et al\\.",
      "year" : 2014
    }, {
      "title" : "HC-Search: A learning framework for search-based structured prediction",
      "author" : [ "Doppa", "Janardhan Rao", "Fern", "Alan", "Tadepalli", "Prasad" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR),",
      "citeRegEx" : "Doppa et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Doppa et al\\.",
      "year" : 2014
    }, {
      "title" : "Training deterministic parsers with non-deterministic oracles",
      "author" : [ "Goldberg", "Yoav", "Nivre", "Joakim" ],
      "venue" : "Transactions of the ACL,",
      "citeRegEx" : "Goldberg et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Goldberg et al\\.",
      "year" : 2013
    }, {
      "title" : "A tabular method for dynamic oracles in transition-based parsing",
      "author" : [ "Goldberg", "Yoav", "Sartorio", "Francesco", "Satta", "Giorgio" ],
      "venue" : "Transactions of the ACL,",
      "citeRegEx" : "Goldberg et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Goldberg et al\\.",
      "year" : 2014
    }, {
      "title" : "Imitation learning by coaching",
      "author" : [ "He", "Daumé III", "Hal", "Eisner", "Jason" ],
      "venue" : "In Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "He et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "He et al\\.",
      "year" : 2012
    }, {
      "title" : "Dynamic programming algorithms for transition-based dependency parsers",
      "author" : [ "Kuhlmann", "Marco", "Gómez-Rodrı́guez", "Carlos", "Satta", "Giorgio" ],
      "venue" : "In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies-Volume",
      "citeRegEx" : "Kuhlmann et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Kuhlmann et al\\.",
      "year" : 2011
    }, {
      "title" : "Sensitive error correcting output codes",
      "author" : [ "Langford", "John", "Beygelzimer", "Alina" ],
      "venue" : "In Learning Theory, pp",
      "citeRegEx" : "Langford et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Langford et al\\.",
      "year" : 2005
    }, {
      "title" : "Building a large annotated corpus of English: The Penn Treebank",
      "author" : [ "Marcus", "Mitch", "Marcinkiewicz", "Mary Ann", "Santorini", "Beatrice" ],
      "venue" : "Computational Linguistics,",
      "citeRegEx" : "Marcus et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Marcus et al\\.",
      "year" : 1993
    }, {
      "title" : "Non-projective dependency parsing using spanning tree algorithms",
      "author" : [ "McDonald", "Ryan", "Pereira", "Fernando", "Ribarov", "Kiril", "Hajic", "Jan" ],
      "venue" : "In Proceedings of the Joint Conference on Human Language Technology Conference and Empirical Methods in Natural Language Processing (HLT/EMNLP),",
      "citeRegEx" : "McDonald et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "McDonald et al\\.",
      "year" : 2005
    }, {
      "title" : "An efficient algorithm for projective dependency parsing",
      "author" : [ "Nivre", "Joakim" ],
      "venue" : "In International Workshop on Parsing Technologies (IWPT), pp",
      "citeRegEx" : "Nivre and Joakim.,? \\Q2003\\E",
      "shortCiteRegEx" : "Nivre and Joakim.",
      "year" : 2003
    }, {
      "title" : "Efficient reductions for imitation learning",
      "author" : [ "Ross", "Stéphane", "Bagnell", "J. Andrew" ],
      "venue" : "In Proceedings of the Workshop on Artificial Intelligence and Statistics (AI-Stats),",
      "citeRegEx" : "Ross et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Ross et al\\.",
      "year" : 2010
    }, {
      "title" : "Reinforcement and imitation learning via interactive no-regret learning",
      "author" : [ "Ross", "Stéphane", "Bagnell", "J. Andrew" ],
      "venue" : null,
      "citeRegEx" : "Ross et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Ross et al\\.",
      "year" : 2014
    }, {
      "title" : "A reduction of imitation learning and structured prediction to no-regret online learning",
      "author" : [ "Ross", "Stéphane", "Gordon", "Geoff J", "Bagnell", "J. Andrew" ],
      "venue" : "In Proceedings of the Workshop on Artificial Intelligence and Statistics (AI-Stats),",
      "citeRegEx" : "Ross et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Ross et al\\.",
      "year" : 2011
    }, {
      "title" : "Online convex programming and generalized infinitesimal gradient ascent",
      "author" : [ "Zinkevich", "Martin" ],
      "venue" : "In Proceedings of the International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Zinkevich and Martin.,? \\Q2003\\E",
      "shortCiteRegEx" : "Zinkevich and Martin.",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 15,
      "context" : "One approach to structured prediction is learning to search (L2S) (Collins & Roark, 2004; Daumé III & Marcu, 2005; Daumé III et al., 2009; Ross et al., 2011; Doppa et al., 2014; Ross & Bagnell, 2014), which solves the problem by: 1.",
      "startOffset" : 66,
      "endOffset" : 199
    }, {
      "referenceID" : 4,
      "context" : "One approach to structured prediction is learning to search (L2S) (Collins & Roark, 2004; Daumé III & Marcu, 2005; Daumé III et al., 2009; Ross et al., 2011; Doppa et al., 2014; Ross & Bagnell, 2014), which solves the problem by: 1.",
      "startOffset" : 66,
      "endOffset" : 199
    }, {
      "referenceID" : 1,
      "context" : "One approach to structured prediction is learning to search (L2S) (Collins & Roark, 2004; Daumé III & Marcu, 2005; Daumé III et al., 2009; Ross et al., 2011; Doppa et al., 2014; Ross & Bagnell, 2014), which solves the problem by: 1. converting structured prediction into a search problem with specified search space and actions; 2. defining structured features over each state to capture the interdependency between output variables; 3. constructing a reference policy based on training data; 4. learning a policy that imitates the reference policy. Empirically, L2S approaches have been shown to be competitive with other structured prediction approaches both in accuracy and running time (see e.g. Daumé III et al. (2014)).",
      "startOffset" : 121,
      "endOffset" : 724
    }, {
      "referenceID" : 15,
      "context" : ", 2009), DAgger (Ross et al., 2011) and AggreVaTe (Ross & Bagnell, 2014).",
      "startOffset" : 16,
      "endOffset" : 35
    }, {
      "referenceID" : 6,
      "context" : ", (Goldberg & Nivre, 2013; Goldberg et al., 2014)).",
      "startOffset" : 2,
      "endOffset" : 49
    }, {
      "referenceID" : 15,
      "context" : ", (Ross et al., 2011; He et al., 2012)) defines the loss of a policy as an accumulation of the costs of states and actions in the trajectory generated by the policy.",
      "startOffset" : 2,
      "endOffset" : 38
    }, {
      "referenceID" : 7,
      "context" : ", (Ross et al., 2011; He et al., 2012)) defines the loss of a policy as an accumulation of the costs of states and actions in the trajectory generated by the policy.",
      "startOffset" : 2,
      "endOffset" : 38
    }, {
      "referenceID" : 1,
      "context" : ", the sequence tagging example in (Daumé III et al., 2009)). In general, finding the optimal action at states not in the optimal trajectory can be tricky (e.g., (Goldberg & Nivre, 2013; Goldberg et al., 2014)). Finally, like most other L2S algorithms, LOLS assumes access to a cost-sensitive classification algorithm. A cost-sensitive classifier predicts a label ŷ given an example x, and receives a loss cx(ŷ), where cx is a vector containing the cost for each possible label. In order to perform online updates, we assume access to a no-regret online cost-sensitive learner, which we formally define below. Definition 1. Given a hypothesis classH : X → [K], the regret of an online cost-sensitive classification algorithm which Doppa et al. (2014) discuss several approaches for defining a search space.",
      "startOffset" : 41,
      "endOffset" : 750
    }, {
      "referenceID" : 15,
      "context" : "Since the previous works in this area (Daumé III et al., 2009; Ross et al., 2011; Ross & Bagnell, 2014) have only studied regret guarantees to the reference policy, the quantity we’re studying is strictly more difficult.",
      "startOffset" : 38,
      "endOffset" : 103
    }, {
      "referenceID" : 10,
      "context" : "We train on 38k sentences and test on 11k from the Penn Treebank (Marcus et al., 1993).",
      "startOffset" : 65,
      "endOffset" : 86
    }, {
      "referenceID" : 11,
      "context" : "A dependency parser learns to generate a tree structure describing the syntactic dependencies between words in a sentence (McDonald et al., 2005; Nivre, 2003).",
      "startOffset" : 122,
      "endOffset" : 158
    }, {
      "referenceID" : 8,
      "context" : "We implemented a hybrid transition system (Kuhlmann et al., 2011) which parses a sentence from left to right with three actions: SHIFT, REDUCELEFT and REDUCERIGHT.",
      "startOffset" : 42,
      "endOffset" : 65
    } ],
    "year" : 2015,
    "abstractText" : "Methods for learning to search for structured prediction typically imitate a reference policy, with existing theoretical guarantees demonstrating low regret compared to that reference. This is unsatisfactory in many applications where the reference policy is suboptimal and the goal of learning is to improve upon it. Can learning to search work even when the reference is poor? We provide a new learning to search algorithm, LOLS, which does well relative to the reference policy, but additionally guarantees low regret compared to deviations from the learned policy: a local-optimality guarantee. Consequently, LOLS can improve upon the reference policy, unlike previous algorithms. This enables us to develop structured contextual bandits, a partial information structured prediction setting with many potential applications.",
    "creator" : "LaTeX with hyperref package"
  }
}