{
  "name" : "1205.1782.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Approximate Dynamic Programming By Minimizing Distributionally Robust Bounds",
    "authors" : [ "Marek Petrik" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Large Markov decision processes (MDPs) are common in reinforcement learning and operations research and are often solved by approximate dynamic programming (ADP). Many ADP algorithms have been developed and studied, often with impressive empirical performance. However, because many ADP methods must be carefully tuned to work well and offer insufficient theoretical guarantees, it is important to develop new methods that have both good theoretical guarantees and empirical performance.\nApproximate linear programming (ALP)—an ADP method—has been developed with the goal of achieving convergence and good theoretical guarantees (de Farias & van Roy, 2003). Approximate bilinear programming (ABP) improves on the theoretical properties of ALP at the cost of additional computational complexity (Petrik & Zilberstein, 2009, 2011). Both ALP and ABP provide guarantees that rely on conservative error bounds in terms of the L∞ norm and often under-perform in practice (Petrik & Zilberstein, 2009). It is, therefore, desirable to develop ADP methods that offer both tighter bounds and better empirical performance.\nIn this paper, we propose and analyze distributionally robust approximate dynamic programming (DRADP)—a new approximate dynamic programming method. DRADP improves on approximate linear and bilinear programming both in terms of theoretical properties and empirical performance. This method builds on approximate linear and bilinear programming but achieves better solution quality by explicitly optimizing tighter, less conservative, bounds stated in terms of a weighted L1 norm. In particular, DRADP computes a good solution for a given initial distribution instead of attempting to find a solution that is good for all initial distributions.\nThe objective in ADP is to compute a policy π with the maximal return ρ(π). Maximizing the return also minimizes the loss with respect to the optimal policy π?—known as the policy loss and defined as ρ(π?)− ρ(π). There are two main challenges in computing a good policy for a large MDP. First, it is\nar X\niv :1\n20 5.\n17 82\nv2 [\nst at\n.M L\n] 2\n1 M\nay 2\n01 2\nnecessary to efficiently evaluate its return; evaluation using simulation is time consuming and often impractical. Second, the return of a parameterized policy may be a function that is hard to optimize. DRADP addressed both these issues by maximizing a simple lower bound ρ̃(π) on the return using ideas from robust optimization. This lower bound is easy to optimize and can be computed from a small sample of the domain, eliminating the need for extensive simulation.\nMaximizing a lower bound on the return corresponds to minimizing an upper bound ρ(π?)− ρ̃(π) on the policy loss. The main reason to minimize an upper bound—as opposed to a lower bound—is that the approximation error can be bounded by the difference ρ(π?)− ρ̃(π?) for the optimal policy only, instead of the difference for the set of all policies, as we show formally in Section 4.\nThe lower bound on the return in DRADP is based on an approximation of the state occupancy distributions or frequencies (Puterman, 2005). The state occupancy frequency represents the fraction of time that is spent in the state and is in some sense the dual of a value function. Occupancy frequencies have been used, for example, to solve factored MDPs (Dolgov & Durfee, 2006) and in dual dynamic programming (Wang, 2007; Wang et al., 2008) (The term “dual dynamic programming” also refers to unrelated linear stochastic programming methods). These methods can improve the empirical performance, but proving bounds on the policy loss has proved challenging. We take a different approach to prove tight bounds on the policy loss. While the existing methods approximate the state occupancy frequencies by a subset, we approximate it by a superset.\nWe call the DRADP approach distributionally robust because it uses the robust optimization methodology to represent and simplify the set of occupancy distributions (Delage & Ye, 2010). Robust optimization is a recently revived approach for modeling uncertainty in optimization problems (Ben-Tal et al., 2009). It does not attempt to model the uncertainty precisely, but instead computes solutions that are immunized against its effects. In distributionally robust optimization, the uncertainty is in probability distributions. DRADP introduces the uncertainty in state occupancy frequencies in order to make very large MDPs tractable and uses the robust optimization approach to compute solutions that are immune to this uncertainty.\nThe remainder of the paper is organized as follows. First, in Section 2, we define the basic framework including MDPs and value functions. Then, Section 3 introduces the general DRADP method in terms of generic optimization problems. Section 4 analyzes approximation errors involved in DRADP and shows that standard concentration coefficient assumptions on the MDP (Munos, 2007) can be used to derive tighter bounds. To leverage existing mathematical programming methods, we show that DRADP can be formulated in terms of standard mathematical optimization models in Section 5. Finally, Section 6 presents experimental results on standard benchmark problems.\nWe consider the offline—or batch—setting in this paper, in which all samples are generated in advance of computing the value function. This setting is identical to that of LSPI (Lagoudakis & Parr, 2003) and ALP (de Farias & van Roy, 2003)."
    }, {
      "heading" : "2 Framework and Notation",
      "text" : "In this section, we define the basic concepts required for solving Markov decision processes: value functions, and occupancy frequencies. We use the following general notation throughout the paper. The symbols 0 and 1 denote vectors of all zeros or ones of appropriate dimensions respectively; the symbol I denotes an identity matrix of an appropriate dimension. The operator [·]+ denotes an element-wise non-negative part of a vector. We will often use linear algebra and expectation notations interchangeably; for example: Eu [X ] = uTx , where x is a vector of the values of the random variable X . We also\nuse RX to denote the set of all functions from a finite set X to R; note that RX is trivially a vector space.\nA Markov Decision Process is a tuple (S ,A , P, r,α). Here, S is a finite set of states,A is a finite set of actions, P : S ×A ×S 7→ [0, 1] is the transition function (P(s, a, s′) is the probability of transiting to state s′ from state s given action a), and r : S ×A 7→ R is a reward function. The initial distribution is: α : S 7→ [0,1], such that ∑\ns∈S α(s) = 1. The set of all state-action pairs isW = S ×A . For the sake of simplicity, we assume that all actions can be taken in all states. To avoid technicalities that detract from the main ideas of the paper, we assume finite state and action sets but the results apply with additional compactness assumptions to infinite sets. We will use S and W to denote random variables with values in S and W .\nThe solution of an MDP is a stationary deterministic policy π : S →A , which determines the action to take in any state; the set of all deterministic policies is denoted by ΠD. A stationary randomized—or stochastic—policy π : S ×A → [0,1] assigns the probability to all actions for every state; the set of all randomized policies is denoted by ΠR. Clearly ΠD ⊆ ΠR holds by mapping the chosen action to the appropriate distribution. A randomized policy can be thought of as a vector on W that assigns the appropriate probabilities to each state–action pair.\nFor any π ∈ ΠR, we can define the transition probability matrix and the reward vector as follows: Pπ(s, s′) = ∑ a∈A P(s, a, s ′) · π(s, a) and rπ(s) = ∑\na∈A r(s, a) · π(s, a). We use Pa and ra to represent values for a policy that always takes action a ∈A . We also define a matrix A and a vector b as follows:\nAT = I− γPTa1 I− γP T a2 · · · , bT = rTa1 r T a2 · · ·\nValues A and b are usually used in approximate linear programming (ALP) (Schweitzer & Seidmann, 1985) and linear program formulations of MDPs (Puterman, 2005). The main objective in solving an MDP is to compute a policy with the maximal return.\nDefinition 2.1. The return ρ : ΠR → R of π ∈ ΠR is defined as: ρ(π) = ∑∞ n=0α T(γ · Pπ)n rπ. The optimal policy solves π? ∈ arg maxπ∈ΠR ρ(π) and we use ρ ? = ρ(π?).\nDRADP relies on two main solution concepts: state occupancy frequencies and value functions. State occupancy frequencies—or measures—intuitively represent the probability of terminating in each state when the discount factor γ is interpreted as a probability of remaining in the system (Puterman, 2005). State-action occupancy frequencies are defined for state–action pairs and represent the joint probability of being in the state and taking the action.\nState occupancy frequency for π ∈ ΠR is denoted by dπ ∈ RS and is defined as:\ndπ = (1− γ) · ∞ ∑\nt=0\n(γ · PTπ ) tα= (1− γ) · I− γ · PTπ −1 α .\nState-action occupancy frequency is denoted by uπ ∈ RW (its set-valued equivalent is U(π)) and is a product of state–occupancy frequencies and action probabilities:\nuπ(s, a) = dπ(s) ·π(s, a) , U(π) = {uπ} .\nNote that U(π) is a set-valued function with the output set of cardinality 1. State and state-action occupancy frequencies represent valid probability measures over S and W respectively. We use d? = dπ? and u\n? = uπ? to denote the optimal measures. Finally, we use u|π ∈ RS+ for π ∈ ΠD to denote a restriction of u to π such that u|π(s) = u(s,π(s)).\nState-action occupancy frequencies are closely related to the set U of dual feasible solutions of the linear program formulation of an MDP, which is defined as (e.g. Section 6.9 of (Puterman, 2005)):\nU = ¦ u ∈ RW+ : A Tu= (1− γ) ·α © . (2.1)\nThe following well-known proposition characterizes the basic properties of the set U .\nProposition 2.2 (e.g. Theorem 6.9 in (Puterman, 2005)). The set of occupancy frequencies satisfies the following properties.\n(i) U = ⋃\nπ∈ΠR U(π) = conv(\n⋃\nπ∈ΠD U(π)).\n(ii) For each ū ∈ U , define π′(s, a) = ū(s, a)/ ∑ a′∈A ū(s, a ′). Then uπ′ = ū.\n(iii) 1Tu= 1 for each u ∈ U . (iv) ATu= (1− γ) ·α for each u ∈ U .\nPart (i), in particular, holds because deterministic policies represent the basic feasible solutions of the dual linear program for an MDP.\nA value function vπ ∈ RS of π ∈ ΠR maps states to the return obtained when starting in them and is defined by:\nvπ = ∞ ∑\nt=0\n(γ · Pπ)t rπ = I− γ · Pπ −1 rπ .\nThe set of all possible value functions is denoted by V . It is well known that a policy π? with the value function v? is optimal if and only if v? ≥ vπ for every π ∈ ΠR. The value function update Lπ for a policy π and the Bellman operator L are defined as: Lπv = γPπv+ rπ and Lv =maxπ∈ΠR Lπv.\nThe optimal value function v? satisfies Lv? = v?. The following proposition states the well-known connection between state–action occupancy frequencies and value functions.\nProposition 2.3 (e.g. Chapter 6 in (Puterman, 2005)). For each π ∈ ΠR: ρ(π) = Eα vπ(S) = Euπ [r(W )]/(1− γ) .\nThe value function, computed by a dynamic programming algorithm, is typically then used to derive the greedy policy. A greedy policy takes in every state an action that maximizes the expected conditional return.\nDefinition 2.4. A policy π ∈ ΠD is greedy with respect to a value function v when Lπv = Lv; in other words:\nπ(s) ∈ arg max a∈A\nr(s, a) + γ · ∑\ns′∈S\nP(s, a, s′) · v(s′) ,\nfor each s ∈ S with ties broken arbitrarily.\nMDP is a very general model. Often, specific properties of the MDP can be used to compute better solutions and to derive tighter bounds. One common assumption—used to derive L2 bounds for API—is a smoothness of transition probabilities (Munos, 2003), also known as the concentration coefficient (Munos, 2007); this property can be used to derive tighter DRADP bounds.\nAssumption 1 (Concentration coefficient). There exists a probability measure µ ∈ [0, 1]S and a constant C ∈ R+ such that for all s, s′ ∈ S and all π ∈ ΠD the transition probability is bounded as: P(s,π(s), s′)≤ C ·µ(s′)."
    }, {
      "heading" : "3 Distributionally Robust Approximate Dynamic Programming",
      "text" : "In this section, we formalize DRADP and describe it in terms of generic optimization problems. Practical DRADP implementations are sampled versions of the optimization problems described in this section. However, as it is common in ADP literature, we do not explicitly analyze the sampling method used with DRADP in this paper, because the sampling error can simply be added to the error bounds that we derive. The sampling is performed and errors bounded identically to approximate linear programming and approximate bilinear programming—state and action samples are used to select a subset of constraints and variables (de Farias & van Roy, 2003; Petrik et al., 2010; Petrik & Zilberstein, 2011).\nThe main objective of ADP is to compute a policy π ∈ ΠR that maximizes the return ρ(π). Because the MDPs of interest are very large, a common approach is to simplify them by restricting the set of policies that are considered to a smaller set Π̃ ⊆ ΠR. For example, policies may be constrained to take the same action in some states; or to be greedy with respect to an approximate value function. Since it is not possible to compute an optimal policy, the common objective is to minimize the policy loss. Policy loss captures the difference in the discounted return when following policy π instead of the optimal policy π?.\nDefinition 3.1. The expected policy loss of π ∈ ΠR is defined as:\nρ? −ρ(π) = bT(u? − uπ)\n1− γ = ‖v? − vπ‖1,α ,\nwhere ‖ · ‖1,α represents an α-weighted L1 norm.\nADP relies on approximate value functions Ṽ ⊆ V that are a subset of all value functions. In DRADP, approximate value functions are used simultaneously to both restrict the space of policies and to approximate their returns. We, in addition, define a set of approximate occupancy frequencies Ũ(π) ⊇ U(π) that are a superset of the true occupancy frequencies. We call any element in the appropriate approximate sets representable.\nWe consider linear function approximation, in which the values for states are represented as a linear combination of nonlinear basis functions (vectors). For each s ∈ S , we define a vector φ(s) of features with |φ| being the dimension of the vector. The rows of the basis matrix Φ correspond to φ(s), and the approximation space is generated by the columns of Φ. Approximate value functions and policy-dependent state occupancy measures for linear approximations are defined for some given feature matrices Φu and Φv as:\nṼ = n v ∈ V : v = Φv x , x ∈ R|φ| o , (3.1)\nŨ(π) = n u ∈ RA+ : ΦTu A Tu= (1− γ) ·ΦTu α, u(s, a)≤ π(s, a) o . (3.2)\nClearly, Ũ(π) ⊇ U(π) from the definition of uπ. We will assume the following important assumption without reference for the remainder of the paper.\nAssumption 2. One of the features in each of φu and φv is a constant; that is, 1= Φu xu and 1= Φv xv for some xu and xv .\nThe following lemma, which can be derived directly from the definition of Ũ and Proposition 2.2, shows the importance of Assumption 2.\nLemma 3.2. Suppose that Assumption 2 holds. Then for each π ∈ ΠR: u ∈ Ũ(π)⇒ 1Tu= 1 .\nApproximate policies Π̃ are most often represented indirectly—by assuming policies that are greedy to the approximate value functions. The set G of all such greedy policies is defined by: G = { π ∈ ΠD : Lπv = Lv, v ∈ Ṽ }. Although DRADP applies to other approximate policy sets we will particularly focus on the set Π̃ = G .\nWe are now ready to define the basic DRADP formulation which is analyzed in the remainder of the paper.\nDefinition 3.3. DRADP computes an approximate policy by solving the following optimization problem:\narg max π∈Π̃ ρ̃(π) = arg min π∈Π̃ ρ? − ρ̃(π) , (DRADP)\nwhere the function ρ̃ : ΠR→ R is defined by:\nρ̃(π) =max v∈Ṽ αTv− max u∈Ũ(π) uT(Av− b) 1− γ . (3.3)\nNote that the solution of (DRADP) is a policy; this policy is not necessarily greedy with respect to the optimal v in (3.3) unlike in most other ADP approaches. The expression (3.3) can be understood intuitively as follows. The first term, αTv, represents the expected return if v is the value function of π. The second term maxu∈Ũ(π)(u\nT(Av− b))/(1− γ) is a penalty function, which offsets any gains when v 6= vπ and is motivated by the primal-dual slack variables in the LP formulation of the MDP. Given this interpretation, DRADP simultaneously restricts the set of value functions and upper-approximates the penalty function.\nThe following theorem states an important property of Definition 3.3, which is used to derive approximation error bounds.\nTheorem 3.4. For each π ∈ ΠR, ρ̃ lower-bounds the true return: ρ̃(π)≤ ρ(π). In addition, when Φu and Φv are invertible and π ∈ ΠD then ρ(π) = ρ̃(π).\nProof of Theorem 3.4. The theorem follows by complementary slackness from the fact that Ũ(π) ⊇ U(π). We use that dTπ (I− γPπ) = (1− γ) ·α T for any π ∈ ΠR from the definition of dπ to derive:\nρ(π) = Eα vπ = αTvπ = rTπ dπ 1− γ +max v∈Ṽ αT − dTπ (I− γ · Pπ) 1− γ v\n= rTπ dπ 1− γ +max v∈Ṽ αTv− dTπ (I− γ · Pπ)v 1− γ\n=max v∈Ṽ\nαTv− dTπ (I− γ · Pπ)v − d T π rπ\n1− γ\n=max v∈Ṽ\nαTv− dTπ v− Lπv\n1− γ\n=max v∈Ṽ\nαTv− uTπ (Av− b)\n1− γ\n(3.2) ≥ max\nv∈Ṽ min u∈Ũ(π)\nαTv− uT (Av− b)\n1− γ\n= ρ̃(π) .\nNow, assume that Φu is the identity matrix. Then, using (i) of Proposition 2.2, Ũ(π) = {uπ} whenever π ∈ ΠD. Note that this does not hold for π ∈ ΠR \\ΠD.\nWe now show that the lower bound ρ̃ in (3.3) can be simplified in some cases by ignoring the value functions for any π ∈ ΠR; the formulation (3.3) will nevertheless be particularly useful in the theoretical analysis because it relates value functions and occupancy frequencies.\nρ̃′(π) = min u∈Ũ ′(π)\nuTb\n1− γ , (3.4)\nwhere Ũ ′(π) is defined equivalently to Ũ(π) with the exception that Φu = Φv = Φ for some Φ.\nProposition 3.5. When Φv = Φu, then ρ̃(π) = ρ̃′(π). When Φv 6= Φu, then define Ũ ′ and ρ̃′ using a new representation Φ′ = [Φv Φu]. Then: ρ̃(π) = ρ̃′(π).\nProof of Proposition 3.5. Recall that:\nŨ(π) = ¦ u ∈ RA+ : Φ T u A Tu= (1− γ) ·ΦTu α, u(s, a)≤ π(s, a) © .\nAssume that Φ = Φv = Φu. First, note that u ∈ Ũ(π) implies that ΦTu Au= (1−γ)Φ T u α and v ∈ Ṽ implies that v = Φv x for some x . Then:\nρ̃(π) =max v∈Ṽ min u∈Ũ(π)\nαTv − uT(Av− b)\n1− γ\n(3.1) = max\nx min\nu∈Ũ(π)\nαTΦx − uT(AΦx − b)\n1− γ\n(3.2) = max\nx min\nu∈Ũ(π)\nαTΦx − (1− γ)αTΦx\n1− γ +\nuTb\n1− γ\n=max x min u∈Ũ(π)\nuTb\n1− γ\n= min u∈Ũ(π)\nuTb\n1− γ .\nWhen Φv 6= Φu, define Φ = [Φv Φu]. Then:\nρ̃(π) (3.1) = max\nx min\nu∈Ũ(π)\nαTΦv x − uT(AΦv x − b)\n1− γ\n=max x αTΦv x − max u∈Ũ(π) uT(AΦv x − b) 1− γ\n(?) = max\nn\nαT (1− γ) ·Φuλ1 +Φv x −πTλ2 : A Φuλ1 + Φv x 1− γ − b ≤ λ2, λ2 ≥ 0 o\n=max n\nαT[Φu Φv] T y −πTλ2 : A[Φu Φv]T y − b ≤ (1− γ) ·λ2,λ2 ≥ 0\no\n(?) = min\nu∈Ũc(π)\nuTb\n1− γ ,\nwhere: Ũc(π) = u : [Φu Φv] TATu= (1− γ) · [Φu Φv]Tα, 0≤ u≤ π .\nAbove, (?) equalities are derived from LP duality. This shows that simply combining the features to [Φu Φv] leads to the same approximate return function as using them separately.\nFor the remainder of the paper assume that Φv = Φu since assuming that they are the same does not reduce the solution quality.\nA potential challenge with DRADP is in representing the set of approximate policies Π̃, because a policy must generalize to all states even when computed from a small sample. Note, that for a fixed value function v in (3.3) the policy that solves minπ∈Π̃ ρ̃(π) is not necessarily the greedy with respect to v. The following representation theorem, however, shows that when the set of representable policies Π̃ is sufficiently rich, then the computed policy will be greedy with respect to a representable value function.\nTheorem 3.6. Suppose that Π̃⊇ G . Then: (i) maxπ∈Π̃ ρ̃(π) =maxπ∈G ρ̃(π).\n(ii) ∃π̄ ∈ argmaxπ∈Π̃ ρ̃(π) such that π̄ ∈ G .\nProof of Theorem 3.6. Recall, that given Proposition 3.5, we can assume the simple representation of the return ρ′(π). For a fixed π ∈ ΠR the optimization in ρ′(π) over u represents the following linear program:\nmin u\nuTb/(1− γ)\ns.t. ΦTATu= (1− γ) ·ΦTα\n0≤ u≤ π .\nThe dual of this linear program is:\nmax λ1,λ2 αTΦλ1 −πTλ2 s.t. AΦλ1 ≤ b+ (1− γ) ·λ2\nλ2 ≥ 0 .\n(3.5)\nNow, suppose a fixed λ1 in (3.5) and let v = Φλ1. Then, π ≥ 0 implies there exists one optimal λ2 such that:\nλ2(s, a) =\n\nv(s)− γ · ∑\ns′∈S\nP(s, a, s′)v(s′)− r(s, a)\n\n\n+\n∀s ∈ S , a ∈A .\nThis means that (3.5) is equivalent to:\nmax λ1\nαTΦλ1 − πT AΦλ1 − b +\n1− γ\nNow, consider policies π1,π2 ∈ ΠR that are identical in all states except in s ∈ S . That is π1(s) = a1,π2(s) = a2 and assume that a1 is the greedy action. To simplify the notation, we are assuming that\na2 can represent a randomized action. Then:\nγ · ∑\ns′∈S\nP(s, a1, s ′) · v(s′)− r(s, a1)\nD 2.4 ≥ γ · ∑\ns′∈S\nP(s, a2, s ′) · v(s′)− r(s, a2) ,\nv(s)− γ · ∑\ns′∈S\nP(s, a1, s ′) · v(s′)− r(s, a1)≤ v(s)− γ ·\n∑\ns′∈S\nP(s, a2, s ′) · v(s′)− r(s, a2) ,\n\nv(s)− γ · ∑\ns′∈S\nP(s, a1, s ′) · v(s′)− r(s, a1)\n\n\n+\n≤\n\nv(s)− γ · ∑\ns′∈S\nP(s, a2, s ′) · v(s′)− r(s, a2)\n\n\n+\n,\nπT1 AΦλ1 − b + ≤ π T 2 AΦλ1 − b + ,\nρ̃′(π1)≥ ρ̃′(π2) .\nApplying this argument inductively to every state, one can construct a policy π ∈ G ∩ Π̃ with respect to the approximate value function. Because this argument applies to each state individually, it also applies to DRADP from an incomplete sample.\nNote that the assumption Π̃ ⊇ G simply implies that DRADP can select a policy that is greedy with respect to any approximate value function v ∈ Ṽ . This is an implicit assumption in many ADP algorithms, including ALP and LSPI. We state the assumption explicitly to indicate results that do not hold in case there are additional restrictions on the set of policies that is considered.\nTheorem 3.6 implies that it is only necessary to consider policies that are greedy with respect to representable value functions which is the most common approach in ADP. However, other approaches for representing policies may have better theoretical or empirical properties and should be also studied."
    }, {
      "heading" : "4 Approximation Error Bounds",
      "text" : "This section describes the a priori approximation properties of DRADP solutions; these bounds can be evaluated before a solution is computed. We focus on several types of bounds that not only show the performance of the method, but also make it easier to theoretically compare DRADP to existing ADP methods. These bounds show that DRADP has stronger theoretical guarantees than most other ADP methods. The first bound mirrors some simple bounds for approximate policy iteration (API) in terms of the L∞ norm (Munos, 2007):\nlim sup k→∞ ‖v? − vπk‖∞ ≤ 2 · γ (1− γ)2 limsup k→∞ εk , (4.1)\nwhere πk and εk are the policy and L∞ approximation error at iteration k.\nTheorem 4.1. Suppose that Π̃⊇ G and that π̄ ∈ argmaxπ∈Π̃ ρ̃(π) in (DRADP). The policy loss ρ?−ρ(π̄) is then bounded as:\n‖v? − vπ̄‖1,α ≤ 2\n1− γ min v∈Ṽ ‖v − Lv‖∞ . (4.2)\nProof of Theorem 4.1. Assume that π̄ is an optimal solution of (DRADP). First, the policy loss can be\nexpressed in terms of approximate values and occupancy frequencies:\nρ? −ρ(π̄) T 3.4 ≤ ρ? − ρ̃(π̄) =min\nπ∈Π̃ ( ρ? − ρ̃(π) )\nG⊆Π̃ ≤ min\nπ∈G ( ρ? − ρ̃(π) )\n=min v∈Ṽ min π∈G max u∈Ũ(π) uT(Av− b) 1− γ +αT(v? − v)\nP 2.2 =\n1\n1− γ min v∈Ṽ min π∈G max u∈Ũ(π)\nuT(Av− b) + (u?)TA(v? − v)\nP 2.3 =\n1\n1− γ min v∈Ṽ min π∈G max u∈Ũ(π)\nuT(Av− b) + (u?)T(b− Av)\n(3.2) ≤ 1\n1− γ min v∈Ṽ min π∈G max u1,u2∈Ũ(π) uT1 (Av− b) + u T 2 (b− Av)\nui≥0 ≤ 1\n1− γ min v∈Ṽ max u1,u2∈Ũ(π) uT1 [Av− b]+ + u T 2 [b− Av]+\n≤ 2\n1− γ min v∈Ṽ max u∈Ũ(π)\nuT|Av− b| .\nThen, the loss can be upper bounded by choosing the greedy policy:\nρ? −ρ(π̄)≤ 2\n1− γ min v∈Ṽ min π∈G max u∈Ũ(π)\nuT|Av− b|\n≤ 2\n1− γ min v∈Ṽ min π∈G max u∈Ũ(π) u|Tπ |v− Lπv|\n≤ 2\n1− γ min v∈Ṽ max u∈Ũ(π) u|Tπ |v − Lv| ,\nwhere π is a policy greedy with respect to v when not specified otherwise. Finally, the bound is established by relaxing the constraints on u:\nρ? −ρ(π̄) L 3.2 ≤ 2\n1− γ min v∈Ṽ max u\nn\nu|Tπ |v− Lv| : 1 Tu= 1,0≤ u≤ π\no\n≤ 2\n1− γ min v∈Ṽ max u\nn\nu|Tπ |v − Lv| : 1 Tu≤ 1, u≥ 0\no\n= 2\n1− γ min v∈Ṽ max u\nn u|Tπ |v − Lv| : ‖u‖1 ≤ 1 o\n(?) ≤ 2\n1− γ min v∈Ṽ ‖v− Lv‖∞ .\nThe inequality (?) follows by the Holder’s inequality.\nTheorem 4.1 highlights several advantages of the DRADP bound (4.2) over (4.1): 1) it bounds the expected loss ‖v? − vπ̄‖1,α instead of the worst-case loss ‖v? − vπ̄‖∞, 2) it is smaller by a factor of 1/(1−γ), 3) it holds in finite time instead of a limit, and 4) its right-hand side is with respect to the best approximation of the optimal value function instead of the worst case approximation over all iteration.\nIn comparison with approximate linear programming bounds, (4.2) bounds the true policy loss and not simply the approximation of v? (de Farias & van Roy, 2003). The limitation of (4.2), however, is that it relies on an L∞ norm which can be quite conservative. We address this issue in two ways. First, we prove a bound of a different type.\nTheorem 4.2. Suppose that Π̃ ⊇ G and that π̄ ∈ argmaxπ∈Π̃ ρ̃(π) in (DRADP). Then, the policy loss ρ? −ρ(π̄) is bounded as:\n‖v? − vπ̄‖1,α ≤ min v∈Ṽ ,v≤v? ‖v − v?‖1,α . (4.3)\nProof of Theorem 4.2. Assume that π̄ is an optimal solution of (DRADP). Then:\nρ? −ρ(π̄) T 3.4 ≤ ρ? − ρ̃(π̄)≤ min\nπ∈ΠR ( ρ? − ρ̃(π) ≤ ρ? − ρ̃(π?) .\nNow, using the dual representation of ρ̃(·) as in Theorem 3.6 (see also Theorem 5.1 below) we get:\nρ? −ρ(π̄)≤min ¦ ρ? −αTΦλ1 −λT2 π ? : (1− γ) ·λ2 ≥ AΦλ1 − b, λ2 ≥ 0 © .\nIt can be readily shown by subtracting 1 from Φλ1 that there exists an optimal λ1,λ2 such that λT2 π ? = 0 (see (ii) of Theorem 5.1). Then:\nρ? −ρ(π̄)≤min ¦ ρ? −αTΦλ1 : (1− γ) ·λ2 ≥ AΦλ1 − b, λ2 ≥ 0, λT2 π ? = 0 ©\n=min ¦ ρ? −αTΦλ1 : (I− γ · Pπ?)Φλ1 ≤ rπ? © =min ¦ ρ? −αTv : (I− γ · Pπ?)v ≤ rπ? , v ∈ Ṽ ©\nL A.2 = min ¦ ρ? −αTv : v ≤ I− γ · Pπ? −1 rπ? , v ∈ Ṽ ©\nP 2.3 = min ¦ αTv? −αTv : v ≤ v?, v ∈ Ṽ © .\nThe bound (4.3), unlike bounds in most ADP algorithms, does not contain a factor of 1/(1− γ) of any power. Although (4.3) does not involve an L∞ norm, it does require that v ≤ v? which may be undesirable. Next, we show bounds that rely purely on weighted norms under additional assumptions on the concentration coefficient.\nAs mentioned above, Assumption 1 can be used to improve the solutions of DRADP and to derive tighter bounds. Note that this assumption must be known in advance and cannot be gleaned from the samples. To this end, for some fixed C ∈ R+ and µ ∈ RS in Assumption 1, define:\nŨS(π) =\n(\nu ∈ Ũ(π) : ∑\na∈A u(s, a)≤ σ(s), ∀s ∈ S\n)\n,\nσ(s) = γ ·µ(s) + (1− γ) ·α(s),\nρ̃S(π) =max v∈Ṽ min u∈ŨS(π)\nαTv− uT(Av− b)\n1− γ\n.\nThese assumptions imply the following structure of all admissible state frequencies.\nLemma 4.3. Suppose that Assumption 1 holds with constants C and µ. Then: d ≤ C ·σ for each d ∈ ŨS(π) and π ∈ ΠR.\nProof of Lemma 4.3. Suppose any π ∈ ΠR and its occupancy frequency u. Then from the definition of u:\nd(s) = ∑\na∈A u(s, a) = γ ·\n∑\ns′∈S a′∈A\nP(s′, a′, s) · u(s′, a′) + (1− γ) ·α(s)\nu≥0 ≤ γ · ∑\ns′∈S a′∈A\nC ·µ(s) · u(s′, a′) + (1− γ) ·α(s)\n≤ γ · C ·µ(s)\n∑\ns′∈S ,a′∈A\nu(s′, a′) + (1− γ) ·α(s)\nP 2.2 ≤ γ · C ·µ(s) + (1− γ) ·α(s)≤ C ·σ(s) ,\nwhich implies that ŨS(π)⊇ U(π) for any π ∈ ΠR . Therefore ρ̃S(π)≤ ρ(π) from Theorem 3.4.\nThe following theorem shows a tighter bound on the DRADP policy loss for MDPs that satisfy the smoothness assumption.\nTheorem 4.4. Suppose that Assumption 1 holds with constants C and µ, Π̃⊇ G , and that π̄ ∈ arg maxπ∈Π̃ ρ̃(π) in (DRADP). Then, the loss of π̄ is bounded as:\nρ? −ρ(π̄)≤ 2 · C 1− γ min v∈Ṽ ‖v− Lv‖1,σ . (4.4)\nProof of Theorem 4.4. Using the same derivation as in the proof of Theorem 4.1, we have that:\nρ? −ρ(π̄)≤ 2\n1− γ min v∈Ṽ max u\nn u|Tπ |v− Lv| : u ∈ ŨS(π) o\nThen, the bound can be derived from the assumption as follows:\nρ? −ρ(π̄) L 4.3 ≤ 2\n1− γ min v∈Ṽ max u\nn\nu|Tπ |v− Lv| : 0≤ u, ∑\na∈A u(s, a)≤ C ·σ(s)\no\n≤ 2 · C 1− γ min v∈Ṽ max u n u|Tπ diag(σ)|v− Lv| : 0≤ u, ∑ a∈A u(s, a)≤ 1 o ≤ 2 · C 1− γ min v∈Ṽ max d n dT diag(σ)|v− Lv| : ‖d‖∞ ≤ 1 o\n(?) ≤ 2 · C 1− γ min v∈Ṽ ‖v − Lv‖1,σ.\nThe inequality (?) follows by Holder’s inequality.\nThe bound in Theorem 4.4 is similar to comparable Lp bounds for API (Munos, 2003), except it relies on a weighted L1 norm instead of the L2 norm and preserves all the advantages of Theorem 4.1.\nTheorem 4.4 exploits that the set of occupancy frequencies is restricted under the smoothness assumption which leads to a tighter lower bound ρ̃S on the return.\nFinally, DRADP is closely related to robust ABP (Petrik & Zilberstein, 2009, 2011) but provides several significant advantages. First, DRADP does not require transitive feasible (Petrik & Zilberstein, 2011) value functions, which simplifies the use of constraint generation. Second, ABP minimizes L∞ bounds ρr : ΠR → R on the policy loss, which can be too conservative. In fact, it is easy to show that DRADP solutions can be better than ABP solutions by an arbitrarily large factor."
    }, {
      "heading" : "5 Computational Models",
      "text" : "In this section, we describe how to solve the DRADP optimization problem. Since DRADP generalizes ABP (Petrik & Zilberstein, 2009), it is necessarily NP complete to solve in theory, but relatively easy to solve in practice. Note that the NP-completeness is in terms of the number of samples and features and not in the number of states or actions of the MDP. In addition, the NP completeness a is favorable property when compared to API algorithms, such as LSPI, which may never converge (Lagoudakis & Parr, 2003).\nTo solve DRADPs in practice, we derive bilinear and mixed integer linear program formulations for which many powerful solvers have been developed. These formulations lead to anytime solvers—even approximate solutions result in valid policies—and can therefore easily trade off solution quality with time complexity.\nTo derive bilinear formulations of DRADP, we represent the set of policies Π̃ using linear equalities as: Π̃ = ¦ π ∈ [0, 1]W : ∑\na∈A π(s, a) = 1 ©\n. This set can be defined using matrix notation as Bπ = 1 and π ≥ 0, where B : |S | × |W | is defined as: B(s′, (s′, a)) = 1 when s = s′ and 0 otherwise. Clearly Π̃⊇ G , which implies that the computed policy is greedy with respect to a representable value function from Theorem 3.6 even as sampled. It would be easy to restrict the set Π̃ by assuming the same action must be taken in a subset of states: one would add constraints π(s, a) = π(s′, a) for some s, s′ ∈ S and all a ∈A .\nWhen the set of approximate policies is represented by linear inequalities, the DRADP optimization problem can be formulated as the following separable bilinear program (Horst & Tuy, 1996).\nmax π,λ1,λ2 αTΦλ1 −πTλ2 s.t. Bπ= 1, π≥ 0, λ2 ≥ 0,\n(1− γ) ·λ2 ≥ AΦλ1 − b .\n(5.1)\nBilinear programs are a generalization of linear programs and are in general NP hard to solve.\nTheorem 5.1. Suppose that Π̃⊇ G . Then the sets of optimal solutions of (5.1) and (DRADP) are identical and there exists an optimal solution (π̄, λ̄1, λ̄2) of (5.1) such that:\n(i) π̄ is deterministic and greedy with respect to Φλ̄1, (ii) π̄Tλ̄2 = 0.\nProof of Theorem 5.1. The equivalence of the sets of optimal solutions follows directly from the dual representation from the proof of Theorem 3.6. We next prove the two properties separately:\n(i) Follows directly from (ii) of Theorem 3.6. (ii) To prove by contradiction that there is an optimal solution π with πTλ2 = 0, assume an optimal\nsolution π such that πTλ2 > 0. Since π ≥ 0, λ2 ≥ 0, there exists an index i (when treating π as\na simple vector), such that π(i) = 1 and λ2(i)> 0 (from the integrality of π). We then show that there exists a solution with a lower value πTλ2, smaller number of j such that λ2( j)> 0, without decreasing the objective value. From the optimality of λ2 and the positivity of λ2(i), we have that (the constraint in (5.1) is active):\n(1− γ) ·λ2(i) = aTi Φλ1 − bi > 0,\nwhere aTi is the i-th row of the matrix A and bi is the i-th element of the vector b. Now, from Assumption 2, there exists λ′1 such that:\nΦλ′1 = Φλ1 −λ2(i) · 1.\nThis λ1 is trivially feasible in (5.1). Let (1− γ) · λ′2 = AΦλ′1 − b + . Now using Lemma A.1 it is readily seen that: A1= (1− γ) · 1. Then:\nAΦλ′1 − b= AΦλ1 − b−λ2(i) · 1, AΦλ′1 − b≤ AΦλ1 − b,\nAΦλ′1 − b + ≤ AΦλ1 − b + ,\nλ′2 ≤ λ2.\nIn addition, λ′2(i) = 0, and thus: λ ′ 2 ≤ λ2 −λ2(i). Then:\nαTΦλ′1 −π Tλ′2 ≥ α TΦλ1 −λ2(i)−πTλ2 +λ2(i)≥ αTΦλ1 −πTλ2 .\nTherefore λ′1,λ ′ 2 are also optimal with one less nonzero index i such that π(i)> 0 and λ ′ 2(π)> 0. The claim then follows by choosing i with the maximal λ2(i).\nBecause there are few, if any, industrial solvers for bilinear programs, we reformulate (5.1) as a mixed integer linear program (MILP). Any separable bilinear program can be formulated as a MILP (Horst & Tuy, 1996), but such generic formulations are impractical because they lead to large MILPs with weak linear relaxations. Instead, we derive a more compact and structured MILP formulation that exploits the existence of optimal deterministic policies in DRADP (see (i) of Theorem 5.1) and is based on McCormic inequalities on the bilinear terms (Linderoth, 2005). To formulate the MILP, assume a given upper bound τ ∈ R on any optimal solution λ2? of (5.1) such that τ ≥ λ2?(s, a) for all s ∈ S and a ∈A . Then:\nmax z,π,λ1,λ2\nαTΦλ1 − 1Tz\ns.t. z ≥ λ2 −τ · (1−π),\n(1− γ) ·λ2 ≥ AΦλ1 − b, Bπ= 1, π ∈ {0,1}|S ||A |\nz ≥ 0, λ2 ≥ 0 .\n(5.2)\nTheorem 5.2. Suppose that Π̃⊇ G and (π̄, λ̄1, λ̄2, z̄) is an optimal solution of (5.2). Then, (π̄, λ̄1, λ̄2) is an optimal solution of (5.1) with the same objective value given that τ > ‖λ̄2‖∞.\nProof of Theorem 5.2. We use McCormic inequalities, as described in (Linderoth, 2005). In particular, assume that (x , y) ∈ {(x , y) : lx ≤ x ≤ ux , l y ≤ y ≤ uy}. Then the following holds:\nx · y ≥max{l y · x + lx · y − lx · l y , uy · x + ux · y − ux · uy} x · y ≤min{uy · x + lx · y − lx · uy , l y · x + ux · y − ux · l y} .\nTo simplify the notation, we use a single index i ∈ W to denote the individual elements of π,λ2, z. From the assumptions of the theorem and the constraints on policies, we have that: π(i) ∈ [0,1] and λ2 ∈ [0,τ]. Then for all i the McCormic inequalities for (5.1) are:\nπ(i) ·λ2(i)≥max{0,λ2(i)−τ · (1−π(i))} π(i) ·λ2(i)≤min{τ ·π(i),λ2(i)}.\nSince any optimal z in (5.2) satisfies z(i) = max{0,λ2(i)− τ · (1−π(i))}, z(i) is a lower bound on π(i) ·λ(i). As a result, for any π ∈ ΠR, the objective of (5.2) is an upper bound on the objective of (5.1). Then, it can be readily shown that whenever π(i) ∈ {0, 1} then π(i) = λ2(i)π(i): when π(i) = 1 then z(i) = λ2(i) = π(i)·λ2(i) and when π(i) = 0 then z(i) =max{0,λ2(i)−τ·(1−π(i))}= 0= π(i)·λ2(i). This shows the equality of the sets of optimal solutions stated in the theorem.\nAs discussed above, any practical implementation of DRADP must be sample-based. The bilinear program (5.1) is constructed from samples very similarly to ALPs (e.g. Sec 6 of (de Farias & van Roy, 2003)) and identically to ABPs (e.g. Sec 6 of (Petrik & Zilberstein, 2011)). Briefly, the formulation involves only the rows of A that correspond to transitions of sampled state-action pairs and b entries are estimated from the corresponding rewards. As a result, there is one λ1 variable for each feature, and λ2 and π are nonzero only for the sampled rows of A (zeros do not need to be considered). The size of the optimization problem (5.1) is then independent of the number of states and actions of the MDP; it depends only on the number of samples and features."
    }, {
      "heading" : "6 Experimental Results",
      "text" : "In this section, we experimentally evaluate the empirical performance of DRADP. We present results on the inverted pendulum problem—a standard benchmark problem—and a synthetic chain problem. We gather state and action samples in advance and solve MILP (5.2) using IBM CPLEX 12.2. We then compare the results to three related methods which work on offline samples: 1) LSPI (Lagoudakis & Parr, 2003), 2) ALP (de Farias & van Roy, 2003), and 3) ABP (Petrik & Zilberstein, 2009). While solving the MILP formulation of DRADP is NP hard (in the number of features and samples), this does not mean that the computation takes longer than for other ADP methods; for example, the computation time of LSPI is unbounded in the worst case (there are no convergence guarantees). In the experiments, we restrict the computation time for all methods to 60s.\nInverted Pendulum The goal in the inverted pendulum benchmark problem is to balance an inverted pole by accelerating a cart in either of two directions (Lagoudakis & Parr, 2003). There are three actions that represent applying the force of u = −50N , u = 0N , and u = 50N to the cart with a uniform noise between −10N and 10N . The angle of the inverted pendulum is governed by a differential equation. We used the standard features for this benchmark problem for all the methods: 9 radial basis functions arranged in a grid over the 2-dimensional state space with centers µi and a constant term required\nby Assumption 2. The problem setting, including the initial distribution is identical to the setting in (Lagoudakis & Parr, 2003).\nFig. 1 shows the number of balancing steps (with a 3000-step bound) for each method as a function of the number of training samples averaged over 5 runs. The figure does not show error bars for clarity; the variance was close to 0 for DRADP. The results indicate that DRADP computes a very good solution for even a small number of samples and significantly outperforms LSPI. Note the poor performance of ABP and ALP with the 10 standard features; better results have been obtained with large and different feature spaces (Petrik et al., 2010) but even these do not match DRADP. The solution quality of ABP decreases with more samples, because the bounds become more conservative and the optimization problems become harder to solve.\nChain Problem Because the solution quality of ADP methods depends on many factors, good results on a single benchmark problem do not necessarily generalize to other domains. We, therefore, compare DRADP to other methods on a large number of randomly generated chain problems. This problem consists of 30 states s1 . . . s30 and 2 actions: left and right with 10% chance of moving the opposite way. The features are 10 orthogonal polynomials. The rewards are 0 except: r(s2) = −50, r(s3) = 4, r(s4) = −50, r(s20) = 10. Fig. 2 shows the results of 1000 instantiations with randomly chosen initial distributions and indicates that DRADP significantly outperforms other methods including API (a simple version of LSPI)."
    }, {
      "heading" : "7 Conclusion",
      "text" : "This paper proposes and analyzes DRADP—a new ADP method. DRADP is based on a mathematical optimization formulation—like ALP—but offers significantly stronger theoretical guarantees and better empirical performance. The DRADP framework also makes it easy to improve the solution quality by incorporating additional assumptions on state occupation frequencies, such as the small concentration coefficient. Given the encouraging theoretical and empirical properties of DRADP, we hope it will lead to better methods for solving large MDPs and will help to deepen the understanding of ADP.\nAcknowledgements I thank Dan Iancu and Dharmashankar Subramanian for the discussions that inspired this paper. I also thank the anonymous ICML 2012 and EWRL 2012 reviewers for their detailed comments."
    }, {
      "heading" : "A Basic Properties of Value Functions",
      "text" : "Lemma A.1. For any v ∈ V the following holds: L(v + k1) = Lv + γk1. In addition, the sets of greedy policies with respect to v and v+ k1 are identical.\nLemma A.2. The operators P and (I− γP)−1 are monotonous for any stochastic matrix P:\nx ≥ y ⇒ P x ≥ P y\nx ≥ y ⇒ (I− γP)−1 x ≥ (I− γP)−1 y\nfor all x and y.\nLemma A.3. Suppose that v ∈ V satisfies v ≥ Lv. Then v ≥ v?.\nLemma A.4. Each v ∈ V satisfies: v− Lv ≤ v − Lπv."
    } ],
    "references" : [ {
      "title" : "Robust Optimization",
      "author" : [ "Ben-Tal", "Aharon", "Ghaoui", "Laurent El", "Nemirovski", "Arkadi" ],
      "venue" : null,
      "citeRegEx" : "Ben.Tal et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Ben.Tal et al\\.",
      "year" : 2009
    }, {
      "title" : "The linear programming approach to approximate dynamic programming",
      "author" : [ "de Farias", "Daniela P", "van Roy", "Ben" ],
      "venue" : "Operations Research,",
      "citeRegEx" : "Farias et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Farias et al\\.",
      "year" : 2003
    }, {
      "title" : "Distributionally robust optimization under moment uncertainty with application to data driven problems",
      "author" : [ "Delage", "Eric", "Ye", "Yinyu" ],
      "venue" : "Operations Research,",
      "citeRegEx" : "Delage et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Delage et al\\.",
      "year" : 2010
    }, {
      "title" : "Symmetric approximate linear programming for factored MDPs with application to constrained problems",
      "author" : [ "Dolgov", "Dmitri", "Durfee", "Edmund" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "Dolgov et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Dolgov et al\\.",
      "year" : 2006
    }, {
      "title" : "Global optimization: Deterministic approaches",
      "author" : [ "Horst", "Reiner", "Tuy", "Hoang" ],
      "venue" : null,
      "citeRegEx" : "Horst et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Horst et al\\.",
      "year" : 1996
    }, {
      "title" : "Least-squares policy iteration",
      "author" : [ "Lagoudakis", "Michail G", "Parr", "Ronald" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Lagoudakis et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Lagoudakis et al\\.",
      "year" : 2003
    }, {
      "title" : "A simplicial branch-and-bound algorithm for solving quadratically constrained quadratic programs",
      "author" : [ "Linderoth", "Jeff" ],
      "venue" : "Mathematical Programming, Series B,",
      "citeRegEx" : "Linderoth and Jeff.,? \\Q2005\\E",
      "shortCiteRegEx" : "Linderoth and Jeff.",
      "year" : 2005
    }, {
      "title" : "Error bounds for approximate policy iteration",
      "author" : [ "Munos", "Remi" ],
      "venue" : "In International Conference on Machine Learning,",
      "citeRegEx" : "Munos and Remi.,? \\Q2003\\E",
      "shortCiteRegEx" : "Munos and Remi.",
      "year" : 2003
    }, {
      "title" : "Performance bounds in Lp norm for approximate value iteration",
      "author" : [ "Munos", "Remi" ],
      "venue" : "SIAM Journal of Control and Optimization,",
      "citeRegEx" : "Munos and Remi.,? \\Q2007\\E",
      "shortCiteRegEx" : "Munos and Remi.",
      "year" : 2007
    }, {
      "title" : "Approximate dynamic programming by minimizing distributionally robust bounds",
      "author" : [ "Petrik", "Marek" ],
      "venue" : null,
      "citeRegEx" : "Petrik and Marek.,? \\Q2012\\E",
      "shortCiteRegEx" : "Petrik and Marek.",
      "year" : 2012
    }, {
      "title" : "Robust value function approximation using bilinear programming",
      "author" : [ "Petrik", "Marek", "Zilberstein", "Shlomo" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "Petrik et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Petrik et al\\.",
      "year" : 2009
    }, {
      "title" : "Robust approximate bilinear programming for value function approximation",
      "author" : [ "Petrik", "Marek", "Zilberstein", "Shlomo" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Petrik et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Petrik et al\\.",
      "year" : 2011
    }, {
      "title" : "Feature selection using regularization in approximate linear programs for Markov decision processes",
      "author" : [ "Petrik", "Marek", "Taylor", "Gavin", "Parr", "Ron", "Zilberstein", "Shlomo" ],
      "venue" : "In International Conference on Machine Learning,",
      "citeRegEx" : "Petrik et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Petrik et al\\.",
      "year" : 2010
    }, {
      "title" : "Markov decision processes: Discrete stochastic dynamic programming",
      "author" : [ "Puterman", "Martin L" ],
      "venue" : null,
      "citeRegEx" : "Puterman and L.,? \\Q2005\\E",
      "shortCiteRegEx" : "Puterman and L.",
      "year" : 2005
    }, {
      "title" : "Generalized polynomial approximations in Markovian decision processes",
      "author" : [ "Schweitzer", "Paul J", "Seidmann", "Abraham" ],
      "venue" : "Journal of Mathematical Analysis and Applications,",
      "citeRegEx" : "Schweitzer et al\\.,? \\Q1985\\E",
      "shortCiteRegEx" : "Schweitzer et al\\.",
      "year" : 1985
    }, {
      "title" : "New Representations and Approximations for Sequential Decision Making",
      "author" : [ "Wang", "Tao" ],
      "venue" : "PhD thesis, University of Alberta,",
      "citeRegEx" : "Wang and Tao.,? \\Q2007\\E",
      "shortCiteRegEx" : "Wang and Tao.",
      "year" : 2007
    }, {
      "title" : "Stable dynamic programming",
      "author" : [ "Wang", "Tao", "Lizotte", "Daniel", "Bowling", "Michael", "Schuurmans", "Dale" ],
      "venue" : "In Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "Wang et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 16,
      "context" : "Occupancy frequencies have been used, for example, to solve factored MDPs (Dolgov & Durfee, 2006) and in dual dynamic programming (Wang, 2007; Wang et al., 2008) (The term “dual dynamic programming” also refers to unrelated linear stochastic programming methods).",
      "startOffset" : 130,
      "endOffset" : 161
    }, {
      "referenceID" : 0,
      "context" : "Robust optimization is a recently revived approach for modeling uncertainty in optimization problems (Ben-Tal et al., 2009).",
      "startOffset" : 101,
      "endOffset" : 123
    }, {
      "referenceID" : 12,
      "context" : "The sampling is performed and errors bounded identically to approximate linear programming and approximate bilinear programming—state and action samples are used to select a subset of constraints and variables (de Farias & van Roy, 2003; Petrik et al., 2010; Petrik & Zilberstein, 2011).",
      "startOffset" : 210,
      "endOffset" : 286
    }, {
      "referenceID" : 12,
      "context" : "Note the poor performance of ABP and ALP with the 10 standard features; better results have been obtained with large and different feature spaces (Petrik et al., 2010) but even these do not match DRADP.",
      "startOffset" : 146,
      "endOffset" : 167
    } ],
    "year" : 2012,
    "abstractText" : "Approximate dynamic programming is a popular method for solving large Markov decision processes. This paper describes a new class of approximate dynamic programming (ADP) methods— distributionally robust ADP—that address the curse of dimensionality by minimizing a pessimistic bound on the policy loss. This approach turns ADP into an optimization problem, for which we derive new mathematical program formulations and analyze its properties. DRADP improves on the theoretical guarantees of existing ADP methods—it guarantees convergence and L1 norm-based error bounds. The empirical evaluation of DRADP shows that the theoretical guarantees translate well into good performance on benchmark problems.",
    "creator" : "LaTeX with hyperref package"
  }
}