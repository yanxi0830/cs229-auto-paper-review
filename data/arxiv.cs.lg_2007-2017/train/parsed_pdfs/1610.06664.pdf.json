{
  "name" : "1610.06664.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Stochastic Gradient MCMC with Stale Gradients",
    "authors" : [ "Changyou Chen", "Nan Ding", "Chunyuan Li", "Yizhe Zhang", "Lawrence Carin" ],
    "emails" : [ "cc448@duke.edu;", "cl319@duke.edu;", "yz196@duke.edu;", "lcarin@duke.edu;", "dingnan@google.com" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "The pervasiveness of big data has made scalable machine learning increasingly important, especially for deep models. A basic technique is to adopt stochastic optimization algorithms [1], e.g., stochastic gradient descent and its extensions [2]. In each iteration of stochastic optimization, a minibatch of data is used to evaluate the gradients of the objective function and update model parameters (errors are introduced in the gradients, because they are computed based on minibatches rather than the entire dataset; since the minibatches are typically selected at random, this yields the term “stochastic” gradient). This is highly scalable because processing a minibatch of data in each iteration is relatively cheap compared to analyzing the entire (large) dataset at once. Under certain conditions, stochastic optimization is guaranteed to converge to a (local) optima [1]. Because of its scalability, the minibatch strategy has recently been extended to Markov Chain Monte Carlo (MCMC) Bayesian sampling methods, yielding SG-MCMC [3, 4, 5].\nIn order to handle large-scale data, distributed stochastic optimization algorithms have been developed, for example [6], to further improve scalability. In a distributed setting, a cluster of machines with multiple cores cooperate with each other, typically through an asynchronous scheme, for scalability [7, 8, 9]. A downside of an asynchronous implementation is that stale gradients must be used in parameter updates (“stale gradients” are stochastic gradients computed based on outdated parameters, instead of the latest parameters; they are easier to compute in a distributed system, but introduce additional errors relative to traditional stochastic gradients). While some theory has been developed to guarantee the convergence of stochastic optimization with stale gradients [10, 11, 12], little analysis has been done in a Bayesian setting, where SG-MCMC is applied. Distributed SG-MCMC algorithms share characteristics with distributed stochastic optimization, and thus are highly scalable and suitable for large-scale Bayesian learning. Existing Bayesian distributed systems with traditional MCMC\n29th Conference on Neural Information Processing Systems (NIPS 2016), Barcelona, Spain.\nar X\niv :1\n61 0.\n06 66\n4v 1\n[ st\nat .M\nL ]\n2 1\nO ct\n2 01\nmethods, such as [13], usually employ stale statistics instead of stale gradients, where stale statistics are summarized based on outdated parameters, e.g., outdated topic distributions in distributed Gibbs sampling [13]. Little theory exists to guarantee the convergence of such methods. For existing distributed SG-MCMC methods, typically only standard stochastic gradients are used, for limited problems such as matrix factorization, without rigorous convergence theory [14, 15, 16].\nIn this paper, by extending techniques from standard SG-MCMC [17], we develop theory to study the convergence behavior of SG-MCMC with Stale gradients (S2G-MCMC). Our goal is to evaluate the posterior average of a test function φ(x), defined as φ̄ , ∫ X φ(x)ρ(x)d x, where ρ(x) is the desired posterior distribution with x the possibly augmented model parameters (see Section 2). In practice, S2G-MCMC generates L samples {xl}Ll=1 and uses the sample average φ̂L , 1L ∑L l=1 φ(xl) to approximate φ̄. We measure how φ̂L approximates φ̄ in terms of bias, MSE and estimation variance,\ndefined as |Eφ̂L − φ̄|, E ( φ̂L − φ̄ )2 and E ( φ̂L − Eφ̂L )2 , respectively. From the definitions, the\nbias and MSE characterize how accurately φ̂L approximates φ̄, and the variance characterizes how fast φ̂L converges to its own expectation (for a prescribed number of samples L). Our theoretical results show that while the bias and MSE depend on the staleness of stochastic gradients, the variance is independent of it. In a simple asynchronous Bayesian distributed system with S2G-MCMC, our theory indicates a linear speedup on the decrease of the variance w.r.t. the number of workers used to calculate the stale gradients, while maintaining the same optimal bias level as standard SG-MCMC. We validate our theory on several synthetic experiments and deep neural network models, demonstrating the effectiveness and scalability of the proposed S2G-MCMC framework.\nRelated Work Using stale gradients is a standard setup in distributed stochastic optimization systems. Representative algorithms include, but are not limited to, the ASYSG-CON [6] and HOGWILD! algorithms [18], and some more recent developments [19, 20]. Furthermore, recent research on stochastic optimization has been extended to non-convex problems with provable convergence rates [12]. In Bayesian learning with MCMC, existing work has focused on running parallel chains on subsets of data [21, 22, 23, 24], and little if any effort has been made to use stale stochastic gradients, the setting considered in this paper."
    }, {
      "heading" : "2 Stochastic Gradient MCMC",
      "text" : "Throughout this paper, we denote vectors as bold lower-case letters, and matrices as bold uppercase letters. For example, N (m,Σ) means a multivariate Gaussian distribution with mean m and covariance Σ. In the analysis we consider algorithms with fixed-stepsizes for simplicity; decreasingstepsize variants can be addressed similarly as in [17].\nThe goal of SG-MCMC is to generate random samples from a posterior distribution p(θ|D) ∝ p(θ) ∏N i=1 p(di |θ), which are used to evaluate a test function. Here θ ∈ Rn represents the parameter vector and D = {d1, · · · ,dN} represents the data, p(θ) is the prior distribution, and p(di |θ) the likelihood for di. SG-MCMC algorithms are based on a class of stochastic differential equations, called Itô diffusion, defined as\nd xt = F (xt)dt+ g(xt)dwt , (1)\nwhere x ∈ Rm represents the model states, typically x augments θ such that θ ⊆ x and n ≤ m; t is the time index, wt ∈ Rm is m-dimensional Brownian motion, functions F : Rm → Rm and g : Rm → Rm×m are assumed to satisfy the usual Lipschitz continuity condition [25]. For appropriate functions F and g, the stationary distribution, ρ(x), of the Itô diffusion (1) has a marginal distribution equal to the posterior distribution p(θ|D) [26]. For example, denoting the unnormalized negative log-posterior as U(θ) , − log p(θ) − ∑N i=1 log p(di |θ), the stochastic gradient Langevin dynamic (SGLD) method [3] is based on 1st-order Langevin dynamics, with x = θ, and F (xt) = −∇θU(θ), g(xt) = √ 2 In, where In is the n × n identity matrix. The stochastic gradient Hamiltonian Monte Carlo (SGHMC) method [4] is based on 2nd-order Langevin\ndynamics, with x = (θ,q), and F (xt) = (\nq −B q−∇θU(θ)\n) , g(xt) = √ 2B (\n0 0 0 In\n) for a\nscalar B > 0; q is an auxiliary variable known as the momentum [4, 5]. Diffusion forms for other\nSG-MCMC algorithms, such as the stochastic gradient thermostat [5] and variants with Riemannian information geometry [27, 26, 28], are defined similarly.\nIn order to efficiently draw samples from the continuous-time diffusion (1), SG-MCMC algorithms typically apply two approximations: i) Instead of analytically integrating infinitesimal increments dt, numerical integration over small step size h is used to approximate the integration of the true dynamics. ii) Instead of working with the full gradient ∇θU(θlh), a stochastic gradient ∇θŨl(θlh), defined as\n∇θŨl(θ) , −∇θ log p(θ)− N\nJ J∑ i=1 ∇θ log p(dπi |θ), (2)\nis calculated from a minibatch of size J , where {π1, · · · , πJ} is a random subset of {1, · · · , N}. Note that to match the time index t in (1), parameters have been and will be indexed by “lh” in the l-th iteration."
    }, {
      "heading" : "3 Stochastic Gradient MCMC with Stale Gradients",
      "text" : "In this section, we extend SG-MCMC to the stale-gradient setting, commonly met in asynchronous distributed systems [7, 8, 9], and develop theory to analyze convergence properties.\n3.1 Stale stochastic gradient MCMC (S2G-MCMC)\nThe setting for S2G-MCMC is the same as the standard SG-MCMC described above, except that the stochastic gradient (2) is replaced with a stochastic gradient evaluated with outdated parameter θ(l−τl)h instead of the latest version θlh (see Appendix A for an example):\n∇θÛτl(θ) , −∇θ log p(θ(l−τl)h)− N\nJ J∑ i=1 ∇θ log p(dπi |θ(l−τl)h), (3)\nwhere τl ∈ Z+ denotes the staleness of the parameter used to calculate the stochastic gradient in the l-th iteration. A distinctive difference between S2G-MCMC and SG-MCMC is that stale stochastic gradients are no longer unbiased estimations of the true gradients. This leads to additional challenges in developing convergence bounds, one of the main contributions of this paper.\nAlgorithm 1 State update of SGHMC with the stale stochastic gradient∇θÛτl(θ)\nInput: xlh = (θlh,qlh),∇θÛτl(θ), τl, τ , h, B Output: x(l+1)h = (θ(l+1)h,q(l+1)h) if τl ≤ τ then\nDraw ζl ∼ N (0, I); q(l+1)h = (1−Bh) qlh−∇θÛτl(θ)h+ √ 2Bhζl;\nθ(l+1)h = θlh + q(l+1)h h; end if\nWe assume a bounded staleness for all τl’s, i.e.,\nmax l τl ≤ τ\nfor some constant τ . As an example, Algorithm 1 describes the update rule of the stale-SGHMC in each iteration with the Euler integrator, where the stale gradient ∇θÛτl(θ) with staleness τl is used."
    }, {
      "heading" : "3.2 Convergence analysis",
      "text" : "This section analyzes the convergence properties of the basic S2G-MCMC; an extension with multiple chains is discussed in Section 3.3. It is shown that the bias and MSE depend on the staleness parameter τ , while the variance is independent of it, yielding significant speedup in Bayesian distributed systems.\nBias and MSE In [17], the bias and MSE of the standard SG-MCMC algorithms with a Kth order integrator were analyzed, where the order of an integrator reflects how accurately an SG-MCMC algorithm approximates the corresponding continuous diffusion. Specifically, if evolving xt with a numerical integrator using discrete time increment h induces an error bounded by O(hK), the integrator is called a Kth order integrator, e.g., the popular Euler method used in SGLD [3] is a 1st-order integrator. In particular, [17] proved the bounds stated in Lemma 1.\nLemma 1 ([17]). Under standard assumptions (see Appendix B), the bias and MSE of SG-MCMC with a Kth-order integrator at time T = hL are bounded as:\nBias: ∣∣∣Eφ̂L − φ̄∣∣∣ = O(∑l ‖E∆Vl‖\nL +\n1\nLh + hK ) MSE: E ( φ̂L − φ̄ )2 = O ( 1 L ∑ l E ‖∆Vl‖ 2\nL +\n1\nLh + h2K\n)\nHere ∆Vl , L − L̃l, where L is the generator of the Itô diffusion (1) defined as\nLf(xt) , lim h→0+ E [f(xt+h)]− f(xt) h =\n( F (xt) · ∇x + 1\n2\n( g(xt)g(xt) T ) :∇x∇Tx ) f(xt) , (4)\nfor any compactly supported twice differentiable function f : Rn → R, h→ 0+ means h approaches zero along the positive real axis. L̃l is the same as L except using the stochastic gradient∇Ũl instead of the full gradient.\nWe show that the bounds of the bias and MSE of S2G-MCMC share similar forms as SG-MCMC, but with additional dependence on the staleness parameter. In addition to the assumptions in SG-MCMC [17] (see details in Appendix B), the following additional assumption is imposed.\nAssumption 1. The noise in the stochastic gradients is well-behaved, such that: 1) the stochastic gradient is unbiased, i.e., ∇θU(θ) = Eξ∇θŨ(θ) where ξ denotes the random permutation over\n{1, · · · , N}; 2) the variance of stochastic gradient is bounded, i.e., Eξ ∥∥∥U(θ)− Ũ(θ)∥∥∥2 ≤ σ2; 3) the\ngradient function∇θU is Lipschitz (so is∇θŨ ), i.e., ‖∇θU(x)−∇θU(y)‖ ≤ C ‖x−y‖ ,∀x,y.\nIn the following theorems, we omit the assumption statement for conciseness. Due to the staleness of the stochastic gradients, the term ∆Vl in S2G-MCMC is equal to L−L̃l−τl , where L̃l−τl arises from ∇θÛτl . The challenge arises to bound these terms involving ∆Vl. To this end, define flh ,∥∥xlh−x(l−1)h∥∥, and ψ to be a functional satisfying the Poisson Equation∗:\n1\nL L∑ l=1 Lψ(xlh) = φ̂L − φ̄ . (5)\nTheorem 2. After L iterations, the bias of S2G-MCMC with a Kth-order integrator is bounded, for some constant D1 independent of {L, h, τ}, as:∣∣∣Eφ̂L − φ̄∣∣∣ ≤ D1( 1\nLh +M1τh+M2h\nK ) ,\nwhere M1 , maxl |Lflh|maxl ‖E∇ψ(xlh)‖C, M2 , ∑K k=1 ∑ l EL̃ k+1 l ψ(x(l−1)h) (k+1)!L are constants.\nTheorem 3. After L iterations, the MSE of S2G-MCMC with a Kth-order integrator is bounded, for some constant D2 independent of {L, h, τ}, as:\nE ( φ̂L − φ̄ )2 ≤ D2 ( 1\nLh + M̃1τ\n2h2 + M̃2h 2K ) ,\nwhere constants M̃1 , maxl ‖E∇ψ(xlh)‖2 maxl (Lflh)2 C2, M̃2 , E( ∑ l L̃ K+1 l ψ(x(l−1)h) L(K+1)! )\n2. The theorems indicate that both the bias and MSE depend on the staleness parameter τ . For a fixed computational time, this could possibly lead to unimproved bounds, compared to standard SG-MCMC, when τ is too large, i.e., the terms with τ would dominate, as is the case in the distributed system discussed in Section 4. Nevertheless, better bounds than standard SG-MCMC could be obtained if the decrease of 1Lh is faster than the increase of the staleness in a distributed system.\n∗The existence of a nice ψ is guaranteed in the elliptic/hypoelliptic SDE settings when x is on a torus [25].\nVariance Next we investigate the convergence behavior of the variance, Var(φ̂L) , E ( φ̂L − Eφ̂L )2 . Theorem 4 indicates the variance is independent of τ , hence a linear speedup in the\ndecrease of variance is always achievable when stale gradients are computed in parallel. An example is discussed in the Bayesian distributed system in Section 4. Theorem 4. After L iterations, the variance of S2G-MCMC with a Kth-order integrator is bounded, for some constant D, as:\nVar ( φ̂L ) ≤ D ( 1\nLh + h2K\n) .\nThe variance bound is the same as for standard SG-MCMC, whereas L could increase linearly w.r.t. the number of workers in a distributed setting, yielding significant variance reduction. When optimizing the the variance bound w.r.t.h, we get an optimal variance bound stated in Corollary 5. Corollary 5. In term of estimation variance, the optimal convergence rate of S2G-MCMC with a Kth-order integrator is bounded as: Var ( φ̂L ) ≤ O ( L−2K/(2K+1) ) .\nIn real distributed systems, the decrease of 1/Lh and increase of τ , in the bias and MSE bounds, would typically cancel, leading to the same bias and MSE level compared to standard SG-MCMC, whereas a linear speedup on the decrease of variance w.r.t. the number of workers is always achievable. More details are discussed in Section 4."
    }, {
      "heading" : "3.3 Extension to multiple parallel chains",
      "text" : "This section extends the theory to the setting with S parallel chains, each independently running an S2G-MCMC algorithm. After generating samples from the S chains, an aggregation step is needed to combine the sample average from each chain, i.e., {φ̂Ls}Ms=1, where Ls is the number of iterations on chain s. For generality, we allow each chain to have different step sizes, e.g., (hs)Ss=1. We aggregate the sample averages as φ̂SL , ∑S s=1 Ts T φ̂Ls , where Ts , Lshs, T , ∑S s=1 Ts.\nInterestingly, with increasing S, using multiple chains does not seem to directly improve the convergence rate for the bias, but improves the MSE bound, as stated in Theorem 6.\nTheorem 6. Let Tm , maxl Tl, hm , maxl hl, T̄ = T/S, the bias and MSE of S parallel S2GMCMC chains with a Kth-order integrator are bounded, for some constants D1 and D2 independent of {L, h, τ}, as:\nBias: ∣∣∣Eφ̂SL − φ̄∣∣∣ ≤ D1( 1T̄ + TmT̄ (M1τhs +M2hKs ) ) MSE: E ( φ̂SL − φ̄ )2 ≤ D2 ( 1− 1/T̄\nT +\n1 T̄ 2 + T 2m T̄ 2 ( M21 τ 2h2s +M 2 2h 2K s )) .\nAssume that T̄ = T/S is independent of the number of chains. As a result, using multiple chains does not directly improve the bound for the bias†. However, for the MSE bound, although the last two terms are independent of S, the first term decreases linearly with respect to S because T = T̄ S. This indicates a decreased estimation variance with more chains. This matches the intuition because more samples can be obtained with more chains in a given amount of time.\nThe decrease of MSE for multiple-chain is due to the decrease of the variance as stated in Theorem 7. Theorem 7. The variance of S parallel S2G-MCMC chains with a Kth-order integrator is bounded, for some constant D independent of {L, h, τ}, as:\nE ( φ̂SL − Eφ̂SL )2 ≤ D\n( 1\nT + S∑ s=1 T 2s T 2 h2Ks\n) .\nWhen using the same step size for all chains, Theorem 7 gives an optimal variance bound of O ( ( ∑ s Ls) −2K/(2K+1)), i.e. a linear speedup with respect to S is achieved. In addition, Theorem 6 with τ = 0 and K = 1 provides convergence rates for the distributed SGLD algorithm in [14], i.e., improved MSE and variance bounds compared to the single-server SGLD. †It means the bound does not directly relate to low-order terms of S, though constants might be improved."
    }, {
      "heading" : "4 Applications to Distributed SG-MCMC Systems",
      "text" : "Our theory for S2G-MCMC is general, serving as a basic analytic tool for distributed SG-MCMC systems. We propose two simple Bayesian distributed systems with S2G-MCMC in the following.\nSingle-chain distributed SG-MCMC Perhaps the simplest architecture is an asynchronous distributed SG-MCMC system, where a server runs an S2G-MCMC algorithm, with stale gradients computed asynchronously from W workers. The detailed operations of the server and workers are described in Appendix A.\nWith our theory, now we explain the convergence property of this simple distributed system with SG-MCMC, i.e., a linear speedup w.r.t. the number of workers on the decrease of variance, while maintaining the same bias level. To this end, rewrite L = WL̄ from Theorems 2 and 3, where L̄ is the average number of iterations on each worker. We can observe from the theorems that when M1τh > M2h\nK in the bias and M̃1τ2h2 > M̃2h2K in the MSE, the terms with τ dominate. Optimizing the bounds with respect to h yields a bound of O((τ/WL̄)1/2) for the bias, and O((τ/WL̄)2/3) for the MSE. In practice, we usually observe τ ≈ W , making W in the optimal bounds cancels, i.e., the same optimal bias and MSE bounds as standard SG-MCMC are obtained, no theoretical speedup is achieved when increasing W . However, from Corollary 5, the variance is independent of τ , thus a linear speedup on the variance bound can be always obtained when increasing the number of workers, i.e., the distributed SG-MCMC system convergences a factor of W faster than standard SG-MCMC with a single machine. We are not aware of similar conclusions from optimization, because most of the research focuses on the convex setting, thus only variance (equivalent to MSE) is studied.\nMultiple-chain distributed SG-MCMC We can also adopt multiple servers based on the multiplechain setup in Section 3.3, where each chain corresponds to one server. The detailed architecture is described in Appendix A. This architecture trades off communication cost with convergence rates. As indicated by Theorems 6 and 7, the MSE and variance bounds can be improved with more servers. Note that when only one worker is associated with one server, we recover the setting of S independent servers. Compared to the single-server architecture described above with S workers, from Theorems 2–7, while the variance bound is the same, the single-server arthitecture improves the bias and MSE bounds by a factor of S.\nMore advanced architectures More complex architectures could also be designed to reduce communication cost, for example, by extending the downpour [7] and elastic SGD [29] architectures to the SG-MCMC setting. Their convergence properties can also be analyzed with our theory since they are essentially using stale gradients. We leave the detailed analysis for future work."
    }, {
      "heading" : "5 Experiments",
      "text" : "Our primal goal is to validate the theory, comparing with different distributed architectures and algorithms, such as [30, 31], is beyond the scope of this paper. We first use two synthetic experiments to validate the theory, then apply the distributed architecture described in Section 4 for Bayesian deep learning. To quantitatively describe the speedup property, we adopt the the iteration speedup [12], defined as: iteration speedup , #iterations with a single workeraverage #iterations on a worker , where # is the iteration count when the same level of precision is achieved. This speedup best matches with the theory. We also consider the time speedup, defined as: running time for a single workerrunning time forW worker , where the running time is recorded at the same accuracy. It is affected significantly by hardware, thus is not accurately consistent with the theory."
    }, {
      "heading" : "5.1 Synthetic experiments",
      "text" : "Impact of stale gradients A simple Gaussian model is used to verify the impact of stale gradients on the convergence accuracy, with di ∼ N (θ, 1), θ ∼ N (0, 1). 1000 data samples {di} are generated, with minibatches of size 10 to calculate stochastic gradients. The test function is φ(θ) , θ2. The distributed SGLD algorithm is adopted in this experiment. We aim to verify that the optimal MSE bound ∝ τ2/3L−2/3, derived from Theorem 3 and discussed in Section 4 (with W = 1). The optimal stepsize is h = Cτ−2/3L−1/3 for some constant C. Based on the optimal bound, setting\nL = L0 × τ for some fixed L0 and varying τ ’s would result in the same MSE, which is ∝ L−2/30 . In the experiments we set C = 1/30, L0 = 500, τ = {1, 2, 5, 10, 15, 20}, and average over 200 runs to approximate the expectations in the MSE formula. As indicated in Figure 1, approximately the same MSE’s are obtained after L0τ iterations for different τ values, consistent with the theory. Note since the stepsizes are set to make end points of the curves reach the optimal MSE’s, the curves would not match the optimal MSE curves of τ2/3L−2/3 in general, except for the end points, i.e., they are lower bounded by τ2/3L−2/3.\nConvergence speedup of the variance A Bayesian logistic regression model (BLR) is adopted to verify the variance convergence properties. We use the Adult dataset‡, a9a, with 32,561 training samples and 16,281 test samples. The test function is defined as the standard logistic loss. We average over 10 runs to estimate the expectation Eφ̂L in the variance. We use the single-server distributed architecture in Section 4, with multiple workers computing stale gradients in parallel. We plot the variance versus the average number of iterations on the workers (L̄) and the running time in Figure 2 (a) and (b), respectively. We can see that the variance drops faster with increasing number of workers. To quantitatively relate these results to the theory, Corollary 5 indicates that L1L2 = W1 W2\n, where (Wi, Li)2i=1 means the number of workers and iterations at the same variance, i.e., a linear speedup is achieved. The iteration speedup and time speedup are plotted in Figure 2 (c), showing that the iteration speedup approximately scales linearly worker numbers, consistent with Corollary 5; whereas the time speedup deteriorates when the worker number is large due to high system latency."
    }, {
      "heading" : "5.2 Applications to deep learning",
      "text" : "We further test S2G-MCMC on Bayesian learning of deep neural networks. The distributed system is developed based on an MPI (message passing interface) extension of the popular Caffe package for deep learning [32]. We implement the SGHMC algorithm, with the point-to-point communications between servers and workers handled by the MPICH library.The algorithm is run on a cluster of five machines. Each machine is equipped with eight 3.60GHz Intel(R) Core(TM) i7-4790 CPU cores.\nWe evaluate S2G-MCMC on the above BLR model and two deep convolutional neural networks (CNN). In all these models, zero mean and unit variance Gaussian priors are employed for the weights to capture weight uncertainties, an effective way to deal with overfitting [33]. We vary the number of servers S among {1, 3, 5, 7}, and the number of workers for each server from 1 to 9.\nLeNet for MNIST We modify the standard LeNet to a Bayesian setting for the MNIST dataset.LeNet consists of 2 convolutional layers, 2 max pool layers and 2 ReLU nonlinear layers, followed by 2 fully connected layers [34]. The detailed specification can be found in Caffe. For simplicity, we use the default parameter setting specified in Caffe, with the additional parameter B in SGHMC (Algorithm 1) set to (1−m), where m is the moment variable defined in the SGD algorithm in Caffe.\n‡http://www.csie.ntu.edu.tw/ cjlin/libsvmtools/datasets/binary.html.\nCifar10-Quick net for CIFAR10 The Cifar10-Quick net consists of 3 convolutional layers, 3 max pool layers and 3 ReLU nonlinear layers, followed by 2 fully connected layers. The CIFAR-10 dataset consists of 60,000 color images of size 32×32 in 10 classes, with 50,000 for training and 10,000 for testing.Similar to LeNet, default parameter setting specified in Caffe is used.\nIn these models, the test function is defined as the cross entropy of the softmax outputs {o1, · · · ,oN} for test data {(d1, y1), · · · , (dN , yN )} with C classes, i.e., loss = − ∑N i=1 oyi +N log ∑C c=1 e\noc . Since the theory indicates a linear speedup on the decrease of variance w.r.t. the number of workers, this means for a single run of the models, the loss would converge faster to its expectation with increasing number of workers. The following experiments verify this intuition."
    }, {
      "heading" : "5.2.1 Single-server experiments",
      "text" : "We first test the single-server architecture in Section 4 on the three models. Because the expectations in the bias, MSE or variance are not analytically available in these complex models, we instead plot the loss versus average number of iterations (L̄ defined in Section 4) on each worker and the running time in Figure 3. As mentioned above, faster decrease of the loss with more workers is expected.\nFor the ease of visualization, we only plot the results with {1, 2, 4, 6, 9} workers; more detailed results are provided in Appendix I. We can see that generally the loss decreases faster with increasing number of workers. In the CIFAR-10 dataset, the final losses of 6 and 9 workers are worst than the one with 4 workers. It shows that the accuracy of the sample average suffers from the increased staleness due to the increased number of workers. Therefore a smaller step size h should be considered to maintain high accuracy when using a large number of workers. Note the 1-worker curves correspond to the standard SG-MCMC, whose loss decreases much slower due to high estimation variance, though in theory it has the same level of bias as the single-server architecture for a given number of iterations (they will converge to the same accuracy)."
    }, {
      "heading" : "5.2.2 Multiple-server experiments",
      "text" : "Finally, we test the multiple-servers architecture on the same models. We use the same criterion as the single-server setting to measure the convergence behavior. The loss versus average number of iterations on each worker (L̄ defined in Section 4) for the three datasets are plotted in Figure 4, where we vary the number of servers among {1, 3, 5, 7}, and use 2 workers for each server. The plots of loss versus time and using different number of workers for each server are provided in the Appendix. We can see that in the simple BLR model, multiple servers do not seem to show significant speedup, probably due to the simplicity of the posterior, where the sample variance is too small for multiple\nservers to take effect; while in the more complicated deep neural networks, using more servers results in a faster decrease of the loss, especially in the MNIST dataset."
    }, {
      "heading" : "6 Conclusion",
      "text" : "We extend theory from standard SG-MCMC to the stale stochastic gradient setting, and analyze the impacts of the staleness to the convergence behavior of an S2G-MCMC algorithm. Our theory reveals that the estimation variance is independent of the staleness, leading to a linear speedup w.r.t. the number of workers, although in practice little speedup in terms of optimal bias and MSE might be achieved due to their dependence on the staleness. We test our theory on a simple asynchronous distributed SG-MCMC system with two simulated examples and several deep neural network models. Experimental results verify the effectiveness and scalability of the proposed S2G-MCMC framework.\nAcknowledgements Supported in part by ARO, DARPA, DOE, NGA, ONR and NSF."
    }, {
      "heading" : "B Assumptions",
      "text" : "First, following [25], we will need to assume the corresponding SDE of SG-MCMC to be either elliptic or hypoelliptic. The ellipticity/hypoellipticity describes whether the Brownian motion is able to spread over the whole parameter space. The SDE of the SGLD is elliptic, while for other SGMCMC algorithms such as the SGHMC, the hypoellipticity assumption is usually reasonable. When the domain x is on the torus, the ellipticity and hypoellipticity of an SDE guarantees the existence of a nice solution for the Poisson equation (5). The assumption is summarized in Assumption 2.\nAssumption 2. The corresponding SDE of a SG-MCMC algorithm is either elliptic or hypoelliptic‖.\nWhen x is extended to the domain of Rp for some integer p > 0, we need some assumptions on the solution of the Poisson equation (5). Note (5) can be equivalently written in an integration form [35] using Itô’s formula:\n1\nt ∫ t 0 φ(xs)ds− φ̄ (6)\n= 1\nt (ψ(xt)− ψ(x0))−\n1\nt ∫ t 0 ∇ψ(xs) · g(xs)dws .\nIntuitively, ψ needs to be bounded if the discrepancy between φ̂L and φ̄ were to be bounded. This is satisfied if the SDE is defined in a bounded domain [25]. In the unbounded domain as for SG-MCMC algorithms, it turns out the following boundedness assumptions on ψ suffice [17]. Assumption 3. 1) ψ and its up to 3rd-order derivatives, Dkψ, are bounded by a function V , i.e., ‖Dkψ‖ ≤ CkVpk for k = (0, 1, 2, 3), Ck, pk > 0. 2) the expectation of V on {xlh} is bounded: supl EVp(xlh) < ∞. 3) V is smooth such that sups∈(0,1) Vp (sx + (1− s) y) ≤ C (Vp (x) + Vp (y)), ∀x,y, p ≤ max{2pk} for some C > 0.\nFurthermore, in our proofs the expectation of a function under a diffusion needs to be expanded in a Taylor expansion style, e.g., Eφ(xt) = ∑` i=0 ti i!L iφ(x0) + t `+1r`,F,φ(x0) by using Kolmogorov’s\n‖The SDE of the SGLD can be verified to be elliptic. For other SG-MCMC algorithms such as the SGHMC, the hypoellipticity assumption is usually reasonable, see [25] on how to verify hypoellipticity of an SDE.\nbackward equation. To ensure the remainder term r`,F,φ(x0) to be bounded, it suffices to make the following assumption on the smoothness and boundedness of F (x) [35, 17].\nAssumption 4. F (x) is infinitely differentiable with bounded derivatives of any order; and |F (x)| ≤ A(1 + |x |s) for some integer s > 0 and A > 0."
    }, {
      "heading" : "C Notation",
      "text" : "For simplicity, we will simplify some notation used in the proof as follows:\n∇θŨl(θlh) , ∇θŨlh , G̃lh ∇θUl(θlh) , ∇θUlh , Glh ψ(Xlh) , ψlh"
    }, {
      "heading" : "D Proof of Theorem 2",
      "text" : "In S2G-MCMC, for the l-th iteration, suppose a stochastic gradient with a staleness τl is used, e.g., G̃(l−τl)h. First, we will bound the difference between G̃(l−τl)h and the stochastic gradient at the l-th iteration G̃lh, by using the Lipschitz property of G̃lh, with the following lemma.\nLemma 8. Let flh , ∥∥xlh−x(l−1)h∥∥, the expected difference between G̃(l−τl)h and G̃lh is bounded by: ∥∥∥E(G̃(l−τl)h − G̃lh)∥∥∥ = l−1max i=l−τl |Lifih|Cτh+O(h2), (7)\nwhere the expectation is taken over the randomness of the SG-MCMC algorithm, e.g., the randomness from stochastic gradients and the injected Gaussian noise.\nProof. Note the randomness of G̃lh comes from two sources, the injected Gaussian noise and the stochastic gradient noise. We denote the expectations with respect to these two randomness as Eζ and Eg , respectively. The whole expectation thus can be decomposed as E = EζEg .\nApplying the Lipschitz property of G̃lh, we have∥∥∥E(G̃(l−τl)h − G̃lh)∥∥∥ = ∥∥Eζ (G(l−τl)h −Glh)∥∥ ≤ Eζ\n∥∥(G(l−τl)h −Glh)∥∥ ≤ CEζ\n∥∥(θ(l−τl)h − θlh)∥∥ ≤ CEζ ∥∥∥∥∥ l−1∑\ni=l−τl\n( θ(ih) − θ(i+1)h )∥∥∥∥∥ ≤ C\nl−1∑ i=l−τl Eζ ∥∥(θ(ih) − θ(i+1)h)∥∥\n≤ C l−1∑\ni=l−τl\nEζ ∥∥x(i+1)h−xih∥∥\nFrom the definition of Kth-order integrator, i.e., Eζf(xlh) = eL̃lhf(x(l−1)h) +O(hK+1), if we let\nf(xlh) = ∥∥xlh−x(l−1)h∥∥ , flh ,\nwhere x(l−1)h is the starting point in the l-th iteration, and note that\nf(x(l−1)h) = 0 .\nWe have\nC l−1∑ i=l−τl Eζ ∥∥x(i+1)h−xih∥∥ , C l−1∑ i=l−τl Eζf(xlh) (8)\n≤C l−1∑\ni=l−τl\n( eLihf(x(i−1)h) +O(h K+1) )\n(9)\n≤C l−1∑\ni=l−τl\n|Lifih|h+O(h2) (10)\n≤ l−1max i=l−τl |Lifih|Cτh+O(h2) ,\nwhere (10) is obtained by expanding the exponential operator and the assumption that the high order terms are bounded.\nNow we proceed to prove Theorem 2. The basic technique follows [17], thus we skip some derivations for some steps.\nProof of Theorem 2. Before the proof, let us first define some notation. First, define the operator ∆Vl for each l as a differential operator as for any function ψ:\n∆Vlψ , ( G̃l−τl −Gl ) · ∇pψ .\nSecond, define the local generator, L̃l, for an Itô diffusion, where the true gradient in (1) is replaced with the stochastic gradient from the l-th iteration, i.e., L̃lf(Xt) ,(\nF̃l(xt) · ∇+ 1\n2\n( σ(xt)σ(xt) T ) :∇∇T ) f(xt) ,\nfor a compactly supported twice differentiable function f , where F̃l is the same as F but with the full gradient Glh replaced with the stochastic gradient G̃lh. Based on these definitions, we have\nL̃l = L+ ∆Vl .\nFollowing [17], for an SG-MCMC with a Kth-order integrator, and a test function φ, we have: E[ψ(xlh)] = ( I + hL̃l ) ψ(x(l−1)h) (11)\n+ K∑ k=2 hk k! L̃kl ψ(x(l−1)h) +O ( hK+1 (K + 1)! L̃K+1l ψ(l−1)h ) ,\nwhere I is the identity map. Sum over l = 1, · · · , L in (11), take expectation on both sides, and use the relation L̃l = L+∆Vl to expand the first order term. We obtain\nL∑ l=1 E[ψ(xlh)] = ψ(x0) + L−1∑ l=1 E[ψ(xlh)]\n+ h L∑ l=1 E[Lψ(x(l−1)h)] + h L∑ l=1 E[∆Vlψ(x(l−1)h)]\n+ K∑ k=2 hk k! L∑ l=1 E[L̃kl ψ(x(l−1)h)]\n+O\n( hK+1\n(K + 1)! ∑ l EL̃K+1l ψ(l−1)h\n) .\nDivide both sides by Lh, use the Poisson equation (5), and reorganize terms. We have:\nE[ 1\nL ∑ l φ(xlh)− φ̄] = 1 L L∑ l=1 E[Lψ(x(l−1)h)] (12)\n= 1\nLh (E[ψ(xlh)]− ψ(x0))−\n1\nL ∑ l E[∆Vlψ(x(l−1)h)]\n− K∑ k=2 hk−1 k!L L∑ l=1 E[L̃kl ψ(x(l−1)h)] +O\n( hK\n(K + 1)!L ∑ l EL̃K+1l ψ(l−1)h\n)\nAccording to [17], the term ∑ l E[L̃ k l ψ(x(l−1)h)] is bounded by ∑ l E[L̃ k l ψ(X(l−1)h)]\n= O\n( 1\nh + hK−k+1 ∑ l EL̃K+1l ψ(l−1)h\n) , (13)\nSubstituting (13) into (12), after simplification, we have: E ( 1 L ∑ l φ(xlh)− φ̄ ) = 1\nLh (E[ψ(xlh)]− ψ(x0))︸ ︷︷ ︸\nC1\n− 1 L ∑ l\nE[∆Vlψ(x(l−1)h)]︸ ︷︷ ︸ C2\n− K∑ k=2 O\n( hk−1\nLh + hK L ∑ l 1 k! EL̃Kl ψ(l−1)h\n) +\nhK\n(K + 1)!L ∑ l EL̃K+1l ψ(l−1)h ,\nAccording to the assumption, the term C1 is bounded. For term C2, according to the Cauchy–Schwarz inequality, we have\n|C2| = 1\nL ∣∣∣∣∣∑ l E ( G̃(l−τl)h −Glh ) · E∇ψ(l−1)h ∣∣∣∣∣ ≤ 1 L ∑ l\n∣∣∣E(G̃(l−τl)h −Glh) · E∇ψ(l−1)h∣∣∣ ≤ 1 L ∑ l\n∥∥∥E(G̃(l−τl)h −Glh)∥∥∥∥∥E∇ψ(l−1)h∥∥ ≤ 1 L ∑ l\n(∥∥∥E(G̃(l−τl)h − G̃lh)∥∥∥+ ∥∥∥E(G̃lh −Glh)∥∥∥)∥∥E∇ψ(l−1)h∥∥ = 1\nL ∑ l ∥∥∥E(G̃(l−τl)h − G̃lh)∥∥∥∥∥E∇ψ(l−1)h∥∥ Applying (7) from Lemma 8, we have\n|C2| ≤ 1\nL ∑ l ( l max i=l−τl ‖Li‖ ‖E∇ψlh‖Cτlh )\n≤ max l ‖Ll‖max l ‖E∇ψlh‖Cτh .\nAs a result, collecting low order terms, the bias can be expressed as:∣∣∣Eφ̂− φ̄∣∣∣ = ∣∣∣∣∣E ( 1 L ∑ l φ(xlh)− φ̄ )∣∣∣∣∣ =\n∣∣∣∣∣C1Lh − C2 + hK K∑ k=1\n1\n(k + 1)!L ∑ l EL̃k+1l ψ(l−1)h ∣∣∣∣∣ . (14)\nAs a result, there exists some constant D1 independent of (L, h, τ), such that∣∣∣Eφ̂− φ̄∣∣∣ ≤ D1 ∣∣∣∣ 1Lh ∣∣∣∣+ |C2|+ ∣∣M1τh+ ∣∣M2hK∣∣∣∣ (15)\n=D1\n( 1\nLh +M1τh+M2h\nK ) ,\nwhere M1 , maxl ‖Ll‖maxl ‖E∇ψlh‖C, M2 , ∑K k=1 1 (k+1)!L ∑ l EL̃ k+1\nl ψ(l−1)h. (15) follows by substituting the inequality for C2 above. This completes the proof."
    }, {
      "heading" : "E Proof of Theorem 3",
      "text" : "Proof. Similar to the proof of Theorem 2, we first expand Eψlh using the property of Kth-order integrator as\nL∑ l=1 E (ψ(xlh)) = L∑ l=1 ψ(x(l−1)h) + h L∑ l=1 Lψ(x(l−1)h)\n+ h L∑ l=1 ∆Vlψ(x(l−1)h) + K∑ k=2 hk k! L∑ l=1 L̃kl ψ(x(l−1)h)\n+O\n( hK+1\n(K + 1)! ∑ l L̃K+1l ψ(l−1)h\n) .\nSubstituting the Poisson equation (5) into the above equation, dividing both sides by Lh and rearranging related terms arrives\nφ̂−φ̄ = 1 Lh (Eψ(xLh)− ψ(x0)) (16)\n− 1 Lh L∑ l=1 ( Eψ(l−1)h − ψ(l−1)h ) − 1 L L∑ l=1 ∆Vlψ(l−1)h\n− K∑ k=2 hk−1 2L L∑ l=1 L̃kl ψ(x(l−1)h) +O\n( hK\nL(K + 1)! ∑ l L̃K+1l ψ(l−1)h ) Taking square on both sides, we have there exists some positive constant D, such that\n( φ̂− φ̄ )2 ≤ D  (EψLh − ψ0) 2\nL2h2︸ ︷︷ ︸ A1\n+ 1\nL2h2 L∑ l=1 ( Eψ(l−1)h − ψ(l−1)h )2 ︸ ︷︷ ︸\nA2\n+\n( 1\nL L∑ l=1 ∆Vlψ(l−1)h )2 ︸ ︷︷ ︸\nA3\n+ K∑ k=2 h2(k−1) k!L2 ( L∑ l=1 L̃kl ψ(l−1)h )2 ︸ ︷︷ ︸\nA4\n+\n(∑ l L̃ K+1 l ψ(l−1)h\nL(K + 1)! )2 h2K︸ ︷︷ ︸\nA5\n (17)\nAfter taking expectation, we have E ( φ̂− φ̄ )2 ≤ C (EA1 + EA2 + EA3 + EA4 + EA5)\nA1 is easily bounded by the assumption that ‖ψ‖ ≤ V p0 <∞. From the proof of Theorem 3 in [17], A2 and A4 are also bounded, which are summarized in Lemma 9.\nLemma 9. The terms EA2 and EA4 are bounded by: EA2 = O ( 1\nLh ) EA4 = O ( 1\nLh + h2K K∑ k=2 1 Lk! ∑ l L̃k+1l ψ(l−1)h\n) .\nWe are left to show a bound for EA3. First we have\nEA3 = E\n( 1\nL L∑ l=1 ∆Vlψ(l−1)h\n)2\n=E\n( 1\nL L∑ l=1 ( G̃(l−τl)h −Glh ) · ∇pψ(l−1)h\n)2\n= 1\nL2 L∑ i=1 L∑ j=1 E [( G̃(i−τi)h −Gih ) · ∇pψ(i−1)h ( G̃(j−τj)h −Gjh ) · ∇pψ(j−1)h ] Using the Cauchy–Schwartz inequality, we have\n≤ 1 L2 L∑ i=1 L∑ j=1 ∥∥∥E(G̃(i−τi)h −Gih)∥∥∥∥∥∥E(G̃(j−τj)h −Gjh)∥∥∥∥∥E∇ψ(i−1)h∥∥ ∥∥E∇ψ(j−1)h∥∥ ≤ 1 L2 L∑ i=1 L∑ j=1\n(∥∥∥E(G̃(i−τi)h − G̃ih)∥∥∥+ ∥∥∥E(G̃ih −Gih)∥∥∥)(∥∥∥E(G̃(j−τj)h − G̃jh)∥∥∥+ ∥∥∥E(G̃jh −Gjh)∥∥∥)∥∥E∇ψ(i−1)h∥∥ ∥∥E∇ψ(j−1)h∥∥ = 1\nL2 L∑ i=1 L∑ j=1 ∥∥∥E(G̃(i−τi)h − G̃ih)∥∥∥∥∥∥E(G̃(j−τj)h − G̃jh)∥∥∥∥∥E∇ψ(i−1)h∥∥ ∥∥E∇ψ(j−1)h∥∥ Applying (7) from Lemma 8, we have\nEA3 ≤ max l ‖E∇ψlh‖2 max l (Llflh)2 C2τ2h2 .\nCollecting low order terms from the above bounds, we have there exists some constantD2 independent of (L, h, τ), such that\nE ( φ̂− φ̄ )2 ≤C1 Lh + C2h 2K + max l ‖E∇ψlh‖2 max l ‖Ll‖2 C2τ2h2\n≤D2 ( 1\nLh + M̃1τ\n2h2 + M̃2h 2K ) ,\nwhere M̃1 , maxl ‖E∇ψlh‖2 maxl (Llflh)2 C2, M̃2 , E ( 1 L(K+1)! ∑ l L̃ K+1 l ψ(l−1)h )2 . This completes the proof."
    }, {
      "heading" : "F Proof of Theorem 4",
      "text" : "In the proof, we will use the following simple result stated Lemma 10. Lemma 10. Let (M1, · · · ,MN ) be a set of independent martingale, i.e, E [Mn|F ] = 0, where F is the filtration generated byMn. Then we have\nE ( N∑ n=1 Mn )2 |F  = N∑ n=1 E [ M2n|F ] . (18)\nProof.\nE ( N∑ n=1 Mn )2 |F  = E  N∑ i=1 N∑ j=1 MiMj |F  =E\n[ N∑ i=1 M2i |F ] + ∑ i 6=j E [Mi|F ]E [Mj |F ]\n= N∑ i=1 E [ M2i |F ] .\nIn the following we will omitted the filtration F in the expectation for simplicity. We we now ready to prove Theorem 4.\nProof. By definition, we have Var ( φ̂L ) = E ( φ̂L − φ̄− ( Eφ̂L − φ̄ ))2 Substitute (12) and (16) into the above equation, we have\nφ̂L − Eφ̄ = − 1\nLh ∑ l ( Eψ(l−1)h − ψ(l−1)h ) − 1 L ∑ l (A1 − EA1)− ∑ k hk−1 k!L ∑ l (A2 − EA2)− hK (K + 1)!L ∑ l (A3 − EA3) ,\nwhere\nA1 , ∆Vlψ(l−1)h\nA2 , L̃kl ψ(l−1)h A3 , L̃K+1l ψ(l−1)h .\nTake square on both sides, following by expectation, and note that all (Ai − EAi) are martingale for i = 1, 2, 3, which allows us to use (18) from Lemma 10. We have there exists a constant D independent of (L, h, τ), such that\nVar ( φ̂L ) ≤ D  1 L2h2 E (∑ l ( Eψ(l−1)h − ψ(l−1)h ))2\n+ 1\nL2 ∑ l E (A1 − EA1)2 + ∑ k h2(k−1) (k!L)2 ∑ l E (A2 − EA2)2\n+ h2K\n((K + 1)!L)2 ∑ l\nE (A3 − EA3)2 )\n≤ D  1L2h2E (∑\nl\n( Eψ(l−1)h − ψ(l−1)h ))2 ︸ ︷︷ ︸\nB1\n+ 1\nL2 ∑ l E (A1 − EA1)2 + K∑ k=2 h2(k−1) (k!L)2 ∑ l EA22 + h2K ((K + 1)!L)2 ∑ l EA23\n) .\nAccording to Lemma 9, B1 is bounded by\nB1 = O\n( 1\nLh\n) .\nFurthermore, according to the assumptions, both EA22 and EA23 are bounded. The delayed parameter τ exists in E (A1 − EA1)2, we have\nE (A1 − EA1)2 =E ( ∆Vlψ(l−1)h − E∆Vlψ(l−1)h )2 =E (( G̃(l−τl)h −Glh ) · ∇pψ(l−1)h − E ( G̃(l−τl)h −Glh ) · ∇pψ(l−1)h\n)2 Expanding the terms, we have there exists a constant D1 such that\nE (A1 − EA1)2 ≤D1E ( G̃(l−τl)h · ∇pψ(l−1)h − EG̃(l−τl)h · ∇pψ(l−1)h )2 +D1E ( Glh · ∇pψ(l−1)h − EGlh · ∇pψ(l−1)h\n)2 =D1E ( G̃(l−τl)h · ∇pψ(l−1)h )2 +D1E ( Glh · ( ∇pψ(l−1)h −∇pψ(l−1)h\n))2 ≤D1 ( E ∥∥∥G̃(l−τl)h∥∥∥2 E∥∥∇pψ(l−1)h∥∥2 + E ‖Glh‖2 E∥∥∇pψ(l−1)h −∇pψ(l−1)h∥∥2)\n≤D1 sup l\n{ E ∥∥∥G̃lh∥∥∥2 E ‖∇pψlh‖2 + E ‖Glh‖2 E ‖∇pψlh‖2} .\nAccording to the assumptions, the above bound is bounded, and does not depend on τ . As a result,\n1\nL2 ∑ l E (A1 − EA1)2 ≤ D1 L .\nIn addition, the bounds for both EA22 and EA23 are given in Lemma 9, which are higher-order terms with respect to h, i.e., O ( h2K ) .\nCollecting low order terms, we have there exists a constant D independent of (L, h, τ), such that the variance is bounded by:\nVar ( φ̂L ) ≤ D ( 1\nLh + h2K\n) = D ( 1\nWL̄h + h2K\n) ."
    }, {
      "heading" : "G Proof of Theorem 6",
      "text" : "We separate the proof for the bias and MSE, respectively.\nProof for the bias. According to the definition of φ̂SL, we have\n∣∣∣Eφ̂SL − φ̄∣∣∣ = ∣∣∣∣∣E S∑ s=1 Ts T φ̂Ls − φ̄ ∣∣∣∣∣ =\n∣∣∣∣∣ S∑ s=1 Ts T E ( φ̂Ls − φ̄ )∣∣∣∣∣ ≤\nS∑ s=1 Ts T ∣∣∣Eφ̂Ls − φ̄∣∣∣ =\nS∑ s=1 Ts T D1 ( 1 Lshs + ( M1τhs +M2h K s )) (19)\n=D1\n( S\nT + S∑ s=1 Ts T ( M1τhs +M2h K s\n))\n≤D1 ( S\nT + STm T\n( M1τhm +M2h K m )) , (20)\nwhere Tm , maxl Tl, hm , maxl hl, (19) follows by substituting the bias from Theorem 2 for each server into the formula.\nSimilarly, for the MSE bound, we have\nE ( φ̂SL − φ̄ )2 = E ( S∑ s=1 Ts T ( φ̂Ls − φ̄ ))2\n= S∑ s=1 T 2s T 2 E ( φ̂Ls − φ̄ )2 + ∑ i 6=j TiTj T2 E [ φ̂Li − φ̄ ] E [ φ̂Lj − φ̄ ] ≤ S∑ s=1 T 2s T 2 E ( φ̂Ls − φ̄ )2 + ∑ i 6=j TiTj T 2\n∣∣∣Eφ̂Li − φ̄∣∣∣ ∣∣∣Eφ̂Lj − φ̄∣∣∣ . Substituting the bounds for single chain bias and MSE from Theorem 2 and Theorem 3, respectively, we have\n≤ S∑ s=1 T 2s T 2 D′2 ( 1 Ts + ( M̃1τ 2h2s + M̃2h 2K s )) + ∑ i 6=j TiTj T 2 D1 ( 1 Ti + ( M1τhi +M2h K i )) D1 ( 1 Tj + ( M1τhj +M2h K j ))\n≤D2  1 T + S2 − S T 2 + ∑ i,j TiTj T 2 ( M21 τ 2h2m +M 2 2h 2K m ) ≤D2 ( 1\nT + S2 − S T 2 + S2T 2m T 2\n( M21 τ 2h2m +M 2 2h 2K m )) ,\nwhere D2 = max{D′2, D21}, Tm , maxl Tl, hm , maxl hl, the last equality collects the low order terms. This completes the proof."
    }, {
      "heading" : "H Proof of Theorem 7",
      "text" : "Proof. Following the proof of Theorem 6, for the variance, we have\nE ( φ̂SL − Eφ̂ )2 = E ( S∑ s=1 Ts T ( φ̂Ls − Eφ̂Ls ))2\n= S∑ s=1 T 2s T 2 E ( φ̂Ls − φ̄Ls )2 + ∑ i 6=j TiTj T2 E [ φ̂Li − Eφ̂Li ] E [ φ̂Lj − Eφ̂Lj ]\n= S∑ s=1 T 2s T 2 E ( φ̂Ls − φ̄Ls )2 .\nSubstituting the variance bound in Theorem 4 for each server, we have\nE ( φ̂SL − Eφ̂ )2 ≤ D S∑ s=1 T 2s T 2 ( 1 Lshs + h2Ks )\n=D S∑ s=1 ( Ts T 2 + T 2s T 2 h2Ks )\n=D\n( 1\nT + S∑ s=1 T 2s T 2 h2Ks\n)"
    }, {
      "heading" : "I Additional Results",
      "text" : "See Figure 6 7 8 9 10 11. The content of the figures is described in the titles."
    } ],
    "references" : [ {
      "title" : "Online algorithms and stochastic approximations",
      "author" : [ "L. Bottou", "editor" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1998
    }, {
      "title" : "Stochastic gradient descent tricks",
      "author" : [ "L. Bottou" ],
      "venue" : "Technical report, Microsoft Research, Redmond, WA,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Bayesian learning via stochastic gradient Langevin dynamics",
      "author" : [ "M. Welling", "Y.W. Teh" ],
      "venue" : "ICML,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Stochastic gradient Hamiltonian Monte Carlo",
      "author" : [ "T. Chen", "E.B. Fox", "C. Guestrin" ],
      "venue" : "ICML,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Bayesian sampling using stochastic gradient thermostats",
      "author" : [ "N. Ding", "Y. Fang", "R. Babbush", "C. Chen", "R.D. Skeel", "H. Neven" ],
      "venue" : "NIPS,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Distributed delayed stochastic optimization",
      "author" : [ "A. Agarwal", "J.C. Duchi" ],
      "venue" : "NIPS,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Large scale distributed deep networks",
      "author" : [ "J. Dean" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2012
    }, {
      "title" : "MXNet: A flexible and efficient machine learning library for heterogeneous distributed systems",
      "author" : [ "T. Chen" ],
      "venue" : null,
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2015
    }, {
      "title" : "TensorFlow: Large-scale machine learning",
      "author" : [ "M. Abadi" ],
      "venue" : "on heterogeneous systems,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2015
    }, {
      "title" : "More effective distributed ML via a stale synchronous parallel parameter server",
      "author" : [ "Q. Ho", "J. Cipar", "H. Cui", "J.K. Kim", "S. Lee", "P.B. Gibbons", "G.A. Gibbons", "G.R. Ganger", "E.P. Xing" ],
      "venue" : "NIPS,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Communication efficient distributed machine learning with the parameter server",
      "author" : [ "M. Li", "D. Andersen", "A. Smola", "K. Yu" ],
      "venue" : "NIPS,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Asynchronous parallel stochastic gradient for nonconvex optimization",
      "author" : [ "X. Lian", "Y. Huang", "Y. Li", "J. Liu" ],
      "venue" : "NIPS,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Scalable inference in latent variable models",
      "author" : [ "A. Ahmed", "M. Aly", "J. Gonzalez", "S. Narayanamurthy", "A.J. Smola" ],
      "venue" : "WSDM,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Distributed stochastic gradient MCMC",
      "author" : [ "S. Ahn", "B. Shahbaba", "M. Welling" ],
      "venue" : "ICML,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Large-scale distributed Bayesian matrix factorization using stochastic gradient MCMC",
      "author" : [ "S. Ahn", "A. Korattikara", "N. Liu", "S. Rajan", "M. Welling" ],
      "venue" : "KDD,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Parallel stochastic gradient Markov chain Monte Carlo for matrix factorisation models",
      "author" : [ "U. Simsekli", "H. Koptagel", "Guldas H", "A.Y. Cemgil", "F. Oztoprak", "S. Birbil" ],
      "venue" : "Technical report,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2015
    }, {
      "title" : "On the convergence of stochastic gradient MCMC algorithms with high-order integrators",
      "author" : [ "C. Chen", "N. Ding", "L. Carin" ],
      "venue" : "NIPS,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Hogwild!: A lock-free approach to parallelizing stochastic gradient descent",
      "author" : [ "F. Niu", "B. Recht", "C. Ré", "S.J. Wright" ],
      "venue" : "NIPS,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "An asynchronous mini-batch algorithm for regularised stochastic optimization",
      "author" : [ "H.R. Feyzmahdavian", "A. Aytekin", "M. Johansson" ],
      "venue" : "Technical Report arXiv:1505.04824, May",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Asynchronous stochastic convex optimization: the noise is in the noise and SGD don’t care",
      "author" : [ "S. Chaturapruek", "J.C. Duchi", "C. Ré" ],
      "venue" : "NIPS,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Bayes and big data: The consensus Monte Carlo algorithm",
      "author" : [ "S.L. Scott", "A.W. Blocker", "F.V. Bonassi" ],
      "venue" : "Bayes 250,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Variational consensus Monte Carlo",
      "author" : [ "M. Rabinovich", "E. Angelino", "M.I. Jordan" ],
      "venue" : "NIPS,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Asymptotically exact, embarrassingly parallel MCMC",
      "author" : [ "W. Neiswanger", "C. Wang", "E.P. Xing" ],
      "venue" : "UAI,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Parallelizing MCMC with random partition trees",
      "author" : [ "X. Wang", "F. Guo", "K. Heller", "D. Dunson" ],
      "venue" : "NIPS,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Construction of numerical time-average and stationary measures via Poisson equations",
      "author" : [ "J.C. Mattingly", "A.M. Stuart", "M.V. Tretyakov" ],
      "venue" : "SIAM Journal on Numerical Analysis, 48(2):552–577,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "A complete recipe for stochastic gradient MCMC",
      "author" : [ "Y.A. Ma", "T. Chen", "E.B. Fox" ],
      "venue" : "NIPS,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Stochastic gradient Riemannian Langevin dynamics on the probability simplex",
      "author" : [ "S. Patterson", "Y.W. Teh" ],
      "venue" : "NIPS,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Preconditioned stochastic gradient Langevin dynamics for deep neural networks",
      "author" : [ "C. Li", "C. Chen", "D. Carlson", "L. Carin" ],
      "venue" : "AAAI,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Deep learning with elastic averaging SGD",
      "author" : [ "S. Zhang", "A.E. Choromanska", "Y. Lecun" ],
      "venue" : "NIPS,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Distributed Bayesian learning with stochastic natural-gradient expectation propagation and the posterior server",
      "author" : [ "Y.W. Teh", "L. Hasenclever", "T. Lienart", "S. Vollmer", "S. Webb", "B. Lakshminarayanan", "C. Blundell" ],
      "venue" : "Technical Report arXiv:1512.09327v1, December",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "On Markov chain Monte Carlo methods for tall data",
      "author" : [ "R. Bardenet", "A. Doucet", "C. Holmes" ],
      "venue" : "Technical Report arXiv:1505.02827, May",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Caffe: Convolutional architecture for fast feature embedding",
      "author" : [ "T. Jia", "E. Shelhamer", "J. Donahue", "S. Karayev", "J. Long", "R. Girshick", "S. Guadarrama", "T. Darrell" ],
      "venue" : "arXiv preprint arXiv:1408.5093,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Weight uncertainty in neural networks",
      "author" : [ "C. Blundell", "J. Cornebise", "K. Kavukcuoglu", "D. Wierstra" ],
      "venue" : "ICML,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "A. Krizhevshy", "I. Sutskever", "G.E. Hinton" ],
      "venue" : "NIPS,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Non-)asymptotic properties of stochastic gradient Langevin dynamics",
      "author" : [ "S.J. Vollmer", "K.C. Zygalakis", "Y.W. Teh" ],
      "venue" : "Technical Report arXiv:1501.00438, University of Oxford, UK, January",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "A basic technique is to adopt stochastic optimization algorithms [1], e.",
      "startOffset" : 65,
      "endOffset" : 68
    }, {
      "referenceID" : 1,
      "context" : ", stochastic gradient descent and its extensions [2].",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 0,
      "context" : "Under certain conditions, stochastic optimization is guaranteed to converge to a (local) optima [1].",
      "startOffset" : 96,
      "endOffset" : 99
    }, {
      "referenceID" : 2,
      "context" : "Because of its scalability, the minibatch strategy has recently been extended to Markov Chain Monte Carlo (MCMC) Bayesian sampling methods, yielding SG-MCMC [3, 4, 5].",
      "startOffset" : 157,
      "endOffset" : 166
    }, {
      "referenceID" : 3,
      "context" : "Because of its scalability, the minibatch strategy has recently been extended to Markov Chain Monte Carlo (MCMC) Bayesian sampling methods, yielding SG-MCMC [3, 4, 5].",
      "startOffset" : 157,
      "endOffset" : 166
    }, {
      "referenceID" : 4,
      "context" : "Because of its scalability, the minibatch strategy has recently been extended to Markov Chain Monte Carlo (MCMC) Bayesian sampling methods, yielding SG-MCMC [3, 4, 5].",
      "startOffset" : 157,
      "endOffset" : 166
    }, {
      "referenceID" : 5,
      "context" : "In order to handle large-scale data, distributed stochastic optimization algorithms have been developed, for example [6], to further improve scalability.",
      "startOffset" : 117,
      "endOffset" : 120
    }, {
      "referenceID" : 6,
      "context" : "In a distributed setting, a cluster of machines with multiple cores cooperate with each other, typically through an asynchronous scheme, for scalability [7, 8, 9].",
      "startOffset" : 153,
      "endOffset" : 162
    }, {
      "referenceID" : 7,
      "context" : "In a distributed setting, a cluster of machines with multiple cores cooperate with each other, typically through an asynchronous scheme, for scalability [7, 8, 9].",
      "startOffset" : 153,
      "endOffset" : 162
    }, {
      "referenceID" : 8,
      "context" : "In a distributed setting, a cluster of machines with multiple cores cooperate with each other, typically through an asynchronous scheme, for scalability [7, 8, 9].",
      "startOffset" : 153,
      "endOffset" : 162
    }, {
      "referenceID" : 9,
      "context" : "While some theory has been developed to guarantee the convergence of stochastic optimization with stale gradients [10, 11, 12], little analysis has been done in a Bayesian setting, where SG-MCMC is applied.",
      "startOffset" : 114,
      "endOffset" : 126
    }, {
      "referenceID" : 10,
      "context" : "While some theory has been developed to guarantee the convergence of stochastic optimization with stale gradients [10, 11, 12], little analysis has been done in a Bayesian setting, where SG-MCMC is applied.",
      "startOffset" : 114,
      "endOffset" : 126
    }, {
      "referenceID" : 11,
      "context" : "While some theory has been developed to guarantee the convergence of stochastic optimization with stale gradients [10, 11, 12], little analysis has been done in a Bayesian setting, where SG-MCMC is applied.",
      "startOffset" : 114,
      "endOffset" : 126
    }, {
      "referenceID" : 12,
      "context" : "methods, such as [13], usually employ stale statistics instead of stale gradients, where stale statistics are summarized based on outdated parameters, e.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 12,
      "context" : ", outdated topic distributions in distributed Gibbs sampling [13].",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 13,
      "context" : "For existing distributed SG-MCMC methods, typically only standard stochastic gradients are used, for limited problems such as matrix factorization, without rigorous convergence theory [14, 15, 16].",
      "startOffset" : 184,
      "endOffset" : 196
    }, {
      "referenceID" : 14,
      "context" : "For existing distributed SG-MCMC methods, typically only standard stochastic gradients are used, for limited problems such as matrix factorization, without rigorous convergence theory [14, 15, 16].",
      "startOffset" : 184,
      "endOffset" : 196
    }, {
      "referenceID" : 15,
      "context" : "For existing distributed SG-MCMC methods, typically only standard stochastic gradients are used, for limited problems such as matrix factorization, without rigorous convergence theory [14, 15, 16].",
      "startOffset" : 184,
      "endOffset" : 196
    }, {
      "referenceID" : 16,
      "context" : "In this paper, by extending techniques from standard SG-MCMC [17], we develop theory to study the convergence behavior of SG-MCMC with Stale gradients (SG-MCMC).",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 5,
      "context" : "Representative algorithms include, but are not limited to, the ASYSG-CON [6] and HOGWILD! algorithms [18], and some more recent developments [19, 20].",
      "startOffset" : 73,
      "endOffset" : 76
    }, {
      "referenceID" : 17,
      "context" : "Representative algorithms include, but are not limited to, the ASYSG-CON [6] and HOGWILD! algorithms [18], and some more recent developments [19, 20].",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 18,
      "context" : "Representative algorithms include, but are not limited to, the ASYSG-CON [6] and HOGWILD! algorithms [18], and some more recent developments [19, 20].",
      "startOffset" : 141,
      "endOffset" : 149
    }, {
      "referenceID" : 19,
      "context" : "Representative algorithms include, but are not limited to, the ASYSG-CON [6] and HOGWILD! algorithms [18], and some more recent developments [19, 20].",
      "startOffset" : 141,
      "endOffset" : 149
    }, {
      "referenceID" : 11,
      "context" : "Furthermore, recent research on stochastic optimization has been extended to non-convex problems with provable convergence rates [12].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 20,
      "context" : "In Bayesian learning with MCMC, existing work has focused on running parallel chains on subsets of data [21, 22, 23, 24], and little if any effort has been made to use stale stochastic gradients, the setting considered in this paper.",
      "startOffset" : 104,
      "endOffset" : 120
    }, {
      "referenceID" : 21,
      "context" : "In Bayesian learning with MCMC, existing work has focused on running parallel chains on subsets of data [21, 22, 23, 24], and little if any effort has been made to use stale stochastic gradients, the setting considered in this paper.",
      "startOffset" : 104,
      "endOffset" : 120
    }, {
      "referenceID" : 22,
      "context" : "In Bayesian learning with MCMC, existing work has focused on running parallel chains on subsets of data [21, 22, 23, 24], and little if any effort has been made to use stale stochastic gradients, the setting considered in this paper.",
      "startOffset" : 104,
      "endOffset" : 120
    }, {
      "referenceID" : 23,
      "context" : "In Bayesian learning with MCMC, existing work has focused on running parallel chains on subsets of data [21, 22, 23, 24], and little if any effort has been made to use stale stochastic gradients, the setting considered in this paper.",
      "startOffset" : 104,
      "endOffset" : 120
    }, {
      "referenceID" : 16,
      "context" : "In the analysis we consider algorithms with fixed-stepsizes for simplicity; decreasingstepsize variants can be addressed similarly as in [17].",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 24,
      "context" : "SG-MCMC algorithms are based on a class of stochastic differential equations, called Itô diffusion, defined as d xt = F (xt)dt+ g(xt)dwt , (1) where x ∈ R represents the model states, typically x augments θ such that θ ⊆ x and n ≤ m; t is the time index, wt ∈ R is m-dimensional Brownian motion, functions F : R → R and g : R → Rm×m are assumed to satisfy the usual Lipschitz continuity condition [25].",
      "startOffset" : 397,
      "endOffset" : 401
    }, {
      "referenceID" : 25,
      "context" : "For appropriate functions F and g, the stationary distribution, ρ(x), of the Itô diffusion (1) has a marginal distribution equal to the posterior distribution p(θ|D) [26].",
      "startOffset" : 166,
      "endOffset" : 170
    }, {
      "referenceID" : 2,
      "context" : "For example, denoting the unnormalized negative log-posterior as U(θ) , − log p(θ) − ∑N i=1 log p(di |θ), the stochastic gradient Langevin dynamic (SGLD) method [3] is based on 1st-order Langevin dynamics, with x = θ, and F (xt) = −∇θU(θ), g(xt) = √ 2 In, where In is the n × n identity matrix.",
      "startOffset" : 161,
      "endOffset" : 164
    }, {
      "referenceID" : 3,
      "context" : "The stochastic gradient Hamiltonian Monte Carlo (SGHMC) method [4] is based on 2nd-order Langevin dynamics, with x = (θ,q), and F (xt) = ( q −B q−∇θU(θ) ) , g(xt) = √ 2B ( 0 0 0 In ) for a scalar B > 0; q is an auxiliary variable known as the momentum [4, 5].",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 3,
      "context" : "The stochastic gradient Hamiltonian Monte Carlo (SGHMC) method [4] is based on 2nd-order Langevin dynamics, with x = (θ,q), and F (xt) = ( q −B q−∇θU(θ) ) , g(xt) = √ 2B ( 0 0 0 In ) for a scalar B > 0; q is an auxiliary variable known as the momentum [4, 5].",
      "startOffset" : 252,
      "endOffset" : 258
    }, {
      "referenceID" : 4,
      "context" : "The stochastic gradient Hamiltonian Monte Carlo (SGHMC) method [4] is based on 2nd-order Langevin dynamics, with x = (θ,q), and F (xt) = ( q −B q−∇θU(θ) ) , g(xt) = √ 2B ( 0 0 0 In ) for a scalar B > 0; q is an auxiliary variable known as the momentum [4, 5].",
      "startOffset" : 252,
      "endOffset" : 258
    }, {
      "referenceID" : 4,
      "context" : "SG-MCMC algorithms, such as the stochastic gradient thermostat [5] and variants with Riemannian information geometry [27, 26, 28], are defined similarly.",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 26,
      "context" : "SG-MCMC algorithms, such as the stochastic gradient thermostat [5] and variants with Riemannian information geometry [27, 26, 28], are defined similarly.",
      "startOffset" : 117,
      "endOffset" : 129
    }, {
      "referenceID" : 25,
      "context" : "SG-MCMC algorithms, such as the stochastic gradient thermostat [5] and variants with Riemannian information geometry [27, 26, 28], are defined similarly.",
      "startOffset" : 117,
      "endOffset" : 129
    }, {
      "referenceID" : 27,
      "context" : "SG-MCMC algorithms, such as the stochastic gradient thermostat [5] and variants with Riemannian information geometry [27, 26, 28], are defined similarly.",
      "startOffset" : 117,
      "endOffset" : 129
    }, {
      "referenceID" : 6,
      "context" : "3 Stochastic Gradient MCMC with Stale Gradients In this section, we extend SG-MCMC to the stale-gradient setting, commonly met in asynchronous distributed systems [7, 8, 9], and develop theory to analyze convergence properties.",
      "startOffset" : 163,
      "endOffset" : 172
    }, {
      "referenceID" : 7,
      "context" : "3 Stochastic Gradient MCMC with Stale Gradients In this section, we extend SG-MCMC to the stale-gradient setting, commonly met in asynchronous distributed systems [7, 8, 9], and develop theory to analyze convergence properties.",
      "startOffset" : 163,
      "endOffset" : 172
    }, {
      "referenceID" : 8,
      "context" : "3 Stochastic Gradient MCMC with Stale Gradients In this section, we extend SG-MCMC to the stale-gradient setting, commonly met in asynchronous distributed systems [7, 8, 9], and develop theory to analyze convergence properties.",
      "startOffset" : 163,
      "endOffset" : 172
    }, {
      "referenceID" : 16,
      "context" : "Bias and MSE In [17], the bias and MSE of the standard SG-MCMC algorithms with a Kth order integrator were analyzed, where the order of an integrator reflects how accurately an SG-MCMC algorithm approximates the corresponding continuous diffusion.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 2,
      "context" : ", the popular Euler method used in SGLD [3] is a 1st-order integrator.",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 16,
      "context" : "In particular, [17] proved the bounds stated in Lemma 1.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 16,
      "context" : "Lemma 1 ([17]).",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 16,
      "context" : "In addition to the assumptions in SG-MCMC [17] (see details in Appendix B), the following additional assumption is imposed.",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 24,
      "context" : "∗The existence of a nice ψ is guaranteed in the elliptic/hypoelliptic SDE settings when x is on a torus [25].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 13,
      "context" : "In addition, Theorem 6 with τ = 0 and K = 1 provides convergence rates for the distributed SGLD algorithm in [14], i.",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 6,
      "context" : "More advanced architectures More complex architectures could also be designed to reduce communication cost, for example, by extending the downpour [7] and elastic SGD [29] architectures to the SG-MCMC setting.",
      "startOffset" : 147,
      "endOffset" : 150
    }, {
      "referenceID" : 28,
      "context" : "More advanced architectures More complex architectures could also be designed to reduce communication cost, for example, by extending the downpour [7] and elastic SGD [29] architectures to the SG-MCMC setting.",
      "startOffset" : 167,
      "endOffset" : 171
    }, {
      "referenceID" : 29,
      "context" : "5 Experiments Our primal goal is to validate the theory, comparing with different distributed architectures and algorithms, such as [30, 31], is beyond the scope of this paper.",
      "startOffset" : 132,
      "endOffset" : 140
    }, {
      "referenceID" : 30,
      "context" : "5 Experiments Our primal goal is to validate the theory, comparing with different distributed architectures and algorithms, such as [30, 31], is beyond the scope of this paper.",
      "startOffset" : 132,
      "endOffset" : 140
    }, {
      "referenceID" : 11,
      "context" : "To quantitatively describe the speedup property, we adopt the the iteration speedup [12], defined as: iteration speedup , #iterations with a single worker average #iterations on a worker , where # is the iteration count when the same level of precision is achieved.",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 31,
      "context" : "The distributed system is developed based on an MPI (message passing interface) extension of the popular Caffe package for deep learning [32].",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 32,
      "context" : "In all these models, zero mean and unit variance Gaussian priors are employed for the weights to capture weight uncertainties, an effective way to deal with overfitting [33].",
      "startOffset" : 169,
      "endOffset" : 173
    }, {
      "referenceID" : 33,
      "context" : "LeNet consists of 2 convolutional layers, 2 max pool layers and 2 ReLU nonlinear layers, followed by 2 fully connected layers [34].",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 0,
      "context" : "References [1] L.",
      "startOffset" : 11,
      "endOffset" : 14
    }, {
      "referenceID" : 1,
      "context" : "[2] L.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "[3] M.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 3,
      "context" : "[4] T.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5] N.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "[6] A.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "[7] J.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "[8] T.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "[9] M.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 9,
      "context" : "[10] Q.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[11] M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "[12] X.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "[13] A.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 13,
      "context" : "[14] S.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 14,
      "context" : "[15] S.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 15,
      "context" : "[16] U.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "[17] C.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 17,
      "context" : "[18] F.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "[19] H.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "[20] S.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "[21] S.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 21,
      "context" : "[22] M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 22,
      "context" : "[23] W.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "[24] X.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 24,
      "context" : "[25] J.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 25,
      "context" : "[26] Y.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 26,
      "context" : "[27] S.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 27,
      "context" : "[28] C.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 28,
      "context" : "[29] S.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 29,
      "context" : "[30] Y.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 30,
      "context" : "[31] R.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 31,
      "context" : "[32] T.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 32,
      "context" : "[33] C.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 33,
      "context" : "[34] A.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 34,
      "context" : "[35] S.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 24,
      "context" : "B Assumptions First, following [25], we will need to assume the corresponding SDE of SG-MCMC to be either elliptic or hypoelliptic.",
      "startOffset" : 31,
      "endOffset" : 35
    }, {
      "referenceID" : 34,
      "context" : "Note (5) can be equivalently written in an integration form [35] using Itô’s formula: 1 t ∫ t",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 24,
      "context" : "This is satisfied if the SDE is defined in a bounded domain [25].",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 16,
      "context" : "In the unbounded domain as for SG-MCMC algorithms, it turns out the following boundedness assumptions on ψ suffice [17].",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 24,
      "context" : "For other SG-MCMC algorithms such as the SGHMC, the hypoellipticity assumption is usually reasonable, see [25] on how to verify hypoellipticity of an SDE.",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 34,
      "context" : "To ensure the remainder term r`,F,φ(x0) to be bounded, it suffices to make the following assumption on the smoothness and boundedness of F (x) [35, 17].",
      "startOffset" : 143,
      "endOffset" : 151
    }, {
      "referenceID" : 16,
      "context" : "To ensure the remainder term r`,F,φ(x0) to be bounded, it suffices to make the following assumption on the smoothness and boundedness of F (x) [35, 17].",
      "startOffset" : 143,
      "endOffset" : 151
    }, {
      "referenceID" : 16,
      "context" : "The basic technique follows [17], thus we skip some derivations for some steps.",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 16,
      "context" : "Following [17], for an SG-MCMC with a Kth-order integrator, and a test function φ, we have: E[ψ(xlh)] = ( I + hL̃l ) ψ(x(l−1)h) (11)",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 16,
      "context" : "According to [17], the term ∑ l E[L̃ k l ψ(x(l−1)h)] is bounded by ∑ l E[L̃ k l ψ(X(l−1)h)]",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 16,
      "context" : "From the proof of Theorem 3 in [17], A2 and A4 are also bounded, which are summarized in Lemma 9.",
      "startOffset" : 31,
      "endOffset" : 35
    } ],
    "year" : 2016,
    "abstractText" : "Stochastic gradient MCMC (SG-MCMC) has played an important role in largescale Bayesian learning, with well-developed theoretical convergence properties. In such applications of SG-MCMC, it is becoming increasingly popular to employ distributed systems, where stochastic gradients are computed based on some outdated parameters, yielding what are termed stale gradients. While stale gradients could be directly used in SG-MCMC, their impact on convergence properties has not been well studied. In this paper we develop theory to show that while the bias and MSE of an SG-MCMC algorithm depend on the staleness of stochastic gradients, its estimation variance (relative to the expected estimate, based on a prescribed number of samples) is independent of it. In a simple Bayesian distributed system with SG-MCMC, where stale gradients are computed asynchronously by a set of workers, our theory indicates a linear speedup on the decrease of estimation variance w.r.t. the number of workers. Experiments on synthetic data and deep neural networks validate our theory, demonstrating the effectiveness and scalability of SG-MCMC with stale gradients.",
    "creator" : "LaTeX with hyperref package"
  }
}