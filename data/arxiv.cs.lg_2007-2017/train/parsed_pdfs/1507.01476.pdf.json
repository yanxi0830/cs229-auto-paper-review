{
  "name" : "1507.01476.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Zaid Harchaoui" ],
    "emails" : [ "nhe6@gatech.edu", "zaid.harchaoui@inria.fr" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "A wide range of machine learning and signal processing problems can be formulated as the minimization of a composite objective:\nmin x∈X\nF (x) := f(x) + ‖Bx‖ (1)\nwhere X is closed and convex, f is convex and can be either smooth, or nonsmooth yet enjoys a particular structure. The term ‖Bx‖ defines a regularization penalty through a norm ‖ · ‖, and x 7→ Bx a linear mapping on a closed convex set X. The function f usually corresponds to an empirical risk, that is an empirical average of a possibly non-smooth loss function evaluated on a set of data-points, while x encodes the learning parameters. All in all, the objective F has a doubly non-smooth structure.\nIn many situations, the objective function F of interest enjoys a favorable structure, namely a so-called Fenchel-type representation [7, 12, 14]:\nf(x) = max z∈Z\n{〈x,Az〉 − ψ(z)} (2)\nwhere Z is convex compact subset of a Euclidean space, and ψ(·) is a convex function. Sec. 4 will give several examples of such situations. Fenchel-type representations can then be leveraged to use first-order optimisation algorithms.\n∗The authors would like to thank Anatoli Juditsky and Arkadi Nemirovski for fruitful discussions. This work was supported by the NSF Grant CMMI-1232623, the LabEx Persyval-Lab (ANR-11-LABX-0025), the project Titan (CNRS-Mastodons), the project Macaron (ANR-14-CE23-0003-01), the MSR-Inria joint centre, and the Moore-Sloan Data Science Environment at NYU.\nar X\niv :1\n50 7.\n01 47\n6v 1\n[ m\nat h.\nO C\n] 6\nJ ul\nA simple first option to minimise F is using the so-called Nesterov smoothing technique [21] along with a proximal gradient algorithm [23], assuming that the proximal operator associated with X is computationally tractable and cheap to compute. However, this is certainly not the case when considering problems with norms acting in the spectral domain of high-dimensional matrices, such as the matrix nuclear-norm [13] and structured extensions thereof [6, 2]. In the latter situation, another option is to use a smoothing technique now with a conditional gradient or Frank-Wolfe algorithm to minimize F , assuming that a a linear minimization oracle associated with X is cheaper to compute than the proximal operator [7, 15, 24]. Neither option takes advantage of the composite structure of the objective (1) or handles the case when the linear mapping B is nontrivial.\nContributions Our goal in this paper is to propose a new first-order optimization algorithm, called SemiProximal Mirror-Prox , designed to solve the difficult non-smooth composite optimisation problem (1), which does not require the exact computation of proximal operators. Instead, the Semi-Proximal Mirror-Prox relies upon i) Fenchel-type representability of f ; ii) Linear minimization oracle associated with ‖·‖ in the domain X. While the Fenchel-type representability of f allows to cure the non-smoothness of f , the linear minimisation over the domain X allows to tackle the non-smooth regularisation penalty ‖ · ‖. We establish the theoretical convergence rate of Semi-Proximal Mirror-Prox, which exhibits the optimal complexity bounds, i.e. O(1/ 2), for the number of calls to linear minimization oracle. Furthermore, Semi-Proximal Mirror-Prox generalizes previously proposed approaches and improves upon them in special cases:\n1. Case B ≡ 0: Semi-Proximal Mirror-Prox does not require assumptions on favorable geometry of dual domains Z or simplicity of ψ(·) in (2).\n2. Case B = I: Semi-Proximal Mirror-Prox is competitive with previously proposed approaches [16, 24] based on smoothing techniques.\n3. Case of non-trivial B: Semi-Proximal Mirror-Prox is the first proximal-free or conditional-gradient-type optimization algorithm for (1).\nRelated work The Semi-Proximal Mirror-Prox algorithm belongs the family of conditional gradient algorithms, whose most basic instance is the Frank-Wolfe algorithm for constrained smooth optimization using a linear minimization oracle; see [13, 1, 4]. Recently, in [7, 14], the authors consider constrained non-smooth optimisation when the domain Z has a “favorable geometry”, i.e. the domain is amenable to linear minimisation (favorable geometry), and establish a complexity bound with O(1/ 2) calls to the linear minimization oracle. Recently, in [16], a method called conditional gradient sliding is proposed to solve similar problems, using a smoothing technique, with a complexity bound in O(1/ 2) for the calls to the linear minimization oracle (LMO) and additionally a O(1/ ) bound for the linear operator evaluations. Actually, this O(1/ 2) bound for the LMO complexity can be shown to be indeed optimal for conditional-gradient-type or LMO-based algorithms, when solving general1 non-smooth convex problems [15].\nHowever, these previous approaches are appropriate for objective with a non-composite structure. When applied to our problem (1), the smoothing would be applied to the objective taken as a whole, ignoring its composite structure. Conditional-gradient-type algorithms were recently proposed for composite objectives [8, 10, 26, 24, 17], but cannot be applied for our problem. In [10], f is smooth and B is identity matrix, whereas in [24], f is non-smooth and B is also the identity matrix. The proposed Semi-Proximal MirrorProx can be seen as a blend of the successful components resp. of the Composite Conditional Gradient algorithm [10] and the Composite Mirror-Prox [12], that enjoys the optimal complexity bound O(1/ 2) on the total number of LMO calls, yet solves a broader class of convex problems than previously considered.\n1Related research extended such approaches to stochastic or online settings [11, 9, 16]; such settings are beyond the scope of this work.\nOutline The paper is organized as follows. In Section 2, we describe the norm-regularized nonsmooth problem of interest and illustrate it with several examples. In Section 3, we present the conditional gradient type method based on an inexact Mirror-Prox framework for structured variational inequalities. In Section 4, we present promising experimental results showing the interest of the approach in comparison to competing methods, resp. on a collaborative filtering for movie recommendation and link prediction for social network analysis applications."
    }, {
      "heading" : "2 Framework and assumptions",
      "text" : "We present here our theoretical framework, which hinges upon a smooth convex-concave saddle point reformulation of the norm-regularized non-smooth minimization (3). We shall use the following notations throughout the paper. For a given norm ‖ · ‖, we define the dual norm as ‖s‖∗ = max‖x‖≤1〈s, x〉. For any x ∈ Rm×n, ‖x‖2 = ‖x‖F = ( ∑m i=1 ∑n j=1 |xij |2)1/2.\nProblem We consider the composite minimization problem\nOpt = min x∈X\nf(x) + ‖Bx‖ (3)\nwhere X is a closed convex set in the Euclidean space Ex; x 7→ Bx is a linear mapping from X to Y (⊃ BX), where Y is a closed convex set in the Euclidean space Ey. We make two important assumptions on the function f and the norm ‖ · ‖ defining the regularization penalty, explained below.\nFenchel-type Representation The non-smoothness of f can be challenging to tackle. However, in many cases of interest, the function f enjoys a favorable structure that allows to tackle it with smoothing techniques. We assume that the norm f(x) is a non-smooth convex function given by\nf(x) = max z∈Z Φ(x, z) (4)\na where Φ(x, z) is a smooth convex-concave function and Z is a convex and compact set in the Euclidean space Ez. Such representation was introduced and developed in [7, 12, 14], for the purpose of non-smooth optimisation. Fenchel-type representability can be interpreted as a general form of the smoothing-favorable structure of non-smooth functions used in the Nesterov smoothing technique [21]. Representations of this type are readily available for a wide family of “well-structured” nonsmooth functions f ; see Sec. 4 for examples.\nComposite Linear Minimization Oracle Proximal-gradient-type algorithms require the computation of a proximal operator at each iteration, i.e.\nmin y∈Y\n{ 1\n2 ‖y‖22 + 〈η, y〉+ α‖y‖\n} . (5)\nFor several cases of interest, described below, the computation of the proximal operator can be expensive or intractable. A classical example is the nuclear norm, whose proximal operator boils down to singular value thresholding, therefore requiring a full singular value decomposition. In contrast to the proximal operator, the linear minimization oracle can much cheaper. The linear minimization oracle (LMO) is a routine which, given an input α > 0 and η ∈ Ey, returns a point\nmin y∈Y\n{〈η, y〉+ α‖y‖} (6)\nIn the case of the nuclear-norm, the LMO only requires the computation of the top pair of eigenvectors/eigenvalues, which is an order of magnitude fast in time-complexity.\nSaddle Point Reformulation. The crux of our approach is a smooth convex-concave saddle point reformulation of (3). After massaging the saddle-point reformulation, we consider the variational inequality associated with the obtained saddle-point problem. For a constrained smooth optimisation problem, the corresponding variational inequality provides the sufficient and necessary condition for an optimal solution to the problem [3, 4]. For non-smooth optimization problems, the corresponding variational inequality is directly related to the accuracy certificate used to guarantee the accuracy of a solution to the optimisation problem; see Sec. 2.1 in [12] and [19]. We shall present then an algorithm to solve the variational inequality established below, that leverages its particular structure.\nAssuming that f admits a Fenchel-type representation (4), we rewrite (3) in epigraph form\nmin x∈X,y∈Y,τ≥‖y‖ max z∈Z\n{Φ(x, z) + τ : y = Bx} ,\nwhich, with a properly selected ρ > 0, can be further approximated by\nÔpt = min x∈X,y∈Y,τ≥‖y‖ max z∈Z\n{Φ(x, z) + τ + ρ‖y − Bx‖2} (7)\n= min x∈X,y∈Y,τ≥‖y‖ max z∈Z,‖w‖2≤1\n{Φ(x, z) + τ + ρ〈y − Bx,w〉} . (8)\nIn fact, when ρ is large enough one can always guarantee Ôpt = Opt. It is indeed sufficient to set ρ as the Lipschitz constant of ‖ · ‖ with respect to ‖ · ‖2.\nIntroduce the variables u := [x, y; z, w] and v := τ . The variational inequality associated with the above saddle point problem is fully described by the domain\nX+ = {x+ = [u; v] : x ∈ X, y ∈ Y, z ∈ Z, ‖w‖2 ≤ 1, τ ≥ ‖y‖}\nand the monotone vector field F (x+ = [u; v]) = [Fu(u);Fv] ,\nwhere\nFu u =  x y z w   =  ∇xΦ(x, z)− ρBTw ρw −∇zΦ(x, z) ρ(Bx− y)  , Fv(v = τ) = 1. In the next section, we present an efficient algorithm to solve this type of variational inequality, which enjoys a particular structure; we call such an inequality semi-structured."
    }, {
      "heading" : "3 Semi-Proximal Mirror-Prox for Semi-structured Variational In-",
      "text" : "equalities\nSemi-structured variational inequalities (Semi-VI) enjoy a particular product structure, that allows to get the best of two worlds, namely the proximal setup (where the proximal operator can be computed) and the LMO setup (where the linear minimization oracle can be computed). Basically, the domain X is decomposed as a Cartesian product over two sets X = X1 ×X2, such that X1 admits a proximal-mapping while X2 admits a linear minimization oracle. We now describe the main theoretical and algorithmic components of the SemiProximal Mirror-Prox algorithm, resp. in Sec. 3.1 and in Sec. 3.2, and finally describe the overall algorithm in Sec. 3.3."
    }, {
      "heading" : "3.1 Composite Mirror-Prox with Inexact Prox-mappings",
      "text" : "We first present a new algorithm, which can be seen as an extension of the composite Mirror Prox algorithm, denoted CMP for brevity, that allows inexact computation of the Prox-mappings, and can solve a broad class of variational inequalites. The original Mirror Prox algorithm was introduced in [18], and was extended to composite minimization in [12] assuming exact computations of Prox-mappings.\nStructured Variational Inequalities. We consider the variational inequality VI(X,F ):\nFind x∗ ∈ X : 〈F (x), x− x∗〉 ≥ 0,∀x ∈ X\nwith domain X and operator F that satisfy the assumptions (A.1)–(A.4) below.\n(A.1) Set X ⊂ Eu × Ev is closed convex and its projection PX = {u : x = [u; v] ∈ X} ⊂ U , where U is convex and closed, Eu, Ev are Euclidean spaces;\n(A.2) The function ω(·) : U → R is continuously differentiable and also 1-strongly convex w.r.t. some norm2 ‖ · ‖. This defines the Bregman distance\nVu(u ′) = ω(u′)− ω(u)− 〈ω′(u), u′ − u〉 ≥ 1\n2 ‖u′ − u‖2 .\n(A.3) The operator F (x = [u, v]) : X → Eu × Ev is monotone and of form F (u, v) = [Fu(u);Fv] with Fv ∈ Ev being a constant and Fu(u) ∈ Eu satisfying the condition\n∀u, u′ ∈ U : ‖Fu(u)− Fu(u′)‖∗ ≤ L‖u− u′‖+M\nfor some L <∞,M <∞;\n(A.4) The linear form 〈Fv, v〉 of [u; v] ∈ Eu × Ev is bounded from below on X and is coercive on X w.r.t. v: whenever [ut; vt] ∈ X, t = 1, 2, ... is a sequence such that {ut}∞t=1 is bounded and ‖vt‖2 → ∞ as t→∞, we have 〈Fv, vt〉 → ∞, t→∞.\n-Prox-mapping In the Composite Mirror Prox with exact Prox-mappings [12], the quality of an iterate, in the course of the algorithm, is measured through the so-called dual gap function\nVI(x ∣∣X,F ) = sup\ny∈X 〈F (y), x− y〉 .\nWe give in Appendix A a refresher on dual gap functions, for the reader’s convenience. We shall establish the complexity bounds in terms this dual gap function for our algorithm, which directly provides an accuracy certificate along the iterations. However, we first need to define what we mean by an inexact prox-mapping. Inexact proximal mapping were recently considered in the context of accelerated proximal gradient algorithms [25]. The definition we give below is more general, allowing for non-Euclidean proximal-mappings.\nWe introduce here the notion of -prox-mapping ( ≥ 0). For ξ = [η; ζ] ∈ Eu×Ev and x = [u; v] ∈ X, let us define the subset P x(ξ) of X as\nP x(ξ) = {x̂ = [û; v̂] ∈ X : 〈η + ω′(û)− ω′(u), û− s〉+ 〈ζ, v̂ − w〉 ≤ ∀[s;w] ∈ X}.\nWhen = 0, this reduces to the exact prox-mapping, in the usual setting, that is\nPx(ξ) = Argmin [s;w]∈X\n{〈η, s〉+ 〈ζ, w〉+ Vu(s)} .\nWhen > 0, this yields our definition of an inexact prox-mapping, with inexactness parameter . Note that for any ≥ 0, the set P x(ξ = [η; γFv]) is well defined whenever γ > 0. The Composite Mirror-Prox with Inexact Prox-mappings is outlined in Algorithm 1.\n2There is a slight abuse of notation here. The norm here is not the same as the one in problem (3)\nAlgorithm 1 Composite Mirror Prox Algorithm (CMP) for VI(X,F )\nInput: stepsizes γt > 0, inexactness t ≥ 0, t = 1, 2, . . . Initialize x1 = [u1; v1] ∈ X for t = 1, 2, . . . , T do\nyt := [ût; v̂t] ∈ P txt (γtF (x t)) = P txt (γt[Fu(u t);Fv]) xt+1 := [ut+1; vt+1] ∈ P txt (γtF (y t)) = P txt (γt[Fu(û t);Fv])\n(9)\nend for Output: xT := [ūT ; v̄T ] = ( ∑T t=1 γt) −1∑T t=1 γty t\nNote that this composite version of Mirror Prox algorithm works essentially as if there were no vcomponent at all. Therefore, the proposed algorithm is a not-trivial extension of the Composite Mirror-Prox with exact prox-mappings, both from a theoretical and algorithmic point of views. We establish below the theoretical convergence rate; see Appendix for the proof.\nTheorem 3.1. Assume that the sequence of step-sizes (γt) in the CMP algorithm satisfy\nσt := γt〈Fu(ût)− Fu(ut), ût − ut+1〉 − Vût(ut+1)− Vut(ût) ≤ γ2tM2 , t = 1, 2, . . . , T . (10)\nThen, denoting Θ[X] = sup[u;v]∈X Vu1(u), for a sequence of inexact prox-mappings with inexactness t ≥ 0, we have\nVI(x̄T ∣∣X,F ) := sup\nx∈X 〈F (x), x̄T − x〉 ≤\nΘ[X] +M2 ∑T t=1γ 2 t + 2 ∑T t=1 t∑T\nt=1 γt . (11)\nRemarks Note that the assumption on the sequence of step-sizes (γt) is clearly satisfied when γt ≤ ( √ 2L)−1. When M = 0, it is satisfied as long as γt ≤ L−1.\nCorollary 3.1. Assume further that X = X1 ×X2, and let F be the monotone vector field associated with the saddle point problem\nSadVal = min x1∈X1 max x2∈X2\nΦ(x1, x2), (12)\ntwo induced convex optimization problems Opt(P ) = minx1∈X1 [ Φ(x1) = supx2∈X2 Φ(x 1, x2) ]\n(P ) Opt(D) = maxx2∈X2 [ Φ(x2) = infx1∈X1 Φ(x 1, x2) ] (D) (13)\nwith convex-concave locally Lipschitz continuous cost function Φ. In addition, assuming that problem (P ) in (13) is solvable with optimal solution x1∗ and denoting by x̄ 1 T the projection of x̄T ∈ X = X1 ×X2 onto X1, we have\nΦ(x̄1T )−Opt(P ) ≤ [∑T\nt=1 γt\n]−1 [ Θ[{x1∗} ×X2] +M2 ∑T t=1 γ2t + 2 ∑T t=1 t ] . (14)\nThe theoretical convergence rate established in Theorem 3.1 and Corollary 3.1 generalizes the previous result established in Corollary 3.1 in [12] for CMP with exact prox-mappings. Indeed, when exact proxmappings are used, we recover the result of [12]. When inexact prox-mappings are used, the errors due to the inexactness of the prox-mappings accumulates and is reflected in the bound (34) and (14)."
    }, {
      "heading" : "3.2 Composite Conditional Gradient",
      "text" : "We now turn to a variant of the composite conditional gradient algorithm, denoted CCG, tailored for a particular class of problems, which we call smooth semi-linear problems. The composite conditional gradient algorithm was introduced in [10]. We present an extension here which will turn to be especially tailored for sub-problems that will be solved in Sec. 3.3.\nMinimizing Smooth Semi-linear Problems. We consider the smooth semi-linear problem\nmin x=[u;v]∈X\n{ φ+(u, v) = φ(u) + 〈θ, v〉 } (15)\nrepresented by the pair (X;φ+) such that the following assumptions are satisfied. We assume that\ni) X ⊂ Eu × Ev is closed convex and its projection PX ⊂ U , where U is convex and compact;\nii) φ(u) : U → R be a convex continuously differentiable function, and there exists 1 < κ ≤ 2 and L < ∞ such that\nφ(u′) ≤ φ(u) + 〈∇φ(u), u′ − u〉+ L0 κ ‖u′ − u‖κ ∀u, u′ ∈ U ; (16)\niii) θ ∈ Ev be such that every linear function on Eu × Ev of the form\n[u; v] 7→ 〈η, u〉+ 〈θ, v〉 (17)\nwith η ∈ Eu attains its minimum on X at some point x[η] = [u[η]; v[η]]; we have at our disposal a Composite Linear Minimization Oracle (LMO) which, given on input η ∈ Eu, returns x[η].\nAlgorithm 2 Composite Conditional Gradient Algorithm CCG(X,φ(·), θ; ) Input: accuracy > 0 and γt = 2/(t+ 1), t = 1, 2, . . . Initialize x1 = [u1; v1] ∈ X and for t = 1, 2, . . . do\nCompute δt = 〈gt, ut − ut[gt]〉+ 〈θ, vt − vt[gt]〉, where gt = ∇φ(ut); if δt ≤ then\nReturn xt = [ut; vt] else\nUpdate xt+1 = [ut+1; vt+1] ∈ X such that φ+(xt+1) ≤ φ+ (xt + γt(xt[gt]− xt)) end if\nend for\nThe algorithm is outlined in Algorithm 2. Note that CCG works essentially as if there were no vcomponent at all. The CCG algorithm enjoys a convergence rate in O(t−(κ−1)) in the evaluations of the function φ+, and the accuracy certificates (δt) enjoy the same rate O(t\n−(κ−1)) as well, for solving problems of type (15). See Appendix for details and the proof.\nProposition 3.1. Denote D the ‖ · ‖-diameter of U . When solving problems of type (15), the sequence of iterates (xt) of CCG satisfies\nt := φ +(xt)−min x∈X φ+(x) ≤ 2L0D\nκ\nκ(3− κ)\n( 2\nt+ 1\n)κ−1 , t ≥ 2 (18)\nIn addition, the accuracy certificates (δt) satisfy\nmin 1≤s≤t\nδs ≤ O(1)L0Dκ ( 2\nt+ 1\n)κ−1 , t ≥ 2. (19)"
    }, {
      "heading" : "3.3 Semi-Proximal Mirror-Prox for Semi-structured Variational Inequality",
      "text" : "We now give the full description of a special class of variational inequalities, called semi-structured variational inequalities. This family of problems encompasses both cases that we discussed so far in Section 3.1 and 3.2. But most importantly, it also covers many other problems that do not fall into these two regimes and in particular, our essential problem of interest (3).\nSemi-structured Variational Inequalities. The class of semi-structured variational inequalities allows to go beyond Assumptions (A.1) − (A.4), by assuming more structure. This structure is consistent with what we call a semi-proximal setup, which encompasses both the regular proximal setup and the regular linear minimization setup as special cases. Indeed, we consider a class of variational inequality VI(X,F ) that satisfies, in addition to Assumptions (A.1)− (A.4), the following assumptions:\n(S.1) Proximal setup for X: we assume that Eu = Eu1×Eu2 , Ev = Ev1×Ev2 , and U ⊂ U1×U2, X = X1×X2 with Xi ∈ Eui×Evi and PiX = {ui : [ui; vi] ∈ Xi} ⊂ Ui for i = 1, 2, where U1 is convex and closed, U2 is convex and compact. We also assume that ω(u) = ω1(u1) + ω2(u2) and ‖u‖ = ‖u1‖Eu1 + ‖u2‖Eu2 , with ω2(·) : U2 → R continuously differentiable such that\nω2(u ′ 2) ≤ ω2(u2) + 〈∇ω2(u2), u′2 − u2〉+ L0 κ ‖u′2 − u2‖κEu2 ,∀u2, u ′ 2 ∈ U2;\nfor a particular 1 < κ ≤ 2 and L0 < ∞. Furthermore, we assume that the ‖ · ‖Eu2 -diameter of U2 is bounded by some D > 0..\n(S.2) Proximal mapping on X1: we assume that for any η1 ∈ Eu1 and α > 0, we have at disposal easy-tocompute prox-mappings of the form,\nProxω1(η1, α) := min x1=[u1;v1]∈X1 {ω1(u1) + 〈η1, u1〉+ α〈Fv1 , v1〉} .\n(S.3) Linear minimization on X2: we assume that we we have at our disposal Composite Linear Minimization Oracle (LMO), which given any input η2 ∈ Eu2 and α > 0, returns an optimal solution to the minimization problem with linear form, that is,\nLMO(η2, α) := min x2=[u2;v2]∈X2 {〈η2, u2〉+ α〈Fv2 , v2〉} .\nSemi-proximal setup We denote such problems as Semi-VI(X,F ). On the one hand, when U2 is a singleton, we get the full-proximal setup. On the other hand, when U1 is a singleton, we get the full linearminimization-oracle setup (full LMO setup). In the gray zone in between, we get the semi-proximal setup.\nThe Semi-Proximal Mirror-Prox algorithm. We finally present here our main contribution, the SemiProximal Mirror-Prox algorithm, which solves the semi-structured variational inequality under (A.1)−(A.4) and (S.1) − (S.3). The Semi-Proximal Mirror-Prox algorithm blends both CMP and CCG. Basically, for sub-domain X2 given by LMO, instead of computing exactly the prox-mapping, we mimick inexactly the prox-mapping via a conditional gradient algorithm in the composite Mirror Prox algorithm. For the subdomain X1, we compute the prox-mapping as it is.\nCourse of the Semi-Proximal Mirror-Prox algorithm Basically, at step t, we first update yt1 = [û t 1; v̂ t 1] by computing the exact prox-mapping and update yt2 = [û t 2; v̂ t 2] by running the composite conditional gradient algorithm to problem (15) specifically with\nX = X2, φ(·) = ω2(·) + 〈γtFu2(ut2)− ω′2(ut2), ·〉, and θ = γtFv2 ,\nuntil δ(yt2) = maxy2∈X2〈∇φ+(yt2), yt2 − y2〉 ≤ t. We then update xt+11 = [u t+1 1 ; v t+1 1 ] and x t+1 2 = [u t+1 2 ; v t+1 2 ] similarly except this time taking the value of the operator at point yt. Combining the results in Theorem 3.1 and Proposition 3.1, we arrive at the following complexity bound.\nAlgorithm 3 Semi-Proximal Mirror-Prox Algorithm for Semi-VI(X,F )\nInput: stepsizes γt > 0, accuracies t ≥ 0, t = 1, 2, . . . [1] Initialize x1 = [x11;x 1 2] ∈ X, where x11 = [u11; v11 ];x12 = [u12, ; v12 ]. for t = 1, 2, . . . , T do [2] Compute yt = [yt1; y t 2] that\nyt1 := [û t 1; v̂ t 1] = Proxω1(γtFu1(u t 1)− ω′1(ut1), γt) yt2 := [û t 2; v̂ t 2] = CCG(X2, ω2(·) + 〈γtFu2(ut2)− ω′2(ut2), ·〉, γtFv2 ; t)\n[3] Compute xt+1 = [xt+11 ;x t+1 2 ] that\nxt+11 := [u t+1 1 ; v t+1 1 ] = Proxω1(γtFu1(û t 1)− ω′1(ut1), γt) xt+12 := [u t+1 2 ; v t+1 2 ] = CCG(X2, ω2(·) + 〈γtFu2(ût2)− ω′2(ut2), ·〉, γtFv2 ; t)\nend for Output: xT := [ūT ; v̄T ] = ( ∑T t=1 γt) −1∑T t=1 γty t\nProposition 3.2. Under the assumption (A.1) − (A.4) and (S.1) − (S.3) with M = 0, for the outlined algorithm to return an -solution to the variational inequality V I(X,F ), the total number of Mirror Prox steps required does not exceed\nTotal number of steps = O\n( LΘ[X] ) and the total number of calls to the Linear Minimization Oracle does not exceed\nN = O(1) ( L0L κDκ\nκ\n) 1 κ−1\nΘ[X].\nIn particular, if we use Euclidean proximal setup on U2 with ω2(·) = 12‖x2‖ 2, which leads to κ = 2 and L0 = 1, then the number of LMO calls does not exceed N = O(1) ( L2D2(Θ[X1] +D 2 ) / 2.\nDiscussion The proposed Semi-Proximal Mirror-Prox algorithm enjoys the optimal complexity bounds, i.e. O(1/ 2), in the number of calls to LMO; see [15] for the optimal complexity bounds for general nonsmooth optimisation with LMO. Furthermore, Semi-Proximal Mirror-Prox generalizes previously proposed approaches and improves upon them in special cases of problem (3); see Appendix."
    }, {
      "heading" : "4 Experiments",
      "text" : "We present here illustrations of the proposed approach. We report the experimental results obtained with the proposed Semi-Proximal Mirror-Prox, denoted Semi-MP here, and state-of-the-art competing optimization algorithms. We consider three different models, all with a non-smooth loss function and a nuclear-norm regularization penalty: i) matrix completion with `2 data fidelity term; ii) robust collaborative filtering for movie recommendation; iii) link prediction for social network analysis. For i) & ii), we compare to two competing approaches: a) smoothing conditional gradient proposed in [24] (denoted Smooth-CG); b) smoothing proximal gradient ([20, 6]) equipped semi-proximal setup (Semi-SPG). For iii), we compare to Semi-LPADMM, using [22], and solving proximal mapping through conditional gradient routines. Additional experiments and implementation details are given in Appendix E.\nMatrix completion on synthetic data We consider the matrix completion problem, with a nuclearnorm regularisation penalty and an `2 data-fidelity term. We first investigate the convergence patterns of our Semi-MP and Semi-SPG under two different strategies of the inexactness, a) fixed inner CG steps and\nb) decaying t = c/t as the theory suggested. The plots in Fig. 3 indicate that using the second strategy with O(1/t) decaying inexactness provides better and more reliable performance than using fixed number of inner steps. Similar trends are observed for the Semi-SPG. One can see that these two algorithms based on inexact proximal mappings are notably faster than applying conditional gradient on the smoothed problem.\nRobust collaborative filtering We consider the collaborative filtering problem, with a nuclear-norm regularisation penalty and an `1-loss function. We run the above three algorithms on the the small and medium MovieLens datasets. The small-size dataset consists of 943 users and 1682 movies with about 100K ratings, while the medium-size dataset consists of 3952 users and 6040 movies with about 1M ratings. We follow [24] to set the regularisation parameters. In Fig. 2, we can see that Semi-MP clearly outperforms Smooth-CG, while it is competitive with Semi-SPG.\nLink prediction We consider now the link prediction problem, where the objective consists a hinge-loss for the empirical risk part and multiple regularization penalties, namely the `1-norm and the nuclear-norm. For this example, applying the Smooth-CG or Semi-SPG would require two smooth approximations, one for hinge loss term and one for `1 norm term. Therefore, we consider another alternative approach, Semi-LPADMM, where we apply the linearized preconditioned ADMM algorithm [22] by solving proximal mapping through conditional gradient routines. Up to our knowledge, ADMM with early stopping is not fully theoretically analysed in literature. However, from an intuitive point of view, as long as the accumulated error is controlled sufficiently, such variant of ADMM should converge.\nWe conduct experiments on a binary social graph data set called Wikivote, which consists of 7118 nodes and 103,747 edges. Since the computation cost of these two algorithms mainly come from the LMO calls, we present in below the performance in terms of number of LMO calls. For the first set of experiments, we select top 1024 highest degree users from Wikivote and run the two algorithms on this small dataset with different strategies for the inner LMO calls.\nIn Fig. 2, we observe that the Semi-MP is less sensitive to the inner accuracies of prox-mappings compared to the ADMM variant, which sometimes stops progressing if the prox-mapping of early iterations are not solved with sufficient accuracy. The results on the full dataset corroborate the fact that Semi-MP outperforms the semi-proximal variant of the ADMM algorithm."
    }, {
      "heading" : "A Preliminaries: Variational Inequalities and Accuracy Certifi-",
      "text" : "cates\nFor the reader’s convenience, we recall here the relationship between variational inequalities, accuracy certificates, and execution protocols, for non-smooth optimization algorithms. The exposition below is directly taken from [12], and recalled here for the reader’s convenience.\nExecution protocols and accuracy certificates. Let X be a nonempty closed convex set in a Euclidean space E and F (x) : X → E be a vector field.\nSuppose that we process (X,F ) by an algorithm which generates a sequence of search points xt ∈ X, t = 1, 2, ..., and computes the vectors F (xt), so that after t steps we have at our disposal t-step execution protocol It = {xτ , F (xτ )}tτ=1. By definition, an accuracy certificate for this protocol is simply a collection λt = {λtτ}tτ=1 of nonnegative reals summing up to 1. We associate with the protocol It and accuracy certificate λt two quantities as follows:\n• Approximate solution xt(It, λt) := ∑t τ=1 λ t τxτ , which is a point of X;\n• Resolution Res(X ′ ∣∣It, λt) on a subset X ′ 6= ∅ of X given by\nRes(X ′ ∣∣It, λt) = sup\nx∈X′ t∑ τ=1 λtτ 〈F (xτ ), xτ − x〉. (20)\nThe role of those notions for non-smooth optimization is explained below.\nVariational inequalities. Assume that F is monotone, i.e.,VI(X,F)\n〈F (x)− F (y), x− y〉 ≥ 0, ∀x, y ∈ X . (21)\nOur goal is to approximate a weak solution to the variational inequality (v.i.) VI(X,F ) associated with (X,F ). A weak solution is defined as a point x∗ ∈ X such that\n〈F (y), y − x∗〉 ≥ 0 ∀y ∈ X. (22)\nA natural (in)accuracy measure of a candidate weak solution x ∈ X to VI(X,F ) is the dual gap function VI(x ∣∣X,F ) = sup\ny∈X 〈F (y), x− y〉 (23)\nThis inaccuracy is a convex nonnegative function which vanishes exactly at the set of weak solutions to the VI(X,F ).\nProposition A.1. For every t, every execution protocol It = {xτ ∈ X,F (xτ )}tτ=1 and every accuracy certificate λt one has xt := xt(It, λt) ∈ X. Besides this, assuming F monotone, for every closed convex set X ′ ⊂ X such that xt ∈ X ′ one has\nVI(x t ∣∣X ′, F ) ≤ Res(X ′∣∣It, λt). (24)\nProof. Indeed, xt is a convex combination of the points xτ ∈ X with coefficients λtτ , whence xt ∈ X. With X ′ as in the premise of Proposition, we have\n∀y ∈ X ′ : 〈F (y), xt − y〉 = t∑\nτ=1\nλtτ 〈F (y), xτ − y〉 ≤ t∑\nτ=1\nλtτ 〈F (xτ ), xτ − y〉 ≤ Res(X ′ ∣∣It, λt),\nwhere the first ≤ is due to monotonicity of F .\nConvex-concave saddle point problems. Now let X = X1 ×X2, where Xi is a closed convex subset in Euclidean space Ei, i = 1, 2, and E = E1 × E2, and let Φ(x1, x2) : X1 ×X2 → R be a locally Lipschitz continuous function which is convex in x1 ∈ X1 and concave in x2 ∈ X2. X1, X2,Φ give rise to the saddle point problem\nSadVal = min x1∈X1 max x2∈X2\nΦ(x1, x2), (25)\ntwo induced convex optimization problems\nOpt(P ) = min x1∈X1\n[ Φ(x1) = sup\nx2∈X2 Φ(x1, x2)\n] (P )\nOpt(D) = max x2∈X2\n[ Φ(x2) = inf\nx1∈X1 Φ(x1, x2)\n] (D)\n(26)\nand a vector field F (x1, x2) = [F1(x 1, x2);F2(x 1, x2)] specified (in general, non-uniquely) by the relations\n∀(x1, x2) ∈ X1 ×X2 : F1(x1, x2) ∈ ∂x1Φ(x1, x2), F2(x1, x2) ∈ ∂x2 [−Φ(x1, x2)].\nIt is well known that F is monotone on X, and that weak solutions to the VI(X,F ) are exactly the saddle points of Φ on X1×X2. These saddle points exist if and only if (P ) and (D) are solvable with equal optimal values, in which case the saddle points are exactly the pairs (x1∗, x 2 ∗) comprised by optimal solutions to (P ) and (D). In general, Opt(P ) ≥ Opt(D), with equality definitely taking place when at least one of the sets X1, X2 is bounded; if both are bounded, saddle points do exist. To avoid unnecessary complications, from now on, when speaking about a convex-concave saddle point problem, we assume that the problem is proper, meaning that Opt(P ) and Opt(D) are reals; this definitely is the case when X is bounded.\nA natural (in)accuracy measure for a candidate x = [x1;x2] ∈ X1 ×X2 to the role of a saddle point of Φ is the quantity\nSad(x ∣∣X1, X2,Φ) = Φ(x1)− Φ(x2)\n= [Φ(x1)−Opt(P )] + [Opt(D)− Φ(x2)] + [Opt(P )−Opt(D)]︸ ︷︷ ︸ ≥0\n(27)\nThis inaccuracy is nonnegative and is the sum of the duality gap Opt(P )−Opt(D) (always nonnegative and vanishing when one of the sets X1, X2 is bounded) and the inaccuracies, in terms of respective objectives, of x1 as a candidate solution to (P ) and x2 as a candidate solution to (D).\nThe role of accuracy certificates in convex-concave saddle point problems stems from the following observation:\nProposition A.2. Let X1, X2 be nonempty closed convex sets, Φ : X := X1×X2 → R be a locally Lipschitz continuous convex-concave function, and F be the associated monotone vector field on X.\nLet It = {xτ = [x1τ ;x2τ ] ∈ X,F (xτ )}tτ=1 be a t-step execution protocol associated with (X,F ) and λt = {λtτ}tτ=1 be an associated accuracy certificate. Then xt := xt(It, λt) = [x1,t;x2,t] ∈ X.\nAssume, further, that X ′1 ⊂ X1 and X ′2 ⊂ X2 are closed convex sets such that\nxt ∈ X ′ := X ′1 ×X ′2. (28)\nThen Sad(x t ∣∣X ′1, X ′2,Φ) = sup\nx2∈X′2 Φ(x1,t, x2)− inf x1∈X′1 Φ(x1, x2,t) ≤ Res(X ′ ∣∣It, λt). (29)"
    }, {
      "heading" : "In addition, setting Φ̃(x1) = supx2∈X′2 Φ(x",
      "text" : "1, x2), for every x̄1 ∈ X ′1 we have\nΦ̃(x1,t)− Φ̃(x̄1) ≤ Φ̃(x1,t)− Φ(x̄1, x2,t) ≤ Res({x̄1} ×X ′2 ∣∣It, λt). (30)\nIn particular, when the problem Opt = minx1∈X′1 Φ̃(x 1) is solvable with an optimal solution x1∗, we have\nΦ̃(x1,t)−Opt ≤ Res({x1∗} ×X ′2 ∣∣It, λt). (31)\nProof. The inclusion xt ∈ X is clear. For every set Y ⊂ X we have\n∀[p; q] ∈ Y : Res(Y ∣∣It, λt) ≥∑tτ=1 λtτ [〈F1(x1τ ), x1τ − p〉+ 〈F2(x2τ ), x2τ − q〉] ≥ ∑t τ=1 λ t τ [ [Φ(x1τ , x 2 τ )− Φ(p, x2τ )] + [Φ(x1τ , q)− Φ(x1τ , x2τ )]\n] [by the origin of F and since Φ is convex-concave]\n= ∑t τ=1 λ t τ [ Φ(x1τ , q)− Φ(p, x2τ ) ] ≥ Φ(x1,t, q)− Φ(p, x2,t)\n[by origin of xt and since Φ is convex-concave]\nThus, for every Y ⊂ X we have\nsup [p;q]∈Y\n[ Φ(x1,t, q)− Φ(p, x2,t) ] ≤ Res(Y ∣∣It, λt). (32) Now assume that Condition (28) is satisfied. Setting Y = X ′ := X ′1 ×X ′2, and recalling what Sad is, (32) yields (29). With Y = {x̄1}×X ′2 (32) yields the second inequality in (30); the first inequality in (30) is clear since x2,t ∈ X ′2."
    }, {
      "heading" : "B Theoretical analysis of composite Mirror Prox with inexact",
      "text" : "proximal mappings\nWe restate the Theorem 3.1 below and the proof below. The theoretical convergence rate established in Theorem 3.1 and Corollary 3.1 extends the previous result established in Corollary 3.1 in [12] for CMP with exact prox-mappings. Indeed, when exact prox-mappings are used, we recover the result of [12]. When inexact prox-mappings are used, the errors due to the inexactness of the prox-mappings accumulates and is reflected in the bound (34) and (14).\nTheorem 3.1. Assume that the sequence of step-sizes (γt) in the CMP algorithm satisfy\nσt := γt〈Fu(ût)− Fu(ut), ût − ut+1〉 − Vût(ut+1)− Vut(ût) ≤ γ2tM2 , t = 1, 2, . . . , T . (33)\nThen, denoting Θ[X] = sup[u;v]∈X Vu1(u), for a sequence of inexact prox-mappings with inexactness t ≥ 0, we have\nVI(x̄T ∣∣X,F ) := sup\nx∈X 〈F (x), x̄T − x〉 ≤\nΘ[X] +M2 ∑T t=1γ 2 t + 2 ∑T t=1 t∑T\nt=1 γt . (34)\nRemarks Note that the assumption on the sequence of step-sizes (γt) is clearly satisfied when γt ≤ ( √ 2L)−1. When M = 0, it is satisfied as long as γt ≤ L−1.\nProof. The proofs builds upon and extends the proof in [12]. For all u, u′, w ∈ U , we have the well-known identity\n〈V ′u(u′), w − u′〉 = Vu(w)− Vu′(w)− Vu(u′). (35)\nIndeed, the right hand side writes as\n[ω(w)− ω(u)− 〈ω′(u), w − u〉]− [ω(w)− ω(u′)− 〈ω′(u′), w − u′〉]− [ω(u′)− ω(u)− 〈ω′(u), u′ − u〉] = 〈ω′(u), u− w〉+ 〈ω′(u), u′ − u〉+ 〈ω′(u′), w − u′〉 = 〈ω′(u′)− ω′(u), w − u′〉 = 〈V ′u(u′), w − u′〉.\nFor x = [u; v] ∈ X, ξ = [η; ζ], ≥ 0, let [u′; v′] ∈ P x(ξ). By definition, for all [s;w] ∈ X, the inequality holds\n〈η + V ′u(u′), u′ − s〉+ 〈ζ, v′ − w〉 ≤ ,\nwhich by (35) implies that\n〈η, u′ − s〉+ 〈ζ, v′ − w〉 ≤ 〈V ′u(u′), s− u′〉+ = Vu(s)− Vu′(s)− Vu(u′) + . (36)\nWhen applying (36) with = t, [u; v] = [u t; vt] = xt, ξ = γtF (x t) = [γtFu(u t); γtFv], [u ′; v′] = [ût; v̂t] = yt, and [s;w] = [ut+1; vt+1] = xt+1 we obtain\nγt[〈Fu(ut), ût − ut+1〉+ 〈Fv, v̂t − vt+1〉] ≤ Vut(ut+1)− Vût(ut+1)− Vut(ût) + t ; (37)\nand applying (36) with = t, [u; v] = x t, ξ = γtF (y t), [u′; v′] = xt+1, and [s;w] = z ∈ X we get\nγt[〈Fu(ût), ut+1 − s〉+ 〈Fv, vt+1 − w〉] ≤ Vut(s)− Vut+1(s)− Vut(ut+1) + t . (38)\nAdding (38) to (37), we obtain for every z = [s;w] ∈ X\nγt〈F (yt), yt − z〉 = γt[〈Fu(ût), ût − s〉+ 〈Fv, v̂t − w〉] ≤ Vut(s)− Vut+1(s) + σt + 2 t , (39)\nwith σt := γt〈Fu(ût)− Fu(ut), ût − ut+1〉 − Vût(ut+1)− Vut(ût) . Due to the strong convexity, with modulus 1, of Vu(·) w.r.t. ‖ · ‖, we have for all u, û\nVu(û) ≥ 1\n2 ‖u− û‖2 .\nTherefore,\nσt ≤ γt‖Fu(ût)− Fu(ut)‖∗‖ût − ut+1‖ − 12‖û t − ut+1‖2 − 1 2 ‖ut − ût‖2\n≤ 1 2 [ γ2t ‖Fu(ût)− Fu(ut)‖2∗ − ‖ut − ût‖2 ] ≤ 1\n2 [ γ2t [M + L‖ût − ut‖]2 − ‖ut − ût‖2 ] ,\nwhere the last inequality follows from Assumption A.3. Note that γtL < 1 implies that\nγ2t [M + L‖ût − ut‖]2 − ‖ût − ut‖2 ≤ max r\n[ γ2t [M + Lr] 2 − r2 ] = γ2tM 2\n1− γ2tL2 .\nLet us assume that the step-sizes γt > 0 are chosen so that (33) holds, that is σt ≤ γ2tM2. It is indeed the case when 0 < γt ≤ 1√2L ; when M = 0, we can take also γt ≤ 1 L . Summing up inequalities (39) over t = 1, 2, ..., t, and taking into account that Vut+1(s) ≥ 0, we finally conclude that for all z = [s;w] ∈ X, T∑ t=1 λtT 〈F (yt), yt − z〉 ≤ Vu1(s) +M 2 ∑T t=1 γ 2 t + 2 ∑T t=1 t∑T t=1 γt , where λtT = ( T∑ i=1 γi) −1γt ."
    }, {
      "heading" : "C Theoretical analysis of composite conditional gradient",
      "text" : "C.1 Convergence rate\nThe CCG algorithm enjoys a convergence rate in O(t−(κ−1)) in the evaluations of the function φ+, and the accuracy certificates (δt) enjoy the same rate O(t −(κ−1)) as well, for solving problems of type (15).\nProposition 3.1. Denote D the ‖ · ‖-diameter of U . When solving problems of type (15), the sequence of iterates (xt) of CCG satisfies\nt := φ +(xt)−min x∈X φ+(x) ≤ 2L0D\nκ\nκ(3− κ)\n( 2\nt+ 1\n)κ−1 , t ≥ 2 (40)\nIn addition, the accuracy certificates (δt) satisfy\nmin 1≤s≤t\nδs ≤ O(1)L0Dκ ( 2\nt+ 1\n)κ−1 , t ≥ 2 (41)\nC.2 Proof of Proposition 3.1\n10. The projection of X2 onto Eu2 is contained in U2, whence\n‖u2[∇φ(us2)]− us2‖ ≤ D.\nThis observation, due to the structure of φ+, implies that whenever x, x′ ∈ X and γ ∈ [0, 1], we have\nφ+(x+ γ(x+ − x)) ≤ φ+(x) + γ〈∇φ+(x), x′ − x〉+ L0D κ\nκ γκ. (42)\nSetting xs+ = x s 2 + γs(x2[∇φ(us)]− xs2) and γs2/(s+ 1), we have\nδt+1 ≤ φ+(xs+)− min x2∈X2 φ+(x2) (43)\n≤ δs + γs〈∇φ(xs2), x[∇φ+(xs2)]− x2〉+ L0D\nκ\nκ γκs (44)\n= δs − γs∆s + L0D\nκ\nκ γκs , (45)\nwhence, due to ∆s ≥ δs ≥ 0,\n(i) δt+1 ≤ (1− γs)δs + L0D\nκ\nκ γκs , s = 1, 2, ...,\n(ii) γτ∆τ ≤ δτ − δτ+1 + L0D\nκ\nκ γκτ , τ = 1, 2, ... (46)\n20. Let us prove (40) by induction on s ≥ 2. By (46.i) and due to γ1 = 1 we have δ2 ≤ L0D κ\nκ , whence\nδ2 ≤ 2L0D κ κ(3−κ)γ κ−1 2 due to γ2 = 2/3 and 1 < κ ≤ 2. Now assume that δs ≤ 2L0D κ κ(3−κ)γ κ−1 s for some t ≥ 2. Then, invoking (46.i),\nδs+1 ≤ 2L0D\nκ\nκ(3− κ) γκ−1s (1− γs) +\nL0D κ\nκ γκs\n≤ 2L0D κ\nκ(3− κ)\n[ γκ−1s −\nκ− 1 2 γκs ] ≤ 2L0D κ\nκ(3− κ) 2κ−1\n[ (t+ 1)1−κ + (1− κ)(t+ 1)−κ ] Therefore, by convexity of (t+ 1)1−κ in t\nδs+1 ≤ 2L0D\nκ\nκ(3− κ) 2κ−1(t+ 2)1−κ =\n2L0D κ\nκ(3− κ) γκ−1t+1\nThe induction is completed.\n30. To prove (41), given s ≥ 2, let s− = Ceil(max[2, s/2]). Summing up inequalities (46.ii) over s− ≤ τ ≤ s, we get (\nmin τ≤s ∆τ ) ∑s τ=s− γτ ≤ s∑\nτ=s−\nγτ∆τ ≤ δs− − δs+1 + L0D\nκ\n2 ∑s τ=s− γκτ ≤ O(1)L0Dκγκ−1s\nand ∑s τ=s− γτ ≥ O(1), and (41) follows."
    }, {
      "heading" : "D Semi-Proximal Mirror-Prox",
      "text" : "D.1 Theoretical analysis for Semi-Proximal Mirror-Prox\nWe first restate Proposition 3.2 and provide the proof below.\nProposition 3.2. Under the assumption (A.1) − (A.4) and (S.1) − (S.3) with M = 0, for the outlined algorithm to return an -solution to the variational inequality V I(X,F ), the total number of Mirror Prox\nsteps required does not exceed O ( LΘ[X] ) , and the total number of calls to the Linear Minimization Oracle\ndoes not exceed\nN = O(1) ( L0L κDκ\nκ\n) 1 κ−1\nΘ[X].\nIn particular, if we use Euclidean proximal setup on U2 with ω2(·) = 12‖x2‖ 2, which leads to κ = 2 and L0 = 1, then the number of LMO calls does not exceed N = O(1) ( L2D2(Θ[X1] +D 2 ) / 2.\nProof. Let us fix N as the number of Mirror prox steps, and since M = 0, from Theorem 3.1, the efficiency estimate of the variational inequality implies that\nVI(x̄ N |X,F ) ≤\nL(Θ[X] + 2 ∑N t=1 t)\nN .\nLet us fix t = 2Θ[X] N for each t = 1, . . . , N , then from Proposition 3.1, it takes at most s = O(1)(L0D κN\nΘ[X] ) 1/(κ−1) LMO oracles to generate a point such that ∆s ≤ t. Moreover, we have\nVI(x̄ N |X,F ) ≤ 2LΘ[X]\nN .\nTherefore, to ensure VI(x̄ N |X,F ) ≤ for a given accuracy > 0, the number of Mirror Prox steps N is at most O(LΘ[X] ) and the number of LMO calls on X2 needed is at most\nN = O(1) (L0DκN\nΘ[X]\n)1/(κ−1) ·N = O(1) (L0LκDκ κ )1/(κ−1) Θ[X].\nIn particular, if κ = 2 and L0 = 1, this quantity can be reduced to\nN = O(1)L 2D2Θ[X]\n2 .\nD.2 Discussion of Semi-Proximal Mirror-Prox\nThe proposed Semi-Proximal Mirror-Prox algorithm enjoys the optimal complexity bounds, i.e. O(1/ 2), in the number of calls to linear minimization oracle. Furthermore, Semi-Proximal Mirror-Prox generalizes previously proposed approaches and improves upon them in special cases of problem (3).\nWhen there is no regularisation penalty, Semi-Proximal Mirror-Prox is more general than previous algorithms for solving the corresponding constrained non-smooth optimisation problem. Semi-Proximal MirrorProx does not require assumptions on favorable geometry of dual domains Z or simplicity of ψ(·) in (2). When the regularisation is simply a norm (with no operator in front of the argument), Semi-Proximal Mirror-Prox is competitive with previously proposed approaches [16, 24] based on smoothing techniques.\nWhen the regularisation penalty is non-trivial, Semi-Proximal Mirror-Prox is the first proximal-free or conditional-gradient-type optimization algorithm, up to our knowledge."
    }, {
      "heading" : "E Numerical experiments and implementation details",
      "text" : "E.1 Matrix completion: `2-fit +nuclear norm\nWe first consider the the following type of matrix completion problem,\nmin x∈Rm×n\n‖PΩx− b‖2 + λ‖x‖nuc (47)\nwhere ‖ · ‖nuc stands for the nuclear norm and PΩx is the restriction of x onto the cells Ω.\nCompeting algorithms. We compare the following three candidate algorithms, i) Semi-Proximal MirrorProx (Semi-MP) ; ii) conditional gradient after smoothing (Smooth-CG); iii) inexact accelerate proximal gradient after smoothing (Semi-SPG). We provide below the key steps of each algorithms.\n1. Semi-MP: this is shorted for our Semi-Proximal Mirror-Prox algorithm, we solve the saddle point reformulation given by\nmin x,v:‖x‖nuc≤v max ‖y‖2≤1\n〈PΩx− b, y〉+ λv (48)\nwhich is equivalent as to the semi-structured variational inequality Semi-VI (X,F ) with X = {[u = (x; y); v] : ‖x‖nuc ≤ v, ‖y‖2 ≤ 1} and F = [Fu(u);Fv] = [PTΩ y; b − PΩx;λ]. The subdomain X1 = {y : ‖y‖2 ≤ 1} is given by full-prox setup and the subdomain X2 = {(x; v) : ‖x‖nuc ≤ v} is given by LMO. By setting both the distance generating functions ωx(x) and ωy(y) as the Euclidean distance, the update of y reduces to a gradient step, and the update of x follows the composite conditional gradient routine over a simple quadratic problem.\n2. Smooth-CG: The algorithm ([24]) directly applies the generalized composite conditional gradient on the following smoothed problem using the Nesterov smoothing technique,\nmin x,v:‖x‖nuc≤v fγ(x) + λv, where fγ(x) = max ‖y‖2≤1\n{〈PΩx− b, y〉 − γ\n2 ‖y‖22}. (49)\nUnder the full memory version, the update of x at step t requires computing reoptimization problem\nmin θ1,...,θt\nfγ( t∑ i=1 θiuiv T i ) + λ t∑ i=1 θi (50)\nwhere {ui, vi}ti=1 are the singular vectors collected from the linear minimization oracles. Same as suggested in [24], we use the quasi-Newton solver L-BFGS-B [5] to solve the above re-optimization subproblem. Notice that in this situation, solving (50) can be relatively efficient even for large t since computing the gradient of the objective in (50) does not necessarily need to compute out the full matrix representation of x = ∑t i=1 θiuiv T i .\n3. Semi-SPG: The approach is to apply the accelerated proximal gradient to the smoothed composite model as in (49) and approximately solve the proximal mappings via conditional gradient routines. In fact, Semi-SPG can be considered as a direct extension of the conditional gradient sliding to the composite setting. Same as Semi-MP, the update of x is given by the composite conditional gradient routine over a simple quadratic problem and additional interpolation step. Since the Lipschitz constant is not known, the learning rate is selected through backtracking.\nFor Semi-MP and Semi-SPG, we test two different strategies for the inexact prox-mappings, a)fixed inner CG steps and b)decaying t = c/t as the theory suggested. For the sake of simplicity, we generate the synthetic data such that the magnitudes of the constant factors (i.e. Frobenius norm and nuclear norm of optimal solution) are approximately of order 1, which means the convergence rate is dominated mainly by the number of LMO calls. In Fig. 3, we evaluate the optimality gap of these algorithms with different parameters\n(e.g. number of inner steps, scaling factor c, smoothness parameter γ) and compare their performance given the best-tuned parameter. As the plot shows, the Semi-MP algorithm generates a solution with = 10−3 accuracy within about 3000 LMO calls, which is not bad at all given the fact that the worst complexity is O(1/ 2). Also, the plots indicate that using the second strategy with O(1/t) decaying inexactness provides better and more reliable performance than using fixed number of inner steps. Similar trends are observed for the Semi-SPG. One can see that these two algorithms based on inexact proximal mappings are notably faster than applying conditional gradient on the smoothed problem. Moreover, since the Smooth-CG requires additional computation and memory cost for the re-optimization procedure, the actual difference in terms of CPU time could be more significant.\nE.2 Robust collaborative fitering: `1-empirical risk +nuclear norm\nWe consider the collaborative filtering problem, with a nuclear-norm regularisation penalty and an `1- empirical risk function:\nmin x\n1 |E| ∑\n(i,j)∈E\n|xij − bij |+ λ‖x‖nuc. (51)\nCompeting algorithms. We compare the above three candidate algorithm. The smoothed problem for Semi-SPG and Smooth-CG in this case becomes\nmin x,v:‖x‖nuc≤v fγ(x) + λv, where fγ(x) = max ‖y‖∞≤1  1|E| ∑ (i,j)∈E (xij − bij)yij − γ 2 ‖y‖22  . (52) Note that in this case, for Smooth-CG, solving the re-optimization problem in (50) at each iteration requires computing the full matrix representation for the gradient. For large t and large-scale problems, the computation cost for re-optimization is no longer negligible. However, the Semi-MP and Semi-SPG do not suffer from this limitation since the conditional gradient routines are called for simple quadratic subproblems. For this particular example, we implement the Semi-MP slightly different from the above scheme. We solve the following saddle point reformulation with properly selected ρ,\nmin x,y,v1,v2:\nv1≥‖x‖nuc,v2≥‖y‖1\nmax ‖w‖2≤1\nv2 + λv1 + ρ〈Ax− b− y, w〉 (53)\nwhere we use A to denote the operator 1|E|PE . The semi-structured variational inequality Semi-VI (X,F ) associated with the above saddle point problem is given by X = {[u = (x, y, w); v = (v1.v2)] : ‖x‖nuc ≤ v1, ‖y‖1 ≤ v2, ‖w‖2 ≤ 1} and F = [Fu(u);Fv] = [ρAw;−ρw; ρ(y − Ax + b);λ; 1]. The subdomain X1 = {(y, w, v2) : ‖y‖1 ≤ v2, ‖w‖2 ≤ 1} is given by full-prox setup and the subdomain X2 = {(x; v1) : ‖x‖nuc ≤ v1} is given by LMO. By setting both the distance generating functions as the Euclidean distance, the update of w reduces to the gradient step, the update of y reduces to the soft-thresholding operator, and the update\nof x is given by the composite conditonal gradient routine. In our experiment, the factor ρ is updated adaptively in such a way that the back-projection step does not increase the objective function value. We set the stepsizes γt along the iterations using line-search. All in all, the Semi-Proximal Mirror-Prox algorithm (Semi-MP) is fully automatic, and does not require tuning of any parameter.\nWe run the above three algorithms on the the small and medium MovieLens datasets. The small-size dataset consists of 943 users and 1682 movies with about 100K ratings,while the medium-size dataset consists of 3952 users and 6040 movies with about 1M ratings. We follow [24] to set the regularisation parameters. We randomly pick 80% of the entries to build the training dataset, and compute the normalized mean absolute error (NMAE) on the remaining test dataset. For Smooth-CG, we carry out the algorithm with different smoothing parameters, ranging from {1e−3, 1e−2, 1e−1, 1e0} and select the one with the best performance. For the Semi-SPG algorithm, we adopt the best smoothing parameter found in Smooth-CG. We use two different strategies to control the number of LMO calls at each iteration, i.e. the accuracy of the proximal mapping for both Semi-SPG and Semi-MP, which are a) fixed inner CG steps and b) decaying t = c/t as the theory suggested. We report in Fig. 4 and Fig. 5 the performance of each algorithm under different choice of parameters and the overall comparison of objective value and NMAE on test data in Fig. 6.\nIn Fig. 4 and Fig. 5, we can see that using fixed inner CG steps sometimes achieve comparable performance\nas using the decaying epsilon t. In Fig. 6, we can see that Semi-MP clearly outperforms Smooth-CG, while it is competitive with Semi-SPG. In the large-scale setting, Semi-MP achieves better objective as well as test NMAE compared to Smooth-CG.\nE.3 Link prediction: hinge loss + `1-norm + nuclear norm\nWe consider the following model for the link prediction problem,\nmin x∈Rm×n\n1 |E| ∑\n(i,j)∈E\nmax (1− (bij − 0.5)xij , 0) + λ1‖x‖1 + λ2‖x‖nuc (54)\nThis example is more complicated than the previous two examples since it has not only one nonsmooth loss function but also two regularization terms. Applying the smoothing-CG or Semi-SPG would require to build two smooth approximations, one for hinge loss term and one for `1 norm term. Therefore, we consider another alternative approach, Semi-LPADMM, where we apply the linearized preconditioned ADMM algorithm by solving proximal mapping through conditional gradient routines. Up to our knowledge, ADMM with early stopping is not well-analyzed in literature, but intuitively as long as the accumulated error is controlled sufficiently, the variant will converge.\nWe conduct experiments on a binary social graph data set called Wikivote, which consists of 7118 nodes and 103,747 edges. Since the computation cost of these two algorithms mainly come from the LMO calls, we present in below the performance in terms of number of LMO calls. For the first set of experiments, we select top 1024 highest degree users from Wikivote and run the two algorithms on this small dataset with different strategies for the inner LMO calls.\nIn Fig. 7, we observe that the Semi-MP is less sensitive to the inner accuracies of prox-mappings compared to the ADMM variant, which sometimes stop progressing if the prox mapping of early iterations are not solved with sufficient accuracy. Another observation is that in this example, the second strategy, which essentially saves the use of LMOs, works better in the long run than using fixed number of LMOs. The results indicate again on the full dataset again indicates that our algorithm performs better than the semi-proximal variant of ADMM algorithm."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : "We propose a new first-order optimisation algorithm to solve high-dimensional non-smooth composite minimisation problems. Typical examples of such problems have an objective that decomposes into a non-smooth empirical risk part and a non-smooth regularisation penalty. The proposed algorithm, called Semi-Proximal Mirror-Prox, leverages the Fenchel-type representation of one part of the objective while handling the other part of the objective via linear minimization over the domain. The algorithm stands in contrast with more classical proximal gradient algorithms with smoothing, which require the computation of proximal operators at each iteration and can therefore be impractical for high-dimensional problems. We establish the theoretical convergence rate of Semi-Proximal Mirror-Prox, which exhibits the optimal complexity bounds, i.e. O(1/ ), for the number of calls to linear minimization oracle. We present promising experimental results showing the interest of the approach in comparison to competing methods.",
    "creator" : "LaTeX with hyperref package"
  }
}