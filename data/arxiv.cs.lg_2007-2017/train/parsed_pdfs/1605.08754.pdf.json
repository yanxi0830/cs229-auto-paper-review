{
  "name" : "1605.08754.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Dan Garber", "Elad Hazan" ],
    "emails" : [ "dgarber@ttic.edu", "ehazan@cs.princeton.edu", "chijin@eecs.berkeley.edu", "sham@cs.washington.edu", "cnmusco@mit.edu", "praneeth@microsoft.com", "asid@microsoft.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "• Offline Eigenvector Estimation: Given an explicit A ∈ Rn×d with Σ = A>A, we show how to compute an approximate top eigenvector in time Õ ([ nnz(A) + d sr(A)gap2 ] · log 1/ ) and Õ ([ nnz(A)3/4(d sr(A))1/4√\ngap\n] · log 1/ ) . Here nnz(A) is the number of nonzeros in A,\nsr(A) def = ‖A‖2F ‖A‖22\nis the stable rank, gap is the relative eigengap, and Õ(·) hides log factors in d and gap. By separating the gap dependence from the nnz(A) term, our first runtime improves upon the classical power and Lanczos methods. It also improves prior work using fast subspace embeddings [AC09, CW13] and stochastic optimization [Sha15c], giving significantly better dependencies on sr(A) and . Our second running time improves these\nfurther when nnz(A) ≤ d sr(A)gap2 . • Online Eigenvector Estimation: Given a distribution D with covariance matrix Σ and\na vector x0 which is an O(gap) approximate top eigenvector for Σ, we show how to refine to an approximation using O (\nv(D) gap·\n) samples from D. Here v(D) is a natural notion of\nvariance. Combining our algorithm with previous work to initialize x0, we obtain improved sample complexity and runtime results under a variety of assumptions on D.\nWe achieve our results using a general framework that we believe is of independent interest. We give a robust analysis of the classic method of shift-and-invert preconditioning to reduce eigenvector computation to approximately solving a sequence of linear systems. We then apply fast stochastic variance reduced gradient (SVRG) based system solvers to achieve our claims. We believe our results suggest the general effectiveness of shift-and-invert based approaches and imply that further computational gains may be reaped in practice.\n∗This paper combines work first appearing in [GH15] and [JKM+15]\nar X\niv :1\n60 5.\n08 75\n4v 1\n[ cs\n.D S]"
    }, {
      "heading" : "1 Introduction",
      "text" : "Given A ∈ Rn×d, computing the top eigenvector of A>A is a fundamental problem in numerical linear algebra, applicable to principal component analysis [Jol02], spectral clustering and learning [NJW02, VW04], pagerank computation, and many other graph computations [PBMW99, Kor03, Spi07]. For instance, a degree-k principal component analysis is nothing more than performing k leading eigenvector computations. Given the ever-growing size of modern datasets, it is thus a key challenge to come up with more efficient algorithms for this basic computational primitive.\nIn this work we provide improved algorithms for computing the top eigenvector, both in the offline case, when A is given explicitly and in the online or statistical case where we access samples from a distribution D over Rd and wish to estimate the top eigenvector of the covariance matrix Ea∼D [ aa> ] . In the offline case, our algorithms are the fastest to date in a wide and meaningful regime of parameters. Notably, while the running time of most popular methods for eigenvector computations is a product of the size of the dataset (i.e. number of non-zeros in A) and certain spectral characteristics of A, which both can be quite large in practice, we present running times that actually split the dependency between these two quantities, and as a result may yield significant speedups. In the online case, our results yield improved sample complexity bounds and allow for very efficient streaming implementations with memory and processing-time requirements that are proportional to the size of a single sample.\nOn a high-level, our algorithms are based on a robust analysis of the classic idea of shiftand-invert preconditioning [Saa92], which allows us to efficiently reduce eigenvector computation to approximately solving a short sequence of well-conditioned linear systems in λI − A>A for some shift parameter λ ≈ λ1(A). We then apply state-of-the-art stochastic gradient methods to approximately solve these linear systems."
    }, {
      "heading" : "1.1 Our Approach",
      "text" : "The well known power method for computing the top eigenvector of A>A starts with an initial vector x and repeatedly multiplies by A>A, eventually causing x to converge to the top eigenvector. For a random start vector, the power method converges in O(log(d/ )/gap) iterations, where gap = (λ1− λ2)/λ1, λi denotes the ith largest eigenvalue of A>A, and we assume a high-accuracy regime where < gap. The dependence on this gap ensures that the largest eigenvalue is significantly amplified in comparison to the remaining values.\nIf the eigenvalue gap is small, one approach is replace A>A with a preconditioned matrix – i.e. a matrix with the same top eigenvector but a much larger gap. Specifically, let B = λI − A>A for some shift parameter λ. If λ > λ1, we can see that the smallest eigenvector of B (the largest eigenvector of B−1) is equal to the largest eigenvector of A>A. Additionally, if λ is close to λ1, there will be a constant gap between the largest and second largest values of B−1. For example, if λ = (1 + gap)λ1, then we will have λ1 ( B−1 ) = 1λ−λ1 = 1 gap·λ1 and λ2 ( B−1 ) = 1λ−λ2 = 1 2·gap·λ1 .\nThis constant factor gap ensures that the power method applied to B−1 converges to the top eigenvector of A>A in just O(log(d/ )) iterations. Of course, there is a catch – each iteration of this shifted-and-inverted power method must solve a linear system in B, whose condition number is proportional 1gap . For small gap, solving this system via iterative methods is more expensive.\nFortunately, linear system solvers are incredibly well studied and there are many efficient iterative algorithms we can adapt to apply B−1 approximately. In particular, we show how to accelerate the iterations of the shifted-and-inverted power method using variants of Stochastic Variance Re-\nduced Gradient (SVRG) [JZ13]. Due to the condition number of B, we will not entirely avoid a 1 gap dependence, however, we can separate this dependence from the input size nnz(A). Typically, stochastic gradient methods are used to optimize convex functions that are given as the sum of many convex components. To solve a linear system (M>M)x = b we minimize the convex function f(x) = 12x >(M>M)x−b>x with components ψi(x) = 12x > (mim>i )x− 1nb>x where mi is the i th row of M. Such an approach can be used to solve systems in A>A, however solving systems in B = λI −A>A requires more care. We require an analysis of SVRG that guarantees convergence even when some of our components are non-convex. We give a simple analysis for this setting, generalizing recent work in the area [SS15, CR15].\nGiven fast approximate solvers for B, the second main piece of our algorithmic framework is a new error bound for the shifted-and-inverted power method, showing that it is robust to approximate linear system solvers, such as SVRG. We give a general analysis, showing exactly what accuracy each system must be solved to, allowing for faster implementations using linear solvers with\nweaker guarantees. Our proofs center around the potential function: G(x) def = ∥∥∥Pv⊥1 x∥∥∥B / ‖Pv1x‖B, where Pv1 and Pv⊥1 are the projections onto the top eigenvector and its complement respectively. This function resembles tangent based potential functions used in previous work [HP14] except that we use the B norm rather than the `2 norm. For the exact power method, this is irrelevant – progress is identical in both norms (see Lemma 38 of the Appendix). However, ‖·‖B is a natural norm for measuring the progress of linear system solvers for B, so our potential function makes it possible to extend analysis to the case when B−1x is computed up to error ξ with bounded ‖ξ‖B."
    }, {
      "heading" : "1.2 Our Results",
      "text" : "Our algorithmic framework described above offers several advantageous. We obtain improved running times for computing the top eigenvector in the offline model. In Theorem 16 we give an algorithm running in time O ([\nnnz(A) + d sr A gap2\n] · [ log 1 + log\n2 d gap ]) , where sr(A) = ‖A‖2F / ‖A‖ 2 2 ≤\nrank(A) is the stable rank and nnz(A) is the number of non-zero entries. Up to log factors, our runtime is in many settings proportional to the input size nnz(A), and so is very efficient for large matrices. In the case when nnz(A) ≤ d sr(A) gap2 we apply the results of [FGKS15b, LMH15] to provide\nan accelerated runtime of O ([\nnnz(A)3/4(d sr(A))1/4√ gap ] · [ log dgap log 1 + log 3 d gap ]) , shown in Theorem\n17. Finally, in the case when > gap, our results easily extend to give gap-free bounds (Theorems 35 and 36), identical to those shown above but with gap replaced by . Note that our offline results hold for any A and require no initial knowledge of the top eigenvector. In Section 6 we discuss how to estimate the parameters λ1, gap, with modest additional runtime cost.\nOur algorithms return an approximate top eigenvector x with x>A>Ax ≥ (1 − )λ1. By choosing error ·gap, we can ensure that x is actually close to v1 – i.e. that |x>v1| ≥ 1− . Further, we obtain the same asymptotic runtime since O ( log 1 ·gap + log 2 d gap ) = O ( log 1 + log 2 d gap ) . We compare our runtimes with previous work in Table 1. In the online case, in Theorem 25, we show how to improve an O(gap) approximation to the\ntop eigenvector to an approximation with constant probability using O (\nv(D) gap·\n) samples where\nv(D) is a natural variance measure. Our algorithm is based on the streaming SVRG algorithm of [FGKS15a]. It requires just O(d) amortized time per sample, uses just O(d) space, and is easily parallelized. We can apply our result in a variety of regimes, using existing algorithms to obtain\nthe initial O(gap) approximation and our algorithm to improve. As shown in Table 2, this gives improved runtimes and sample complexities over existing work. Notably, we give better asymptotic sample complexity than known matrix concentration results for general distributions, and give the first streaming algorithm that is asymptotically optimal in the popular Gaussian spike model.\nOverall, our robust shifted-and-inverted power method analysis gives new understanding of this classical technique. It gives a means of obtaining provably accurate results when each iteration is implemented using fast linear system solvers with weak accuracy guarantees. In practice, this reduction between approximate linear system solving and eigenvector computation shows that optimized regression libraries can be leveraged for faster eigenvector computation in many cases. Furthermore, in theory we believe that the reduction suggests computational limits inherent in eigenvector computation as seen by the often easier-to-analyze problem of linear system solving. Indeed, in Section 7, we provide evidence that in certain regimes our statistical results are optimal."
    }, {
      "heading" : "1.3 Previous Work",
      "text" : "Offline Eigenvector Computation\nDue to its universal applicability, eigenvector computation in the offline case is extremely well studied. Classical methods, such as the QR algorithm, take roughly O(nd2) time to compute a full eigendecomposition. This can be accelerated to O(ndω−1), where ω < 2.373 is the matrix multiplication constant [Wil12, LG14], however this is still prohibitively expensive for large matrices. Hence, faster iterative methods are often employed, especially when only the top eigenvector (or a few of the top eigenvectors) is desired.\nAs discussed, the popular power method requires O (\nlog(d/ ) gap\n) iterations to converge to an\napproximate top eigenvector. Using Chebyshev iteration, or more commonly, the Lanczos method, this bound can be improved to O (\nlog(d/ )√ gap\n) [Saa92], giving total runtime of O ( nnz(A) · log(d/ )√gap ) .\nWhen > gap, the gap terms in these runtimes can be replaced by . While we focus on the high-precision regime when < gap, we also give gap-free bounds in Section 8.\nUnfortunately, if nnz(A) is very large and gap is small, the above runtimes can still be quite expensive, and there is a natural desire to separate the 1√gap dependence from the nnz(A) term. One approach is to use random subspace embedding matrices [AC09, CW13] or fast row sampling algorithms [CLM+15], which can be applied in O(nnz(A)) time and yield a matrix Ã which is a good spectral approximation to the original. The number of rows in Ã depends only on the stable rank of A and the error of the embedding – hence it can be significantly smaller than n. Applying such a subspace embedding and then computing the top eigenvector of Ã>Ã requires runtime O (nnz(A) + poly(sr(A), , gap)), achieving the goal of reducing runtime dependence on the input size nnz(A). Unfortunately, the dependence on is significantly suboptimal – such an approach cannot be used to obtain a linearly convergent algorithm. Further, the technique does not extend to the online setting, unless we are willing to store a full subspace embedding of our sampled rows.\nAnother approach, which we follow more closely, is to apply stochastic optimization techniques, which iteratively update an estimate to the top eigenvector, considering a random row of A with each update step. Such algorithms naturally extend to the online setting and have led to improved dependence on the input size for a variety of problems [Bot10]. Using variance-reduced stochastic\ngradient techniques, [Sha15c] achieves runtime O (( nnz(A) + dr 2n2\ngap2λ21\n) · log(1/ ) log log(1/ ) ) for\napproximately computing the top eigenvector of a matrix with constant probability. Here r is an\nupper bound on the squared row norms of A. In the best case, when row norms are uniform, this runtime can be simplified to O (( nnz(A) + d sr(A) 2\ngap2\n) · log(1/ ) log log(1/ ) ) .\nThe result in [Sha15c] makes an important contribution in separating input size and gap dependencies using stochastic optimization techniques. Unfortunately, the algorithm requires an approximation to the eigenvalue gap and a starting vector that has a constant dot product with the top eigenvector. In [Sha15b] the analysis is extended to a random initialization, however loses polynomial factors in d. Furthermore, the dependencies on the stable rank and are suboptimal – we improve them to sr(A) and log(1/ ) respectively, obtaining true linear convergence.\nOnline Eigenvector Computation\nWhile in the offline case the primary concern is computation time, in the online, or statistical setting, research also focuses on minimizing the number of samples that are drawn from D in order to achieve a given accuracy. Especially sought after are results that achieve asymptotically optimal accuracy as the sample size grows large.\nWhile the result we give in Theorem 25 works for any distribution parameterized by a variance bound, in this section, in order to more easily compare to previous work, we normalize λ1 = 1 and assume we have the row norm bound ‖a‖22 ≤ O(d) which then gives us the variance bound∥∥Ea∼D [(aa>)2]∥∥2 = O(d). Additionally, we compare runtimes for computing some x such that |x>v1| ≥ 1− , as this is the most popular guarantee studied in the literature. Theorem 25 is easily extended to this setting as obtaining x with xTAA>x ≥ (1− · gap)λ1 ensures |x>v1| ≥ 1− . Our algorithm requires O ( d\ngap2\n) samples to find such a vector under the assumptions given above.\nThe simplest algorithm in this setting is to take n samples from D and compute the leading eigenvector of the empirical estimate Ê[aa>] = 1n ∑n i=1 aia > i . By a matrix Bernstein bound, such as\ninequality of Theorem 6.6.1 of [Tro15], O ( d log d gap2 ) samples is enough to insure ∥∥∥Ê[aa>]− E[aa>]∥∥∥ 2 ≤ √ · gap. By Lemma 37 in the Appendix, this gives that, if x is set to the top eigenvector of Ê[aa>] it will satisfy |x>v1| ≥ 1− . x can be approximated with any offline eigenvector algorithm. A large body of work focuses on improving this simple algorithm, under a variety of assumptions on D. A common focus is on obtaining streaming algorithms, in which the storage space is just O(d) - proportional to the size of a single sample. In Table 2 we give a sampling of results in this\narea. All listed results rely on distributional assumptions at least as strong as those given above. Note that, in each setting, we can use the cited algorithm to first compute an O(gap) approximate eigenvector, and then refine this approximation to an approximation using O (\nd gap2 ) samples by applying our streaming SVRG based algorithm. This allows us to obtain improved runtimes and sample complexities. To save space, we do not include our improved runtime bounds in Table 2, however they are easy to derive by adding the runtime required by the given algorithm\nto achieve O(gap) accuracy, to O ( d2\ngap2\n) – the runtime required by our streaming algorithm.\nThe bounds given for the simple matrix Bernstein based algorithm described above, Krasulina/Oja’s Algorithm [BDF13], and SGD [Sha15a] require no additional assumptions, aside from those given at the beginning of this section. The streaming results cited for [MCJ13] and [HP14] assume a is generated from a Gaussian spike model, where ai = √ λ1γiv1+Zi and γi ∼ N (0, 1), Zi ∼ N (0, Id). We note that under this model, the matrix Bernstein results improve by a log d factor and so match our results in achieving asymptotically optimal convergence rate. The results of [MCJ13] and [HP14] sacrifice this optimality in order to operate under the streaming model. Our work gives the best of both works – a streaming algorithm giving asymptotically optimal results.\nThe streaming Alecton algorithm [SRO15] assumes E ∥∥aa>Waa>∥∥ ≤ O(1)tr(W) for any sym-\nmetric W that commutes with Eaa>. This is strictly stronger than our assumption that∥∥Ea∼D [(aa>)2]∥∥2 = O(d). Algorithm\nSample Size\nRuntime Streaming? Our Sample Complexity\nMatrix Bernstein plus Lanczos (explicitly forming sampled matrix) O ( d log d gap2 ) O ( d3 log d gap2 ) × O ( d log d gap3 + d gap2 ) Matrix Bernstein plus\nLanczos (iteratively applying sampled matrix)\nO ( d log d gap2 ) O ( d2 log d·log(d/ ) gap2.5 ) × O ( d log d gap3 + d gap2 ) Memory-efficient PCA\n[MCJ13, HP14] O ( d log(d/ ) gap3 ) O ( d2 log(d/ ) gap3 ) √ O ( d log(d/gap) gap4 + d gap2 ) Alecton [SRO15] O(d log(d/ )gap2 ) O( d2 log(d/ ) gap2 ) √ O(d log(d/gap)gap3 + d gap2 )\nKrasulina / Oja’s Algorithm [BDF13]\nO( d c1 gap2 c2 ) O( dc1+1 gap2 c2 ) √\nO( d c1\ngap2+c2 + dgap2 )\nSGD [Sha15a] O(d 3 log(d/ ) 2 ) O( d4 log(d/ ) 2 ) √\nO ( d3 log(d/gap)\ngap2 + d gap2 )\nTable 2: Summary of existing work on Online Eigenvector Estimation and improvements given by our results. Runtimes are for computing a unit vector x such that |x>v1| ≥ 1− . For each of these results we can obtain improved running times and sample complexities by running the algorithm to first compute an O(gap) approximate eigenvector, and then running our algorithm to obtain an\napproximation using an additional O\n(\nd gap2\n)\nsamples, O(d) space, and O(d) work per sample."
    }, {
      "heading" : "1.4 Paper Organization",
      "text" : "Section 2 Review problem definitions and parameters for our runtime and sample bounds.\nSection 3 Describe the shifted-and-inverted power method and show how it can be implemented using approximate system solvers.\nSection 4 Show how to apply SVRG to solve systems in our shifted matrix, giving our main runtime results for offline eigenvector computation.\nSection 5 Show how to use an online variant of SVRG to run the shifted-and-inverted power method, giving our main sampling complexity and runtime results in the statistical setting.\nSection 6 Show how to efficiently estimate the shift parameters required by our algorithms.\nSection 7 Give a lower bound in the statistical setting, showing that our results are asymptotically optimal for a wide parameter range.\nSection 8 Give gap-free runtime bounds, which apply when > gap."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We bold all matrix variables. We use [n] def = {1, ..., n}. For a symmetric positive semidefinite (PSD) matrix M we let ‖x‖M def = √ x>Mx and λ1(M), ..., λd(M) denote its eigenvalues in decreasing order. We use M N to denote the condition that x>Mx ≤ x>Nx for all x."
    }, {
      "heading" : "2.1 The Offline Problem",
      "text" : "We are given a matrix A ∈ Rn×d with rows a(1), ..., a(n) and wish to compute an approximation to the top eigenvector of Σ def = A>A. Specifically, for error parameter we want a unit vector x such that x>Σx ≥ (1− )λ1(Σ)."
    }, {
      "heading" : "2.2 The Statistical Problem",
      "text" : "We have access to an oracle returning independent samples from a distribution D on Rd and wish to compute the top eigenvector of Σ def = Ea∼D [ aa> ] . Again, for error parameter we want to return a unit vector x such that x>Σx ≥ (1− )λ1(Σ)."
    }, {
      "heading" : "2.3 Problem Parameters",
      "text" : "We parameterize the running times and sample complexities of our algorithms in terms of several natural properties of A, D, and Σ. Let λ1, ..., λd denote the eigenvalues of Σ in decreasing order and v1, ..., vd denote their corresponding eigenvectors. We define the eigenvalue gap by gap\ndef = λ1−λ2λ1 .\nWe use the following additional parameters for the offline and statistical problems respectively: • Offline Problem: Let sr(A) def= ∑\ni λi λ1 = ‖A‖2F ‖A‖22 denote the stable rank of A. Note that we\nalways have sr(A) ≤ rank(A). Let nnz(A) denote the number of non-zero entries in A.\n• Online Problem: Let v(D) def= ∥∥∥Ea∼D[(aa>)2]∥∥∥ 2\n‖Ea∼D(aa>)‖22 =\n∥∥∥Ea∼D[(aa>)2]∥∥∥ 2\nλ21 denote a natural upper\nbound on the variance of D in various settings. Note that v(D) ≥ 1."
    }, {
      "heading" : "3 Algorithmic Framework",
      "text" : "Here we develop our robust shift-and-invert framework. In Section 3.1 we provide a basic overview of the framework and in Section 3.2 we introduce the potential function we use to measure progress of our algorithms. In Section 3.3 we show how to analyze the framework given access to an exact linear system solver and in Section 3.4 we strengthen this analysis to work with an inexact linear system solver. Finally, in Section 3.5 we discuss initializing the framework."
    }, {
      "heading" : "3.1 Shifted-and-Inverted Power Method Basics",
      "text" : "We let Bλ def = λI−Σ denote the shifted matrix that we will use in our implementation of the shiftedand-inverted power method. As discussed, in order for B−1λ to have a large eigenvalue gap, λ should be set to (1 + c · gap)λ1 for some constant c ≥ 0. Throughout this section we assume that we have a crude estimate of λ1 and gap and fix λ to be a value satisfying ( 1 + gap150 ) λ1 ≤ λ ≤ ( 1 + gap100 ) λ1. (See Section 6 for how we can compute such a λ). For the remainder of this section we work with such a fixed value of λ and therefore for convenience denote Bλ as B.\nNote that λi ( B−1 ) = 1λi(B) = 1 λ−λi and so λ1(B−1) λ2(B−1) = λ−λ2λ−λ1 ≥ gap gap/100 = 100. This large gap will ensure that, assuming the ability to apply B−1, the power method will converge very quickly. In the remainder of this section we develop our error analysis for the shifted-and-inverted power method which demonstrates that approximate application of B−1 in each iteration in fact suffices."
    }, {
      "heading" : "3.2 Potential Function",
      "text" : "Our analysis of the power method focuses on the objective of maximizing the Rayleigh quotient, x>Σx for a unit vector x. Note that as the following lemma shows, this has a direct correspondence to the error in maximizing |v>1 x|:\nLemma 1 (Bounding Eigenvector Error by Rayleigh Quotient). For a unit vector x let = λ1 − x>Σx. If ≤ λ1 · gap then ∣∣∣v>1 x∣∣∣ ≥√1− λ1 · gap . Proof. Among all unit vectors x such that = λ1 − x>Σx, a minimizer of\n∣∣v>1 x∣∣ has the form x = ( √ 1− δ2)v1 + δv2 for some δ. We have\n= λ1 − x>Σx = λ1 − λ1(1− δ2)− λ2δ2 = (λ1 − λ2)δ2.\nTherefore by direct computation,∣∣∣v>1 x∣∣∣ = √1− δ2 = √1− λ1 − λ2 = √ 1− λ1 · gap .\nIn order to track the progress of our algorithm we use a more complex potential function than just the Rayleigh quotient error, λ1 − x>Σx. Our potential function G is defined for x 6= 0 by\nG(x) def = ∥∥∥Pv⊥1 x∥∥∥B ‖Pv1x‖B\nwhere Pv1 and Pv⊥1 are the projections onto v1 and the subspace orthogonal to v1 respectively. Equivalently, we have that:\nG(x) =\n√ ‖x‖2B − ( v>1 B 1/2x )2∣∣v>1 B1/2x∣∣ = √∑ i≥2 α2i λi(B−1)√ α21\nλ1(B−1)\n. (1)\nwhere αi = v > i x.\nWhen the Rayleigh quotient error = λ1 − x>Σx of x is small, we can show a strong relation between and G(x). We prove this in two parts. We first give a technical lemma, Lemma 2, that we will use several times for bounding the numerator of G. We then prove the connection in Lemma 3.\nLemma 2. For a unit vector x and = λ1 − x>Σx if ≤ λ1 · gap then\n≤ x>Bx− (v>1 Bx)(v>1 x) ≤ (\n1 + λ− λ1 λ1 · gap\n) .\nProof. Since B = λI−Σ and since v1 is an eigenvector of Σ with eigenvalue λ1 we have\nx>Bx− (v>1 Bx)(v>1 x) = λ ‖x‖ 2 2 − x >Σx− (λv>1 x− v>1 Σx)(v>1 x) = λ− λ1 + − (λv>1 x− λ1v>1 x)(v>1 x)\n= (λ− λ1) ( 1− (v>1 x)2 ) + .\nNow by Lemma 1 we know that |v>1 x| ≥ √\n1− λ1·gap , giving us the upper bound. Furthermore, since trivially ∣∣v>1 x∣∣ ≤ 1 and λ− λ1 > 0, we have the lower bound. Lemma 3 (Potential Function to Rayleigh Quotient Error Conversion). For a unit vector x and = λ1 − x>Σx if ≤ 12λ1 · gap, we have:\nλ− λ1 ≤ G(x)2 ≤\n( 1 +\nλ− λ1 λ1 · gap\n)( 1 +\n2\nλ1 · gap\n)\nλ− λ1 .\nProof. Since v1 is an eigenvector of B, we can write G(x) 2 = x>Bx−(v>1 Bx)(v>1 x) (v>1 Bx)(v > 1 x) . Lemmas 1 and 2 then give us:\nλ− λ1 ≤ G(x)2 ≤\n( 1 +\nλ− λ1 λ1 · gap\n)\n(λ− λ1) ( 1− λ1·gap ) .\nSince ≤ 12λ1 · gap, we have 1\n1− λ1·gap\n≤ 1 + 2 λ1·gap . This proves the lemma."
    }, {
      "heading" : "3.3 Power Iteration",
      "text" : "Here we show that the shifted-and-inverted power iteration in fact makes progress with respect to our objective function given an exact linear system solver for B. Formally, we show that applying B−1 to a vector x decreases the potential function G(x) geometrically.\nTheorem 4. Let x be a unit vector with 〈x, v1〉 6= 0 and let x̃ = B−1x, i.e. the power method update of B−1 on x. Then, under our assumption on λ, we have:\nG(x̃) ≤ λ2 ( B−1 ) λ1 (B−1) G(x) ≤ 1 100 G(x).\nNote that x̃ may no longer be a unit vector. However, G(x̃, v1) = G(cx̃, v1) for any scaling parameter c, so the theorem also holds for x̃ scaled to have unit norm.\nProof. Writing x in the eigenbasis, we have x = ∑ i αivi and x̃ = ∑ i αiλi ( B−1 ) vi. Since 〈x, v1〉 6= 0, α1 6= 0 and by the equivalent formulation of G(x) given in (1):\nG(x̃) =\n√∑ i≥2 α 2 iλi(B\n−1)√ α21λ1(B −1) ≤ λ2 ( B−1 ) λ1 (B−1) ·\n√∑ i≥2\nα2i λi(B−1)√ α21\nλ1(B−1)\n= λ2 ( B−1 ) λ1 (B−1) ·G(x) .\nRecalling that λ1(B−1) λ2(B−1) = λ−λ2λ−λ1 ≥ gap gap/100 = 100 yields the result.\nThe challenge in using the above theorem, and any traditional analysis of the shifted-andinverted power method, is that we don’t actually have access to B−1. In the next section we show that the shifted-and-inverted power method is robust – we still make progress on our objective function even if we only approximate B−1x using a fast linear system solver."
    }, {
      "heading" : "3.4 Approximate Power Iteration",
      "text" : "We are now ready to prove our main result. We show that each iteration of the shifted-and-inverted power method makes constant factor expected progress on our potential function assuming we:\n1. Start with a sufficiently good x and an approximation of λ1\n2. Can apply B−1 approximately using a system solver such that the function error (i.e. distance to B−1x in the B norm) is sufficiently small in expectation.\n3. Can estimate Rayleigh quotients over Σ well enough to only accept updates that do not hurt progress on the objective function too much.\nThis third assumption is necessary since the second assumption is quite weak. An expected progress bound on the linear system solver allows, for example, the solver to occasionally return a solution that is entirely orthogonal to v1, causing us to make unbounded backwards progress on our potential function. The third assumption allows us to reject possibly harmful updates and ensure that we still make progress in expectation. In the offline setting, we can access A and are able to compute Rayleigh quotients exactly in time nnz(A) time. However, we only assume the ability to estimate quotients since in the online setting we only have access to Σ through samples from D.\nOur general theorem for the approximate power iteration, Theorem 5, assumes that we can solve linear systems to some absolute accuracy in expectation. This is not completely standard. Typically, system solver analysis assumes an initial approximation to B−1x and then shows a relative progress bound – that the quality of the initial approximation is improved geometrically in each iteration of the algorithm. In Corollary 6 we show how to find a coarse initial approximation\nto B−1x, in fact just approximating B−1 with 1 x>Bx\nx. Using this approximation, we show that Theorem 5 actually implies that traditional system solver relative progress bounds suffice.\nNote that in both claims we measure error of the linear system solver using ‖·‖B. This is a natural norm in which geometric convergence is shown for many linear system solvers and directly corresponds to the function error of minimizing f(w) = 12w >Bw − w>x to compute B−1x.\nTheorem 5 (Approximate Shifted-and-Inverted Power Iteration – Warm Start). Let x = ∑\ni αivi be a unit vector such that G(x) ≤ 1√\n10 . Suppose we know some shift parameter λ with ( 1 + gap150 ) λ1 <\nλ ≤ ( 1 + gap100 ) λ1 and an estimate λ̂1 of λ1 such that 10 11 (λ− λ1) ≤ λ− λ̂1 ≤ λ− λ1. Furthermore, suppose we have a subroutine solve(·) such that on any input x\nE [∥∥solve (x)−B−1x∥∥\nB\n] ≤ c1\n1000\n√ λ1(B−1),\nfor some c1 < 1, and a subroutine q̂uot (·) that on any input x 6= 0∣∣∣q̂uot (x)− quot(x)∣∣∣ ≤ 1 30 (λ− λ1) for all nonzero x ∈ Rd.\nwhere quot(x) def = x >Σx x>x\n. Then the following update procedure:\nSet x̂ = solve (x) ,\nSet x̃ =  x̂ if { q̂uot (x̂) ≥ λ̂1 − ( λ− λ̂1 ) /6 and ‖x̂‖2 ≥ 2 3 1\nλ−λ̂1 x otherwise,\nsatisfies the following:\n• G(x̃) ≤ 1√ 10 and\n• E [G(x̃)] ≤ 325G(x) + c1 500 .\nThat is, not only do we decrease our potential function by a constant factor in expectation, but we are guaranteed that the potential function will never increase beyond 1/ √ 10.\nProof. The first claim follows directly from our choice of x̃ from x and x̂. If x̃ = x, it holds trivially by our assumption that G(x) ≤ 1√\n10 . Otherwise, x̃ = x̂ and we know that λ1 − quot (x̂) ≤ λ̂1 − quot (x̂) ≤ λ̂1 − q̂uot (x̂) + ∣∣∣q̂uot (x̂)− quot (x̂)∣∣∣\n≤ λ− λ̂1 6 + λ− λ1 30 ≤ λ− λ1 5 ≤ λ1 · gap 500 .\nThe claim then follows from Lemma 3 as G(x̂)2 ≤ (\n1 + λ− λ1 λ1 · gap\n)( 1 +\n2 (λ1 − quot (x̂)) λ1 · gap\n) λ1 − quot (x̂)\nλ− λ1\n≤ 101 100 · 251 250 ·\n( λ1·gap\n500 ) ( λ1·gap\n150\n) ≤ 1√ 10 .\nAll that remains is to show the second claim, that E [G(x̃)] ≤ 325G(x) + 4c1 1000 . Let F denote the event that we accept our iteration and set x = x̂ = solve (x). That is:\nF def= { q̂uot (x̂) ≥ λ̂1 −\nλ− λ̂1 6 } ∪ { ‖x̂‖2 ≥ 2 3\n1\nλ− λ̂1\n} .\nUsing our bounds on λ̂1 and q̂uot (·), we know that q̂uot (x) ≤ quot(x) + (λ− λ1)/30 and λ− λ̂1 ≤ λ− λ1. Therefore, since −1/6− 1/30 ≥ −1/2 we have\nF ⊆ {quot (x̂) ≥ λ1 − (λ− λ1) /2} ∪ { ‖x̂‖2 ≥ 2\n3\n1\nλ− λ1\n} ,\nWe will complete the proof in two steps. First we let ξ def = x̂ −B−1x and show that assuming F is true then G(x̂) and ‖ξ‖B are linearly related, i.e. expected error bounds on ‖ξ‖B correspond to expected error bounds on G(x̂). Second, we bound the probability that F does not occur and bound error incurred in this case. Combining these yields the result.\nTo show the linear relationship in the case where F is true, first note Lemma 1 shows that in this case ∣∣∣v>1 x̂‖x̂‖2 ∣∣∣ ≥√1− λ1−quot(x̂)λ1·gap ≥ 34 . Consequently, ‖Pv1 x̂‖B = ∣∣∣v>1 x̂∣∣∣√λ− λ1 = ∣∣∣∣v>1 x̂‖x̂‖2 ∣∣∣∣ · ‖x̂‖√λ− λ1 ≥ 34 · 23 1√λ− λ1 = √ λ1(B−1) 2 . However, ∥∥∥Pv⊥1 x̂∥∥∥B ≤ ∥∥∥Pv⊥1 B−1x∥∥∥B + ∥∥∥Pv⊥1 ξ∥∥∥B ≤ ∥∥∥Pv⊥1 B−1x∥∥∥B + ‖ξ‖B and by Theorem 4 and the definition of G we have∥∥∥Pv⊥1 B−1x∥∥∥B = ∥∥Pv1B−1x∥∥B ·G(B−1x) ≤ (|〈x, v1〉|√λ1(B−1)) · G(x)100 . Taking expectations, using that |〈x, v1〉| ≤ 1, and combining these three inequalities yields\nE [G(x̂)|F ] = E  ∥∥∥Pv⊥1 B−1x∥∥∥B ‖Pv1B−1x‖B ∣∣∣∣∣∣F  ≤ G(x) 50 + 2 E [‖ξ‖B|F ]√ λ1(B−1)\n(2)\nSo, conditioning on making an update and changing x (i.e. F occurring), we see that our potential function changes exactly as in the exact case (Theorem 4) with additional additive error due to our inexact linear system solve.\nNext we upper bound P [F ] and use it to compute E [‖ξ‖B|F ]. We will show that G def= { ‖ξ‖B ≤ 1 100 · √ λ1 (B−1) } ⊆ F\nwhich then implies by Markov inequality that P [F ] ≥ P [ ‖ξ‖B ≤ 1 100 · √ λ1 (B−1) ] ≥ 1− E [‖ξ‖B] 1 100 · √ λ1 (B−1) ≥ 9 10 , (3)\nwhere we used the fact that E[‖ξ‖B] ≤ c1 1000 √ λ1(B−1) for some c1 < 1.\nLet us now show that G ⊆ F . Suppose G is occurs. We can bound ‖x̂‖2 as follows: ‖x̂‖2 ≥ ∥∥B−1x∥∥ 2 − ‖ξ‖2 ≥ ∥∥B−1x∥∥−√λ1 (B−1) ‖ξ‖B ≥ |α1|λ1 ( B−1 ) − 1\n100 · λ1\n( B−1 ) = 1\nλ− λ1\n( |α1| − 1\n100\n) ≥ 3\n4\n1\nλ− λ1 , (4)\nwhere we use Lemmas 2 and 3 to conclude that |α1| ≥ √\n1− 110 . We now turn to showing the Rayleigh quotient condition required by F . In order to do this, we first bound x̂>Bx̂− ( v>1 Bx̂ ) ( v>1 x̂ ) and then use Lemma 2. We have:√\nx̂>Bx̂− ( v>1 Bx̂ ) ( v>1 x̂ ) = ∥∥∥Pv⊥1 x̂∥∥∥B ≤ ∥∥∥Pv⊥1 B−1x∥∥∥B + ∥∥∥Pv⊥1 ξ∥∥∥B\n≤ √∑\ni≥2 α2iλi (B\n−1) + 1 100 · √ λ1 (B−1)\n≤ √ λ2 (B−1) + 1 100 · √ λ1 (B−1) ≤ 1 9 √ λ− λ1,\nwhere we used the fact that λ2 ( B−1 ) ≤ 1100λ1 ( B−1 ) since λ ≤ λ1 + gap100 in the last step. Now, using Lemma 2 and the bound on ‖x̂‖2, we conclude that\nλ̂1 − q̂uot (x̂) ≤ λ1 − quot (x̂) + ∣∣∣quot (x̂)− q̂uot (x̂)∣∣∣+ λ̂1 − λ1\n≤ x̂>Bx̂−\n( v>1 Bx̂ ) ( v>1 x̂ ) ‖x̂‖22 + λ− λ1 30 + λ− λ1 11\n≤ 1 81 (λ− λ1) · 16 9 (λ− λ1)2 + λ− λ1 8\n≤ (λ− λ1) /6 ≤ ( λ− λ̂1 ) /4. (5)\nCombining (4) and (5) shows that G ⊆ F there by proving (3). Using this and the fact that ‖·‖B ≥ 0 we can upper bound E [‖ξ‖B|F ] as follows:\nE [‖ξ‖B|F ] ≤ 1\nP [F ] · E [‖ξ‖B] ≤ c1 900 · √ λ1(B−1)\nPlugging this into (2), we obtain:\nE [G(x̂)|F ] ≤ 1 50 G(x) + 2E [‖ξ‖B|F ]√ λ1(B−1) ≤ 1 50 ·G(x) + 2c1 900 .\nWe can now finally bound E [G(x̃)] as follows:\nE [G(x̃)] = P [F ] · E [G(x̂)|F ] + (1− P [F ])G(x)\n≤ 9 10\n( 1\n50 ·G(x) + 2c1 900\n) + 1\n10 G(x) =\n3\n25 G(x) + 2c1 1000 .\nThis proves the theorem.\nCorollary 6 (Relative Error Linear System Solvers). For any unit vector x, we have:∥∥∥∥ 1x>Bxx−B−1x ∥∥∥∥\nB\n≤ α1 √ λ1(B−1) ·G(x) = λ1 ( B−1 )√√√√∑ i≥2 α2i λi (B−1) , (6)\nwhere x = ∑\ni αivi is the decomposition of x along vi. Therefore, instantiating Theorem 5 with c1 = α1G(x) gives E[G(x̃)] ≤ 425G(x) as long as:\nE [∥∥solve (x)−B−1x∥∥\nB\n] ≤ 1\n1000 ∥∥∥∥ 1λ− x>Σxx−B−1x ∥∥∥∥\nB\n.\nProof. Since B is PSD we see that if we let f(w) = 12w >Bw − w>x, then the minimizer is B−1x. Furthermore note that 1 x>Bx\n= arg minβ f(βx) and therefore∥∥∥∥ 1x>Bxx−B−1x ∥∥∥∥2\nB\n= x>B−1x− 1 x>Bx = 2 [ f ( x x>Bx ) − f(B−1x) ] =2 [ min β f(βx)− f(B−1x) ] ≤ 2 [ f(λ1 ( B−1 ) x)− f(B−1x)\n] =λ1 ( B−1 )2 x>Bx− 2λ1 ( B−1 ) x>x+ x>B−1x\n= d∑ i=1 ∣∣∣v>i B 12x∣∣∣2 (λ1 (B−1)− λi (B−1))2 ≤ λ1 (B−1)2∑ i≥2 ∣∣∣v>i B 12x∣∣∣2 =λ1 ( B−1\n)2∑ i≥2 α2i λi (B−1) ,\nwhich proves (6). Consequently\nc1 1000\n√ λ1(B−1) = 1\n1000 α1G(x)\n√ λ1(B−1) ≥ 1\n1000 ∥∥∥∥ 1x>Bxx−B−1x ∥∥∥∥\nB\nwhich with Theorem 5 then completes the proof."
    }, {
      "heading" : "3.5 Initialization",
      "text" : "Theorem 5 and Corollary 6 show that, given a good enough approximation to v1, we can rapidly refine this approximation by applying the shifted-and-inverted power method. In this section, we cover initialization. That is, how to obtain a good enough approximation to apply these results.\nWe first give a simple bound on the quality of a randomly chosen start vector x0.\nLemma 7 (Random Initialization Quality). Suppose x ∼ N (0, I), and we initialize x0 as x‖x‖2 , then with probability greater than 1−O ( 1 d10 ) , we have:\nG(x0) ≤ √ κ(B−1)d10.5 ≤ 15 1√\ngap · d10.5\nwhere κ(B−1) = λ1(B −1)/λd(B −1).\nProof.\nG(x0) =G(x) = ∥∥∥Pv⊥1 x∥∥∥B ‖Pv1x‖B = √ ‖x‖2B − ( v>1 B 1/2x )2∣∣v>1 B1/2x∣∣ = √∑ i≥2 (v>i x) 2 λi(B−1)√ (v>1 x) 2\nλ1(B−1)\n,\n≤ √ κ(B−1) ·\n√∑ i≥2(v > i x)\n2∣∣v>1 x∣∣ Since {v>i x}i are independent standard normal Gaussian variables. By standard concentration arguments, with probability greater than 1− e−Ω(d), we have √∑ i≥2(v > i x) 2 = O( √ d). Meanwhile,\nv>1 x is just a one-dimensional standard Gaussian. It is easy to show P (∣∣v>1 x∣∣ ≤ 1d10 ) = O ( 1d10 ), which finishes the proof.\nWe now show that we can rapidly decrease our initial error to obtain the required G(x) ≤ 1√ 10\nbound for Theorem 5.\nTheorem 8 (Approximate Shifted-and-Inverted Power Method – Burn-In). Suppose we initialize x0 as in Lemma 7 and suppose we have access to a subroutine solve (·) such that\nE [∥∥solve (x)−B−1x∥∥\nB\n] ≤ 1 3000κ(B−1)d21 · ∥∥∥∥ 1λ− x>Σxx−B−1x ∥∥∥∥ B\nwhere κ(B−1) = λ1(B −1)/λd(B −1). Then the following procedure,\nxt = solve (xt−1) / ‖solve (xt−1)‖2 after T = O ( log d+ log κ(B−1)) ) iterations satisfies:\nG(xT ) ≤ 1√ 10 ,\nwith probability greater than 1−O( 1 d10 ).\nProof. As before, we first bound the numerator and denominator of G(x̂) more carefully as follows: Numerator: ∥∥∥Pv⊥1 x̂∥∥∥B ≤ ∥∥∥Pv⊥1 B−1x∥∥∥B + ∥∥∥Pv⊥1 ξ∥∥∥B ≤ ∥∥∥Pv⊥1 B−1x∥∥∥B + ‖ξ‖B\n= √∑ i≥2 ( vTi B −1/2x )2 + ‖ξ‖B = √∑ i≥2 α 2 iλi (B\n−1) + ‖ξ‖B , Denominator: ‖Pv1 x̂‖B ≥ ∥∥Pv1B−1x∥∥B − ‖Pv1ξ‖B ≥ ∥∥Pv1B−1x∥∥B − ‖ξ‖B = ∣∣vTi B−1/2x∣∣− ‖ξ‖B = α1√λ1 (B−1)− ‖ξ‖B\nWe now use the above estimates to bound G(x̂).\nG(x̂) ≤\n√∑ i≥2 α 2 iλi (B\n−1) + ‖ξ‖B α1 √ λ1 (B−1)− ‖ξ‖B\n≤ λ2 ( B−1 )√∑ i≥2 α2i λi(B−1) + ‖ξ‖B\nλ1 (B−1) √\nα21 λ1(B−1) − ‖ξ‖B\n= G(x) λ2 ( B−1 ) + ‖ξ‖B / √∑ i≥2 α2i λi(B−1)\nλ1 (B−1)− ‖ξ‖B / √ α21 λ1(B−1)\nBy Lemma 7, we know with at least probability 1−O( 1 d10 ), we have G(x0) ≤ √ κ(B−1)d10.5.\nConditioned on high probability result of G(x0), we now use induction to prove G(xt) ≤ G(x0). It trivially holds for t = 0. Suppose we now have G(x) ≤ G(x0), then by the condition in Theorem 8 and Markov inequality, we know with probability greater than 1− 1\n100 √ κ(B−1)d10.5 we have:\n‖ξ‖B ≤ 1 30 √ κ(B−1)d10.5 · ∥∥∥∥ 1λ− x>Σxx−B−1x ∥∥∥∥ B\n≤ 1 30 · ∥∥∥∥ 1λ− x>Σxx−B−1x ∥∥∥∥ B min { 1, 1 G(x0) } ≤ 1 30 · ∥∥∥∥ 1λ− x>Σxx−B−1x ∥∥∥∥ B min { 1, 1 G(x) }\n≤ λ1 ( B−1 ) − λ2 ( B−1 ) 4 min  √√√√∑\ni≥2\nα2i λi (B−1) ,\n√ α21\nλ1 (B−1)  The last inequality uses Corollary 6 with the fact that λ2 ( B−1 ) ≤ 1100λ1 ( B−1 ) . Therefore, we have: We will have:\nG(x̂) ≤ λ1 ( B−1 ) + 3λ2 ( B−1 ) 3λ1 (B−1) + λ2 (B−1) ×G(x) ≤ 1 2 G(x)\nThis finishes the proof of induction. Finally, by union bound, we know with probability greater than 1 − O( 1\nd10 ) in T = O(log d +\nlog κ(B−1)) steps, we have:\nG(xT ) ≤ 1\n2T G(x0) ≤ 1√ 10"
    }, {
      "heading" : "4 Offline Eigenvector Computation",
      "text" : "In this section we show how to instantiate the framework of Section 3 in order to compute an approximate top eigenvector in the offline setting. As discussed, in the offline setting we can trivially compute the Rayleigh quotient of a vector in nnz(A) time as we have explicit access to A>A. Consequently the bulk of our work in this section is to show how we can solve linear systems in B efficiently in expectation, allowing us to apply Corollary 6 of Theorem 5.\nIn Section 4.1 we first show how Stochastic Variance Reduced Gradient (SVRG) [JZ13] can be adapted to solve linear systems of the form Bx = b. If we wanted, for example, to solve a linear system in a positive definite matrix like A>A, we would optimize the objective function f(x) = 12x\n>A>Ax − b>x. This function can be written as the sum of n convex components, ψi(x) = 1 2x > (aia>i )x− 1nb>x. In each iteration of traditional gradient descent, one computes the full gradient of f(xi) and takes a step in that direction. In stochastic gradient methods, at each iteration, a single component is sampled, and the step direction is based only on the gradient of the sampled component. Hence, we avoid a full gradient computation at each iteration, leading to runtime gains.\nUnfortunately, while we have access to the rows of A and so can solve systems in A>A, it is less clear how to solve systems in B = λI−A>A. To do this, we will split our function into components of the form ψi(x) = 1 2x > (wiI− aia>i )x− 1nb>x for some set of weights wi with ∑i∈[n]wi = λ.\nImportantly, (wiI − aia>i ) may not be positive semidefinite. That is, we are minimizing a sum of functions which is convex, but consists of non-convex components. While recent results for minimizing such functions could be applied directly [SS15, CR15] here we show how to obtain stronger results by using a more general form of SVRG and analyzing the specific properties of our function (i.e. the variance).\nOur analysis shows that we can make constant factor progress in solving linear systems in B in time O (\nnnz(A) + d sr(A) gap2\n) . If d sr(A)\ngap2 ≤ nnz(A) this gives a runtime proportional to the input size –\nthe best we could hope for. If not, we show in Section 4.2 that it is possible to accelerate our system solver, achieving runtime Õ (\nnnz(A)3/4(d sr(A))1/4√ gap\n) . This result uses the work of [FGKS15b, LMH15]\non accelerated approximate proximal point algorithms. With our solvers in place, in Section 4.3 we pull our results together, showing how to use these solvers in the framework of Section 3 to give faster running times for offline eigenvector computation."
    }, {
      "heading" : "4.1 SVRG Based Solver",
      "text" : "Here we provide a sampling based algorithm for solving linear systems in B. In particular we provide an algorithm for solving the more general problem where we are given a strongly convex function that is a sum of possibly non-convex functions that obey smoothness properties. We provide a general result on bounding the progress of an algorithm that solves such a problem by non-uniform sampling in Theorem 9 and then in the remainder of this section we show how to bound the requisite quantities for solving linear systems in B.\nTheorem 9 (SVRG for Sums of Non-Convex Functions). Consider a set of functions, {ψ1, ψ2, ...ψn}, each mapping Rd → R. Let f(x) = ∑ i ψi(x) and let x\nopt def= arg minx∈Rd f(x). Suppose we have a probability distribution p on [n], and that starting from some initial point x0 ∈ Rd in each iteration k we pick ik ∈ [n] independently with probability pik and let\nxk+1 := xk − η\npi (5ψi(xk)−5ψi(x0)) + η5 f(x0)\nfor some η. If f is µ-strongly convex and if for all x ∈ Rd we have∑ i∈[n] 1 pi ∥∥5ψi(x)−5ψi(xopt)∥∥22 ≤ 2S [f(x)− f(xopt)] , (7) where S is a variance parameter, then for all m ≥ 1 we have\nE  1 m ∑ k∈[m] f(xk)− f(xopt)  ≤ 1 1− 2ηS̄ [ 1 µηm + 2ηS ] · [ f(x0)− f(xopt)\n] Consequently, if we pick η to be a sufficiently small multiple of 1/S̄ then when m = O(S/µ) we can decrease the error by a constant multiplicative factor in expectation.\nProof. We first note that Eik [xk+1 − xk] = η5 f(xk). This is, in each iteration, in expectation, we\nmake a step in the direction of the gradient. Using this fact we have: Eik ∥∥xk+1 − xopt∥∥22 = Eik ∥∥(xk+1 − xk) + (xk − xopt)∥∥22\n= ∥∥xk − xopt∥∥22 − 2Eik(xk+1 − xk)>(xk − xopt) + Eik ‖xk+1 − xk‖22\n= ∥∥xk − xopt∥∥22 − 2η5 f(xk)> (xk − xopt)\n+ ∑ i∈[n] η2pi ∥∥∥∥ 1pi (5ψi(xk)−5ψi(x0)) +5f(x0) ∥∥∥∥2 2\nWe now apply the fact that ‖x+ y‖22 ≤ 2 ‖x‖ 2 2 + 2 ‖y‖ 2 2 to give:∑\ni∈[n]\npi ∥∥∥∥ 1pi (5ψi(xk)−5ψi(x0)) +5f(x0) ∥∥∥∥2\n2\n≤ ∑ i∈[n] 2pi ∥∥∥∥ 1pi (5ψi(xk)−5ψi(xopt)) ∥∥∥∥2 2 + ∑ i∈[n] 2pi ∥∥∥∥ 1pi (5ψi(x0)−5ψi(xopt))−5f(x0) ∥∥∥∥2 2 .\nThen, using that 5f(xopt) = 0 by optimality, that E ‖x− Ex‖22 ≤ E ‖x‖ 2 2, and (7) we have:∑\ni∈[n]\npi ∥∥∥∥ 1pi (5ψi(xk)−5ψi(x0)) +5f(x0) ∥∥∥∥2\n2\n≤ ∑ i∈[n] 2 pi ∥∥5ψi(xk)−5ψi(xopt)∥∥22 + ∑ i∈[n] 2pi ∥∥∥∥ 1pi (5ψi(x0)−5ψi(xopt))− (5f(x0)−5f(xopt)) ∥∥∥∥2 2\n≤ ∑ i∈[n] 2 pi ∥∥5ψi(xk)−5ψi(xopt)∥∥22 + ∑ i∈[n] 2pi ∥∥∥∥ 1pi 5 ψi(x0)−5ψi(xopt)) ∥∥∥∥2 2\n≤ 4S [ f(xk)− f(xopt) + f(x0)− f(xopt) ] Since f(xopt)− f(xk) ≥ 5f(xk)>(xopt − xk) by the convexity of f , these inequalities imply\nEik ∥∥xk+1 − xopt∥∥22 ≤ ∥∥xk − xopt∥∥22 − 2η [f(xk)− f(xopt)]+ 4η2S [f(xk)− f(xopt) + f(x0)− f(xopt)]\n= ∥∥xk − xopt∥∥22 − 2η(1− 2ηS) (f(xk)− f(xopt))+ 4η2S̄ (f(x0)− f(xopt))\nRearranging, we have: 2η(1− 2ηS) ( f(xk)− f(xopt) ) ≤ ∥∥xk − xopt∥∥22 − Eik ∥∥xk+1 − xopt∥∥22 + 4η2S̄ (f(x0)− f(xopt)) .\nAnd summing over all iterations and taking expectations we have:\nE 2η(1− 2ηS̄) ∑ k∈[m] f(xk)− f(xopt)  ≤ ∥∥x0 − xopt∥∥22 + 4mη2S̄ [f(x0)− f(xopt)] . Finally, we use that by strong convexity,\n∥∥x0 − xopt∥∥22 ≤ 2µ (f(x0)− f(xopt)) to obtain: E\n2η(1− 2ηS̄) ∑ k∈[m] f(xk)− f(xopt)  ≤ 2 µ [ f(x0)− f(xopt) ] + 4mη2S̄ [ f(x0)− f(xopt) ]\nand thus\nE  1 m ∑ k∈[m] f(xk)− f(xopt)  ≤ 1 1− 2ηS̄ [ 1 µηm + 2ηS̄ ] · [ f(x0)− f(xopt) ]\nTheorem 9 immediately yields a solver for Bx = b. Finding the minimum norm solution to this system is equivalent to minimizing f(x) = 12x\n>Bx− b>x. If we take the common approach of applying a smoothness bound for each ψi along with a strong convexity bound on f(x) we obtain:\nLemma 10 (Simple Variance Bound for SVRG). Let\nψi(x) def =\n1 2 x> ( λ ‖ai‖22 ‖A‖2F I− aia>i ) x− 1 n b>x\nso we have ∑\ni∈[n] ψi(x) = f(x) = 1 2x >Bx− b>x. Setting pi = ‖ai‖22 ‖A‖2F for all i, we have\n∑ i∈[n] 1 pi ∥∥5ψi(x)−5ψi(xopt)∥∥22 = O ( ‖A‖4F λ− λ1 [ f(x)− f(xopt) ])\nProof. We first compute, for all i ∈ [n]\n5ψi(x) = ( λ ‖ai‖22 ‖A‖2F I− aia>i ) x− 1 n b. (8)\nWe have that each ψi is λ‖ai‖22 ‖A‖2F + ‖ai‖2 smooth with respect to ‖·‖2. Specifically,\n∥∥5ψi(x)−5ψi(xopt)∥∥2 = ∥∥∥∥∥ ( λ ‖ai‖22 ‖A‖2F I− aia>i ) (x− xopt) ∥∥∥∥∥ 2\n≤ ( λ ‖ai‖22 ‖A‖2F + ‖ai‖2 )∥∥x− xopt∥∥ 2 .\nAdditionally, f(x) is λd(B) = λ−λ1 strongly convex so we have ∥∥x− xopt∥∥2\n2 ≤ 2λ−λ1\n[ f(x)− f(xopt) ] and putting all this together we have\n∑ i∈[n] 1 pi ∥∥5ψi(x)−5ψi(xopt)∥∥22 ≤∑ i∈[n] ‖A‖2F ‖ai‖22 · ‖ai‖42\n( λ\n‖A‖2F + 1 )2 · 2 λ− λ1 [ f(x)− f(xopt) ] = O ( ‖A‖4F λ− λ1 [ f(x)− f(xopt) ])\nwhere the last step uses that λ ≤ 2λ1 ≤ 2 ‖A‖2F so λ ‖A‖2F ≤ 2.\nAssuming that λ = (1 + c · gap)λ1 for some constant c, the above bound means that we can make constant progress on our linear system by setting m = O(S/µ) = O ( ‖A‖4F\n(λ−λ1)2\n) = O ( sr(A)2\ngap2\n) .\nThis dependence on stable rank matches the dependence given in [Sha15c] (see discussion in Section 1.3), however we can show that it is suboptimal. We show to improve the bound to O (\nsr(A) gap2\n) by\nusing a better variance analysis. Instead of bounding each ∥∥5ψi(x)−5ψi(xopt)∥∥22 term using the smoothness of ψi, we more carefully bound the sum of these terms.\nLemma 11. (Improved Variance Bound for SVRG) For i ∈ [n] let\nψi(x) def =\n1 2 x> ( λ ‖ai‖22 ‖A‖2F I− aia>i ) x− 1 n b>x\nso we have ∑\ni∈[n] ψi(x) = f(x) = 1 2x >Bx− b>x. Setting pi = ‖ai‖22 ‖A‖2F for all i, we have for all x\n∑ i∈[n] 1 pi ∥∥5ψi(x)−5ψi(xopt)∥∥22 ≤ 4λ1 ‖A‖2Fλ− λ1 · [f(x)− f(xopt)] . Proof. Using the gradient computation in (8) we have\n∑ i∈[n] 1 pi ∥∥5ψi(x)−5ψi(xopt)∥∥22 = ∑ i∈[n] ‖A‖2F ‖ai‖22 ∥∥∥∥∥ ( λ ‖ai‖22 ‖A‖2F I− aia>i ) (x− xopt) ∥∥∥∥∥ 2 2\n= ∑ i∈[n] λ2 ‖ai‖22 ‖A‖2F ∥∥x− xopt∥∥2 2 − 2 ∑ i∈[n] λ ∥∥x− xopt∥∥2 aia>i\n+ ∑ i∈[n] ‖A‖2F ‖ai‖2 ∥∥x− xopt∥∥2‖ai‖22aia>i = λ2 ∥∥x− xopt∥∥2 2 − 2λ ∥∥x− xopt∥∥2 Σ + ‖A‖2F ∥∥x− xopt∥∥2 Σ .\n≤ λ ∥∥x− xopt∥∥2\nB + ‖A‖2F ∥∥x− xopt∥∥2 Σ . (9)\nNow since\nΣ λ1I λ1\nλ− λ1 B\nwe have ∑ i∈[n] 1 pi ∥∥5ψi(x)−5ψi(xopt)∥∥22 ≤ ( λ(λ− λ1) + ‖A‖2F · λ1 λ− λ1 )∥∥x− xopt∥∥2 B\n≤ ( 2 ‖A‖2F λ1 λ− λ1 )∥∥x− xopt∥∥2 B\nwhere in the last inequality we just coarsely bound λ(λ−λ1) ≤ λ1 ‖A‖2F . Now since B is full rank, Bxopt = b, we can compute:∥∥x− xopt∥∥2\nB = x>Bx− 2b>x+ b>xopt = 2[f(x)− f(xopt)]. (10)\nThe result follows.\nPlugging the bound in Lemma 11 into Theorem 9 we have:\nTheorem 12. (Offline SVRG-Based Solver) Let S = 2λ1‖Σ‖2F λ−λ1 , µ = λ−λ1. The iterative procedure described in Theorem 9 with f(x) = 12x >Bx − b>x, ψi(x) = 12x > ( λ‖ai‖22 ‖Σ‖2F I− aia>i ) x − b>x, pi = ‖ai‖22 ‖Σ‖2F , η = 1/(8S) and m chosen uniformly at random from [64S/µ] returns a vector xm such that\nE ∥∥xm − xopt∥∥2B ≤ 12 ∥∥x0 − xopt∥∥2B .\nFurther, assuming ( 1 + gap150 ) λ1 < λ ≤ ( 1 + gap100 ) λ1, this procedure runs in time O ( nnz(A) + d·sr(A) gap2 ) .\nProof. Lemma 11 tells us that∑ i∈[n] 1 pi ∥∥5ψi(x)−5ψi(xopt)∥∥22 ≤ 2S [f(x)− f(xopt)] . Further f(x) = 12x\n>Bx − b>x is λd(B)-strongly convex and λd(B) = λ − λ1 = µ. Plugging this into Theorem 9 and using (10) which shows ∥∥x− xopt∥∥2 B\n= 2[f(x)− f(xopt)] we have, for m chosen uniformly from [64S/µ]:\nE  1 64S/µ ∑ k∈[64S/µ] f(xk)− f(xopt)  ≤ 4/3 · [1/8 + 1/8] · [f(x0)− f(xopt)] E [ f(xm)− f(xopt) ] ≤ 1\n2\n[ f(x0)− f(xopt) ] E ∥∥xm − xopt∥∥2B ≤ 12 ∥∥x0 − xopt∥∥2B .\nThe procedure requires O (nnz(A)) time to initially compute 5f(x0), along with each pi and the step size η which depend on ‖A‖2F and the row norms of A. Each iteration then just requires O(d) time to compute 5ψi(·) and perform the necessary vector operations. Since there are at most [64S/µ] = O ( λ1‖A‖2F (λ−λ1)2 ) iterations, our total runtime is\nO ( nnz(A) + d ·\nλ1 ‖A‖2F (λ− λ1)2\n) = O ( nnz(A) +\nd · sr(A) gap2\n) .\nNote that if our matrix is uniformly sparse - i.e. all rows have sparsity at most ds, then the runtime is actually at most O (\nnnz(A) + ds·sr(A) gap2\n) ."
    }, {
      "heading" : "4.2 Accelerated Solver",
      "text" : "Theorem 12 gives a linear solver for B that makes progress in expectation and which we can plug into Theorems 5 and 8. However, we first show that the runtime in Theorem 12 can be accelerated in some cases. We apply a result of [FGKS15b], which shows that, given a solver for a regularized version of a convex function f(x), we can produce a fast solver for f(x) itself. Specifically:\nLemma 13 (Theorem 1.1 of [FGKS15b]). Let f(x) be a µ-strongly convex function and let xopt def = arg minx∈Rd f(x). For any γ > 0 and any x0 ∈ Rd, let fγ,x0(x) def = f(x) + γ2 ‖x− x0‖ 2 2. Let x opt γ,x0 def = arg minx∈Rd fγ,x0(x). Suppose that, for all x0 ∈ Rd, c > 0, γ > 0, we can compute a point xc such that\nEfγ,x0(xc)− fγ,x0(xoptγ,x0) ≤ 1\nc\n[ fγ,x0 − fγ,x0(xoptγ,x0) ] in time Tc. Then given any x0, c > 0, γ > 2µ, we can compute x1 such that\nEf(x1)− f(xopt) ≤ 1\nc\n[ f(x0)− f(xopt) ] in time O ( T\n4 (\n2γ+µ µ )3/2√dγ/µe log c) . We first give a new variance bound on solving systems in B when a regularizer is used. The\nproof of this bound is very close to the proof given for the unregularized problem in Lemma 11.\nLemma 14. For i ∈ [n] let\nψi(x) def =\n1 2 x> ( λ ‖ai‖22 ‖A‖2F I− aia>i ) x− 1 n b>x+ γ ‖ai‖22 2 ‖A‖2F ‖x− x0‖22\nso we have ∑\ni∈[n] ψi(x) = fγ,x0(x) = 1 2x >Bx− b>x+ γ2 ‖x− x0‖ 2 2. Setting pi = ‖ai‖22 ‖A‖2F for all i, we\nhave for all x∑ i∈[n] 1 pi ∥∥5ψi(x)−5ψi(xoptγ,x0)∥∥22 ≤ ( γ2 + 12λ1 ‖A‖2F λ− λ1 + γ )[ fγ,x0(x)− fγ,x0(xoptγ,x0) ] Proof. We have for all i ∈ [n]\n5ψi(x) = ( λ ‖ai‖22 ‖A‖2F I− aia>i ) x− 1 n b+ γ ‖ai‖22 2 ‖A‖2F (x− 2x0) (11)\nPlugging this in we have:∑ i∈[n] 1 pi ∥∥5ψi(x)−5ψi(xoptγ,x0)∥∥22 = ∑ i∈[n] ‖A‖2F ‖ai‖22 ∥∥∥∥∥ ( λ ‖ai‖22 ‖A‖2F I− aia>i ) (x− xoptγ,x0) + γ ‖ai‖22 2 ‖A‖2F (x− xoptγ,x0) ∥∥∥∥∥ 2 2\nFor simplicity we now just use the fact that ‖x+ y‖22 ≤ 2 ‖x‖ 2 2 + 2 ‖y‖ 2 2 and apply our bound from equation (9) to obtain:∑ i∈[n] 1 pi\n∥∥5ψi(x)−5ψi(xoptγ,x0)∥∥22 ≤ 2λ2 ∥∥x− xoptγ,x0∥∥22 − 4λ∥∥x− xoptγ,x0∥∥2Σ + 2 ‖Σ‖2F ∥∥x− xoptγ,x0∥∥2Σ + 2\n∑ i∈[n] ‖ai‖22 ‖A‖2F γ2 4 ∥∥x− xoptγ,x0∥∥22 ≤ ( 2λ2 + γ2/2 + 2λ1 ‖A‖2F − 4λ1λ )∥∥x− xoptγ,x0∥∥22\n≤ ( γ2/2 + 6λ1 ‖A‖2F )∥∥x− xoptγ,x0∥∥22\nNow, fγ,x0(·) is λ− λ1 + γ strongly convex, so∥∥x− xoptγ,x0∥∥22 ≤ 2λ− λ1 + γ [fγ,x0(x)− fγ,x0(xoptγ,x0)] . So overall we have:\n∑ i∈[n] 1 pi ∥∥5ψi(x)−5ψi(xoptγ,x0)∥∥22 ≤ ( γ2 + 12λ1 ‖A‖2F λ− λ1 + γ )[ fγ,x0(x)− fγ,x0(xoptγ,x0) ]\nWe can now use this variance bound to obtain an accelerated solver for B. We assume nnz(A) ≤ d sr(A) gap2\n, as otherwise, the unaccelerated solver in Theorem 12 runs in O(nnz(A)) time and cannot be accelerated further.\nTheorem 15 (Accelerated SVRG-Based Solver). Assuming ( 1 + gap150 ) λ1 < λ ≤ ( 1 + gap100 ) λ1 and nnz(A) ≤ d sr(A) gap2\n, applying the iterative procedure described in Theorem 9 along with the acceleration given by Lemma 13 gives a solver that returns x with\nE ∥∥x− xopt∥∥2\nB ≤ 1\n2 ∥∥x0 − xopt∥∥2B . in time O ( nnz(A)3/4(d sr(A))1/4√ gap · log ( d gap )) .\nProof. Following Theorem 12, the variance bound of Lemma 14 means that we can make constant progress in minimizing fγ,x0(x) in O (nnz(A) + dm) time where m = O ( γ2+12λ1‖Σ‖2F\n(λ−λ1+γ)2\n) . So,\nfor γ ≥ 2(λ − λ1) we can make 4 (\n2γ+(λ−λ1) λ−λ1\n)3/2 progress, as required by Lemma 13 in time\nO ( (nnz(A) + dm) · log (\nγ λ−λ1\n)) time. Hence by Lemma 13 we can make constant factor expected\nprogress in minimizing f(x) in time:\nO (( nnz(A) + d\nγ2 + 12λ1 ‖A‖2F (λ− λ1 + γ)2\n) log ( γ\nλ− λ1\n)√ γ\nλ− λ1\n)\nBy our assumption, we have nnz(A) ≤ d sr(A) gap2 = dλ1‖A‖2F (λ−λ1)2 . So, if we let γ = Θ (√ dλ1‖A‖2F nnz(A) ) then\nusing a sufficiently large constant, we have γ ≥ 2(λ− λ1). We have γλ−λ1 = Θ (√ dλ1‖A‖2F nnz(A)λ21gap 2 ) =\nΘ (√\nd sr(A) nnz(A)gap2\n) and can make constant expected progress in minimizing f(x) in time:\nO\n( nnz(A)3/4(d sr(A))1/4\n√ gap\n· log ( d\ngap\n)) ."
    }, {
      "heading" : "4.3 Shifted-and-Inverted Power Method",
      "text" : "Finally, we are able to combine the solvers from Sections 4.1 and 4.2 with the framework of Section 3 to obtain faster algorithms for top eigenvector computation.\nTheorem 16 (Shifted-and-Inverted Power Method With SVRG). Let B = λI−A>A for ( 1 + gap150 ) λ1 ≤\nλ ≤ ( 1 + gap100 ) λ1 and let x0 ∼ N (0, I) be a random initial vector. Running the inverted power method on B initialized with x0, using the SVRG solver from Theorem 12 to approximately apply B−1 at each step, returns x such that with probability 1−O ( 1 d10 ) , x>Σx ≥ (1− )λ1 in total time\nO (( nnz(A) + d sr(A)\ngap2\n) · ( log2 ( d\ngap\n) + log ( 1 ))) .\nNote that by instantiating the above theorem with ′ = · gap, and applying Lemma 1 we can find a unit vector x such that |v>1 x| ≥ 1 − in the same asymptotic running time (an extra log(1/gap) term is absorbed into the log2(d/gap) term).\nProof. By Theorem 8, if we start with x0 ∼ N (0, I) we can run O ( log ( d gap )) iterations of the\ninverted power method, to obtain x1 with G(x1) ≤ 1√10 with probability 1 − O ( 1 d10 ) . Each iteration requires applying an linear solver that decreases initial error in expectation by a factor of 1\npoly(d,1/gap) . Such a solver is given by applying the solver in Theorem 12 O ( log ( d gap )) times, decreasing error by a constant factor in expectation each time. So overall in order to find x1 with\nG(x1) ≤ 1√10 , we require time O (( nnz(A) + d sr(A) gap2 ) · log2 ( d gap )) .\nAfter this initial ‘burn-in’ period we can apply Corollary 6 of Theorem 5, which shows that running a single iteration of the inverted power method will decrease G(x) by a constant factor in expectation. In such an iteration, we only need to use a solver that decreases initial error by a constant factor in expectation. So we can perform each inverted power iteration in this stage in\ntime O (\nnnz(A) + d sr(A) gap2\n) .\nWith O ( log ( d )) iterations, we can obtain x with E [ G(x)2 ] = O ( d10 ) So by Markov’s inequality, we have G(x)2 = O( ), giving us xTΣx ≥ (1−O( ))λ1 by Lemma 3. Union bounding over both stages gives us failure probability O ( 1 d10 ) , and adding the runtimes from the two stages gives us\nthe final result. Note that the second stage requires O ( log ( d )) = O(log d+ log(1/ )) iterations to\nachieve the high probability bound. However, the O(log d) term is smaller than the O ( log2 (\nd gap )) term, so is absorbed into the asymptotic notation.\nWe can apply an identical analysis using the accelerated solver from Theorem 15, obtaining the following runtime which beats Theorem 16 whenever nnz(A) ≤ d sr(A)\ngap2 :\nTheorem 17 (Shifted-and-Inverted Power Method Using Accelerated SVRG). Let B = λI−A>A for ( 1 + gap150 ) λ1 ≤ λ ≤ ( 1 + gap100 ) λ1 and let x0 ∼ N (0, I) be a random initial vector. Assume that nnz(A) ≤ d sr(A) gap2 . Running the inverted power method on B initialized with x0, using the accelerated SVRG solver from Theorem 15 to approximately apply B−1 at each step, returns x such that with probability 1−O ( 1 d10 ) , |v>1 x| ≥ 1− in total time\nO\n(( nnz(A)3/4(d sr(A))1/4\n√ gap\n) · ( log3 ( d\ngap\n) + log ( d\ngap\n) log ( 1 ))) ."
    }, {
      "heading" : "5 Online Eigenvector Computation",
      "text" : "Here we show how to apply the shifted-and-inverted power method framework of Section 3 to the online setting. This setting is more difficult than the offline case. As there is no canonical matrix A, and we only have access to the distribution D through samples, in order to apply Theorem 5 we must show how to both estimate the Rayleigh quotient (Section 5.1) as well as solve the requisite linear systems in expectation (Section 5.2).\nAfter laying this ground work, our main result is given in Section 5.3. Ultimately, the results in this section allow us to achieve more efficient algorithms for computing the top eigenvector in the statistical setting as well as improve upon the previous best known sample complexity for top eigenvector computation. As we show in Section 7 the bounds we provide in this section are in fact tight for general distributions."
    }, {
      "heading" : "5.1 Estimating the Rayleigh Quotient",
      "text" : "Here we show how to estimate the Rayleigh quotient of a vector with respect to Σ. Our analysis is standard – we first approximate the Rayleigh quotient by its empirical value on a batch of k samples and prove using Chebyshev’s inequality that the error on this sample is small with constant probability. We then repeat this procedure O(log(1/p)) times and output the median. By a Chernoff bound this yields a good estimate with probability 1− p. The formal statement of this result and its proof comprise the remainder of this subsection.\nTheorem 18 (Online Rayleigh Quotient Estimation). Given ∈ (0, 1], p ∈ [0, 1], and unit vector x set k = d4 v(D) −2e and m = O(log(1/p)). For all i ∈ [k] and j ∈ [m] let a(j)i be drawn independently from D and set Ri,j = x>a(j)i (a (j) i ) >x and Rj = 1 k ∑ i∈[k]Ri,j. If we let z be median\nvalue of the Rj then with probability 1− p we have ∣∣z − x>Σx∣∣ ≤ λ1.\nProof.\nVara∼D(x >aa>x) = Ea∼D(x>aa>x)2 − (Ea∼Dx>aa>x)2\n≤ Ea∼D ‖a‖22 x >aa>x− (x>Σx)2 ≤ ∥∥∥Ea∼D ‖a‖22 aa>∥∥∥\n2 = v(D)λ21\nConsequently, Var(Ri,j) ≤ v(D)λ21, and since each of the a (j) i were drawn independently this implies that we have that Var(Rj) ≤ v(D)λ21/k. Therefore, by Chebyshev’s inequality\nP [ |Rj − E[Rj ]| ≥ 2 √ v(D)λ21 k ] ≤ 1 4 .\nSince E[Rj ] = x>Σx and since we defined k appropriately this implies that\nP [∣∣∣Rj − x>Σx∣∣∣ ≥ λ1] ≤ 1\n4 . (12)\nThe median z satisfies |z − x>Σx| ≤ as more than half of the Rj satisfy |Rj − x>Σx| ≤ . This happens with probability 1− p by Chernoff bound, our choice of m and (12)."
    }, {
      "heading" : "5.2 Solving the Linear system",
      "text" : "Here we show how to solve linear systems in B = λI −Σ in the streaming setting. We follow the general strategy of the offline algorithms in Section 4, replacing traditional SVRG with the streaming SVRG algorithm of [FGKS15a]. Similarly to the offline case we minimize f(x) = 12x\n>Bx− b>x and define for all a ∈ supp(D),\nψa(x) def =\n1 2 x>(λI− aa>)x− b>x. (13)\ninsuring that f(x) = Ea∼Dψa(x).. The performance of streaming SVRG [FGKS15a] is governed by three regularity parameters. As in the offline case, we use the fact that f(·) is µ-strongly convexity for µ = λ−λ1 and we require a smoothness parameter, denoted S, that satisfies:\n∀x ∈ Rd : Ea∼D ∥∥5ψa(x)−5ψa(xopt)∥∥22 ≤ 2S [f(x)− f(xopt)] . (14)\nFurthermore, we require an upper bound the variance, denoted σ2, that satisfies:\nEa∼D 1\n2 ∥∥5ψa(xopt)∥∥2(52f(xopt))−1 ≤ σ2 . (15) With the following two lemmas we bound these parameters.\nLemma 19 (Streaming Smoothness). The smoothness parameter S def = λ+ v(D)λ21 λ−λ1 satisfies (14).\nProof. Our proof is similar to the one for Lemma 10.\nEa∼D ∥∥5ψa(x)−5ψa(xopt)∥∥22 = Ea∼D ∥∥∥(λI− aa>)(x− xopt)∥∥∥22\n= λ2 ∥∥x− xopt∥∥2\n2 − 2λEa∼D ∥∥x− xopt∥∥2 aa> + Ea∼D ∥∥∥aa>(x− xopt)∥∥∥2\n2 ≤ λ2 ∥∥x− xopt∥∥2\n2 − 2λ ∥∥x− xopt∥∥2 Σ + ∥∥∥Ea∼D ‖a‖22 aa>∥∥∥ 2 · ∥∥x− xopt∥∥2 2\n≤ λ ∥∥x− xopt∥∥2\nB + v(D)λ21 ∥∥x− xopt∥∥2 2 .\nSince f is λ − λ1-strongly convex, ∥∥x− xopt∥∥2\n2 ≤ 2λ−λ1 [f(x) − f(x opt)]. Furthermore, since direct calculation reveals, 2[f(x)− f(xopt)] = ∥∥x− xopt∥∥2\nB , the result follows.\nLemma 20 (Streaming Variance). The variance parameter σ2 def = v(D)λ21 λ−λ1 ∥∥xopt∥∥2 2 satisfies (15).\nProof. We have\nEa∼D 1\n2 ∥∥5ψa(xopt)∥∥2(52f(xopt))−1 = Ea∼D 12 ∥∥∥(λI− aa>)xopt − b∥∥∥2B−1 = Ea∼D 1\n2 ∥∥∥(λI− aa>)xopt −Bxopt∥∥∥2 B−1\n= Ea∼D 1\n2 ∥∥∥(Σ− aa>)xopt∥∥∥2 B−1 .\nApplying E ‖a− Ea‖22 = E ‖a‖ 2 2 − ‖Ea‖ 2 2 gives:\nEa∼D ∥∥∥(Σ− aa>)xopt∥∥∥2\nB−1 = Ea∼D\n∥∥xopt∥∥2 aa>B−1aa> − ∥∥xopt∥∥2 ΣB−1Σ ≤ Ea∼D ∥∥xopt∥∥2 aa>B−1aa> .\nFurthermore, since B−1 1λ−λ1 I we have\nEa∼Daa>B−1aa> 1 λ− λ1 Ea∼D(aa>)2\n(∥∥Ea∼D(aa>)2∥∥2 λ− λ1 ) I = ( v(D)λ21 λ− λ1 ) I .\nCombining these three equations yields the result.\nWith the regularity parameters bounded we can apply the streaming SVRG algorithm of [FGKS15a] to solve systems in B. We encapsulate the core iterative step of Algorithm 1 of [FGKS15a] as follows:\nDefinition 21 (Streaming SVRG Step). Given x0 ∈ Rd and η, k,m > 0 we define a streaming SVRG step, x = ssvrg iter(x0, η, k,m) as follows. First we take k samples a1, ..., ak from D and set g = 1k ∑ i∈[k] ψai where ψai is as defined in (13). Then for m̃ chosen uniformly at random from {1, ...,m} we draw m̃ additional samples ã1, ..., ãm̃ from D. For t = 0, ..., m̃− 1 we let\nxt+1 := xt − η\nL (5ψãt(xt)−5ψãt(x0) +5g(x0))\nand return xm̃ as the output.\nThe accuracy of the above iterative step is proven in Theorem 4.1 of [FGKS15a], which we include, using our notation below:\nTheorem 22 (Theorem 4.1 of [FGKS15a] 1). Let f(x) = Ea∼Dψa(x) and let µ, S, σ2 be the strong convexity, smoothness, and variance bounds for f(x). Then for any distribution over x0 we have that x := ssvrg iter(x0, η, k,m) has E[f(x)− f(xopt)] upper bounded by\n1\n1− 4η ( S µmη + 4η )[ Ef(x0)− f(xopt) ] + 1 + 2η k √S µ · [Ef(x0)− f(xopt)] + σ 2 . Using Theorem 22 we can immediately obtain the following guarantee for solve system in B:\nCorollary 23 (Streaming SVRG Solver - With Initial Point). Let µ = λ − λ1, S = λ + v(D)λ21 λ−λ1 , and σ2 = v(D)λ21 λ−λ1 ∥∥xopt∥∥2 2 . Let c2, c3 ∈ (0, 1) be any constants and set η = c28 , m = [ S µc22 ] , and\nk = max {[\nS µc2\n] , [\nv(D)λ21 (λ−λ1)2c3\n]} . If to solve Bx = b for unit vector b with initial point x0, we use the\niterative procedure described in Definition 21 to compute x = ssvrg iter(x0, η, k,m) then: E ∥∥x− xopt∥∥2\nB ≤ 22c2 · ∥∥x0 − xopt∥∥2B + 10c3λ1(B−1). Further, the procedure requires O ( v(D) gap2 [ 1 c22 + 1c3 ]) samples from D.\n1Note that Theorem 4.1 in [FGKS15a] has an additional parameter of α, which bounds the Hessian of f(xopt) in comparison to the Hessian everywhere else. In our setting this parameter is 1 as 52f(y) = 52f(z) for all y and z.\nProof. Using the inequality (x+ y)2 ≤ 2x2 + 2y2 we have that√S µ · E[f(x0)− f(xopt)] + σ 2 ≤ 2S µ · E[f(x0)− f(xopt)] + 2σ2 Additionally, since b is a unit vector, we know that ∥∥xopt∥∥2 2 = ∥∥B−1b∥∥2 2 ≤ 1 (λ−λ1)2 . Using equation\n(10), i.e. that ∥∥x− xopt∥∥2\nB = 2[f(x)− f(xopt)] for all x, we have by Theorem 22:\nE ∥∥x− xopt∥∥2\nB ≤ 1\n1− c2/2\n[( 8c2 +\nc2 2 + 4 + c2 2 · c2 ) · ∥∥x0 − xopt∥∥2B + 4 + c24k · v(D)λ21(λ− λ1)3 ] ≤ 22c2 ·\n∥∥x0 − xopt∥∥2B + 10c3λ− λ1 = 22c2 · ∥∥x0 − xopt∥∥2B + 10c3λ1(B−1). Since 1/(λ− λ1) = λ1(B−1) we see that E ∥∥x− xopt∥∥2 B\nis as desired. All that remains is to bound the number of samples we used.\nNow the number of samples used to compute x is clearly at most m+ k Now\nm = S\nµc22 = O\n( λ\nc22(λ− λ1) + v(D)λ21 c22(λ− λ1)2\n) = O ( 1\nc22gap + v(D) c22gap 2\n) .\n. However since gap < 1 and v(D) ≥ 1 this simplifies to m = O (\nv c22gap 2\n) . Next to bound k\nwe can ignore the [ S µc2 ] term since this was already included in our bound of m and just bound\nv(D)λ21 c3(λ−λ1)2 = O\n( v(D)\ngap2c3\n) yielding our desired sample complexity.\nWhereas in the offline case, we could ensure that our initial error ∥∥x0 − xopt∥∥2B is small by simply scaling by the Rayleigh quotient (Corollary 6) in the online case estimating the Rayleigh quotient to sufficient accuracy would require too many samples. Instead, here simply show how to simply apply Corollary 23 iteratively to solve the desired linear systems to absolute accuracy without an initial point. Ultimately, due to the different error dependences in the online case this guarantee suffices and the lack of an initial point is not a bottleneck.\nCorollary 24 (Streaming SVRG Solver). There is a streaming algorithm that iteratively applies the solver of Corollary 23 to solve Bx = b for unit vector b and returns a vector x that satisfies\nE ∥∥x− xopt∥∥2\nB ≤ 10cλ1(B−1) using O\n( v(D)\ngap2·c\n) samples from D.\nProof. Let x0 = 0. Then ∥∥x0 − xopt∥∥2B = ∥∥B−1b∥∥2B ≤ λ1(B−1) since b is a unit vector. If we apply Corollary 23 with c2 = 1 44 and c3 = 1 20 , then we will obtain x1 with E\n∥∥x1 − xopt∥∥2B ≤ 12λ1(B−1). If we then double c3 and apply the solver again we obtain x2 with E\n∥∥x1 − xopt∥∥2B ≤ 14λ1(B−1). Iterating in this way, after log(1/c) iterations we will have the desired guarantee: E ∥∥x− xopt∥∥2 B ≤ 10cλ1(B −1). Our total sample cost in each iteration is, by Corollary 23, O ( v(D) gap2 [ 1 442 + 1c3 ]) . Since we double c3 each time, the cost corresponding to the 1 c3\nterms is dominated by the last iteration when we have c3 = O(c). So our overall sample cost is just:\nO ( v(D) gap2 [ 1 c + log(1/c) ]) = O ( v(D) gap2 · c ) ."
    }, {
      "heading" : "5.3 Online Shifted-and-Inverted Power Method",
      "text" : "We now apply the results in Section 5.1 and Section 5.2 to the shifted-and-inverted power method framework of Section 3 to give our main result in the online setting, an algorithm that quickly refines a coarse approximation to v1 into a finer approximation.\nTheorem 25 (Online Shifted-and-Inverted Power Method – Warm Start). Let B = λI − A>A for ( 1 + gap150 ) λ1 ≤ λ ≤ ( 1 + gap100 ) λ1 and let x0 be some vector with G(x0) ≤ 1√10 . Running the shifted-and-inverted power method on B initialized with x0, using the streaming SVRG solver of Corollary 24 to approximately apply B−1 at each step, returns x such that x>Σx ≥ (1− )λ1 with constant probability for any target < gap. The algorithm uses O( v(D)gap· ) samples and amortized O(d) time per sample.\nWe note that by instantiating Theorem 25, with ′ = · gap, and applying Lemma 1 we can find x such that |v>1 x| ≥ 1− with constant probability in time O\n( v(D)\ngap2·\n) .\nProof. By Lemma 3 it suffices to have G2(x) = O( gap) or equivalently G(x) = O( √ /gap). In\norder to succed with constant probability it suffices to have E [G(x)] = O( √ /gap) with constant probability. Since we start with G(x0) ≤ 1√10 , we can achieve this using log(gap/ ) iterations of the approximate shifted-and-inverted power method of Theorem 5. In each iteration i we choose\nthe error parameter for Theorem 5 to be c1(i) = 1√ 10 · ( 1 5 )i . Consequently,\nE [G(xi)] ≤ 3\n25 G(xi−1) +\n4\n1000 1√ 10 · ( 1 5 )i and by induction E [G(xi)] ≤ 15i 1√ 10 . We halt when (15) i = O( √ /gap) and hence c1(i) =\nO( √ /gap).\nIn order to apply Theorem 5 we need a subroutine q̂uot (x) that lets us approximate quot(x) to within an additive error 130(λ − λ1) = O(gap · λ1). Theorem 18 gives us such a routine, requiring O (\nv(D) log log(gap/ ) gap2 ) = O( v(D)gap· ) samples to succeed with probability 1 − O ( 1 log(gap/ ) ) (since <\ngap). Union bounding, the estimation succeeds in all rounds with constant probability.\nBy Corollary 24 with c = Θ(c1(i) 2) the cost for solving each linear system solve is O\n( v(D)\ngap2c1(i)2\n) .\nSince c1(i) multiplies by a constant factor with each iteration the cost over all O(log(gap/d ) iterations is just a truncated geometric series and is proportional to cost in the last iteration, when c = Θ (\ngap\n) . So the total cost for solving the linear systems is O ( v(D) gap· ) . Adding this to the\nnumber of samples for the Rayleigh quotient estimation yields the result."
    }, {
      "heading" : "6 Parameter Estimation for Offline Eigenvector Computation",
      "text" : "In Section 4, in order to invoke Theorems 5 and 8 we assumed knowledge of some λ with (1 + c1 · gap)λ1 ≤ λ ≤ (1 + c2 · gap)λ1 for some small constant c1 and c2. Here we show how to estimate this parameter using Algorithm 1, incurring a modest additional runtime cost.\nIn this section, for simplicity we initially assume that we have oracle access to compute B−1λ x for any given x, and any λ > λ1. We will then show how to achieve the same results when we\nAlgorithm 1 Estimating the eigenvalue and the eigengap Input: A ∈ Rn×d, α 1: w = [w1, w2]← N (0, 1)d×2 2: t← O (α log d) 3: [ λ̃\n(0) 1 , λ̃ (0) 2\n] ← eigEstimate (( ATA )t w )\n4: λ (0) ← (1 + 12)λ̃ (0) 1 5: i← 0 6: while λ (i) − λ̃(i)1 < 110 ( λ (i) − λ̃(i)2 ) do 7: i← i+ 1 8: w = [w1, w2]← N (0, 1)d×2\n9:\n[ λ̂\n(i) 1 , λ̂ (i) 2\n] ← eigEstimate (( λ (i−1) I−ATA )−t w ) 10: [ λ̃\n(i) 1 , λ̃ (i) 2\n] ← [ λ\n(i−1) − 1 λ̂ (i) 1 , λ (i−1) − 1 λ̂ (i) 2 ] 11: λ (i) ← 12 ( λ̃ (i) 1 + λ (i−1) ) 12: end while Output: λ\ncan only compute B−1λ x approximately. We use a result of [MM15] that gives gap free bounds for computing eigenvalues using the power method. The following is a specialization of Theorem 1 from [MM15]:\nTheorem 26. For any > 0, any matrix M ∈ Rd×d with eigenvalues λ1, ..., λd, and k ≤ d, let W ∈ Rd×k be a matrix with entries drawn independently from N (0, 1). Let eigEstimate(Y) be a function returning for each i, λ̃i = ṽ > i Mṽi where ṽi is the i\nth largest left singular vector of Y. Then setting [λ̃1, ..., λ̃k] = eigEstimate ( MtW ) , for some fixed constant c and t = cα log d for any α > 1, with probability 1− 1 d10 , we have for all i:\n|λ̃i − λi| ≤ 1\nα λk+1\nThroughout the proof, we assume α is picked to be some large constant - e.g. α > 100. Theorem 26 implies:\nLemma 27. Conditioning on the event that Theorem 26 holds for all iterates i, then the iterates of Algorithm 1 satisfy:\n0 ≤ λ1 − λ̃(0)1 ≤ 1\nα λ1 and\n1\n2\n( 1− 3\nα\n) λ1 ≤ λ (0) − λ1 ≤ 1\n2 λ1, and,\n0 ≤ λ1 − λ̃(i)1 ≤ 1\nα− 1\n( λ (i−1) − λ1 ) and 1\n2\n( 1− 1\nα− 1\n)( λ (i−1) − λ1 ) ≤ λ(i) − λ1 ≤ 1\n2\n( λ (i−1) − λ1 ) .\nProof. The proof can be decomposed into two parts:\nPart I (Lines 3-4): Theorem 26 tells us that λ̃ (0) 1 ≥ ( 1− 1α ) λ1. This means that we have\n0 ≤ λ1 − λ̃(0)1 ≤ 1\nα λ1 and\n1\n2\n( 1− 3\nα\n) λ1 ≤ λ (0) − λ1 ≤ 1\n2 λ1.\nPart II (Lines 5-6): Consider now iteration i. We now apply Theorem 26 to the matrix( λ (i−1) I−ATA )−1 . The top eigenvalue of this matrix is ( λ (i−1) − λ1 )−1 . This means that we\nhave ( 1− 1α ) ( λ (i−1) − λ1 )−1 ≤ λ̂(i)1 ≤ ( λ (i−1) − λ1 )−1 , and hence we have,\n0 ≤ λ1 − λ̃(i)1 ≤ 1\nα− 1\n( λ (i−1) − λ1 ) and 1\n2\n( 1− 1\nα− 1\n)( λ (i−1) − λ1 ) ≤ λ(i) − λ1 ≤ 1\n2\n( λ (i−1) − λ1 ) .\nThis proves the lemma.\nLemma 28. Recall we denote λ2 def = λ2 ( ATA ) and gap\ndef = λ1−λ2λ1 . Then conditioning on the event that Theorem 26 holds for all iterates i, the iterates of Algorithm 1 satisfy ∣∣∣λ2 − λ̃(i)2 ∣∣∣ ≤\n1 α−1\n( λ (i−1) − λ2 ) , and λ (i) − λ̃(i)2 ≥ gapλ1 4 .\nProof. Since ( λ (i−1) − λ2 )−1 is the second eigenvalue of the matrix ( λ (i−1) I−ATA )−1 , Theorem 26 tells us that ( 1− 1\nα\n)( λ (i−1) − λ2 )−1 ≤ λ̂(i)2 ≤ ( 1 + 1\nα\n)( λ (i−1) − λ2 )−1 .\nThis immediately yields the first claim. For the second claim, we notice that\nλ (i) − λ̃(i)2 = λ (i) − λ2 + λ2 − λ̃(i)2 (ζ1)\n≥ λ(i) − λ2 − 1\nα− 1\n( λ (i−1) − λ2 )\n= λ (i) − λ1 −\n1\nα− 1\n( λ (i−1) − λ1 ) + ( 1− 1\nα− 1\n) (λ1 − λ2)\n(ζ2)\n≥ 1 2\n( 1− 3\nα− 1\n)( λ (i−1) − λ1 ) + ( 1− 1\nα− 1\n) (λ1 − λ2) ≥\ngapλ1 4 ,\nwhere (ζ1) follows from the first claim of this lemma, and (ζ2) follows from Lemma 27.\nWe now state and prove the main result in this section:\nTheorem 29. Suppose α > 100, and after T iterations, Algorithm 1 exits. Then with probability 1− ⌈ log 10 gap ⌉ +1\nd10 , we have T ≤ ⌈ log 10gap ⌉ + 1, and:(\n1 + gap\n120\n) λ1 ≤ λ (T ) ≤ ( 1 + gap\n8\n) λ1\nProof. By union bound, we know with probability 1 − ⌈ log 10 gap ⌉ +1\nd10 , Theorem 26 will hold for all iterates where i ≤ ⌈ log 10gap ⌉ + 1.\nLet i = ⌈ log 10gap ⌉ , suppose the algorithm has not exited yet after i iterations, then since λ (i)−λ1\ndecays geometrically, we have λ (i)−λ1 ≤ gapλ110 . Therefore, Lemmas 27 and 28 imply that λ (i+1)− λ̃ (i+1) 1 ≤ ( 1 2 + 1 α−1 )( λ (i) − λ1 ) ≤ gapλ115 , and\nλ (i+1) − λ̃(i+1)2 ≥ λ (i+1) − λ2 − ∣∣∣∣λ2 − λ̃(i+1)2 ∣∣∣∣ ≥ λ1 − λ2 − 1α− 1 ( λ (i) − λ2 )\n= gapλ1 − 1\nα− 1\n( λ (i) − λ1 + λ1 − λ2 ) ≥ 3\n4 gapλ1\nThis means that the exit condition on Line 6 must be triggered in i+ 1 iteration, proving the first part of the lemma.\nFor upper bound, by Lemmas 27, 28 and exit condition we know:\nλ (T ) − λ1 ≤ λ (T ) − λ̃(T )1 ≤ 1\n10 (λ\n(T ) − λ̃(T )2 ) ≤ 1\n10\n( λ (T ) − λ2 + ∣∣∣λ2 − λ̃(T )2 ∣∣∣)\n≤ 1 10\n( λ (T ) − λ2 + 1\nα− 1 (λ\n(T−1) − λ2) )\n= 1\n10\n( α\nα− 1 gapλ1 + (λ\n(T ) − λ1) + 1\nα− 1\n( λ (T−1) − λ1 ))\n≤ 1 10\n( α\nα− 1 gapλ1 +\nα\nα− 2\n( λ (T ) − λ1 ))\nSince α > 100, this directly implies λ (T ) − λ1 ≤ gap8 λ1.\nFor lower bound, since as long as the Algorithm 1 does not exists, by Lemmas 28, we have\nλ (T−1) − λ̃(T−1)1 ≥ 110\n( λ (T−1) − λ̃(T−1)2 ) ≥ gapλ140 , and thus:\nλ (T−1) − λ1 = λ (T−1) − λ̃(T−1)1 − (λ1 − λ̃ (T−1) 1 ) ≥ gapλ1 40 − 1 α− 1\n( λ (T−1) − λ1 )\n≥ gapλ1 40 − 2 α− 2\n( λ (T ) − λ1 ) ≥ gapλ1\n50\nBy Lemma 27, we know λ (T ) − λ1 ≥ 12(1− 1 α−1(λ (T−1) − λ1)) > gap120λ1\nNote that, although we proved the upper bound and lower bound in Theorem 29 with specific constants coefficient 18 and 1 120 , this analysis can easily be extended to any smaller constants by modifying the constant in the exit condition, and choosing α larger. Also in the failure probability\n1−\n⌈ log 10gap ⌉ + 1\nd10 ,\nthe term d10 can be replaced by any poly(d) by adjusting the constant in setting t ← O(α log d) in Algorithm 1. Assuming log 1gap < poly(d), thus gives that Theorem 29 returns a correct result with high probability.\nFinally, we can also bound the runtime of algorithm 1, when we use SVRG based approximate linear system solvers for Bλ.\nTheorem 30. With probability 1−O( 1 d10 log 1gap), Algorithm 1 runs in time\nO ([ nnz(A) + d sr(A)\ngap2\n] · log3 ( d\ngap )) .\nProof. By Theorem 29, we know only O(log 1/gap) iterations of the algorithm are needed. In\neach iteration, the runtime is dominated by running eigEstimate (( λ (i−1) I−ATA )−t w ) , which\nis dominated by computing ( λ (i−1) I−ATA )−t w. Since t = O(log d), it’s easy to verify that:\nto make Theorem 26 hold, we only need to approximate ( λ (i−1) I−ATA )−1 w up to accuracy\npoly(gap/d). By Theorem 12, we know this approximation can be calculated in time\nO ([ nnz(A) + d sr(A)λ21\n(λ (i−1) − λ1)2\n] · log ( d\ngap\n))\n. Combining Theorem 29 with Lemma 27, we know λ (i−1)−λ1 ≥ λ (T )−λ1 ≥ gap120 , thus approximately solving ( λ (i−1) I−ATA )−1 w can be done in time Õ ( nnz(A) + d sr(A)\ngap2\n) . Finally, since the runtime\nof Algorithm 1 is dominated by repeating this subroutine t × T = O(log d · log(1/gap)) times, we finish the proof.\nNote that we can accelerate the runtime of Algorithm 1 to Õ (\nnnz(A)3/4(d sr(A))1/4√ gap\n) , by simply\nreplacing the base solver for ( λ (i−1) I−ATA )−1 w with the accelerated solver in Theorem 15."
    }, {
      "heading" : "7 Lower Bounds",
      "text" : "Here we show that our online eigenvector estimation algorithm (Theorem 25) is asymptotically optimal - as sample size grows large it achieves optimal accuracy as a function of sample size. We rely on the following lower bound for eigenvector estimation in the Gaussian spike model:\nLemma 31 (Lower bound for Gaussian Spike Model [BJNP13]). Suppose data is generated as\nai = √ λιiv ? + Zi (16)\nwhere ιi ∼ N (0, 1), and Zi ∼ N (0, Id). Let v̂ be some estimator of the top eigenvector v?. Then, there is some universal constant c0, so that for n sufficiently large, we have:\ninf v̂ max v?∈Sd−1\nE ‖v̂ − v?‖2 ≥ c0 (1 + λ)d\nλ2n\nTheorem 32. Consider the problem of estimating the top eigenvector v1 of Ea∼Daa>, where we observe n i.i.d samples from unknown distribution D. If gap < 0.9, then there exists some universal constant c, such that for any estimator v̂ of top eigenvector, there always exists some hard distribution D so that for n sufficiently large:\nE ‖v̂ − v1‖22 ≥ c v(D) gap2n\nProof. Suppose the claim of theorem is not true, then there exist some estimator v̂ so that\nE ‖v̂ − v1‖22 < c ′ v(D) gap2n\nholds for all distribution D, and for any fixed constant c′ when n is sufficiently large. Let distribution D be the Gaussian Spike Model specified by Eq.(16), then by calculation, it’s not hard to verify that:\nv(D) =\n∥∥∥Ea∼D [(aa>)2]∥∥∥ 2\n‖Ea∼D(aa>)‖22 = d+ 2 + 3λ 1 + λ\nSince we know gap = λ1+λ < 0.9, this implies λ < 9, which gives v(D) < d+29 1+λ < 30d 1+λ . Therefore, we have that:\nE ‖v̂ − v?‖22 < c ′ v(D) gap2n < 30c′ (1 + λ)d λ2n\nholds for all v? ∈ Sd−1. Choose c′ = c030 in Lemma 31 we have a contradiction.\n‖v̂ − v1‖22 = 2−2v̂>v1, so this bound implies that- to obtain |v̂>v1| ≥ 1− , we need v(D) gap2n = O( ) so n = Θ (\nv(D) gap2\n) . This exactly matches the sample complexity given by Theorem 25."
    }, {
      "heading" : "8 Gap-Free Bounds",
      "text" : "In this section we demonstrate that our techniques can easily be extended to obtain gap-free runtime bounds, for the regime when ≥ gap. In many ways these bounds are actually much easier to achieve than the gap dependent bounds since they require less careful error analysis.\nLet be our error parameter and m be the number of eigenvalues of Σ that are ≥ (1− /2)λ1. Choose λ = λ1 + /100. We have λ1(B\n−1) = 100 λ1 . For i > m we have λi(B −1) < 2 λ1 . κ(B −1) ≤ 100 . Let Vb have columns equal to all bottom eigenvectors with eigenvalues λi < (1− /2)λ1. Let Vt\nhave columns equal to the m remaining top eigenvectors. We define a simple modified potential:\nḠ(x) def = ‖PVbx‖B ‖Pv1x‖B =\n√∑ i>m\nα2i λi(B−1)√ α21\nλ1(B−1)\nWe have the following Lemma connecting this potential function to eigenvalue error:\nLemma 33. For unit x, if Ḡ(x) ≤ c √ for sufficiently small constant c then λ1 − x>Σx ≤ λ1.\nProof.\nḠ(x) ≥ ‖PVbx‖2 ‖Pv1x‖2 ≥ ‖PVbx‖2 ‖PVtx‖2\nSo if Ḡ(x) ≤ c √ then ‖PVtx‖ 2 2 c 2 ≥ ‖PVbx‖ 2 2 and since ‖PVtx‖ 2 2 + ‖PVbx‖ 2 2 = 1, this gives ‖PVtx‖ 2 2 ≥ 1 1+c2 . So we have xTΣx ≥ PVtxTΣxPVt ≥ (1− /2)λ1 1+c2 ≥ 1− for small enough c, giving the lemma.\nWe now follow the proof of Lemma 8, which is actually much simpler in the gap-free case.\nTheorem 34 (Approximate Shifted-and-Inverted Power Method – Gap-Free). Suppose we randomly initialize x0 as in Lemma 7 and suppose we have access to a subroutine solve (·) such that\nE [∥∥solve (x)−B−1x∥∥\nB\n] ≤\n3\n3000d21\n√ λd(B−1)\nThen the following procedure,\nxt = solve (xt−1) / ‖solve (xt−1)‖\nafter T = O (log d/ ) iterations satisfies:\nḠ(xT ) ≤ c √ ,\nwith probability greater than 1−O( 1 d10 ). Proof. By Lemma 7, we know with at least probability 1 − O( 1 d10\n), we have Ḡ(x0) ≤ G(x0) ≤√ κ(B−1)d10.5 = 100d 10.5\n. We want to show by induction that at iteration i we have Ḡ(xi) ≤ 1 2i · 100d10.5 , which will give us the lemma if we set T = log2\n( 100d10.5\nc 1.5\n) = O(log(d/ )).\nLet x̂ = solve (x) and ξ = x̂−B−1x. Following Lemma 8 we have: ‖PVb (x̂)‖B ≤ ∥∥PVb (B−1x)∥∥B + ‖PVb (ξ)‖B ≤ ∥∥PVb (B−1x)∥∥B + ‖ξ‖B\n= √∑ i>m α2iλi(B −1) + ‖ξ‖B\n≤ λm+1(B−1) √√√√∑ i>m α2i λi(B−1) + 3 3000d21 √ λm+1(B−1)  ≤ 2λm+1(B−1) max  √√√√∑\ni>m\nα2i λi(B−1) , 3 3000d21 √ λm+1(B−1)  and\n‖Pv1 (x̂)‖B ≥ ∥∥Pv1 (B−1x)∥∥B − ‖Pv1 (ξ)‖B ≥ ∥∥Pv1 (B−1x)∥∥B − ‖ξ‖B\n= √ α21λ1(B −1)− ‖ξ‖B\n≥ λ1(B−1) √√√√α21 − 6(3000d21)2 λ1(B−1) .\nInitially, we have with high probability, by the argument in Lemma 7, α1 ≥ 1d10 so we have\n‖Pv1 (x̂)‖B ≥ λ1(B−1) 2\n√ α21\nλ1(B−1) . This also holds by induction in each iteration.\nLet α̂1 = |v>1 x̂|/ ‖x̂‖2. ‖Pv1 (x̂)‖ 2 B =\nα̂21‖x̂‖ 2 2\nλ1(B−1) so we have\nα̂21 ≥ λ1(B\n−1)2\n‖x̂‖22\n( α21 −\n6\n(3000d21)2 ) and since ‖x̂‖22 ≤ 2 (∥∥B−1x∥∥2 2 + 2 ‖ξ‖22 ) ≤ λ1(B−1)2 + 2 6 (3000d21)2 ≤ λ1(B−1)2 ( 2 + 2\n6\n(3000d21)2\n) we\nhave:\nα̂21 ≥ 1\n2.1\n( α21 −\n6\n(3000d21)2\n) ≥ 1\n3 α21.\nSo over all log2\n( 100d10.5\nc 1.5 ) iterations, we always have α̂21 ≥ 1d10 · ( c 1.5 100d10.5 )log2 3 and so\n6\n(3000d21)2 <<\n1/2α21. Combining the above bounds:\nḠ(x̂) ≤ 2λm+1\n( B−1 ) λ1 (B−1) /2 · max\n{√∑ i>m α2i λi(B−1) , 3 3000d21 √ λm+1(B−1) } √\nα21 λ1(B−1)\n≤ 4 50\nmax { Ḡ(x), O( √ ) } .\nThis is enough to give the Theorem.\nFinally, we combine Theorem 34 with the SVRG based solvers of Theorem 12 and 15 to obtain:\nTheorem 35 (Gap-Free Shifted-and-Inverted Power Method With SVRG). Let B = λI −A>A for λ = ( 1 + 100 ) and let x0 ∼ N (0, I) be a random initial vector. Running the inverted power method on B initialized with x0, using the SVRG solver from Theorem 12 to approximately apply B−1 at each step, returns x such that with probability 1−O ( 1 d10 ) , x>Σx ≥ (1− )λ1 in time\nO (( nnz(A) + d sr(A)\n2\n) · log2 ( d )) .\nTheorem 36 (Accelerated Gap-Free Shifted-and-Inverted Power Method With SVRG). Let B = λI−A>A for λ = ( 1 + 100 ) and let x0 ∼ N (0, I) be a random initial vector. Running the inverted power method on B initialized with x0, using the SVRG solver from Theorem 15 to approximately apply B−1 at each step, returns x such that with probability 1−O ( 1 d10 ) , x>Σx ≥ (1− )λ1 in total time\nO ( nnz(A)3/4(d sr(A))1/4√ · log3 ( d )) ."
    }, {
      "heading" : "9 Acknowledgements",
      "text" : "Sham Kakade acknowledges funding from the Washington Research Foundation for innovation in Data-intensive Discovery."
    }, {
      "heading" : "A Appendix",
      "text" : "Lemma 37 (Eigenvector Estimation via Spectral Norm Matrix Approximation). Let A>A have top eigenvector 1, top eigenvector v1 and eigenvalue gap gap. Let B\n>B be some matrix with∥∥A>A−B>B∥∥ 2 ≤ O( √ · gap). Let x be the top eigenvector of B>B. Then:\n|x>v1| ≥ 1− .\nProof. We can any unit vector y as y = c1v1 + c2v2 where v2 is the component of x orthogonal to v1 and c 2 1 + c 2 2 = 1. We know that\nv>1 B >Bv1 = v > 1 A >Av1 − vT1 (A>A−B>B)v1 1− √ gap ≤ v>1 B>Bv1 ≤ 1 + √ gap\nSimilarly we can compute:\nv>2 B >Bv2 = v > 2 A >Av2 − vT2 (A>A−B>B)v2 1− gap− √ gap ≤ v>2 B>Bv2 ≤ 1− gap + √ gap.\nand\n|v>1 B>Bv2| = |v>1 A>Av2 − vT1 (A>A−B>B)v2| ≤ √ gap.\nWe have x>BB>x = c21(v > 1 B >Bv1) + c 2 2(v > 2 B >Bv2) + 2c1c2 · v>2 B>Bv1. We want to bound c1 ≥ 1− so c21 ≥ 1−O( ). Since x is the top eigenvector of BB> we have:\nx>BB>x ≥ v>1 BB>v1 c22(v > 2 B >Bv2) + 2c2v > 2 B >Bv1 ≥ (1− c21)v>1 BB>v1\n2 √ 1− c21 √ gap ≥ (1− c21) ( v>1 BB >v1 − v>2 BB>v2 )\n1√ 1− c21 ≥ (1− 2 √ )gap 2 √ gap\n1 1− c21 ≥ 1− 5\n√\n4\nThis means we need have 1− c21 ≤ O( ) meaning c21 ≥ 1−O( ) as desired.\nLemma 38 (Inverted Power Method progress in `2 and B norms). Let x be a unit vector with 〈x, v1〉 6= 0 and let x̃ = B−1w, i.e. the power method update of B−1 on x. Then, we have both:∥∥∥Pv⊥1 x̃∥∥∥B\n‖Pv1 x̃‖B ≤ λ2(B\n−1)\nλ1(B−1) · ∥∥∥Pv⊥1 x∥∥∥B ‖Pv1x‖B\n(17)\nand ∥∥∥Pv⊥1 x̃∥∥∥2 ‖Pv1 x̃‖2 ≤ λ2(B −1) λ1(B−1) · ∥∥∥Pv⊥1 x∥∥∥2 ‖Pv1x‖2\n(18)\nProof. (17) was already shown in Lemma 4. We show (18) similarly. Writing x in the eigenbasis of B−1, we have x = ∑ i αivi and x̃ = ∑ i αiλi ( B−1 ) vi. Since 〈x, v1〉 6= 0, α1 6= 0 and we have:∥∥∥Pv⊥1 x̃∥∥∥2 ‖Pv1 x̃‖2 = √∑ i≥2 α 2 iλ 2 i (B −1)√ α21λ 2 1(B −1) ≤ λ2 ( B−1 ) λ1 (B−1) · √∑ i≥2 α 2 i√ α21 = λ2 ( B−1 ) λ1 (B−1) · ∥∥∥Pv⊥1 x∥∥∥2 ‖Pv1x‖2 ."
    } ],
    "references" : [ {
      "title" : "The fast Johnson-Lindenstrauss transform and approximate nearest neighbors",
      "author" : [ "Nir Ailon", "Bernard Chazelle" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "Ailon and Chazelle.,? \\Q2009\\E",
      "shortCiteRegEx" : "Ailon and Chazelle.",
      "year" : 2009
    }, {
      "title" : "Minimax bounds for sparse PCA with noisy high-dimensional data",
      "author" : [ "Aharon Birnbaum", "Iain M Johnstone", "Boaz Nadler", "Debashis Paul" ],
      "venue" : "Annals of Statistics,",
      "citeRegEx" : "Birnbaum et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Birnbaum et al\\.",
      "year" : 2013
    }, {
      "title" : "Large-scale machine learning with stochastic gradient descent",
      "author" : [ "Léon Bottou" ],
      "venue" : "In Proceedings of COMPSTAT,",
      "citeRegEx" : "Bottou.,? \\Q2010\\E",
      "shortCiteRegEx" : "Bottou.",
      "year" : 2010
    }, {
      "title" : "Uniform sampling for matrix approximation",
      "author" : [ "Michael B Cohen", "Yin Tat Lee", "Cameron Musco", "Christopher Musco", "Richard Peng", "Aaron Sidford" ],
      "venue" : "In Proceedings of the 6th Conference on Innovations in Theoretical Computer Science (ITCS),",
      "citeRegEx" : "Cohen et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Cohen et al\\.",
      "year" : 2015
    }, {
      "title" : "Primal method for ERM with flexible minibatching schemes and non-convex losses",
      "author" : [ "Dominik Csiba", "Peter Richtárik" ],
      "venue" : null,
      "citeRegEx" : "Csiba and Richtárik.,? \\Q2015\\E",
      "shortCiteRegEx" : "Csiba and Richtárik.",
      "year" : 2015
    }, {
      "title" : "Low rank approximation and regression in input sparsity time",
      "author" : [ "Kenneth L Clarkson", "David P Woodruff" ],
      "venue" : "In Proceedings of the 45th Annual ACM Symposium on Theory of Computing (STOC),",
      "citeRegEx" : "Clarkson and Woodruff.,? \\Q2013\\E",
      "shortCiteRegEx" : "Clarkson and Woodruff.",
      "year" : 2013
    }, {
      "title" : "Competing with the empirical risk minimizer in a single pass",
      "author" : [ "Roy Frostig", "Rong Ge", "Sham M Kakade", "Aaron Sidford" ],
      "venue" : "In Proceedings of the 28th Annual Conference on Computational Learning Theory (COLT),",
      "citeRegEx" : "Frostig et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Frostig et al\\.",
      "year" : 2015
    }, {
      "title" : "Un-regularizing: approximate proximal point and faster stochastic algorithms for empirical risk minimization",
      "author" : [ "Roy Frostig", "Rong Ge", "Sham M Kakade", "Aaron Sidford" ],
      "venue" : "In Proceedings of the 32nd International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Frostig et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Frostig et al\\.",
      "year" : 2015
    }, {
      "title" : "Fast and simple PCA via convex optimization",
      "author" : [ "Dan Garber", "Elad Hazan" ],
      "venue" : null,
      "citeRegEx" : "Garber and Hazan.,? \\Q2015\\E",
      "shortCiteRegEx" : "Garber and Hazan.",
      "year" : 2015
    }, {
      "title" : "Robust shift-and-invert preconditioning: Faster and more sample efficient algorithms for eigenvector computation",
      "author" : [ "Chi Jin", "Sham M Kakade", "Cameron Musco", "Praneeth Netrapalli", "Aaron Sidford" ],
      "venue" : null,
      "citeRegEx" : "Jin et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Jin et al\\.",
      "year" : 2015
    }, {
      "title" : "Principal component analysis",
      "author" : [ "Ian Jolliffe" ],
      "venue" : "Wiley Online Library,",
      "citeRegEx" : "Jolliffe.,? \\Q2002\\E",
      "shortCiteRegEx" : "Jolliffe.",
      "year" : 2002
    }, {
      "title" : "On spectral graph drawing",
      "author" : [ "Yehuda Koren" ],
      "venue" : "In Computing and Combinatorics,",
      "citeRegEx" : "Koren.,? \\Q2003\\E",
      "shortCiteRegEx" : "Koren.",
      "year" : 2003
    }, {
      "title" : "Powers of tensors and fast matrix multiplication",
      "author" : [ "François Le Gall" ],
      "venue" : "In Proceedings of the 39th International Symposium on Symbolic and Algebraic Computation,",
      "citeRegEx" : "Gall.,? \\Q2014\\E",
      "shortCiteRegEx" : "Gall.",
      "year" : 2014
    }, {
      "title" : "A universal catalyst for first-order optimization",
      "author" : [ "Hongzhou Lin", "Julien Mairal", "Zaid Harchaoui" ],
      "venue" : null,
      "citeRegEx" : "Lin et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lin et al\\.",
      "year" : 2015
    }, {
      "title" : "Randomized block krylov methods for stronger and faster approximate singular value decomposition",
      "author" : [ "Cameron Musco", "Christopher Musco" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Musco and Musco.,? \\Q2015\\E",
      "shortCiteRegEx" : "Musco and Musco.",
      "year" : 2015
    }, {
      "title" : "On spectral clustering: Analysis and an algorithm",
      "author" : [ "Andrew Y Ng", "Michael I Jordan", "Yair Weiss" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Ng et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Ng et al\\.",
      "year" : 2002
    }, {
      "title" : "The PageRank citation ranking: bringing order to the Web",
      "author" : [ "Lawrence Page", "Sergey Brin", "Rajeev Motwani", "Terry Winograd" ],
      "venue" : null,
      "citeRegEx" : "Page et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Page et al\\.",
      "year" : 1999
    }, {
      "title" : "Numerical methods for large eigenvalue problems",
      "author" : [ "Yousef Saad" ],
      "venue" : null,
      "citeRegEx" : "Saad.,? \\Q1992\\E",
      "shortCiteRegEx" : "Saad.",
      "year" : 1992
    }, {
      "title" : "Convergence of stochastic gradient descent for PCA",
      "author" : [ "Ohad Shamir" ],
      "venue" : null,
      "citeRegEx" : "Shamir.,? \\Q2015\\E",
      "shortCiteRegEx" : "Shamir.",
      "year" : 2015
    }, {
      "title" : "Fast stochastic algorithms for SVD and PCA: Convergence properties and convexity",
      "author" : [ "Ohad Shamir" ],
      "venue" : null,
      "citeRegEx" : "Shamir.,? \\Q2015\\E",
      "shortCiteRegEx" : "Shamir.",
      "year" : 2015
    }, {
      "title" : "A stochastic PCA and SVD algorithm with an exponential convergence rate",
      "author" : [ "Ohad Shamir" ],
      "venue" : "In Proceedings of the 32nd International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Shamir.,? \\Q2015\\E",
      "shortCiteRegEx" : "Shamir.",
      "year" : 2015
    }, {
      "title" : "Spectral graph theory and its applications",
      "author" : [ "Daniel A Spielman" ],
      "venue" : "In null,",
      "citeRegEx" : "Spielman.,? \\Q2007\\E",
      "shortCiteRegEx" : "Spielman.",
      "year" : 2007
    }, {
      "title" : "Global convergence of stochastic gradient descent for some non-convex matrix problems",
      "author" : [ "Christopher D Sa", "Christopher Re", "Kunle Olukotun" ],
      "venue" : "In Proceedings of the 32nd International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Sa et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Sa et al\\.",
      "year" : 2015
    }, {
      "title" : "An introduction to matrix concentration inequalities",
      "author" : [ "Joel A Tropp" ],
      "venue" : null,
      "citeRegEx" : "Tropp.,? \\Q2015\\E",
      "shortCiteRegEx" : "Tropp.",
      "year" : 2015
    }, {
      "title" : "A spectral algorithm for learning mixture models",
      "author" : [ "Santosh Vempala", "Grant Wang" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "Vempala and Wang.,? \\Q2004\\E",
      "shortCiteRegEx" : "Vempala and Wang.",
      "year" : 2004
    }, {
      "title" : "Multiplying matrices faster than CoppersmithWinograd",
      "author" : [ "Virginia Vassilevska Williams" ],
      "venue" : "In Proceedings of the 44th Annual ACM Symposium on Theory of Computing (STOC),",
      "citeRegEx" : "Williams.,? \\Q2012\\E",
      "shortCiteRegEx" : "Williams.",
      "year" : 2012
    } ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "We give faster algorithms and improved sample complexities for estimating the top eigenvector of a matrix Σ – i.e. computing a unit vector x such that x>Σx ≥ (1− )λ1(Σ): • Offline Eigenvector Estimation: Given an explicit A ∈ Rn×d with Σ = A>A, we show how to compute an approximate top eigenvector in time Õ ([ nnz(A) + d sr(A) gap2 ] · log 1/ ) and Õ ([ nnz(A)(d sr(A)) √ gap ] · log 1/ ) . Here nnz(A) is the number of nonzeros in A, sr(A) def = ‖A‖2F ‖A‖22 is the stable rank, gap is the relative eigengap, and Õ(·) hides log factors in d and gap. By separating the gap dependence from the nnz(A) term, our first runtime improves upon the classical power and Lanczos methods. It also improves prior work using fast subspace embeddings [AC09, CW13] and stochastic optimization [Sha15c], giving significantly better dependencies on sr(A) and . Our second running time improves these further when nnz(A) ≤ d sr(A) gap2 . • Online Eigenvector Estimation: Given a distribution D with covariance matrix Σ and a vector x0 which is an O(gap) approximate top eigenvector for Σ, we show how to refine to an approximation using O ( v(D) gap· ) samples from D. Here v(D) is a natural notion of variance. Combining our algorithm with previous work to initialize x0, we obtain improved sample complexity and runtime results under a variety of assumptions on D. We achieve our results using a general framework that we believe is of independent interest. We give a robust analysis of the classic method of shift-and-invert preconditioning to reduce eigenvector computation to approximately solving a sequence of linear systems. We then apply fast stochastic variance reduced gradient (SVRG) based system solvers to achieve our claims. We believe our results suggest the general effectiveness of shift-and-invert based approaches and imply that further computational gains may be reaped in practice. ∗This paper combines work first appearing in [GH15] and [JKM15] ar X iv :1 60 5. 08 75 4v 1 [ cs .D S] 2 6 M ay 2 01 6",
    "creator" : "LaTeX with hyperref package"
  }
}