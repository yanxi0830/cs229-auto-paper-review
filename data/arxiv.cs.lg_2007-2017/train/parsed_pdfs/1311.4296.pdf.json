{
  "name" : "1311.4296.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Reflection methods for user-friendly submodular optimization",
    "authors" : [ "Stefanie Jegelka" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n31 1.\n42 96\nv1 [\ncs .L\nG ]\n1 8\nN ov"
    }, {
      "heading" : "1 Introduction",
      "text" : "Submodularity is a rich combinatorial concept that expresses widely occurring phenomena such as diminishing marginal costs and preferences for grouping. A set function F : 2V → R on a set V is submodular if for all subsets S, T ⊆ V , we have F (S ∪ T ) + F (S ∩ T ) ≤ F (S) + F (T ). Submodular functions underlie the goals of numerous problems in machine learning, computer vision and signal processing [1]. Several problems in these areas can be phrased as submodular optimization tasks: notable examples include graph cut-based image segmentation [9], sensor placement [32], or document summarization [34]. A longer list of examples may be found in [1].\nThe theoretical complexity of submodular optimization is well-understood: unconstrained minimization of submodular set functions is polynomial-time [21] while submodular maximization is NPhard. Algorithmically, however, the picture is different. Generic submodular maximization admits efficient algorithms that can attain approximate optima with global guarantees; these algorithms are typically based on local search techniques [18, 38]. In contrast, although polynomial-time solvable, submodular function minimization (SFM) which seeks to solve\nmin S⊆V F (S), (1)\nposes substantial algorithmic difficulties. This is partly due to the fact that one is commonly interested in an exact solution (or an arbitrarily close approximation thereof), and “polynomial-time” is not necessarily equivalent to “practically fast”.\nSubmodular minimization algorithms may be obtained from two main perspectives: combinatorial and continuous. Combinatorial algorithms for SFM typically use close connections to matroid and\nmaximum flow methods; the currently theoretically fastest combinatorial algorithm for SFM scales as O(n6 + n5τ), where τ is the time to evaluate the function oracle [40] (for an overview of other algorithms, see e.g., [36]). These combinatorial algorithms are typically nontrivial to implement.\nContinuous methods offer an alternative by instead minimizing a convex extension. This idea exploits the fundamental connection between a submodular function F and its Lovász extension f [35], which is continuous and convex. The SFM problem (1) is then equivalent to\nmin x∈[0,1]n f(x). (2)\nThe Lovász extension f is nonsmooth, so we might have to resort to subgradient methods. While a fundamental result of Edmonds [17] demonstrates that a subgradient of f can be computed in O(n log n) time, subgradient methods can be sensitive to choices of the step size, and can be slow. They theoretically converge at a rate of O(1/ √ t) (after t iterations). The “smoothing technique” of [39] does not in general apply here because computing a smoothed gradient is equivalent to solving the submodular minimization problem. We discuss this issue further in Section 2.\nAn alternative to minimizing the Lovász extension directly on [0, 1]n is to consider a slightly modified convex problem. Specifically, the exact solution of the discrete problem minS⊆V F (S) and of its nonsmooth convex relaxation minx∈[0,1]n f(x) may be found as a level set S0 = {k | x∗k > 0} of the unique point x∗ that minimizes the strongly convex function [1, 12]:\nf(x) + 12‖x‖2. (3) We will refer to the minimization of (3) as the proximal problem due to its close similarity to proximity operators used in convex optimization [14]. When F is a cut function, (3) becomes a total variation problem (see, e.g., [11] and references therein) that also occurs in other regularization problems [1]. Two noteworthy points about (3) are: (i) addition of the strongly convex component 1 2‖x‖2; (ii) the ensuing removal of the box-constraints x ∈ [0, 1]n. These changes allow us to consider a convex dual which is amenable to smooth optimization techniques.\nTypical approaches to generic SFM include Frank-Wolfe methods [19] that have cheap iterations and O(1/t) convergence, but can be quite slow in practice (Section 5); or the minimum-normpoint/Fujishige-Wolfe algorithm [22] that has expensive iterations but finite convergence. Other recent methods are approximate [26]. In contrast to several iterative methods based on convex relaxations, we seek to obtain exact discrete solutions.\nTo the best of our knowledge, all generic algorithms that use only submodularity are several orders of magnitude slower than specialized algorithms when they exist (e.g., for graph cuts). However, the submodular function is not always generic and given via a black-box, but has known structure. Following [29, 31, 41, 44], we make the assumption that F (S) =\n∑r i=1 Fi(S) is a sum of sufficiently\n“simple” functions (see Sec. 3). This structure allows the use of (parallelizable) dual decomposition techniques for the problem in Eq. (2), with [13, 41] or without [31] Nesterov’s smoothing technique, or with direct smoothing [44] techniques. But existing approaches typically have two drawbacks: (a) they use smoothing or step-size parameters whose selection may be critical and quite tedious; and (b) they still exhibit slow convergence (see Section 5).\nThese drawbacks arise from working with formulation (2). Our main insight is that, despite seemingly counter-intuitive, the proximal problem (3) offers a much more user-friendly tool for solving (1) than its natural convex counterpart (2), both in implementation and running time. We approach Problem (3) via its dual. This allows decomposition techniques which combine well with orthogonal projection and reflection methods that (a) exhibit faster convergence, (b) are easily parallelizable, (c) require no extra hyperparameters, and (d) are extremely easy to implement.\nThe main three algorithms that we consider are: (i) dual block-coordinate descent (equivalently, primal-dual proximal-Dykstra), which was already shown to be extremely efficient for total variation problems [3] that are special cases of Problem (3); (ii) Douglas-Rachford splitting using the careful variant of [5], which for our formulation (Section 4.2) requires no hyper-parameters; and (iii) accelerated projected gradient [6]. We will see these alternative algorithms can offer speedups beyond known efficiencies. Our observations have two implications: first, from the viewpoint of solving Problem (3), they offers speedups for often occurring denoising and reconstruction problems that employ total variation. Second, our experiments suggest that projection and reflection methods can work very well for solving the combinatorial problem (1).\nIn summary, we make the following contributions:\n(1) In Section 3, we cast the problem of minimizing decomposable submodular functions as an orthogonal projection problem and show how existing optimization techniques may be brought to bear on this problem, to obtain fast, easy-to-code and easily parallelizable algorithms. In addition, we show examples of classes of functions amenable to our approach. In particular, for simple functions, i.e., those for which minimizing F (S)− a(S) is easy for all vectors1 a ∈ Rn, the problem in Eq. (3) may be solved in O(log 1ε ) calls to such minimization routines, to reach a precision ε (Section 2, 3, Appendix B). (2) In Section 5, we demonstrate the empirical gains of using accelerated proximal methods, Douglas-Rachford and block coordinate descent methods over existing approaches: fewer hyperparameters and faster convergence."
    }, {
      "heading" : "2 Review of relevant results from submodular analysis",
      "text" : "The relevant concepts we review here are the Lovász extension, base polytopes of submodular functions, and relationships between proximal and discrete problems. For more details, see [1, 21].\nLovász extension and convexity. The power set 2V may be naturally identified with the vertices of the hypercube, i.e., {0, 1}n. The Lovász extension f of any set function is defined by linear interpolation, so that for any S ⊂ V , F (S) = f(1S). It may be computed in closed form once the components of x are sorted: if xσ(1) > · · · > xσ(n), then f(x) = ∑n k=1 xσ(k) [\nF ({σ(1), . . . , σ(k)})− F ({σ(1), . . . , σ(k − 1)}) ] [35]. For the graph cut function, f is the total variation.\nIn this paper, we are going to use two important results: (a) if the set function F is submodular, then its Lovász extension f is convex, and (b) minimizing the set function F is equivalent to minimizing f(x) with respect to x ∈ [0, 1]n. Given x ∈ [0, 1]n, all of its level sets may be considered and the function may be evaluated (at most n times) to obtain a set S. Moreover, for a submodular function, the Lovász extension happens to be the support function of the base polytope B(F ) defined as B(F ) = {y ∈ Rn | ∀S ⊂ V, y(S) 6 F (S) and y(V ) = F (V )}, that is f(x) = maxy∈B(F ) y⊤x [17]. A maximizer of y⊤x (and hence the value of f(x)), may be computed by the “greedy algorithm”, which first sorts the components of w in decreasing order xσ(1) > · · · > xσ(n), and then compute yσ(k) = F ({σ(1), . . . , σ(k)})− F ({σ(1), . . . , σ(k − 1)}). In other words, a linear function can be maximized over B(F ) in time O(n log n + nτ) (note that the term nτ may be improved in many special cases). This is crucial for exploiting convex duality.\nDual of discrete problem. We may derive a dual problem to the discrete problem in Eq. (1) and the convex nonsmooth problem in Eq. (2), as follows:\nmin S⊆V F (S) = min x∈[0,1]n f(x) = min x∈[0,1]n max y∈B(F ) y⊤x = max y∈B(F ) min x∈[0,1]n y⊤x = max y∈B(F ) (y)−(V ), (4)\nwhere (y)− = min{y, 0} applied elementwise. This allows to obtain dual certificates of optimality from any y ∈ B(F ) and x ∈ [0, 1]n. Proximal problem. The optimization problem (3), i.e., minx∈Rn f(x) + 12‖x‖2, has intricate relations to the SFM problem [12]. Given the unique optimal solution x∗ of (3), the maximal (resp. minimal) optimizer of the SFM problem is the set S∗ of nonnegative (resp. positive) elements of x∗. More precisely, solving (3) is equivalent to minimizing F (S) + µ|S| for all µ ∈ R. A solution Sµ ⊆ V is obtained from a solution x∗ as S∗µ = {i | x∗i > µ}. Conversely, x∗ may be obtained from all S∗µ as x ∗ k = sup{µ ∈ R | k ∈ S∗µ} for all k ∈ V . Moreover, if x is an ε-optimal solution\nof Eq. (3), then we may construct √ εn-optimal solutions for all Sµ [1; Prop. 10.5]. In practice, the duality gap of the discrete problem is usually much lower than that of the proximal version of the same problem, as we will see in Section 5. Note that the problem in Eq. (3) provides much more information than Eq. (2), as all µ-parameterized discrete problems are solved.\nThe dual problem of Problem (3) reads as follows:\nmin x∈Rn f(x)+ 12‖x‖22 = minx∈Rn maxy∈B(F ) y ⊤x+ 12‖x‖22 = maxy∈B(F ) minx∈Rn y ⊤x+ 12‖x‖22 = maxy∈B(F )− 1 2‖y‖22, where primal and dual variables are linked as x = −y. Observe that this dual problem is equivalent to finding the orthogonal projection of 0 onto B(F ).\n1Every vector a ∈ Rn may be viewed as a modular (linear) set function: a(S) , ∑\ni∈S a(i).\nDivide-and-conquer strategies for the proximal problems. Given a solution x∗ of the proximal problem, we have seen how to get S∗µ for any µ by simply thresholding x\n∗ at µ. Conversely, one can recover x∗ exactly from at most n well-chosen values of µ. A known divide-and-conquer strategy [21, 23] hinges upon the fact that for any µ, one can easily see which components of x∗ are greater or smaller than µ by computing S∗µ. The resulting algorithm makes O(n) calls to the submodular function oracle. In Appendix B, we extend an alternative approach by Tarjan et al. [45] for cuts to general submodular functions and obtain a solution to (3) up to precision ε in O(min{n, log 1ε}) iterations. This result is particularly useful if our function F is a sum of functions for each of which by itself the SFM problem is easy. Beyond squared ℓ2-norms, our algorithm equally applies to computing all minimizers of f(x) +\n∑p j=1 hj(xj) for arbitrary smooth strictly convex functions hj ,\nj = 1, . . . , n."
    }, {
      "heading" : "3 Decomposition of submodular functions",
      "text" : "Following [29, 31, 41, 44], we assume that our function F may be decomposed as the sum F (S) = ∑r\nj=1 Fj(S) of r “simple” functions. In this paper, by “simple” we mean functions G for which G(S) − a(S) can be minimized efficiently for all vectors a ∈ Rn (more precisely, we require that S 7→ G(S∪T )−a(S) can be minimized efficiently over all subsets of V \\T , for any T ⊆ V and a). Efficiency may arise from the functional form of G, or from the fact that G has small support. For such functions, Problems (1) and (3) become\nmin S⊆V\n∑r\nj=1 Fj(S) = min x∈[0,1]n\n∑r\nj=1 fj(x) min x∈Rn\n∑r\nj=1 fj(x) +\n1 2‖x‖22. (5)\nThe key to the algorithms presented here is to be able to minimize 12‖x−z‖22+fj(x), or equivalently, to orthogonally project z onto B(Fj): min 12‖y − z‖22 subject to y ∈ B(Fj). We next sketch some examples of functions F and their decompositions into simple functions Fj . As shown at the end of Section 2, projecting onto B(Fj) is easy as soon as the corresponding submodular minimization problems are easy. Here we outline some cases for which specialized fast algorithms are known.\nGraph cuts. A widely used class of submodular functions are graph cuts. Graphs may be decomposed into substructures such as trees, simple paths or single edges. Message passing algorithms apply to trees, while the proximal problem for paths is very efficiently solved by [3]. For single edges, it is solvable in closed form. Tree decompositions are common in graphical models, whereas path decompositions are frequently used for TV problems [3].\nConcave functions. Another important class of submodular functions is that of concave functions of cardinality, i.e., Fj(S) = h(|S|) for a concave function h. Problem (3) for such functions may be solved in O(n log n) time (see [20] and Appendix B). Functions of this class have been used in [26, 28, 44]. Such functions also include covering functions [44].\nHierarchical functions. Here, the ground set corresponds to the leaves of a rooted, undirected tree. Each node has a weight, and the cost of a set of nodes S ⊆ V is the sum of the weights of all nodes in the smallest subtree (including the root) that spans S. This class of functions too admits to solve the proximal problem in O(n logn) time [24, 25]. Related tree functions have been considered in [27], where the elements v of the ground set are arranged in a tree of height d and each have a weight w(v). Let desc(v) be the set of descendants of v in the tree. Then F (S) = ∑\nv∈V w(v)1[dec(v) ∩ S 6= ∅]. Jenatton et al. [27] show how to solve the proximal problem for such a function in time O(nd).\nSmall support. Any general, potentially slower algorithm such as the minimum-norm-point algorithm can be applied if the support of each Fj is only a small subset of the ground set."
    }, {
      "heading" : "3.1 Dual decomposition of the nonsmooth problem",
      "text" : "We first review existing dual decomposition techniques for the nonsmooth problem (1). We always assume that F =\n∑r j=1 Fj , and define Hr := ∏r j=1 R n ≃ Rn×r. We follow [31] to derive a dual formulation (see Appendix A):\nLemma 1. The dual of Problem (1) may be written in terms of variables λ1, . . . , λr ∈ Rn as\nmax ∑r\nj=1 gj(λj) s.t. λ ∈\n{ (λ1, . . . , λr) ∈ Hr | ∑r\nj=1 λj = 0\n}\n(6)\nwhere gj(λj) = minS⊂V Fj(S)− λj(S) is a nonsmooth concave function.\nThe dual is the maximization of a nonsmooth concave function over a convex set, onto which it is easy to project: the projection of a vector y has j-th block equal to yj − 1r ∑r k=1 yk. Moreover, in our setup, functions gj and their subgradients may be computed efficiently through SFM.\nWe consider several existing alternatives for the minimization of f(x) on x ∈ [0, 1]n, most of which use Lemma 1. Computing subgradients for any fj means calling the greedy algorithm, which runs in time O(n logn). All of the following algorithms require the tuning of an appropriate step size.\nPrimal subgradient descent (primal-sgd): Agnostic to any decomposition properties, we may apply a standard simple subgradient method to f . A subgradient of f may be obtained from the subgradients of the components fj . This algorithm converges at rate O(1/ √ t).\nDual subgradient descent (dual-sgd) [31]: Applying a subgradient method to the nonsmooth dual in Lemma 1 leads to a convergence rate of O(1/ √ t). Computing a subgradient requires minimizing the submodular functions Fj individually. In simulations, following [31], we consider a step-size rule similar to Polyak’s rule (dual-sgd-P) [7], as well as a decaying step-size (dual-sgd-F), and use discrete optimization for all Fj .\nPrimal smoothing (primal-smooth) [44]: The nonsmooth primal may be smoothed in several ways by smoothing the fj individually; one example is f̃ εj (xj) = maxyj∈B(Fj) y ⊤ j xj− ε2‖yj‖2. This leads to a function that is (1/ε)-smooth. Computing f̃ εj means solving the proximal problem for Fj . The convergence rate is O(1/t), but, apart from the step size which may be set relatively easily, the smoothing constant ε needs to be defined.\nDual smoothing (dual-smooth): Instead of the primal, the dual (6) may be smoothed, e.g., by entropy [10, 41] applied to each gj as g̃εj (λj) = minx∈[0,1]n fj(x)+ εh(x) where h(x) is a negative entropy. Again, the convergence rate is O(1/t) but there are two free parameters (in particular the smoothing constant ε which is hard to tune). This method too requires solving proximal problems for all Fj in each iteration.\nDual smoothing with entropy also admits coordinate descent methods [37] that exploit the decomposition, but we do not compare to those here."
    }, {
      "heading" : "3.2 Dual decomposition methods for proximal problems",
      "text" : "We may also consider Eq. (3) and first derive a dual problem using the same technique as in Section 3.1. Lemma 2 (proved in Appendix A) formally presents our dual formulation as a best approximation problem. The primal variable can be recovered as x = −∑j yj . Lemma 2. The dual of Eq. (3) may be written as the best approximation problem\nmin λ,y\n‖y − λ‖22 s.t. λ ∈ { (λ1, . . . , λr) ∈ Hr | ∑r\nj=1 λj = 0\n} , y ∈ ∏r\nj=1 B(Fj). (7)\nWe can actually eliminate the λj and obtain the simpler looking dual problem\nmax y −1 2\n∥ ∥ ∥ ∑r\nj=1 yj\n∥ ∥ ∥ 2\n2 s.t. yj ∈ B(Fj), j ∈ {1, . . . , r} (8)\nSuch a dual was also used in [43]. In Section 5, we will see the effect of solving one of these duals or the other. For the simpler dual (8) the case r = 2 is of special interest; it reads\nmax y1∈B(F1), y2∈B(F2) −1 2 ‖y1 + y2‖22 ⇐⇒ min y1∈B(F1),−y2∈−B(F2) ‖y1 − (−y2)‖2. (9)\nWe write Problem (9) in this suggestive form to highlight its key geometric structure: it is, like (7), a best approximation problem: i.e., the problem of finding the closest point between the polytopes B(F1) and −B(F2). Notice, however, that (7) is very different from (9)—the former operates in a product space while the latter does not, a difference that can have impact in practice (see Section 5). We are now ready to present algorithms that exploit our dual formulations."
    }, {
      "heading" : "4 Algorithms",
      "text" : "We describe a few competing methods for solving our smooth dual formulations. We describe the details for the special 2-block case (9); the same arguments apply to the block dual from Lemma 2."
    }, {
      "heading" : "4.1 Block coordinate descent or proximal-Dykstra",
      "text" : "Perhaps the simplest approach to solving (9) (viewed as a minimization problem) is to use a block coordinate descent (BCD) procedure, which in this case performs the alternating projections:\nyk+11 ← argminy1∈B(F1) ‖y1 − (−yk2 )‖22; yk+12 ← argminy2∈B(F2) ‖y2 − (−yk+11 )‖2. (10) The iterations for solving (8) are analogous. This BCD method (applied to (9)) is equivalent to applying the so-called proximal-Dykstra method [14] to the primal problem. This may be seen by comparing the iterates. Notice that the BCD iteration (10) is nothing but alternating projections onto the convex polyhedra B(F1) and B(F2). There exists a large body of literature studying method of alternating projections—we refer the interested reader to the monograph [15] for further details.\nHowever, despite its attractive simplicity, it is known that BCD (in its alternating projections form), can converge arbitrarily slowly [5] depending on the relative orientation of the convex sets onto which one projects. Thus, we turn to a potentially more effective method."
    }, {
      "heading" : "4.2 Douglas-Rachford splitting",
      "text" : "The Douglas-Rachford (DR) splitting method [16] includes algorithms like ADMM as a special case [14]. It avoids the slowdowns alluded to above by replacing alternating projections with alternating “reflections”. Formally, DR applies to convex problems of the form [4, 14]\nminx φ1(x) + φ2(x), (11)\nsubject to the qualification ri(domφ1) ∩ ri(domφ2) 6= ∅. To solve (11), DR starts with some z0, and performs the three-step iteration (for k ≥ 0): 1. xk = proxφ2(zk); 2. vk = proxφ1(2xk − zk); 3. zk+1 = zk + γk(vk − zk), (12) where γk ∈ [0, 2] is a sequence of scalars that satisfy ∑\nk γk(2 − γk) = ∞. The sequence {xk} produced by iteration (12) can be shown to converge to a solution of (11) [4; Thm. 25.6].\nIntroducing the reflection operator Rφ := 2 proxφ − I, and setting γk = 1, the DR iteration (12) may be written in a more symmetric form as\nxk = proxφ2(zk), zk+1 = 1 2 [Rφ1Rφ2 + I]zk, k ≥ 0. (13)\nApplying DR to the duals (7) or (9), requires first putting them in the form (11), either by introducing extra variables or by going back to the primal, which is unnecessary. This is where the special structure of our dual problem proves crucial, a recognition that is subtle yet remarkably important.\nInstead of applying DR to (9), consider the closely related problem\nminy δ1(y) + δ − 2 (y), (14)\nwhere δ1, δ − 2 are indicator functions for B(F1) and −B(F2), respectively. Applying DR directly to (14) does not work because usually ri(dom δ1) ∩ ri(dom δ2) = ∅. Indeed, applying DR to (14) generates iterates that diverge to infinity [5; Thm. 3.13(ii)]. Fortunately, even though the DR iterates for (14) may diverge, Bauschke et al. [5] show how to extract convergent sequences from these iterates, which actually solve the corresponding best approximation problem; for us this is nothing but the dual (9) that we wanted to solve in the first place. Theorem 3, which is a simplified version of [5; Thm. 3.13], formalizes the above discussion. Theorem 3. [5] Let A and B be nonempty polyhedral convex sets. Let ΠA (ΠB) denote orthogonal projection onto A (B), and let RA := 2ΠA − I (similarly RB) be the corresponding reflection operator. Let {zk} be the sequence generated by the DR method (13) applied to (14). If A∩B 6= ∅, then {zk}k≥0 converges weakly to a fixed-point of the operator T := 12 [RARB + I]; otherwise‖zk‖2 → ∞. The sequences {xk} and {ΠAΠBzk} are bounded; the weak cluster points of either of the two sequences {(ΠARBzk, xk)}k≥0 {(ΠAxk, xk)}k≥0, (15) are solutions best approximation problem mina,b ‖a− b‖ such that a ∈ A and b ∈ B.\nThe key consequence of Theorem 3 is that we can apply DR with impunity to (14), and extract from its iterates the optimal solution to problem (9) (from which recovering the primal is trivial). The most important feature of solving the dual (9) in this way is that absolutely no stepsize tuning is required, making the method very practical and user friendly (see also Appendix D)."
    }, {
      "heading" : "5 Experiments",
      "text" : "We empirically compare the proposed projection methods2 to the (smoothed) subgradient methods discussed in Section 3.1. For solving the proximal problem, we apply block coordinate descent (BCD) and Douglas-Rachford (DR) to Problem (8) if applicable, and also to (7) (BCD-para, DRpara). In addition, we use acceleration to solve (8) or (9) [6]. The main iteration cost of all methods except for the primal subgradient method is the orthogonal projection onto polytopes B(Fj), and therefore the number of iterations is a suitable criterion for comparisons. The primal subgradient method uses the greedy algorithm in each iteration, which runs in O(n log n). However, as we will see, its convergence is so slow to counteract any benefit that may arise from not using projections. We do not include Frank-Wolfe methods here, since FW is equivalent to a subgradient descent on the primal and converges correspondingly slowly.\nAs benchmark problems, we use (i) graph cut problems for segmentation, or MAP inference in a 4-neighborhood grid-structured MRF, and (ii) concave functions similar to those used in [44], but together with graph cut functions. The segmentation problems (i) are set up in a fairly standard way on a 4-neighbor grid graph, with unary potentials derived from Gaussian Mixture Models of color features. The weight of graph edge (i, j) is a function of exp(−‖yi − yj‖2), where yi is the RGB color vector of pixel i. The functions in (i) decompose as sums over vertical and horizontal paths. All horizontal paths are independent and can be solved together in parallel, and similarly all vertical paths. The functions in (ii) are constructed by extracting regions Rj via superpixels [33] and, for each Rj , defining the function Fj(S) = |S||Rj \\ S|. We use 200 and 500 regions. The problems have size 640 × 427. Hence, for (i) we have r = 640 + 427 (but solve it as r = 2) and for (ii) r = 640 + 427 + 500 (solved as r = 3).\nFor algorithms working with formulation (7), we compute an improved smooth duality gap of a current primary solution x = −∑j yj as follows: find y′ ∈ argmaxy∈B(F ) x⊤y (then f(x) = x⊤y′) and find an improved x′ by minimizing minz z⊤y′ + 12‖z‖2 subject to the constraint that z has the same ordering as x [1]. The constraint ensures that (x′)⊤y′ = f(x′). This is an isotonic regression problem and can be solved in time O(n) using the “pool adjacent violators” algorithm [1]. The gap is then f(x′) + 12‖x′‖2 − (− 12‖y′‖2). For computing the discrete gap, we find the best level set Si of x and, using y′ = −x, compute mini F (Si)− y′−(V ). Two functions (r = 2). Figure 2 shows the duality gaps for the discrete and smooth (where applicable) problems for two instances of segmentation problems. The algorithms working with the proximal problems are much faster than the ones directly solving the nonsmooth problem. In particular DR converges extremely fast, faster even than BCD which is known to be a state-of-the-art algorithms for this problem [3]. This, in itself, is a new insight for solving TV. We also see that the discrete gap shrinks faster than the smooth gap, i.e., the optimal discrete solution does not require to solve the smooth problem to extremely high accuracy. Figure 1 illustrates example results for different gaps.\nMore functions (r > 2). Figure 3 shows example results for four problems of sums of concave and cut functions. Here, we can only run DR-para. Overall, BCD, DR-para and the accelerated gradient method perform very well.\n2Code and data corresponding to this paper are available at https://sites.google.com/site/mloptstat/drsubmod\nParallel speedups If we aim for parallel methods, then again DR outperforms BCD. Figure 4 (right) shows the speedup gained from parallel processing for r = 2. Using 8 cores, we obtain a 5-fold speed-up.\nRunning time compared to graph cuts Table 1 shows the running times of our DR method (implemented in Matlab/C++) and the Maxflow code of [8, 9, 30] (using the wrapper [2]) for the four graph cut (segmentation) instances above on a MacBook Air with a 2 GHz Intel Core i7. The running times are averages over 5 repetitions. DR was run for 10, 10, 21, and 20 iterations, respectively.\nDR is by a factor of 2-9 slower than the specialized code. Given that, as opposed to the combinatorial algorithm, DR solves the full regularization path, is parallelizable, generic and straightforwardly extends to a variety of functions, this is remarkable.\nIn summary, our experiments suggest that projection methods can be extremely useful for solving the combinatorial submodular minimization problem. Of the tested methods, DR, cyclic BCD and accelerated gradient perform very well. For parallelism, applying DR on (9) converges much faster than BCD on the same problem."
    }, {
      "heading" : "6 Conclusion",
      "text" : "We have presented a novel approach to submodular function minimization based on the equivalence with a best approximation problem. The use of reflection methods avoids any hyperparameters and reduce the number of iterations significantly, suggesting the suitability of reflection methods for combinatorial problems. Given the natural parallelization abilities of our approach, it would be interesting to perform detailed empirical comparisons with existing parallel implementations of graph cuts (e.g., [42]). Moreover, a generalization beyond submodular functions of the relationships between combinatorial optimization problems and convex problems would enable the application of our framework to other common situations such as multiple labels (see, e.g., [31]).\nAcknowledgments. This research was in part funded by the Office of Naval Research under contract/grant number N00014-11-1-0688, by NSF CISE Expeditions award CCF-1139158, by DARPA XData Award FA8750-12-2-0331, and the European Research Council (SIERRA project), as well as gifts from Amazon Web Services, Google, SAP, Blue Goji, Cisco, Clearstory Data, Cloudera, Ericsson, Facebook, General Electric, Hortonworks, Intel, Microsoft, NetApp, Oracle, Samsung, Splunk, VMware and Yahoo!. We would like to thank Martin Jaggi, Simon Lacoste-Julien and Mark Schmidt for discussions."
    }, {
      "heading" : "A Derivations of Dual Problems",
      "text" : ""
    }, {
      "heading" : "A.1 Proof of Lemma 1",
      "text" : "Proof. To derive the non-smooth dual problem, we follow [31] and use Lagrangian duality:\nmin x∈[0,1]n f(x) = min x∈[0,1]n\n∑r\nj=1 fj(x) = min\nx1,...,xr∈[0,1]n\n∑r\nj=1 fj(xj) such that x1 = · · · = xr\n= min x∈Rn, x1,...,xr∈[0,1]n max (λj)\n∑r\nj=1 fj(xj) +\n∑r\nj=1 λ⊤j (x− xj)\n= max∑r j=1 λj=0\n∑r\nj=1 min\nxj∈[0,1]n\n{ fj(xj)− λ⊤j xj }\n= max∑r j=1 λj=0\n∑r\nj=1 max yj∈B(Fj) (yj − λj)−(V ) = max∑r\nj=1 λj=0\n∑r\nj=1 gj(λj),\nwhere gj(λj) = minA⊂V Fj(A)−λj(A) is a nonsmooth concave function, which may be computed efficiently through submodular function minimization."
    }, {
      "heading" : "A.2 Proof of Lemma 2",
      "text" : "Proof. The proof follows a similar saddle-point approach.\nmin x∈Rn f(x) + 12‖x‖22 = minx∈Rn ∑r j=1 fj(x) + 1 2‖x‖22\n= min x1,...,xr∈Rn\n∑r\nj=1\n{ fj(xj) + 1\n2r ‖xj‖22\n}\nsuch that x1 = · · · = xr\n= min x∈Rn, x1,...,xr∈Rn max λj\n∑r\nj=1\n{ fj(xj) + 1\n2r ‖xj‖22 + λ⊤j (x− xj)\n}\n= max∑ r j=1 λj=0\n∑r\nj=1 min xj∈Rn\n{ fj(xj)− λ⊤j xj + 12r‖xj‖22 }\n= max∑ r j=1 λj=0\n∑r\nj=1 min xj∈Rn\n{\nmax yj∈B(Fj)\nx⊤j yj − λ⊤j xj + 12r‖xj‖22 }\n= max∑r j=1 λj=0\n∑r\nj=1 max yj∈B(Fj) − r2‖yj − λj‖22\n= max∑r j=1 λj=0 max yj∈B(Fj) − r 2\nr ∑\nj=1\n‖yj − λj‖22. (16)\nWriting (16) as a minimization problem and ignoring constants completes the proof."
    }, {
      "heading" : "B Divide-and-conquer algorithm for parametric submodular minimization",
      "text" : ""
    }, {
      "heading" : "B.1 Description of the algorithm",
      "text" : "The optimal solution x∗ of our proximal problem minx∈Rn f(x) + ‖x‖2 indicates the minimizers of F (S) − λ|S| for all λ ∈ R. Those minimizers form a chain S∅ ⊂ S1 ⊂ . . . ⊂ Sk = V . The solutions are the level sets of the optimal solution x∗.\nHere, we extend the approach of Tarjan et al. [45] for parametric max-flow to all submodular functions and all monotone strictly convex functions beyond the square functions used in the main paper. More precisely, we consider a submodular function F defined on V = {1, . . . , n} and n differentiable strictly convex functions hi such that their Fenchel-conjugates h∗i have full domain, for\ni ∈ {1, . . . , n}. The functions h∗i are then differentiable. We consider the following problem:\nmin x∈Rn f(x) +\nn ∑\ni=1\nhi(xi) = min x∈Rn max y∈B(F )\ny⊤x+\nn ∑\ni=1\nhi(xi) (17)\n= max y∈B(F ) min x∈Rn\ny⊤x+\nn ∑\ni=1\nhi(xi) (18)\n= max y∈B(F )\n− n ∑\ni=1\nh∗i (−yi). (19)\nThe optimality conditions are\n1. y ∈ B(F ), 2. y⊤x = f(x),\n3. −yi = h′i(xi) ⇔ xi = (h∗i )′(−yi).\nLet τ(V ) be the time for minimizing the submodular function F (S) + a(S) on the ground set V (for any a ∈ Rn). For our complexity analysis, we make the assumption that minimizing the (contracted) function FS,a(T ) , F (S ∪ T )− F (S) + a(T ) on the smaller ground set U ⊆ V \\ S (for any a ∈ Rn, S ⊆ V , U ⊆ V \\S) takes time at most |U||V |τ(V ). This is a reasonable assumption, because it essentially says that τ(V ) grows at least linearly in the size of V . To our knowledge, even fast algorithms for special submodular functions take at least linear time.\nWe will also use the notation F (S | T ) , F (S ∪ T )− F (S). For recursions, we use the restriction FS : 2\nS → R, FS(T ) = F (T ) of F to S and the contraction FS : 2V \\S → R, FS(T ) = F (T | S) of F on S.\nAlgorithm 1: Recursive Divide-and-Conquer"
    }, {
      "heading" : "SplitInterval (λmin, λmax, V , F , i)",
      "text" : "if i even then\n// unbalanced split λ ← argminλ ∑\ni hi(λ) − λF (V ) A ← argminT⊆V F (T ) + ∑ i∈T h ′ i(λ) if S = ∅ or S = V then return x = λ1V\nend else\n// balanced split λ ← (λmin + λmax)/2 S ← argminT⊆V F (T ) + ∑ i∈T h ′ i(λ) if S = ∅ then x ← SplitInterval (λmin, λ, V , F , i+ 1) return x\nend if S = V then\nx ← SplitInterval (λ, λmax, V , F , i+ 1) return x\nend end // S 6= ∅ and S 6= V xS ← SplitInterval (λmin, λ, S, FA, i+ 1) xV \\S ← SplitInterval (λ, λmax, V \\ S, FS , i+ 1) return [xS , xV \\S ]\nAlgorithm 1 is a divide-and-conquer algorithm. In each recursive call, it takes an interval [λmin, λmax] in which all components of the optimal solution lie and either (a) shortens the search\ninterval for any break point, (b) finds the optimal (constant) value of x on a range of elements, or (c) recursively splits the problem into a set S and V \\ S with corresponding ranges for the values of x∗ and finds the optimal values of x on the two subsets."
    }, {
      "heading" : "B.2 Review of related results",
      "text" : "The goal of this appendix is to show Proposition 4 below. We first start by reviewing existing results regarding separable problems on the base polyhedron (see [1] for details).\nIt is known that if y ∈ B(F ), then yk ∈ [ F (V )−F (V \\{k}), F ({k}) ]\n; thus, the optimal solution x is such that xk ∈ [ (h∗k) ′(−F ({k})), (h∗k)′(F (V \\{k})−F (V )) ]\n. We therefore set the initial search range to\nλmin = min k∈V\n(h∗k) ′(−F ({k})) and λmax = max k∈V (h∗k) ′(F (V \\{k})− F (V )).\nThe algorithm relies on the following facts (see [1] for a proof). For all three propositions, we assume that the hi are strictly convex, continuously differentiable functions on R such that supλ∈R h\n′(λ) = +∞ and infλ∈R h′(λ) = −∞. Proposition 1 (Monotonicity of optimizing sets). Let α < β and Sα be any minimizer of F (S) + h′(α)(S) and Sβ any minimizer of F (S) + h′(β)(S). Then Sβ ⊆ Sα. Proposition 2 (Characterization of x∗). The coordinates x∗j (j ∈ V ) of the unique optimal solution x∗ of Problem 17 are x∗j = max{λ | j ∈ Sλ}, where Sλ is any minimizer of F (S) + h′(λ)(S).\nPropositions 1 and 2 imply that the level sets of x∗ form a chain ∅ = S0 ⊂ S1 ⊂ . . . ⊂ Sk = V of maximal minimizers for the critical values of λ (which are the entries of x∗). (Each Si = Sλ for some λ = x∗j .)\nProposition 3 (Splits). Let T = Si be a level set of x∗ and let y ∈ RT , z ∈ RV \\T be the minimizers of the subproblems\ny = argmin x\nfT (x) + ∑\ni∈T\nhi(xi)\nz = argmin x\nfT (x) + ∑\ni/∈T\nhi(xi)"
    }, {
      "heading" : "Then x∗j = yj for j ∈ T and x∗j = zj for j ∈ V \\ T .",
      "text" : "The algorithm uses Proposition 3 recursively.\nProof. Let λ be the value in x∗ defining Si = Sλ. It is easy to see that the restriction FT and the contraction FT are both submodular. Hence, Propositions 1 and 2 hold for them.\nSince the restriction on T is equivalent to the original function for any S ⊆ T , F (S) + h(λ)(S) = FT (S) + hT (λ)(S) for any S ⊆ T . With this, Propositions 1 and 2 imply that for any α > λ, F (S) + h(λ)(S) = FT (S) + hT (λ)(S) and therefore x∗j = yj for j ∈ T .\nSimilarly, for any S ∈ V \\ T , it holds that F (S ∪ T ) + h(λ)(S ∪ T ) = FT (S) + (h′(λ))T (S) + F (T ) + h′(λ)(T ). Due to the monotonicity property of the optimizing sets, Sα ⊇ T for all α < λ, and therefore the maximal minimizer Uα of FT (S) + (h′(α))T (S) satisfies Uα ∪ T = Sα (the terms F (T ) + h′(λ)(T ) are constant with respect to U ). Hence Poposition 2 implies that x∗j = zj for j ∈ V \\ T .\nThese propositions imply that there is a set of at most n values of λ = α that define the level sets Sα of the optimal solution x∗. If we know these break point values, then we know x∗. Algorithm 1 interleaves an unbalanced split strategy that may split the seach interval in an unbalanced way but converges in O(n) recursive calls, and a balanced split strategy that always halves the search intervals but is not finitely convergent."
    }, {
      "heading" : "B.3 Proof of convergence",
      "text" : "We now prove the convergence rate for Algorithm 1. Proposition 4. The minimum of f(x) +\n∑n i=1 hi(xi) may be obtained up to coordinate-wise accu-\nracy ǫ within O (\nmin{n, log 1ǫ} )\n(20)\nsubmodular function minimizations. If hi(xi) = 12x 2 i , then ǫ = ∆min n2ℓ0 is sufficient to recover the exact solution, where ∆min = min{|F (S | T )| | S ⊆ V \\ T, F (S | T ) 6= 0} and ℓ0 is the length of the initial interval [λmin, λmax].\nProof. The proof relies on Propositions 1, 2 and 3.\nWe first argue for the correctness of the balanced splitting strategy. Propositions 1 and 2 imply that for any λ ∈ R, if S is a minimizer of F (S) + h′(λ)(S), then the unique minimum of f(x) + ∑n\ni=1 hi(xi) satisfies that for all k ∈ S, xk > h′k(λ) and for all k ∈ V \\S, xk 6 h′k(λ). In particular, if S = ∅, then this means that for all k ∈ V , xk 6 h′k(λ). Similarly, if S = V , then for all k ∈ V , xk > h ′ k(λ). The limits of the interval are set accordingly. The correctness of the recursive call follows from Proposition 3.\nIn each iteration, the size of the search interval [λmin, λmax] for any break point is at least halved. Hence, within d recursions, the length of each interval is at most 2−dℓ0.\nThe choice of λ in the unbalanced splitting strategy corresponds to solving a simplified version of the dual problem. Indeed, by convex duality, the following two problems are dual to each other:\nmax y\n− ∑\ni\nh∗i (−yi) s.t. y(V ) = F (V ) (21)\nmin λ∈R\n∑\ni∈V\nhi(λ)− λF (V ). (22)\nProblem (21) replaces the constraint that y ∈ B(F ) by y(V ) = F (V ), dropping the constraint that y(S) ≤ F (S) for all S ⊆ V . Testing whether y satisfies all constraints of (19), i.e., y ∈ B(F ) is equivalent to testing whether F (S) − y(S) ≥ 0. We do this implicitly by our choice of λ: Convex duality implies that the the optimal solutions of Problems (21) and (22) satisfy yi = −h′i(λ). This holds in particular for the chosen (unique optimal) λ in the algorithm.\nLet T be a minimizer of F (S) + h′(λ)(S) = F (S) − y(S). If T = ∅ or T = V , then y ∈ B(F ) and an optimal solution for the full dual problem (19). Hence, y and x = λ1V = (h∗)′(−y) form a primal/dual optimal pair for (19).\nIf ∅ ⊂ T ⊂ V and F (T ) − y(T ) < 0, then y /∈ B(F ), and we perform a split with the same argumentation as above. This splitting strategy is exactly that of [1, 23] and splits at most n times. Hence, this strategy yields the global optimum (to machine precision) in the time of O(n) times solving a submodular minimization on V . If n is large, this may be computationally expensive.\nIf we only do balanced splits, we end up approaching the break points more and more closely (but typically never exactly). Unbalanced splits always find an exact break point, but with potentially little progress in reducing the intervals. Algorithm 1 thus interleaves both strategies where we store intervals of allowed values for subsets of components of A. At step d there are at most min{n, 2d} different intervals (as there cannot be more intervals than elements of V ). To split these intervals, submodular function minimization problems have to be solved on each of these intervals, with total complexity less than a single submodular function optimization problem on the full set. At each iteration, intervals corresponding to a singleton may be trivially completely solved, and components which are already found are discarded. Hence, at each recursive level, the total computation time is bounded above by τ(V ).\nWhile balanced splits always substantially shrink the intervals, they are not finitely convergent. Unbalanced splits converge after at most n recursions. Following the argumentation of Tarjan et al. [45], who considered the special case of flows, alternating the two types of splits gives the best of both worlds: (a) all components are estimated up to precision ℓ0\n2d/2 , and (b) the algorithm is finitely con-\nvergent, and will stop when ℓ0 2d/2 is less than the minimal distance between two different components of x.\nFinally, we adress the precision for the special case that hi(xi) = 12x 2 i for all i ∈ V . If the interval lengths are smaller than the smallest gap between any two break points (components of x∗), then each interval contains at most one break point and the algorithm converges after at most two unbalanced splits. Hence, we here consider ǫ to be one half times the smallest gap between any two break points. Let ∅ = S0 ⊂ S1 ⊂ . . . ⊂ Sk = V be the chain of level sets of x∗. By the optimality conditions discussed above for unbalanced splits, any constant part T = Si \\ Si−1 of x∗ takes value λ1 = −yj1 (j ∈ T ), where y(T ) = FSi−1(T ), and hence\nλ = −F (Si \\ Si−1|Si−1)|Si \\ Si−1| . (23)\nTherefore, the (absolute) difference between any two such values is loosely lower bounded by\nmin i\n∣ ∣ ∣ ∣ F (Si \\ Si−1|Si−1) |Si \\ Si−1| − F (Si+1 \\ Si|Si)|Si+1 \\ Si| ∣ ∣ ∣ ∣ ≥ ∆min ( 2 n− 1 − 2 n ) ≥ 2∆min n2 . (24)\nThis implies O(log(ℓ0n2/∆min)) iterations.\nNote that in the case of flows, the algorithm is not exactly equivalent to the flow algorithm of [45], which updates flows directly."
    }, {
      "heading" : "C BCD and proximal Dykstra",
      "text" : "We consider the best approximation problem\nmin 12‖x− y‖22 s.t. x ∈ C1 ∩ C2 ∩ · · · ∩ Cm.\nLet us show the details for only the two block case. The general case follows similarly.\nConsider the more general problem\nmin 12‖x− y‖22 + f(x) + h(x). (25) Clearly, this problem contains the two-block best approximation problem as a special case (by setting f and h to be suitable indicator functions). Now introduce two variables z, w that equal x; then the corresponding Lagrangian is\nL(x, z, w, ν, µ) := 12‖x− y‖22 + f(z) + h(w) + νT (x− z) + µT (x− w). From this Lagrangian, a brief calculation yields the dual optimization problem\nmin g(ν, µ) := 12‖ν + µ− y‖22 + f∗(ν) + h∗(µ). We solve this dual problem via BCD, which has the updates\nνk+1 = argminν g(ν, µk), µk+1 = argminµ g(νk+1, µ).\nThus, 0 ∈ νk+1 +µk − y+ ∂f∗(νk+1) and 0 ∈ νk+1 +µk+1− y+ ∂h∗(µk+1). The first optimality condition may be rewritten as\ny−µk ∈ νk+1+∂f∗(νk+1) =⇒ νk+1 = proxf∗(y−µk) =⇒ νk+1 = y−µk−proxf (y−µk). Similarly, we second condition yields µk+1 = y − νk+1 − proxh(y − νk+1). Now use Lagrangian stationarity x = y − ν − µ =⇒ y − µ = x+ ν to rewrite BCD using primal and dual variables to obtain the so-called proximal-Dykstra method:\ntk ← proxf (xk + νk) νk+1 ← xk + νk − tk xk+1 ← proxh(µk + tk) µk+1 ← µk + tk − xk+1\nWe discussed the more general problem (25) because it contains the smoothed primal as a special case, namely with y = 0 in (25), f = f1, and h = f2, we obtain\nmin f1(x) + f2(x) + 1 2‖x‖22,\nfor which BCD yields the proximal-Dykstra method that was previously used in [3] for twodimensional TV optimization."
    }, {
      "heading" : "D Recipe: Submodular minimization via reflections",
      "text" : "To be precise, we summarize here how to solve Problem (17) via reflections. As we showed above, the dual is of the form\nmin λ,y\n‖y − λ‖22 s.t. λ ∈ A = { (λ1, . . . , λr) ∈ Hr | ∑r\nj=1 λj = 0\n} , y ∈ B , ∏r\nj=1 B(Fj).\n(26)\nThe vector y consists of r parts yj ∈ B(Fj). We first solve the dual by starting with any z(0) ∈ Hr, and iterate\nz(k+1) = 12 (z k +RARB(z (k))). (27)\nUpon convergence to a point z∗, we extract the components\nyj = ΠB(Fj)(z ∗ j ). (28)\nThe final primal solution is x = −∑j yj ∈ Rn."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2013,
    "abstractText" : "Recently, it has become evident that submodularity naturally captures widely oc-<lb>curring concepts in machine learning, signal processing and computer vision. Con-<lb>sequently, there is need for efficient optimization procedures for submodular func-<lb>tions, especially for minimization problems. While general submodular minimiza-<lb>tion is challenging, we propose a new method that exploits existing decomposabil-<lb>ity of submodular functions. In contrast to previous approaches, our method is<lb>neither approximate, nor impractical, nor does it need any cumbersome parame-<lb>ter tuning. Moreover, it is easy to implement and parallelize. A key component<lb>of our method is a formulation of the discrete submodular minimization problem<lb>as a continuous best approximation problem that is solved through a sequence of<lb>reflections, and its solution can be easily thresholded to obtain an optimal discrete<lb>solution. This method solves both the continuous and discrete formulations of<lb>the problem, and therefore has applications in learning, inference, and reconstruc-<lb>tion. In our experiments, we illustrate the benefits of our method on two image<lb>segmentation tasks.",
    "creator" : "LaTeX with hyperref package"
  }
}