{
  "name" : "1407.0202.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "SAGA: A Fast Incremental Gradient Method With Support for Non-Strongly Convex Composite Objectives",
    "authors" : [ "Aaron Defazio" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Remarkably, recent advances [1, 2] have shown that it is possible to minimise strongly convex finite sums provably faster in expectation than is possible without the finite sum structure. This is significant for machine learning problems as a finite sum structure is common in the empirical risk minimisation setting. The requirement of strong convexity is likewise satisfied in machine learning problems in the typical case where a quadratic regulariser is used.\nIn particular, we are interested in minimising functions of the form\nf(x) = 1\nn n∑ i=1 fi(x),\nwhere x ∈ Rd, each fi is convex and has Lipschitz continuous derivatives with constant L. We will also consider the case where each fi is strongly convex with constant µ, and the “composite” (or proximal) case where an additional regularisation function is added:\nF (x) = f(x) + h(x),\nwhere h : Rd → Rd is convex but potentially non-differentiable, and where the proximal operation of h is easy to compute — few incremental gradient methods are applicable in this setting [3][4].\nOur contributions are as follows. In Section 2 we describe the SAGA algorithm, a novel incremental gradient method. In Section 5 we prove theoretical convergence rates for SAGA in the strongly convex case better than those for SAG [1] and SVRG [5], and a factor of 2 from the SDCA [2] convergence rates. These rates also hold in the composite setting. Additionally, we show that ∗The first author completed this work while under funding from NICTA. This work was partially supported by the MSR-Inria Joint Centre and a grant by the European Research Council (SIERRA project 239993).\nar X\niv :1\n40 7.\n02 02\nv3 [\ncs .L\nG ]\nlike SAG but unlike SDCA, our method is applicable to non-strongly convex problems without modification. We establish theoretical convergence rates for this case also. In Section 3 we discuss the relation between each of the fast incremental gradient methods, showing that each stems from a very small modification of another."
    }, {
      "heading" : "2 SAGA Algorithm",
      "text" : "We start with some known initial vector x0 ∈ Rd and known derivatives f ′i(φ0i ) ∈ Rd with φ0i = x0 for each i. These derivatives are stored in a table data-structure of length n, or alternatively a n× d matrix. For many problems of interest, such as binary classification and least-squares, only a single floating point value instead of a full gradient vector needs to be stored (see Section 4). SAGA is inspired both from SAG [1] and SVRG [5] (as we will discuss in Section 3). SAGA uses a step size of γ and makes the following updates, starting with k = 0:\nSAGA Algorithm: Given the value of xk and of each f ′i(φki ) at the end of iteration k, the updates for iteration k + 1 is as follows:\n1. Pick a j uniformly at random.\n2. Take φk+1j = x k, and store f ′j(φ k+1 j ) in the table. All other entries in the table remain\nunchanged. The quantity φk+1j is not explicitly stored.\n3. Update x using f ′j(φ k+1 j ), f ′ j(φ k j ) and the table average: wk+1 = xk − γ [ f ′j(φ k+1 j )− f ′j(φkj ) + 1\nn n∑ i=1 f ′i(φ k i )\n] , (1)\nxk+1 = proxhγ ( wk+1 ) . (2)\nThe proximal operator we use above is defined as\nproxhγ (y) := argmin x∈Rd\n{ h(x) + 1\n2γ ‖x− y‖2\n} . (3)\nIn the strongly convex case, when a step size of γ = 1/(2(µn+L)) is chosen, we have the following convergence rate in the composite and hence also the non-composite case:\nE ∥∥∥xk − x∗∥∥∥2 ≤ (1− µ\n2(µn+ L) )k [∥∥x0 − x∗∥∥2 + n µn+ L [ f(x0)− 〈 f ′(x∗), x0 − x∗ 〉 − f(x∗) ]] .\nWe prove this result in Section 5. The requirement of strong convexity can be relaxed from needing to hold for each fi to just holding on average, but at the expense of a worse geometric rate (1 −\nµ 6(µn+L) ), requiring a step size of γ = 1/(3(µn+ L)).\nIn the non-strongly convex case, we have established the convergence rate in terms of the average iterate, excluding step 0: x̄k = 1k ∑k t=1 x t. Using a step size of γ = 1/(3L) we have\nE [ F (x̄k) ] − F (x∗) ≤ 4n\nk\n[ 2L\nn ∥∥x0 − x∗∥∥2 + f(x0)− 〈f ′(x∗), x0 − x∗〉− f(x∗)] . This result is proved in the supplementary material. Importantly, when this step size γ = 1/(3L) is used, our algorithm automatically adapts to the level of strong convexity µ > 0 naturally present, giving a convergence rate of (see the comment at the end of the proof of Theorem 1):\nE ∥∥∥xk − x∗∥∥∥2 ≤ (1−min{ 1\n4n , µ 3L })k [∥∥x0 − x∗∥∥2 + 2n 3L [ f(x0)− 〈 f ′(x∗), x0 − x∗ 〉 − f(x∗) ]] .\nAlthough any incremental gradient method can be applied to non-strongly convex problems via the addition of a small quadratic regularisation, the amount of regularisation is an additional tunable parameter which our method avoids."
    }, {
      "heading" : "3 Related Work",
      "text" : "We explore the relationship between SAGA and the other fast incremental gradient methods in this section. By using SAGA as a midpoint, we are able to provide a more unified view than is available in the existing literature. A brief summary of the properties of each method considered in this section is given in Figure 1. The method from [3], which handles the non-composite setting, is not listed as its rate is of the slow type and can be up to n times smaller than the one for SAGA or SVRG [5].\nSAGA: midpoint between SAG and SVRG/S2GD\nIn [5], the authors make the observation that the variance of the standard stochastic gradient (SGD) update direction can only go to zero if decreasing step sizes are used, thus preventing a linear convergence rate unlike for batch gradient descent. They thus propose to use a variance reduction approach (see [7] and references therein for example) on the SGD update in order to be able to use constant step sizes and get a linear convergence rate. We present the updates of their method called SVRG (Stochastic Variance Reduced Gradient) in (6) below, comparing it with the non-composite form of SAGA rewritten in (5). They also mention that SAG (Stochastic Average Gradient) [1] can be interpreted as reducing the variance, though they do not provide the specifics. Here, we make this connection clearer and relate it to SAGA.\nWe first review a slightly more generalized version of the variance reduction approach (we allow the updates to be biased). Suppose that we want to use Monte Carlo samples to estimate EX and that we can compute efficiently EY for another random variable Y that is highly correlated with X . One variance reduction approach is to use the following estimator θα as an approximation to EX: θα := α(X−Y )+EY , for a step size α ∈ [0, 1]. We have that Eθα is a convex combination of EX and EY : Eθα = αEX + (1− α)EY . The standard variance reduction approach uses α = 1 and the estimate is unbiased Eθ1 = EX . The variance of θα is: Var(θα) = α2[Var(X) + Var(Y )− 2 Cov(X,Y )], and so if Cov(X,Y ) is big enough, the variance of θα is reduced compared to X , giving the method its name. By varying α from 0 to 1, we increase the variance of θα towards its maximum value (which usually is still smaller than the one for X) while decreasing its bias towards zero.\nBoth SAGA and SAG can be derived from such a variance reduction viewpoint: here X is the SGD direction sample f ′j(x k), whereas Y is a past stored gradient f ′j(φ k j ). SAG is obtained by using α = 1/n (update rewritten in our notation in (4)), whereas SAGA is the unbiased version with α = 1 (see (5) below). For the same φ’s, the variance of the SAG update is 1/n2 times the one of SAGA, but at the expense of having a non-zero bias. This non-zero bias might explain the complexity of the convergence proof of SAG and why the theory has not yet been extended to proximal operators. By using an unbiased update in SAGA, we are able to obtain a simple and tight theory, with better constants than SAG, as well as theoretical rates for the use of proximal operators.\n(SAG) xk+1 = xk − γ [ f ′j(x\nk)− f ′j(φkj ) n + 1 n n∑ i=1 f ′i(φ k i )\n] , (4)\n(SAGA) xk+1 = xk − γ [ f ′j(x k)− f ′j(φkj ) + 1\nn n∑ i=1 f ′i(φ k i )\n] , (5)\n(SVRG) xk+1 = xk − γ [ f ′j(x k)− f ′j(x̃) + 1\nn n∑ i=1 f ′i(x̃)\n] . (6)\nThe SVRG update (6) is obtained by using Y = f ′j(x̃) with α = 1 (and is thus unbiased – we note that SAG is the only method that we present in the related work that has a biased update direction). The vector x̃ is not updated every step, but rather the loop over k appears inside an outer loop, where x̃ is updated at the start of each outer iteration. Essentially SAGA is at the midpoint between SVRG and SAG; it updates the φj value each time index j is picked, whereas SVRG updates all of φ’s as a batch. The S2GD method [8] has the same update as SVRG, just differing in how the number of inner loop iterations is chosen. We use SVRG henceforth to refer to both methods.\nSVRG makes a trade-off between time and space. For the equivalent practical convergence rate it makes 2x-3x more gradient evaluations, but in doing so it does not need to store a table of gradients, but a single average gradient. The usage of SAG vs. SVRG is problem dependent. For example for linear predictors where gradients can be stored as a reduced vector of dimension p− 1 for p classes, SAGA is preferred over SVRG both theoretically and in practice. For neural networks, where no theory is available for either method, the storage of gradients is generally more expensive than the additional backpropagations, but this is computer architecture dependent.\nSVRG also has an additional parameter besides step size that needs to be set, namely the number of iterations per inner loop (m). This parameter can be set via the theory, or conservatively as m = n, however doing so does not give anywhere near the best practical performance. Having to tune one parameter instead of two is a practical advantage for SAGA.\nFinito/MISOµ\nTo make the relationship with other prior methods more apparent, we can rewrite the SAGA algorithm (in the non-composite case) in term of an additional intermediate quantity uk, with u0 := x0 + γ ∑n i=1 f ′ i(x 0), in addition to the usual xk iterate as described previously:\nSAGA: Equivalent reformulation for non-composite case: Given the value of uk and of each f ′i(φ k i ) at the end of iteration k, the updates for iteration k + 1, is as follows:\n1. Calculate xk: xk = uk − γ n∑ i=1 f ′i(φ k i ). (7)\n2. Update u with uk+1 = uk + 1n (x k − uk).\n3. Pick a j uniformly at random.\n4. Take φk+1j = x k, and store f ′j(φ k+1 j ) in the table replacing f ′ j(φ k j ). All other entries in\nthe table remain unchanged. The quantity φk+1j is not explicitly stored.\nEliminating uk recovers the update (5) for xk. We now describe how the Finito [9] and MISOµ [10] methods are closely related to SAGA. Both Finito and MISOµ use updates of the following form, for a step length γ:\nxk+1 = 1\nn ∑ i φki − γ n∑ i=1 f ′i(φ k i ). (8)\nThe step size used is of the order of 1/µn. To simplify the discussion of this algorithm we will introduce the notation φ̄ = 1n ∑ i φ k i .\nSAGA can be interpreted as Finito, but with the quantity φ̄ replaced with u, which is updated in the same way as φ̄, but in expectation. To see this, consider how φ̄ changes in expectation:\nE [ φ̄k+1 ] = E [ φ̄k + 1\nn\n( xk − φkj )] = φ̄k + 1\nn\n( xk − φ̄k ) .\nThe update is identical in expectation to the update for u, uk+1 = uk + 1n (x k − uk). There are three advantages of SAGA over Finito/MISOµ. SAGA does not require strong convexity to work, it has support for proximal operators, and it does not require storing the φi values. MISO has proven support for proximal operators only in the case where impractically small step sizes are used [10]. The big advantage of Finito/MISOµ is that when using a per-pass re-permuted access ordering, empirical speed-ups of up-to a factor of 2x has been observed. This access order can also be used with the other methods discussed, but with smaller empirical speed-ups. Finito/MISOµ is particularly useful when fi is computationally expensive to compute compared to the extra storage costs required over the other methods.\nSDCA\nThe Stochastic Dual Coordinate Descent (SDCA) [2] method on the surface appears quite different from the other methods considered. It works with the convex conjugates of the fi functions. However, in this section we show a novel transformation of SDCA into an equivalent method that only works with primal quantities, and is closely related to the MISOµ method.\nConsider the following algorithm:\nSDCA algorithm in the primal Step k + 1:\n1. Pick an index j uniformly at random.\n2. Compute φk+1j = prox fj γ (z), where γ = 1µn and z = −γ ∑n i6=j f ′ i(φ k i ).\n3. Store the gradient f ′j(φ k+1 j ) = 1 γ ( z − φk+1j ) in the table at location j. For i 6= j, the\ntable entries are unchanged (f ′i(φ k+1 i ) = f ′ i(φ k i )).\nAt completion, return xk = −γ∑ni f ′i(φki ) . We claim that this algorithm is equivalent to the version of SDCA where exact block-coordinate maximisation is used on the dual.1 Firstly, note that while SDCA was originally described for onedimensional outputs (binary classification or regression), it has been expanded to cover the multiclass predictor case [11] (called Prox-SDCA there). In this case, the primal objective has a separate strongly convex regulariser, and the functions fi are restricted to the form fi(x) := ψi(XTi x), where Xi is a d×p feature matrix, and ψi is the loss function that takes a p dimensional input, for p classes. To stay in the same general setting as the other incremental gradient methods, we work directly with the fi(x) functions rather than the more structured ψi(XTi x). The dual objective to maximise then becomes\nD(α) = −µ 2 ∥∥∥∥∥ 1µn n∑ i=1 αi ∥∥∥∥∥ 2 − 1 n n∑ i=1 f∗i (−αi)  , where αi’s are d-dimensional dual variables. Generalising the exact block-coordinate maximisation update that SDCA performs to this form, we get the dual update for block j (with xk the current primal iterate):\nαk+1j = α k j + argmax\n∆aj∈Rd\n{ −f∗j ( −αkj −∆αj ) − µn\n2 ∥∥∥∥xk + 1µn∆αj ∥∥∥∥2 } . (9)\nIn the special case where fi(x) = ψi(XTi x), we can see that (9) gives exactly the same update as Option I of Prox-SDCA in [11, Figure 1], which operates instead on the equivalent p-dimensional dual variables α̃i with the relationship that αi = Xiα̃i.2 As noted by Shalev-Shwartz & Zhang [11], the update (9) is actually an instance of the proximal operator of the convex conjugate of fj . Our primal formulation exploits this fact by using a relation between the proximal operator of a function and its convex conjugate known as the Moreau decomposition:\nproxf ∗ (v) = v − proxf (v).\nThis decomposition allows us to compute the proximal operator of the conjugate via the primal proximal operator. As this is the only use in the basic SDCA method of the conjugate function, applying this decomposition allows us to completely eliminate the “dual” aspect of the algorithm, yielding the above primal form of SDCA. The dual variables are related to the primal representatives φi’s through αi = −f ′i(φi). The KKT conditions ensure that if the αi values are dual optimal then xk = γ ∑ i αi as defined above is primal optimal. The same trick is commonly used to interpret Dijkstra’s set intersection as a primal algorithm instead of a dual block coordinate descent algorithm [12].\nThe primal form of SDCA differs from the other incremental gradient methods described in this section in that it assumes strong convexity is induced by a separate strongly convex regulariser, rather than each fi being strongly convex. In fact, SDCA can be modified to work without a separate regulariser, giving a method that is at the midpoint between Finito and SDCA. We detail such a method in the supplementary material.\n1More precisely, to Option I of Prox-SDCA as described in [11, Figure 1]. We will simply refer to this method as “SDCA” in this paper for brevity.\n2This is because f∗i (αi) = inf α̃i s.t. αi=Xiα̃i ψ∗i (α̃i).\nSDCA variants\nThe SDCA theory has been expanded to cover a number of other methods of performing the coordinate step [11]. These variants replace the proximal operation in our primal interpretation in the previous section with an update where φk+1j is chosen so that: f ′ j(φ k+1 j ) = (1−β)f ′j(φkj )+βf ′j(xk),\nwhere xk = − 1µn ∑ i f ′ i(φ k i ). The variants differ in how β ∈ [0, 1] is chosen. Note that φk+1j does not actually have to be explicitly known, just the gradient f ′j(φ k+1 j ), which is the result of the above interpolation. Variant 5 by Shalev-Shwartz & Zhang [11] does not require operations on the conjugate function, it simply uses β = µnL+µn . The most practical variant performs a line search involving the convex conjugate to determine β. As far as we are aware, there is no simple primal equivalent of this line search. So in cases where we can not compute the proximal operator from the standard SDCA variant, we can either introduce a tuneable parameter into the algorithm (β), or use a dual line search, which requires an efficient way to evaluate the convex conjugates of each fi."
    }, {
      "heading" : "4 Implementation",
      "text" : "We briefly discuss some implementation concerns:\n• For many problems each derivative f ′i is just a simple weighting of the ith data vector. Logistic regression and least squares have this property. In such cases, instead of storing the full derivative f ′i for each i, we need only to store the weighting constants. This reduces the storage requirements to be the same as the SDCA method in practice. A similar trick can be applied to multi-class classifiers with p classes by storing p− 1 values for each i.\n• Our algorithm assumes that initial gradients are known for each fi at the starting point x0. Instead, a heuristic may be used where during the first pass, data-points are introduced oneby-one, in a non-randomized order, with averages computed in terms of those data-points processed so far. This procedure has been successfully used with SAG [1].\n• The SAGA update as stated is slower than necessary when derivatives are sparse. A just-intime updating of u or x may be performed just as is suggested for SAG [1], which ensures that only sparse updates are done at each iteration.\n• We give the form of SAGA for the case where each fi is strongly convex. However in practice we usually have only convex fi, with strong convexity in f induced by the addition of a quadratic regulariser. This quadratic regulariser may be split amongst the fi functions evenly, to satisfy our assumptions. It is perhaps easier to use a variant of SAGA where the regulariser µ2 ||x||2 is explicit, such as the following modification of Equation (5):\nxk+1 = (1− γµ)xk − γ [ f ′j(x k)− f ′j(φkj ) + 1\nn ∑ i f ′i(φ k i )\n] .\nFor sparse implementations instead of scaling xk at each step, a separate scaling constant βk may be scaled instead, with βkxk being used in place of xk. This is a standard trick used with stochastic gradient methods.\nFor sparse problems with a quadratic regulariser the just-in-time updating can be a little intricate. In the supplementary material we provide example python code showing a correct implementation that uses each of the above tricks."
    }, {
      "heading" : "5 Theory",
      "text" : "In this section, all expectations are taken with respect to the choice of j at iteration k + 1 and conditioned on xk and each f ′i(φ k i ) unless stated otherwise.\nWe start with two basic lemmas that just state properties of convex functions, followed by Lemma 1, which is specific to our algorithm. The proofs of each of these lemmas is in the supplementary material. Lemma 1. Let f(x) = 1n ∑n i=1 fi(x). Suppose each fi is µ-strongly convex and has Lipschitz continuous gradients with constant L. Then for all x and x∗:\n〈f ′(x), x∗ − x〉 ≤ L− µ L [f(x∗)− f(x)]− µ 2 ‖x∗ − x‖2\n− 1 2Ln ∑ i ‖f ′i(x∗)− f ′i(x)‖ 2 − µ L 〈f ′(x∗), x− x∗〉 .\nLemma 2. We have that for all φi and x∗:\n1\nn ∑ i ‖f ′i(φi)− f ′i(x∗)‖ 2 ≤ 2L\n[ 1\nn ∑ i fi(φi)− f(x∗)− 1 n ∑ i 〈f ′i(x∗), φi − x∗〉 ] .\nLemma 3. It holds that for any φki , x∗, xk and β > 0, with wk+1 as defined in Equation 1: E ∥∥∥wk+1 − xk − γf ′(x∗)∥∥∥2 ≤ γ2(1 + β−1)E∥∥∥f ′j(φkj )− f ′j(x∗)∥∥∥2 + γ2(1 + β)E ∥∥∥f ′j(xk)− f ′j(x∗)∥∥∥2\n− γ2β ∥∥∥f ′(xk)− f ′(x∗)∥∥∥2 .\nTheorem 1. With x∗ the optimal solution, define the Lyapunov function T as:\nT k := T (xk, {φki }ni=1) := 1\nn ∑ i fi(φ k i )− f(x∗)− 1 n ∑ i 〈 f ′i(x ∗), φki − x∗ 〉 + c ∥∥xk − x∗∥∥2 .\nThen with γ = 12(µn+L) , c = 1 2γ(1−γµ)n , and κ = 1 γµ , we have the following expected change in the Lyapunov function between steps of the SAGA algorithm (conditional on T k):\nE[T k+1] ≤ (1− 1 κ )T k.\nProof. The first three terms in T k+1 are straight-forward to simplify:\nE\n[ 1\nn ∑ i fi(φ k+1 i )\n] = 1\nn f(xk) +\n( 1− 1\nn\n) 1\nn ∑ i fi(φ k i ).\nE [ − 1 n ∑ i 〈 f ′i(x ∗), φk+1i − x∗ 〉] = − 1 n 〈 f ′(x∗), xk − x∗ 〉 − ( 1− 1 n ) 1 n ∑ i 〈 f ′i(x ∗), φki − x∗ 〉 .\nFor the change in the last term of T k+1, we apply the non-expansiveness of the proximal operator3: c ∥∥xk+1 − x∗∥∥2 = c∥∥proxγ(wk+1)− proxγ(x∗ − γf ′(x∗))∥∥2\n≤ c ∥∥wk+1 − x∗ + γf ′(x∗)∥∥2 .\nWe expand the quadratic and apply E[wk+1] = xk − γf ′(xk) to simplify the inner product term: cE ∥∥wk+1 − x∗ + γf ′(x∗)∥∥2 = cE∥∥xk − x∗ + wk+1 − xk + γf ′(x∗)∥∥2\n= c ∥∥xk − x∗∥∥2 + 2cE [〈wk+1 − xk + γf ′(x∗), xk − x∗〉]+ cE∥∥wk+1 − xk + γf ′(x∗)∥∥2\n= c ∥∥xk − x∗∥∥2 − 2cγ 〈f ′(xk)− f ′(x∗), xk − x∗〉+ cE∥∥wk+1 − xk + γf ′(x∗)∥∥2\n≤ c ∥∥xk − x∗∥∥2 − 2cγ 〈f ′(xk), xk − x∗〉+ 2cγ 〈f ′(x∗), xk − x∗〉− cγ2β ∥∥f ′(xk)− f ′(x∗)∥∥2\n+ ( 1 + β−1 ) cγ2E ∥∥f ′j(φkj )− f ′j(x∗)∥∥2 + (1 + β) cγ2E∥∥f ′j(xk)− f ′j(x∗)∥∥2 . (Lemma 7) The value of β shall be fixed later. Now we apply Lemma 1 to bound −2cγ 〈 f ′(xk), xk − x∗ 〉 and\nLemma 6 to bound E ∥∥f ′j(φkj )− f ′j(x∗)∥∥2:\ncE ∥∥xk+1 − x∗∥∥2 ≤ (c− cγµ)∥∥xk − x∗∥∥2 + ((1 + β)cγ2 − cγ\nL\n) E ∥∥f ′j(xk)− f ′j(x∗)∥∥2\n− 2cγ(L− µ) L\n[ f(xk)− f(x∗)− 〈 f ′(x∗), xk − x∗ 〉] − cγ2β ∥∥f ′(xk)− f ′(x∗)∥∥2 + 2 ( 1 + β−1 ) cγ2L [ 1\nn ∑ i fi(φ k i )− f(x∗)− 1 n ∑ i 〈 f ′i(x ∗), φki − x∗ 〉] .\n3Note that the first equality below is the only place in the proof where we use the fact that x∗ is an optimality point.\nWe can now combine the bounds that we have derived for each term in T , and pull out a fraction 1κ of T k (for any κ at this point). Together with the inequality − ∥∥f ′(xk)− f ′(x∗)∥∥2 ≤\n−2µ [ f(xk)− f(x∗)− 〈 f ′(x∗), xk − x∗ 〉] [13, Thm. 2.1.10], that yields:\nE[T k+1]− T k ≤ − 1 κ T k +\n( 1\nn − 2cγ(L− µ) L − 2cγ2µβ\n)[ f(xk)− f(x∗)− 〈 f ′(x∗), xk − x∗ 〉] + ( 1\nκ + 2(1 + β−1)cγ2L− 1 n\n)[ 1\nn ∑ i fi(φ k i )− f(x∗)− 1 n ∑ i 〈 f ′i(x ∗), φki − x∗ 〉]\n+\n( 1\nκ − γµ\n) c ∥∥∥xk − x∗∥∥∥2 + ((1 + β)γ − 1\nL\n) cγE ∥∥∥f ′j(xk)− f ′j(x∗)∥∥∥2 . (10) Note that each of the terms in square brackets are positive, and it can be readily verified that our assumed values for the constants (γ = 12(µn+L) , c = 1 2γ(1−γµ)n , and κ = 1 γµ ), together with β = 2µn+LL ensure that each of the quantities in round brackets are non-positive (the constants were determined by setting all the round brackets to zero except the second one — see [14] for the details). Adaptivity to strong convexity result: Note that when using the γ = 13L step size, the same c as above can be used with β = 2 and 1κ = min { 1 4n , µ 3L } to ensure non-positive terms.\nCorollary 1. Note that c ∥∥xk − x∗∥∥2 ≤ T k, and therefore by chaining the expectations, plugging in the constants explicitly and using µ(n− 0.5) ≤ µn to simplify the expression, we get:\nE [∥∥∥xk − x∗∥∥∥2] ≤ (1− µ\n2(µn+ L) )k [∥∥x0 − x∗∥∥2 + n µn+ L [ f(x0)− 〈 f ′(x∗), x0 − x∗ 〉 − f(x∗) ]] .\nHere the expectation is over all choices of index jk up to step k."
    }, {
      "heading" : "6 Experiments",
      "text" : "We performed a series of experiments to validate the effectiveness of SAGA. We tested a binary classifier on MNIST, COVTYPE, IJCNN1 and a least squares predictor on MILLIONSONG. Details of these datasets can be found in [9]. We used the same code base for each method, just changing the main update rule. SVRG was tested with the recalibration pass used every n iterations, as suggested in [8]. Each method had its step size parameter chosen so as to give the fastest convergence.\nWe tested with a L2 regulariser, which all methods support, and with a L1 regulariser on a subset of the methods. The results are shown in Figure 2. We can see that Finito (perm) performs the best on a per epoch equivalent basis, but it can be the most expensive method per step. SVRG is similarly fast on a per epoch basis, but when considering the number of gradient evaluations per epoch is double that of the other methods for this problem, it is middle of the pack. SAGA can be seen to perform similar to the non-permuted Finito case, and to SDCA. Note that SAG is slower than the other methods at the beginning. To get the optimal results for SAG, an adaptive step size rule needs to be used rather than the constant step size we used. In general, these tests confirm that the choice of methods should be done based on their properties as discussed in Section 3, rather than their convergence rate."
    }, {
      "heading" : "A The SDCA/Finito Midpoint Algorithm",
      "text" : "Using Lagrangian duality theory, SDCA can be shown at step k as minimising the following lower bound:\nAk(x) = 1\nn fj(x) +\n1\nn n∑ i 6=j [ fi(φ k i ) + 〈 f ′i(φ k i ), x− φki 〉] + µ 2 ‖x‖2 .\nInstead of directly including the regulariser in this bound, we can use the standard strong convexity lower bound for each fi, by removing µ2 ‖x‖\n2 and changing the expression in the summation to fi(φ k i )+ 〈 f ′i(φ k i ), x− φki 〉 + µ2 ‖x− φi‖\n2. The transformation to having strong convexity within the fi functions yields the following simple modification to the algorithm: φk+1j = prox fj (µ(n−1))−1(z), where:\nz = 1 n− 1 ∑ i 6=j φki − 1 µ(n− 1) ∑ i 6=j f ′i(φ k i ).\nIt can be shown that after this update:\nxk+1 = φk+1j = 1\nn ∑ i φk+1i − 1 µn ∑ i f ′i(φ k+1 i ).\nNow the similarity to Finito is apparent if this equation is compared Equation 8: xk+1 = 1n ∑ i φ k i −\nγ ∑n i=1 f ′ i(φ k i ). The only difference is that the vectors on the right hand side of the equation are at their values at step k+1 instead of k. Note that there is a circular dependency here, as φk+1j := x k+1 but φk+1j appears in the definition of x k+1. Solving the proximal operator is the resolution of the circular dependency. This mid-point between Finito and SDCA is interesting in it’s own right, as it appears experimentally to have similar robustness to permuted orderings as Finito, but it has no tunable parameters like SDCA.\nWhen the proximal operator above is fast to compute, say on the same order as just evaluating fj , then SDCA can be the best method among those discussed. It is a little slower than the other methods discussed here, but it has no tunable parameters at all. It is also the only choice when each fi is not differentiable. The major disadvantage of SDCA is that it can not handle non-strongly convex problems directly. Although like most methods, adding a small amount of quadratic regularisation can be used to recover a convergence rate. It is also not adapted to use proximal operators for the regulariser in the composite objective case. The requirement of computing the proximal operator of each loss fi initially appears to be a big disadvantage, however there are variants of SDCA that remove this requirement, but they introduce additional downsides."
    }, {
      "heading" : "B Lemmas",
      "text" : "Lemma 4. Let f be µ-strongly convex and have Lipschitz continuous gradients with constant L. Then we have for all x and y:\nf(x) ≥ f(y) + 〈f ′(y), x− y〉+ 1 2 (L− µ) ‖f ′(x)− f ′(y)‖2\n+ µL\n2 (L− µ) ‖y − x‖ 2\n+ µ\n(L− µ) 〈f ′(x)− f ′(y), y − x〉 .\nProof. Define the function g as g(x) = f(x) − µ2 ‖x‖ 2. Then the gradient is g′(x) = f ′(x) − µx. g has a Lipschitz gradient with constant L− µ. By convexity, we have [13, Thm. 2.1.5]: g(x) ≥ g(y) + 〈g′(y), x− y〉+ 1\n2(L− µ) ‖g ′(x)− g′(y)‖2 .\nSubstituting in the definition of g and g′, and simplifying the terms gives the result. Lemma 5. Let f(x) = 1n ∑n i=1 fi(x). Suppose each fi is µ-strongly convex and has Lipschitz continuous gradients with constant L. Then for all x and x∗:〈 f ′(x), x∗ − x 〉 ≤ L− µ\nL [f(x∗)− f(x)]−µ 2 ‖x∗ − x‖2− 1 2Ln ∑ i ∥∥f ′i(x∗)− f ′i(x)∥∥2−µ L 〈 f ′(x∗), x− x∗ 〉 .\nProof. This is a straight-forward corollary of Lemma 4, using y = x∗, and averaging over the fi functions.\nLemma 6. We have that for all φi and x∗:\n1\nn ∑ i ‖f ′i(φi)− f ′i(x∗)‖ 2 ≤ 2L\n[ 1\nn ∑ i fi(φi)− f(x∗)− 1 n ∑ i 〈f ′i(x∗), φi − x∗〉 ] .\nProof. Apply the standard inequality f(y) ≥ f(x) + 〈f ′(x), y − x〉 + 12L ‖f ′(x)− f ′(y)‖ 2, with y = φi and x = x∗, for each fi, and sum.\nLemma 7. It holds that for any φki , x∗, xk and β > 0, with wk+1 as defined in Equation 1: E ∥∥wk+1 − xk − γf ′(x∗)∥∥2 ≤ γ2(1 + β−1)E∥∥f ′j(φkj )− f ′j(x∗)∥∥2 + γ2(1 + β)E∥∥f ′j(xk)− f ′j(x∗)∥∥2\n− γ2β ∥∥f ′(xk)− f ′(x∗)∥∥2 .\nProof. We follow a similar argument as occurs in the SVRG proof [5] for this term, but with a tighter argument. The tightening comes from using ‖x+ y‖2 ≤ (1 + β−1) ‖x‖2 + (1 + β) ‖y‖2 instead of the simpler β = 1 case they use. The other key trick is the use of the standard variance decomposition E[‖X − E[X]‖2] = E[‖X‖2]− ‖E[X]‖2 three times.\nE ∥∥∥wk+1 − xk + γf ′(x∗)∥∥∥2\n= E ∥∥∥∥−γn∑\ni\nf ′i(φ k i ) + γf ′(x∗) + γ [ f ′j(φ k j )− f ′j(xk) ] ︸ ︷︷ ︸\n:= γX\n∥∥∥∥2\n= γ2E ∥∥∥∥∥ X︷ ︸︸ ︷[ f ′j(φ k j )− f ′j(x∗)− 1 n ∑ i f ′i(φ k i ) + f ′(x∗) ] − [ f ′j(x k)− f ′j(x∗)− E[X]︷ ︸︸ ︷ f ′(xk) + f ′(x∗) ]∥∥∥∥∥ 2 + γ2 ∥∥∥∥ E[X]︷ ︸︸ ︷ f ′(xk)− f ′(x∗) ∥∥∥∥2\n≤ γ2(1 + β−1)E ∥∥∥∥∥f ′j(φkj )− f ′j(x∗)− 1n∑ i f ′i(φ k i ) + f ′(x∗) ∥∥∥∥∥ 2\n+ γ2(1 + β)E ∥∥∥f ′j(xk)− f ′j(x∗)− f ′(xk) + f ′(x∗)∥∥∥2 + γ2 ∥∥∥f ′(xk)− f ′(x∗)∥∥∥2\n(use variance decomposition twice more): ≤ γ2(1 + β−1)E ∥∥∥f ′j(φkj )− f ′j(x∗)∥∥∥2 + γ2(1 + β)E ∥∥∥f ′j(xk)− f ′j(x∗)∥∥∥2 − γ2β ∥∥∥f ′(xk)− f ′(x∗)∥∥∥2 ."
    }, {
      "heading" : "C Non-strongly-convex Problems",
      "text" : "Theorem 2. When each fi is convex, using γ = 13L , we have for x̄ k = 1k ∑k t=1 x t that:\nE [ F (x̄k) ] − F (x∗) ≤ 4n\nk\n[ 2L\nn ∥∥x0 − x∗∥∥2 + f(x0)− 〈f ′(x∗), x0 − x∗〉− f(x∗)] . Here the expectation is over all choices of index jk up to step k.\nProof. A more detailed version of this proof is available in [14]. We proceed by using a similar argument as in Theorem 1, but we add an additional α ∥∥xk − x∗∥∥2 together with the existing c ∥∥xk − x∗∥∥2 term in the Lyapunov function.\nWe will bound α ∥∥xk − x∗∥∥2 in a different manner to c∥∥xk − x∗∥∥2. Define ∆ =\n− 1γ ( wk+1 − xk ) − f ′(xk), the difference between our approximation to the gradient at xk and\ntrue gradient. Then instead of using the non-expansiveness property at the beginning, we use a result proved for prox-SVRG [4, 2nd eq. on p.12]:\nαE ∥∥xk+1 − x∗∥∥2 ≤ α ∥∥xk − x∗∥∥2 − 2αγE [F (xk+1)− F (x∗)]+ 2αγ2E ‖∆‖2 .\nAlthough their quantity ∆ is different, they only use the property that E[∆] = 0 to prove the above equation. A full proof of this property for the SAGA algorithm that follows their argument appears in [14].\nTo bound the ∆ term, a small modification of the argument in Lemma 7 can be used, giving: E ‖∆‖2 ≤ ( 1 + β−1 ) E ∥∥f ′j(φkj )− f ′j(x∗)∥∥2 + (1 + β)E∥∥f ′j(xk)− f ′j(x∗)∥∥2 .\nApplying this gives: αE ∥∥xk+1 − x∗∥∥2 ≤ α ∥∥xk − x∗∥∥2 − 2αγE [F (xk+1)− F (x∗)]\n+ 2(1 + β−1)αγ2E ∥∥f ′j(φkj )− f ′j(x∗)∥∥2 + 2 (1 + β)αγ2E∥∥f ′j(xk)− f ′j(x∗)∥∥2 .\nAs in Theorem 1, we then apply Lemma 6 to bound E ∥∥f ′j(φkj )− f ′j(x∗)∥∥2. Combining with the rest of the Lyapunov function as was derived in Theorem 1 gives (we basically add the α terms to inequality (10) with µ = 0):\nE[T k+1]− T k ≤ ( 1\nn − 2cγ\n)[ f(xk)− f(x∗)− 〈 f ′(x∗), xk − x∗ 〉] − 2αγE [ F (xk+1)− F (x∗) ] + ( 4(1 + β−1)αLγ2 + 2(1 + β−1)cLγ2 − 1\nn\n)[ 1\nn ∑ i fi(φ k i )− f(x∗)− 1 n ∑ i 〈 f ′i(x ∗), φki − x∗ 〉]\n+ (\n(1 + β)cγ + 2(1 + β)αγ − c L\n) γE ∥∥f ′j(xk)− f ′j(x∗)∥∥2 .\nAs before, the terms in square brackets are positive by convexity. Given that our choice of step size is γ = 13L (to match the adaptive to strong convexity step size), we can set the three round brackets to zero by using β = 1, c = 3L2n and α = 3L 8n . We thus obtain:\nE[T k+1]− T k ≤ − 1 4n\nE [ F (xk+1)− F (x∗) ] .\nThese expectations are conditional on information from step k. We now take the expectation with respect to all previous steps, yielding E[T k+1] − E[T k] ≤ − 14nE [ F (xk+1)− F (x∗) ] , where all expectations are unconditional. Further negating and summing for k from 0 to k − 1 results in telescoping of the T terms, giving:\n1\n4n E [ k∑ t=1 [ F (xt)− F (x∗) ]] ≤ T 0 − E[T k].\nWe can drop the −E [ T k ]\nterm since T k is always positive. Then we apply convexity to pull the summation inside of F , and multiply through by 4n/k, giving:\nE [ F ( 1\nk k∑ t=1 xt)− F (x∗) ] ≤ 1 k E [ k∑ t=1 [ F (xt)− F (x∗) ]] ≤ 4n k T 0.\nWe get a (c+ α) = 15L8n ≤ 2Ln term that we use in T 0 for simplicity."
    }, {
      "heading" : "D Example Code for Sparse Least Squares & Ridge Regression",
      "text" : "The SAGA method is quite easy to implement for dense gradients, however the implementation for sparse gradient problems can be tricky. The main complication is the need for just-in-time updating of the elements of the iterate vector. This is needed to avoid having to do any full dense vector operations at each iteration. We provide below a simple implementation for the case of least-squares problems that illustrates how to correctly do this. The code is in the compiled Python (Cython) language.\nimport random\nimport numpy as np\ncimport numpy as np\ncimport cython\nfrom cython.view cimport array as cvarray\n# Performs the lagged update of x by g.\ncdef inline lagged update(long k, double[:] x, double[:] g, unsigned long[:] lag,\nlong[:] yindices, int ylen, double[:] lag scaling , double a):\ncdef unsigned int i\ncdef long ind\ncdef unsigned long lagged amount = 0\nfor i in range(ylen):\nind = yindices[i] lagged amount = k−lag[ind] lag[ind] = k x[ind] += lag scaling[lagged amount]∗(a∗g[ind])\n# Performs x += a∗y, where x is dense and y is sparse. cdef inline add weighted(double[:] x, double[:] ydata , long[:] yindices, int ylen, double a):\ncdef unsigned int i\nfor i in range(ylen):\nx[yindices[i]] += a∗ydata[i]\n# Dot product of a dense vector with a sparse vector\ncdef inline spdot(double[:] x, double[:] ydata , long[:] yindices, int ylen):\ncdef unsigned int i\ncdef double v = 0.0\nfor i in range(ylen):\nv += ydata[i]∗x[yindices[i]]\nreturn v\ndef saga lstsq(A, double[:] b, unsigned int maxiter, props):\n# temporaries\ncdef double[:] ydata\ncdef long[:] yindices\ncdef unsigned int i, j, epoch, lagged amount\ncdef long indstart , indend, ylen, ind\ncdef double cnew, Aix, cchange, gscaling\n# Data points are stored in columns in CSC format.\ncdef double[:] data = A.data\ncdef long[:] indices = A.indices\ncdef long[:] indptr = A.indptr\ncdef unsigned int m = A.shape[0] # dimensions\ncdef unsigned int n = A.shape[1] # datapoints\ncdef double[:] xk = np.zeros(m)\ncdef double[:] gk = np.zeros(m)\ncdef double eta = props[’eta’] # Inverse step size = 1/gamma\ncdef double reg = props.get(’reg’, 0.0) # Default 0\ncdef double betak = 1.0 # Scaling factor for xk.\n# Tracks for each entry of x, what iteration it was last updated at.\ncdef unsigned long[:] lag = np.zeros(m, dtype=’I’)\n# Initialize gradients cdef double gd = −1.0/n for i in range(n):\nindstart = indptr[i]\nindend = indptr[i+1]\nydata = data[indstart:indend]\nyindices = indices[indstart:indend] ylen = indend−indstart add weighted(gk, ydata, yindices, ylen, gd∗b[i])\n# This is just a table of the sum the geometric series (1−reg/eta) # It is used to correctly do the just−in−time updating when # L2 regularisation is used. cdef double[:] lag scaling = np.zeros(n∗maxiter+1) lag scaling[0] = 0.0\nlag scaling[1] = 1.0\ncdef double geosum = 1.0 cdef double mult = 1.0 − reg/eta for i in range(2,n∗maxiter+1):\ngeosum ∗= mult lag scaling[i] = lag scaling[i−1] + geosum\n# For least−squares, we only need to store a single # double for each data point, rather than a full gradient vector. # The value stored is the A i ∗ betak ∗ x product cdef double[:] c = np.zeros(n)\ncdef unsigned long k = 0 # Current iteration number\nfor epoch in range(maxiter):\nfor j in range(n):\nif epoch == 0:\ni = j\nelse:\ni = np.random.randint(0, n)\n# Selects the (sparse) column of the data matrix containing datapoint i.\nindstart = indptr[i]\nindend = indptr[i+1]\nydata = data[indstart:indend]\nyindices = indices[indstart:indend] ylen = indend−indstart\n# Apply the missed updates to xk just−in−time lagged update(k, xk, gk, lag, yindices, ylen, lag scaling , −1.0/(eta∗betak))\nAix = betak ∗ spdot(xk, ydata, yindices, ylen)\ncnew = Aix cchange = cnew−c[i]\nc[i] = cnew betak ∗= 1.0 − reg/eta\n# Update xk with sparse step bit (with betak scaling) add weighted(xk, ydata, yindices, ylen, −cchange/(eta∗betak))\nk += 1\n# Perform the gradient−average part of the step lagged update(k, xk, gk, lag, yindices, ylen, lag scaling , −1.0/(eta∗betak))\n# update the gradient average\nadd weighted(gk, ydata, yindices, ylen, cchange/n)\n# Perform the just in time updates for the whole xk vector, so that all entries are up−to−date. gscaling = −1.0/(eta∗betak) for ind in range(m):\nlagged amount = k−lag[ind] lag[ind] = k\nxk[ind] += lag scaling[lagged amount]∗gscaling∗gk[ind] return betak ∗ np.asarray(xk)"
    } ],
    "references" : [ {
      "title" : "Minimizing finite sums with the stochastic average gradient",
      "author" : [ "Mark Schmidt", "Nicolas Le Roux", "Francis Bach" ],
      "venue" : "Technical report, INRIA,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2013
    }, {
      "title" : "Stochastic dual coordinate ascent methods for regularized loss minimization",
      "author" : [ "Shai Shalev-Shwartz", "Tong Zhang" ],
      "venue" : "JMLR, 14:567–599,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2013
    }, {
      "title" : "Incrementally updated gradient methods for constrained and regularized optimization",
      "author" : [ "Paul Tseng", "Sangwoon Yun" ],
      "venue" : "Journal of Optimization Theory and Applications,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2014
    }, {
      "title" : "A proximal stochastic gradient method with progressive variance reduction",
      "author" : [ "Lin Xiao", "Tong Zhang" ],
      "venue" : "Technical report,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2014
    }, {
      "title" : "Accelerating stochastic gradient descent using predictive variance reduction",
      "author" : [ "Rie Johnson", "Tong Zhang" ],
      "venue" : null,
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2013
    }, {
      "title" : "Stochastic dual coordinate ascent with alternating direction method of multipliers",
      "author" : [ "Taiji Suzuki" ],
      "venue" : "Proceedings of The 31st International Conference on Machine Learning,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2014
    }, {
      "title" : "Variance reduction techniques for gradient estimates in reinforcement learning",
      "author" : [ "Evan Greensmith", "Peter L. Bartlett", "Jonathan Baxter" ],
      "venue" : "JMLR, 5:1471–1530,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2004
    }, {
      "title" : "Semi-stochastic gradient descent methods",
      "author" : [ "Jakub Konečný", "Peter Richtárik" ],
      "venue" : "ArXiv e-prints,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2013
    }, {
      "title" : "Finito: A faster, permutable incremental gradient method for big data problems",
      "author" : [ "Aaron Defazio", "Tiberio Caetano", "Justin Domke" ],
      "venue" : "Proceedings of the 31st International Conference on Machine Learning,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2014
    }, {
      "title" : "Incremental majorization-minimization optimization with application to largescale machine learning",
      "author" : [ "Julien Mairal" ],
      "venue" : "Technical report, INRIA Grenoble Rhône-Alpes / LJK Laboratoire Jean Kuntzmann,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2014
    }, {
      "title" : "Accelerated proximal stochastic dual coordinate ascent for regularized loss minimization",
      "author" : [ "Shai Shalev-Shwartz", "Tong Zhang" ],
      "venue" : "Technical report,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2013
    }, {
      "title" : "Proximal Splitting Methods in Signal Processing. In Fixed-Point Algorithms for Inverse Problems in Science and Engineering",
      "author" : [ "Patrick Combettes", "Jean-Christophe Pesquet" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "1 Introduction Remarkably, recent advances [1, 2] have shown that it is possible to minimise strongly convex finite sums provably faster in expectation than is possible without the finite sum structure.",
      "startOffset" : 43,
      "endOffset" : 49
    }, {
      "referenceID" : 1,
      "context" : "1 Introduction Remarkably, recent advances [1, 2] have shown that it is possible to minimise strongly convex finite sums provably faster in expectation than is possible without the finite sum structure.",
      "startOffset" : 43,
      "endOffset" : 49
    }, {
      "referenceID" : 2,
      "context" : "We will also consider the case where each fi is strongly convex with constant μ, and the “composite” (or proximal) case where an additional regularisation function is added: F (x) = f(x) + h(x), where h : R → R is convex but potentially non-differentiable, and where the proximal operation of h is easy to compute — few incremental gradient methods are applicable in this setting [3][4].",
      "startOffset" : 380,
      "endOffset" : 383
    }, {
      "referenceID" : 3,
      "context" : "We will also consider the case where each fi is strongly convex with constant μ, and the “composite” (or proximal) case where an additional regularisation function is added: F (x) = f(x) + h(x), where h : R → R is convex but potentially non-differentiable, and where the proximal operation of h is easy to compute — few incremental gradient methods are applicable in this setting [3][4].",
      "startOffset" : 383,
      "endOffset" : 386
    }, {
      "referenceID" : 0,
      "context" : "In Section 5 we prove theoretical convergence rates for SAGA in the strongly convex case better than those for SAG [1] and SVRG [5], and a factor of 2 from the SDCA [2] convergence rates.",
      "startOffset" : 115,
      "endOffset" : 118
    }, {
      "referenceID" : 4,
      "context" : "In Section 5 we prove theoretical convergence rates for SAGA in the strongly convex case better than those for SAG [1] and SVRG [5], and a factor of 2 from the SDCA [2] convergence rates.",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 1,
      "context" : "In Section 5 we prove theoretical convergence rates for SAGA in the strongly convex case better than those for SAG [1] and SVRG [5], and a factor of 2 from the SDCA [2] convergence rates.",
      "startOffset" : 165,
      "endOffset" : 168
    }, {
      "referenceID" : 0,
      "context" : "SAGA is inspired both from SAG [1] and SVRG [5] (as we will discuss in Section 3).",
      "startOffset" : 31,
      "endOffset" : 34
    }, {
      "referenceID" : 4,
      "context" : "SAGA is inspired both from SAG [1] and SVRG [5] (as we will discuss in Section 3).",
      "startOffset" : 44,
      "endOffset" : 47
    }, {
      "referenceID" : 2,
      "context" : "The method from [3], which handles the non-composite setting, is not listed as its rate is of the slow type and can be up to n times smaller than the one for SAGA or SVRG [5].",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 4,
      "context" : "The method from [3], which handles the non-composite setting, is not listed as its rate is of the slow type and can be up to n times smaller than the one for SAGA or SVRG [5].",
      "startOffset" : 171,
      "endOffset" : 174
    }, {
      "referenceID" : 5,
      "context" : "3 ? 3[6] 3 7 Non-smooth 7 7 3 7 7 Low Storage Cost 7 7 7 3 7 Simple(-ish) Proof 3 7 3 3 3 Adaptive to SC 3 3 7 ? ? Figure 1: Basic summary of method properties.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 4,
      "context" : "In [5], the authors make the observation that the variance of the standard stochastic gradient (SGD) update direction can only go to zero if decreasing step sizes are used, thus preventing a linear convergence rate unlike for batch gradient descent.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 6,
      "context" : "They thus propose to use a variance reduction approach (see [7] and references therein for example) on the SGD update in order to be able to use constant step sizes and get a linear convergence rate.",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 0,
      "context" : "They also mention that SAG (Stochastic Average Gradient) [1] can be interpreted as reducing the variance, though they do not provide the specifics.",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 0,
      "context" : "One variance reduction approach is to use the following estimator θα as an approximation to EX: θα := α(X−Y )+EY , for a step size α ∈ [0, 1].",
      "startOffset" : 135,
      "endOffset" : 141
    }, {
      "referenceID" : 7,
      "context" : "The S2GD method [8] has the same update as SVRG, just differing in how the number of inner loop iterations is chosen.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 8,
      "context" : "We now describe how the Finito [9] and MISOμ [10] methods are closely related to SAGA.",
      "startOffset" : 31,
      "endOffset" : 34
    }, {
      "referenceID" : 9,
      "context" : "We now describe how the Finito [9] and MISOμ [10] methods are closely related to SAGA.",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 9,
      "context" : "MISO has proven support for proximal operators only in the case where impractically small step sizes are used [10].",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 1,
      "context" : "SDCA The Stochastic Dual Coordinate Descent (SDCA) [2] method on the surface appears quite different from the other methods considered.",
      "startOffset" : 51,
      "endOffset" : 54
    }, {
      "referenceID" : 10,
      "context" : "1 Firstly, note that while SDCA was originally described for onedimensional outputs (binary classification or regression), it has been expanded to cover the multiclass predictor case [11] (called Prox-SDCA there).",
      "startOffset" : 183,
      "endOffset" : 187
    }, {
      "referenceID" : 10,
      "context" : "As noted by Shalev-Shwartz & Zhang [11], the update (9) is actually an instance of the proximal operator of the convex conjugate of fj .",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 11,
      "context" : "The same trick is commonly used to interpret Dijkstra’s set intersection as a primal algorithm instead of a dual block coordinate descent algorithm [12].",
      "startOffset" : 148,
      "endOffset" : 152
    }, {
      "referenceID" : 10,
      "context" : "SDCA variants The SDCA theory has been expanded to cover a number of other methods of performing the coordinate step [11].",
      "startOffset" : 117,
      "endOffset" : 121
    }, {
      "referenceID" : 0,
      "context" : "The variants differ in how β ∈ [0, 1] is chosen.",
      "startOffset" : 31,
      "endOffset" : 37
    }, {
      "referenceID" : 10,
      "context" : "Variant 5 by Shalev-Shwartz & Zhang [11] does not require operations on the conjugate function, it simply uses β = μn L+μn .",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 0,
      "context" : "This procedure has been successfully used with SAG [1].",
      "startOffset" : 51,
      "endOffset" : 54
    }, {
      "referenceID" : 0,
      "context" : "A just-intime updating of u or x may be performed just as is suggested for SAG [1], which ensures that only sparse updates are done at each iteration.",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 8,
      "context" : "Details of these datasets can be found in [9].",
      "startOffset" : 42,
      "endOffset" : 45
    }, {
      "referenceID" : 7,
      "context" : "SVRG was tested with the recalibration pass used every n iterations, as suggested in [8].",
      "startOffset" : 85,
      "endOffset" : 88
    } ],
    "year" : 2014,
    "abstractText" : "In this work we introduce a new optimisation method called SAGA in the spirit of SAG, SDCA, MISO and SVRG, a set of recently proposed incremental gradient algorithms with fast linear convergence rates. SAGA improves on the theory behind SAG and SVRG, with better theoretical convergence rates, and has support for composite objectives where a proximal operator is used on the regulariser. Unlike SDCA, SAGA supports non-strongly convex problems directly, and is adaptive to any inherent strong convexity of the problem. We give experimental results showing the effectiveness of our method.",
    "creator" : "LaTeX with hyperref package"
  }
}