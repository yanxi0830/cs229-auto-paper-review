{
  "name" : "1504.01365.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "PASSCoDe: Parallel ASynchronous Stochastic dual Co-ordinate Descent",
    "authors" : [ "Cho-Jui Hsieh", "Hsiang-Fu Yu", "Inderjit S. Dhillon" ],
    "emails" : [ "cjhsieh@cs.utexas.edu", "rofuyu@cs.utexas.edu", "inderjit@cs.utexas.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "family of `2-regularized empirical risk minimization problems, including linear SVM, logistic regression, and many others. The vanilla implementation of DCD is quite slow; however, by maintaining primal variables while updating dual variables, the time complexity of DCD can be significantly reduced. Such a strategy forms the core algorithm in the widely-used LIBLINEAR package. In this paper, we parallelize the DCD algorithms in LIBLINEAR. In recent research, several synchronized parallel DCD algorithms have been proposed, however, they fail to achieve good speedup in the shared memory multi-core setting. In this paper, we propose a family of asynchronous stochastic dual coordinate descent algorithms (PASSCoDe). Each thread repeatedly selects a random dual variable and conducts coordinate updates using the primal variables that are stored in the shared memory. We analyze the convergence properties when different locking/atomic mechanisms are applied. For implementation with atomic operations, we show linear convergence under mild conditions. For implementation without any atomic operations or locking, we present the first backward error analysis for PASSCoDe under the multi-core environment, showing that the converged solution is the exact solution for a primal problem with perturbed regularizer. Experimental results show that our methods are much faster than previous parallel coordinate descent solvers."
    }, {
      "heading" : "1 Introduction",
      "text" : "Given a set of instance-label pairs (ẋi, ẏi), i = 1, · · · , n, ẋi ∈ Rd, ẏi ∈ R, we focus on the following empirical risk minimization problem with `2-regularization:\nmin w∈Rd\nP (w) := 1\n2 ‖w‖2 + n∑ i=1 `i(w Txi), (1)\nwhere xi = ẏiẋi, `i(·) is the loss function and ‖·‖ is the 2-norm. A large class of machine learning problems can be formulated as the above optimization problem. Examples include Support Vector Machines (SVMs), logistic regression, ridge regression, and many others. Problem (1) is usually called the primal problem, and can usually be solved by Stochastic Gradient Descent (SGD) (Zhang, 2004; Shalev-Shwartz et al., 2007), second order methods (Lin et al., 2007), or primal coordinate descent algorithms (Chang et al., 2008; Huang et al., 2009).\nInstead of solving the primal problem, another class of algorithms solves the following dual problem of (1):\nmin α∈Rn\nD(α) := 1\n2 ‖ n∑ i=1 αixi‖2 + n∑ i=1 `∗i (−αi), (2)\nar X\niv :1\n50 4.\n01 36\n5v 1\n[ cs\n.L G\n] 6\nA pr\n2 01\nwhere `∗i (·) is the conjugate of the loss function `i(·), defined by `∗i (u) = maxz(zu− `i(z)). If we define\nw(α) = ∑ i=1 αixi, (3)\nthen it is known that w(α∗) = w∗ and P (w∗) = −D(α∗) where w∗,α∗ are the optimal primal/dual solutions respectively. Examples include hinge-loss SVM, square hinge SVM and `2-regularized logistic regression.\nStochastic Dual Coordinate Descent (DCD) has become the most widely-used algorithm for solving (2), and it is faster than primal solvers (including SGD) in many large-scale problems. The success of DCD is mainly due to the trick of maintaining the primal variables w based on the primal-dual relationship (3). By maintaining w in memory, Hsieh et al. (2008); Keerthi et al. (2008) showed that the time complexity of each coordinate update can be reduced from O(nnz) to O(nnz/n), where nnz is number of nonzeros in the training dataset. Several DCD algorithms for different machine learning problems are currently implemented in LIBLINEAR (Fan et al., 2008) and they are now widely used in both academia and industry. The success of DCD has also catalyzed a large body of theoretical studies (Nesterov, 2012; Shalev-Shwartz & Zhang, 2013).\nIn this paper, we parallelize the DCD algorithm in a shared memory multicore system. There are two threads of work on parallel coordinate descent. The first thread focuses on synchronized algorithms, including synchronized CD (Richtárik & Takáč, 2012; Bradley et al., 2011) and synchronized DCD algorithms (Yang, 2013; Jaggi et al., 2014). However, choosing the block size is a trade-off problem between communication and convergence speed, so synchronous algorithms usually suffer from slower convergence. To overcome this problem, the other thread of work focuses on asynchronous CD algorithms in multi-core shared memory systems (Liu & Wright, 2014; Liu et al., 2014). However, none of the existing work maintains both the primal and dual variables. As a result, the recent asynchronous CD algorithms end up being much slower than the state-of-the-art serial DCD algorithms that maintain both w and α, as in the LIBLINEAR software. This leads to a challenging question: how to maintaining both primal and dual in an asynchronous and efficient way?\nIn this paper, we propose the first asynchronous dual coordinate descent (PASSCoDe) algorithms with the address to the issue for the primal variable maintenance in the shared memory multi-core setting. We carefully discuss and analyze three versions of PASSCoDe: PASSCoDe-Lock, PASSCoDe-Atomic, and PASSCoDe-Wild. In PASSCoDe-Lock, convergence is always guaranteed but the overhead for locking makes it even slower than serial DCD. In PASSCoDe-Atomic, the primal-dual relationship (3) is enforced by atomic writes to the shared memory; while PASSCoDe-Wild proceeds without any locking and atomic operations, as a result of which the relationship (3) between primal and dual variables can be violated due to memory conflicts. Our contributions can be summarized below: • We propose and analyze a family of asynchronous parallelization of the most efficient DCD algorithm:\nPASSCoDe-Lock, PASSCoDe-Atomic, PASSCoDe-Wild. • We show linear convergence of PASSCoDe-Atomic under certain conditions. • We present a backward error analysis for PASSCoDe-Wild and show that the converged solution is\nthe exact solution of a primal problem with a perturbed regularizer. Therefore the performance is close-to-optimal on most of the datasets. To best of our knowledge, this is the first attempt to analyze a parallel machine learning algorithm with memory conflicts using backward error analysis, which is a standard tool in numerical analysis (Wilkinson, 1961). • Experimental results show that our algorithms (PASSCoDe-Atomic and PASSCoDe-Wild) are much\nfaster than existing methods. For example, on the webspam dataset, PASSCoDe-Atomic took 2 sec-\nonds and PASSCoDe-Wild took 1.6 seconds to achieve 99% accuracy, while CoCoA took 11.5 seconds using 10 threads and LIBLINEAR took 10 seconds using 1 thread to achieve the same accuracy."
    }, {
      "heading" : "2 Related Work",
      "text" : "Stochastic Coordinate Descent. Coordinate descent is a classical optimization technique that has been studied for a long time (Bertsekas, 1999; Luo & Tseng, 1992). Recently it has enjoyed renewed interest due to the success of “stochastic” coordinate descent in real applications (Hsieh et al., 2008; Nesterov, 2012). In terms of theoretical analysis, the convergence of (cyclic) coordinate descent has been studied for a long time (Luo & Tseng, 1992; Bertsekas, 1999), and the global linear convergence is presented recently under certain condition (Saha & Tewari, 2013; Wang & Lin, 2014).\nStochastic Dual Coordinate Descent. Many recent papers (Hsieh et al., 2008; Yu et al., 2011; ShalevShwartz & Zhang, 2013) have shown that solving the dual problem using coordinate descent algorithms is faster on large-scale datasets. The success of SDCD strongly relies on exploiting the primal-dual relationship (3) to speed up the gradient computation in the dual space. DCD has become the state-of-the-art solver implemented in LIBLINEAR (Fan et al., 2008). In terms of convergence of dual objective function, some standard theoretical guarantees for coordinate descent can be directly applied. Different from standard analysis, Shalev-Shwartz & Zhang (2013) presented the convergence rate in terms of duality gap.\nParallel Stochastic Coordinate Descent. In order to conduct coordinate updates in parallel, Richtárik & Takáč (2012) studied the algorithm where each processor updates a randomly selected block (or coordinate) simultaneously, and Bradley et al. (2011) proposed a similar algorithm for `1-regularized problems. Scherrer et al. (2012) studied parallel greedy coordinate descent. However, the above synchronized methods usually face a trade-off in choosing the block size. If the block size is small, the load balancing problem leads to slow running time. If the block size is large, the convergence speed becomes much slower or the algorithm even diverges. These problems can be resolved by developing an asynchronous algorithm. Asynchronous coordinate descent has been studied by (Bertsekas & Tsitsiklis, 1989), but they require the Hessian to be diagonal dominant in order to establish the convergence. Recently, Liu et al. (2014); Liu & Wright (2014) proved linear convergence of asynchronous stochastic coordinate descent algorithms under the essential strong convexity condition and a “bounded staleness” condition, where they consider both “consistent read” and “inconsistent read” models. Avron et al. (2014) showed linear rate of convergence for the asynchronous randomized Gaussian-Seidel updates, which is a special case of coordinate descent on linear systems.\nParallel Stochastic Dual Coordinate Descent. For solving (5), each coordinate updates only requires the global primal variables w and one local dual variable αi, thus algorithms only need to synchronize w. Based on this observation, Yang (2013) proposed to update several coordinates or blocks simultaneously and update the globalw, and Jaggi et al. (2014) showed that each block can be solved with other approaches under the same framework. However, both these parallel DCD methods are synchronized algorithms.\nTo the best of our knowledge, this is the first to propose and analyze asynchronous parallel stochastic dual coordinate descent methods. By maintaining a primal solutionw while updating dual variables, our algorithm is much faster than the previous asynchronous coordinate descent methods of (Liu & Wright, 2014; Liu et al., 2014) for solving the dual problem (2). Our algorithms are also faster than synchronized dual coordinate descent methods (Yang, 2013; Jaggi et al., 2014) since the latest values ofw can be accessed by all the threads. In terms of theoretical contribution, the inconsistent read model in (Liu & Wright, 2014) cannot be directly applied to our algorithm because each update on αi is based on the shared w vector. We further show linear convergence for PASSCoDe-Atomic, and study the properties of the converged solution for the\nwild version of our algorithm (without any locking and atomic operations) using a backward error analysis. Our algorithm has been successfully applied to solve the collaborative ranking problem (Anonymous, 2015)."
    }, {
      "heading" : "3 Algorithms",
      "text" : ""
    }, {
      "heading" : "3.1 Stochastic Dual Coordinate Descent",
      "text" : "We first describe the Stochastic Dual Coordinate Descent (DCD) algorithm for solving the dual problem (2). At each iteration, DCD randomly picks a dual variable αi and updates it by minimizing the one variable subproblem (Eq. (4) in Algorithm 1). Without exploiting the structure of the quadratic term, the subproblems require substantial computation (need O(nnz) time), where nnz is the total number of nonzero elements in the training data. However, ifw(α) that satisfies (3) is maintained in memory, the subproblem D(α+ δei) can be written as\nD(α+ δei) = 1 2 ‖w + δxi‖2 + `∗i (−(αi + δ)),\nand the optimal solution can be computed by\nδ = arg min δ\n1 2 (δ + wTxi ‖xi‖2 )2 + 1 ‖xi‖2 `∗i (−(αi + δ)).\nNote that all ‖xi‖ can be pre-computed and are constants. For each coordinate update we only need to solve a simple one-variable subproblem, and the main computation is in computing wTxi, which requires O(nnz/n) time. For SVM problems, the subproblem has a closed form solution, while for logistic regression problems it has to be solved by an iterative solver (see Yu et al. (2012) for details). The DCD algorithm, which is part of the popular LIBLINEAR package, is described in Algorithm 1.\nAlgorithm 1 Stochastic Dual Coordinate Descent (DCD) Input: Initial α and w = ∑n i=1 αixi\n1: while not converged do 2: Randomly pick i 3: Update αi ← αi + ∆αi, where\n∆αi ← arg min δ\n1 2 ‖w + δxi‖2 + `∗i (−(αi + δ)) (4)\n4: Update w by w ← w + ∆αixi 5: end while"
    }, {
      "heading" : "3.2 Asynchronous Stochastic Dual Coordinate Descent",
      "text" : "To parallelize DCD in a shared memory multi-core system, we propose a family of Asynchronous Stochastic Dual Coordinate Descent (PASSCoDe) algorithms. PASSCoDe is very simple but effective. Each thread repeatedly run the updates (steps 2 to 4) in Algorithm 1 using w, α, and training data stored in a shared memory. The threads do not need to coordinate or synchronize their iterations. The details are shown in Algorithm 2.\nAlgorithm 2 Parallel Asynchronous Stochastic dual Co-ordinate Descent (PASSCoDe) Input: Initial α and w = ∑n i=1 αixi\nNumber of threads Lock Atomic Wild 2 98.03s / 0.27x 15.28s / 1.75x 14.08s / 1.90x 4 106.11s / 0.25x 8.35s / 3.20x 7.61s / 3.50x\n10 114.43s / 0.23x 3.86s / 6.91x 3.59s / 7.43x\nAlthough PASSCoDe is a simple extension of DCD in a multi-core setting, there are many options in terms of locking/atomic operations for each step, and these choices lead to variations in speed and convergence properties, as we will show in this paper.\nNote that the ∆αi obtained by subproblem (5) is exactly the same as (4) in Algorithm 1 if only one thread is involved. However, when there are multiple threads, the w vector may not be the latest one since some other threads have not completed the writes in step 3.\nPASSCoDe-Lock. To ensure w = ∑\ni αixi for the latest α, we have to lock the following variables between step 1 and 2:\nstep 1.5: lock variables in Ni := {wt | (xi)t 6= 0}.\nThe locks are then released after step 3. With this locking mechanism, PASSCoDe-Lock will be serializable, i.e., generate the same solution sequence with the serial DCD. Unfortunately, threads will waste a lot of time due to the locks, so PASSCoDe-Lock is very slow comparing to the non-locking version (and even slower than the serial version of DCD). See Table 1 for details.\nPASSCoDe-Atomic. The above locking scheme is to ensure that each thread updates αi based on the latest w values. However, as shown in (Niu et al., 2011; Liu & Wright, 2014), the effect of using slightly stale values is usually limited in practice. Therefore, we propose an PASSCoDe-Atomic algorithm that avoids locking all the variables in Ni simultaneously. Instead, each thread just reads the current w values from memory without any locking. In practice (see Section 5) we observe that the convergence speed is not significantly affected by using values of w. However, to ensure that the limit point of the algorithm is still the global optimizer of (1), the equation w∗ = ∑ i α ∗ ixi has to be maintained. Therefore, we apply the following “atomic writes” in step 3:\nstep 3: For each j ∈ N(i) Update wj ← wj + ∆αi(xi)j atomically\nPASSCoDe-Atomic is much faster than PASSCoDe-Lock as shown in Table 1 since the atomic writes for a single variable is much faster than locking all the variables. However, the convergence of PASSCoDe-Atomic is not guaranteed by any previous convergence analysis. To bridge this gap between practice and theory, we prove linear convergence of PASSCoDe-Atomic under certain conditions in Section 4.\nPASSCoDe-Wild. Finally, we consider Algorithm 2 without any locks and atomic operations. The resulting algorithm, PASSCoDe-Wild, is faster than PASSCoDe-Atomic and PASSCoDe-Lock and can achieve almost linear speedup using a single processing unit. However, due to the memory conflicts in step 3, some of the ”updates” to w will be over-written by other threads. As a result, the ŵ and α̂ outputted by the algorithm usually do not satisfy Eq (3):\nŵ 6= w̄ := ∑ i α̂ixi, (6)\nwhere ŵ, α̂ are the primal and dual variables outputted by the algorithm, and w̄ defined in (6) is computed from α̂. It is easy to see that α̂ is not the optimal solution of (2). Due to the same reason, in the prediction phase it is not clear whether ŵ or w̄ should be used. To answer this question, in Section 4 we show that ŵ is actually the optimal solution of a perturbed primal problem (1) using a backward error analysis, where the loss function is the same and the regularization term is slightly perturbed. As a result, the prediction should be done using ŵ, and this also yields much better performance in practice, as shown in Table 2 below.\nWe summarize the behavior of the three algorithms in Figure 1. Using locks, the algorithm PASSCoDeLock is serializable but very slow (even slower than the serial DCD). In the other extreme, the wild version without any lock and atomic operation has very good speed up, but the behavior can be totally different from the serial DCD. Luckily, in Section 4 we provide the convergence guarantee for PASSCoDe-Atomic, and apply a backward error analysis to show that PASSCoDe-Wild will converge to the solution with the same loss function with a slightly perturbed regularizer."
    }, {
      "heading" : "3.3 Implementation Details",
      "text" : "Deadlock Avoidance. Without a proper implementation, the deadlock can arise in PASSCoDe-Lock because a thread needs to acquire all the locks associated with Ni. A simple way to avoid deadlock is by associating an ordering for all the locks such that each thread follows the same ordering to acquire the locks.\nRandom Permutation. In LIBLINEAR, the random sampling (step 2) of Algorithm 1 is replaced by the index from a random permutation, such that each αi can be selected in n steps in stead of n log n steps in expectation. Random permutation can be easily implemented asynchronously for Algorithm 2 as follows. Initially, given p threads, {1, . . . , n} is randomly partitioned into p blocks. Then, each thread can asynchronously generate the random permutation on its own block of variables. Shrinking Heuristic. For loss such as hinge and squared-hinge, the optimal α∗ is usually sparse. Based on this property, a shrinking strategy was proposed by Hsieh et al. (2008) to further speed up DCD. This heuristic is also implemented in LIBLINEAR. The idea is to maintain an active set by skipping variables which tend to be fixed. This heuristic can also be implemented in Algorithm 2 by maintaining an active set for each thread. Thread Affinity. The memory design of most modern multi-core machines is non-uniform memory access (NUMA), where a core has faster memory access to its local memory socket. To reduce possible latency due to the remote socket access, we should bind each thread to a physical core and allocate data in its local memory. Note that the current OpenMP does not support this functionality for thread affinity. Library such as libnuma can be used to enforce thread affinity."
    }, {
      "heading" : "4 Convergence Analysis",
      "text" : "In this section we formally analyze the convergence properties of our proposed algorithms in Section 3. Note that all the proofs can be found in the Appendix. We assign a global counter j for the total number of updates, and the index i(j) denotes the component selected at step j. We define {α1,α2, . . . } to be the sequence generated by our algorithms, and\n∆αj = α j+1 i(j) − α j i(j).\nThe update ∆αj at iteration j is obtained by solving\n∆αj ← arg min δ\n1 2 ‖ŵj + δxi(j)‖2 + `∗i(j)(−(αi(j) + δ)),\nwhere ŵj is the currentw in the memory. We usewj = ∑\ni α j ixi to denote the “accurate”w at iteration j.\nIn the PASSCoDe-Lock setting,wj = ŵj is ensured by using the locks. However, in PASSCoDe-Atomic and PASSCoDe-Wild, ŵj 6= wj because some of the updates have not been written into the shared memory. To capture this phenomenon, we define Zj to be the set of all “updates to w” before iteration j:\nZj := {(t, k) | t < j, k ∈ N(i(t))},\nwhere N(i(t)) := {u | Xi(t),u 6= 0} is all nonzero features in xi(t). We define U j ⊆ Zj to be the updates that have already been written into ŵj . Therefore, we have\nŵj = ∑\n(t,k)∈Uj (∆αt)Xi(t),kek.\n4.1 Linear Convergence of PASSCoDe-Atomic\nIn PASSCoDe-Atomic, we assume all the updates before the (j − τ)-th iteration has been written into ŵj , therefore,\nAssumption 1. The set U j satisfies Zj−τ ⊆ U j ⊆ Zj .\nNow we define some constants used in our theoretical analysis. Note that X ∈ Rn×d is the data matrix, and we use X̄ ∈ Rn×d to denote the normalized data matrix where each row is x̄Ti = xTi /‖xi‖2. We then define\nMi = max S⊆[d] ‖ ∑ t∈S X̄:,tXi,t‖, M = max i Mi,\nwhere [d] := {1, . . . , d} is the set of all the feature indices, and X̄:,t is the t-th column of X̄ . We also define Lmax to be the Lipschitz constant of D(·) within the level set {α | D(α) ≤ D(α0)}, Rmin = mini ‖xi‖2, Rmax = maxi ‖xi‖2. We assume that Rmax = 1 and there is no zero training sample, so Rmin > 0.\nTo prove the convergence of asynchronous algorithms, we first show that the expected step size does not increase super-linearly by the following Lemma 1.\nLemma 1. If τ is small enough such that\n(6τ(τ + 1)2eM)/ √ n ≤ 1, (7)\nthen PASSCoDe-Atomic satisfies the following inequality:\nE(‖αj−1 −αj‖2) ≤ ρE(‖αj −αj+1‖2), (8)\nwhere ρ = (1 + 6(τ+1)eM√ n )2.\nThe detailed proof is in Appendix A.2. We use a similar technique as in (Liu & Wright, 2014) to prove this lemma, but the proof is different from (Liu & Wright, 2014) because • Their “inconsistent read” model assumes ŵj = ∑ i α̇ixi for some α̇. However, in our case ŵ\nj may not be written in this form due to incomplete updates in step 3 of Algorithm 2. • In (Liu & Wright, 2014), each coordinate is updated by γ∇tf(α) with a fixed step size γ. We consider\nthe case that each subproblem (4) is solved exactly. To show the linear convergence of our algorithms, we assume the objective function (2) satisfies the following property:\nDefinition 1. The objective function (2) admits the global error bound if there is a constant κ such that\n‖α− PS(α)‖ ≤ κ‖T (α)−α‖, (9)\nwhere PS(·) is the projection to the set of optimal solutions, and T : Rn → Rn is the operator defined by\nTt(α) = arg min u\nD(α+ (u− αt)et) ∀t = 1, . . . , n.\nThe objective function satisfies the global error bound from the beginning if (9) holds for all α satisfying\nD(α) ≤ D(α0)\nwhere α0 is the initial point.\nThis definition is a generalized version of Definition 6 in (Wang & Lin, 2014). We list several important machine learning problems that admit global error bounds:\n• Support Vector Machines (SVM) with hinge loss (Boser et al., 1992):\n`i(zi) = C max(1− zi, 0)\n`∗i (−αi) = { −αi if 0 ≤ αi ≤ C, ∞ otherwise.\n(10)\n• Support Vector Machines (SVM) with square hinge loss:\n`i(zi) = C max(1− zi, 0)2.\n`∗i (−αi) = { −αi + α2i /4C if αi ≥ 0, ∞ otherwise.\n(11)\nNote that C > 0 is the penalty parameter that controls the weights between loss and regularization.\nTheorem 1. The Support Vector Machines (SVM) with hinge loss or square hinge loss satisfy the global error bound (9).\nProof. For SVM with hinge loss, each element of the mapping T (·) can be written as\nTt(α) = arg min u\nD(α+ (u− αt)et)\n= arg min u\n1 2 ‖w(α) + (u− αt)xt‖2 + `∗(−u)\n= ΠX (w(α)Txt − 1 ‖xt‖2 ) = ΠX (∇tD(α) ‖xt‖2 ) ,\nwhere ΠX is the projection to the set X, and for hinge-loss SVM X := [0, C]. Using Lemma 26 in (Wang & Lin, 2014), we can show that for all t = 1, . . . , n\n∣∣αt −ΠX(∇tD(α)‖xt‖2 )∣∣ ≥min(1, 1‖xt‖2 )∣∣αt −ΠX(∇tD(α))∣∣ ≥min(1, 1\nR2max ) ∣∣αt −ΠX(∇tD(α))∣∣\n≥ ∣∣αt −ΠX(∇tD(α))∣∣,\nwhere the last inequality is due to the assumption that Rmax = 1. Therefore,\n‖α− T (α)‖2 ≥ 1√ n ‖α− T (α)‖1\n≥ 1√ n n∑ t=1 |αt −ΠX ( ∇tD(α) ) | = 1√ n ‖∇+D(α)‖1\n≥ 1√ n ‖∇+D(α)‖2\n≥ 1 κ0 √ n ‖α− PS(α)‖2,\nwhere ∇+D(α) is the projected gradient defined in Definition 5 of (Wang & Lin, 2014) and κ0 is the κ defined in Theorem 18 of (Wang & Lin, 2014). Thus, with κ = κ0 √ n, we obtain that the dual function of the hinge-loss SVM satisfies the global error bound defined in Definition 1. Similarly, we can show that the SVM with squared-hinge loss satisfies the global error bound.\nNext we explicitly state the linear convergence guarantee for PASSCoDe-Atomic.\nTheorem 2. Assume the objective function (2) admits a global error bound from the beginning and the Lipschitz constant Lmax is finite in the level set. If (7) holds and\n1 ≥ 2Lmax R2min (1 + eτM√ n )( τ2M2e2 n )\nthen PASSCoDe-Atomic has a global linear convergence rate in expectation, that is,\nE[D(αj+1)]−D(α∗) ≤ η ( E[D(αj)]−D(α∗) ) , (12)\nwhere α∗ is the optimal solution and\nη = 1− κ Lmax (1− 2Lmax R2min (1 + eτM√ n )( τ2M2e2 n )) (13)\n4.2 Backward Error Analysis for PASSCoDe-Wild\nIn PASSCoDe-Wild, assume the sequence {αj} converges to α̂ and {wj} converges to ŵ. Now we show that the dual solution α̂ and the corresponding primal variables w̄ = ∑n i=1 α̂ixi are actually the dual and primal solutions of a perturbed problem:\nTheorem 3. α̂ is the optimal solution of a perturbed dual problem\nα̂ = arg min α D(α)− n∑ i=1 αi Txi, (14)\nand w̄ = ∑\ni α̂ixi is the solution of the corresponding primal problem:\nw̄ = arg min w\n1 2 wTw + n∑ i=1 `i((w − )Txi), (15)\nwhere ∈ Rd is given by = w̄ − ŵ.\nProof. By definition, α̂ is the limit point of PASSCoDe-Wild. Therefore, {∆αi} → 0 for all i. Combining with the fact that {ŵj} → ŵ, we have\n−ŵTxi ∈ ∂αi`∗i (−α̂i), ∀i.\nSince ŵ = w̄ − , we have\n−(w̄ − )Txi ∈ ∂αi`∗i (−α̂i), ∀i −w̄Txi ∈ ∂αi ( `∗i (−α̂i)− α̂i Txi ) , ∀i\n0 ∈ ∂αi\n( 1\n2 ‖ n∑ i=1 α̂ixi‖2 + `∗i (−α̂i)− α̂i Txi\n) , ∀i\nwhich is the optimality condition of (14). Thus, α̂ is the optimal solution of (14). For the second part of the theorem, let’s consider the following equivalent primal problem and its Lagrangian:\nmin w,ξ\n1 2 wTw + n∑ i=1 `i(ξi) s.t. ξi = (w − )Txi ∀i = 1, . . . , n\nL(w, ξ,α) := 1\n2 wTw + n∑ i=1 {`i(ξi) + αi(ξi −wTxi + Txi)}\nThe corresponding convex version of the dual function can be derived as follows.\nD̂(α) = max w,ξ −L(w, ξ,α)\n= ( max w −1 2 wTw + n∑ i=1 αiw Txi ) + n∑ i=1 ( max ξi −`i(ξi)− αiξi ) − αi Txi\n= 1\n2 ‖ n∑ i=1 αixi‖2 + n∑ i=1 `∗i (−αi)− αi Txi\n= D(α)− n∑ i=1 αi Txi\nThe last second equality comes from 1) the substitution of w∗ = ∑T\ni=1 αixi obtained by setting ∇w − L(w, ξ,α) = 0; 2) the definition of the conjugate function `∗i (−αi). Thus, the second part of the theorem follows.\nNote that is the error caused by the memory conflicts. From Theorem 3, w̄ is the optimal solution of the “biased” primal problem (15), however, in (15) the actual model that fits the loss function should be ŵ = w̄− . Therefore after the training process we should use ŵ to predict, which is thew we maintained during the parallel coordinate descent updates. Replacing w by w − in (15), we have the following corollary :\nCorollary 1. ŵ computed by PASSCoDe-Wild is the solution of the following perturbed primal problem:\nŵ = arg min w\n1 2 (w + )T (w + ) + n∑ i=1 `i(w Txi) (16)\nThe above corollary shows that the computed primal solution ŵ is actually the exact solution of a perturbed problem (where the perturbation is on the regularizer). This strategy (of showing that the computed solution to a problem is the exact solution of a perturbed problem) is inspired by the backward error analysis technique commonly employed in numerical analysis (Wilkinson, 1961)1."
    }, {
      "heading" : "5 Experimental Results",
      "text" : "We conduct several experiments and show that the proposed PASSCoDe-Atomic and PASSCoDe-Wild have superior performance compared to other state-of-the-art parallel coordinate descent algorithms. We consider the hinge loss and five datasets: news20, covtype, rcv1, webspam, and kddb. Detailed information is shown in Table 3. To have a fair comparison, we implement all compared methods in C++ using OpenMP as the parallel programming framework. All the experiments are performed on an Intel multi-core dual-socket machine with 256 GB memory. Each socket is associated with 10 computation cores. We explicitly enforce that all the threads use cores from the same socket to avoid inter-socket communication. Our codes will be publicly available. We focus on solving the (hinge loss) SVM (see (5) in the Appendix) in the experiments, but the algorithms can also be applied to other objective functions. Note that some of the figures are in Appendix 6.\nSerial Baselines. • DCD: we implement Algorithm 1. Instead of sampling with replacement, a random permutation is\nused to enforce random sampling without replacement. • LIBLINEAR: we use the implementation in http://www.csie.ntu.edu.tw/˜cjlin/liblinear.\nThis implementation is equivalent to DCD with the shrinking strategy. Compared Parallel Implementation. • PASSCoDe: We implement the proposed three variants of Algorithm 2 using DCD as the building\nblock: Wild, Atomic, and Lock. • CoCoA: We implement a multi-core version of CoCoA (Jaggi et al., 2014) with βK = 1 and DCD as\nits local dual method. • AsySCD: We follow the description in (Liu & Wright, 2014; Liu et al., 2014) to implement AsySCD\nwith the step length γ = 12 and the shuffling period p = 10 as suggested in (Liu et al., 2014).\n1J. H. Wilkinson received the Turing Award in 1970, partly for his work on backward error analysis"
    }, {
      "heading" : "5.1 Convergence in terms of iterations.",
      "text" : "The primal objective function value is used to determine the convergence. Note that we still use P (ŵ) for PASSCoDe-Wild, although the true primal objective should be (16). As long as ŵT remains small enough, the trend of (16) and P (ŵ) are similar.\nFigure 4(a), 5(a), 6(a) show the convergence results of PASSCoDe-Wild, PASSCoDe-Atomic, CoCoA, and AsySCD with 10 threads in terms of number of iterations. The horizontal line in grey indicates the primal objective function value obtained by LIBLINEAR using the default stopping condition. The result for LIBLINEAR is also included for reference. We have the follow observations • Convergence of three PASSCoDe variants are almost identical and very close to the convergence\nbehavior of serial LIBLINEAR on three large sparse datasets (rcv1, webspam, and kddb). • PASSCoDe-Wild and PASSCoDe-Atomic converge significantly faster than CoCoA. • On covtype, a more dense dataset, all three algorithms (PASSCoDe-Wild, PASSCoDe-Atomic, and\nCoCoA) have slower convergence."
    }, {
      "heading" : "5.2 Efficiency.",
      "text" : "Timing. To have a fair comparison, we include both initialization and computation into the timing results. For DCD, PASSCoDe, CoCoA, initialization takes one pass of entire data matrix (which is O(nnz(X))) to compute ‖xi‖ for each instance. In the initialization stage, AsySCD requires O(n × nnz(X)) time and O(n2) space to form and store the Hessian matrix Q for (2). Thus, we only have results on news20 for AsySCD as all other datasets are too large for AsySCD to fit Q in even 256 GB memory. Note that we also parallelize the initialization part for each algorithm in our implementation to have a fair comparison.\nFigures 2(b), 3(b), 4(b), 5(b), 6(b) show the primal objective values in terms of time and Figures 2(c), 3(c), 4(c), 5(c), 6(c) shows the accuracy in terms of time. Note that the x-axis for news20, covtype, and rcv1 is in log-scale. A horizontal line in gray in each figure denotes the objective values/accuracy obtained by LIBLINEAR using the default stopping condition. We have the following observations: • From Figures 4(b) and 4(c), we can see that AsySCD is orders of magnitude slower than other ap-\nproaches including parallel methods and serial reference (AsySCD using 10 cores takes 0.4 seconds to run 10 iterations, while all the other parallel approaches takes less than 0.14 seconds, and LIBLINEAR takes less than 0.3 seconds). In fact, AsySCD is still slower than other methods even when the initialization time is excluded. This is expected because AsySCD is a parallel version of a standard coordinate descent method, which is known to be much slower than DCD for (2). Since AsySCD runs out of memory for all the other larger datasets, we do not show the results in other figures. • In most figures, both PASSCoDe approaches outperform CoCoA. In Figure 6(c), kddb shows better\naccuracy performance in the early stage which can be explained by the ensemble nature of CoCoA. In the long term, it still converges to the accuracy obtained by LIBLINEAR. • For all datasets, PASSCoDe-Wild is shown to be slightly faster than PASSCoDe-Atomic. Given the fact\nthat both methods show similar convergence in terms of iterations, this phenomenon can be explained by the effect of atomic operations. We can observe that more dense the dataset, larger the difference between PASSCoDe-Wild and PASSCoDe-Atomic."
    }, {
      "heading" : "5.3 Speedup",
      "text" : "We are interested in the following evaluation criterion:\nspeedup := time taken by the target method with p threads time taken by the best serial reference method ,\nThis criterion is different from scaling, where the denominator is replaced by “time taken for the target method with single thread.” Note that a method can have perfect scaling but very poor speedup. Figures 2(d), 3(d), 4(d), 5(d), 6(d) shows the speedup results, where 1) DCD is used as the best serial reference; 2) the shrinking heuristic is turned off for all PASSCoDe and DCD to have fair comparison; 3) the initialization time is excluded from the computation of speedup. • PASSCoDe-Wild has very good speedup performance compared to other approaches. It achieves about\n6 to 8 speedups using 10 threads on all the datasets. • From Figure 2(d), we can see that AsySCD does not have any “speedup” over the serial reference,\nalthough it is shown to have almost linear scaling (Liu et al., 2014; Liu & Wright, 2014)."
    }, {
      "heading" : "6 Conclusions",
      "text" : "In this paper, we present a family of parallel asynchronous stochastic dual coordinate descent algorithms in the shared memory multi-core setting, where each thread repeatedly selects a random dual variable and conducts coordinate updates using the primal variables that are stored in the shared memory. We analyze the convergence properties when different locking/atomic mechanism is used. For the setting with atomic updates, we show the linear convergence under certain condition. For the setting without any lock or atomic write, which achieves the best speed up, we present a backward error analysis to show that the primal variables obtained by the algorithm is the exact solution for a primal problem with perturbed regularizer. Experimental results show that our algorithms are much faster than previous parallel coordinate descent solvers.\n(a) Convergence\n(b) Objective\n(c) Accuracy\n(d) Speedup\n(a) Convergence\n(b) Objective\n(c) Accuracy\n(d) Speedup\n(a) Convergence\n(b) Objective\n(c) Accuracy\n(d) Speedup\nFigure 4: rcv1 dataset\n(a) Convergence\n(b) Objective\n(c) Accuracy\n(d) Speedup\nFigure 5: webspam dataset\n(a) Convergence\n(b) Objective\n(c) Accuracy\n(d) Speedup\nFigure 6: kddb dataset"
    }, {
      "heading" : "A.1 Notations and Prepositions",
      "text" : ""
    }, {
      "heading" : "A.1.1 Notations",
      "text" : "• For all i = 1, . . . , n, we have the following definitions:\nhi(u) := `∗i (−u) ‖xi‖2\nproxi(s) := arg minu\n1 2 (u− s)2 + hi(u)\nTi(w, s) := arg min u\n1 2 ‖w + (u− s)xi‖2 + `∗i (−u)\n= arg min u\n1\n2\n[ u− (s− w\nTxi ‖xi‖2 )\n]2 + hi(u),\nwherew ∈ Rd and s ∈ R. We also denote prox(s) as the proximal operator from Rn to Rn such that (prox(x))i = proxi(si). We can see the connection of the above operator and the proximal operator: Ti(w, s) = proxi(s− w Txi ‖xi‖2 ).\n• Let {αj} and {ŵj} be the sequence generated/maintained by Algorithm 2 using\nαj+1t =\n{ Tt(ŵ\nj , αjt ) if t = i(j), αjt if t 6= i(j),\nwhere i(j) is the index selected at j-th iteration. For convenience, we define\n∆αj = α j+1 i(j) − α j i(j).\n• Let {α̃j} be the sequence defined by\nα̃j+1t = Tt(ŵ j , αjt ) ∀t = 1, . . . , n.\nNote that α̃j+1i(j) = α j+1 i(t) and α̃ j+1 = prox(αj − X̄ŵj).\n• Let w̄j = ∑\ni α j ixi be the “true” primal variables corresponding to α j ."
    }, {
      "heading" : "A.1.2 Prepositions",
      "text" : "Preposition 1. Ei(j)(‖αj+1 −αj‖2) = 1\nn ‖α̃j+1 −αj‖2. (17)\nProof. It can be proved by the definition of α̃ and the assumption that i(j) is uniformly random selected from {1, . . . , n}.\nPreposition 2.\n‖X̄w̄j − X̄ŵj‖ ≤M j−1∑ t=j−τ |∆αt|. (18)"
    }, {
      "heading" : "Proof.",
      "text" : "‖X̄w̄j − X̄ŵj‖ = ‖X̄( ∑\n(t,k)∈Zj\\Uj (∆αt)Xi(t),kek)‖ = ‖ ∑ (t,k)∈Zj\\Uj (∆αt)X̄:,kXi(t),k‖\n≤ j−τ∑ t=j−1 |∆αt|Mi ≤M j−1∑ t=j−τ |∆αt|\nPreposition 3. For any w1,w2 ∈ Rd and s1, s2 ∈ R,\n|Ti(w1, s1)− Ti(w2, s2)| ≤ |s1 − s2 + (w1 −w2)Txi ‖xi‖2 |. (19)\nProof. It can be proved by the connection of Ti(w, s) and proxi(·) and the non-expansiveness of the proximal operator.\nPreposition 4. Let M ≥ 1, q = 6(τ+1)eM√ n\n, ρ = (1 + q)2, and θ = ∑τ\nt=1 ρ t/2. If M ≥ 1 and q(τ + 1) ≤ 1,\nthen ρ(τ+1)/2 ≤ e, and\nρ−1 ≤ 1− 4 + 4M + 4Mθ√ n . (20)\nProof. By the definition of ρ and the condition q(τ + 1) ≤ 1, we have\nρ(τ+1)/2 = (( ρ1/2 )1/q)q(τ+1) = ( (1 + q)1/q )q(τ+1) ≤ eq(τ+1) ≤ e.\nBy the definitions of q, we know that\nq = ρ1/2 − 1 = 6(τ + 1)eM√ n ⇒ 3 2 =\n√ n(ρ1/2 − 1)\n4(τ + 1)eM .\nWe can derive\n3 2 =\n√ n(ρ1/2 − 1)\n4(τ + 1)eM\n≤ √ n(ρ1/2 − 1)\n4(τ + 1)ρ(τ+1)/2M ∵ ρ(τ+1)/2 ≤ e\n≤ √ n(ρ1/2 − 1)\n4(1 + θ)ρ1/2M ∵ 1 + θ = τ∑ t=0 ρt/2 ≤ (τ + 1)ρτ/2\n= √ n(1− ρ−1/2) 4(1 + θ)M ≤ √ n(1− ρ−1)\n4(1 + θ)M ∵ ρ−1/2 ≤ 1\nCombining the condition that M ≥ 1 and 1 + θ ≥ 1, we have √ n(1− ρ−1)− 4 4(1 + θ)M ≥ √ n(1− ρ−1) 4(1 + θ)M − 1 2 ≥ 1,\nwhich leads to\n4(1 + θ)M ≤ √ n− √ nρ−1 − 4\nρ−1 ≤ 1− 4 + 4M + 4Mθ√ n ."
    }, {
      "heading" : "A.2 Proof of Lemma 1",
      "text" : "Similar to Liu & Wright (2014), we prove Eq. (8) by induction. First, we know that for any two vectors a and b, we have\n‖a‖2 − ‖b‖2 ≤ 2‖a‖‖b− a‖.\nSee Liu & Wright (2014) for a proof for the above inequality. Thus, for all j , we have\n‖αj−1 − α̃j‖2 − ‖αj − α̃j+1‖2 ≤ 2‖αj−1 − α̃j‖‖αj − α̃j+1 −αj−1 + α̃j‖. (21)\nThe second factor in the r.h.s of (21) is bounded as follows:\n‖αj − α̃j+1 −αj−1 + α̃j‖ ≤ ‖αj −αj−1‖+ ‖ prox(αj − X̄ŵj)− prox(αj−1 − X̄ŵj−1)‖ ≤ ‖αj −αj−1‖+ ‖(αj − X̄ŵj)− (αj−1 − X̄ŵj−1)‖ ≤ ‖αj −αj−1‖+ ‖αj −αj−1‖+ ‖X̄ŵj − X̄ŵj−1‖ = 2‖αj −αj−1‖+ ‖X̄ŵj − X̄ŵj−1‖ = 2‖αj −αj−1‖+ ‖X̄ŵj − X̄w̄j + X̄w̄j − X̄w̄j−1 + X̄w̄j−1 − X̄ŵj−1‖ ≤ 2‖αj −αj−1‖+ ‖X̄w̄j − X̄w̄j−1‖+ ‖X̄ŵj − X̄w̄j‖+ ‖X̄w̄j−1 − X̄ŵj−1‖\n≤ (2 +M)‖αj −αj−1‖+ j−1∑ t=j−τ ‖∆αt‖M + j−2∑ t=j−τ−1 ‖∆αt‖M = (2 + 2M)‖αj −αj−1‖+ 2M j−2∑\nt=j−τ−1 ‖∆αt‖ (22)\nNow we prove (8) by induction. Induction Hypothesis. Due to Preposition 1, we prove the following equivalent statement. For all j,\nE(‖αj−1 − α̃j‖2) ≤ ρE(‖αj − α̃j+1‖2), (23)\nInduction Basis. When j = 1,\n‖α1 − α̃2 +α0 − α̃1‖ ≤ (2 + 2M)‖α1 −α0‖.\nBy taking the expectation on (21), we have\nE[‖α0 − α̃1‖2]− E[‖α1 − α̃2‖2] ≤ 2E[‖α0 − α̃1‖‖α1 − α̃2 −α0 + α̃1‖] ≤ (4 + 4M)E(‖α0 − α̃1‖‖α0 −α1‖).\nFrom (17) we have E[‖α0 −α1‖2] = 1n‖α 0 − α̃1‖2. Also, by AM-GM inequality, for any µ1, µ2 > 0 and any c > 0, we have\nµ1µ2 ≤ 1\n2 (cµ21 + c −1µ22). (24)\nTherefore, we have\nE[‖α0 − α̃1‖‖α0 −α1‖] ≤ 1 2 E [ n1/2‖α0 −α1‖2 + n−1/2‖α̃1 −α0‖2 ] = 1 2 E [ n−1/2‖α0 − α̃1‖2 + n−1/2‖α̃1 −α0‖2 ] by (17)\n= n−1/2E[‖α0 − α̃1‖2].\nTherefore,\nE[‖α0 − α̃1‖2]− E[‖α1 − α̃2‖2] ≤ 4 + 4M√ n E[‖α0 − α̃1‖2],\nwhich implies\nE[‖α0 −α1‖2] ≤ 1 1− 4+4M√\nn\nE[‖α1 − α̃2‖2] ≤ ρE[‖α1 − α̃2‖2], (25)\nwhere the last inequality is based on Preposition 4 and the fact θM ≥ 1. Induction Step. By the induction hypothesis, we assume\nE[‖αt−1 − α̃t‖2] ≤ ρE[‖αt − α̃t+1‖2] ∀t ≤ j − 1. (26)\nThe goal is to show E[‖αj−1 − α̃j‖2] ≤ ρE[‖αj − α̃j+1‖2].\nFirst, we show that for all t < j,\nE [ ‖αt −αt+1‖‖αj−1 − α̃j‖ ] ≤ ρ\n(j−1−t)/2 √ n\nE [ ‖αj−1 − α̃j‖2 ] (27)\nProof. By (24) with c = n1/2β, where β = ρ(t+1−j)/2,\nE [ ‖αt −αt+1‖‖αj−1 − α̃j‖ ] ≤ 1 2 E [ n1/2β‖αt −αt+1‖2 + n−1/2β−1‖αj−1 − α̃j‖2\n] = 1 2 E [ n1/2βE[‖αt −αt+1‖2] + n−1/2β−1‖αj−1 − α̃j‖2\n] = 1 2 E [ n−1/2β‖αt − α̃t+1‖2 + n−1/2β−1‖αj−1 − α̃j‖2 ] by Preposition 1\n≤ 1 2 E [ n−1/2βρj−1−t‖αj−1 − α̃j‖2 + n−1/2β−1‖αj−1 − α̃j‖2 ] by Eq. (26)\n≤ 1 2 E [ n−1/2β−1‖αj−1 − α̃j‖2 + n−1/2β−1‖α̃j−1 −αj‖2 ] by the definition of β ≤ ρ (j−1−t)/2 √ n E [ ‖αj−1 − α̃j‖2 ]\nLet θ = ∑τ\nt=1 ρ t/2. We have\nE[‖αj−1 − α̃j‖2]− E[‖αj − α̃j+1‖2]\n≤ E [ 2‖αj−1 − α̃j‖ ( (2 + 2M)‖αj −αj−1‖+ 2M j−1∑ t=j−τ−1 ‖αt −αt−1‖ )] by (21), (22) = (4 + 4M)E(‖αj−1 − α̃j‖‖αj −αj−1‖) + 4M j−1∑\nt=j−τ−1 E [ ‖αj−1 − α̃j‖‖αt −αt−1‖ ]\n≤ (4 + 4M)n−1/2E[‖α̃j −αj−1‖2] + 4Mn−1/2E[‖αj−1 − α̃j‖2] j−2∑\nt=j−1−τ ρ(j−1−t)/2 by (27)\n≤ (4 + 4M)n−1/2E[‖α̃j −αj−1‖2] + 4Mn−1/2θE[‖αj−1 − α̃j‖2]\n≤ 4 + 4M + 4Mθ√ n E[‖αj−1 − α̃j‖2],\nwhich implies that\nE[‖αj−1 − α̃j‖2] ≤ 1 1− 4+4M+4Mθ√\nn\nE[‖αj − α̃j+1‖2] ≤ ρE[‖αj − α̃j+1‖2],\nwhere the last inequality is based on Preposition 4."
    }, {
      "heading" : "A.3 Proof of Theorem 2",
      "text" : "First, we define T (w,α) to be a n-dimensional vector such that\n(T (w,α))t = Tt(w,αt) for all t,\nWe can then bound the distanceE[‖T (wj ,αj)−T (ŵj ,αj)‖2] by (we omit the expectation in the following derivation):\n‖T (wj ,αj)− T (ŵj ,αj)‖2 = n∑ t=1 ( Tt(w j , αjt )− Tt(ŵ j , αjt ) )2 ≤ ∑ t ((wj − ŵj)Txt ‖xt‖2\n)2 (By Proposition 2) = ‖X̄(wj − ŵj)‖2 ≤M2 ( j−1∑ t=j−τ ‖αt+1 −αt‖ )2 (By Proposition 3) ≤ τM2 ( j−1∑ t=j−τ ‖αt+1 −αt‖2 )\n≤ τM2 ( τ∑ t=1 ρt‖αj −αj+1‖2 ) (By Lemma 1)\n≤ τM 2\nn ( τ∑ t=1 ρt)‖T (ŵj ,αj)−αj‖2\n≤ τ 2M2\nn ρτ‖T (ŵj ,αj)−αj‖2\nSince ρ(τ+1)/2 ≤ e, we have ρτ+1 ≤ e2, so ρτ ≤ e2 since ρ ≥ 1. Therefore,\n‖T (wj ,αj)− T (ŵj ,αj)‖2 ≤ τ 2M2e2\nn ‖T (ŵj ,αj)−αj‖2. (28)\nAs a result,\n‖T (wj ,αj)−αj‖2 = ‖T (wj ,αj)− T (ŵj ,αj) + T (ŵj ,αj)−αj‖2 ≤ 2 ( ‖T (wj ,αj)− T (ŵj ,αj)‖2 + ‖T (ŵj ,αj)−αj‖2 ) ≤ 2(1 + e 2τ2M2\nn )‖T (ŵj ,αj)−αj‖2. (29)\nNext, we bound the decrease of objective function value by\nD(αj)−D(αj+1) = D(αj)−D(ᾱj+1) +D(ᾱj+1)−D(αj+1)\n≥ ‖xi(j)‖2\n2 ‖αji(j) − Ti(j)(w j ,αj)‖2 − Lmax 2 ‖Ti(j)(wj ,αj)− Ti(j)(ŵj ,αj)‖2\nSo\nE[D(αj)]− E[D(αj+1)] ≥ R 2 min 2n E[‖T (wj ,αj)‖2]− Lmax 2n E[‖T (ŵj ,αj)−αj‖2]\n≥ R 2 min 2n E[‖T (wj ,αj)−αj‖2]− Lmax 2n τ2M2e2 n E[‖T (ŵj ,αj)−αj‖2] ≥ R 2 min\n2n E[‖T (wj ,αj)−αj‖2]− 2Lmax 2n\nτ2M2e2\nn (1 + eτM√ n )E[‖T (wj ,αj)−αj‖2]\n≥ R 2 min\n2n\n( 1− 2Lmax\nR2min (1 +\neτM√ n )( τ2M2e2 n )\n) E[‖T (wj ,αj)−αj‖2]\nLet b = (1− 2Lmax R2min (1 + eτM√ n )( τ 2M2e2 n )) and combine the above inequality with eq (9) we have\nE[D(αj)]− E[D(αj+1)] ≥ bκE[‖αj − PS(αj)‖2]\n≥ bκ Lmax E[D(αj)−D∗].\nTherefore, we have\nE[D(αj+1)]−D∗ = E[D(αj)]− (E[D(αj)]− E[D(αj+1)])−D∗\n≤ (1− bκ Lmax )(E[D(αj)]−D∗)."
    } ],
    "references" : [ {
      "title" : "Revisiting asynchronous linear solvers: Provable convergence rate through randomization",
      "author" : [ "H. Avron", "A. Druinsky", "A. Gupta" ],
      "venue" : "In IEEE International Parallel and Distributed Processing Symposium,",
      "citeRegEx" : "Avron et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Avron et al\\.",
      "year" : 2014
    }, {
      "title" : "Parallel and Distributed Computation: Numerical Methods",
      "author" : [ "Bertsekas", "Dimitri P", "Tsitsiklis", "John N" ],
      "venue" : null,
      "citeRegEx" : "Bertsekas et al\\.,? \\Q1989\\E",
      "shortCiteRegEx" : "Bertsekas et al\\.",
      "year" : 1989
    }, {
      "title" : "A training algorithm for optimal margin classifiers",
      "author" : [ "Boser", "Bernhard E", "Guyon", "Isabelle", "Vapnik", "Vladimir" ],
      "venue" : "In Proceedings of the Fifth Annual Workshop on Computational Learning Theory,",
      "citeRegEx" : "Boser et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Boser et al\\.",
      "year" : 1992
    }, {
      "title" : "Parallel coordinate descent for l1-regularized loss minimization",
      "author" : [ "Bradley", "Joseph K", "Kyrola", "Aapo", "Bickson", "Danny", "Guestrin", "Carlos" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Bradley et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Bradley et al\\.",
      "year" : 2011
    }, {
      "title" : "Coordinate descent method for large-scale L2-loss linear SVM",
      "author" : [ "Chang", "Kai-Wei", "Hsieh", "Cho-Jui", "Lin", "Chih-Jen" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Chang et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Chang et al\\.",
      "year" : 2008
    }, {
      "title" : "A dual coordinate descent method for large-scale linear SVM",
      "author" : [ "Hsieh", "Cho-Jui", "Chang", "Kai-Wei", "Lin", "Chih-Jen", "Keerthi", "S. Sathiya", "Sundararajan", "Sellamanickam" ],
      "venue" : "In Proceedings of the Twenty Fifth International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Hsieh et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Hsieh et al\\.",
      "year" : 2008
    }, {
      "title" : "Communication-efficient distributed dual coordinate ascent",
      "author" : [ "Jaggi", "Martin", "Smith", "Virginia", "Takáč", "Terhorst", "Jonathan", "Hofmann", "Thomas", "Jordan", "Michael I" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Jaggi et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Jaggi et al\\.",
      "year" : 2014
    }, {
      "title" : "A sequential dual method for large scale multi-class linear SVMs",
      "author" : [ "Keerthi", "S. Sathiya", "Sundararajan", "Sellamanickam", "Chang", "Kai-Wei", "Hsieh", "Cho-Jui", "Lin", "Chih-Jen" ],
      "venue" : "In Proceedings of the Forteenth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pp. 408–416,",
      "citeRegEx" : "Keerthi et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Keerthi et al\\.",
      "year" : 2008
    }, {
      "title" : "Asynchronous stochastic coordinate descent: Parallelism and convergence properties",
      "author" : [ "J. Liu", "S.J. Wright" ],
      "venue" : null,
      "citeRegEx" : "Liu and Wright,? \\Q2014\\E",
      "shortCiteRegEx" : "Liu and Wright",
      "year" : 2014
    }, {
      "title" : "An asynchronous parallel stochastic coordinate descent algorithm",
      "author" : [ "J. Liu", "S.J. Wright", "C. Re", "V. Bittorf" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Liu et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Liu et al\\.",
      "year" : 2014
    }, {
      "title" : "On the convergence of coordinate descent method for convex differentiable minimization",
      "author" : [ "Luo", "Zhi-Quan", "Tseng", "Paul" ],
      "venue" : "Journal of Optimization Theory and Applications,",
      "citeRegEx" : "Luo et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Luo et al\\.",
      "year" : 1992
    }, {
      "title" : "Efficiency of coordinate descent methods on huge-scale optimization problems",
      "author" : [ "Nesterov", "Yurii E" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "Nesterov and E.,? \\Q2012\\E",
      "shortCiteRegEx" : "Nesterov and E.",
      "year" : 2012
    }, {
      "title" : "HOGWILD!: a lock-free approach to parallelizing stochastic gradient descent",
      "author" : [ "Niu", "Feng", "Recht", "Benjamin", "Ré", "Christopher", "Wright", "Stephen J" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Niu et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Niu et al\\.",
      "year" : 2011
    }, {
      "title" : "Parallel coordinate descent methods for big data optimization",
      "author" : [ "Richtárik", "Peter", "Takáč", "Martin" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Richtárik et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Richtárik et al\\.",
      "year" : 2012
    }, {
      "title" : "On the nonasymptotic convergence of cyclic coordinate descent methods",
      "author" : [ "Saha", "Ankan", "Tewari", "Ambuj" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "Saha et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Saha et al\\.",
      "year" : 2013
    }, {
      "title" : "Feature clustering for accelerating parallel coordinate descent",
      "author" : [ "C. Scherrer", "A. Tewari", "M. Halappanavar", "D. Haglin" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "Scherrer et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Scherrer et al\\.",
      "year" : 2012
    }, {
      "title" : "Pegasos: primal estimated sub-gradient solver for SVM",
      "author" : [ "S. Shalev-Shwartz", "Y. Singer", "N. Srebro" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Shalev.Shwartz et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Shalev.Shwartz et al\\.",
      "year" : 2007
    }, {
      "title" : "Stochastic dual coordinate ascent methods for regularized loss minimization",
      "author" : [ "Shalev-Shwartz", "Shai", "Zhang", "Tong" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Shalev.Shwartz et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Shalev.Shwartz et al\\.",
      "year" : 2013
    }, {
      "title" : "Iteration complexity of feasible descent methods for convex optimization",
      "author" : [ "Wang", "Po-Wei", "Lin", "Chih-Jen" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Wang et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2014
    }, {
      "title" : "Trading computation for communication: Distributed stochastic dual coordinate ascent",
      "author" : [ "T. Yang" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "Yang,? \\Q2013\\E",
      "shortCiteRegEx" : "Yang",
      "year" : 2013
    }, {
      "title" : "Dual coordinate descent methods for logistic regression and maximum entropy models",
      "author" : [ "Yu", "Hsiang-Fu", "Huang", "Fang-Lan", "Lin", "Chih-Jen" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Yu et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Yu et al\\.",
      "year" : 2011
    }, {
      "title" : "Solving large scale linear prediction problems using stochastic gradient descent algorithms",
      "author" : [ "Zhang", "Tong" ],
      "venue" : "In Proceedings of the 21th International Conference on Machine Learning (ICML),",
      "citeRegEx" : "Zhang and Tong.,? \\Q2004\\E",
      "shortCiteRegEx" : "Zhang and Tong.",
      "year" : 2004
    } ],
    "referenceMentions" : [ {
      "referenceID" : 16,
      "context" : "Problem (1) is usually called the primal problem, and can usually be solved by Stochastic Gradient Descent (SGD) (Zhang, 2004; Shalev-Shwartz et al., 2007), second order methods (Lin et al.",
      "startOffset" : 113,
      "endOffset" : 155
    }, {
      "referenceID" : 4,
      "context" : ", 2007), or primal coordinate descent algorithms (Chang et al., 2008; Huang et al., 2009).",
      "startOffset" : 49,
      "endOffset" : 89
    }, {
      "referenceID" : 3,
      "context" : "The first thread focuses on synchronized algorithms, including synchronized CD (Richtárik & Takáč, 2012; Bradley et al., 2011) and synchronized DCD algorithms (Yang, 2013; Jaggi et al.",
      "startOffset" : 79,
      "endOffset" : 126
    }, {
      "referenceID" : 19,
      "context" : ", 2011) and synchronized DCD algorithms (Yang, 2013; Jaggi et al., 2014).",
      "startOffset" : 40,
      "endOffset" : 72
    }, {
      "referenceID" : 6,
      "context" : ", 2011) and synchronized DCD algorithms (Yang, 2013; Jaggi et al., 2014).",
      "startOffset" : 40,
      "endOffset" : 72
    }, {
      "referenceID" : 9,
      "context" : "To overcome this problem, the other thread of work focuses on asynchronous CD algorithms in multi-core shared memory systems (Liu & Wright, 2014; Liu et al., 2014).",
      "startOffset" : 125,
      "endOffset" : 163
    }, {
      "referenceID" : 4,
      "context" : "By maintaining w in memory, Hsieh et al. (2008); Keerthi et al.",
      "startOffset" : 28,
      "endOffset" : 48
    }, {
      "referenceID" : 4,
      "context" : "By maintaining w in memory, Hsieh et al. (2008); Keerthi et al. (2008) showed that the time complexity of each coordinate update can be reduced from O(nnz) to O(nnz/n), where nnz is number of nonzeros in the training dataset.",
      "startOffset" : 28,
      "endOffset" : 71
    }, {
      "referenceID" : 5,
      "context" : "Recently it has enjoyed renewed interest due to the success of “stochastic” coordinate descent in real applications (Hsieh et al., 2008; Nesterov, 2012).",
      "startOffset" : 116,
      "endOffset" : 152
    }, {
      "referenceID" : 5,
      "context" : "Many recent papers (Hsieh et al., 2008; Yu et al., 2011; ShalevShwartz & Zhang, 2013) have shown that solving the dual problem using coordinate descent algorithms is faster on large-scale datasets.",
      "startOffset" : 19,
      "endOffset" : 85
    }, {
      "referenceID" : 20,
      "context" : "Many recent papers (Hsieh et al., 2008; Yu et al., 2011; ShalevShwartz & Zhang, 2013) have shown that solving the dual problem using coordinate descent algorithms is faster on large-scale datasets.",
      "startOffset" : 19,
      "endOffset" : 85
    }, {
      "referenceID" : 9,
      "context" : "By maintaining a primal solutionw while updating dual variables, our algorithm is much faster than the previous asynchronous coordinate descent methods of (Liu & Wright, 2014; Liu et al., 2014) for solving the dual problem (2).",
      "startOffset" : 155,
      "endOffset" : 193
    }, {
      "referenceID" : 19,
      "context" : "Our algorithms are also faster than synchronized dual coordinate descent methods (Yang, 2013; Jaggi et al., 2014) since the latest values ofw can be accessed by all the threads.",
      "startOffset" : 81,
      "endOffset" : 113
    }, {
      "referenceID" : 6,
      "context" : "Our algorithms are also faster than synchronized dual coordinate descent methods (Yang, 2013; Jaggi et al., 2014) since the latest values ofw can be accessed by all the threads.",
      "startOffset" : 81,
      "endOffset" : 113
    }, {
      "referenceID" : 3,
      "context" : "Recently it has enjoyed renewed interest due to the success of “stochastic” coordinate descent in real applications (Hsieh et al., 2008; Nesterov, 2012). In terms of theoretical analysis, the convergence of (cyclic) coordinate descent has been studied for a long time (Luo & Tseng, 1992; Bertsekas, 1999), and the global linear convergence is presented recently under certain condition (Saha & Tewari, 2013; Wang & Lin, 2014). Stochastic Dual Coordinate Descent. Many recent papers (Hsieh et al., 2008; Yu et al., 2011; ShalevShwartz & Zhang, 2013) have shown that solving the dual problem using coordinate descent algorithms is faster on large-scale datasets. The success of SDCD strongly relies on exploiting the primal-dual relationship (3) to speed up the gradient computation in the dual space. DCD has become the state-of-the-art solver implemented in LIBLINEAR (Fan et al., 2008). In terms of convergence of dual objective function, some standard theoretical guarantees for coordinate descent can be directly applied. Different from standard analysis, Shalev-Shwartz & Zhang (2013) presented the convergence rate in terms of duality gap.",
      "startOffset" : 117,
      "endOffset" : 1089
    }, {
      "referenceID" : 3,
      "context" : "Recently it has enjoyed renewed interest due to the success of “stochastic” coordinate descent in real applications (Hsieh et al., 2008; Nesterov, 2012). In terms of theoretical analysis, the convergence of (cyclic) coordinate descent has been studied for a long time (Luo & Tseng, 1992; Bertsekas, 1999), and the global linear convergence is presented recently under certain condition (Saha & Tewari, 2013; Wang & Lin, 2014). Stochastic Dual Coordinate Descent. Many recent papers (Hsieh et al., 2008; Yu et al., 2011; ShalevShwartz & Zhang, 2013) have shown that solving the dual problem using coordinate descent algorithms is faster on large-scale datasets. The success of SDCD strongly relies on exploiting the primal-dual relationship (3) to speed up the gradient computation in the dual space. DCD has become the state-of-the-art solver implemented in LIBLINEAR (Fan et al., 2008). In terms of convergence of dual objective function, some standard theoretical guarantees for coordinate descent can be directly applied. Different from standard analysis, Shalev-Shwartz & Zhang (2013) presented the convergence rate in terms of duality gap. Parallel Stochastic Coordinate Descent. In order to conduct coordinate updates in parallel, Richtárik & Takáč (2012) studied the algorithm where each processor updates a randomly selected block (or coordinate) simultaneously, and Bradley et al.",
      "startOffset" : 117,
      "endOffset" : 1262
    }, {
      "referenceID" : 2,
      "context" : "In order to conduct coordinate updates in parallel, Richtárik & Takáč (2012) studied the algorithm where each processor updates a randomly selected block (or coordinate) simultaneously, and Bradley et al. (2011) proposed a similar algorithm for `1-regularized problems.",
      "startOffset" : 190,
      "endOffset" : 212
    }, {
      "referenceID" : 2,
      "context" : "In order to conduct coordinate updates in parallel, Richtárik & Takáč (2012) studied the algorithm where each processor updates a randomly selected block (or coordinate) simultaneously, and Bradley et al. (2011) proposed a similar algorithm for `1-regularized problems. Scherrer et al. (2012) studied parallel greedy coordinate descent.",
      "startOffset" : 190,
      "endOffset" : 293
    }, {
      "referenceID" : 2,
      "context" : "In order to conduct coordinate updates in parallel, Richtárik & Takáč (2012) studied the algorithm where each processor updates a randomly selected block (or coordinate) simultaneously, and Bradley et al. (2011) proposed a similar algorithm for `1-regularized problems. Scherrer et al. (2012) studied parallel greedy coordinate descent. However, the above synchronized methods usually face a trade-off in choosing the block size. If the block size is small, the load balancing problem leads to slow running time. If the block size is large, the convergence speed becomes much slower or the algorithm even diverges. These problems can be resolved by developing an asynchronous algorithm. Asynchronous coordinate descent has been studied by (Bertsekas & Tsitsiklis, 1989), but they require the Hessian to be diagonal dominant in order to establish the convergence. Recently, Liu et al. (2014); Liu & Wright (2014) proved linear convergence of asynchronous stochastic coordinate descent algorithms under the essential strong convexity condition and a “bounded staleness” condition, where they consider both “consistent read” and “inconsistent read” models.",
      "startOffset" : 190,
      "endOffset" : 891
    }, {
      "referenceID" : 2,
      "context" : "In order to conduct coordinate updates in parallel, Richtárik & Takáč (2012) studied the algorithm where each processor updates a randomly selected block (or coordinate) simultaneously, and Bradley et al. (2011) proposed a similar algorithm for `1-regularized problems. Scherrer et al. (2012) studied parallel greedy coordinate descent. However, the above synchronized methods usually face a trade-off in choosing the block size. If the block size is small, the load balancing problem leads to slow running time. If the block size is large, the convergence speed becomes much slower or the algorithm even diverges. These problems can be resolved by developing an asynchronous algorithm. Asynchronous coordinate descent has been studied by (Bertsekas & Tsitsiklis, 1989), but they require the Hessian to be diagonal dominant in order to establish the convergence. Recently, Liu et al. (2014); Liu & Wright (2014) proved linear convergence of asynchronous stochastic coordinate descent algorithms under the essential strong convexity condition and a “bounded staleness” condition, where they consider both “consistent read” and “inconsistent read” models.",
      "startOffset" : 190,
      "endOffset" : 912
    }, {
      "referenceID" : 0,
      "context" : "Avron et al. (2014) showed linear rate of convergence for the asynchronous randomized Gaussian-Seidel updates, which is a special case of coordinate descent on linear systems.",
      "startOffset" : 0,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "Avron et al. (2014) showed linear rate of convergence for the asynchronous randomized Gaussian-Seidel updates, which is a special case of coordinate descent on linear systems. Parallel Stochastic Dual Coordinate Descent. For solving (5), each coordinate updates only requires the global primal variables w and one local dual variable αi, thus algorithms only need to synchronize w. Based on this observation, Yang (2013) proposed to update several coordinates or blocks simultaneously and update the globalw, and Jaggi et al.",
      "startOffset" : 0,
      "endOffset" : 421
    }, {
      "referenceID" : 0,
      "context" : "Avron et al. (2014) showed linear rate of convergence for the asynchronous randomized Gaussian-Seidel updates, which is a special case of coordinate descent on linear systems. Parallel Stochastic Dual Coordinate Descent. For solving (5), each coordinate updates only requires the global primal variables w and one local dual variable αi, thus algorithms only need to synchronize w. Based on this observation, Yang (2013) proposed to update several coordinates or blocks simultaneously and update the globalw, and Jaggi et al. (2014) showed that each block can be solved with other approaches under the same framework.",
      "startOffset" : 0,
      "endOffset" : 533
    }, {
      "referenceID" : 20,
      "context" : "For SVM problems, the subproblem has a closed form solution, while for logistic regression problems it has to be solved by an iterative solver (see Yu et al. (2012) for details).",
      "startOffset" : 148,
      "endOffset" : 165
    }, {
      "referenceID" : 12,
      "context" : "However, as shown in (Niu et al., 2011; Liu & Wright, 2014), the effect of using slightly stale values is usually limited in practice.",
      "startOffset" : 21,
      "endOffset" : 59
    }, {
      "referenceID" : 5,
      "context" : "Based on this property, a shrinking strategy was proposed by Hsieh et al. (2008) to further speed up DCD.",
      "startOffset" : 61,
      "endOffset" : 81
    }, {
      "referenceID" : 2,
      "context" : "We list several important machine learning problems that admit global error bounds: • Support Vector Machines (SVM) with hinge loss (Boser et al., 1992): `i(zi) = C max(1− zi, 0) `i (−αi) = { −αi if 0 ≤ αi ≤ C, ∞ otherwise.",
      "startOffset" : 132,
      "endOffset" : 152
    }, {
      "referenceID" : 6,
      "context" : "• CoCoA: We implement a multi-core version of CoCoA (Jaggi et al., 2014) with βK = 1 and DCD as its local dual method.",
      "startOffset" : 52,
      "endOffset" : 72
    }, {
      "referenceID" : 9,
      "context" : "• AsySCD: We follow the description in (Liu & Wright, 2014; Liu et al., 2014) to implement AsySCD with the step length γ = 1 2 and the shuffling period p = 10 as suggested in (Liu et al.",
      "startOffset" : 39,
      "endOffset" : 77
    }, {
      "referenceID" : 9,
      "context" : ", 2014) to implement AsySCD with the step length γ = 1 2 and the shuffling period p = 10 as suggested in (Liu et al., 2014).",
      "startOffset" : 105,
      "endOffset" : 123
    }, {
      "referenceID" : 9,
      "context" : "• From Figure 2(d), we can see that AsySCD does not have any “speedup” over the serial reference, although it is shown to have almost linear scaling (Liu et al., 2014; Liu & Wright, 2014).",
      "startOffset" : 149,
      "endOffset" : 187
    } ],
    "year" : 2015,
    "abstractText" : "Stochastic Dual Coordinate Descent (DCD) has become one of the most efficient ways to solve the family of `2-regularized empirical risk minimization problems, including linear SVM, logistic regression, and many others. The vanilla implementation of DCD is quite slow; however, by maintaining primal variables while updating dual variables, the time complexity of DCD can be significantly reduced. Such a strategy forms the core algorithm in the widely-used LIBLINEAR package. In this paper, we parallelize the DCD algorithms in LIBLINEAR. In recent research, several synchronized parallel DCD algorithms have been proposed, however, they fail to achieve good speedup in the shared memory multi-core setting. In this paper, we propose a family of asynchronous stochastic dual coordinate descent algorithms (PASSCoDe). Each thread repeatedly selects a random dual variable and conducts coordinate updates using the primal variables that are stored in the shared memory. We analyze the convergence properties when different locking/atomic mechanisms are applied. For implementation with atomic operations, we show linear convergence under mild conditions. For implementation without any atomic operations or locking, we present the first backward error analysis for PASSCoDe under the multi-core environment, showing that the converged solution is the exact solution for a primal problem with perturbed regularizer. Experimental results show that our methods are much faster than previous parallel coordinate descent solvers.",
    "creator" : "LaTeX with hyperref package"
  }
}