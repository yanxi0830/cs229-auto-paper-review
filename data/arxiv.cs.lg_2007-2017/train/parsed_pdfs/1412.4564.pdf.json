{
  "name" : "1412.4564.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Convolutional Neural Networks for MATLAB",
    "authors" : [ "Andrea Vedaldi", "Karel Lenc" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n41 2.\n45 64\nv1 [\ncs .C\nV ]\n1 5\nD ec\n2 01\nContents"
    }, {
      "heading" : "1 Introduction 2",
      "text" : "1.1 MatConvNet on a glance . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.2 The structure and evaluation of CNNs . . . . . . . . . . . . . . . . . . . . . 4 1.3 CNN derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.4 CNN modularity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6"
    }, {
      "heading" : "2 Computational blocks 6",
      "text" : "2.1 Convolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.2 Pooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 2.3 ReLU . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 2.4 Normalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 2.5 Softmax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 2.6 Log-loss . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 2.7 Softmax log-loss . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11"
    }, {
      "heading" : "3 Network wrappers and examples 12",
      "text" : "3.1 Pre-trained models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 3.2 Learning models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 3.3 Running large scale experiments . . . . . . . . . . . . . . . . . . . . . . . . . 13"
    }, {
      "heading" : "4 About MatConvNet 14",
      "text" : "4.1 Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15"
    }, {
      "heading" : "1 Introduction",
      "text" : "MatConvNet is a simple MATLAB toolbox implementing Convolutional Neural Networks (CNN) for computer vision applications. This documents starts with a short overview of CNNs and how they are implemented inMatConvNet. Section 2 lists all the computational building blocks implemented in MatConvNet that can be combined to create CNNs and gives the technical details of each one. Finally, Section 3 discusses more abstract CNN wrappers and example code and models.\nA Convolutional Neural Network (CNN) can be viewed as a function f mapping data x, for example an image, on an output vector y. The function f is a composition of a sequence (or a directed acyclic graph) of simpler functions f1, . . . , fL, also called computational blocks in this document. Furthermore, these blocks are convolutional, in the sense that they map an input image of feature map to an output feature map by applying a translation-invariant and local operator, e.g. a linear filter. The MatConvNet toolbox contains implementation for the most commonly used computational blocks (described in Section 2) which can be used either directly, or through simple wrappers. Thanks to the modular structure, it is a simple task to create and combine new blocks with the existing ones.\nBlocks in the CNN usually contain parameters w1, . . . ,wL. These are discriminatively learned from example data such that the resulting function f realizes an useful mapping. A typical example is image classification; in this case the output of the CNN is a vector\ny = f(x) ∈ RC containing the confidence that x belong to any of C possible classes. Given training data (x(i),y(i)) (where y(i) is the indicator vector of the class of x(i)), the parameters are learned by solving\nargmin w1,...wn\n1\nn\nn∑\ni=1\nℓ ( f(x(i);w1, . . . ,wL),y (i) )\n(1)\nwhere ℓ is a suitable loss function (e.g. the hinge or log loss). The optimization problem (1) is usually non-convex and very large as complex CNN architectures need to be trained from hundred-thousands or even millions of examples. Therefore efficiency is a paramount. Optimization often uses a variant of stochastic gradient descent. The algorithm is, conceptually, very simple: at each iteration a training point is selected at random, the derivative of the loss term for that training sample is computed resulting in a gradient vector, and parameters are incrementally updated by moving towards the local minima in the direction of the gradient. The key operation here is to compute the derivative of the objective function, which is obtained by an application of the chain rule known as backpropagation. MatConvNet can evaluate the derivatives of all the computational blocks. It also contains several examples of training small and large models using these capabilities and a default solver, although it is easy to write customized solvers on top of the library.\nWhile CNNs are relatively efficient to compute, training requires iterating many times through vast data collections. Therefore the computation speed is very important in practice. Larger models, in particular, may require the use of GPU to be trained in a reasonable time. MatConvNet has integrated GPU support based on NVIDIA CUDA and MATLAB builtin CUDA capabilities."
    }, {
      "heading" : "1.1 MatConvNet on a glance",
      "text" : "MatConvNet has a simple design philosophy. Rather than wrapping CNNs around complex layers of software, it exposes simple functions to compute CNN building blocks, such as linear convolution and ReLU operators. These building blocks are easy to combine into a complete CNNs and can be used to implement sophisticated learning algorithms. While several realworld examples of small and large CNN architectures and training routines are provided, it is always possible to go back to the basics and build your own, using the efficiency of MATLAB in prototyping. Often no C coding is required at all to try a new architectures. As such, MatConvNet is an ideal playground for research in computer vision and CNNs.\nMatConvNet contains the following elements:\n• CNN computational blocks. A set of optimized routines computing fundamental building blocks of a CNN. For example, a convolution block is implemented by y=vl_nnconv(x,f,b) where x is an image, f a filter bank, and b a vector of biases (Section 2.1). The derivatives are computed as [dzdx,dzdf,dzdb] = vl_nnconv(x,f,b,dzdy) where dzdy is the derivative of the CNN output w.r.t y (Section 2.1). Section 2 describes all the blocks in detail.\n• CNN wrappers. MatConvNet provides a simple wrapper, suitably invoked by vl_simplenn, that implements a CNN with a linear topology (a chain of blocks). This is good enough\nto run most of current state-of-the-art models for image classification. You are invited to look at the implementation of this function, as it is a great starting point to understand how to implement more complex CNNs.\n• Example applications. MatConvNet provides several example of learning CNNs with stochastic gradient descent and CPU or GPU, on MNIST, CIFAR10, and ImageNet data.\n• Pre-trained models. MatConvNet provides several state-of-the-art pre-trained CNN models that can be used off-the-shelf, either to classify images or to produce image encodings in the spirit of Caffe or DeCAF."
    }, {
      "heading" : "1.2 The structure and evaluation of CNNs",
      "text" : "CNNs are obtained by connecting one or more computational blocks. Each block y = f(x,w) takes an image x and a set of parameters w as input and produces a new image y as output. An image is a real 4D array; the first two dimensions index spatial coordinates (image rows and columns respectively), the third dimension feature channels (there can be any number), and the last dimension image instances. A computational block f is therefore represented as follows:\nx f y\nw\nFormally, x is a 4D tensor stacking N 3D images\nx ∈ RH×W×D×N\nwhere H and W are the height and width of the images, D its depth, and N the number of images. In what follows, all operations are applied identically to each image in the stack x; hence for simplicity we will drop the last dimension in the discussion (equivalent to assuming N = 1), but the ability to operate on image batches is very important for efficiency.\nIn general, a CNN can be obtained by connecting blocks in a directed acyclic graph (DAG). In the simplest case, this graph reduces to a sequence of computational blocks (f1, f2, . . . , fL). Let x1,x2, . . . ,xL be the output of each layer in the network, and let x0 denote the network input. Each output xl depends on the previous output xl−1 through a function fl with parameter wl as xl = fl(xl−1;wl); schematically:\nx0 f1 f2 ... fL xL\nw1 w2 wL\nx2 x3 xL−1\nGiven an input x0, evaluating the network is a simple matter of evaluating all the intermediate stages in order to compute an overall function xL = f(x0;w1, . . . ,wL)."
    }, {
      "heading" : "1.3 CNN derivatives",
      "text" : "In training a CNN, we are often interested in taking the derivative of a loss ℓ : f(x,w) 7→ R with respect to the parameters. This effectively amounts to extending the network with a scalar block at the end:\nx0 f1 f2 ... fL ℓ\nw1 w2 wL\nz ∈ R x2 x3 xL−1 xL\nThe derivative of ℓ ◦ f with respect to the parameters can be computed but starting from the end of the chain (or DAG) and working backwards using the chain rule, a process also known as back-propagation. For example the derivative w.r.t. wl is:\ndz\nd(vecwl)⊤ =\ndz d(vecxL)⊤ d vecxL d(vecxL−1)⊤ . . . d vecxl+1 d(vecxl)⊤ d vecxl d(vecwl)⊤ . (2)\nNote that the derivatives are implicitly evaluated at the working point determined by the input x0 during the evaluation of the network in the forward pass. The vec symbol is the vectorization operator, which simply reshape its tensor argument to a column vector. This notation for the derivatives is taken from [5] and is used throughout this document.\nComputing (2) requires computing the derivative of each block xl = fl(xl−1,wl) with respect to its parameters wl and input xl−1. Let us know focus on computing the derivatives for one computational block. We can look at the network as follows:\nℓ ◦ fL(·,wL) ◦ fL−1(·,wL−1) · · · ◦ fl+1(·,wl+1) ︸ ︷︷ ︸\nz(·)\n◦fl(xl,wl) ◦ . . .\nwhere ◦ denotes the composition of function. For simplicity, lump together the factors from fl + 1 to the loss ℓ into a single scalar function z(·) and drop the subscript l from the first block. Hence, the problem is to compute the derivative of (z ◦ f)(x,w) ∈ R with respect to the data x and the parameters w. Graphically:\nx f z(·) z\nw\ny\nThe derivative of z ◦ f with respect to x and w are given by:\ndz\nd(vecx)⊤ =\ndz d(vecy)⊤ d vec f d(vecx)⊤ ,\ndz\nd(vecw)⊤ =\ndz d(vecy)⊤ d vec f d(vecw)⊤ ,\nWe note two facts. The first one is that, since z is a scalar function, the derivatives have a number of elements equal to the number of parameters. So in particular dz/d vecx⊤ can be reshaped into an array dz/dx with the same shape of x, and the same applies to the derivatives dz/dy and dz/dw. Beyond the notational convenience, this means that storage for the derivatives is not larger than the storage required for the model parameters and forward evaluation.\nThe second fact is that computing dz/dx and dz/dw require the derivative dz/dy. The latter can be obtained by applying this calculation recursively to the next block in the chain."
    }, {
      "heading" : "1.4 CNN modularity",
      "text" : "Sections 1.2 and 1.3 suggests a modular programming interface for the implementation of CNN modules. Abstractly, we need two functionalities:\n• Forward messages: Evaluation of the output y = f(x,w) given input data x and parameters w (forward message).\n• Backward messages: Evaluation of the CNN derivative dz/dx and dz/dw with respect to the block input data x and parameters w given the block input data x and paramters w as well as the CNN derivative dx/dy with respect to the block output data y."
    }, {
      "heading" : "2 Computational blocks",
      "text" : "This section describes the individual computational block supported by the MatConvNet. The interface of a CNN computational block follows Section 1.4. The block can be evaluated as a MATLAB function y = vl_nn<block>(x,w) that takes as input arrays x and w representing the input data and parameters of the block and returns an array y as output. x and y are 4D real arrays packing N maps or images, as discussed above, whereas \\bw may have an arbitrary shape.\nIn order to compute the block derivatives, the same function can take a third optional argument dzdy representing the derivative of the output of the network with respect to y and returns the corresponding derivatives [dzdx,dzdw] = vl_nn<block>(x,w,dzdy). dzdx, dzdy and dzdw are array with the same dimension of x, y and w respectively, as discussed in Section 1.3.\nA function syntax may differ slightly depending on the specifics of a block. For example, a function can take additional optional arguments, specified as a property-value list; it can take no parameters (e.g. a rectified linear unit), in which case w is omitted; it can take\nmultiple inputs and parameters, in which there may be more than one x, w, dzdx, dzdy or dzdw. See the MATLAB inline help of each function for details on the syntax.1\nThe rest of the section describes the blocks implemented in MatConvNet. The purpose is to describe the blocks analytically; refer to MATLAB inline help for further details on the API."
    }, {
      "heading" : "2.1 Convolution",
      "text" : "The convolutional block is implemented by the function vl_nnconv. y=vl_nnconv(x,f,b) computes the convolution of the input map x with a bank of K multi-dimensional filters f and biases b. Here\nx ∈ RH×W×D, f ∈ RH ′×W ′×D×K , y ∈ RH ′′×W ′′×K , W ′′ = W−W ′+1, H ′′ = H−H ′+1,\nFormally, the output is given by\nyi′′j′′k = bk +\nH′∑\ni′=1\nW ′∑\nj′=1\nD∑\nd=1\nfi′j′d × xi′′+i′,j′′+j′,d,k.\nThe call vl_nnconv(x,f,[]) does not use the biases. Note that the function works with arbitrarily sized inputs and filters (as opposed to, for example, square images).\nOutput size, padding, and sampling stride. The convolution operator can be adapted to account for image padding and subsampling. Suppose that the input image or map x has width W and that the filter f has width W ′ ≤ W . Then there are\nW ′′ = W −W ′ + 1\npossible translations of the filters in the horizontal direction such that the filter is entirely contained in the input x. Hence, by default the filtered signal y has width W ′′. However, vl_nnconv accepts a padding parameters [Pt, Pb, Pl, Pr] whose effect is to virtually pad with zeros the signal x in the top, bottom, left, and right spatial directions respectively. In this case, the output signal has width\nW ′′ = W + (Pl + Pr)−W ′ + 1.\nvl_nnconv also accepts a stride parameter (δw, δh) to subsample the output. In this case, if j is the column index of the output signal y, its maximum value is given by:\n(j − 1)δw +W ′ ≤ W + (Pl + Pr).\nHence the width of y is given by\nW ′′ = ⌊ W + Pl + Pr −W\n′\nδw ⌋ + 1\nsamples. Similar relations apply to the signal heights H,H ′ and H ′′.\n1In some cases it may be convenient to wrap these functions to obtain completely uniform and abstract interfaces to all block types. Writing such wrappers, if they are needed, is easy. The core functions, however, focus on providing a straightforward and obvious interface to each block.\nFully connected layers. In other libraries, a fully connected blocks or layers are blocks where each output dimension linearly depends on all the input dimensions. MatConvNet does not distinguishes between fully connected layers and convolutional blocks. Instead, the former is a special case of the latter obtained when the output map y has dimensions W ′′ = H ′′ = 1. Internally, vl_nnconv handle this case more efficiently if possible.\nFilter groups. For additional flexibility, vl_nnconv allows to group input feature channels and apply to them different filter groups. To to do so, specify as input a bank of K filters f ∈ RH\n′×W ′×D′×K such that D′ divides the number of input dimensions D. These are treated as g = D/D′ filter groups; the first group is applied to dimensions d = 1, . . . , D′ of the input x; the second group to dimensions d = D′ + 1, . . . , 2D′ and so on. Note that the ouptut is still an array y ∈ RH\n′′×W ′′×K . An application of grouping is implementing the Krizhevsky and Hinton network [6], which uses two such streams. Another application is sum pooling; in the latter case, one can specify D groups ofD′ = 1 dimensional filters identical filters of value 1 (however, this is considerably slower than calling the dedicated pooling function as given in Section 2.2).\nMatrix notation and derivations. It is often convenient to express the convolution operation in matrix form. To this end, let φ(x) the im2row operator, extracting all W ′ ×H ′ patches from the map x and storing them as rows of a (H ′′W ′′)×(H ′W ′D) matrix. Formally, this operator is given by:\n[φ(x)]pq = (i,j,d)=t(p,q) xijd\nwhere the index mapping (i, j, d) = t(p, q) is\ni = i′′ + i′ − 1, j = j′′ + j′ − 1, p = i′′ +H ′′(j′′ − 1), q = i′ +H ′(j′ − 1) +H ′W ′(d− 1).\nIt is also useful to define the “transposed” operator row2im:\n[φ∗(M)]ijd = ∑\n(p,q)∈t−1(i,j,d)\nMpq.\nNote that φ and φ∗ are linear operators. Both can be expressed by a matrixH ∈ R(H ′′W ′′H′W ′D)×(HWD) such that vec(φ(x)) = H vec(x), vec(φ∗(M)) = H⊤ vec(M).\nHence we obtain the following expression for the vectorized output (see [5]):\nvecy = vec (φ(x)F ) =\n{\n(I ⊗ φ(x)) vecF, or, equivalently,\n(F⊤ ⊗ I) vec φ(x),\nwhere F ∈ R(H ′W ′D)×K is the matrix obtained by reshaping the array f and I is an identity matrix of suitable dimensions. This allows obtaining the following formulas for the derivatives:\ndz\nd(vecF )⊤ =\ndz\nd(vecy)⊤ (I ⊗ φ(x)) = vec\n[\nφ(x)⊤ dz\ndY\n]⊤\nwhere Y ∈ R(H ′′W ′′)×K is the matrix obtained by reshaping the array y. Likewise:\ndz\nd(vecx)⊤ =\ndz\nd(vecy)⊤ (F⊤ ⊗ I)\nd vecφ(x) d(vecx)⊤ = vec\n[ dz\ndY F⊤\n]⊤\nH\nIn summary, after reshaping these terms we obtain the formulas:\nvecy = vec (φ(x)F ) , dz\ndF = φ(x)⊤\ndz\ndY ,\ndz\ndX = φ∗\n( dz\ndY F⊤\n)\nwhere X ∈ R(H ′W ′)×D is the matrix obtained by reshaping x. Notably, these expressions are used to implement the convolutional operator; while this may seem inefficient, it is instead a fast approach when the number of filters is large and it allows leveraging fast BLAS and GPU BLAS implementations."
    }, {
      "heading" : "2.2 Pooling",
      "text" : "vl_nnpool implements max and sum pooling. The max pooling operator computes the maximum response of each feature channel in a H ′ ×W ′ patch\nyi′′j′′d = max 1≤i′≤H′,1≤j′≤W ′ xi′′+i′,j′′+j′,d.\nresulting in an output of size y ∈ RH ′′×W ′′×D, similar to the convolution operator of Sectino 2.1. Sum-pooling computes the average of the values instead:\nyi′′j′′d = 1\nW ′H ′\n∑\n1≤i′≤H′,1≤j′≤W ′\nxi′′+i′,j′′+j′,d.\nPadding and stride. Similar to the convolution operator of Sect. 2.1, vl_nnpool supports padding the input; however, the effect is different from padding in the convolutional block as pooling regions straddling the image boundaries are cropped. For max pooling, this is equivalent to extending the input data with −∞; for sum pooling, this is similar to padding with zeros, but the normalization factor at the boundaries is smaller to account for the smaller integration area.\nMatrix notation. Since max pooling simply select for each output element an input element, the relation can be expressed in matrix form as vecy = S(x) vecx for a suitable selector matrix S(x) ∈ {0, 1}(H\n′′W ′′D)×(HWD). The derivatives can the be written as: dz\nd(vecx)⊤ = dz d(vecy)⊤ S(x), for all but a null set of points, where the operator is not differentiable (this usually does not pose problems in optimization by stochastic gradient). For max-pooling, similar relations exists with two differences: S does not depend on the input x and it is not binary, in order to account for the normalization factors. In summary, we have the expressions:\nvecy = S(x) vecx, dz\nd vecx = S(x)⊤\ndz\nd vecy . (3)"
    }, {
      "heading" : "2.3 ReLU",
      "text" : "vl_nnrelu computes the Rectified Linear Unit (ReLU):\nyijd = max{0, xijd}.\nMatrix notation. With matrix notation, we can express the ReLU as\nvecy = diag s vecx, dz\nd vecx = diag s\ndz\nd vecy\nwhere s = [vecx > 0] ∈ {0, 1}HWD is an indicator vector."
    }, {
      "heading" : "2.4 Normalization",
      "text" : "vl_nnnormalize implements a cross-channel normalization operator. Normalization applied independently at each spatial location and groups of channels to get:\nyijk = xijk\n κ + α ∑\nt∈G(k)\nx2ijt\n\n\n−β\n,\nwhere, for each output channel k, G(k) ⊂ {1, 2, . . . , D} is a corresponding subset of input channels. Note that input x and output y have the same dimensions. Note also that the operator is applied across feature channels in a convolutional manner at all spatial locations.\nImplementation details. The derivative is easily computed as:\ndz\ndxijd =\ndz\ndyijd L(i, j, d|x)−β − 2αβxijd\n∑\nk:d∈G(k)\ndz\ndyijk L(i, j, k|x)−β−1xijk\nwhere L(i, j, k|x) = κ+ α ∑\nt∈G(k)\nx2ijt."
    }, {
      "heading" : "2.5 Softmax",
      "text" : "vl_softmax computes the softmax operator:\nyijk = exijk\n∑D t=1 e\nxijt .\nNote that the operator is applied across feature channels and in a convolutional manner at all spatial locations.\nImplementation details. Care must be taken in evaluating the exponential in order to avoid underflow or overflow. The simplest way to do so is to divide from numerator and denominator by the maximum value:\nyijk = exijk−maxd xijd\n∑D t=1 e\nxijt−maxd xijd .\nThe derivative is given by:\ndz\ndxijd =\n∑\nk\ndz\ndyijk\n( exijdL(x)−1δ{k=d} − e xijdexijkL(x)−2 ) , L(x) =\nD∑\nt=1\nexijt .\nSimplifying:\ndz\ndxijd = yijd\n(\ndz\ndyijd −\nK∑\nk=1\ndz\ndyijk yijk.\n)\n.\nIn matrix for: dz\ndX = Y ⊙\n( dz\ndY −\n( dz\ndY ⊙ Y\n) 11⊤ )\nwhere X, Y ∈ RHW×D are the matrices obtained by reshaping the arrays x and y. Note that the numerical implementation of this expression is straightforward once the output Y has been computed with the caveats above."
    }, {
      "heading" : "2.6 Log-loss",
      "text" : "vl_logloss computes the logarithmic loss\ny = ℓ(x, c) = − ∑\nij\nlog xijc\nwhere c ∈ {1, 2, . . . , D} is the ground-truth class. Note that the operator is applied across input channels in a convolutional manner, summing the loss computed at each spatial location into a single scalar.\nImplementation details. The derivative is\ndz\ndxijd = −\ndz\ndy\n1\nxijc δ{d=c}."
    }, {
      "heading" : "2.7 Softmax log-loss",
      "text" : "vl_softmaxloss combines the softmax layer and the log-loss into one step for improved numerical stability. It computes\ny = − ∑\nij\n(\nxijc − log D∑\nd=1\nexijd\n)\nwhere c is the ground-truth class.\nImplementation details. The derivative is given by\ndz\ndxijd = −\ndz dy (δd=c − yijc)\nwhere yijc is the output of the softmax layer. In matrix form:\ndz\ndX = −\ndz\ndy\n( 1⊤ec − Y )\nwhere X, Y ∈ RHW×D are the matrices obtained by reshaping the arrays x and y and ec is the indicator vector of class c."
    }, {
      "heading" : "3 Network wrappers and examples",
      "text" : "It is easy enough to combine the computational blocks of Sect. 2 in any network DAG by writing a corresponding MATLAB script. Nevertheless, MatConvNet provides a simple wrapper for the common case of a linear chain. This is implemented by the vl_simplenn and vl_simplenn_move functions.\nvl_simplenn takes as input a structure net representing the CNN as well as input x and potentially output derivatives dzdy, depending on the mode of operation. Please refer to the inline help of the vl_simplenn function for details on the input and output formats. In fact, the implementation of vl_simplenn is a good example of how the basic neural net building block can be used together and can serve as a basis for more complex implementations."
    }, {
      "heading" : "3.1 Pre-trained models",
      "text" : "vl_simplenn is easy to use with pre-trained models (see the homepage to download some). For example, the following code downloads a model pre-trained on the ImageNet data and applies it to one of MATLAB stock images:\n% setup MatConvNet in MATLAB run matlab/vl_setupnn\n% download a pre−t ra ined CNN from the web urlwrite ( . . .\n' http ://www. v l f e a t . org /sandbox−matconvnet /models / imagenet−vgg−f . mat ' , . . . ' imagenet−vgg−f . mat ' ) ;\nnet = load ( ' imagenet−vgg−f . mat ' ) ;\n% obta in and preproces s an image im = imread ( ' peppers . png ' ) ; im_ = single (im ) ; % note : 255 range im_ = imresize(im_ , net . normalization . imageSize ( 1 : 2 ) ) ; im_ = im_ − net . normalization . averageImage ;\nNote that the image should be preprocessed before running the network. While preprocessing specifics depend on the model, the pre-trained model contain a net.normalization field that\ndescribes the type of preprocessing that is expected. Note in particular that this network takes images of a fixed size as input and requires removing the mean; also, image intensities are normalized in the range [0,255].\nThe next step is running the CNN. This will return a res structure with the output of the network layers:\n% run the CNN res = vl_simplenn(net , im_ ) ;\nThe output of the last layer can be used to classify the image. The class names are contained in the net structure for convenience:\n% show the c l a s s i f i c a t i o n r e s u l t scores = squeeze ( gather ( res ( end ) . x ) ) ; [ bestScore , best ] = max( scores ) ; f i g u r e (1 ) ; c l f ; imagesc (im ) ; t i t l e ( s p r i n t f ( '%s (%d ) , s co r e %.3 f ' , . . . net . classes . description{best} , best , bestScore ) ) ;\nNote that several extensions are possible. First, images can be cropped rather than rescaled. Second, multiple crops can be fed to the network and results averaged, usually for improved results. Third, the output of the network can be used as generic features for image encoding."
    }, {
      "heading" : "3.2 Learning models",
      "text" : "As MatConvNet can compute derivatives of the CNN using back-propagation, it is simple to implement learning algorithms with it. A basic implementation of stochastic gradient descent is therefore straightforward. Example code is provided in examples/cnn_train. This code is flexible enough to allow training on NMINST, CIFAR, ImageNet, and probably many other datasets. Corresponding examples are provided in the examples/ directory."
    }, {
      "heading" : "3.3 Running large scale experiments",
      "text" : "For large scale experiments, such as learning a network for ImageNet, a NVIDIA GPU (at least 6GB of memory) and adequate CPU and disk speeds are highly recommended. For example, to train on ImageNet, we suggest the following:\n• Download the ImageNet data http://www.image-net.org/challenges/LSVRC. Install it somewhere and link to it from data/imagenet12\n• Consider preprocessing the data to convert all images to have an height 256 pixels. This can be done with the supplied utils/preprocess-imagenet.sh script. In this manner, training will not have to resize the images every time. Do not forget to point the training code to the pre-processed data.\n• Consider copying the dataset in to a RAM disk (provided that you have enough memory!) for faster access. Do not forget to point the training code to this copy.\n• Compile MatConvNet with GPU support. See the homepage for instructions.\n• Compile also the vl_imreadjpeg function. Currently, reading JPEG images from disk is a bottleneck and this function can partially alleviate this problem (in the future it should remove the bottleneck almost entirely). See the homepage for instructions.\nOnce your setup is ready, you should be able to run examples/cnn_imagenet (edit the file and change any flag as needed to enable GPU support and image pre-fetching on multiple threads).\nIf all goes well, you should expect to be able to train with 200-300 images/sec."
    }, {
      "heading" : "4 About MatConvNet",
      "text" : "MatConvNet main features are:\n• Flexibility. Neural network layers are implemented in a straightforward manner, often directly in MATLAB code, so that they are easy to modify, extend, or integrate with new ones.\n• Power. The implementation can run the latest models such as Krizhevsky et al. [6], including the DeCAF and Caffe variants, and variants from the Oxford Visual Geometry Group. Pre-learned features for different tasks can be easily downloaded.\n• Efficiency. The implementation is quite efficient, supporting both CPU and GPU computation (in the latest versions of MALTAB).\n• Self contained. The implementation is fully self-contained, requiring only MATLAB and a compatible C/C++ compiler to work (GPU code requires the freely-available CUDA DevKit). Several fully-functional image classification examples are included.\nRelation to other CNN implementations. There are many other open-source CNN implementations. MatConvNet borrows its convolution algorithms from Caffe (and is in fact capable of running most of Caffe’s models). Caffe is a C++ framework using a custom CNN definition language based on Google Protocol Buffers. Both MatConvNet and Caffe are predated by Cuda-Convnet [6], a C++ -based project that allows defining a CNN architectures using configuration files. While Caffe and Cuda-Convnet can be somewhat faster than MatConvNet, the latter exposes individual CNN building blocks as MATLAB functions, as well as integrating with the native MATLAB GPU support, which makes it very convenient for fast prototyping. The DeepLearningToolbox [7] is a MATLAB toolbox implementing, among others, CNNs, but it does not seem to have been tested on large scale problems. While MatConvNet specialises on CNNs and computer vision applications, there are several general-purpose machine learning frameworks which include CNN support, but none of them interfaces natively with MATLAB. For example, the Torch7 toolbox [3] uses Lua and Theano [1] uses Python."
    }, {
      "heading" : "4.1 Acknowledgments",
      "text" : "The implementation of several CNN computations in this library are inspired by the Caffe library [4] (however, Caffe is not a dependency). Several of the example networks have been trained by Karen Simonyan as part of [2].\nWe kindly thank NVIDIA for suppling GPUs used in the creation of this software."
    } ],
    "references" : [ {
      "title" : "Theano: a CPU and GPU math expression compiler",
      "author" : [ "James Bergstra", "Olivier Breuleux", "Frédéric Bastien", "Pascal Lamblin", "Razvan Pascanu", "Guillaume Desjardins", "Joseph Turian", "David Warde-Farley", "Yoshua Bengio" ],
      "venue" : "In Proceedings of the Python for Scientific Computing Conference (SciPy),",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2010
    }, {
      "title" : "Return of the devil in the details: Delving deep into convolutional nets",
      "author" : [ "K. Chatfield", "K. Simonyan", "A. Vedaldi", "A. Zisserman" ],
      "venue" : "In Proc. BMVC,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2014
    }, {
      "title" : "Torch7: A matlab-like environment for machine learning",
      "author" : [ "Ronan Collobert", "Koray Kavukcuoglu", "Clément Farabet" ],
      "venue" : "In BigLearn,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1923
    }, {
      "title" : "Caffe: An open source convolutional architecture for fast feature embedding",
      "author" : [ "Yangqing Jia" ],
      "venue" : "http://caffe.berkeleyvision.org/,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2013
    }, {
      "title" : "Integrals and derivatives for correlated gaussian fuctions using matrix differential calculus",
      "author" : [ "D.B. Kinghorn" ],
      "venue" : "International Journal of Quantum Chemestry,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1996
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "A. Krizhevsky", "I. Sutskever", "G.E. Hinton" ],
      "venue" : "In Proc. NIPS,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2012
    }, {
      "title" : "Prediction as a candidate for learning deep hierarchical models of data",
      "author" : [ "R.B. Palm" ],
      "venue" : "Master’s thesis,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "This notation for the derivatives is taken from [5] and is used throughout this document.",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 5,
      "context" : "An application of grouping is implementing the Krizhevsky and Hinton network [6], which uses two such streams.",
      "startOffset" : 77,
      "endOffset" : 80
    }, {
      "referenceID" : 4,
      "context" : "Hence we obtain the following expression for the vectorized output (see [5]):",
      "startOffset" : 72,
      "endOffset" : 75
    }, {
      "referenceID" : 5,
      "context" : "[6], including the DeCAF and Caffe variants, and variants from the Oxford Visual Geometry Group.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "Both MatConvNet and Caffe are predated by Cuda-Convnet [6], a C++ -based project that allows defining a CNN architectures using configuration files.",
      "startOffset" : 55,
      "endOffset" : 58
    }, {
      "referenceID" : 6,
      "context" : "The DeepLearningToolbox [7] is a MATLAB toolbox implementing, among others, CNNs, but it does not seem to have been tested on large scale problems.",
      "startOffset" : 24,
      "endOffset" : 27
    }, {
      "referenceID" : 2,
      "context" : "For example, the Torch7 toolbox [3] uses Lua and Theano [1] uses Python.",
      "startOffset" : 32,
      "endOffset" : 35
    }, {
      "referenceID" : 0,
      "context" : "For example, the Torch7 toolbox [3] uses Lua and Theano [1] uses Python.",
      "startOffset" : 56,
      "endOffset" : 59
    } ],
    "year" : 2014,
    "abstractText" : "MatConvNet is an implementation of Convolutional Neural Networks (CNNs) for MATLAB. The toolbox is designed with an emphasis on simplicity and flexibility. It exposes the building blocks of CNNs as easy-to-use MATLAB functions, providing routines for computing linear convolutions with filter banks, feature pooling, and many more. In this manner, MatConvNet allows fast prototyping of new CNN architectures; at the same time, it supports efficient computation on CPU and GPU allowing to train complex models on large datasets such as ImageNet ILSVRC. This document provides an overview of CNNs and how they are implemented in MatConvNet and gives the technical details of each computational block in the toolbox.",
    "creator" : "LaTeX with hyperref package"
  }
}