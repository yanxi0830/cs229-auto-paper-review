{
  "name" : "1406.1856.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Drifting-Games Analysis for Online Learning and Applications to Boosting",
    "authors" : [ "Haipeng Luo", "Robert E. Schapire" ],
    "emails" : [ "haipengl@cs.princeton.edu", "schapire@cs.princeton.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 6.\n18 56\nv2 [\ncs .L\nG ]\n3 0"
    }, {
      "heading" : "1 Introduction",
      "text" : "In this paper, we study online learning problems within a drifting-games framework, with the aim of developing a general methodology for designing learning algorithms based on a minimax analysis.\nTo solve an online learning problem, it is natural to consider game-theoretically optimal algorithms which find the best solution even in worst-case scenarios. This is possible for some special cases ([7, 1, 3, 21]) but difficult in general. On the other hand, many other efficient algorithms with optimal regret rate (but not exactly minimax optimal) have been proposed for different learning settings (such as the exponential weights algorithm [14, 15], and follow the perturbed leader [18]). However, it is not always clear how to come up with these algorithms. Recent work by Rakhlin et al. [26] built a bridge between these two classes of methods by showing that many existing algorithms can indeed be derived from a minimax analysis followed by a series of relaxations.\nIn this paper, we provide a parallel way to design learning algorithms by first converting online learning problems into variants of drifting games, and then applying a minimax analysis and relaxations. Drifting games [28] (reviewed in Section 2) generalize Freund’s “majority-vote game” [13] and subsume some well-studied boosting and online learning settings. A nearly minimax optimal algorithm is proposed in [28]. It turns out the connections between drifting games and online learning go far beyond what has been discussed previously. To show that, we consider variants of drifting games that capture different popular online learning problems. We then generalize the minimax analysis in [28] based on one key idea: relax a 0-1 loss function by a convex surrogate. Although\n∗R. Schapire is currently at Microsoft Research in New York City.\nthis idea has been applied widely elsewhere in machine learning, we use it here in a new way to obtain a very general methodology for designing and analyzing online learning algorithms. Using this general idea, we not only recover existing algorithms, but also design new ones with special useful properties. A somewhat surprising result is that our new algorithms are totally parameterfree, which is usually not the case for algorithms derived from a minimax analysis. Moreover, a generalized notion of regret (ǫ-regret, defined in Section 3) that measures how good the algorithm is compared to all but the top ǫ fraction of candidates arises naturally in our drifting-games framework. Below we summarize our results for a range of learning settings.\nHedge Settings: (Section 3) The Hedge problem [14] investigates how to cleverly bet across a set of actions. We show an algorithmic equivalence between this problem and a simple drifting game (DGv1). We then show how to relax the original minimax analysis step by step to reach a general recipe for designing Hedge algorithms (Algorithm 3). Three examples of appropriate convex surrogates of the 0-1 loss function are then discussed, leading to the well-known exponential weights algorithm and two other new ones, one of which (NormalHedge.DT in Section 3.3) bears some similarities with the NormalHedge algorithm [10] and enjoys a similar ǫ-regret bound simultaneously for all ǫ and horizons. However, our regret bounds do not depend on the number of actions, and thus can be applied even when there are infinitely many actions. Our analysis is also arguably simpler and more intuitive than the one in [10] and easy to be generalized to more general settings. Moreover, our algorithm is more computationally efficient since it does not require a numerical searching step as in NormalHedge. Finally, we also derive high probability bounds for the randomized Hedge setting as a simple side product of our framework without using any concentration results.\nMulti-armed Bandit Problems: (Section 4) The multi-armed bandit problem [6] is a classic example for learning with incomplete information where the learner can only obtain feedback for the actions taken. To capture this problem, we study a quite different drifting game (DGv2) where randomness and variance constraints are taken into account. Again the minimax analysis is generalized and the EXP3 algorithm [6] is recovered. Our results could be seen as a preliminary step to answer the open question [2] on exact minimax optimal algorithms for the multi-armed bandit problem.\nOnline Convex Optimization: (Section 4) Based the theory of convex optimization, online convex optimization [31] has been the foundation of modern online learning theory. The corresponding drifting game formulation is a continuous space variant (DGv3). Fortunately, it turns out that all results from the Hedge setting are ready to be used here, recovering the continuous EXP algorithm [12, 17, 24] and also generalizing our new algorithms to this general setting. Besides the usual regret bounds, we also generalize the ǫ-regret, which, as far as we know, is the first time it has been explicitly studied. Again, we emphasize that our new algorithms are adaptive in ǫ and the horizon.\nBoosting: (Section 4) Realizing that every Hedge algorithm can be converted into a boosting algorithm ([29]), we propose a new boosting algorithm (NH-Boost.DT) by converting NormalHedge.DT. The adaptivity of NormalHedge.DT is then translated into training error and margin distribution bounds that previous analysis in [29] using nonadaptive algorithms does not show. Moreover, our new boosting algorithm ignores a great many examples on each round, which is an appealing property useful to speeding up the weak learning algorithm. This is confirmed by our experiments.\nRelated work: Our analysis makes use of potential functions. Similar concepts have widely appeared in the literature [8, 5], but unlike our work, they are not related to any minimax analysis and might be hard to interpret. The existence of parameter free Hedge algorithms for unknown number of actions was shown in [11], but no concrete algorithms were given there. Boosting algorithms that ignore some examples on each round were studied in [16], where a heuristic was used to ignore examples with small weights and no theoretical guarantee is provided."
    }, {
      "heading" : "2 Reviewing Drifting Games",
      "text" : "We consider a simplified version of drifting games similar to the one described in [29, chap. 13] (also called chip games). This game proceeds through T rounds, and is played between a player and an adversary who controls N chips on the real line. The positions of these chips at the end of round t are denoted by st ∈ RN , with each coordinate st,i corresponding to the position of chip i. Initially, all chips are at position 0 so that s0 = 0. On every round t = 1, . . . , T : the player first chooses a distribution pt over the chips, then the adversary decides the movements of the chips zt so that the\nnew positions are updated as st = st−1 + zt. Here, each zt,i has to be picked from a prespecified set B ⊂ R, and more importantly, satisfy the constraint pt · zt ≥ β ≥ 0 for some fixed constant β. At the end of the game, each chip is associated with a nonnegative loss defined by L(sT,i) for some nonincreasing function L mapping from the final position of the chip to R+. The goal of the player is to minimize the chips’ average loss 1N ∑N i=1 L(sT,i) after T rounds. So intuitively, the player aims to “push” the chips to the right by assigning appropriate weights on them so that the adversary has to move them to the right by β in a weighted average sense on each round. This game captures many learning problems. For instance, binary classification via boosting can be translated into a drifting game by treating each training example as a chip (see [28] for details).\nWe regard a player’s strategy D as a function mapping from the history of the adversary’s decisions to a distribution that the player is going to play with, that is, pt = D(z1:t−1) where z1:t−1 stands for z1, . . . , zt−1. The player’s worst case loss using this algorithm is then denoted by LT (D). The minimax optimal loss of the game is computed by the following expression: minD LT (D) = minp1∈∆N maxz1∈Zp1 · · ·minpT∈∆N maxzT∈ZpT 1 N ∑N i=1 L( ∑T t=1 zt,i), where ∆N is the N dimensional simplex and Zp = BN ∩ {z : p · z ≥ β} is assumed to be compact. A strategy D∗ that realizes the minimum in minD LT (D) is called a minimax optimal strategy. A nearly optimal strategy and its analysis is originally given in [28], and a derivation by directly tackling the above minimax expression can be found in [29, chap. 13]. Specifically, a sequence of potential functions of a chip’s position is defined recursively as follows:\nΦT (s) = L(s), Φt−1(s) = min w∈R+ max z∈B\n(Φt(s+ z) + w(z − β)). (1)\nLet wt,i be the weight that realizes the minimum in the definition of Φt−1(st−1,i), that is, wt,i ∈ argminw maxz(Φt(st−1,i + z) + w(z − β)). Then the player’s strategy is to set pt,i ∝ wt,i. The key property of this strategy is that it assures that the sum of the potentials over all the chips never increases, connecting the player’s final loss with the potential at time 0 as follows:\n1\nN\nN ∑\ni=1\nL(sT,i) ≤ 1\nN\nN ∑\ni=1\nΦT (sT,i) ≤ 1\nN\nN ∑\ni=1\nΦT−1(sT−1,i) ≤ · · · ≤ 1\nN\nN ∑\ni=1\nΦ0(s0,i) = Φ0(0).\n(2) It has been shown in [28] that this upper bound on the loss is optimal in a very strong sense.\nMoreover, in some cases the potential functions have nice closed forms and thus the algorithm can be efficiently implemented. For example, in the boosting setting, B is simply {−1,+1}, and one can verifyΦt(s) = 1+β 2 Φt+1(s+1)+ 1−β 2 Φt+1(s−1) and wt,i = 12 (Φt(st−1,i − 1)− Φt(st−1,i + 1)). With the loss function L(s) being 1{s ≤ 0}, these can be further simplified and eventually give exactly the boost-by-majority algorithm [13]."
    }, {
      "heading" : "3 Online Learning as a Drifting Game",
      "text" : "The connection between drifting games and some specific settings of online learning has been noticed before ([28, 23]). We aim to find deeper connections or even an equivalence between variants of drifting games and more general settings of online learning, and provide insights on designing learning algorithms through a minimax analysis. We start with a simple yet classic Hedge setting."
    }, {
      "heading" : "3.1 Algorithmic Equivalence",
      "text" : "In the Hedge setting [14], a player tries to earn as much as possible (or lose as little as possible) by cleverly spreading a fixed amount of money to bet on a set of actions on each day. Formally, the game proceeds for T rounds, and on each round t = 1, . . . , T : the player chooses a distribution pt over N actions, then the adversary decides the actions’ losses ℓt (i.e. action i incurs loss ℓt,i ∈ [0, 1]) which are revealed to the player. The player suffers a weighted average loss pt · ℓt at the end of this round. The goal of the player is to minimize his “regret”, which is usually defined as the difference between his total loss and the loss of the best action. Here, we consider an even more general notion of regret studied in [20, 19, 10, 11], which we call ǫ-regret. Suppose the actions are ordered according to their total losses after T rounds (i.e.\n∑T t=1 ℓt,i) from smallest to largest, and let iǫ be the index\nInput: A Hedge Algorithm H for t = 1 to T do\nQuery H: pt = H(ℓ1:t−1). Set: DR(z1:t−1) = pt. Receive movements zt from the adversary. Set: ℓt,i = zt,i −minj zt,j, ∀i.\nAlgorithm 1: Conversion of a Hedge Algorithm H to a DGv1 Algorithm DR\nInput: A DGv1 Algorithm DR for t = 1 to T do\nQuery DR: pt = DR(z1:t−1). Set: H(ℓ1:t−1) = pt. Receive losses ℓt from the adversary. Set: zt,i = ℓt,i − pt · ℓt, ∀i.\nAlgorithm 2: Conversion of a DGv1 Algorithm DR to a Hedge Algorithm H\nof the action that is the ⌈Nǫ⌉-th element in the sorted list (0 < ǫ ≤ 1). Now, ǫ-regret is defined as RǫT (p1:T , ℓ1:T ) = ∑T t=1 pt · ℓt − ∑T t=1 ℓt,iǫ . In other words, ǫ-regret measures the difference between the player’s loss and the loss of the ⌈Nǫ⌉-th best action (recovering the usual regret with ǫ ≤ 1/N ), and sublinear ǫ-regret implies that the player’s loss is almost as good as all but the top ǫ fraction of actions. Similarly, RǫT (H) denotes the worst case ǫ-regret for a specific algorithm H. For convenience, when ǫ ≤ 0 or ǫ > 1, we define ǫ-regret to be ∞ or −∞ respectively. Next we discuss how Hedge is highly related to drifting games. Consider a variant of drifting games where B = [−1, 1], β = 0 and L(s) = 1{s ≤ −R} for some constant R. Additionally, we impose an extra restriction on the adversary: |zt,i − zt,j | ≤ 1 for all i and j. In other words, the difference between any two chips’ movements is at most 1. We denote this specific variant of drifting games by DGv1 (summarized in Appendix A) and a corresponding algorithm by DR to emphasize the dependence on R. The reductions in Algorithm 1 and 2 and Theorem 1 show that DGv1 and the Hedge problem are algorithmically equivalent (note that both conversions are valid). The proof is straightforward and deferred to Appendix B. By Theorem 1, it is clear that the minimax optimal algorithm for one setting is also minimax optimal for the other under these conversions.\nTheorem 1. DGv1 and the Hedge problem are algorithmically equivalent in the following sense: (1) Algorithm 1 produces a DGv1 algorithm DR satisfying LT (DR) ≤ i/N where i ∈ {0, . . . , N} is such that R(i+1)/NT (H) < R ≤ R i/N T (H).\n(2) Algorithm 2 produces a Hedge algorithm H with RǫT (H) < R for any R such that LT (DR) < ǫ."
    }, {
      "heading" : "3.2 Relaxations",
      "text" : "From now on we only focus on the direction of converting a drifting game algorithm into a Hedge algorithm. In order to derive a minimax Hedge algorithm, Theorem 1 tells us it suffices to derive minimax DGv1 algorithms. Exact minimax analysis is usually difficult, and appropriate relaxations seem to be necessary. To make use of the existing analysis for standard drifting games, the first obvious relaxation is to drop the additional restriction in DGv1, that is, |zt,i − zt,j| ≤ 1 for all i and j. Doing this will lead to the exact setting discussed in [23] where a near optimal strategy is proposed using the recipe in Eq. (1). It turns out that this relaxation is reasonable and does not give too much more power to the adversary. To see this, first recall that results from [23], written in our\nnotation, state that minDR LT (DR) ≤ 12T ∑\nT−R 2 j=0 ( T+1 j ) , which, by Hoeffding’s inequality, is upper\nbounded by 2 exp ( − (R+1) 2\n2(T+1)\n)\n. Second, statement (2) in Theorem 1 clearly remains valid if the input\nof Algorithm 2 is a drifting game algorithm for this relaxed version of DGv1. Therefore, by setting ǫ > 2 exp ( − (R+1) 2\n2(T+1)\n) and solving for R, we have RǫT (H) ≤ O ( √ T ln(1ǫ ) ) , which is the known\noptimal regret rate for the Hedge problem, showing that we lose little due to this relaxation.\nHowever, the algorithm proposed in [23] is not computationally efficient since the potential functions Φt(s) do not have closed forms. To get around this, we would want the minimax expression in Eq. (1) to be easily solved, just like the case when B = {−1, 1}. It turns out that convexity would allow us to treat B = [−1, 1] almost as B = {−1, 1}. Specifically, if each Φt(s) is a convex function of s, then due to the fact that the maximum of a convex function is always realized at the boundary of a compact region, we have\nmin w∈R+ max z∈[−1,1] (Φt(s+ z) + wz) = min w∈R+ max z∈{−1,1}\n(Φt(s+ z) + wz) = Φt(s− 1) + Φt(s+ 1)\n2 ,\n(3)\nInput: A convex, nonincreasing, nonnegative function ΦT (s). for t = T down to 1 do\nFind a convex function Φt−1(s) s.t. ∀s, Φt(s− 1) + Φt(s+ 1) ≤ 2Φt−1(s). Set: s0 = 0. for t = 1 to T do\nSet: H(ℓ1:t−1) = pt s.t. pt,i ∝ Φt(st−1,i − 1)− Φt(st−1,i + 1). Receive losses ℓt and set st,i = st−1,i + ℓt,i − pt · ℓt, ∀i.\nAlgorithm 3: A General Hedge Algorithm H\nwith w = (Φt(s − 1) − Φt(s + 1))/2 realizing the minimum. Since the 0-1 loss function L(s) is not convex, this motivates us to find a convex surrogate of L(s). Fortunately, relaxing the equality constraints in Eq. (1) does not affect the key property of Eq. (2) as we will show in the proof of Theorem 2. “Compiling out” the input of Algorithm 2, we thus have our general recipe (Algorithm 3) for designing Hedge algorithms with the following regret guarantee.\nTheorem 2. For Algorithm 3, if R and ǫ are such that Φ0(0) < ǫ and ΦT (s) ≥ 1{s ≤ −R} for all s ∈ R, then RǫT (H) < R.\nProof. It suffices to show that Eq. (2) holds so that the theorem follows by a direct application of statement (2) of Theorem 1. Let wt,i = (Φt(st−1,i − 1) − Φt(st−1,i + 1))/2. Then ∑\niΦt(st,i) ≤ ∑ i (Φt(st−1,i + zt,i) + wt,izt,i) since pt,i ∝ wt,i andpt·zt ≥ 0. On the other hand, by Eq. (3), we have Φt(st−1,i + zt,i) +wt,izt,i ≤ minw∈R+ maxz∈[−1,1] (Φt(st−1,i + z) + wz) = 1 2 (Φt(st−1,i − 1) + Φt(st−1,i + 1)), which is at most Φt−1(st−1,i) by Algorithm 3. This shows∑\niΦt(st,i) ≤ ∑ iΦt−1(st−1,i) and Eq. (2) follows.\nTheorem 2 tells us that if solving Φ0(0) < ǫ for R gives R > R for some value R, then the regret of Algorithm 3 is less than any value that is greater than R, meaning the regret is at most R."
    }, {
      "heading" : "3.3 Designing Potentials and Algorithms",
      "text" : "Now we are ready to recover existing algorithms and develop new ones by choosing an appropriate potential ΦT (s) as Algorithm 3 suggests. We will discuss three different algorithms below, and summarize these examples in Table 1 (see Appendix C).\nExponential Weights (EXP) Algorithm. Exponential loss is an obvious choice for ΦT (s) as it has been widely used as the convex surrogate of the 0-1 loss function in the literature. It turns out that this will lead to the well-known exponential weights algorithm [14, 15]. Specifically, we pick ΦT (s) to be exp (−η(s+R)) which exactly upper bounds 1{s ≤ −R}. To compute Φt(s) for t ≤ T , we simply let Φt(s − 1) + Φt(s + 1) ≤ 2Φt−1(s) hold with equality. Indeed, direct computations show that all Φt(s) share a similar form: Φt(s) = ( eη+e−η\n2\n)T−t · exp (−η(s+R)) .\nTherefore, according to Algorithm 3, the player’s strategy is to set\npt,i ∝ Φt(st−1,i − 1)− Φt(st−1,i + 1) ∝ exp (−ηst−1,i) , which is exactly the same as EXP (note that R becomes irrelevant after normalization). To derive re-\ngret bounds, it suffices to require Φ0(0) < ǫ, which is equivalent to R > 1η\n(\nln(1ǫ ) + T ln eη+e−η 2\n)\n.\nBy Theorem 2 and Hoeffding’s lemma (see [9, Lemma A.1]), we thus know RǫT (H) ≤ 1η ln ( 1 ǫ ) +\nTη 2 =\n√\n2T ln ( 1 ǫ )\nwhere the last step is by optimally tuning η to be √\n2(ln 1ǫ )/T . Note that this algorithm is not adaptive in the sense that it requires knowledge of T and ǫ to set the parameter η.\nWe have thus recovered the well-known EXP algorithm and given a new analysis using the driftinggames framework. More importantly, as in [26], this derivation may shed light on why this algorithm works and where it comes from, namely, a minimax analysis followed by a series of relaxations, starting from a reasonable surrogate of the 0-1 loss function.\n2-norm Algorithm. We next move on to another simple convex surrogate: ΦT (s) = a[s]2− ≥ 1{s ≤ −1/√a}, where a is some positive constant and [s]− = min{0, s} represents a truncating operation. The following lemma shows that Φt(s) can also be simply described.\nLemma 1. If a > 0, then Φt(s) = a ( [s]2− + T − t ) satisfies Φt(s− 1) + Φt(s+ 1) ≤ 2Φt−1(s).\nThus, Algorithm 3 can again be applied. The resulting algorithm is extremely concise:\npt,i ∝ Φt(st−1,i − 1)− Φt(st−1,i + 1) ∝ [st−1,i − 1]2− − [st−1,i + 1]2−. We call this the “2-norm” algorithm since it resembles the p-norm algorithm in the literature when p = 2 (see [9]). The difference is that the p-norm algorithm sets the weights proportional to the derivative of potentials, instead of the difference of them as we are doing here. A somewhat surprising property of this algorithm is that it is totally adaptive and parameter-free (since a disappears under normalization), a property that we usually do not expect to obtain from a minimax analysis. Direct application of Theorem 2 (Φ0(0) = aT < ǫ ⇔ 1/ √ a > √\nT/ǫ) shows that its regret achieves the optimal dependence on the horizon T .\nCorollary 1. Algorithm 3 with potential Φt(s) defined in Lemma 1 produces a Hedge algorithm H such that RǫT (H) ≤ √ T/ǫ simultaneously for all T and ǫ.\nNormalHedge.DT. The regret for the 2-norm algorithm does not have the optimal dependence on ǫ. An obvious follow-up question would be whether it is possible to derive an adaptive algorithm that achieves the optimal rate O( √\nT ln(1/ǫ)) simultaneously for all T and ǫ using our framework. An even deeper question is: instead of choosing convex surrogates in a seemingly arbitrary way, is there a more natural way to find the right choice of ΦT (s)?\nTo answer these questions, we recall that the reason why the 2-norm algorithm can get rid of the dependence on ǫ is that ǫ appears merely in the multiplicative constant a that does not play a role after normalization. This motivates us to let ΦT (s) in the form of ǫF (s) for some F (s). On the other hand, from Theorem 2, we also want ǫF (s) to upper bound the 0-1 loss function 1{s ≤ − √\ndT ln(1/ǫ)} for some constant d. Taken together, this is telling us that the right choice of F (s) should be of the formΘ ( exp(s2/T ) )\n1. Of course we still need to refine it to satisfy the monotonicity and other properties. We define ΦT (s) formally and more generally as:\nΦT (s) = a ( exp ( [s]2 −\ndT\n) − 1 ) ≥ 1 { s ≤ − √ dT ln (\n1 a + 1\n)\n}\n,\nwhere a and d are some positive constants. This time it is more involved to figure out what other Φt(s) should be. The following lemma addresses this issue (proof deferred to Appendix C).\nLemma 2. If bt = 1− 12 ∑T τ=t+1 ( exp ( 4 dτ ) − 1 ) , a > 0, d ≥ 3 and Φt(s) = a ( exp ( [s]2 − dt ) − bt ) (define Φ0(s) ≡ a(1 − b0)), then we have Φt(s − 1) + Φt(s + 1) ≤ 2Φt−1(s) for all s ∈ R and t = 2, . . . , T . Moreover, Eq. (2) still holds.\nNote that even if Φ1(s− 1) + Φ1(s+ 1) ≤ 2Φ0(s) is not valid in general, Lemma 2 states that Eq. (2) still holds. Thus Algorithm 3 can indeed still be applied, leading to our new algorithm:\npt,i ∝ Φt(st−1,i − 1)− Φt(st−1,i + 1) ∝ exp ( [st−1,i−1]2− dt ) − exp ( [st−1,i+1] 2 − dt ) .\nHere, d seems to be an extra parameter, but in fact, simply setting d = 3 is good enough:\nCorollary 2. Algorithm 3 with potential Φt(s) defined in Lemma 2 and d = 3 produces a Hedge algorithm H such that the following holds simultaneously for all T and ǫ:\nRǫT (H) ≤ √ 3T ln ( 1 2ǫ ( e4/3 − 1 ) (lnT + 1) + 1 ) = O ( √ T ln (1/ǫ) + T ln lnT ) .\nWe have thus proposed a parameter-free adaptive algorithm with optimal regret rate (ignoring the ln lnT term) using our drifting-games framework. In fact, our algorithm bears a striking similarity to NormalHedge [10], the first algorithm that has this kind of adaptivity. We thus name our algorithm NormalHedge.DT2. We include NormalHedge in Table 1 for comparison. One can see that the main differences are: 1) On each round NormalHedge performs a numerical search to find out the right parameter used in the exponents; 2) NormalHedge uses the derivative of potentials as weights.\n1Similar potential was also proposed in recent work [22, 25] for a different setting. 2“DT” stands for discrete time.\nCompared to NormalHedge, the regret bound for NormalHedge.DT has no explicit dependence on N , but has a slightly worse dependence on T (indeed ln lnT is almost negligible). We emphasize other advantages of our algorithm over NormalHedge: 1) NormalHedge.DT is more computationally efficient especially when N is very large, since it does not need a numerical search for each round; 2) our analysis is arguably simpler and more intuitive than the one in [10]; 3) as we will discuss in Section 4, NormalHedge.DT can be easily extended to deal with the more general online convex optimization problem where the number of actions is infinitely large, while it is not clear how to do that for NormalHedge by generalizing the analysis in [10]. Indeed, the extra dependence on the number of actionsN for the regret of NormalHedge makes this generalization even seem impossible. Finally, we will later see that NormalHedge.DT outperforms NormalHedge in experiments. Despite the differences, it is worth noting that both algorithms assign zero weight to some actions on each round, an appealing property when N is huge. We will discuss more on this in Section 4."
    }, {
      "heading" : "3.4 High Probability Bounds",
      "text" : "We now consider a common variant of Hedge: on each round, instead of choosing a distribution pt, the player has to randomly pick a single action it, while the adversary decides the losses ℓt at the same time (without seeing it). For now we only focus on the player’s regret to the best action: RT (i1:T , ℓ1:T ) = ∑T t=1 ℓt,it −mini ∑T t=1 ℓt,i. Notice that the regret is now a random variable, and we are interested in a bound that holds with high probability. Using Azuma’s inequality, standard analysis (see for instance [9, Lemma 4.1]) shows that the player can simply draw it according to pt = H(ℓ1:t−1), the output of a standard Hedge algorithm, and suffers regret at most RT (H) + √\nT ln(1/δ) with probability 1 − δ. Below we recover similar results as a simple side product of our drifting-games analysis without resorting to concentration results, such as Azuma’s inequality.\nFor this, we only need to modify Algorithm 3 by setting zt,i = ℓt,i − ℓt,it . The restriction pt · zt ≥ 0 is then relaxed to hold in expectation. Moreover, it is clear that Eq. (2) also still holds in expectation. On the other hand, by definition and the union bound, one can show that ∑\ni E[L(sT,i)] = ∑ i Pr [sT,i ≤ −R] ≥ Pr [RT (i1:T , ℓ1:T ) ≥ R]. So setting Φ0(0) = δ shows that the regret is smaller than R with probability 1− δ. Therefore, for example, if EXP is used, then the regret would be at most √\n2T ln(N/δ) with probability 1−δ, giving basically the same bound as the standard analysis. One draw back is that EXP would need δ as a parameter. However, this can again be addressed by NormalHedge.DT for the exact same reason that NormalHedge.DT is independent of ǫ. We have thus derived high probability bounds without using any concentration inequalities."
    }, {
      "heading" : "4 Generalizations and Applications",
      "text" : "Multi-armed Bandit (MAB) Problem: The only difference between Hedge (randomized version) and the non-stochastic MAB problem [6] is that on each round, after picking it, the player only sees the loss for this single action ℓt,it instead of the whole vector ℓt. The goal is still to compete with the best action. A common technique used in the bandit setting is to build an unbiased estimator ℓ̂t for the losses, which in this case could be ℓ̂t,i = 1{i = it}·ℓt,it/pt,it . Then algorithms such as EXP can be used by replacing ℓt with ℓ̂t, leading to the EXP3 algorithm [6] with regret O( √ TN lnN).\nOne might expect that Algorithm 3 would also work well by replacing ℓt with ℓ̂t. However, doing so breaks an important property of the movements zt,i: boundedness. Indeed, Eq. (3) no longer makes sense if z could be infinitely large, even if in expectation it is still in [−1, 1] (note that zt,i is now a random variable). It turns out that we can address this issue by imposing a variance constraint on zt,i. Formally, we consider a variant of drifting games where on each round, the adversary picks a random movement zt,i for each chip such that: zt,i ≥ −1,Et[zt,i] ≤ 1,Et[z2t,i] ≤ 1/pt,i and Et[pt · zt] ≥ 0. We call this variant DGv2 and summarize it in Appendix A. The standard minimax analysis and the derivation of potential functions need to be modified in a certain way for DGv2, as stated in Theorem 4 (Appendix D). Using the analysis for DGv2, we propose a general recipe for designing MAB algorithms in a similar way as for Hedge and also recover EXP3 (see Algorithm 4 and Theorem 5 in Appendix D). Unfortunately so far we do not know other appropriate potentials due to some technical difficulties. We conjecture, however, that there is a potential function that could recover the poly-INF algorithm [4, 5] or give its variants that achieve the optimal regret O( √ TN).\nOnline Convex Optimization: We next consider a general online convex optimization setting [31]. Let S ⊂ Rd be a compact convex set, and F be a set of convex functions with range [0, 1] on S. On each round t, the learner chooses a point xt ∈ S, and the adversary chooses a loss function ft ∈ F (knowing xt). The learner then suffers loss ft(xt). The regret after T rounds is RT (x1:T , f1:T ) = ∑T\nt=1 ft(xt) − minx∈S ∑T\nt=1 ft(x). There are two general approaches to OCO: one builds on convex optimization theory [30], and the other generalizes EXP to a continuous space [12, 24]. We will see how the drifting-games framework can recover the latter method and also leads to new ones.\nTo do so, we introduce a continuous variant of drifting games (DGv3, see Appendix A). There are now infinitely many chips, one for each point in S. On round t, the player needs to choose a distribution over the chips, that is, a probability density function pt(x) on S. Then the adversary decides the movements for each chip, that is, a function zt(x) with range [−1, 1] on S (not necessarily convex or continuous), subject to a constraint Ex∼pt [zt(x)] ≥ 0. At the end, each point x is associated with a loss L(x) = 1{∑t zt(x) ≤ −R}, and the player aims to minimize the total loss ∫ x∈S L(x)dx.\nOCO can be converted into DGv3 by setting zt(x) = ft(x)−ft(xt) and predictingxt = Ex∼pt [x] ∈ S. The constraint Ex∼pt [zt(x)] ≥ 0 holds by the convexity of ft. Moreover, it turns out that the minimax analysis and potentials for DGv1 can readily be used here, and the notion of ǫ-regret, now generalized to the OCO setting, measures the difference of the player’s loss and the loss of a best fixed point in a subset of S that excludes the top ǫ fraction of points. With different potentials, we obtain versions of each of the three algorithms of Section 3 generalized to this setting, with the same ǫ-regret bounds as before. Again, two of these methods are adaptive and parameter-free. To derive bounds for the usual regret, at first glance it seems that we have to set ǫ to be close to zero, leading to a meaningless bound. Nevertheless, this is addressed by Theorem 6 using similar techniques in [17], giving the usual O( √ dT lnT ) regret bound. All details can be found in Appendix E.\nApplications to Boosting: There is a deep and well-known connection between Hedge and boosting [14, 29]. In principle, every Hedge algorithm can be converted into a boosting algorithm; for instance, this is how AdaBoost was derived from EXP. In the same way, NormalHedge.DT can be converted into a new boosting algorithm that we call NH-Boost.DT. See Appendix F for details and further background on boosting. The main idea is to treat each training example as an “action”, and to rely on the Hedge algorithm to compute distributions over these examples which are used to train the weak hypotheses. Typically, it is assumed that each of these has “edge” γ, meaning its accuracy on the training distribution is at least 1/2 + γ. The final hypothesis is a simple majority vote of the weak hypotheses. To understand the prediction accuracy of a boosting algorithm, we often study the training error rate and also the distribution of margins, a well-established measure of confidence (see Appendix F for formal definitions). Thanks to the adaptivity of NormalHedge.DT, we can derive bounds on both the training error and the distribution of margins after any number of rounds:\nTheorem 3. After T rounds, the training error of NH-Boost.DT is of order Õ(exp(− 13Tγ2)), and the fraction of training examples with margin at most θ(≤ 2γ) is of order Õ(exp(− 13T (θ− 2γ)2)).\nThus, the training error decreases at roughly the same rate as AdaBoost. In addition, this theorem implies that the fraction of examples with margin smaller than 2γ eventually goes to zero as T gets large, which means NH-Boost.DT converges to the optimal margin 2γ; this is known not to be true for AdaBoost (see [29]). Also, like AdaBoost, NH-Boost.DT is an adaptive boosting algorithm that does not require γ or T as a parameter. However, unlike AdaBoost, NH-Boost.DT has the striking property that it completely ignores many examples on each round (by assigning zero weight), which is very helpful for the weak learning algorithm in terms of computational efficiency. To test this, we conducted experiments to compare the efficiency of AdaBoost, “NH-Boost” (an analogous boosting algorithm derived from NormalHedge) and NH-Boost.DT. All details are in Appendix G. Here we only briefly summarize the results. While the three algorithms have similar performance in terms of training and test error, NH-Boost.DT is always the fastest one in terms of running time for the same number of rounds. Moreover, the average faction of examples with zero weight is significantly higher for NH-Boost.DT than for NH-Boost (see Table 3). On one hand, this explains why NHBoost.DT is faster (besides the reason that it does not require a numerical step). On the other hand, this also implies that NH-Boost.DT tends to achieve larger margins, since zero weight is assigned to examples with large margin. This is also confirmed by our experiments.\nAcknowledgements. Support for this research was provided by NSF Grant #1016029. The authors thank Yoav Freund for helpful discussions and the anonymous reviewers for their comments."
    }, {
      "heading" : "A Summary of Drifting Game Variants",
      "text" : "We study three different variants of drifting games throughout the paper, which corresponds to the Hedge setting, the multi-armed bandit problem and online convex optimization respectively. The protocols of these variants are summarized below.\nDGv1\nGiven: a loss function L(s) = 1{s ≤ −R}. For t = 1, . . . , T :\n1. The player chooses a distribution pt over N chips.\n2. The adversary decides the movement of each chip zt,i ∈ [−1, 1] subject to pt · zt ≥ 0 and |zt,i − zt,j | ≤ 1 for all i and j.\nThe player suffers loss ∑N i=1 L( ∑T t=1 zt,i).\nDGv2\nGiven: a loss function L(s) = 1{s ≤ −R}. For t = 1, . . . , T :\n1. The player chooses a distribution pt over N chips.\n2. The adversary randomly decides the movement of each chip zt,i ≥ −1 subject to Et[zt,i] ≤ 1,Et[z2t,i] ≤ 1/pt,i and Et[pt · zt] ≥ 0.\nThe player suffers loss ∑N i=1 L( ∑T t=1 zt,i).\nDGv3\nGiven: a compact convex set S, a loss function L(s) = 1{s ≤ −R}. For t = 1, . . . , T :\n1. The player chooses a density function pt(x) on S.\n2. The adversary decides a function zt(x) : S → [−1, 1] subject to Ex∼pt [zt(x)] ≥ 0.\nThe player suffers loss ∫ x∈S L( ∑T t=1 zt(x))dx."
    }, {
      "heading" : "B Proof of Theorem 1",
      "text" : "Proof. We first show that both conversions are valid. In Algorithm 1, it is clear that ℓt,i ≥ 0. Also, ℓt,i ≤ 1 is guaranteed due to the extra restriction of DGv1. For Algorithm 2, zt,i lies in B = [−1, 1] since ℓt,i ∈ [0, 1], and direct computation showspt·zt = 0 ≥ β(= 0) and |zt,i−zt,j| = |ℓt,i−ℓt,j| ≤ 1 for all i and j.\n(1) For any choices of zt, we have N ∑\ni=1\nL(sT,i) =\nN ∑\ni=1\nL\n(\nN ∑\nt=1\nzt,i\n)\n≤ N ∑\ni=1\nL\n(\nN ∑\nt=1\n(zt,i − pt · zt) ) ,\nwhere the inequality holds since pt · zt is required to be nonnegative and L is a nonincreasing function. By Algorithm 1, zt,i − pt · zt is equal to ℓt,i − pt · ℓt, leading to\nN ∑\ni=1\nL(sT,i) ≤ N ∑\ni=1\nL\n(\nN ∑\nt=1\n(ℓt,i − pt · ℓt) ) = N ∑\ni=1\n1\n{\nR ≤ N ∑\nt=1\n(pt · ℓt − ℓt,i) } .\nSince R(i+1)/NT (H) < R ≤ R i/N T (H), we must have ∑N t=1 (pt · ℓt − ℓt,j) < R except for the best i actions, which means ∑N\ni=1 L(sT,i) ≤ i. This holds for any choices of zt, so LT (DR) ≤ i/N . (2) By Algorithm 2 and the condition LT (DR) < ǫ , we have\n1\nN\nN ∑\ni=1\n1\n{\nR ≤ N ∑\nt=1\n(pt · ℓt − ℓt,i) } = 1\nN\nN ∑\ni=1\nL(sT,i) ≤ LT (DR) < ǫ,\nwhich means there are at most ⌈Nǫ⌉ − 1 actions satisfying R ≤ ∑N t=1 (pt · ℓt − ℓt,i), and thus ∑N\nt=1 (pt · ℓt − ℓt,iǫ) < R. Since this holds for any choices of ℓt, we have RǫT (H) < R."
    }, {
      "heading" : "C Summary of Hedge Algorithms and Proofs of Lemma 1, Lemma 2 and",
      "text" : "Corollary 2\nProof of Lemma 1. It suffices to show [s − 1]2− + [s + 1]2− ≤ 2[s]2− + 2. When s ≥ 0, LHS = [s− 1]2− ≤ 1 < 2 = RHS. When s < 0, LHS ≤ (s− 1)2 + (s+ 1)2 = 2s2 + 2 = RHS.\nProof of Lemma 2. Let F (s) = exp ( [s−1]2 −\ndt\n) +exp ( [s+1]2 −\ndt\n) −2 exp ( [s]2 −\nd(t−1)\n)\n. It suffices to show\nF (s) ≤ 2(bt − bt−1) = exp ( 4\ndt\n)\n− 1,\nwhich is clearly true for the following 3 cases:\nF (s) =\n\n  \n  \n0 if s > 1; exp (\n(s−1)2 dt\n)\n− 1 < exp ( 1 dt ) − 1 if 0 < s ≤ 1; exp (\n(s−1)2 dt\n) + 1− 2 exp ( s2\nd(t−1)\n)\n< exp ( 4 dt ) − 1 if −1 < s ≤ 0.\nFor the last case s ≤ −1, if we can show that F (s) is increasing in this region, then the lemma follows. Below, we show this by proving F ′(s) is nonnegative when s ≤ −1.\nLet h(s, c) = ∂ exp(s2/c)\n∂s = 2s c exp\n(\ns2\nc\n)\n. F ′(s) can now be written as\nF ′(s) = h(s− 1, c) + h(s+ 1, c)− 2h(s, c) + 2(h(s, c)− h(s, c′)), where c = dt and c′ = d(t − 1). Next we apply (one-dimensional) Taylor expansion to h(s− 1, c) and h(s+ 1, c) around s, and h(s, c′) around c, leading to\nF ′(s) = ∞ ∑\nk=1\n(−1)k k! ∂kh(s, c) ∂sk +\n∞ ∑\nk=1\n1\nk!\n∂kh(s, c)\n∂sk − 2\n∞ ∑\nk=1\n(c′ − c)k k! ∂kh(s, c) ∂ck\n= 2\n∞ ∑\nk=1\n(\n1\n(2k)!\n∂2kh(s, c) ∂s2k − (−d) k k! ∂kh(s, c) ∂ck\n)\n.\nDirect computation (see Lemma 3 below) shows that ∂ kh(s,c) ∂ck and ∂ 2kh(s,c) ∂s2k\nshare exact same forms only with different constants:\n∂kh(s, c)\n∂ck = exp\n(\ns2\nc\n) k ∑\nj=0\n(−1)kαk,j · s2j+1\nck+j+1 ,\n∂2kh(s, c)\n∂s2k = exp\n(\ns2\nc\n) k ∑\nj=0\nβk,j · s2j+1\nck+j+1 ,\n(4)\nwhere αk,j and βk,j are recursively defined as:\nαk+1,j = αk,j−1 + (k + j + 1)αk,j , βk+1,j = 4βk,j−1 + (8j + 6)βk,j + (2j + 3)(2j + 2)βk,j+1, (5)\nwith initial values α0,0 = β0,0 = 2 (when j 6∈ {0, . . . , k}, αk,j and βk,j are all defined to be 0). Therefore, F ′(s) can be further simplified as\nF ′(s) = 2 exp\n(\ns2\nc\n) ∞ ∑\nk=1\nk ∑\nj=0\ns2j+1\nck+j+1\n(\nβk,j (2k)! − d kαk,j k!\n)\n.\nSince s is negative, it suffices to show that βk,j(2k)! ≤ dkαk,j\nk! holds for all k and j, which turns out to be true as long as d ≥ 3, as shown by induction in the technical lemma 4 below. To sum up, Φt(s− 1) + Φt(s+ 1) ≤ 2Φt−1(s) for all s ∈ R and t = 2, . . . , T . Finally, we need to show that Eq. (2) still holds. The inequality we just proved above implies ∑\niΦt(st,i) ≤ ∑\ni Φt−1(st−1,i) for t = 2, . . . , T , as shown in Theorem 2. Thus the only thing we need to show here is the case when t = 1. Note that Φ1(s − 1) + Φ1(s + 1) ≤ 2Φ0(s) does not hold for all s apparently. However, in order to prove ∑\ni Φ1(s1,i) ≤ ∑\ni Φ0(s0,i), we in fact only need a much weaker statement: Φ1(−1) + Φ1(1) ≤ 2Φ0(0) since s0,i ≡ 0. This is equivalent to exp (1/d)− 1 ≤ exp (4/d)− 1, which is true trivially.\nLemma 3. Let h(s, c) = 2sc exp ( s2 c ) . The partial derivatives of h(s, c) satisfy Eq. (4) and (5).\nProof. The base case holds trivially. Assume Eq. (4) holds for a fixed k. Then we have\n∂k+1h(s, c)\n∂ck+1 = exp\n(\ns2\nc\n) k ∑\nj=0\n(−1)kαk,j · ( −s 2 c2 s2j+1 ck+j+1 − (k + j + 1) s 2j+1 ck+j+2 )\n= exp\n(\ns2\nc\n) k ∑\nj=0\n(−1)k+1αk,j · ( s2(j+1)+1\nc(k+1)+(j+1)+1 + (k + j + 1)\ns2j+1\nc(k+1)+j+1\n)\n= exp\n(\ns2\nc\n) k+1 ∑\nj=0\n(−1)k+1 (αk,j−1 + (k + j + 1)αk,j) · s2j+1\nc(k+1)+j+1\n= exp\n(\ns2\nc\n) k+1 ∑\nj=0\n(−1)k+1αk+1,j · s2j+1\nc(k+1)+j+1 ,\nand\n∂2(k+1)h(s, c)\n∂s2(k+1) = ∂\n\nexp\n(\ns2\nc\n) k ∑\nj=0\nβk,j · ( 2s2j+2\nck+j+2 + (2j + 1)\ns2j\nck+j+1\n)\n\n\n/\n∂s\n= exp\n(\ns2\nc\n) k ∑\nj=0\nβk,j · ( 4s2j+3\nck+j+3 + (8j + 6)\ns2j+1\nck+j+2 + (2j + 1)2j\ns2j−1\nck+j+1\n)\n= exp\n(\ns2\nc\n) k+1 ∑\nj=0\n(4βk,j−1 + (8j + 6)βk,j + (2j + 3)(2j + 2)βk,j+1) · s2j+1\nck+j+2\n= exp\n(\ns2\nc\n) k+1 ∑\nj=0\nβk+1,j · s2j+1\nck+j+2 ,\nconcluding the proof.\nLemma 4. Let αk,j and βk,j be defined as in Eq. (5). Then βk,j (2k)! ≤ dkαk,j k! holds for all k ≥ 0 and j ∈ {0, . . . , k} when d ≥ 3.\nProof. We prove the lemma by induction on k. The base case k = 0 is trivial. Assume βk,j(2k)! ≤ dkαk,j\nk! holds for a fixed k and all j ∈ {0, . . . , k}, then we have ∀j,\nβk+1,j (2k + 2)! = 4βk,j−1 + (8j + 6)βk,j + (2j + 3)(2j + 2)βk,j+1 (2k + 2)!\n≤ d k (4αk,j−1 + (8j + 6)αk,j + (2j + 3)(2j + 2)αk,j+1)\n(2k + 2)(2k + 1)k! .\nWe need to show that the above expression is at most dk+1αk+1,j/(k + 1)!, which, after arrangements, is equivalent to 2αk,j−1 + (4j + 3)αk,j + (2j + 3)(j + 1)αk,j+1 ≤ d(2k + 1)αk+1,j . We will prove this by another induction on k. Then the lemma follows.\nThe base case (k = 0) is simplified to 6 ≤ 2d, which is true by our assumption d ≥ 3. Assume the inequality holds for a fixed k, then by the definition of αk,j , one has\n2αk+1,j−1 + (4j + 3)αk+1,j + (2j + 3)(j + 1)αk+1,j+1 = (2αk,j−2 + (4j + 3)αk,j−1 + (2j + 3)(j + 1)αk,j)+\n(2(k + j)αk,j−1 + (4j + 3)(k + j + 1)αk,j + (2j + 3)(j + 1)(k + j + 2)αk,j+1)\n= (2αk,j−2 + (4j − 1)αk,j−1 + (2j + 1)jαk,j)+ (k + j + 2) (2αk,j−1 + (4j + 3)αk,j + (2j + 3)(j + 1)αk,j+1) ≤ d(2k + 1)(αk+1,j−1 + (k + j + 2)αk+1,j) (by induction) = d(2k + 1)αk+2,j ≤ d(2k + 3)αk+2,j ,\ncompleting the induction.\nProof of Corollary 2. Recall that ΦT (s) ≥ 1 { s ≤ − √ dT ln ( 1 a + 1 ) } . So by setting Φ0(0) = a(1− b0) < ǫ and applying Theorem 2, we arrive at\nRǫT (H) ≤ √ dT ln (\n1− b0 ǫ + 1\n)\n.\nIt suffices to upper bound 1 − b0, which, by definition, is 12 ∑T t=1 ( exp ( 4 dt ) − 1 ) . Since ex − 1 ≤ ec−1\nc x for any x ∈ [0, c], we have\nT ∑\nt=1\n(\nexp\n(\n4\ndt\n) − 1 ) ≤ (e4/d − 1) T ∑\nt=1\n1 t ≤ (e4/d − 1)(lnT + 1).\nPlugging d = 3 gives the corollary."
    }, {
      "heading" : "D A General MAB Algorithm and Regret Bounds",
      "text" : "Input: A convex, nonincreasing, nonnegative function ΦT (s) ∈ C2, with nonincreasing second derivative. for t = T down to 1 do Find a convex function Φt−1(s) s.t. the conditions of Theorem 4 hold. Set: s0 = 0. for t = 1 to T do\nSet: pt,i ∝ Φt(st−1,i − 1)− Φt(st−1,i + 1). Draw it ∼ pt and receive loss ℓt,it . Set: zt,i = 1{i = it} · ℓt,it/pt,it − ℓt,it , ∀i. Set: st = st−1 + zt.\nAlgorithm 4: A General MAB Algorithm\nTheorem 4. Suppose Φt(s) is convex, twice continuously differentiable (i.e. Φt(s) ∈ C2), have nonincreasing second derivative, and satisfies:\n(\n1 2 +Nαt\n) Φt(s− 1) + ( 1 2 −Nαt ) Φt(s+ 1) ≤ Φt−1(s), ∀s ∈ R (6)\nwhere αt = 12 maxs Φ′′t (s−1)\nΦt(s−1)−Φt(s+1) . If the player’s strategy is such that pt,i ∝ Φt(st−1,i − 1)− Φt(st−1,i + 1), then Eq. (2) holds in expectation.\nProof of Theorem 4. As discussed before, the main difficulty here is the unboundedness of zt,i. However, the expectation of zt,i is still in [−1, 1] as in DGv1. To exploit this fact, we apply Taylor’s theorem to Φt(st−1,i + zt,i) to the second order term:\nΦt(st,i) = Φt(st−1,i + zt,i)\n= Φt(st−1,i) + Φ ′ t(st−1,i)zt,i + 1 2Φ ′′ t (ξt,i)z 2 t,i ≤ Φt(st−1,i) + Φ′t(st−1,i)zt,i + 12Φ ′′ t (st−1,i − 1)z2t,i,\nwhere ξt,i is between st−1,i+zt,i and st−1,i, and the inequality holds becauseΦ′′t (s) is nonincreasing and zt,i ≥ −1 by assumption. Now taking expectation on both sides with respect to the randomness of zt,i, using the convexity of Φt(s), and plugging the assumption Et[z2t,i] ≤ 1/pt,i give:\nEt[Φt(st,i)] ≤ Φt(st−1,i) + Φ′t(st−1,i)Et[zt,i] + 12Φ ′′ t (st−1,i − 1)Et[z2t,i]\n≤ Φt (st−1,i + Et[zt,i]) + 12Φ ′′ t (st−1,i − 1)/pt,i.\nLet wt,i = 12 (Φt(st−1,i − 1)− Φt(st−1,i + 1)). Further plugging pt,i ∝ wt,i and summing over all i, we arrive at\nN ∑\ni=1\nEt[Φt(st,i)] ≤ N ∑\ni=1\n(\nΦt (st−1,i + Et[zt,i]) + Φ′′t (st−1,i − 1)\n2wt,i ·\nN ∑\ni=1\nwt,i\n)\n≤ N ∑\ni=1\n(\nΦt (st−1,i + Et[zt,i]) + 2αt\nN ∑\ni=1\nwt,i\n)\n(by the defintion of αt)\n=\nN ∑\ni=1\n(Φt (st−1,i + Et[zt,i]) + 2Nαtwt,i) .\nSince Et[pt · zt] ≥ 0 implies ∑N i=1 wt,iEt[zt,i] ≥ 0, we thus have N ∑\ni=1\nEt[Φt(st,i)] ≤ N ∑\ni=1\n(Φt (st−1,i + Et[zt,i]) + wt,iEt[zt,i] + 2Nαtwt,i)\n≤ N ∑\ni=1\n(\nmax z∈[−1,+1] (Φt (st−1,i + z) + wt,iz) + 2Nαtwt,i\n)\n= N ∑\ni=1\n(\nmax z∈{−1,+1} (Φt (st−1,i + z) + wt,iz) + 2Nαtwt,i\n)\n(by the convexity of Φt(s))\n=\nN ∑\ni=1\n((\n1 2 +Nαt\n) Φt(st−1,i − 1) + ( 1 2 −Nαt ) Φt(st−1,i + 1) )\n≤ N ∑\ni=1\nΦt−1(st−1,i). (by assumption)\nThe theorem follows by taking expectation on both sides with respect to the past (i.e. the randomness of z1, . . . , zt−1).\nTheorem 5. For Algorithm 4, if R and ǫ are such that Φ0(0) < ǫ and ΦT (s) ≥ 1{s ≤ −R} for all s ∈ R, then E[∑Tt=1 ℓt,it − ∑T t=1 ℓt,iǫ ] < R for any non-oblivious adversary. Moreover, using ΦT (s) = exp(−η(s + R)) (and let Eq. (6) hold with equality) gives exactly the EXP3 algorithm with regret O( √ TN ln(1/ǫ)).\nProof of Theorem 5. We first show that Algorithm 4 converts the multi-armed bandit problem to a valid instance of DGv2. It suffices to prove that zt,i = 1{i = it} · ℓt,it/pt,it − ℓt,it satisfies all conditions defined in DGv2, as shown below (zt,i ≥ −1 is trivial):\nEt[zt,i] = ℓt,i − pt · ℓt ≤ 1,\nEt[z 2 t,i] = pt,i\n(\nℓt,i pt,i\n− ℓt,i )2 + ∑\nj 6=i pt,jℓ\n2 t,j ≤ pt,i\n(\n1\npt,i − 1\n)2\n+ ∑\nj 6=i pt,j =\n1 pt,i − 1 ≤ 1 pt,i ,\nEt[pt · zt] = Et\n ℓt,it − N ∑\nj=1\npt,jℓt,it\n\n = 0.\nTherefore, we can apply Theorem 4 directly, arriving at:\n1\nN\nN ∑\ni=1\nE[ΦT (sT,i)] ≤ · · · ≤ 1\nN\nN ∑\ni=1\nE[Φ0(s0,i)] = Φ0(0) ≤ ǫ.\nOn the other hand, by applying Jensen’ inequality, we have\nE[ΦT (sT,i)] ≥ ΦT (E[sT,i]) ≥ 1{E[sT,i] ≤ −R}.\nNote that E[sT,i] is equal to E [ ∑T t=1 (ℓt,i − ℓt,it) ] . We thus know\n1\nN\nN ∑\ni=1\n1\n{\nE\n[\nT ∑\nt=1\n(ℓt,i − ℓt,it) ] ≤ −R } < ǫ,\nwhich implies E [\n∑T t=1 ℓt,it − ∑T t=1 ℓt,iǫ\n]\n< R for any non-oblivious adversary for the exact same\nargument used in the proof of Theorem 2.\nFinally, we show how to recover EXP3 using Algorithm 4 with input ΦT (s) = exp(−η(s+R)). To compute Φt(s) for t < T , we simply use Eq. (6) with equality. One can verify using induction that\nΦt(s) = exp (−η(s+R)) ( eη + e−η +Neηη2\n2\n)T−t ,\nαt = 1\n2 max s η2Φt(s− 1) Φt(s− 1)− Φt(s+ 1) = eηη2 2(eη − e−η) ,\nΦ′′′t (s) = −η3Φt(s) ≤ 0.\nThe player’s strategy is thus pt,i ∝ exp(−η ∑t−1\nτ=1 ℓ̂τ,i) (recall ℓ̂t,i = 1{i = it} · ℓt,it/pt,it is the estimated loss), which is exactly the same as EXP3 (in fact a simplified version of the original EXP3, see for example [30]). Moreover, the regret can be computed by setting Φ0(0) = ǫ, leading to\nR = 1\nη ln\n(\n1\nǫ\n)\n+ T\nη ln\n( eη + e−η\n2 +\n1 2 Neηη2\n)\n≤ 1 η ln\n(\n1\nǫ\n)\n+ T\nη ln\n(\neη 2/2 +\n1 2 Neηη2\n)\n(by Hoeffding’s Lemma)\n≤ 1 η ln\n(\n1\nǫ\n)\n+ T\nη\n(\nη2\n2 +\n1 2 Neη− η2 2 η2 )\n(ln(1 + x) ≤ x)\nIf η ≤ 1 so that eη−η2/2 ≤ √e, then we have R ≤ 1η ln(1ǫ ) + Tη ( 1 2 + N √ e 2 )\n, which is √\n2T (1 +N √ e) ln(1/ǫ) after optimally choosing η (η ≤ 1 will be satisfied when T is large\nenough)."
    }, {
      "heading" : "E A General OCO Algorithm and Regret Bounds",
      "text" : "Input: A convex, nonincreasing, nonnegative function ΦT (s) for t = T down to 1 do\nFind a convex function Φt−1(s) s.t. ∀s, Φt(s− 1) + Φt(s+ 1) ≤ 2Φt−1(s). Set: s0(x) ≡ 0. for t = 1 to T do\nPredict xt = Ex∼pt [x] where pt is such that pt(x) ∝ Φt(st−1(x) − 1)− Φt(st−1(x) + 1). Receive loss function ft from the adversary. Set: zt(x) = ft(x) − ft(xt). Set: st(x) = st−1(x) + zt(x).\nAlgorithm 5: A General OCO Algorithm\nDefinition of ǫ-regret in the OCO setting: Let Sǫ ⊂ S be such that the ratio of its volume and the one of S is ǫ and also\n∑T t=1 ft(x ′) ≤ ∑Tt=1 ft(x) for all x′ ∈ Sǫ and x ∈ S\\Sǫ (it is clear that such set exists). Then ǫ-regret is defined as RǫT (x1:T , f1:T ) = ∑T t=1 ft(xt)− infx∈S\\Sǫ ∑T t=1 ft(x). Theorem 6. For Algorithm 5, if R is such that ΦT (s) ≥ 1{s ≤ −R} and Φ0(0) < ǫ, then we have RǫT (x1:T , f1:T ) < R and RT (x1:T , f1:T ) < R+ T ǫ 1/d. Specifically, if R = O( √\nT ln(1/ǫ)), then setting ǫ = T−d gives RT (x1:T , f1:T ) = O( √ dT lnT ).\nProof of Theorem 6. Let wt(x) = 12 (Φt(st−1(x)− 1)− Φt(st−1(x) + 1)). Similarly to the Hedge setting, the “sum” of potentials never increases: ∫\nx∈S Φt(st(x))dx ≤\n∫\nx∈S (Φt(st−1(x) + zt(x)) + wt(x)zt(x)) dx ≤\n∫\nx∈S Φt−1(st−1(x))dx.\nHere, the first inequality is due to Ex∼pt [zt(x)] ≥ 0, and the second inequality holds for the exact same reason as in the case for Hedge. Therefore, we have\n∫\nx∈S 1{sT (x) ≤ −R}dx ≤\n∫\nx∈S ΦT (sT (x))dx ≤ · · · ≤\n∫\nx∈S Φ0(0)dx < ǫV,\nwhere V is the volume of S. Recall the construction of Sǫ. There must exist a point x′ ∈ Sǫ such that sT (x′) > −R, otherwise ∫ x 1{sT (x) ≤ −R}dx would be at least ǫV . Unfolding sT (x′), we arrive at ∑\nt ft(xt) − ∑ t ft(x ′) < R. Using the fact ∑ t ft(x ′) ≤ infx∈S\\Sǫ ∑\nt ft(x) gives the bound for ǫ-regret.\nNext consider a shrunk version of S: S′ǫ = {(1 − ǫ 1 d )x∗ + ǫ 1 dx : x ∈ S} where x∗ ∈ argminx ∑ t ft(x). Then ∫\nx∈S 1{sT (x) ≤ −R}dx is at least ∫\nx∈S′ǫ 1{sT (x) ≤ −R}dx = ǫ\n∫\nx∈S 1\n{\nsT\n( (1− ǫ 1d )x∗ + ǫ 1dx ) ≤ −R } dx,\nwhich, by the convexity and the boundedness of ft(x), is at least\nǫ\n∫\nx∈S 1\n{\nT ∑\nt=1\n(\n(1− ǫ 1d )ft(x∗) + ǫ 1 d ft(x)− ft(xt)\n) ≤ −R } dx\n≥ ǫ ∫\nx∈S 1\n{\nT ∑\nt=1\n(ft(x ∗)− ft(xt)) ≤ −R− T ǫ 1 d\n}\ndx\n= ǫV · 1 { T ∑\nt=1\n(ft(x ∗)− ft(xt)) ≤ −R− T ǫ 1 d\n}\n.\nFollowing the previous discussion, the expression in the last line above is strictly less than ǫV ·, which means that the value of the indicator function has to be 0, namely, RT (x1:T , f1:T ) < R + T ǫ1/d."
    }, {
      "heading" : "F NH-Boost.DT, NH-Boost and Proof of Theorem 3",
      "text" : "Input : Training examples (xi, yi) ∈ Rd × {−1,+1}, i = 1, . . . , N. Input : A weak learning algorithm. Input : Number of rounds T . Output: A Hypothesis H(x) : Rd → {−1,+1}. Set: s0 = 0. for t = 1 to T do\nSet: pt,i ∝ exp ( [st−1,i − 1]2−/3t ) − exp ( [st−1,i + 1]2−/3t ) , ∀i. Invoke the weak learning algorithm to get ht with edge γt = 12 ∑\ni pt,iyiht(xi). Set: st,i = st−1,i + 12yiht(xi)− γt, ∀i.\nSet: H(x) = sign( ∑T\nt=1 ht(x)).\nAlgorithm 6: NH-Boost.DT\nInput : Training examples (xi, yi) ∈ Rd × {−1,+1}, i = 1, . . . , N. Input : A weak learning algorithm. Input : Number of rounds T . Output: A Hypothesis H(x) : Rd → {−1,+1}. Set: s0 = 0. for t = 1 to T do\nif t = 1 then Set: p1 to be a uniform distribution. else Find: c such that\n∑N i=1 exp ( [st−1,i]2−/c )\n= Ne. Set: pt,i ∝ −[st−1,i]− exp ( [st−1,i]2−/c )\n, ∀i. Invoke the weak learning algorithm to get ht with edge γt = 12 ∑\ni pt,iyiht(xi). Set: st,i = st−1,i + 12yiht(xi)− γt, ∀i.\nSet: H(x) = sign( ∑T\nt=1 ht(x)).\nAlgorithm 7: NH-Boost\nIn the boosting setting for binary classification, we are given a set of training examples (xi, yi)i=1,...,N where xi ∈ Rd is an example and yi ∈ {−1,+1} is its label. A boosting algorithm proceeds for T rounds. On each round, a distribution pt over the examples is computed and fed into a weak learning algorithm which returns a “weak” hypothesis ht : Rd → {−1,+1} with a guaranteed small edge, that is, γt = 12 ∑\ni pt,iyiht(xi) ≥ γ > 0. At the end, a linear combination of all ht is computed as the final “strong” hypothesis which is expected to have low training error and potentially low generalization error.\nThe conversion of a Hedge algorithm into a boosting algorithm is to treat each example as an “action” and set ℓt,i = 1{ht(xi) = yi} so that the booster tends to increase weights for those “hard”\nexamples. The final hypothesis is a simple majority vote of all ht, that is, H(x) = sign( ∑\nt ht(x)) where sign(x) is the sign function that outputs 1 if x is positive, and −1 otherwise. The margin of example xi is defined as 1T ∑T t=1 yiht(xi), that is, the difference between the fractions of correct hypotheses and incorrect hypotheses on this example. The boosting algorithms derived from NormalHedge.DT and NormalHedge in this way are given in Algorithm 6 and 7.\nProof the Theorem 3. Let (x̃i, ỹi)i=1,...,N be a permutation of the training examples such that their margins are sorted from smallest to largest: ∑\nt ỹ1ht(x̃1) ≤ · · · ≤ ∑\nt ỹNht(x̃N ), which also implies ∑\nt 1{ht(x̃1) = ỹ1} ≤ · · · ≤ ∑ t 1{ht(x̃N ) = ỹN}. Recall that NormalHedge.DT is essentially playing a Hedge game using NormalHedge.DT with loss ℓt,i = 1{ht(xi) = yi}. Therefore, the ǫ-regret bound for the Hedge setting together with the assumption on the weak learning algorithm implies: ∀j ∈ {1, . . . , N},\n1 2 + γ ≤ 1 T\nT ∑\nt=1\nN ∑\ni=1\npt,i1{ht(xi) = yi} ≤ 1\nT\nT ∑\nt=1\n1{ht(x̃j) = ỹj}+ R\nj/N T T , (7)\nwhere Rj/NT = Õ( √ 3T ln(N/j)) is the j/N -regret bound for NormalHedge.DT. So if j is such that γ > Rj/NT /T , we have 1 T ∑T t=1 1{ht(x̃j) = ỹj} > 12 , which is saying that example (x̃j , ỹj) will eventually be classified correctly by H(x) due to the fact that H(x) is taking a majority vote of all ht. This is in fact true for all examples (x̃i, ỹi) such that i ≥ j and thus the training error rate will be at most (j − 1)/N , which is of order Õ(exp(− 13Tγ2)). For the margin bound, by plugging 1{ht(x̃j) = ỹj} = (ỹjht(x̃j) + 1)/2, we rewrite Eq. (7) as:\n2\n(\nγ − R j/N T\nT\n)\n≤ 1 T\nT ∑\nt=1\nỹjht(x̃j).\nTherefore, if j is such that θ < 2(γ −Rj/NT /T ), then the fraction of examples with margin at most θ is again at most (j − 1)/N , which is of order Õ(exp(− 13T (θ − 2γ)2))."
    }, {
      "heading" : "G Experiments in a Boosting Setting",
      "text" : "We conducted experiments to compare the performance of three boosting algorithms for binary classification: AdaBoost [14], NH-Boost (Algorithm 7) and NH-Boost.DT (Algorithm 6), using a set of benchmark data available from the UCI repository3 and LIBSVM datasets4. Some datasets are preprocessed according to [27]. The number of features, training examples and test examples can be found in Table 2.\nAll features are binary. The weak learning algorithm is a simple (exhaustive) decision stump (see for instance [29]). On each round, the weak learning algorithm enumerates all features, and for each feature computes the weighted error of the corresponding stump on the weighted training examples. Therefore, if the number of examples with zero weight is relatively large, then the weak learning algorithm would be faster in computing the weighted error and thus faster in finding the best feature.\nAll boosting algorithms are run for two hundred rounds. The results are summarized in Table 3, with bold entries being the best ones among the three (AB, NB and NBDT stand for AdaBoost, NH-Boost and NH-Boost.DT respectively). As we can see, in terms of training error and test error, all three algorithms have similar performance. However, our NH-Boost.DT algorithm is always the fastest one. The average fraction of examples with zero weights for NH-Boost.DT is significantly higher than the one for NH-Boost (note that AdaBoost does not assign zero weight at all). We plot the change of this fraction over rounds in Figure 1 (using three datasets). As both algorithms proceed, they tend to ignore more and more examples on each round, but NH-Boost.DT consistently ignores more examples than NH-Boost.\nSince st,i is positively correlated to the margin of example i ( 1t ∑t\nτ=1 yihτ (xi)) and large st,i leads to zero weight, the above phenomenon in fact implies that the examples’ margins should be larger for\n3http://archive.ics.uci.edu/ml/ 4http://www.csie.ntu.edu.tw/˜cjlin/libsvmtools/datasets/\nNH-Boost.DT than for NH-Boost. This is confirmed by Figure 2, where we plot the final cumulative margins on three datasets (i.e. each point represents the fraction of examples with at most some fixed margin). One can see that the lines for NH-Boost.DT are below the ones for NH-Boost (and even AdaBoost) for most time, meaning that NH-Boost.DT achieves larger margins in general. This could explain NH-Boost.DT’s better test error on some datasets."
    } ],
    "references" : [ {
      "title" : "Optimal strategies and minimax lower bounds for online convex games",
      "author" : [ "Jacob Abernethy", "Peter L. Bartlett", "Alexander Rakhlin", "Ambuj Tewari" ],
      "venue" : "In Proceedings of the 21st Annual Conference on Learning Theory,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2008
    }, {
      "title" : "Minimax games with bandits",
      "author" : [ "Jacob Abernethy", "Manfred K. Warmuth" ],
      "venue" : "In Proceedings of the 22st Annual Conference on Learning Theory,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2009
    }, {
      "title" : "Repeated games against budgeted adversaries",
      "author" : [ "Jacob Abernethy", "Manfred K. Warmuth" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2010
    }, {
      "title" : "Regret bounds and minimax policies under partial monitoring",
      "author" : [ "Jean-Yves Audibert", "Sébastien Bubeck" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2010
    }, {
      "title" : "Regret in online combinatorial optimization",
      "author" : [ "Jean-Yves Audibert", "Sébastien Bubeck", "Gábor Lugosi" ],
      "venue" : "Mathematics of Operations Research,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2014
    }, {
      "title" : "The nonstochastic multiarmed bandit problem",
      "author" : [ "Peter Auer", "Nicolò Cesa-Bianchi", "Yoav Freund", "Robert E. Schapire" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2002
    }, {
      "title" : "How to use expert advice",
      "author" : [ "Nicolò Cesa-Bianchi", "Yoav Freund", "David Haussler", "David P. Helmbold", "Robert E. Schapire", "Manfred K. Warmuth" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1997
    }, {
      "title" : "Potential-based algorithms in on-line prediction and game theory",
      "author" : [ "Nicolò Cesa-Bianchi", "Gábor Lugosi" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2003
    }, {
      "title" : "Prediction, Learning, and Games",
      "author" : [ "Nicolò Cesa-Bianchi", "Gábor Lugosi" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2006
    }, {
      "title" : "A parameter-free hedging algorithm",
      "author" : [ "Kamalika Chaudhuri", "Yoav Freund", "Daniel Hsu" ],
      "venue" : "Advances in Neural Information Processing Systems",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2009
    }, {
      "title" : "Prediction with advice of unknown number of experts",
      "author" : [ "Alexey Chernov", "Vladimir Vovk" ],
      "venue" : "arXiv preprint arXiv:1006.0475,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2010
    }, {
      "title" : "Universal portfolios",
      "author" : [ "Thomas M. Cover" ],
      "venue" : "Mathematical Finance,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1991
    }, {
      "title" : "Boosting a weak learning algorithm by majority",
      "author" : [ "Yoav Freund" ],
      "venue" : "Information and Computation,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1995
    }, {
      "title" : "A decision-theoretic generalization of on-line learning and an application to boosting",
      "author" : [ "Yoav Freund", "Robert E. Schapire" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1997
    }, {
      "title" : "Adaptive game playing using multiplicative weights",
      "author" : [ "Yoav Freund", "Robert E. Schapire" ],
      "venue" : "Games and Economic Behavior,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1999
    }, {
      "title" : "Additive logistic regression: A statistical view of boosting",
      "author" : [ "Jerome Friedman", "Trevor Hastie", "Robert Tibshirani" ],
      "venue" : "Annals of Statistics,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2000
    }, {
      "title" : "Logarithmic regret algorithms for online convex optimization",
      "author" : [ "Elad Hazan", "Amit Agarwal", "Satyen Kale" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2007
    }, {
      "title" : "Efficient algorithms for online decision problems",
      "author" : [ "Adam Kalai", "Santosh Vempala" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2005
    }, {
      "title" : "Anytime algorithms for multi-armed bandit problems",
      "author" : [ "Robert Kleinberg" ],
      "venue" : "In Proceedings of the seventeenth annual ACM-SIAM symposium on Discrete algorithm,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2006
    }, {
      "title" : "Online decision problems with large strategy sets",
      "author" : [ "Robert David Kleinberg" ],
      "venue" : "PhD thesis,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2005
    }, {
      "title" : "Towards Minimax Online Learning with Unknown Time Horizon",
      "author" : [ "Haipeng Luo", "Robert E. Schapire" ],
      "venue" : "In Proceedings of the 31st International Conference on Machine Learning,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2014
    }, {
      "title" : "Unconstrained online linear learning in hilbert spaces: Minimax algorithms and normal approximations",
      "author" : [ "H Brendan McMahan", "Francesco Orabona" ],
      "venue" : "In Proceedings of the 27th Annual Conference on Learning Theory,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2014
    }, {
      "title" : "Learning with continuous experts using drifting games",
      "author" : [ "Indraneel Mukherjee", "Robert E. Schapire" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2010
    }, {
      "title" : "Random walk approach to regret minimization",
      "author" : [ "Hariharan Narayanan", "Alexander Rakhlin" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2010
    }, {
      "title" : "Simultaneous model selection and optimization through parameter-free stochastic learning",
      "author" : [ "Francesco Orabona" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2014
    }, {
      "title" : "Relax and localize: From value to algorithms",
      "author" : [ "Alexander Rakhlin", "Ohad Shamir", "Karthik Sridharan" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2012
    }, {
      "title" : "How boosting the margin can also boost classifier complexity",
      "author" : [ "Lev Reyzin", "Robert E. Schapire" ],
      "venue" : "In Proceedings of the 23rd International Conference on Machine Learning,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2006
    }, {
      "title" : "Drifting games",
      "author" : [ "Robert E. Schapire" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2001
    }, {
      "title" : "Boosting: Foundations and Algorithms",
      "author" : [ "Robert E. Schapire", "Yoav Freund" ],
      "venue" : null,
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2012
    }, {
      "title" : "Online learning and online convex optimization",
      "author" : [ "Shai Shalev-Shwartz" ],
      "venue" : "Foundations and Trends in Machine Learning,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "This is possible for some special cases ([7, 1, 3, 21]) but difficult in general.",
      "startOffset" : 41,
      "endOffset" : 54
    }, {
      "referenceID" : 0,
      "context" : "This is possible for some special cases ([7, 1, 3, 21]) but difficult in general.",
      "startOffset" : 41,
      "endOffset" : 54
    }, {
      "referenceID" : 2,
      "context" : "This is possible for some special cases ([7, 1, 3, 21]) but difficult in general.",
      "startOffset" : 41,
      "endOffset" : 54
    }, {
      "referenceID" : 20,
      "context" : "This is possible for some special cases ([7, 1, 3, 21]) but difficult in general.",
      "startOffset" : 41,
      "endOffset" : 54
    }, {
      "referenceID" : 13,
      "context" : "On the other hand, many other efficient algorithms with optimal regret rate (but not exactly minimax optimal) have been proposed for different learning settings (such as the exponential weights algorithm [14, 15], and follow the perturbed leader [18]).",
      "startOffset" : 204,
      "endOffset" : 212
    }, {
      "referenceID" : 14,
      "context" : "On the other hand, many other efficient algorithms with optimal regret rate (but not exactly minimax optimal) have been proposed for different learning settings (such as the exponential weights algorithm [14, 15], and follow the perturbed leader [18]).",
      "startOffset" : 204,
      "endOffset" : 212
    }, {
      "referenceID" : 17,
      "context" : "On the other hand, many other efficient algorithms with optimal regret rate (but not exactly minimax optimal) have been proposed for different learning settings (such as the exponential weights algorithm [14, 15], and follow the perturbed leader [18]).",
      "startOffset" : 246,
      "endOffset" : 250
    }, {
      "referenceID" : 25,
      "context" : "[26] built a bridge between these two classes of methods by showing that many existing algorithms can indeed be derived from a minimax analysis followed by a series of relaxations.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 27,
      "context" : "Drifting games [28] (reviewed in Section 2) generalize Freund’s “majority-vote game” [13] and subsume some well-studied boosting and online learning settings.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 12,
      "context" : "Drifting games [28] (reviewed in Section 2) generalize Freund’s “majority-vote game” [13] and subsume some well-studied boosting and online learning settings.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 27,
      "context" : "A nearly minimax optimal algorithm is proposed in [28].",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 27,
      "context" : "We then generalize the minimax analysis in [28] based on one key idea: relax a 0-1 loss function by a convex surrogate.",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 13,
      "context" : "Hedge Settings: (Section 3) The Hedge problem [14] investigates how to cleverly bet across a set of actions.",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 9,
      "context" : "3) bears some similarities with the NormalHedge algorithm [10] and enjoys a similar ǫ-regret bound simultaneously for all ǫ and horizons.",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 9,
      "context" : "Our analysis is also arguably simpler and more intuitive than the one in [10] and easy to be generalized to more general settings.",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 5,
      "context" : "Multi-armed Bandit Problems: (Section 4) The multi-armed bandit problem [6] is a classic example for learning with incomplete information where the learner can only obtain feedback for the actions taken.",
      "startOffset" : 72,
      "endOffset" : 75
    }, {
      "referenceID" : 5,
      "context" : "Again the minimax analysis is generalized and the EXP3 algorithm [6] is recovered.",
      "startOffset" : 65,
      "endOffset" : 68
    }, {
      "referenceID" : 1,
      "context" : "Our results could be seen as a preliminary step to answer the open question [2] on exact minimax optimal algorithms for the multi-armed bandit problem.",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 11,
      "context" : "Fortunately, it turns out that all results from the Hedge setting are ready to be used here, recovering the continuous EXP algorithm [12, 17, 24] and also generalizing our new algorithms to this general setting.",
      "startOffset" : 133,
      "endOffset" : 145
    }, {
      "referenceID" : 16,
      "context" : "Fortunately, it turns out that all results from the Hedge setting are ready to be used here, recovering the continuous EXP algorithm [12, 17, 24] and also generalizing our new algorithms to this general setting.",
      "startOffset" : 133,
      "endOffset" : 145
    }, {
      "referenceID" : 23,
      "context" : "Fortunately, it turns out that all results from the Hedge setting are ready to be used here, recovering the continuous EXP algorithm [12, 17, 24] and also generalizing our new algorithms to this general setting.",
      "startOffset" : 133,
      "endOffset" : 145
    }, {
      "referenceID" : 28,
      "context" : "Boosting: (Section 4) Realizing that every Hedge algorithm can be converted into a boosting algorithm ([29]), we propose a new boosting algorithm (NH-Boost.",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 28,
      "context" : "DT is then translated into training error and margin distribution bounds that previous analysis in [29] using nonadaptive algorithms does not show.",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 7,
      "context" : "Similar concepts have widely appeared in the literature [8, 5], but unlike our work, they are not related to any minimax analysis and might be hard to interpret.",
      "startOffset" : 56,
      "endOffset" : 62
    }, {
      "referenceID" : 4,
      "context" : "Similar concepts have widely appeared in the literature [8, 5], but unlike our work, they are not related to any minimax analysis and might be hard to interpret.",
      "startOffset" : 56,
      "endOffset" : 62
    }, {
      "referenceID" : 10,
      "context" : "The existence of parameter free Hedge algorithms for unknown number of actions was shown in [11], but no concrete algorithms were given there.",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 15,
      "context" : "Boosting algorithms that ignore some examples on each round were studied in [16], where a heuristic was used to ignore examples with small weights and no theoretical guarantee is provided.",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 27,
      "context" : "For instance, binary classification via boosting can be translated into a drifting game by treating each training example as a chip (see [28] for details).",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 27,
      "context" : "A nearly optimal strategy and its analysis is originally given in [28], and a derivation by directly tackling the above minimax expression can be found in [29, chap.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 27,
      "context" : "(2) It has been shown in [28] that this upper bound on the loss is optimal in a very strong sense.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 12,
      "context" : "With the loss function L(s) being 1{s ≤ 0}, these can be further simplified and eventually give exactly the boost-by-majority algorithm [13].",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 27,
      "context" : "3 Online Learning as a Drifting Game The connection between drifting games and some specific settings of online learning has been noticed before ([28, 23]).",
      "startOffset" : 146,
      "endOffset" : 154
    }, {
      "referenceID" : 22,
      "context" : "3 Online Learning as a Drifting Game The connection between drifting games and some specific settings of online learning has been noticed before ([28, 23]).",
      "startOffset" : 146,
      "endOffset" : 154
    }, {
      "referenceID" : 13,
      "context" : "1 Algorithmic Equivalence In the Hedge setting [14], a player tries to earn as much as possible (or lose as little as possible) by cleverly spreading a fixed amount of money to bet on a set of actions on each day.",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 0,
      "context" : "action i incurs loss lt,i ∈ [0, 1]) which are revealed to the player.",
      "startOffset" : 28,
      "endOffset" : 34
    }, {
      "referenceID" : 19,
      "context" : "Here, we consider an even more general notion of regret studied in [20, 19, 10, 11], which we call ǫ-regret.",
      "startOffset" : 67,
      "endOffset" : 83
    }, {
      "referenceID" : 18,
      "context" : "Here, we consider an even more general notion of regret studied in [20, 19, 10, 11], which we call ǫ-regret.",
      "startOffset" : 67,
      "endOffset" : 83
    }, {
      "referenceID" : 9,
      "context" : "Here, we consider an even more general notion of regret studied in [20, 19, 10, 11], which we call ǫ-regret.",
      "startOffset" : 67,
      "endOffset" : 83
    }, {
      "referenceID" : 10,
      "context" : "Here, we consider an even more general notion of regret studied in [20, 19, 10, 11], which we call ǫ-regret.",
      "startOffset" : 67,
      "endOffset" : 83
    }, {
      "referenceID" : 22,
      "context" : "Doing this will lead to the exact setting discussed in [23] where a near optimal strategy is proposed using the recipe in Eq.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 22,
      "context" : "To see this, first recall that results from [23], written in our notation, state that minDR LT (DR) ≤ 1 2T ∑ T−R 2 j=0 ( T+1 j ) , which, by Hoeffding’s inequality, is upper bounded by 2 exp ( − (R+1) 2 2(T+1) )",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 22,
      "context" : "However, the algorithm proposed in [23] is not computationally efficient since the potential functions Φt(s) do not have closed forms.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 13,
      "context" : "It turns out that this will lead to the well-known exponential weights algorithm [14, 15].",
      "startOffset" : 81,
      "endOffset" : 89
    }, {
      "referenceID" : 14,
      "context" : "It turns out that this will lead to the well-known exponential weights algorithm [14, 15].",
      "startOffset" : 81,
      "endOffset" : 89
    }, {
      "referenceID" : 25,
      "context" : "More importantly, as in [26], this derivation may shed light on why this algorithm works and where it comes from, namely, a minimax analysis followed by a series of relaxations, starting from a reasonable surrogate of the 0-1 loss function.",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 8,
      "context" : "We call this the “2-norm” algorithm since it resembles the p-norm algorithm in the literature when p = 2 (see [9]).",
      "startOffset" : 110,
      "endOffset" : 113
    }, {
      "referenceID" : 9,
      "context" : "In fact, our algorithm bears a striking similarity to NormalHedge [10], the first algorithm that has this kind of adaptivity.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 21,
      "context" : "Similar potential was also proposed in recent work [22, 25] for a different setting.",
      "startOffset" : 51,
      "endOffset" : 59
    }, {
      "referenceID" : 24,
      "context" : "Similar potential was also proposed in recent work [22, 25] for a different setting.",
      "startOffset" : 51,
      "endOffset" : 59
    }, {
      "referenceID" : 9,
      "context" : "DT is more computationally efficient especially when N is very large, since it does not need a numerical search for each round; 2) our analysis is arguably simpler and more intuitive than the one in [10]; 3) as we will discuss in Section 4, NormalHedge.",
      "startOffset" : 199,
      "endOffset" : 203
    }, {
      "referenceID" : 9,
      "context" : "DT can be easily extended to deal with the more general online convex optimization problem where the number of actions is infinitely large, while it is not clear how to do that for NormalHedge by generalizing the analysis in [10].",
      "startOffset" : 225,
      "endOffset" : 229
    }, {
      "referenceID" : 5,
      "context" : "4 Generalizations and Applications Multi-armed Bandit (MAB) Problem: The only difference between Hedge (randomized version) and the non-stochastic MAB problem [6] is that on each round, after picking it, the player only sees the loss for this single action lt,it instead of the whole vector lt.",
      "startOffset" : 159,
      "endOffset" : 162
    }, {
      "referenceID" : 5,
      "context" : "Then algorithms such as EXP can be used by replacing lt with l̂t, leading to the EXP3 algorithm [6] with regret O( √ TN lnN).",
      "startOffset" : 96,
      "endOffset" : 99
    }, {
      "referenceID" : 3,
      "context" : "We conjecture, however, that there is a potential function that could recover the poly-INF algorithm [4, 5] or give its variants that achieve the optimal regret O( √ TN).",
      "startOffset" : 101,
      "endOffset" : 107
    }, {
      "referenceID" : 4,
      "context" : "We conjecture, however, that there is a potential function that could recover the poly-INF algorithm [4, 5] or give its variants that achieve the optimal regret O( √ TN).",
      "startOffset" : 101,
      "endOffset" : 107
    }, {
      "referenceID" : 0,
      "context" : "Let S ⊂ R be a compact convex set, and F be a set of convex functions with range [0, 1] on S.",
      "startOffset" : 81,
      "endOffset" : 87
    }, {
      "referenceID" : 29,
      "context" : "There are two general approaches to OCO: one builds on convex optimization theory [30], and the other generalizes EXP to a continuous space [12, 24].",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 11,
      "context" : "There are two general approaches to OCO: one builds on convex optimization theory [30], and the other generalizes EXP to a continuous space [12, 24].",
      "startOffset" : 140,
      "endOffset" : 148
    }, {
      "referenceID" : 23,
      "context" : "There are two general approaches to OCO: one builds on convex optimization theory [30], and the other generalizes EXP to a continuous space [12, 24].",
      "startOffset" : 140,
      "endOffset" : 148
    }, {
      "referenceID" : 16,
      "context" : "Nevertheless, this is addressed by Theorem 6 using similar techniques in [17], giving the usual O( √ dT lnT ) regret bound.",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 13,
      "context" : "Applications to Boosting: There is a deep and well-known connection between Hedge and boosting [14, 29].",
      "startOffset" : 95,
      "endOffset" : 103
    }, {
      "referenceID" : 28,
      "context" : "Applications to Boosting: There is a deep and well-known connection between Hedge and boosting [14, 29].",
      "startOffset" : 95,
      "endOffset" : 103
    }, {
      "referenceID" : 28,
      "context" : "DT converges to the optimal margin 2γ; this is known not to be true for AdaBoost (see [29]).",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 0,
      "context" : "References [1] Jacob Abernethy, Peter L.",
      "startOffset" : 11,
      "endOffset" : 14
    }, {
      "referenceID" : 1,
      "context" : "[2] Jacob Abernethy and Manfred K.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "[3] Jacob Abernethy and Manfred K.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 3,
      "context" : "[4] Jean-Yves Audibert and Sébastien Bubeck.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5] Jean-Yves Audibert, Sébastien Bubeck, and Gábor Lugosi.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "[6] Peter Auer, Nicolò Cesa-Bianchi, Yoav Freund, and Robert E.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "[7] Nicolò Cesa-Bianchi, Yoav Freund, David Haussler, David P.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "[8] Nicolò Cesa-Bianchi and Gábor Lugosi.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "[9] Nicolò Cesa-Bianchi and Gábor Lugosi.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 9,
      "context" : "[10] Kamalika Chaudhuri, Yoav Freund, and Daniel Hsu.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[11] Alexey Chernov and Vladimir Vovk.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "[12] Thomas M.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "[13] Yoav Freund.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 13,
      "context" : "[14] Yoav Freund and Robert E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 14,
      "context" : "[15] Yoav Freund and Robert E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 15,
      "context" : "[16] Jerome Friedman, Trevor Hastie, and Robert Tibshirani.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "[17] Elad Hazan, Amit Agarwal, and Satyen Kale.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 17,
      "context" : "[18] Adam Kalai and Santosh Vempala.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "[19] Robert Kleinberg.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "[20] Robert David Kleinberg.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "[21] Haipeng Luo and Robert E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 21,
      "context" : "[22] H Brendan McMahan and Francesco Orabona.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 22,
      "context" : "[23] Indraneel Mukherjee and Robert E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "[24] Hariharan Narayanan and Alexander Rakhlin.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 24,
      "context" : "[25] Francesco Orabona.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 25,
      "context" : "[26] Alexander Rakhlin, Ohad Shamir, and Karthik Sridharan.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 26,
      "context" : "[27] Lev Reyzin and Robert E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 27,
      "context" : "[28] Robert E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 28,
      "context" : "[29] Robert E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 29,
      "context" : "[30] Shai Shalev-Shwartz.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "For Algorithm 2, zt,i lies in B = [−1, 1] since lt,i ∈ [0, 1], and direct computation showspt·zt = 0 ≥ β(= 0) and |zt,i−zt,j| = |lt,i−lt,j| ≤ 1 for all i and j.",
      "startOffset" : 55,
      "endOffset" : 61
    }, {
      "referenceID" : 29,
      "context" : "The player’s strategy is thus pt,i ∝ exp(−η ∑t−1 τ=1 l̂τ,i) (recall l̂t,i = 1{i = it} · lt,it/pt,it is the estimated loss), which is exactly the same as EXP3 (in fact a simplified version of the original EXP3, see for example [30]).",
      "startOffset" : 226,
      "endOffset" : 230
    }, {
      "referenceID" : 13,
      "context" : "G Experiments in a Boosting Setting We conducted experiments to compare the performance of three boosting algorithms for binary classification: AdaBoost [14], NH-Boost (Algorithm 7) and NH-Boost.",
      "startOffset" : 153,
      "endOffset" : 157
    }, {
      "referenceID" : 26,
      "context" : "Some datasets are preprocessed according to [27].",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 28,
      "context" : "The weak learning algorithm is a simple (exhaustive) decision stump (see for instance [29]).",
      "startOffset" : 86,
      "endOffset" : 90
    } ],
    "year" : 2014,
    "abstractText" : "We provide a general mechanism to design online learning algorithms based on a minimax analysis within a drifting-games framework. Different online learning settings (Hedge, multi-armed bandit problems and online convex optimization) are studied by converting into various kinds of drifting games. The original minimax analysis for drifting games is then used and generalized by applying a series of relaxations, starting from choosing a convex surrogate of the 0-1 loss function. With different choices of surrogates, we not only recover existing algorithms, but also propose new algorithms that are totally parameter-free and enjoy other useful properties. Moreover, our drifting-games framework naturally allows us to study high probability bounds without resorting to any concentration results, and also a generalized notion of regret that measures how good the algorithm is compared to all but the top small fraction of candidates. Finally, we translate our new Hedge algorithm into a new adaptive boosting algorithm that is computationally faster as shown in experiments, since it ignores a large number of examples on each round.",
    "creator" : "LaTeX with hyperref package"
  }
}