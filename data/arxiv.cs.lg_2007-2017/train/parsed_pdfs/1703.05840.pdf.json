{
  "name" : "1703.05840.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Conditional Accelerated Lazy Stochastic Gradient Descent",
    "authors" : [ "Guanghui Lan", "Sebastian Pokutta", "Yi Zhou", "Daniel Zink" ],
    "emails" : [ "george.lan@isye.gatech.edu", "sebastian.pokutta@isye.gatech.edu", "yizhou@gatech.edu", "daniel.zink@gatech.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ε2 )\nimproving over the projection-free, Online Frank-Wolfe based stochastic gradient descent of Hazan and Kale [2012] with convergence rate O( 1\nε4 )."
    }, {
      "heading" : "1 Introduction",
      "text" : "The conditional gradient method (also known as: Frank-Wolfe algorithm) proposed in Frank and Wolfe [1956], gained much popularity in recent years due to its simple projection-free scheme and fast practical convergence rates. We consider the basic convex programming (CP) problem\nf∗ := min x∈X f(x), (1)\nwhere X ⊆ Rn is a closed convex set and f : X → R is a smooth convex function such that ∃L > 0,\n‖f ′(x)− f ′(y)‖∗ ≤ L‖x− y‖, ∀x, y ∈ X. (2)\nThe classic conditional gradient (CG) method solves (1) iteratively by minimizing a series of linear approximations of f over the feasible set X. More specifically, given xk−1 ∈ X at the k-th iteration, it updates xk according to the following steps:\n1) Call the first-order (FO) oracle to compute (f(xk−1), f ′(xk−1)) and set pk = f ′(xk−1).\n2) Call the linear optimization (LO) oracle to compute\nyk ∈ argminx∈X〈pk, x〉. (3)\n3) Set xk = (1− λk)xk−1 + λkyk for some λk ∈ [0, 1].\nar X\niv :1\n70 3.\n05 84\n0v 1\n[ cs\n.L G\n] 1\nCompared to most other first-order methods, such as, gradient descent algorithms and accelerated gradient algorithms Nesterov [1983, 2004], the CG method is computationally cheaper in some cases, since it only requires the solution of a linear optimization subproblem (3) rather than an often costly projection onto the feasible region X.\nThere has been extensive and fruitful research on the general class of linear-optimization-based convex programming (LCP) methods (which covers the CG method and its variants) and their applications in machine learning (e.g., Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3). Furthermore, as shown in Jaggi [2013] and Lan [2013], the total number of iterations for the LCP methods to find an -solution of (1) (i.e., a point x̄ ∈ X, s.t. f(x̄) − f∗ ≤ ) cannot be smaller than O(1/ ), which is not improvable even when the objective function f is strongly convex. Improved complexity results can only be obtained under stronger assumptions on the LO oracle or the feasible set (see, e.g., Garber and Hazan [2013], Lan [2013]). However, the O(1/ ) bound does not preclude the existence of more efficient LCP algorithms for solving (1). Lan and Zhou [2014] proposed a class of conditional gradient sliding methods (CGS), which significantly improve the complexity bounds in terms of the number of gradient evaluations while maintaining optimal complexity bounds for the LO oracle calls required by the LCP methods.\nInspired by Braun et al. [2016] and Lan and Zhou [2014], in this paper we focus on a class of modified LCP methods that require only improving solutions for a certain separation problem rather than solving the linear optimization subproblem (3) explicitly through LO oracle calls while simultaneously minimizing the number of gradient evaluations when performing weak separation over the feasible set X. At first these two objectives seem to be incompatible as Braun et al. [2016] gives up the dual guarantee to simplify the oracle, while the dual guarantee of CG iterations is at the core of the analysis in Lan and Zhou [2014]. We overcome this impasse by carefully modifying both techniques.\nIt should be mentioned that Hazan and Kale [2012] proposed the online Frank-Wolfe (OFW) algorithm, which obtains O(1/ 4) rate of convergence for stochastic problems. Indeed, if we consider the objective function f(x) := E[F (x, ξ)] for stochastic optimization, the OFW method can be applied to solve (1) by viewing the iteratively observed function ft as the current realization of the true objective function f , i.e., ft(·) = F (·, ξt). Without re-evaluating the (sub)gradients at the updated points, the OFW obtains O(T−1/4) bound for any (smooth or non-smooth) objective functions (see Theorem 4.4 in Hazan and Kale [2012]), which implies O(1/ 4) rate of convergence in terms of the number of (sub)gradient evaluations for stochastic optimization. However, we can show that our proposed algorithm obtains O(1/ 2) rate of convergence for stochastic problems, which is much better than the convergence rate of the OFW method. We would like to stress that the stochastic optimization bound in Hazan and Kale [2012, Theorem 4.1] which gives a guarantee\nof O(1/ 2), requires to re-evaluate all gradients at the current iterate and as such the number of gradient evaluations required grows quadratically in t.\nContributions Our main contributions can be briefly summarized as follows. We consider stochastic smooth optimization, where we have only access to unbiased estimators of the gradients of f via a stochastic first-order (SFO) oracle. By incorporating a modified LCG procedure [Braun et al., 2016] into a modified CGS method [Lan and Zhou, 2014] we obtain a new conditional accelerated lazy stochastic gradient descent algorithm (CALSGD) and we show that the number of calls to the weak separation oracle can be optimally bounded by O(1/ ), while the optimal bound of O(1/ 2) on the total number of calls to the SFO oracle can be maintained. In addition, if the exact gradients of f can be accessed by an FO oracle, the latter bound can be significantly improved to O(1/ √ ). In order to achieve the above we will present a modified lazy conditional gradient method, and show that the total number of iterations (or calls to the weak separation oracle) performed by it can be bounded by O(1/ ) under a stronger termination criterion, i.e., the primal-dual gap function.\nWe also consider strongly convex and smooth functions and show that without enforcing any stronger assumptions on the weak separation oracle or the feasible set X, the total number of calls to the FO (resp., SFO) oracle can be optimally bounded by O(log 1/ ) (resp., O(1/ )) for variants of the proposed method to solve deterministic (resp., stochastic) strongly convex and smooth problems. Furthermore, we also generalize the proposed algorithms to solve an important class of non-smooth convex programming problems with a saddle point structure. By adaptively approximating the original non-smooth problem via a class of smooth functions, we are able to show that the deterministic version of CALSGD can obtain an -solution within O(1/ ) number of linear operator evaluations and O(1/ 2) number of calls to the weak separation oracle, respectively. The former bound will increase to O(1/ 2) for non-smooth stochastic optimization.\nFinally, we demonstrate practical speed ups of CALSGD through preliminary numerical experiments for the video co-localization problem, the structured regression problem and quadratic optimization over the standard spectrahedron; an extensive study is beyond the scope of this paper and left for future work. In all cases we report a substantial improvements in performance."
    }, {
      "heading" : "1.1 Notation and terminology",
      "text" : "Let X ⊆ Rn be a convex compact set, and ‖ · ‖X be the norm associated with the inner product in Rn. For the sake of simplicity, we often skip the subscript in the norm ‖ · ‖X . We define the diameter of the set X as\nDX ≡ DX,‖·‖ := max x,y∈X ‖x− y‖. (4)\nFor a given norm ‖ · ‖, we denote its conjugate by ‖s‖∗ = max‖x‖≤1〈s, x〉. For a linear operator A : Rn → Rm, we use ‖A‖ to denote its operator norm defined as ‖A‖ := max‖x‖≤1 ‖Ax‖. Let f : X → R be a convex function, we denote its linear approximation at x by\nlf (x; y) := f(x) + 〈f ′(x), y − x〉. (5)\nClearly, if f satisfies (2), then\nf(y) ≤ lf (x; y) + L2 ‖y − x‖ 2, ∀x, y ∈ X. (6)\nNotice that the constant L in (2) and (6) depends on ‖ · ‖. Moreover, we say f is smooth with curvature at most C, if\nf(y) ≤ lf (x; y) + C2 , ∀ x, y ∈ X. (7)\nIt is clear that if X is bounded, we have C ≤ LD2X . In the following we also use R++ to denote the set of strictly positive reals."
    }, {
      "heading" : "2 Conditional Accelerated Lazy Stochastic Gradient Descent",
      "text" : "We now present a new method for stochastic gradient descent that is based on the stochastic conditional gradient sliding (SCGS) method and the parameter-free lazy conditional gradient (LCG) procedure from Section 2.2, which we refer to as the Conditional Accelerated Lazy Stochastic Gradient Descent (CALSGD) method.\nWe consider the stochastic optimization problem:\nf∗ := min x∈X {f(x) = Eξ[F (x, ξ)]}, (8)\nwhere f(x) is a smooth convex function satisfying (2)."
    }, {
      "heading" : "2.1 The algorithm",
      "text" : "Throughout this section, we assume that there exists a stochastic first-order (SFO) oracle, which for a search point zk ∈ X outputs a stochastic gradient F ′(zk, ξk), s.t.\nE [F ′(zk, ξk)] = f ′(zk), (9) E [ ‖F ′(zk, ξk)− f ′(zk)‖2∗ ] ≤ σ2. (10)\nIf σ = 0, the stochastic gradient F ′(zk, ξk) is the exact gradient at point zk, i.e., F ′(zk, ξk) = f ′(zk). Our algorithmic framework is inspired by the SCGS method by Lan and Zhou [2014]. However, instead of applying the classic CG method to solve the projection subproblem appearing in the accelerated gradient (AG) method, the CALSGD method utilizes a modified parameter-free LCG algorithm (see Section 2.2) to approximately solve the subproblem ψ(x) defined in (16) and skips the computations of the stochastic gradient F ′(z, ξ) from time to time when performing weak separation over the feasible region X. The main advantages of our method are that it does not solve a traditional projection problem and achieves the optimal bounds on the number of calls to the SFO and LOsepX oracles (see Oracle 1 in Subsection 2.2) for solving problem (1)-(8). To the authors’ best knowledge, no such algorithms have been developed before in the literature; we present the algorithm below in Algorithm 1.\nAlgorithm 1 Conditional Accelerated Lazy Stochastic Gradient Descent (CALSGD) Input: Initial point x0 ∈ X, iteration limit N , and weak separation oracle accuracy α ≥ 1. Let βk ∈ R++, γk ∈ [0, 1], and ηk ∈ R+, k = 1, 2, . . ., be given and set y0 = x0. for k = 1, 2, . . . , N do\nzk = (1− γk)yk−1 + γkxk−1, (11)\ngk = 1 Bk ∑Bk j=1F ′(zk, ξk,j), (12) xk = LCG(gk, βk, xk−1, α, ηk), (13) yk = (1− γk)yk−1 + γkxk, (14)\nwhere F ′(zk, ξk,j), j = 1, . . . , Bk, are stochastic gradients computed by the SFO at zk. end for Output: yN .\nWe hasten to make some observations about the CALSGD method. Firstly, we apply mini-batches to estimate the gradient at point zk, where the parameter {Bk} denotes the batch sizes used to compute gk. It can be easily seen from (9), (10), and (12) that\nE[gk − f ′(zk)] = 0 and E[‖gk − f ′(zk)‖2∗] ≤ σ 2 Bk , (15)\nand hence gk is an unbiased estimator of f ′(zk). In fact, letting SBk = ∑Bk j=1(F\n′(zk, ξk,j)− f ′(zk)), from (9) and (10), by induction, we have\nE [ ‖SBk‖2∗ ] = E [ ‖SBk−1 + F ′(zk, ξk,Bk)− f ′(zk)‖2∗ ] = E [ ‖SBk−1‖2∗ + ‖F ′(zk, ξk,Bk)− f ′(zk)‖2∗ + 2〈SBk−1, F ′(zk, ξk,Bk)− f ′(zk)〉\n] = E [ ‖SBk−1‖2∗ ] + E [ ‖F ′(zk, ξk,Bk)− f ′(zk)‖2∗\n] = ∑Bk j=1E [ ‖F ′(zk, ξk,j)− f ′(zk)‖2∗ ] ≤ Bkσ2,\nwhich together with the fact that gk − f ′(zk) = 1Bk ∑Bk j=1 [F\n′(zk, ξk,j)− f ′(zk)] = 1BkSBk , implies the second relationship in (15).\nSecondly, in view of the SCGS method in Lan and Zhou [2014], xk obtained in (13) should be an approximate solution to the gradient sliding subproblem\nmin x∈X\n{ ψk(x) := 〈gk, x〉+ βk2 ‖x− xk−1‖ 2 } , (16)\nsuch that for some ηk ≥ 0 we have\n〈ψ′k(xk), xk − x〉 = 〈gk + βk(xk − xk−1), xk − x〉 ≤ ηk, (17)\nfor all x ∈ X. If we solve the subproblem (16) exactly (i.e., ηk = 0), then CALSGD will reduce to the accelerated stochastic approximation method by Lan [2009, 2012]. However, by employing the LCG procedure (see Procedure 1 in Subsection 2.2), we only need to use a weak separation oracle, but still maintaining the optimal bounds on stochastic first-order oracle as in Lan [2009, 2012], Lan and Zhou [2014].\nThirdly, observe that the CALSGD method so far is conceptual only as we have not yet specified the LCG procedure and the parameters {Bk}, {βk}, {γk}, and {ηk}. We will come back to this issue after introducing the LCG procedure and establishing its main convergence properties."
    }, {
      "heading" : "2.2 The parameter-free lazy conditional gradient procedure",
      "text" : "The classical CG method is a well-known projection-free algorithm, which requires only the solution of a linear optimization subproblem (3) rather than the projection over X per iteration. Therefore, it has computational advantages over many other first-order methods when projection over X is costly. The LCG procedure presented in this subsection, a modification of the vanilla LCG method in Braun et al. [2016], goes several steps further than CG and even vanilla LCG method. Firstly, it replaces LO oracle by a weaker separation oracle LOsep, which is no harder than linear optimization and often much simpler. Secondly, it uses a stronger termination criterion, the Frank-Wolfe gap (cf. (18)), than vanilla LCG method. Finally, it maintains the same order of convergence rate as the CG and the vanilla LCG method.\nWe present the LOsep oracle in Oracle 1 below.\nOracle 1 Weak Separation Oracle LOsepP (c, x,Φ, α) Input: c ∈ Rn linear objective, x ∈ P point, α ≥ 1 accuracy, Φ > 0 objective value; Output: y ∈ P vertex with either (1) cT (x− y) > Φ/α, or (2) y = argmaxy∈P cT (x− z) ≤ Φ.\nObserve that the oracle has two output modes. In particular, Oracle 1 first verifies whether there exists an improving point y ∈ P with the required guarantee and if so it outputs this point, which we refer it as a positive call. If no such point exists the oracle certifies this by providing the maximizer y, which then also provides a new duality gap. We refer to this case as a negative call. The computational advantages of this oracle are that it can reuse previously seen solutions y if they satisfy the improvement condition and even if LO oracle has to be called, the optimization can be terminated early once the improvement condition is satisfied. Finally, the parameter α allows to only approximately satisfy the improvement condition making separation even easier; in our applications we set the parameter α slightly larger than 1.\nWe present the LCG procedure based on Braun et al. [2016] below. We adapted the parameterfree version to remove any dependence on hard to estimate parameters. For any smooth convex function φ, we define its duality gap as\ngapφ,X(x) ≡ gapφ(x) := max y∈X ∇φ(x)T (x− y). (18)\nClearly, by convexity the duality gap is an upper bound on f(x) − f(x∗). Given any accuracy parameter η ≥ 0, the LCG procedure solves minx∈X φ(x) approximately with accuracy η, i.e., it outputs a point ū ∈ X, s.t. gapφ(ū) ≤ η.\nProcedure 1 Parameter-free Lazy Conditional Gradients (LCG) procedure Input: access to gradients of smooth convex function φ, u1 ∈ X vertex, LOsepX weak linear\nseparation oracle, accuracy α ≥ 1, duality gap bound η Output: ū ∈ X with bounded duality gap, i.e., gapφ(ū) ≤ η 1: Φ0 ← maxu∈X ∇φ(u1)T (u1 − u) 2: for t = 1 to T − 1 do 3: vt ← LOsepX(∇φ(ut), xt,Φt−1, α) 4: if not ∇φ(ut)T (ut − vt) > Φt−1/α then 5: if Φt−1 = η then 6: return ū = ut 7: end if 8: else 9: Φt ← max { Φt−1 2 , η }\n{Update Φt} 10: end if 11: λt ← argmin φ((1− λt)ut + λtvt) 12: ut+1 ← (1− λt)ut + λtvt 13: end for\nThe LCG procedure is a parameter-free algorithm. Note that while line search can be expensive in general, for our subproblems, function evaluation is very cheap. The algorithm needs only one LO oracle call to estimate the initial functional value gap at Line 1. Alternatively, this can be also done approximately via binary search with LOsep. The algorithm maintains a sequence, {Φt}, that provides valid upper bounds for the functional value gap at the current iterate, i.e., φ(ut)−φ∗ ≤ 2Φt−1 (see Theorem 5.1 of Braun et al. [2016]), and it halves the value of Φt only when the current oracle call is negative. Finally, our LCG procedure exits at Line 5 whenever LOsepX returns a negative call and Φt−1 = η, which ensures that gapφ(ū) = maxy∈X〈∇φ(ū), ū− y〉 ≤ η.\nTheorem 2.1 below provides a bound for the total number of iterations (or calls to the LOsepX oracle) that the LCG procedure requires to generate a point ū ∈ X with gapφ(ū) ≤ η. Theorem 2.1. Procedure 1 returns a point ū ∈ X such that the duality gap at point ū is bounded by η, i.e., gapφ(ū) ≤ η. Furthermore, the total number of iterations T (and hence LOsepX calls) performed by Procedure 1 is at most\nT ≤\n{ κ+\n8α2Cφ η + 2, η < αCφ; κ+ 4α+ 4α2Cφ η + 2, η ≥ αCφ,\n(19)\nwith κ := 4α ⌈ log Φ0αCφ ⌉ + log Φ0η .\nProof. From the observations above, it is clear that the duality gap at the output point ū is bounded by η.\nAlso observe that the procedure calls LOsepX once per iteration. In order to demonstrate the bound in (19), we split the LCG procedure into two phases, and bound the number of iterations separately for each phase. Let Cφ denote the curvature of the smooth convex function φ.\nWe say Procedure 1 is in the first phase whenever Φt−1 > η. In view of Theorem 5.1 in Braun et al. [2016], it is clear that the number of iterations in the first phase can be bounded as\nT1 ≤ 4α ⌈ log Φ0αCφ ⌉ + 4α2Cφ η + log Φ0 η .\nProcedure 1 enters the second phase when Φt−1 ≤ η. Again with the argumentation in Theorem 5.1 in Braun et al. [2016], we obtain that the total number of positive calls in this phase can be bounded by 4α\n2Cφ η , if η < αCφ, or by 4α if η ≥ αCφ. Moreover, the procedure exits whenever the\ncurrent LOsepX oracle call is a negative call. Hence, the number of iterations in the second phase can be bounded by\nT2 ≤\n{ 4α2Cφ η + 1, η < αCφ;\n4α+ 1, η ≥ αCφ. Thus, our bound in (19) can be obtained from the above two bounds plus one more LO oracle call at Line 1."
    }, {
      "heading" : "2.3 The convergence properties of CALSGD",
      "text" : "This subsection is devoted to establishing the main convergence properties of the CALSGD method. Since the algorithm is stochastic, we will establish the convergence results for finding a stochastic -solution, i.e., a point x̄ ∈ X s.t. E[f(x̄)− f(x∗)] ≤ . We first state a simple technical result from Lan and Zhou [2014, Lemma 2.1] that we will use.\nLemma 2.2. Let wt ∈ (0, 1], t = 1, 2, . . ., be given. Also let us denote\nWt :=\n{ 1 t = 1\n(1− wt)Wt−1 t ≥ 2.\nSuppose that Wt > 0 for all t ≥ 2 and that the sequence {δt}t≥0 satisfies\nδt ≤ (1− wt)δt−1 +Bt, t = 1, 2, . . . .\nThen for any 1 ≤ l ≤ k, we have δk ≤Wk (\n1−wl Wl δl−1 + ∑k i=l Bi Wi ) .\nTheorem 2.3 describes the main convergence properties of the CALSGD method (cf. Algorithm 1).\nTheorem 2.3. Let Γk be defined as follows,\nΓk :=\n{ 1 k = 1\nΓk−1(1− γk) k ≥ 2. (20)\nSuppose that {βk} and {γk} in the CALSGD algorithm satisfy\nγ1 = 1 and Lγk ≤ βk, k ≥ 1. (21)\na) If βkγk Γk ≥ βk−1γk−1Γk−1 , k ≥ 2, (22)\nthen under assumptions (9) and (10), we have\nE [f(yk)− f(x∗)] ≤ βkγk2 D 2 X + Γk k∑ i=1 [ ηiγi Γi + γiσ 2 2ΓiBi(βi−Lγi) ] , (23)\nwhere x∗ is an arbitrary optimal solution of (8) and DX is defined in (4).\nb) If βkγk Γk ≤ βk−1γk−1Γk−1 , k ≥ 2, (24)\n(rather than (22)) is satisfied, then the result in part a) holds by replacing βkγkD2X with β1Γk‖x0 − x∗‖2 in the first term of the RHS of (23).\nc) Under the assumptions in part a) or b), the number of inner iterations performed at the k-th outer iterations is bounded by\nTk =\n{ κ+ 8α2βkD 2 X\nηk + 2, ηk < αβkD 2 X ;\nκ+ 4α+ 4α2βkD 2 X\nηk + 2, ηk ≥ αβkD2X ,\n(25)\nwith κ := 4α ⌈ log\nΦk0 αβkD2X\n⌉ + log\nΦk0 ηk .\nProof. Let us denote δk,j = F ′(zk, ξk,j) − f ′(zk) and δk ≡ gk − f ′(zk) = ∑Bk j=1 δk,j/Bk. We first show part a). In view of (6), (11) and (14), we have\nf(yk) ≤ lf (zk; yk) + L2 ‖yk − zk‖ 2\n= (1− γk)lf (zk; yk−1) + γklf (zk;xk) + Lγ 2 k 2 ‖xk − xk−1‖ 2 = (1− γk)f(yk−1) + γklf (zk;xk) + βkγk2 ‖xk − xk−1‖ 2 − γk(βk−Lγk)2 ‖xk − xk−1‖ 2,\nwhere the last inequality follows from the convexity of f(·). Also observe that by (17), we have\n〈gk + βk(xk − xk−1), xk − x〉 ≤ ηk, ∀x ∈ X,\nwhich implies that\n1 2‖xk − xk−1‖ 2 = 12‖xk−1 − x‖ 2 − 12‖xk − x‖ 2 − 〈xk−1 − xk, xk − x〉 ≤ 12‖xk−1 − x‖ 2 − 12‖xk − x‖ 2 + 1βk 〈gk, x− xk〉+ ηk βk .\nCombing the above two relations, we have\nf(yk) ≤ (1− γk)f(yk−1) + γklf (zk, xk) + γk〈gk, x− xk〉 + βkγk2 [ ‖xk−1 − x‖2 − ‖xk − x‖2 ] + ηkγk − γk(βk−Lγk)2 ‖xk − xk−1‖ 2\n= (1− γk)f(yk−1) + γklf (zk, x) + γk〈δk, x− xk〉 + βkγk2 [ ‖xk−1 − x‖2 − ‖xk − x‖2 ] + ηkγk − γk(βk−Lγk)2 ‖xk − xk−1‖ 2.\nUsing the above inequality and the fact that\n〈δk, x− xk〉 − (βk−Lγk)2 ‖xk − xk−1‖ 2 = 〈δk, x− xk−1〉+ 〈δk, xk−1 − xk〉 − (βk−Lγk)2 ‖xk − xk−1‖ 2\n≤ 〈δk, x− xk−1〉+ ‖δk‖ 2 ∗\n2(βk−Lγk) ,\nwe obtain for all x ∈ X,\nf(yk) ≤ (1− γk)f(yk−1) + γkf(x) + ηkγk + βkγk2 [ ‖xk−1 − x‖2 − ‖xk − x‖2 ] + γk〈δk, x− xk−1〉+ γk‖δk‖ 2 ∗\n2(βk−Lγk) . (26)\nSubtracting f(x) from both sides of (26) and applying Lemma 2.2, we have\nf(yk)− f(x) ≤ Γk(1− γ1) [f(y0)− f(x)] + Γk ∑k i=1 ηiγi Γi + Γk ∑k i=1 βiγi 2Γi [ ‖xk−1 − x‖2 − ‖xk − x‖2 ] + Γk ∑k i=1 γi Γi [ 〈δi, x− xi−1〉+ ‖δi‖ 2 ∗ 2(βi−Lγi) ] . (27)\nAlso observe that∑k i=1 βiγi Γi (‖xi−1 − x‖2 − ‖xi − x‖2)\n= β1γ1Γ1 ‖x0 − x‖ 2 − βkγkΓk ‖xk − x‖ 2 + ∑k i=2 ( βiγi Γi − βi−1γi−1Γi−1 ) ‖xi−1 − x‖2\n≤ β1γ1Γ1 D 2 X + ∑k i=2 ( βiγi Γi − βi−1γi−1Γi−1 ) D2X\n= βkγkΓk D 2 X ,\nwhere the inequality follows from the third assumption in (22) and the definition of DX in (4). Therefore, from the above two relations and the fact that γ1 = 1, we can conclude that\nf(yk)− f(x) ≤ βkγk2 D 2 X + Γk ∑k i=1 γi Γi [ ηi + ‖δi‖2∗ 2(βi−Lγi) + ∑Bi j=1B −1 i 〈δi,j , x− xi−1〉 ] . (28)\nNote that by our assumptions on SFO, the random variables δi,j are independent of the search point xi−1 and hence E[〈δi,j , x∗ − xi−1〉] = 0. In addition, relation (15) implies that E[‖δi‖2∗] ≤ σ2/Bi. Using the previous two observations and taking expectation on both sides of (28) (with x = x∗) we obtain (23).\nSimilarly, Part b) follows from (27), the assumption that γ1 = 1, and the fact that∑k i=1 βiγi Γi (‖xi−1 − x‖2 − ‖xi − x‖2) ≤ β1γ1Γ1 ‖x0 − x‖ 2 − βkγkΓk ‖xk − x‖ 2 ≤ β1‖x0 − x‖2, (29)\ndue to the assumptions in (21) and (24). Let Φk0 denote the initial bound obtained in Line 1 of the LCG procedure at the k-th outer iteration. The result in Part c) follows immediately from (19) and the fact that Cψk = βkD2X .\nNow we provide two different sets of parameters {βk}, {γk}, {ηk}, and {Bk}, which lead to optimal complexity bounds on the number of calls to the SFO and LOsepX oracles.\nCorollary 2.4. Suppose that {βk}, {γk}, {ηk}, and {Bk} in the CALSGD method are set to\nβk = 4L k+2 , γk = 3 k+2 , ηk = LD2X k(k+1) , and Bk =\n⌈ σ2(k+2)3\nL2D2X\n⌉ , k ≥ 1, (30)\nand we assume ‖f ′(x∗)‖ is bounded for any optimal solution x∗ of (8). Under assumptions (9) and (10), we have\nE [f(yk)− f(x∗)] ≤ 6LD 2 X (k+2)2 + 9LD2X 2(k+1)(k+2) , ∀k ≥ 1. (31)\nAs a consequence, the total number of calls to the SFO and LOsepX oracles performed by the CALSGD method for finding a stochastic -solution of (1), respectively, can be bounded by\nO {√ LD2X + σ2D2X 2 } , (32)\nand O {√ LD2X log\nLD2X Λ + LD2X\n} with probability 1− Λ. (33)\nProof. It can be easily seen from (30) that (21) holds. Also note that by (30), we have\nΓk = 6 k(k+1)(k+2) , (34)\nand hence βkγk Γk = 2Lk(k+1)k+2 ,\nwhich implies that (22) holds. It can also be easily checked from (34) and (30) that∑k i=1 ηiγi Γi ≤ kLD 2 X 2 , ∑k i=1 γi ΓiBi(βi−Lγi) ≤ kLD2X 2σ2 .\nUsing the bound in (23), we obtain (31), which implies that the total number of outer iterations N can be bounded by O (√ LD2X/ ) under the assumptions (9) and (10). The bound in (32) then immediately follows from this observation and the fact that the number of calls to the SFO oracle is bounded by ∑N\nk=1Bk ≤ ∑N k=1 σ2(k+2)3\nL2D2X +N ≤ σ\n2(N+3)4 4L2D2X +N.\nWe now provide a good estimation for Φk0 (cf. Line 1 in LCG procedure) at the k-th outer iteration. In view of the definition of Φk0 and ψ(·) (cf. (16)), we have,\nΦk0 = 〈ψ′k(xk−1), xk−1 − x〉 = 〈gk, xk−1 − x〉.\nMoreover, let Ak := ‖gk − f ′(zk)‖∗ ≥ √ Nσ2\nΛBk , by Chebyshev’s inequality and (15), we obtain,\nProb{Ak} ≤ E[‖gk−f ′(zk)|2∗]ΛBk Nσ2 ≤ Λ N , ∀Λ < 1, k ≥ 1,\nwhich implies that Prob{ ⋂N k=1 Āk} ≤ 1− Λ. Hence, by Cauchy-Schwarz and triangle inequalities, we have with probability 1− Λ,\nΦk0 = 〈gk − f ′(zk), xk−1 − x〉+ 〈f ′(zk), xk−1 − x〉} ≤ (√ Nσ2\nΛBk + ‖f ′(zk)− f ′(x∗)‖∗ + ‖f ′(x∗)‖∗\n) DX\n≤ (√\nN Λk3 + 1 ) LD2X + ‖f ′(x∗)‖∗DX , (35)\nwhere the last inequality follows from (6) and (30).\nNote that we always have ηk < αβkD2X . Therefore, it follows from the bound in (25), (30), and (35) that the total number of inner iterations can be bounded by∑N\nk=1Tk ≤ ∑N k=1 [ 4α ( log Φk0 αβkD2X + 1 ) + log Φk0 ηk + 8α2βkD 2 X ηk + 2 ]\n≤ N∑ k=1 [ 5α log ( 2k2 (√ N Λk3 + 1 + ‖f ′(x∗)‖∗ LDX )) + 32α2k ] + (4α+ 2)N\n= O ( N log N 2\nΛ +N 2 +N\n) ,\nwhich implies that our bound in (33).\nWe now provide a slightly improved complexity bound on the number of calls to the SFO oracle which depends on the distance from the initial point to the set of optimal solutions, rather than the diameter DX . In order to obtain this improvement, we need to estimate D0 ≥ ‖x0 − x∗‖ and to fix the number of iterations N in advance. This result will play an important role for the analysis of the CALSGD method to solve strongly convex problems (see Section 4.1).\nCorollary 2.5. Suppose that there exists an estimate D0 s.t. ‖x0 − x∗‖ ≤ D0 ≤ DX . Also assume that the outer iteration limit N ≥ 1 is given. If\nβk = 3L k , γk = 2 k+1 , ηk = 2LD20 Nk , and Bk =\n⌈ σ2N(k+1)2\nL2D20\n⌉ , k ≥ 1. (36)\nUnder assumptions (9) and (10),\nE [f(yN )− f(x∗)] ≤ 8LD 2 0 N(N+1) , ∀N ≥ 1.\nAs a consequence, the total number of calls to the SFO and LOsepX oracles performed by the CALSGD method for finding a stochastic -solution of (1), respectively, can be bounded by\nO {√ LD20 + σ2D20 2 } , (37)\nand (33).\nProof. The proof is similar to Corollary 2.4, and hence details are skipped.\nIt should be pointed out that the complexity bound for the number of calls to the LOsep oracle in (33) is established with probability 1− Λ. However, the probability parameter Λ only appears in the non-dominant term."
    }, {
      "heading" : "3 Deterministic CALSGD",
      "text" : "Our goal in this section is to present a deterministic version of CALSGD, which we refer to as CALGD. Instead of calling the SFO oracle to compute the stochastic gradients, we assume that we have access to the exact gradients of f . Therefore, the CALGD method calls the FO oracle to obtain the exact gradients f ′(zk) at the k-th outer iteration.\nThe CALGD method is formally described as follows.\nAlgorithm 2 The conditional accelerated lazy gradient descent (CALGD) method This algorithm is the same as Algorithm 1 except that steps (12) and (13) are replaced by\nxk = LCG(f ′(zk), βk, xk−1, α, ηk). (38)\nSimilarly to the stochastic case, we can easily see that xk obtained in (38) is an approximate solution for the gradient sliding subproblem\nmin x∈X\n{ ψk(x) := 〈f ′(zk), x〉+\nβk 2 ‖x− xk−1‖2\n} (39)\nsuch that for all x ∈ X\n〈ψ′k(xk), xk − x〉 = 〈f ′(zk) + βk(xk − xk−1), xk − x〉 ≤ ηk, (40)\nfor some ηk ≥ 0. Theorem 3.1 describes the main convergence properties of the above CALGD method.\nTheorem 3.1. Let Γk be defined as in (20). Suppose that {βk} and {γk} in the CALGD algorithm satisfy (21).\na) If (22) is satisfied, then for any x ∈ X and k ≥ 1,\nf(yk)− f(x∗) ≤ βkγk2 D 2 X + Γk ∑k i=1 ηiγi Γi . (41)\nwhere x∗ is an arbitrary optimal solution of (1) and DX is defined in (4).\nb) If (24) (rather than (22)) is satisfied, then for any x ∈ X and k ≥ 1,\nf(yk)− f(x∗) ≤ β1Γk2 ‖x0 − x ∗‖2 + Γk ∑k i=1 ηiγi Γi . (42)\nc) Under the assumptions in either part a) or b), the number of inner iterations performed at the k-th outer iteration can be bounded by (25).\nProof. Since the convergence results stated in Theorem 2.3 cover the deterministic case when we set δk,j = F\n′(zk, ξk,j)− f ′(zk) ≡ 0, Part a) immediately follows from (23) with σ = 0. Similarly, Part b) follows from (27), (29) and δi = ∑Bi j=1δi,j = 0. The proof of Part c) is exactly the same as that of Theorem 2.3.c).\nClearly, there exist various options to specify the parameters {βk}, {γk}, and {ηk} so as to guarantee the convergence of the CALGD method. In the following corollaries, we provide two different parameter settings for {βk}, {γk}, and {ηk}, which lead to optimal complexity bounds on the total number of calls to the FO and LOsep oracles for smooth convex optimization.\nCorollary 3.2. If {βk}, {γk}, and {ηk} in the CALGD method are set to\nβk = 3L k+1 , γk = 3 k+2 , and ηk = LD2X k(k+1) , ∀k ≥ 1, (43)\nand we assume that ‖f ′(x∗)‖ is bounded for any optimal solution x∗ of (1), then for any k ≥ 1,\nf(yk)− f(x∗) ≤ 15LD 2 X\n2(k+1)(k+2) . (44)\nAs a consequence, the total number of calls to the FO and LOsep oracles performed by the CALGD method for finding an -solution of (1) can be bounded by O (√ LD2X/ ) and O ( LD2X/ ) respectively.\nProof. It can be easily seen from (43) that (21) holds, Γk is given by (34), and\nβkγk Γk = 9L(k+1)(k+2) k(k+1)(k+2) 6 = 3Lk 2 ,\nwhich implies that (22) is satisfied. It then follows from Theorem 3.1.a), (43), and (34) that\nf(yk)− f(x∗) ≤ 9LD 2 X 2(k+1)(k+2) + 6 k(k+1)(k+2) ∑k i=1 ηiγi Γi\n= 15LD2X\n2(k+1)(k+2) ,\nwhich implies that the total number of outer iterations performed by the CALGD method for finding an -solution can be bounded by N = √ 15LD2X/(2 ).\nWe first provide a valid upper bound for Φk0 defined in Line 1 when the CALGD method enters the LCG procedure at the k-th outer iteration. In view of the definitions of Φk0 and ψ(·) at Line 1 and (39), respectively, we have, for any k ≥ 1,\nΦk0 = 〈ψ′k(xk−1), xk−1 − x〉 = 〈f ′(zk), xk−1 − x〉 ≤ (‖f ′(zk)− f ′(x∗)‖+ ‖f ′(x∗)‖)‖xk−1 − x‖ ≤ LD2X + ‖f ′(x∗)‖DX , (45)\nwhere the first inequality follows from Cauchy-Schwarz and the triangle inequality, and the second inequality follows from (2) and (4). Note that we always have ηk < αβkD2X . Therefore, similar to the stochastic case, our O(LD2X/ ) bound immediately follows from the above relation, (25), and (43).\nAs before in the stochastic case, we can slightly improve the complexity bound on the calls to the FO oracle in terms of the dependence on DX .\nCorollary 3.3. Suppose that there exists an estimate D0 ≥ ‖x0 − x∗‖ and that the outer iteration limit N ≥ 1 is given. If\nβk = 2L k , γk = 2 k+1 , ηk = 2LD20 Nk , (46)\nfor k ≥ 1, then f(yN )− f(x∗) ≤ 6LD 2 0\nN(N+1) . (47)\nAs a consequence, the total number of calls to the FO and LOsep oracles performed by the CALGD method for finding an -solution of (1) can be bound by\nO ( D0 √ L ) and O ( LD2X ) (48)\nrespectively.\nProof. The proof is similar to Corollary 3.2, and hence omitted."
    }, {
      "heading" : "4 Generalizations to other optimization problems",
      "text" : "We generalize the CALGD and CALSGD methods to solve two other classes of problems frequently seen in machine learning. In particular, we discuss the CALGD method with a restarting technique for solving smooth and strongly convex problems in Subsection 4.1, and in Subsection 4.3 we extend the CALGD method to solve a special class of non-smooth problems. Discussions for the similar extensions for CALSGD method can be found in Subsection 4.2 and 4.4."
    }, {
      "heading" : "4.1 Strongly convex optimization",
      "text" : "In this subsection, we assume that the objective function f is not only smooth (i.e., (6) holds), but also strongly convex, that is, ∃ µ > 0 s.t.\nf(y)− f(x)− 〈f ′(x), y − x〉 ≥ µ2 ‖y − x‖ 2, ∀x, y ∈ X. (49)\nFor simplicity, we first establish the convergence results for the deterministic case, i.e., we have access to the exact gradients of the objective function f .\nThe shrinking conditional gradient method in Lan [2013] needs to make additional assumptions on the LO oracle to obtain a linear rate of convergence. However, we will show now that CALGD (relying on the vanilla weak separation oracle) can obtain a linear rate of convergence in terms of the number of calls to the FO oracle and O(LD2X/ ) rate of convergence in the total number of calls to the LOsep oracle. In view of the lower complexity bound established for the LO oracle to solve strongly convex problems in Jaggi [2013] and Lan [2013], our bound for the LOsep oracle is not improvable.\nWe are now ready to formally describe the CALGD method for solving strongly convex problems, which is obtained by properly restarting the CALGD method (Algorithm 2).\nAlgorithm 3 The CALGD method for strongly convex problems Input: Initial point p0 ∈ X and an estimate δ0 > 0 satisfying f(p0)− f(x∗) ≤ δ0. for s = 1, 2, . . . do Call the CALGD method in Algorithm 2 with input\nx0 = ps−1 and N = ⌈ 2 √ 6L µ ⌉ , (50)\nand parameters βk = 2L k , γk = 2 k+1 , and ηk = ηs,k := 8Lδ02 −s µNk , (51)\nand let ps be its output solution. end for\nIn Algorithm 3, we restart the CALGD method for smooth optimization (i.e., Algorithm 2) every d2 √\n6L/µe iterations. We call each loop iteration a phase of the above CALGD algorithm. Observe that {ηk} decrease by a factor of 2 as s increments by 1, while {βk} and {γk} remain the same. The following theorem shows the convergence of the above variant of the CALGD method.\nTheorem 4.1. Assume (49) holds and let {ps} be generated by Algorithm 3. Then,\nf(ps)− f(x∗) ≤ δ02−s, s ≥ 0.\nAs a consequence, the total number of calls to the FO and LOsep oracles performed by this algorithm for finding an -solution of problem (1) can be bounded by\nO {√\nL µ ⌈ log2 max ( 1, δ0 )⌉} and O { LD2X } , (52)\nrespectively.\nProof. Denote the total number of phases performed by CALGD method to obtain an -solution of (1) by S. In view of the complexity results obtained in Theorem 2.5 in Lan and Zhou [2014], we conclude that\nS = ⌈ log2 max ( 1, δ0 )⌉ . (53)\nThe total number of calls to the FO oracle performed by Algorithm 3 is clearly bounded by NS, which immediately implies our first result in (52).\nNow, let Ts,k denote the number of calls to the LOsep oracle required at the k-th outer iteration in the s-th phase. It follows from Theorem 3.1.c), (45), and (51) that\nTs,k ≤ O ( βkD 2 X\nηs,k\n) = O ( µD2X2\nsN δ0\n) .\nTherefore, the total number of calls to the LOsep oracle can be bounded by∑S s=1 ∑N k=1Ts,k ≤ ∑S s=1 ∑N k=1O ( µD2X2 sN δ0 ) = O ( µD2XN 2\nδ0\n∑S s=12 s )\n= O ( µD2XN 2\nδ0 2S+1 ) = O ( µD2XN 2 ) ,\nwhich implies our second bound in (52) due to the definitions of N and S in (50) and (53), respectively.\nIn view of classic complexity theory for convex optimization, the bound on the total number of calls to the FO oracle (cf. first bound in (52)) is optimal for strongly convex optimization. Moreover, in view of the complexity results established in Lan [2013] and the fact that the LOsep oracle is weaker than the LO oracle, the bound on the total number of calls to the LOsep oracle (cf. second bound in (52)) is not improvable either."
    }, {
      "heading" : "4.2 Strongly convex stochastic optimization",
      "text" : "Similarly to the deterministic case we present an optimal algorithm for solving stochastic smooth and strongly convex problems.\nAlgorithm 4 The CALSGD method for solving strongly convex problems Input: Initial point p0 ∈ X and an estimate δ0 > 0 satisfying f(p0)− f(x∗) ≤ δ0. for s = 1, 2, . . . do Call the CALSGD method in Algorithm 1 with input\nx0 = ps−1 and N = ⌈ 4 √ 2L µ ⌉ , (54)\nand parameters\nβk = 3L k , γk = 2 k+1 , ηk = ηs,k :=\n8Lδ02 −s\nµNk , and Bk = Bs,k := ⌈ µσ2N(k+1)2\n4L2δ02−s\n⌉ , (55)\nand let ps be its output solution. end for\nThe main convergence properties of Algorithm 4 are as follows.\nTheorem 4.2. Assume that (49) holds and let {ps} be generated by Algorithm 4. Then,\nE[f(ps)− f(x∗)] ≤ δ02−s, s ≥ 0.\nAs a consequence, the total number of calls to the SFO and LOsep oracles performed by this algorithm for finding a stochastic -solution of problem (1)-(8) can be bounded by\nO { σ2 µ + √ L µ ⌈ log2 max ( 1, δ0 )⌉} , (56)\nand O { LD2X } , with probability 1− Λ, (57)\nrespectively.\nProof. In view of Corollary 2.5, and Theorem 3.4 in Lan and Zhou [2014], the total number of phases, S, performed by CALSGD method to find a stochastic -solution of problem (1)-(8) is bounded by (53). Since the number of outer iterations in each phase is at most N , the total number of calls to the SFO oracle is bounded by∑S\ns=1 ∑N k=1Bk ≤ ∑S s=1 ∑N k=1 ( µσ2N(k+1)2 4L2δ02−s + 1 )\n≤ µσ 2N(N+1)3\n12L2δ0\n∑S s=12 s + SN\n≤ µσ 2N(N+1)3\n3L2 + SN.\nMoreover, similar to (35), we obtain a good estimator for Φs,k0 , for any 0 < Λ ≤ 1\nΦs,k0 ≤ (√ 4SL2δ0 Λµk22s + 1 ) LD2X + ‖f ′(x∗)‖∗DX ,\nwith probability 1−Λ. Let Ts,k denote the number of calls to the LOsep oracle required at the k-th outer iteration in the s-th phase of the CALSGD method. It follows from Theorem 2.3.c), the above relation, and (55) that with probability 1− Λ,\nTs,k ≤ O ( log Φs,k0 ηs,k + βkD 2 X ηs,k ) = O ( µD2X2 sN δ0 ) holds. Therefore, the total number of calls to the LOsep oracle is bounded by∑S\ns=1 ∑N k=1Ts,k ≤ ∑S s=1 ∑N k=1O ( µD2X2 sN δ0 ) = O ( µD2XN 2δ−10 ∑S s=12 s )\n= O ( µD2XN 2 ) ,\nwhich implies the bound in (57), due to the definitions of N and S in (54) and (53), respectively.\nAccording to Theorem 4.2, the total number of calls to the SFO oracle is bounded by O(1/ ), which is optimal in view of the classic complexity theory for strongly convex optimization (see [Ghadimi and Lan, 2012, 2013]). Moreover, the total number of calls to the LOsep oracle is bounded by O(1/ ), which is the same bound as for the CALGD method for strongly convex optimization and hence not improvable."
    }, {
      "heading" : "4.3 Non-smooth optimization: Saddle point problems",
      "text" : "For the sake of simplicity, we consider the deterministic case, i.e., the problem of interest is an important class of saddle point problems with f given in the form of\nf(x) = max y∈Y\n{ 〈Ax, y〉 − f̂(y) } , (58)\nwhere A : Rn → Rm denotes a linear operator, Y ∈ Rm is a convex compact set, and f̂ : Y → R is a simple convex function. Since the objective function f is non-smooth, we cannot directly apply the CALGD method presented in the previous section. However, as shown by Nesterov [2005], the function f(·) in (58) can be closely approximated by a class of smooth convex functions. More specifically, let ω : Y → R be a given strongly convex function with strongly convex modulus σω > 0, i.e.,\nω(y) ≥ ω(x) + 〈ω′(x), y − x〉+ σω2 ‖y − x‖ 2,∀x, y ∈ Y,\nand let us denote cω := argminy∈Y ω(y), W (y) := ω(y)− ω(cω)− 〈∇ω(cω), y − cω〉 and\nD2Y,W := max y∈Y W (y).\nIt can be easily seen that\n‖y − cω‖2 ≤ 2σωW (y) ≤ 2 σω D2Y,W , ∀y ∈ Y,\nand hence that ‖y1 − y2‖2 ≤ 4σωD 2 Y,W , ∀y1, y2 ∈ Y.\nIn view of these relations, the function f(·) in (58) can be closely approximated by\nfτ (x) := max y∈Y\n{ 〈Ax, y〉 − f̂(y)− τ [W (y)−D2Y,W ] } . (59)\nIn particular, for any τ ≥ 0,\nf(x) ≤ fτ (x) ≤ f(x) + τ D2Y,W , ∀x ∈ X.\nMoreover, Nesterov [2005] shows that fτ (·) is differentiable and its gradients are Lipschitz continuous with the Lipschitz constant given by\nLτ := ‖A‖ 2\nτσω . (60)\nThroughout this subsection, we assume that the feasible region Y and the function f̂ are simple enough, so that the subproblem in (59) is easy to solve. Therefore, the major computational cost for gradient calculations of fτ lie in the evaluations of the linear operator A and its adjoint operator AT . We are now ready to present a variant of the CALGD method, which can achieve optimal bounds on the number of calls to the LOsep oracle and the number of evaluations of the linear operators A and AT .\nAlgorithm 5 The CALGD method for solving saddle point problems This algorithm is the same as Algorithm 2 except that (38) is replaced by\nxk = LCG(f ′ τk (zk), βk, xk−1, α, ηk), (61)\nfor some τk ≥ 0.\nIn Theorem 4.3 we state the main convergence properties of this modified CALGD method to solve the saddle point problem in (1)-(58).\nTheorem 4.3. Suppose that τ1 ≥ τ2 ≥ . . . ≥ 0. Also assume that {βk} and {γk} satisfy (21) (with L replaced by Lτk defined in (60)) and (22). Then, for all k ≥ 1,\nf(yk)− f(x∗) ≤ βkγk2 D 2 X + Γk ∑k i=1 γi Γi ( ηi + τiD2Y,W ) , (62)\nwhere x∗ is an arbitrary optimal solution of (1)-(58). Moreover, the number of inner iterations performed at the k-th outer iteration is bounded by (25).\nProof. The proof is similar to Theorem 4.1 in Lan and Zhou [2014], and hence omitted.\nWe now provide two different sets of parameter settings for {βk}, {γk}, {ηk}, and {τk} which can guarantee the optimal convergence of the above variant of the CALGD method for saddle point optimization. Specifically, Corollary 4.4 gives a static setting for parameter {τk} under the assumption that the outer iteration limit N ≥ 1 is given, while a dynamic setting is provided in Corollary 4.5.\nCorollary 4.4. Assume the outer iteration limit N ≥ 1 is given. If\nτk ≡ τ = 2‖A‖DXDY,W√σωN , k ≥ 1, (63)\nand {βk}, {γk}, and {ηk} used in Algorithm 5 are set to\nβk = 3Lτk k+1 , γk = 3 k+2 , and ηk = LτkD 2 X k2 , k ≥ 1, (64)\nthen the number of linear operator evaluations (for A and AT ) and the number of calls to the LOsep oracle performed by Algorithm 5 for finding an -solution of problem (1)-(58), respectively, is bounded by\nO { ‖A‖DXDY,W√\nσω\n} and O { ‖A‖2D2XD 2 Y,W\nσω 2\n} . (65)\nProof. In view of the result in Corollary 4.2 of Lan and Zhou [2014], our first bound in (65) immediately follows. Moreover, it follows from (45), (25), (63), (64) and (60) that the total number of calls to the LOsep oracle is bounded by∑N\nk=1Tk ≤ ∑N k=1O ( βkD 2 X\nηk\n) = ∑N k=1O ( LτkD 2 X k+1 k2\nLτkD 2 X\n) = O(N2),\nwhich implies our second bound in (65).\nCorollary 4.5. Suppose that parameter {τk} is now set to\nτk = 2‖A‖DX DY,W √ σωk , k ≥ 1, (66)\nand the parameters {βk}, {γk}, and {ηk} used in Algorithm 5 are set as in (64). Then, the number of linear operator evaluations (for A and AT ) and the number of calls to the LOsep oracle performed by Algorithm 5 for finding an -solution of problem (1)-(58) is bounded by the two bounds as given in (65) respectively.\nProof. The proof is similar to the Corollary 4.4, and hence omitted.\nIn view of the discussions in Chen et al. [2014], the obtained bound on the total number of operator evaluations (cf. first bound in (65)) is not improvable for solving the saddle point problems in (1)-(58). Moreover, according to Lan [2013] and the fact that the LOsep oracle is weaker than LO oracle, the O(1/ 2) bound on the total number of calls to the LOsep is not improvable."
    }, {
      "heading" : "4.4 Non-smooth stochastic optimization: stochastic saddle point problems",
      "text" : "In this subsection, we briefly discuss stochastic saddle point problems, i.e., only stochastic gradients of fτ (cf. (59)) are available. In particular, we consider the situation when the original objective function f in (1) is given by\nf(x) = E [ max y∈Y 〈Aξx, y〉 − f̂(y, ξ) ] , (67)\nwhere f̂(·, ξ) is simple concave function for all ξ ∈ Ξ and Aξ is a random linear operator such that\nE [ ‖Aξ‖2 ] ≤ L2A (68)\nWe can solve this stochastic saddle point problem by replacing (61) with\nxk = LCG(gk, xk−1, βk, ηk),\nwhere gk = 1Bk ∑Bk j=1 F ′ τk\n(zk, ξk,j) for some τk ≥ 0 and Bk ≥ 1. By properly specifying {βk}, {ηk}, {τk}, and {Bk}, we can show that the number of linear operator evaluations (for Aξ and ATξ ) and the number of calls to the LOsep oracle performed by this variant of CALSGD method for finding a stochastic -solution of problem (1)-(67) is bounded by\nO { L2AD 2 XD 2 Y,W\nσω 2\n} ,\nand\nO { L2AD 2 XD 2 Y,W\nσω 2 } with probability 1 − Λ respectively. This result can be proved by combining the techniques in Section 2 and those in Theorem 4.3. However, we skip the details of these developments for the sake of simplicity."
    }, {
      "heading" : "5 Experimental results",
      "text" : "We present preliminary experimental results showing the performance of CALSGD compared to OFW for stochastic optimization. As examples we use the video co-localization problem, which can be solved by quadratic programming over a path polytope, different structured regression problems, and quadratic programming over the standard spectrahedron. In all cases we use objective functions of the form ‖Ax − b‖2, with A ∈ Rm×n, i.e., m examples over a feasible region of dimension n. In each example there is a density parameter d specifying the fraction of non-zero entries in A. We compute b = Ax∗ with some feasible point x∗ so that in all examples the optimal value is 0. For comparability we use a batch size of 128 for all algorithms to compute each gradient and the full matrix A for the actual objective function values. Since the function values are not used by any algorithm, each algorithm has only the information provided by the 128 examples sampled in that specific round. All graphs show the function value using a logscale on the vertical axis. We implemented all algorithms using Python 2.7 using Gurobi 7.0 Gurobi Optimization [2016] as the solver for our linear models.\nIn Figure 1 we compare the performance of three algorithms: CALSGD, SCGS and OFW. As described above SCGS is the non-lazy counterpart of CALSGD. In the four graphs of Figure 1 we report the objective function value over the number of iterations, the wall clock time in seconds, the number of calls to the linear oracle, and the number of gradient evaluations in that order. In all these measures, our proposed algorithms outperform OFW by multiple orders of magnitude. As expected in number of iterations and number of gradient evaluations both versions CALSGD and SCGS perform equally well, however in wall clock time and in the number of calls to the linear oracle we observe the advantage of the weaker LOsep oracle over LO.\nFor the rest of the results we compare only the best version of our algorithm CALSGD with OFW. We report on each example the performance of the algorithms over the number of iterations and wall clock time in seconds. The three problem we consider are the following.\nVideo co-localization Video co-localization is the problem of identifying and object over multiple frames of a video. As shown by Joulin et al. [2014] this problem can be solved by quadratic programming over a path/flow polytope. In Figures 2, 3 and 4 we show that our algorithm CALSGD performs significantly better than OFW on this type of instances. We use path polytopes available at http://lime.cs.elte.hu/~kpeter/data/mcf/road/. The non-zero entries of A in this section are chosen uniformly from [0, 1] and the density parameter we used is d = 0.8.\nStructured regression For our structured regression instances we solve the objective function ‖Ax− b‖2 as described before over different polytopes. In Figure 5 the feasible region is the convex hull of all Hamiltonian cycles of graphs of different size. In Figure 6 the polytopes are the standard formulation of the cut problem and the Birkhoff polytope.\nConvex optimization over spectrahedra We consider instances of the problem of finding the minimum of a convex function over the standard spectrahedron, which is defined as Sn := {X ∈ Rn×n | X < 0, tr(X) = 1}. In this case the linear minimization problem for an objective function C is solved by computing an eigenvector for the largest eigenvalue of −C. We use the same method to implement LOsepSn . We show results on three different sized instances, in Figure 7 for n = 50, Figure 8 for n = 100 and in Figure 9 for n = 150."
    } ],
    "references" : [ {
      "title" : "A Modified Frank-Wolfe Algorithm for Computing Minimum-Area Enclosing Ellipsoidal Cylinders: Theory and Algorithms",
      "author" : [ "S. Ahipasaoglu", "M. Todd" ],
      "venue" : "Computational Geometry,",
      "citeRegEx" : "Ahipasaoglu and Todd.,? \\Q2013\\E",
      "shortCiteRegEx" : "Ahipasaoglu and Todd.",
      "year" : 2013
    }, {
      "title" : "On the equivalence between herding and conditional gradient algorithms",
      "author" : [ "F. Bach", "S. Lacoste-Julien", "G. Obozinski" ],
      "venue" : "In the 29th International Conference on Machine Learning,",
      "citeRegEx" : "Bach et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Bach et al\\.",
      "year" : 2012
    }, {
      "title" : "A conditional gradient method with linear rate of convergence for solving convex linear systems",
      "author" : [ "A. Beck", "M. Teboulle" ],
      "venue" : "Math. Methods Oper. Res.,",
      "citeRegEx" : "Beck and Teboulle.,? \\Q2004\\E",
      "shortCiteRegEx" : "Beck and Teboulle.",
      "year" : 2004
    }, {
      "title" : "Lazifying conditional gradient algorithms",
      "author" : [ "G. Braun", "S. Pokutta", "D. Zink" ],
      "venue" : "arXiv preprint arXiv:1610.05120,",
      "citeRegEx" : "Braun et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Braun et al\\.",
      "year" : 2016
    }, {
      "title" : "Optimal primal-dual methods for a class of saddle point problems",
      "author" : [ "Y. Chen", "G. Lan", "Y. Ouyang" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "Chen et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2014
    }, {
      "title" : "Coresets, sparse greedy approximation, and the frank-wolfe algorithm",
      "author" : [ "K.L. Clarkson" ],
      "venue" : "ACM Trans. Algorithms,",
      "citeRegEx" : "Clarkson.,? \\Q2010\\E",
      "shortCiteRegEx" : "Clarkson.",
      "year" : 2010
    }, {
      "title" : "Dual subgradient algorithms for large-scale nonsmooth learning problems",
      "author" : [ "B. Cox", "A. Juditsky", "A.S. Nemirovski" ],
      "venue" : "Manuscript, School of ISyE, Georgia Tech, Atlanta, GA,",
      "citeRegEx" : "Cox et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Cox et al\\.",
      "year" : 2013
    }, {
      "title" : "An algorithm for quadratic programming",
      "author" : [ "M. Frank", "P. Wolfe" ],
      "venue" : "Naval Research Logistics Quarterly,",
      "citeRegEx" : "Frank and Wolfe.,? \\Q1956\\E",
      "shortCiteRegEx" : "Frank and Wolfe.",
      "year" : 1956
    }, {
      "title" : "New Analysis and Results for the Frank-Wolfe Method",
      "author" : [ "R.M. Freund", "P. Grigas" ],
      "venue" : "ArXiv e-prints,",
      "citeRegEx" : "Freund and Grigas.,? \\Q2013\\E",
      "shortCiteRegEx" : "Freund and Grigas.",
      "year" : 2013
    }, {
      "title" : "A Linearly Convergent Conditional Gradient Algorithm with Applications to Online and Stochastic Optimization",
      "author" : [ "D. Garber", "E. Hazan" ],
      "venue" : null,
      "citeRegEx" : "Garber and Hazan.,? \\Q2013\\E",
      "shortCiteRegEx" : "Garber and Hazan.",
      "year" : 2013
    }, {
      "title" : "Optimal stochastic approximation algorithms for strongly convex stochastic composite optimization, I: a generic algorithmic framework",
      "author" : [ "S. Ghadimi", "G. Lan" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "Ghadimi and Lan.,? \\Q2012\\E",
      "shortCiteRegEx" : "Ghadimi and Lan.",
      "year" : 2012
    }, {
      "title" : "Optimal stochastic approximation algorithms for strongly convex stochastic composite optimization, II: shrinking procedures and optimal algorithms",
      "author" : [ "S. Ghadimi", "G. Lan" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "Ghadimi and Lan.,? \\Q2013\\E",
      "shortCiteRegEx" : "Ghadimi and Lan.",
      "year" : 2013
    }, {
      "title" : "Conditional gradient algorithms for machine learning",
      "author" : [ "Z. Harchaoui", "A. Juditsky", "A.S. Nemirovski" ],
      "venue" : "NIPS OPT workshop,",
      "citeRegEx" : "Harchaoui et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Harchaoui et al\\.",
      "year" : 2012
    }, {
      "title" : "Sparse approximate solutions to semidefinite programs",
      "author" : [ "E. Hazan" ],
      "venue" : "LATIN 2008: Theoretical Informatics,",
      "citeRegEx" : "Hazan.,? \\Q2008\\E",
      "shortCiteRegEx" : "Hazan.",
      "year" : 2008
    }, {
      "title" : "Projection-free online learning",
      "author" : [ "E. Hazan", "S. Kale" ],
      "venue" : "arXiv preprint arXiv:1206.4657,",
      "citeRegEx" : "Hazan and Kale.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hazan and Kale.",
      "year" : 2012
    }, {
      "title" : "Sparse Convex Optimization Methods for Machine Learning",
      "author" : [ "M. Jaggi" ],
      "venue" : "PhD thesis, ETH Zürich,",
      "citeRegEx" : "Jaggi.,? \\Q2011\\E",
      "shortCiteRegEx" : "Jaggi.",
      "year" : 2011
    }, {
      "title" : "Revisiting frank-wolfe: Projection-free sparse convex optimization",
      "author" : [ "M. Jaggi" ],
      "venue" : "In the 30th International Conference on Machine Learning,",
      "citeRegEx" : "Jaggi.,? \\Q2013\\E",
      "shortCiteRegEx" : "Jaggi.",
      "year" : 2013
    }, {
      "title" : "Sulovský. A simple algorithm for nuclear norm regularized problems",
      "author" : [ "M.M. Jaggi" ],
      "venue" : "In the 27th International Conference on Machine Learning,",
      "citeRegEx" : "Jaggi,? \\Q2010\\E",
      "shortCiteRegEx" : "Jaggi",
      "year" : 2010
    }, {
      "title" : "Efficient image and video co-localization with frank-wolfe algorithm",
      "author" : [ "A. Joulin", "K. Tang", "L. Fei-Fei" ],
      "venue" : "In European Conference on Computer Vision,",
      "citeRegEx" : "Joulin et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Joulin et al\\.",
      "year" : 2014
    }, {
      "title" : "Convex optimization under inexact first-order information",
      "author" : [ "G. Lan" ],
      "venue" : "Ph.D. dissertation, School of Industrial and Systems Engineering, Georgia Institute of Technology, Atlanta, GA 30332,",
      "citeRegEx" : "Lan.,? \\Q2009\\E",
      "shortCiteRegEx" : "Lan.",
      "year" : 2009
    }, {
      "title" : "An optimal method for stochastic composite optimization",
      "author" : [ "G. Lan" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Lan.,? \\Q2012\\E",
      "shortCiteRegEx" : "Lan.",
      "year" : 2012
    }, {
      "title" : "The complexity of large-scale convex programming under a linear optimization oracle",
      "author" : [ "G. Lan" ],
      "venue" : "Technical Report,",
      "citeRegEx" : "Lan.,? \\Q2013\\E",
      "shortCiteRegEx" : "Lan.",
      "year" : 2013
    }, {
      "title" : "Conditional gradient sliding for convex optimization",
      "author" : [ "G. Lan", "Y. Zhou" ],
      "venue" : "Optimization-Online preprint (4605),",
      "citeRegEx" : "Lan and Zhou.,? \\Q2014\\E",
      "shortCiteRegEx" : "Lan and Zhou.",
      "year" : 2014
    }, {
      "title" : "Conditional gradient algorithms for rank one matrix approximations with a sparsity constraint",
      "author" : [ "R. Luss", "M. Teboulle" ],
      "venue" : "SIAM Review,",
      "citeRegEx" : "Luss and Teboulle.,? \\Q2013\\E",
      "shortCiteRegEx" : "Luss and Teboulle.",
      "year" : 2013
    }, {
      "title" : "A method for unconstrained convex minimization problem with the rate of convergence O(1/k)",
      "author" : [ "Y.E. Nesterov" ],
      "venue" : "Doklady AN SSSR,",
      "citeRegEx" : "Nesterov.,? \\Q1983\\E",
      "shortCiteRegEx" : "Nesterov.",
      "year" : 1983
    }, {
      "title" : "Introductory Lectures on Convex Optimization: a basic course",
      "author" : [ "Y.E. Nesterov" ],
      "venue" : "Kluwer Academic Publishers,",
      "citeRegEx" : "Nesterov.,? \\Q2004\\E",
      "shortCiteRegEx" : "Nesterov.",
      "year" : 2004
    }, {
      "title" : "Smooth minimization of nonsmooth functions",
      "author" : [ "Y.E. Nesterov" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Nesterov.,? \\Q2005\\E",
      "shortCiteRegEx" : "Nesterov.",
      "year" : 2005
    }, {
      "title" : "Positive semidefinite metric learning using boosting-like algorithms",
      "author" : [ "C. Shen", "J. Kim", "L. Wang", "A. van den Hengel" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Shen et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Shen et al\\.",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 13,
      "context" : "Abstract In this work we introduce a conditional accelerated lazy stochastic gradient descent algorithm with optimal number of calls to a stochastic first-order oracle and convergence rate O( 1 ε2 ) improving over the projection-free, Online Frank-Wolfe based stochastic gradient descent of Hazan and Kale [2012] with convergence rate O( 1 ε4 ).",
      "startOffset" : 291,
      "endOffset" : 313
    }, {
      "referenceID" : 7,
      "context" : "The conditional gradient method (also known as: Frank-Wolfe algorithm) proposed in Frank and Wolfe [1956], gained much popularity in recent years due to its simple projection-free scheme and fast practical convergence rates.",
      "startOffset" : 83,
      "endOffset" : 106
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al.",
      "startOffset" : 2,
      "endOffset" : 30
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al.",
      "startOffset" : 2,
      "endOffset" : 50
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al.",
      "startOffset" : 2,
      "endOffset" : 76
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al.",
      "startOffset" : 2,
      "endOffset" : 95
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al.",
      "startOffset" : 2,
      "endOffset" : 112
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al.",
      "startOffset" : 2,
      "endOffset" : 138
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al.",
      "startOffset" : 2,
      "endOffset" : 152
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al.",
      "startOffset" : 2,
      "endOffset" : 177
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al.",
      "startOffset" : 2,
      "endOffset" : 224
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al.",
      "startOffset" : 2,
      "endOffset" : 250
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al.",
      "startOffset" : 2,
      "endOffset" : 270
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al.",
      "startOffset" : 2,
      "endOffset" : 293
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al.",
      "startOffset" : 2,
      "endOffset" : 305
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al.",
      "startOffset" : 2,
      "endOffset" : 326
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]).",
      "startOffset" : 2,
      "endOffset" : 347
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3).",
      "startOffset" : 2,
      "endOffset" : 592
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method.",
      "startOffset" : 2,
      "endOffset" : 692
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3).",
      "startOffset" : 2,
      "endOffset" : 1019
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3). Furthermore, as shown in Jaggi [2013] and Lan [2013], the total number of iterations for the LCP methods to find an -solution of (1) (i.",
      "startOffset" : 2,
      "endOffset" : 1156
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3). Furthermore, as shown in Jaggi [2013] and Lan [2013], the total number of iterations for the LCP methods to find an -solution of (1) (i.",
      "startOffset" : 2,
      "endOffset" : 1171
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3). Furthermore, as shown in Jaggi [2013] and Lan [2013], the total number of iterations for the LCP methods to find an -solution of (1) (i.e., a point x̄ ∈ X, s.t. f(x̄) − f∗ ≤ ) cannot be smaller than O(1/ ), which is not improvable even when the objective function f is strongly convex. Improved complexity results can only be obtained under stronger assumptions on the LO oracle or the feasible set (see, e.g., Garber and Hazan [2013], Lan [2013]).",
      "startOffset" : 2,
      "endOffset" : 1553
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3). Furthermore, as shown in Jaggi [2013] and Lan [2013], the total number of iterations for the LCP methods to find an -solution of (1) (i.e., a point x̄ ∈ X, s.t. f(x̄) − f∗ ≤ ) cannot be smaller than O(1/ ), which is not improvable even when the objective function f is strongly convex. Improved complexity results can only be obtained under stronger assumptions on the LO oracle or the feasible set (see, e.g., Garber and Hazan [2013], Lan [2013]).",
      "startOffset" : 2,
      "endOffset" : 1565
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3). Furthermore, as shown in Jaggi [2013] and Lan [2013], the total number of iterations for the LCP methods to find an -solution of (1) (i.e., a point x̄ ∈ X, s.t. f(x̄) − f∗ ≤ ) cannot be smaller than O(1/ ), which is not improvable even when the objective function f is strongly convex. Improved complexity results can only be obtained under stronger assumptions on the LO oracle or the feasible set (see, e.g., Garber and Hazan [2013], Lan [2013]). However, the O(1/ ) bound does not preclude the existence of more efficient LCP algorithms for solving (1). Lan and Zhou [2014] proposed a class of conditional gradient sliding methods (CGS), which significantly improve the complexity bounds in terms of the number of gradient evaluations while maintaining optimal complexity bounds for the LO oracle calls required by the LCP methods.",
      "startOffset" : 2,
      "endOffset" : 1695
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3). Furthermore, as shown in Jaggi [2013] and Lan [2013], the total number of iterations for the LCP methods to find an -solution of (1) (i.e., a point x̄ ∈ X, s.t. f(x̄) − f∗ ≤ ) cannot be smaller than O(1/ ), which is not improvable even when the objective function f is strongly convex. Improved complexity results can only be obtained under stronger assumptions on the LO oracle or the feasible set (see, e.g., Garber and Hazan [2013], Lan [2013]). However, the O(1/ ) bound does not preclude the existence of more efficient LCP algorithms for solving (1). Lan and Zhou [2014] proposed a class of conditional gradient sliding methods (CGS), which significantly improve the complexity bounds in terms of the number of gradient evaluations while maintaining optimal complexity bounds for the LO oracle calls required by the LCP methods. Inspired by Braun et al. [2016] and Lan and Zhou [2014], in this paper we focus on a class of modified LCP methods that require only improving solutions for a certain separation problem rather than solving the linear optimization subproblem (3) explicitly through LO oracle calls while simultaneously minimizing the number of gradient evaluations when performing weak separation over the feasible set X.",
      "startOffset" : 2,
      "endOffset" : 1985
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3). Furthermore, as shown in Jaggi [2013] and Lan [2013], the total number of iterations for the LCP methods to find an -solution of (1) (i.e., a point x̄ ∈ X, s.t. f(x̄) − f∗ ≤ ) cannot be smaller than O(1/ ), which is not improvable even when the objective function f is strongly convex. Improved complexity results can only be obtained under stronger assumptions on the LO oracle or the feasible set (see, e.g., Garber and Hazan [2013], Lan [2013]). However, the O(1/ ) bound does not preclude the existence of more efficient LCP algorithms for solving (1). Lan and Zhou [2014] proposed a class of conditional gradient sliding methods (CGS), which significantly improve the complexity bounds in terms of the number of gradient evaluations while maintaining optimal complexity bounds for the LO oracle calls required by the LCP methods. Inspired by Braun et al. [2016] and Lan and Zhou [2014], in this paper we focus on a class of modified LCP methods that require only improving solutions for a certain separation problem rather than solving the linear optimization subproblem (3) explicitly through LO oracle calls while simultaneously minimizing the number of gradient evaluations when performing weak separation over the feasible set X.",
      "startOffset" : 2,
      "endOffset" : 2009
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3). Furthermore, as shown in Jaggi [2013] and Lan [2013], the total number of iterations for the LCP methods to find an -solution of (1) (i.e., a point x̄ ∈ X, s.t. f(x̄) − f∗ ≤ ) cannot be smaller than O(1/ ), which is not improvable even when the objective function f is strongly convex. Improved complexity results can only be obtained under stronger assumptions on the LO oracle or the feasible set (see, e.g., Garber and Hazan [2013], Lan [2013]). However, the O(1/ ) bound does not preclude the existence of more efficient LCP algorithms for solving (1). Lan and Zhou [2014] proposed a class of conditional gradient sliding methods (CGS), which significantly improve the complexity bounds in terms of the number of gradient evaluations while maintaining optimal complexity bounds for the LO oracle calls required by the LCP methods. Inspired by Braun et al. [2016] and Lan and Zhou [2014], in this paper we focus on a class of modified LCP methods that require only improving solutions for a certain separation problem rather than solving the linear optimization subproblem (3) explicitly through LO oracle calls while simultaneously minimizing the number of gradient evaluations when performing weak separation over the feasible set X. At first these two objectives seem to be incompatible as Braun et al. [2016] gives up the dual guarantee to simplify the oracle, while the dual guarantee of CG iterations is at the core of the analysis in Lan and Zhou [2014].",
      "startOffset" : 2,
      "endOffset" : 2434
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3). Furthermore, as shown in Jaggi [2013] and Lan [2013], the total number of iterations for the LCP methods to find an -solution of (1) (i.e., a point x̄ ∈ X, s.t. f(x̄) − f∗ ≤ ) cannot be smaller than O(1/ ), which is not improvable even when the objective function f is strongly convex. Improved complexity results can only be obtained under stronger assumptions on the LO oracle or the feasible set (see, e.g., Garber and Hazan [2013], Lan [2013]). However, the O(1/ ) bound does not preclude the existence of more efficient LCP algorithms for solving (1). Lan and Zhou [2014] proposed a class of conditional gradient sliding methods (CGS), which significantly improve the complexity bounds in terms of the number of gradient evaluations while maintaining optimal complexity bounds for the LO oracle calls required by the LCP methods. Inspired by Braun et al. [2016] and Lan and Zhou [2014], in this paper we focus on a class of modified LCP methods that require only improving solutions for a certain separation problem rather than solving the linear optimization subproblem (3) explicitly through LO oracle calls while simultaneously minimizing the number of gradient evaluations when performing weak separation over the feasible set X. At first these two objectives seem to be incompatible as Braun et al. [2016] gives up the dual guarantee to simplify the oracle, while the dual guarantee of CG iterations is at the core of the analysis in Lan and Zhou [2014]. We overcome this impasse by carefully modifying both techniques.",
      "startOffset" : 2,
      "endOffset" : 2582
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3). Furthermore, as shown in Jaggi [2013] and Lan [2013], the total number of iterations for the LCP methods to find an -solution of (1) (i.e., a point x̄ ∈ X, s.t. f(x̄) − f∗ ≤ ) cannot be smaller than O(1/ ), which is not improvable even when the objective function f is strongly convex. Improved complexity results can only be obtained under stronger assumptions on the LO oracle or the feasible set (see, e.g., Garber and Hazan [2013], Lan [2013]). However, the O(1/ ) bound does not preclude the existence of more efficient LCP algorithms for solving (1). Lan and Zhou [2014] proposed a class of conditional gradient sliding methods (CGS), which significantly improve the complexity bounds in terms of the number of gradient evaluations while maintaining optimal complexity bounds for the LO oracle calls required by the LCP methods. Inspired by Braun et al. [2016] and Lan and Zhou [2014], in this paper we focus on a class of modified LCP methods that require only improving solutions for a certain separation problem rather than solving the linear optimization subproblem (3) explicitly through LO oracle calls while simultaneously minimizing the number of gradient evaluations when performing weak separation over the feasible set X. At first these two objectives seem to be incompatible as Braun et al. [2016] gives up the dual guarantee to simplify the oracle, while the dual guarantee of CG iterations is at the core of the analysis in Lan and Zhou [2014]. We overcome this impasse by carefully modifying both techniques. It should be mentioned that Hazan and Kale [2012] proposed the online Frank-Wolfe (OFW) algorithm, which obtains O(1/ ) rate of convergence for stochastic problems.",
      "startOffset" : 2,
      "endOffset" : 2698
    }, {
      "referenceID" : 0,
      "context" : ", Ahipasaoglu and Todd [2013], Bach et al. [2012], Beck and Teboulle [2004], Cox et al. [2013], Clarkson [2010], Freund and Grigas [2013], Hazan [2008], Harchaoui et al. [2012], Jaggi [2011, 2013], Jaggi and Sulovský [2010], Luss and Teboulle [2013], Shen et al. [2012], Hazan and Kale [2012], Lan [2013], Lan and Zhou [2014], Braun et al. [2016]). It should be noted that even the computational cost for LO oracle to solve the linear optimization subproblem (3) is high for some complex feasible regions. Recently, several approaches have been considered to address this issue. Jaggi [2013] demonstrated practical speed up for the CG method by approximately solving (3). Braun et al. [2016] proposed a class of modified CG methods, namely the lazy conditional gradient (LCG) algorithms, which call a weak separation oracle rather than solving the linear subproblem (3) in the classical CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization used in Jaggi [2013], at the expense of not providing any guarantee for function value improvement with respect to (3). Furthermore, as shown in Jaggi [2013] and Lan [2013], the total number of iterations for the LCP methods to find an -solution of (1) (i.e., a point x̄ ∈ X, s.t. f(x̄) − f∗ ≤ ) cannot be smaller than O(1/ ), which is not improvable even when the objective function f is strongly convex. Improved complexity results can only be obtained under stronger assumptions on the LO oracle or the feasible set (see, e.g., Garber and Hazan [2013], Lan [2013]). However, the O(1/ ) bound does not preclude the existence of more efficient LCP algorithms for solving (1). Lan and Zhou [2014] proposed a class of conditional gradient sliding methods (CGS), which significantly improve the complexity bounds in terms of the number of gradient evaluations while maintaining optimal complexity bounds for the LO oracle calls required by the LCP methods. Inspired by Braun et al. [2016] and Lan and Zhou [2014], in this paper we focus on a class of modified LCP methods that require only improving solutions for a certain separation problem rather than solving the linear optimization subproblem (3) explicitly through LO oracle calls while simultaneously minimizing the number of gradient evaluations when performing weak separation over the feasible set X. At first these two objectives seem to be incompatible as Braun et al. [2016] gives up the dual guarantee to simplify the oracle, while the dual guarantee of CG iterations is at the core of the analysis in Lan and Zhou [2014]. We overcome this impasse by carefully modifying both techniques. It should be mentioned that Hazan and Kale [2012] proposed the online Frank-Wolfe (OFW) algorithm, which obtains O(1/ ) rate of convergence for stochastic problems. Indeed, if we consider the objective function f(x) := E[F (x, ξ)] for stochastic optimization, the OFW method can be applied to solve (1) by viewing the iteratively observed function ft as the current realization of the true objective function f , i.e., ft(·) = F (·, ξt). Without re-evaluating the (sub)gradients at the updated points, the OFW obtains O(T−1/4) bound for any (smooth or non-smooth) objective functions (see Theorem 4.4 in Hazan and Kale [2012]), which implies O(1/ ) rate of convergence in terms of the number of (sub)gradient evaluations for stochastic optimization.",
      "startOffset" : 2,
      "endOffset" : 3274
    }, {
      "referenceID" : 3,
      "context" : "By incorporating a modified LCG procedure [Braun et al., 2016] into a modified CGS method [Lan and Zhou, 2014] we obtain a new conditional accelerated lazy stochastic gradient descent algorithm (CALSGD) and we show that the number of calls to the weak separation oracle can be optimally bounded by O(1/ ), while the optimal bound of O(1/ ) on the total number of calls to the SFO oracle can be maintained.",
      "startOffset" : 42,
      "endOffset" : 62
    }, {
      "referenceID" : 22,
      "context" : ", 2016] into a modified CGS method [Lan and Zhou, 2014] we obtain a new conditional accelerated lazy stochastic gradient descent algorithm (CALSGD) and we show that the number of calls to the weak separation oracle can be optimally bounded by O(1/ ), while the optimal bound of O(1/ ) on the total number of calls to the SFO oracle can be maintained.",
      "startOffset" : 35,
      "endOffset" : 55
    }, {
      "referenceID" : 19,
      "context" : "Our algorithmic framework is inspired by the SCGS method by Lan and Zhou [2014]. However, instead of applying the classic CG method to solve the projection subproblem appearing in the accelerated gradient (AG) method, the CALSGD method utilizes a modified parameter-free LCG algorithm (see Section 2.",
      "startOffset" : 60,
      "endOffset" : 80
    }, {
      "referenceID" : 19,
      "context" : "Secondly, in view of the SCGS method in Lan and Zhou [2014], xk obtained in (13) should be an approximate solution to the gradient sliding subproblem",
      "startOffset" : 40,
      "endOffset" : 60
    }, {
      "referenceID" : 19,
      "context" : ", ηk = 0), then CALSGD will reduce to the accelerated stochastic approximation method by Lan [2009, 2012]. However, by employing the LCG procedure (see Procedure 1 in Subsection 2.2), we only need to use a weak separation oracle, but still maintaining the optimal bounds on stochastic first-order oracle as in Lan [2009, 2012], Lan and Zhou [2014]. Thirdly, observe that the CALSGD method so far is conceptual only as we have not yet specified the LCG procedure and the parameters {Bk}, {βk}, {γk}, and {ηk}.",
      "startOffset" : 89,
      "endOffset" : 348
    }, {
      "referenceID" : 3,
      "context" : "The LCG procedure presented in this subsection, a modification of the vanilla LCG method in Braun et al. [2016], goes several steps further than CG and even vanilla LCG method.",
      "startOffset" : 92,
      "endOffset" : 112
    }, {
      "referenceID" : 3,
      "context" : "We present the LCG procedure based on Braun et al. [2016] below.",
      "startOffset" : 38,
      "endOffset" : 58
    }, {
      "referenceID" : 3,
      "context" : "1 of Braun et al. [2016]), and it halves the value of Φt only when the current oracle call is negative.",
      "startOffset" : 5,
      "endOffset" : 25
    }, {
      "referenceID" : 3,
      "context" : "1 in Braun et al. [2016], it is clear that the number of iterations in the first phase can be bounded as",
      "startOffset" : 5,
      "endOffset" : 25
    }, {
      "referenceID" : 3,
      "context" : "1 in Braun et al. [2016], we obtain that the total number of positive calls in this phase can be bounded by 4α Cφ η , if η < αCφ, or by 4α if η ≥ αCφ.",
      "startOffset" : 5,
      "endOffset" : 25
    }, {
      "referenceID" : 16,
      "context" : "The shrinking conditional gradient method in Lan [2013] needs to make additional assumptions on the LO oracle to obtain a linear rate of convergence.",
      "startOffset" : 45,
      "endOffset" : 56
    }, {
      "referenceID" : 15,
      "context" : "In view of the lower complexity bound established for the LO oracle to solve strongly convex problems in Jaggi [2013] and Lan [2013], our bound for the LOsep oracle is not improvable.",
      "startOffset" : 105,
      "endOffset" : 118
    }, {
      "referenceID" : 15,
      "context" : "In view of the lower complexity bound established for the LO oracle to solve strongly convex problems in Jaggi [2013] and Lan [2013], our bound for the LOsep oracle is not improvable.",
      "startOffset" : 105,
      "endOffset" : 133
    }, {
      "referenceID" : 19,
      "context" : "5 in Lan and Zhou [2014], we conclude that S = ⌈ log2 max ( 1, δ0 )⌉ .",
      "startOffset" : 5,
      "endOffset" : 25
    }, {
      "referenceID" : 19,
      "context" : "Moreover, in view of the complexity results established in Lan [2013] and the fact that the LOsep oracle is weaker than the LO oracle, the bound on the total number of calls to the LOsep oracle (cf.",
      "startOffset" : 59,
      "endOffset" : 70
    }, {
      "referenceID" : 19,
      "context" : "4 in Lan and Zhou [2014], the total number of phases, S, performed by CALSGD method to find a stochastic -solution of problem (1)-(8) is bounded by (53).",
      "startOffset" : 5,
      "endOffset" : 25
    }, {
      "referenceID" : 24,
      "context" : "However, as shown by Nesterov [2005], the function f(·) in (58) can be closely approximated by a class of smooth convex functions.",
      "startOffset" : 21,
      "endOffset" : 37
    }, {
      "referenceID" : 24,
      "context" : "Moreover, Nesterov [2005] shows that fτ (·) is differentiable and its gradients are Lipschitz continuous with the Lipschitz constant given by Lτ := ‖A‖ 2 τσω .",
      "startOffset" : 10,
      "endOffset" : 26
    }, {
      "referenceID" : 19,
      "context" : "1 in Lan and Zhou [2014], and hence omitted.",
      "startOffset" : 5,
      "endOffset" : 25
    }, {
      "referenceID" : 19,
      "context" : "2 of Lan and Zhou [2014], our first bound in (65) immediately follows.",
      "startOffset" : 5,
      "endOffset" : 25
    }, {
      "referenceID" : 4,
      "context" : "In view of the discussions in Chen et al. [2014], the obtained bound on the total number of operator evaluations (cf.",
      "startOffset" : 30,
      "endOffset" : 49
    }, {
      "referenceID" : 4,
      "context" : "In view of the discussions in Chen et al. [2014], the obtained bound on the total number of operator evaluations (cf. first bound in (65)) is not improvable for solving the saddle point problems in (1)-(58). Moreover, according to Lan [2013] and the fact that the LOsep oracle is weaker than LO oracle, the O(1/ ) bound on the total number of calls to the LOsep is not improvable.",
      "startOffset" : 30,
      "endOffset" : 242
    }, {
      "referenceID" : 18,
      "context" : "As shown by Joulin et al. [2014] this problem can be solved by quadratic programming over a path/flow polytope.",
      "startOffset" : 12,
      "endOffset" : 33
    }, {
      "referenceID" : 13,
      "context" : "In the example of the Birkhoff polytope it almost looks like as if OFW converges suboptimally, however this is due to the large number of iterations required: the convergence rate of OFW as shown by Hazan and Kale [2012] is O(T−1/4), so if we compute the improvement with logarithmic scale, from, e.",
      "startOffset" : 199,
      "endOffset" : 221
    }, {
      "referenceID" : 13,
      "context" : "In the example of the Birkhoff polytope it almost looks like as if OFW converges suboptimally, however this is due to the large number of iterations required: the convergence rate of OFW as shown by Hazan and Kale [2012] is O(T−1/4), so if we compute the improvement with logarithmic scale, from, e.g., iteration 1500 to iteration 4500, we get −1/4(log(1500)− log(4500)) ≈ 0.",
      "startOffset" : 199,
      "endOffset" : 359
    } ],
    "year" : 2017,
    "abstractText" : "In this work we introduce a conditional accelerated lazy stochastic gradient descent algorithm with optimal number of calls to a stochastic first-order oracle and convergence rate O( 1 ε2 ) improving over the projection-free, Online Frank-Wolfe based stochastic gradient descent of Hazan and Kale [2012] with convergence rate O( 1 ε4 ).",
    "creator" : "LaTeX with hyperref package"
  }
}