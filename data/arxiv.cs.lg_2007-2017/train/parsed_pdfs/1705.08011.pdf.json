{
  "name" : "1705.08011.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Convergence Analysis of Batch Normalization for Deep Neural Nets",
    "authors" : [ "Yintai Ma", "Diego Klabjan" ],
    "emails" : [ "yintaima2020@u.northwestern.edu,", "d-klabjan@northwestern.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "1 Introduction\nDeep neural networks (DNN) have shown unprecedented success in various applications such as object detection. However, it still takes a long time to train a DNN until it converges. Ioffe and Szegedy [12] identified an important problem involved in training deep networks, internal covariate shift, and then proposed batch normalization (BN) to decrease this phenomenon. BN addresses this problem by normalizing the distribution of every hidden layer’s input. In order to do so, it calculates the pre-activation mean and standard deviation using mini-batch statistics at each iteration of training and uses these estimates to normalize the input to the next layer. The output of a layer is normalized by using the batch statistics and two new trainable parameters per neuron are introduced that capture the inverse operation. It is now a standard practice [6, 11]. While this approach leads to a significant performance jump, to the best of our knowledge, there is no known theoretical guarantee for the convergence of an algorithm with BN. The difficulty of analyzing the convergence of the BN algorithm comes from the fact that not all of the BN parameters are updated by gradients. Thus it invalidates most of the classical studies of convergence for gradient methods.\nIn this paper, we propose a generalization of the BN algorithm, diminishing batch normalization (DBN), where we update the BN parameters in a diminishing moving average way. It essentially means that the BN layer adjusts its output according to all past mini-batches instead of only the current one. It helps to reduce the problem of the original BN that the output of a BN layer on a particular training pattern depends on the other patterns in the current mini-batch, which is pointed out in Bottou et al. [6]. By setting the layer parameter we introduce into DBN to a specific value, we recover the original BN algorithm.\nWe give a convergence analysis of the algorithm with a two-layer batch-normalized neural network and diminishing stepsizes. We assume two layers (the generalization to multiple layers can be done by using the same approach but substantially complicating the notation) and an arbitrary loss function. The convergence analysis does require linear activations. The main result shows that under diminishing stepsizes on gradient updates and updates on mini-batch statistics, and standard Lipschitz conditions on loss functions DBN converges to a stationary point. As already pointed out the main challenge is the fact that some trainable parameters are updated by gradient while others are updated\nar X\niv :1\n70 5.\n08 01\n1v 1\n[ cs\n.L G\n] 2\n2 M\nay 2\nby a mere recalculation. We also study the convex case where we assume that the overall loss function is convex (which holds if the regularization parameter is large). In this case, we show a sublinear convergence rate towards the global minimum.\nContributions. The main contribution of this paper is in providing a general convergence guarantee for DBN. Specifically, we make the following contributions.\n• In section 4, we show the sufficient and necessary conditions for the stepsizes and diminishing weights to ensure the convergence of BN parameters.\n• We show that the algorithm converges to a stationary point under a general nonconvex objective function.\n• In section 5, we show that decreasing the stepsizes η(m) for trainable parameters sublinearly (i.e., at rate O(1/m)) ensures sublinear convergence to the optimal value with a convex objective function.\nThis paper is organized as follows. In Section 2, we review the related works and the development of the BN algorithm. We formally state our model and algorithm in Section 3. We present our main results in Sections 4 and 5. In Section 6, we numerically show that the DBN algorithm outperforms the original BN algorithm. Proofs are collected in Appendixes A and B in supplemental material.\n2 Literature Review\nBefore the introduction of BN, it has long been known in the deep learning community that input whitening and decorrelation help to speed up the training process. In fact, Orr and Müller [16] show that preprocessing the data by subtracting the mean, normalizing the variance, and decorrelating the input has various beneficial effects for back-propagation. Krizhevsky et al. [14] propose a method called local response normalization which is inspired by computational neuroscience and acts as a form of lateral inhibition, i.e., the capacity of an excited neuron to reduce the activity of its neighbors. Gülçehre and Bengio [10] propose a standardization layer that bears significant resemblance to batch normalization, except that the two methods are motivated by very different goals and perform different tasks.\nInspired by BN, there are several new works taking BN as a basis for further improvements. Layer normalization [3] is much like the BN except that it uses all of the summed inputs to compute the mean and variance instead of the mini-batch statistics. Besides, unlike BN, layer normalization performs exactly the same computation at training and test times. Normalization propagation [2] uses data-independent estimations for the mean and standard deviation in every layer to reduce the internal covariate shift and make the estimation more accurate for the validation phase. Weight normalization also removes the dependencies between the examples in a minibatch so that it can be applied to recurrent models, reinforcement learning or generative models [19]. Cooijmans et al. [7] propose a new way to apply batch normalization to RNN and LSTM models.\nIn view of all these flavors, the original BN method is the most popular technique and for this reason our choice of the analysis. To the best of our knowledge, we are not aware of any prior analysis of BN.\nBN has gradient and non-gradient updates. Thus nonconvex convergence results do not immediately transfer. Our analysis explicitly takes into account the workings of BN. However, nonconvex convergence proofs are relevant since some small portions of our analysis rely on known proofs and approaches.\nNeural nets are not convex, even if the loss function is convex. For classical convergence results with a nonconvex objective function and diminishing learning rate, we refer to survey papers [4, 5, 6]. Bertsekas and Tsitsiklis [5] provide a convergence result with deterministic gradient with errors. Bottou et al. [6] provide a convergence result with stochastic gradient. The classic analyses showing the norm of gradients of the objective function going to zero date back to [9, 18, 17]. For strongly convex objective functions with a diminishing learning rate, we learn the classic convergence results from [6].\n3 Model and Algorithm\nThe optimization problem for a network is a objective function consisting of a large number of component functions, that reads:\nmin f̄(θ, λ) = N∑ i=1 fi(Xi : θ, λ),\nsubject to θ ∈ P, λ ∈ Q, where fi : Rn1 × Rn2 → R, i = 1, ..., N , are real-valued functions for any data record Xi. Index i associates with data record Xi and target response yi (hidden behind the dependency of f on i) in the training set. Parameters θ include the usual parameters updated by gradients directly associated with the loss function, i.e. behind the part that we have a parametric model, while BN parameters λ are introduced by the BN algorithm and not updated by gradient methods but by the mini-batch statistics. We define that the derivative of fi is always taken with respect to θ: ∇fi(Xi : θ, λ) := ∇θfi(Xi : θ, λ). The deep network we analyze here has 2 fully-connected layers with D1 neurons each. Each hidden layer computes y = kWu with slope k for linear activation, i.e. we assume that the activation functions are linear, and u is the input vector of the layer. We do not need to include an intercept term since the BN algorithm automatically adjusts for it. BN is applied to the output of the first hidden layer.\nWe next describe the computation in each layer to show how we obtain the output of the network. The notations introduced here is used in the analysis. Figure 1 shows the full structure of the network. The input data is vector X , which is one of {Xi}Ni=1. Vector λ = ( (µj) D j=1, (σj) D j=1 ) is the set of all\nBN parameters and vector θ = ( W1,W2, (β (1) j ) D j=1, (γ (1) j ) D j=1 ) is the set of all trainable parameters which are updated by gradients. Matrices W1,W2 are the actual model parameters and β, γ are introduced by BN. The jth entry of output of the first hidden layer is\nz (1) j (X : θ) = k (1)W1,j,·X,\nwhere W1,j,· denotes the weights of linear transformations for the jth neuron and k(1) is the slope of the linear activation function for the first hidden layer. The jth entry of batch-normalized output of the first layer is\ny (1) j (X : θ, λ) = γ (1) j\n( z\n(1) j (X, θ)− µj σj + B\n) + β\n(1) j ,\nwhere β(1)j and γ (1) j are trainable parameters updated by gradient and µj and σj are batch normalization parameters for z(1)j . Trainable parameter µj is the mini-batch mean of z (1) j and trainable parameter σj is the mini-batch sample deviation of z (1) j . Constant B is a small offset term to keep the denominator from zero. The output of jth entry of the output layer reads: z\n(2) j (X : θ, λ) = k (2)W2,j,·y (1)(X : θ, λ).\nThe objective function for the ith data record is\nfi(Xi : θ, λ) = li\n(( z\n(2) j (Xi : θ, λ) ) j ) + c2‖θ‖22,\nwhere li(·) is the loss function associated with the target response yi. We have the following complete expression for the objective function for the ith data\nfi(Xi : θ, λ) = li (k(2) D∑ j=1 W2,k,j [ γ (1) j k(1)W1,j,·Xi − µj σj + B + β (1) j ] )k + c2‖θ‖22. The objective function fi(Xi : θ, λ) is nonconvex with respect to θ and λ. However, when c2 is large enough, the regularization term prevails and makes the objective function convex.\n3.1 Algorithm\nAlgorithm 1 shows the algorithm studied herein. There are two deviations from the standard BN algorithm, one of them actually being a generalization. We use the full gradient instead of the more popular stochastic gradient (SG) method. It essentially means that each batch contains the entire training set instead of a randomly chosen subset of the training set. An analysis of SG is potential future research. Although the primary motivation for full gradient update is to reduce the burdensome in showing the convergence, the full gradient method is similar to SG in the sense that both of them go through the entire training set, while full gradient goes through it deterministically and the SG goes through it in expectation. Therefore, it is reasonable to speculate that the SG method has similar convergence property as the full algorithm studied herein.\nAlgorithm 1 DBN: Diminishing Batch-Normalized Network Update Algorithm 1: Initialize θ ∈ Rn1 and λ ∈ Rn2 2: for iteration m=1,2,... do 3: θ(m+1) := θ(m) − η(m) ∑N i=1∇fi(Xi : θ(m), λ(m))\n4: for j=1,...,D1 do 5: µ(m+1)j := 1 N ∑N i=1 z (1) j (Xi : θ (m+1))\n6: σ(m+1)j := √ 1 N ∑N i=1 ( z (1) j (Xi : θ (m+1))− µ(m+1)j )2\n7: λ(m+1) := α(m+1) (\n(µ (m+1) j ) D1 j=1, (σ (m+1) j ) D1 j=1\n) + (1− α(m+1))λ(m)\nThe second difference is that we update the BN parameters (θ, λ) by their moving averages with respect to diminishing α(m). The original BN algorithm can be recovered by setting α(m) = 1 for every m. After introducing diminishing α(m), λ(m) and hence the output of the BN layer is determined by the history of all past data records, instead of those solely in the last batch. Thus the output of the BN layer becomes more general that better reflects the distribution of the entire dataset. We use two strategies to decide the values of α(m). One is to use a constant smaller than 1 for all m, the other one is to decay the α(m) gradually, such as α(m) = 1/m.\nIn our numerical experiment, we show that Algorithm 1 outperforms the original BN algorithm, where both are based on SG and non-linear activation functions with many layers FNN and CNN models.\n4 General Case\nThe main purpose of our work is to show that Algorithm 1 converges. In the general case, we focus on the nonconvex objective function.\n4.1 Assumptions\nHere are the assumptions we used for the convergence analysis.\nAssumption 4.1 (Lipschitz continuity on θ and λ). For every i we have ‖∇fi(X : θ̃, λ)−∇fi(X : θ̂, λ)‖2 ≤ L̄‖θ̃ − θ̂‖2,∀θ̃, θ̂, λ,X.\n‖∇W1,j,·fi(X : θ̃, λ)−∇W1,j,·fi(X : θ̂, λ)‖2 ≤ L̄‖W̃1,j,· − Ŵ1,j,·‖2, ∀λ, θ̃, θ̂, X, j ∈ {1, ..., D1}.\n‖∇fi(X : θ, λ̃)−∇fi(X : θ, λ̂)‖2 ≤ L̄‖λ̃− λ̂‖2,∀θ, λ̃, λ̂,X, j ∈ {1, ..., D1}.\nNoted that the Lipschitz constants associates with each of the above inequalities are not necessarily the same. Here L̄ is an upper bound for these Lipschitz constants for simplicity.\nAssumption 4.2 (bounded parameters). Sets P and Q are compact set, where θ ∈ P and λ ∈ Q. Thus there exists constant M that weights W and parameters λ are bounded element-wise by this constant M .\n‖W1‖ M and ‖W2‖ M and ‖λ‖ M.\nThis also implies that the updated θ, λ in Algorithm 1 remain in P and Q, respectively.\nAssumption 4.3 (diminishing update on θ). The stepsizes of θ update satisfy ∞∑ m=1 η(m) =∞ and ∞∑ m=1 (η(m))2 <∞. (1)\nThis is a common assumption for diminishing stepsizes in optimization problems.\nAssumption 4.4 (Lipschitz continuity of li(·)). Assume the loss function li(·) for every i is continuously differentiable. It implies that there exists M̂ such that\n‖li(x)− li(y)‖ ≤ M̂‖x− y‖,∀x, y.\nAssumption 4.5 (existance of a stationary point). There exists a stationary point (θ∗, λ∗) such that ‖∇f̄(θ∗, λ∗)‖ = 0.\nWe note that all these are standard assumptions in convergence proofs. We also stress that Assumption 4.4 does not directly imply 4.1. Since we assume that P and Q are compact, then Assumptions 4.1, 4.4 and 4.5 hold for many standard loss function such as softmax and MSE.\n4.2 Convergence Analysis\nWe first have the following lemma specifying sufficient conditions for λ to converge. All the proofs are given in Appendix A.\nTheorem 4.6 Under Assumptions 4.1, 4.2 and 4.3, if {α(m)} satisfies ∞∑ m=1 α(m) <∞ and ∞∑ m=1 m∑ n=1 α(m)η(n) <∞, then sequence {λ(m)} converges to λ̄.\nWe give a discussion of the above conditions for α(m) and η(m) in the end of this section. With the help of Theorem 4.6, we can show the following convergence result.\nLemma 4.7 Under Assumptions 4.4, 4.5 and the assumptions of Theorem 4.6, when ∞∑ m=1 ∞∑ i=m i∑ n=1 α(i)η(n) <∞ and ∞∑ m=1 ∞∑ n=m α(n) <∞, (2) we have\nlim sup M→∞ M∑ m=1 η(m)‖∇f̄(θ(m), λ̄)‖22 <∞.\nThis result is similar to the classical convergence rate analysis for the non-convex objective function with diminishing stepsizes, which can be found in [6].\nLemma 4.8 Under the assumptions of Lemma 4.7, we have lim inf m→∞ ‖∇f̄(θ(m), λ̄)‖22 = 0.\nThe statement of this theorem is that for the full gradient method with diminishing stepsizes the gradient norms cannot stay bounded away from zero. The following result characterizes more precisely the convergence property of Algorithm 1.\nLemma 4.9 Under the assumptions stated in Lemma 4.7, we have lim m→∞ ‖∇f̄(θ(m), λ̄)‖22 = 0.\nOur main result is listed next.\nTheorem 4.10 Under the assumptions stated in Lemma 4.7, we have lim m→∞ ‖∇f̄(θ(m), λ(m))‖22 = 0.\nWe cannot show that {θ(m)}’s converge (standard convergence proofs are also unable to show such a stronger statement). For this reason Theorem 4.10 does not immediately follow from Lemma 4.9 together with Theorem 4.6. The statement of Theorem 4.10 would easily follow from Lemma 4.9 if convergence of {θ(m)} is established and the gradient being continuous.\nConsidering the cases η(m) = O( 1 mk ) and α(m) = O( 1 mh ). We show in Appendix B that the set of sufficient and necessary conditions to satisfy the assumptions of Theorem 4.6 are h > 1 and k ≥ 1. The set of sufficient and necessary conditions to satisfy the assumptions of Lemma 4.7 are h > 2 and k ≥ 1. For example, we can pick η(m) = O( 1m ) and α\n(m) = O( 1m2.001 ) to achieve the above convergence result in Theorem 4.10.\n5 Convex Case\nIn this section, we discuss the convergence of a convex objective function. We stress that even if li(·)’s are convex, the overall fi(·)’s are not convex. However, if the l2 penalty coefficient c2 is large enough, then fi(·)’s become convex since the regularization term prevails. We have the following extra assumption for the convexity of our model.\nAssumption 5.1 (strong convexity). The objective function fi is strongly convex in θ for every i. It implies that there exists constant c > 0 such that\nfi(Xi : θ̃, λ) ≥ fi(Xi : θ̂, λ) +∇fi(Xi : θ̂, λ)T (θ̃ − θ̂) + 1\n2 c‖θ̃ − θ̂‖22,∀θ̃, θ̂, i.\nThis inequality is a common result for strongly convex functions. Unfortunately, this convexity assumption is not met by most popular neural network models unless c2 is large. In this section, we assume that c2 is large enough to force such strong convexity.\n5.1 Convex Objective Convergence Analysis\nHere we perform the convergence analysis with the assumption that f(θ, λ) is jointly convex in θ for any fixed λ (which is implied by convexity of each fi(Xi : θ, λ)). The main result establishes a sublinear convergence rate if η(m) are selected as O( 1m ).\nTheorem 5.2 Under Assumptions 4.1, 4.2, 4.3 and 5.1, suppose the stepsizes satisfy that, for\nall m, η(m) = ζ\nϑ+m for some ζ >\n1\ncµ and ϑ > 0. If {α(m)} satisfies ∞∑ m=1 α(m) ln(m) <\n∞, then the optimality gap satisfies f̄(θ(m), λ(m)) − f̄(θ∗, λ̄) ≤ v ϑ+m , where v :=\nmax\n{ ζ2(NL̄M +M1)\n2(ζcc1 − 1) , (ϑ+ 1)[f̄(θ(1), λ(1))− f̄(θ∗, λ̄)]\n} .\nNote that θ∗ is the optimal θ value with respect to the fixed λ̄. Point (θ∗, λ̄) is the point where f̄ attains its minimum. We learn from Theorem 5.2 that decreasing the stepsizes η(m) sublinearly (i.e. at a rate O(1/m)) ensures the sublinear convergence to the optimal value. We also observe that the initial point determines the initial optimality gap, which appears prominently in the second term defining v. With an appropriate initialization phase, we can easily diminish the role played by this term. Related discussions about the choice of constant parameters to ensure a sublinear convergence rate and the initialization can be found in Bottou et al. [6].\nConsidering the cases η(m) = O( 1m ) and α (m) = O( 1 mh ). We show in Appendix B that the set of sufficient and necessary condition to satisfy the assumptions of Theorem 5.2 is h > 1. For example, we can pick η(m) = O( 1m ) and α (m) = O( 1m1.001 ) to achieve the above convergence result.\n6 Computational Experiments\nWe conduct the computational experiments with Theano and Lasagne on a Linux server with an Nvidia Titan-X GPU. We use MNIST [15], CIFAR-10 [13] and Network Intrusion (NI) [1] datasets to compare the performance between DBN and the original BN algorithm. For the MNIST dataset, we use a four-layer fully connected FNN (784× 300× 300× 10) with the ReLU activation function and for the NI dataset, we use a four-layer fully connected FNN (784× 50× 50× 10) with the ReLU activation function. For the CIFAR-10 dataset, we use a reasonably complex CNN network that has a structure of (Conv-Conv-MaxPool-Dropout-Conv-Conv-MaxPool-Dropout-FC-Dropout-FC), where all four convolution layers and the first fully connected layers are batch normalized. We use the softmax loss function and l2 regularization with for all three models. All the trainable parameters are randomly initialized before training. For all 3 datasets, we use the standard epoch/minibatch setting with the minibatch size of 100, i.e., we do not compute the full gradient and the statistics are over the minibatch. We use AdaGrad [8] to update the learning rates η(m) for trainable parameters, starting from 0.01.\nWe use two different strategies to decide the values of α(m) in DBN: constant values of α(m) and diminishing α(m) where α(m) = 1/m and α(m) = 1/m2. We test the choices of constant α(m) ∈ {1, 0.75, 0.5, 0.25, 0.1, 0.01, 0.001, 0}.\nWe test all the choices of α(m) with the performances presented in Figure 2. Figure 2 shows that all the non-zero choices of α(m) converge properly. The algorithms converge without much difference even when α(m) in DBN is very small, e.g., 1/m2. However, if we select α(m) = 0, the algorithm is erratic. Besides, we observe that all the non-zero choices of α(m) converge at a similar rate. The fact that DBN keeps the batch normalization layer stable with a very small α(m) suggests that the BN parameters do not have to be depended on the latest minibatch, i.e. the original BN.\nWe compare a selected sets of the most efficient choices of α(m) in Figures 3 and 4. They show that DBN with α(m) < 1 is more stable than the original BN algorithm. The variances with respect to epochs of the DBN algorithm are obviously smaller than those of the original BN algorithm’s in each figure.\nTable 1 shows the best result obtained from each choice of α(m). Most importantly, it suggests that the choices of α(m) = 1/m and 1/m2 perform better than the original BN algorithm. Besides, all the constant less-than-one choices of α(m) perform better than the original BN, showing the importance of taking the mini-batch history into consideration for the update of the BN parameters. The BN algorithm in each figure converges to similar error rates on test datasets with different choices of α(m) except for the α(m) = 0 case. Among all the models we tested, α(m) = 0.25 is the only one that performs top 3 for all three datasets, thus the most robust choice.\nTo summarize, our numerical experiments show that the DBN algorithm outperforms the original BN algorithm on the MNIST, NI and CIFAT-10 datasets with typical deep FNN and CNN models.\nFuture Directions. On the analytical side, we believe an extension to more than 2 layers is doable with significant augmentations of the notation. A stochastic gradient version is likely to be much more challenging to analyze. A second open question concerns more general activation functions. Instead of the linear activation function assumed in this paper, it would be interesting to analyze more common choices such as Sigmoid, ReLU, and Maxout.\nReferences [1] KDD Cup 1999 Data, 1999. URL http://www.kdd.org/kdd-cup/view/kdd-cup-1999/Data.\n[2] Devansh Arpit, Yingbo Zhou, Bhargava U. Kota, and Venu Govindaraju. Normalization Propagation: A Parametric Technique for Removing Internal Covariate Shift in Deep Networks. In International Conference on Machine Learning, volume 48, page 11, 2016.\n[3] Jimmy Lei Ba, Jamie Ryan Kiros, and Geoffrey E. Hinton. Layer Normalization. arXiv preprint arXiv:1607.06450, 2016.\n[4] Dimitri P. Bertsekas. Incremental gradient, subgradient, and proximal methods for convex optimization: A Survey. Optimization for Machine Learning, 2010(3):1–38, 2011.\n[5] Dimitri P. Bertsekas and John N. Tsitsiklis. Gradient Convergence in Gradient Methods with Errors. SIAM Journal on Optimization, 10:627–642, 2000.\n[6] Léon Bottou, Frank E. Curtis, and Jorge Nocedal. Optimization Methods for Large-Scale Machine Learning. arXiv preprint arXiv:1606.04838, 2016.\n[7] Tim Cooijmans, Nicolas Ballas, César Laurent, and Aaron Courville. Recurrent Batch Normalization. arXiv preprint arXiv:1603.09025, 2016.\n[8] Yoram Duchi, John and Hazan, Elad and Singer. Adaptive Subgradient Methods for Online Learning and Stochastic Optimization. Journal of Machine Learning Research, 12(Jul):2121–2159, 2011.\n[9] L. Grippo. A Class of Unconstrained Minimization Methods for Neural Network Training. Optimization Methods and Software, 4(2):135–150, 1994.\n[10] Çaglar Gülçehre and Yoshua Bengio. Knowledge Matters: Importance of Prior Information for Optimization. Journal of Machine Learning Research, 17(8):1–32, 2016.\n[11] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep Residual Learning for Image Recognition. In Computer Vision and Pattern Recognition, pages 770–778, dec 2016.\n[12] Sergey Ioffe and Christian Szegedy. Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift. In International Conference on Machine Learning, pages 448–456, 2015.\n[13] Alex Krizhevsky and Geoffrey E. Hinton. Learning Multiple Layers of Features from Tiny Images. PhD thesis, 2009.\n[14] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E. Hinton. Imagenet Classification with Deep Convolutional Neural Networks. In Advances in neural information processing systems, pages 1097–1105, 2012.\n[15] Yann LeCun, Léon Bottou, and Yoshua Bengio. Gradient-based learning applied to document recognition. Proceedings of the IEEE, 86(11):2278–2324, 1998.\n[16] Genevieve B. Orr and Klaus-Robert Müller. Neural Networks: Tricks of the Trade. Springer, New York, 2003.\n[17] B. T. Polyak. Introduction to optimization. Translations series in mathematics and engineering. Optimization Software, 1987.\n[18] B. T. Polyak and Y. Z. Tsypkin. Pseudogradient Adaption and Training Algorithms. Automation and Remote Control, 34:45–67, 1973.\n[19] Tim Salimans and Diederik P. Kingma. Weight Normalization: A Simple Reparameterization to Accelerate Training of Deep Neural Networks. In Advances in Neural Information Processing Systems, pages 901–901, 2016.\nSupplementary material for “Convergence Analysis of Batch Normalization for Deep Neural Nets”\n7 Appendix A: Proofs\n7.1 Nomenclature\nSymbol Explanation\nL̄ The Lipschitz constant η Learning rate for gradient algorithm α Weight parameter for batch-normalization update ~x The vector for one record of input data yj The target output vector for the input record ~xj N Size of training set, number of all ~x in one epoch D1 Dimension of the hidden layer\nz (1) j , z (2) j j th entry of output of the first and second hidden layer, respectively n1, n2 Numbers of parameters in θ and λ, respectively θ Set of all trainable parameters updated by its gradient\nW (1),W (2) ∈ θ, weights of linear transformation between layers γ\n(1) j , β (1) j ∈ θ, trainable parameters for batch-normalized output y (1) j\nλ Set of all batch normalization parameters determined by previous updates µj ∈ λ, mean of previous values of z(1)j σj ∈ λ, standard deviation of previous values of z(1)j B The offset for batch normalization transformation\n7.2 Preliminary Results\nProposition 7.1 There exists a constant M such that, for any θ and fixed λ, we have\n‖∇f̄(θ, λ)‖22 ≤M.\nProof. By Assumption 4.5, we know there exists (θ∗, λ∗) such that ‖∇f̄(θ∗, λ∗)‖2 = 0. Then we have\n‖∇f̄(θ, λ)‖2 =‖∇f̄(θ, λ)‖2 − ‖∇f̄(θ∗, λ∗)‖2 =‖∇f̄(θ, λ)‖2 − ‖∇f̄(θ, λ∗)‖2 + ‖∇f̄(θ, λ∗)‖2 − ‖∇f̄(θ∗, λ∗)‖2 ≤‖∇f̄(θ, λ)−∇f̄(θ, λ∗)‖2 + ‖∇f̄(θ, λ∗)−∇f̄(θ∗, λ∗)‖2\n≤ N∑ i=1 ‖∇fi(Xi : θ, λ)−∇fi(Xi : θ, λ∗)‖2 + N∑ i=1 ‖∇fi(Xi : θ, λ∗)−∇fi(Xi : θ∗, λ∗)‖2 ≤NL̄(‖λ− λ∗‖2 + ‖θ − θ∗‖2),\nwhere the last inequality is by Assumption 4.1. We then have\n‖∇f̄(θ, λ)‖22 ≤ N2L̄2(‖λ− λ∗‖2 + ‖θ − θ∗‖2)2 ≤M,\nbecause sets P and Q are compact by Assumption 4.2.\nProposition 7.2 We have\nfi(X : θ̃, λ) ≤ fi(X : θ̂, λ) +∇fi(X : θ̂, λ)T (θ̃ − θ̂) + 1\n2 L̄‖θ̃ − θ̂‖22,∀θ̃, θ̂, X.\nProof. This is a known result of the Lipschitz-continuous condition that can be found in [6]. We have this result together with Assumption 4.1.\n7.3 Proof of Theorem 4.6 Lemma 7.3 When ∑∞ m=1 α (m) <∞ and ∑∞ m=1 ∑m n=1 α (m)η(n) <∞,\nµ̃ (m) j :=\nµ (m) j\n(1− α(1))(1− α(2))...(1− α(m)) is a Cauchy series.\nProof. By Algorithm 1, we have\nµ (m) j = α\n(m) 1\nN N∑ i=1 k(1)W (m) 1,j,·Xi + (1− α (m))µ (m−1) j . (3)\nWe define α̃(m) := α(m)\n(1− α(1))(1− α(2))...(1− α(m)) and ∆W (m)1,j,· := W (m) 1,j,· −W (m−1) 1,j,· . After\ndividing (3) by (1− α(1))(1− α(2))...(1− α(m)), we obtain\nµ̃ (m) j = α̃\n(m)k(1) 1\nN N∑ i=1 W (m) 1,j,·Xi + µ̃ (m−1) j .\nThen we have\n|µ̃(m+1)j − µ̃ (m) j | = α̃ (m)|k(1)| 1 N N∑ i=1 ( |W (m)1,j,·Xi| )\n= α̃(m)|k(1)| 1 N N∑ i=1 | m∑ n=1 ∆W (n) 1,j,·Xi| (4)\n= α̃(m)|k(1)| 1 N N∑ i=1 ∣∣∣∣∣ m∑ n=1 ( η(n) N∑ l=1 ∇W1,j,·fl(Xl : θ(n), λ(n)) ) ·Xi ∣∣∣∣∣ = α̃(m)|k(1)| 1\nN N∑ i=1 m∑ n=1\n( η(n) ∣∣∣∣∣ ( N∑ l=1 ∇W1,j,·fl(Xl : θ(n), λ(n)) ) ·Xi ∣∣∣∣∣ )\n≤ α̃(m)|k(1)| 1 N N∑ i=1 m∑ n=1\n( η(n)‖\nN∑ l=1 ∇W1,j,·fl(Xl : θ(n), λ(n))‖ · ‖Xi‖\n) (5)\n=α̃(m)|k(1)| 1 N ·\nN∑ i=1 m∑ n=1\n( η(n)‖\nN∑ l=1 [ ∇W1,j,·fl(Xl : θ(n), λ(n))−∇W1,j,· f̄(Xl : θ∗, λ∗) ] ‖ · ‖Xi‖\n)\n≤ α̃(m)|k(1)| 1 N N∑ i=1 m∑ n=1 η(n)( N∑ l=1 [‖∇W1,j,·fl(Xl : θ(n), λ(n))−∇W1,j,·fl(Xl : θ∗, λ(n))‖2+\n‖∇W1,j,·fl(Xl : θ∗, λ(n))−∇W1,j,·fl(Xl : θ∗, λ∗)‖2] · ‖Xi‖2)\n≤ α̃(m)|k(1)| N∑ i=1 m∑ n=1 η(n) ( L̄ · (‖W (n)1,j,· −W ∗ 1,j,·‖2 + ‖λ (n) j,· − λ ∗ j,·‖2) · ‖Xi‖2 ) ≤ α̃(m)\nm∑ n=1 ( η(n) ) |k(1)| N∑ i=1 ( 2L̄M‖Xi‖2 ) (6)\n≤ α̃(m) m∑ n=1 η(n)M̃L̄,M .\nEquation (4) is due to\nW (m) 1,i,j = m∑ n=1 ∆W (n) 1,i,j .\nTherefore,\n|µ̃(p)j − µ̃ (q) j | ≤ M̃L̄,M · q∑ m=p α̃(m) m∑ n=1 η(n)\n= M̃L̄,M · q∑\nm=p α̃(m) m∑ n=1 η(n) = M̃L̄,M · q∑ m=p m∑ n=1 α̃(m)η(n).\n(7)\nIt remains to show that ∞∑ m=1 α(m) <∞, (8)\n∞∑ m=1 m∑ n=1 α(m)η(n) <∞, (9)\nimplies the convergence of {µ̃(m)}. By (8), we have Π∞m=1(1− α(m)) > 0,\nsince\nln(Π∞m=1(1− α(m))) = ∞∑ m=1 ln(1− α(m)) > ∞∑ m=1 −α(m) > −∞.\nIt is also easy to show that there exists C and Mc such that for all m ≥Mc, we have (1− α(1))(1− α(2)) . . . (1− α(m)) ≥ C. (10)\nTherefore, lim m→∞ (1− α(1))(1− α(2)) . . . (1− α(m)) ≥ C.\nThus the following holds:\nα̃(m) ≤ 1 C α(m) (11)\nand q∑\nm=p m∑ n=1 α̃(m)η(n) ≤ 1 C q∑ m=p m∑ n=1 α(m)η(n). (12)\nFrom (9) and (12) it follows that the sequence {µ̃(m)j } is a Cauchy series.\nLemma 7.4 Since {µ̃(m)j } is a Cauchy series, {µ (m) j } is a Cauchy series.\nProof. We know that µ\n(m) j = µ̃ (m) j (1− α (1))...(1− α(m)).\nSince lim m→∞ µ̃ (m) j → µ̃j\nand lim m→∞ (1− α(1))...(1− α(m))→ C̃,\nwe have lim m→∞ µ (m) j → µ̃j · C̃.\nThus µ(m)j is a Cauchy series.\nLemma 7.5 If ∑∞ m=1 α (m) <∞ and ∑∞ m=1 ∑m n=1 α (m)η(n) <∞, {σ(m)j } is a Cauchy series.\nProof. We define σ(m)j := σ̃ (m) j (1− α(1))...(1− α(m)). Then we have\n|σ̃(m+1)j − σ̃ (m) j | = α̃ (m) √√√√ 1 N N∑ i=1 ( k(1)W (m) 1,j,·Xi − µ (m) j )2\n= α̃(m) 1√ N √√√√ N∑ i=1 ( k(1)W (m) 1,j,·Xi − µ (m) j )2\n= α̃(m) |k(1)|√ N √√√√ N∑ i=1 ( W (m) 1,j,·Xi − µ (m) j k(1) )2 .\nSince {µ(m)j } is convergent, there exists c1, c2 and N1 such that for any m > N1, −∞ < c1 < µ\n(m) j < c2 <∞. Therefore,\n|σ̃(m+1)j − σ̃ (m) j |\n≤α̃(m) |k (1)|√ N ·max  √√√√ N∑\ni=1\n( W\n(m) 1,j,·Xi − c1 k(1)\n)2 , √√√√ N∑ i=1 ( W (m) 1,j,·Xi − c2 k(1) )2 . (13)\nFor any C̄ ∈ { c1 k(1) , c2 k(1) } , we have\n|σ̃(m+1)j − σ̃ (m) j | ≤ α̃ (m) |k(1)|√ N · √√√√ N∑ i=1 ( W (m) 1,j,·Xi − C̄ )2 (14)\n≤ α̃(m) |k (1)|√ N · √√√√ N∑ i=1 ( |W (m)1,j,·Xi|+ |C̄| )2 (15)\n= α̃(m) |k(1)|√ N · √√√√ N∑ i=1 ( | ( m∑ n=1 ∆W (n) 1,j,· ) Xi|+ |C̄| )2\n= α̃(m) |k(1)|√ N · √√√√ N∑ i=1 ( | m∑ n=1 ( η(n) · N∑ l=1 ∇W1,j,·fl(Xl : θ(n), λ(n)) ·Xi ) |+ |C̄| )2\n≤ α̃(m) |k (1)|√ N · √√√√ N∑ i=1 ( m∑ n=1 ( η(n) · | N∑ l=1 ∇W1,j,·fl(Xl : θ(n), λ(n)) ·Xi| ) + |C̄| )2 (16)\n≤ α̃(m) |k (1)|√ N · √√√√ N∑ i=1 ( m∑ n=1 η(n)‖ N∑ l=1 ∇W1,j,·fl(Xl : θ(n), λ(n))‖ · ‖Xi‖+ |C̄| )2 (17)\n≤ α̃(m) |k (1)|√ N · √√√√ N∑ i=1 ( m∑ n=1 η(n) ( 2NL̄M‖Xi‖2 ) + |C̄| )2 (18)\n≤ α̃(m) |k (1)|√ N · √√√√N ·(M̃L̄,M m∑ n=1 η(n) + |C̄| )2 (19)\n= α̃(m)|k(1)| · √√√√(M̃L̄,M m∑ n=1 η(n) + |C̄| )2\n= α̃(m)|k(1)| · ( M̃L̄,M m∑ n=1 η(n) + |C̄| ) . (20)\nInequality (14) is by plugging C̄ ∈ { c1 k(1) , c2 k(1) } into (13). Inequality (15) is by the following fact:√√√√ n∑\ni=1\n(ai − c)2 ≤ max  √√√√ n∑\ni=1\n(|ai| − c)2, √√√√ n∑ i=1 (|ai|+ c)2  = √√√√ n∑ i=1 (|ai|+ |c|)2, (21)\nwhere b and ai for every i are arbitrary real scalars. Besides, (21) is due to −2aic ≤ max{−2|ai|c, 2|ai|c}.\nInequalities (16), (17) and (18) follow from the square function being increasing for nonnegative numbers. Besides these facts, (18) is also by the same techniques we used in (5)-(6) where we bound the derivatives with the Lipschitz continuity in the following inequality:\n‖ N∑ l=1 ∇W1,j,·fl(Xl : θ(n), λ(n))‖ ≤ 2NL̄M.\nInequality (19) is by collecting the bounded terms into a single bound M̃L̄,M . Therefore,\n|σ̃(q)j − σ̃ (p) j | ≤ q−1∑ m=p |σ̃(m+1)j − σ̃ (m) j | ≤ q−1∑ m=p α̃(m)|k(1)| · ( M̃L̄,M m∑ n=1 η(n) + |C̄| ) . (22)\nUsing the similar methods in deriving (8) and (9), it can be seen that a set of sufficient conditions ensuring the convergence for {σ̃(m)j } is:\n∞∑ m=1 α(m) <∞,\n∞∑ m=1 m∑ n=1 α(m)η(n) <∞.\nTherefore, the convergence conditions for {σ(m)j } are the same as for {µ (m) j }.\nIt is clear that these lemmas establish the proof of Theorem 4.6.\n7.4 Consequences of Theorem 4.6\nProposition 7.6 Under the assumptions of Theorem 4.6, we have |λ(m) − λ̄|∞ ≤ am,\nwhere\nam = M1 ∞∑ i=m i∑ j=1 α(i)η(j) +M2 ∞∑ i=m α(i) (23)\nand M1 and M2 are constants.\nProof. For the upper bound of σ(m)j , by (20), we have\n|σ̃(q)j − σ̃ (p) j | ≤ q−1∑ m=p α̃(m)|k(1)| ( M̃L̄,M m∑ n=1 η(n) + |C̄| ) .\nWe define˜̄σj := σ̄j\n(1− α(1))...(1− α(u))... . Therefore,\n|̃̄σj − σ̃(m)j | ≤ ∞∑ i=m α̃(i)|k(1)| M̃L̄,M i∑ j=1 η(j) + |C̄|  ≤ |k\n(1)| C ∞∑ i=m α(i) M̃L̄,M i∑ j=1 η(j) + |C̄|  . (24)\nThe first inequality comes by substituting p by m and by taking lim as q →∞ in (22). The second inequality comes from (10). We then obtain,\n∣∣∣σ(m)j − σ̄j ∣∣∣ =(1− α(1))...(1− α(m)) ∣∣∣∣∣ σ (m) j (1− α(1))...(1− α(m)) − σ̄j (1− α(1))...(1− α(m))\n∣∣∣∣∣ ≤(1− α(1))...(1− α(m))[ ∣∣∣∣∣ σ (m) j (1− α(1))...(1− α(m)) − σ̄j (1− α(1))...(1− α(u))...\n∣∣∣∣∣+∣∣∣∣ σ̄j(1− α(1))...(1− α(m)) − σ̄j(1− α(1))...(1− α(u))... ∣∣∣∣]\n≤ ∣∣∣σ̃(m)j − σ̃(∞)j ∣∣∣+ ∣∣∣∣ σ̄j(1− α(1))...(1− α(m)) − σ̃(∞)j ∣∣∣∣ = ∣∣∣σ̃(m)j − σ̃(∞)j ∣∣∣+ ∣∣∣∣ σ̄j(1− α(1))...(1− α(m)) − σ̄j(1− α(1))...(1− α(u))...\n∣∣∣∣ = ∣∣∣σ̃(m)j − σ̃(∞)j ∣∣∣+ σ̄j ∣∣∣∣ (1− α(m+1))...(1− α(u))...− 1(1− α(1))...(1− α(u))...\n∣∣∣∣ ≤ ∣∣∣σ̃(m)j − σ̃(∞)j ∣∣∣+ σ̄jC |1− (1− α(m+1))...(1− α(u))...| ≤ ∣∣∣σ̃(m)j − σ̃(∞)j ∣∣∣+ σ̄jC ∞∑ n=m+1 α(n).\n(25)\nThe second inequality is by (1− α(1))...(1− α(m)) < 1, the third inequality is by (10) and the last inequality can be easily seen by induction. By (25), we obtain\n|σ̄j − σ(m)j | = lim M→∞ |σ(M)j − σ (m) j | ≤ |σ̃j − σ̃ (m) j |+ σ̄j C ∞∑ n=m+1 α(n). (26)\nTherefore, we have\n|σ̄j − σ(m)j |\n≤|̃̄σj − σ̃(m)j |+ σ̄j C ∞∑ n=m+1 α(n) ≤ ∞∑ i=m α̃(i)|k(1)| · M̃L̄,M i∑ j=1 η(j) + |C̄| + σ̄j C ∞∑ i=m+1 α(i) ≤ ∞∑ i=m 1 C α(i)|k(1)| · M̃L̄,M i∑ j=1 η(j) + |C̄| + σ̄j C ∞∑ i=m+1 α(i) ≤ ∞∑ i=m 1 C α(i)|k(1)| · M̃L̄,M i∑ j=1 η(j) + |C̄| + σ̄j C ∞∑ i=m α(i)\n= M̃L̄,M |k(1)|\nC\n∞∑ i=m i∑ j=1 α(i)η(j) + ( σ̄j C + |k(1)||C̄| C ) ∞∑ i=m α(i).\n(27)\nThe first inequality is by (26), the second inequality is by (22), the third inequality is by (11) and the fourth inequality is by adding the nonnegative term σ̄j C α(m) to the right-hand side. For the upper bound of µ(m)j , we have∣∣∣µ(m)j − µ̄j ∣∣∣ =(1− α(1))...(1− α(m)) ∣∣∣∣∣ µ (m) j (1− α(1))...(1− α(m)) − µ̄j (1− α(1))...(1− α(m))\n∣∣∣∣∣ ≤(1− α(1))...(1− α(m))[ ∣∣∣∣∣ µ (m) j (1− α(1))...(1− α(m)) − µ̄j (1− α(1))...(1− α(∞))\n∣∣∣∣∣+∣∣∣∣ µ̄j(1− α(1))...(1− α(m)) − µ̄j(1− α(1))...(1− α(∞)) ∣∣∣∣]\n≤ ∣∣∣µ̃(m) − µ̃(∞)∣∣∣+ ∣∣∣∣ µ̄j(1− α(1))...(1− α(m)) − µ̃(∞) ∣∣∣∣ .\n(28)\nLet us define Am := ∣∣µ̃(m) − µ̃(∞)∣∣ and Bm := ∣∣∣∣ µ̄j(1− α(1))...(1− α(m)) − µ̃(∞) ∣∣∣∣. Recall from Theorem 4.6 that {µ(m)j } is a Cauchy series, by (7),\n|µ̃(p)j − µ̃ (q) j | ≤ M̄L̄,M · q∑ m=p m∑ n=1 α(m)η(n).\nTherefore, the first term in (28) is bounded by\n|µ̃(m)j − µ̃ ∞ j | ≤ M̃L̄,M · ∞∑ i=m i∑ n=1 α(i)η(n) <∞. (29)\nFor the second term in (28), recall that C := (1− α(1))...(1− α(u)).... Then we have C · ∣∣∣∣ µ̄j(1− α(1))...(1− α(m)) − µ̃(∞) ∣∣∣∣ =µ̄j |1− (1− α(m+1))...(1− α(u))...|\n≤µ̄j ∞∑\ni=m+1\nα(i),\nwhere the last inequality can be easily seen by induction. Therefore, the second term in (28) is bounded by ∣∣∣∣ µ̄j(1− α(1))...(1− α(m)) − µ̃(∞) ∣∣∣∣ ≤ µ̄jC ∞∑\ni=m+1\nα(i). (30)\nFrom these we obtain ∣∣∣µ(m)j − µ̄j ∣∣∣ ≤ ∣∣∣µ̃(m) − µ̃(∞)∣∣∣+ ∣∣∣∣ µ̄j(1− α(1))...(1− α(m)) − µ̃(∞)\n∣∣∣∣ ≤M̃L̄,M\n∞∑ i=m i∑ n=1 α(i)η(n) + µ̄j C ∞∑ i=m+1 α(i).\n(31)\nThe first inequality is by (28) and the second inequality is by (29) and (30). Combining (27) and (31), we have that\n|λ(m) − λ̄|∞ = max(|µ(m) − µ̄|∞, |σ(m) − σ̄|∞) ≤M1 ∞∑ i=m i∑ j=1 α(i)η(j) +M2 ∞∑ i=m α(i),\nwhere M1 and M2 are constants defined as\nM1 = max( M̃L̄,M |k(1)|\nC , M̄L̄,M )\nand\nM2 = max( σ̄j + |k(1)||C̄| C , µ̄j C ).\nProposition 7.7 Under the assumptions of Theorem 4.6, −∇f̄(θ(m), λ̄)T · ∇f̄(θ(m), λ(m)) ≤ −‖∇f̄(θ(m), λ̄)‖2 + L̄M √ n2am, where am is defined in Proposition 7.6.\nProof. For simplicity of the proof, let us define\nx(m) := ∇f̄(θ(m), λ̄), y(m) := ∇f̄(θ(m), λ(m)). We have\n|x(m) − y(m)|∞ ≤ ‖x(m) − y(m)‖2 ≤ L̄‖λ(m) − λ̄‖2 ≤ L̄ √ n2‖λ(m) − λ̄‖∞ ≤ L̄ √ n2am, (32) where √ n2 is the dimension of λ. The second inequality is by Assumption 4.1 and the fourth inequality is by Proposition 7.6. Inequality (32) implies that for all m and i, we have\n|x(m)i − y (m) i | ≤ L̄ √ n2am.\nIt remains to show\n− ∑ i y (m) i x (m) i ≤ − ∑ i x (m) i 2 + L̄M √ n2am,∀i,m. (33)\nThis is established by the following four cases.\n1) If x(m)i ≥ 0, x (m) i − y (m) i ≥ 0, then x (m) i ≤ L̄ √ n2am + y (m) i . Thus −x (m) i y (m) i ≤ −x (m) i 2 + L̄M √ n2am by Proposition 7.1.\n2) If x(m)i ≥ 0, x (m) i −y (m) i ≤ 0, then x (m) i ≤ y (m) i , x (m) i 2 ≤ x(m)i ·y (m) i and−x (m) i y (m) i ≤ −x (m) i 2 .\n3) If x(m)i < 0, x (m) i −y (m) i ≥ 0, then x (m) i ≥ y (m) i , x (m) i 2 ≤ x(m)i ·y (m) i and−x (m) i y (m) i ≤ −x (m) i 2 .\n4) If x(m)i < 0, x (m) i −y (m) i ≤ 0, then y (m) i −x (m) i ≤ L̄ √ n2am, y (m) i x (m) i −x (m) i 2 ≥ L̄√n2amx(m)i and −y(m)i x (m) i ≤ −x (m) i 2 − L̄√n2amx(m)i ≤ −x (m) i 2 + L̄M √ n2am. The last inequality is by Proposition 7.1.\nAll these four cases yield (33).\nProposition 7.8 Under the assumptions of Theorem 4.6, we have\nf̄(θ(m+1), λ̄) ≤ f̄(θ(m), λ̄)− η(m)‖∇f̄(θ(m), λ̄)‖22 + η(m)L̄M √ n2am + 1\n2 (η(m))2 ·NL̄M,\nwhere M is a constant and am is defined in Proposition 7.6.\nProof. By Proposition 7.2,\nfi(Xi : θ̃, λ) ≤ fi(Xi : θ̂, λ) +∇fi(Xi : θ̂, λ)T (θ̃ − θ̂) + 1\n2 L̄‖θ̃ − θ̂‖22.\nTherefore, we can sum it over the entire training set from i = 1 to N to obtain\nf̄(θ̃, λ) ≤ f̄(θ̂, λ) +∇f̄(θ̂, λ)T (θ̃ − θ̂) + N 2 L̄‖θ̃ − θ̂‖22. (34)\nIn Algorithm 1, we define the update of θ in the following full gradient way:\nθ(m+1) := θ(m) − η(m) · N∑ i=1 ·∇fi(Xi : θ(m), λ(m)),\nwhich implies θ(m+1) − θ(m) = −η(m) · ∇f̄(θ(m), λ(m)). (35)\nBy (35) we have θ̃− θ̂ = θ(m+1) − θ(m) = −η(m)∇f̄(θ(m), λ(m)). We now substitute θ̃ := θ(m+1), θ̂ := θ(m) and λ := λ̄ into (34) to obtain\nf̄(θ(m+1), λ̄)\n≤ f̄(θ(m), λ̄)− η(m)∇f̄(θ(m), λ̄)T∇f̄(θ(m), λ(m)) + (η(m))2 · NL̄ 2 ‖∇f̄(θ(m), λ(m))‖22 ≤ f̄(θ(m), λ̄)− η(m)∇f̄(θ(m), λ̄)T∇f̄(θ(m), λ(m)) + (η(m))2 · NL̄M 2\n≤ f̄(θ(m), λ̄) + η(m) ( −‖∇f̄(θ(m), λ̄)‖22 + L̄M √ n2am ) + 1\n2 (η(m))2 ·NL̄M\n= f̄(θ(m), λ̄)− η(m)‖∇f̄(θ(m), λ̄)‖22 + η(m)L̄M √ n2am + 1\n2 (η(m))2 ·NL̄M.\n(36)\nThe first inequality is by plugging (35) into (34), the second inequality comes from Proposition 7.1 and the third inequality comes from Proposition 7.7.\n7.5 Proof of Theorem 4.10\nHere we show Theorem 4.10 as the consequence of Theorem 4.6 and Lemmas 4.7, 4.8 and 4.9.\n7.5.1 Proof of Lemma 4.7\nHere we show Lemma 4.7 as the consequence of Lemmas 7.9, 7.10 and 7.11.\nLemma 7.9 ∞∑ m=1 ∞∑ i=m i∑ n=1 α(i)η(n) <∞ and ∞∑ m=1 ∞∑ n=m α(n) <∞ is a set of sufficient condition to ensure ∞∑ m=1 |σ̄j − σ(m)j | <∞,∀j. (37)\nProof. By plugging (26) and (24) into (37), we have the following for all j:\n∞∑ m=1 ∣∣∣σ̄j − σ(m)j ∣∣∣ ≤ ∞∑ m=1 ( |̃̄σj − σ̃(m)j |+ σ̄j C ∞∑ n=m+1 α(n) ) ≤ ∞∑ m=1  |k(1)| C ∞∑ i=m α(i) M̃L̄,M i∑ j=1 η(j) + |C̄| + σ̄j C ∞∑ n=m+1 α(n)\n ≤ |k(1)| · M̃L̄,M\nC\n∞∑ m=1 ∞∑ i=m α(i) i∑ j=1 η(j) + σ̄j + |k(1)||C̄| C ∞∑ m=1 ∞∑ n=m+1 α(n).\n(38)\nIt is easy to see that the the following conditions are sufficient for right-hand side of (38) to be finite:\n∞∑ m=1 ∞∑ i=m i∑ n=1 α(i)η(n) <∞\nand\n∞∑ m=1 ∞∑ n=m α(n) <∞.\nTherefore, we obtain ∞∑ m=1 |σ̄j − σ(m)j | <∞,∀j.\nLemma 7.10 Under Assumption 4.4,\n∞∑ m=1 ∞∑ i=m i∑ n=1 α(i)η(n) <∞ and ∞∑ m=1 ∞∑ n=m α(n) <∞\nis a set of sufficient conditions to ensure\nlim sup M→∞ M∑ m=1 ∣∣∣f̄(θ(m), λ(m))− f̄(θ(m), λ̄)∣∣∣ <∞. Proof. By Assumption 4.4, we have\n‖li(x)− li(y)‖ ≤ M̂‖x− y‖ ≤ M̂ D∑ i=1 |xi − yi|. (39)\nBy the definition of fi(·), we then have ∞∑ m=1 ∣∣∣f̄(θ(m), λ(m))− f̄(θ(m), λ̄)∣∣∣ =\n∞∑ m=1 ∣∣∣∣∣ N∑ i=1 ( li(Xi : θ (m), λ(m)) + c2‖θ(m)‖22 ) − N∑ i=1 ( li(Xi : θ (m), λ̄) + c2‖θ(m)‖22 )∣∣∣∣∣\n= ∞∑ m=1 ∣∣∣∣∣ N∑ i=1 ( li(Xi : θ (m), λ(m))− li(Xi : θ(m), λ̄) )∣∣∣∣∣\n≤ ∞∑ m=1 N∑ i=1 ∣∣∣(li(Xi : θ(m), λ(m))− li(Xi : θ(m), λ̄))∣∣∣ ≤M2\n∞∑ m=1 D∑ j=1 N∑ i=1 ∣∣∣∣∣k(1)W (m) 1,j,·Xi − µ (m) j σ (m) j + B − k(1)W (m) 1,j,·Xi − µ̄j σ̄j + B ∣∣∣∣∣ =M2\n∞∑ m=1 D∑ j=1 N∑ i=1 (∣∣∣∣∣(k(1)W (m)1,j,·Xi) (\n1\nσ (m) j + B\n− 1 σ̄j + B\n) +\nµ̄j σ̄j + B − µ\n(m) j\nσ (m) j + B\n∣∣∣∣∣ )\n≤M2 ∞∑ m=1 D∑ j=1 N∑ i=1 (∣∣∣∣∣(k(1)W (m)1,j,·Xi) (\n1\nσ (m) j + B\n− 1 σ̄j + B )∣∣∣∣∣+ ∣∣∣∣∣ µ̄jσ̄j + B − µ (m) j\nσ (m) j + B\n∣∣∣∣∣ )\n≤M3 ∞∑ m=1 D∑ j=1 ( N∑ i=1 |(k(1)W (m)1,j,·Xi)| ∣∣∣∣∣ 1σ(m)j + B − 1 σ̄j + B ∣∣∣∣∣+ N∑ i=1 ∣∣∣∣∣ µ̄jσ̄j + B − µ (m) j σ (m) j + B ∣∣∣∣∣ )\n=M3 ∞∑ m=1 D∑ j=1 ( N∑ i=1 |(k(1)W (m)1,j,·Xi)| ∣∣∣∣∣ σ̄j − σ (m) j (σ (m) j + B)(σ̄j + B) ∣∣∣∣∣+N ∣∣∣∣∣ µ̄jσ̄j + B − µ (m) j σ (m) j + B ∣∣∣∣∣ ) ≤M3 ∞∑ m=1 D∑ j=1 ( N∑ i=1 |k(1)||W (m)1,j,·Xi| ∣∣∣∣∣ σ̄j − σ (m) j 2B ∣∣∣∣∣+N ∣∣∣∣∣ µ̄jσ̄j + B − µ (m) j σ (m) j + B ∣∣∣∣∣ ) . (40)\nThe first inequality is by the Cauchy-Schwarz inequality, and the second one is by (39). To show the finiteness of (40), we only need to show the following two statements:\n∞∑ m=1 N∑ i=1 |k(1)||W (m)1,j,·Xi| ∣∣∣∣∣ σ̄j − σ (m) j 2B ∣∣∣∣∣ <∞,∀j (41) and\n∞∑ m=1 ∣∣∣∣∣ µ̄jσ̄j + B − µ (m) j σ (m) j + B ∣∣∣∣∣ <∞,∀j. (42) Proof of (41): For all j we have\n∞∑ m=1 N∑ i=1 |k(1)||W (m)1,j,·Xi| ∣∣∣∣∣ σ̄j − σ (m) j 2B ∣∣∣∣∣ ≤ ∞∑ m=1 |k(1)|NDM max i ‖Xi‖ 1 2B\n∣∣∣σ̄j − σ(m)j ∣∣∣ =|k(1)|NDM max\ni ‖Xi‖\n1 2B ∞∑ m=1\n∣∣∣σ̄j − σ(m)j ∣∣∣ . (43)\nThe inequality comes from |W (m)1,j,·Xi| ≤ DM‖Xi‖2, where D is the dimension of Xi and M is the element-wise upper bound for W (m)1,j,· in Assumption 4.2.\nFinally, we invoke Lemma 7.3 to assert that ∑∞ m=1 ∣∣∣σ̄j − σ(m)j ∣∣∣ is finite. Proof of (42): For all j we have\n∞∑ m=1 ∣∣∣∣∣ µ̄jσ̄j + B − µ (m) j σ (m) j + B ∣∣∣∣∣ ≤ ∞∑ m=1 ∣∣∣∣∣ µ̄jσ̄j + B − µ (m) j σ̄j + B ∣∣∣∣∣+ ∞∑ m=1 ∣∣∣∣∣ µ (m) j σ̄j + B − µ (m) j σ (m) j + B ∣∣∣∣∣ . (44)\nThe first term in (44) is finite since {µ(m)j } is a Cauchy series. For the second term, we know that there exists a constant M such that for all m ≥M , µ(m)j ≤ µ̄+1. This is also by the fact that {µ (m) j } is a Cauchy series and it converges to µ̄. Therefore, the second term in (44) becomes M−1∑ m=1 ∣∣∣∣∣ µ (m) j σ̄j + B − µ (m) j σ (m) j + B ∣∣∣∣∣+ ∞∑ m=M ∣∣∣∣∣ µ (m) j σ̄j + B − µ (m) j σ (m) j + B\n∣∣∣∣∣ ≤ M−1∑ m=1 ∣∣∣∣∣ µ (m) j σ̄j + B − µ (m) j σ (m) j + B ∣∣∣∣∣+ ∞∑ m=M (µ̄+ 1) ∣∣∣∣∣ 1σ̄j + B − 1σ(m)j + B ∣∣∣∣∣ .\n(45)\nNoted that function f(σ) = 1\nσ + B is Lipschitz continuous since its gradient is bounded by\n1 2B .\nTherefore we can choose 1\n2B as the Lipschitz constant for f(σ). We then have the following\ninequality: ∣∣∣∣∣ 1σ̄j + B − 1σ(m)j + B ∣∣∣∣∣ ≤ 1 2B |σ̄j − σ(m)j |. (46)\nPlugging (46) into (45), we obtain M−1∑ m=1 ∣∣∣∣∣ µ (m) j σ̄j + B − µ (m) j σ (m) j + B ∣∣∣∣∣+ ∞∑ m=M (µ̄+ 1) ∣∣∣∣∣ 1σ̄j + B − 1σ(m)j + B ∣∣∣∣∣\n≤ M−1∑ m=1 ∣∣∣∣∣ µ (m) j σ̄j + B − µ (m) j σ (m) j + B ∣∣∣∣∣+ ∞∑ m=M (µ̄+ 1) 2B |σ̄j − σ(m)j |,\nwhere the first term is finite by the fact that M is a finite constant. We have shown the condition for the second term to be finite in Lemma 7.9. Therefore,\n∞∑ m=1 ∣∣∣∣∣ µ̄jσ̄j + B − µ (m) j σ (m) j + B ∣∣∣∣∣ <∞,∀j. By (41) and (42), we have that the right-hand side of (40) is finite. It means that the left-hand side of (40) is finite. Thus,\n∞∑ m=1 ∣∣∣f̄(θ(m), λ(m))− f̄(θ(m), λ̄)∣∣∣ <∞. Lemma 7.11 If\n∞∑ m=1 ∞∑ i=m i∑ n=1 α(i)η(n) <∞ and ∞∑ m=1 ∞∑ n=m α(n) <∞,\nthen\nlim sup M→∞ M∑ m=1 η(m)‖∇f̄(θ(m), λ̄)‖22 <∞.\nProof. For simplicity of the proof, we define\nT (M) := M∑ m=1 η(m)‖∇f̄(θ(m), λ̄)‖22,\nO(m) := f̄(θ(m+1), λ(m+1))− f̄(θ(m), λ(m)),\n∆ (m+1) 1 := f̄(θ (m+1), λ(m+1))− f̄(θ(m+1), λ̄),\n∆ (m) 2 := f̄(θ (m+1), λ̄)− f̄(θ(m), λ̄),\nwhere λ̄ is the converged value of λ in Theorem 4.6. Therefore,\nO(m) = ∆ (m+1) 1 + ∆ (m) 1 + ∆ (m) 2 ≤ |∆ (m+1) 1 |+ |∆ (m) 1 |+ ∆ (m) 2 . (47)\nBy Proposition 7.8,\n∆ (m) 2 ≤ −η(m)‖∇f̄(θ(m), λ̄)‖22 + η(m)L̄M √ n2am + 1\n2 (η(m))2 ·NL̄M. (48)\nWe sum the inequality (47) from 1 to K with respect to m and plug (48) into it to obtain\nK∑ m=1 O(m) ≤ K∑ m=1 |∆(m+1)1 |+ K∑ m=1 |∆(m)1 | − K∑ m=1 {η(m)‖∇f̄(θ(m), λ̄)‖22}\n+ K∑ m=1 η(m)L̄M √ n2am + K∑ m=1 {1 2 (η(m))2NL̄M}\n= K∑ m=1 |∆(m+1)1 |+ K∑ m=1 |∆(m)1 | − T (K)\n+ L̄2 √ n2 · K∑ m=1 η(m)am + K∑ m=1 {1 2 (η(m))2NL̄M}.\nFrom this, we have:\nlim sup K→∞ T (K) ≤ lim sup K→∞ −1 c1 (f̄(θ(K), λ(K))− f̄(θ(1), λ(1)))\n+ lim sup K→∞\n1\nc1 K∑ m=1 (|∆(m+1)1 |+ |∆ (m) 1 |)\n+ lim sup K→∞\nL̄2 √ n2 K∑ m=1 η(m)am\n+ lim sup K→∞\nNL̄K\n2c1 K∑ m=1 η(m) 2 .\n(49)\nNext we show that each of the four terms in the right-hand side of (49) is finite, respectively. For the first term,\nlim sup K→∞ −1 c1 (f̄(θ(K), λ(K))− f̄(θ(1), λ(1))) <∞\nis by the fact that the parameters {θ, λ} are in compact sets, which implies that the image of fi(·) is in a bounded set.\nFor the second term, we showed its finiteness in Lemma 7.10.\nFor the third term, by (23), we have\nlim sup K→∞ K∑ m=1 η(m)am\n= lim sup K→∞ K∑ m=1 η(m) K1 ∞∑ i=m i∑ j=1 α(i)η(j) +K2 ∞∑ i=m α(i)  =K1 lim sup\nK→∞ K∑ m=1 η(m)  ∞∑ i=m i∑ j=1 α(i)η(j) +K2 lim sup K→∞ K∑ m=1 η(m) ∞∑ i=m α(i).\n(50)\nThe right-hand side of (50) is finite because\n∞∑ m=1 η(m)  ∞∑ i=m i∑ j=1 α(i)η(j)  < ∞∑ m=1  ∞∑ i=m i∑ j=1 α(i)η(j)  <∞ (51) and\n∞∑ m=1 η(m) ∞∑ i=m α(i) < ∞∑ m=1 ∞∑ i=m α(i) <∞. (52)\nThe second inequalities in (51) and (52) come from the stated assumptions of this lemma.\nFor the fourth term,\nlim sup K→∞\nNL̄M\n2c K∑ m=1 η(m) 2 <∞\nholds, because we have ∑∞ m=1(η\n(m))2 < ∞ in Assumption 4.3. Therefore, T (∞) =∑∞ m=1 η (m)‖∇f̄(θ(m), λ̄)‖22 <∞ holds.\nIn Lemmas 7.9, 7.10 and 7.11, we show that {σ(m)} and {µ(m)} are Cauchy series, hence Lemma 4.7 holds.\n7.5.2 Proof of Lemma 4.8\nThis proof is similar to the the proof by Bertsekas and Tsitsiklis [5].\nProof. By Theorem 4.7, we have\nlim sup M→∞ M∑ m=1 η(m)‖∇f̄(θ(m), λ̄)‖22 <∞. (53)\nIf there exists a > 0 and an integer m̄ such that\n‖∇f̄(θ(m), λ̄)‖2 ≥ for all m ≥ m̄, we would have\nlim inf M→∞ M∑ m=m̄ η(m)‖∇f̄(θ(m), λ̄)‖22 ≥ lim inf M→∞ 2 M∑ m=m̄ η(m) =∞\nwhich contradicts (53). Therefore, lim inf m→∞ ‖∇f̄(θ(m), λ̄)‖2 = 0.\n7.5.3 Proof of Lemma 4.9\nLemma 7.12 Let Yt,W, t and Zt be three sequences such that Wt is nonnegative for all t. Assume that Yt+1 ≤ Yt −Wt + Zt, t = 0, 1, ..., and that the series ∑T t=0 Zt converges as T →∞. Then either Yt →∞ or else Yt converges to a\nfinite value and ∑∞ t=0Wt <∞.\nThis lemma has been proven by Bertsekas and Tsitsiklis [5].\nLemma 7.13 When\n∞∑ m=1 ∞∑ i=m i∑ n=1 α(i)η(n) <∞ and ∞∑ m=1 ∞∑ n=m α(n) <∞,\nit follows that f̄(θ(m), λ̄) converge to a finite value.\nProof. By Proposition 7.8, we have\nf̄(θ(m+1), λ̄) ≤ f̄(θ(m), λ̄)− η(m)‖∇f̄(θ(m), λ̄)‖22 + η(m)L̄M √ n2am + 1\n2 (η(m))2 ·NL̄M.\nLet Y (m) := f̄(θ(m), λ̄), W (m) := η(m)‖∇f̄(θ(m), λ̄)‖22 and Z(m) := η(m)L̄M √ n2am + 1 2 (η(m))2 ·NL̄M . By (1) and (50)- (52), it is easy to see that ∑M m=0 Z\n(m) converges as M →∞. Therefore, by Lemma 7.12, Y (m) converges to a finite value. The infinite case can not occur in our setting due to Assumptions 4.1 and 4.2.\nLemma 7.14 If ∞∑ m=1 ∞∑ i=m i∑ n=1 α(i)η(n) <∞ and ∞∑ m=1 ∞∑ n=m α(n) <∞,\nthen lim m→∞ ‖∇f̄(θ(m), λ̄)‖2 = 0.\nProof. To show that lim m→∞ ‖∇f̄(θ(m), λ̄)‖2 = 0, assume the contrary; that is,\nlim sup m→∞\n‖∇f̄(θ(m), λ̄)‖2 > 0.\nThen there exists an > 0 such that ‖∇f̄(θ(m), λ̄)‖ < /2 for infinitely many m and also ‖∇f̄(θ(m), λ̄)‖ > for infinitely many m. Therefore, there is an infinite subset of integers M, such that for each m ∈M, there exists an integer q(m) > m such that\n‖∇f̄(θ(m), λ̄)‖ < /2, ‖∇f̄(θ(i(m)), λ̄)‖ > ,\n/2 ≤ ‖∇f̄(θ(i), λ̄)‖ ≤ , if m < i < q(m).\n(54)\nFrom\n‖∇f̄(θ(m+1), λ̄)‖ − ‖∇f̄(θ(m), λ̄)‖ ≤ ‖∇f̄(θ(m+1), λ̄)−∇f̄(θ(m), λ̄)‖ ≤ L̄‖θ(m+1) − θ(m)‖ = L̄η(m)‖∇f̄(θ(m), λ(m))‖,\nit follows that for all m ∈M that are sufficiently large so that L̄η(m) < /4, we have\n/4 ≤ ‖∇f̄(θ(m), λ(m))‖. (55)\nOtherwise the condition /2 ≤ ‖∇f̄(θ(m+1), λ̄)‖ would be violated. Without loss of generality, we assume that the above relations as well as (36) hold for all m ∈M. With the above observations, we have for all m ∈M,\n2 ≤ ‖∇f̄(θq(m), λ̄)‖ − ‖∇f̄(θ(m), λ̄)‖\n≤ ‖∇f̄(θq(m), λ̄)−∇f̄(θ(m), λ̄)‖ ≤ L̄‖θq(m) − θ(m)‖ ≤ L̄ q(m)−1∑ i=m ‖θ(i+1) − θ(i)‖ ≤ L̄ q(m)−1∑ i=m η(i)‖∇f̄(θ(i), λ(i))‖ ≤ L̄ q(m)−1∑ i=m η(i)(‖∇f̄(θ(i), λ̄)‖+ ‖∇f̄(θ(i), λ(i))−∇f̄(θ(i), λ̄)‖) ≤ L̄ q(m)−1∑ i=m η(i)(‖∇f̄(θ(i), λ̄)‖+ L̄ √ n2am) ≤ L̄ q(m)−1∑ i=m η(i) + L̄2 √ n2 q(m)−1∑ i=m η(i)am\n= L̄ q(m)−1∑ i=m η(i) + L̄2 √ n2 q(m)−1∑ i=m η(i) M1 ∞∑ j=m j∑ k=1 α(j)η(k) +M2 ∞∑ j=m α(j)  = L̄\nq(m)−1∑ i=m η(i) + L̄2 √ n2M1 q(m)−1∑ i=m η(i) ∞∑ j=m j∑ k=1 α(j)η(k) + L̄2 √ n2M2 q(m)−1∑ i=m η(i) ∞∑ j=m α(j)\nThe first inequality is by (54) and the third one is by the Lipschitz condition assumption. The seventh one is by (32). By (2), we have for all m ∈M,\nq(m)−1∑ i=m η(i) ∞∑ j=m j∑ k=1 α(j)η(k) < ∞∑ i=1 ∞∑ j=i j∑ k=1 α(j)η(k) <∞\nand q(m)−1∑ i=m η(i) ∞∑ j=m α(j) < ∞∑ i=1 ∞∑ j=i α(j) <∞. It is easy to see that for any sequence {αi} with ∑∞ i=1 αi <∞, if follows that lim infM→∞ ∑∞ i=M αi = 0. Therefore,\nlim inf m→∞ q(m)−1∑ i=m η(i) ∞∑ j=m j∑ k=1 α(j)η(k) = 0\nand\nlim inf m→∞ q(m)−1∑ i=m η(i) ∞∑ j=m α(j) = 0.\nFrom this it follows that\nlim inf m→∞ q(m)−1∑ i=m η(i) ≥ 1 2L̄ . (56)\nBy the triangle inequality, we have\n‖∇f̄(θ(m), λ̄)‖ =‖∇f̄(θ(m), λ(m))−∇f̄(θ(m), λ(m)) +∇f̄(θ(m), λ̄)‖\n≥ ∣∣∣‖∇f̄(θ(m), λ(m))‖ − ‖∇f̄(θ(m), λ̄)−∇f̄(θ(m), λ(m))‖∣∣∣ .\nBy (32) and (55), if we pick m ∈M such that L√n2am ≤\n8 , we have ‖∇f̄(θ(m), λ̄)‖ ≥ 8 . Using\n(36), we observe that\nf̄(θq(m), λ̄) ≤ f̄(θ(m), λ̄)− q(m)−1∑ i=m ( η(i)c1‖∇f̄(θ(i), λ̄)‖22 ) + 1 2 ·NL̄M q(m)−1∑ i=m (η(i))2\n≤ f̄(θ(m), λ̄)− c1 (\n8 )2 q(m)−1∑ i=m η(i) + 1 2 ·NL̄M q(m)−1∑ i=m (η(i))2,∀m ∈M,\nwhere the second inequality is by (55). By Lemma 7.13, f̄(θq(m), λ̄) and f̄(θ(m), λ̄) converge to the same finite value. Using this convergence result and the assumption ∑∞ m=0(η\n(m))2 <∞, this relation implies that\nlim sup m→∞,m∈M q(m)−1∑ i=m η(i) = 0\nand contradicts (56).\nBy Lemmas 7.12, 7.13 and 7.14, we show that Theorem 4.10 holds. To this end we write\nlim m→∞\n‖∇f̄(θ(m), λ(m))‖2\n≤ lim m→∞ ‖∇f̄(θ(m), λ(m))−∇f̄(θ(m), λ̄)‖2 + lim m→∞ ‖∇f̄(θ(m), λ̄)‖2 ≤ lim m→∞ L̄‖λ(m) − λ̄‖2 + lim m→∞ ‖∇f̄(θ(m), λ̄)‖2.\nBy Theorem 4.6, we have lim m→∞ L̄‖λ(m) − λ̄‖2 = 0\nand by Lemma 4.9, we have lim m→∞ ‖∇f̄(θ(m), λ̄)‖2 = 0.\nTherefore, we have lim m→∞ ‖∇f̄(θ(m), λ(m))‖22 = 0,\nwhich is the statement in Theorem 4.10.\n7.6 Proof of Theorem 5.2\nIn this section we assume that fi(·) is strongly convex.\nLemma 7.15 If\nm2 ∞∑ i=m i∑ n=1 α(i)η(n) <∞, (57)\nthere exists a constant M such that , for every m we have\n|∆(m+1)1 |+ (1 + η(m)c)|∆ (m) 1 |+ η(m)L̄M √ n2am\n1 2η\n(m)2 ≤M. (58)\nProof. The notation here is the same as the one used in the proof of Lemma 7.11. Showing (58) is equivalent to showing constant upper bounds for |∆(m)1 | η(m) 2 and am η(m) .\nFor an upper bound of |∆(m)1 | η(m) 2 , by (40) and (43), we have\n|∆(m)1 | η(m) 2\n= |f̄(θ(m), λ(m))− f̄(θ(m), λ̄)|\nη(m) 2\n≤ M3 η(m) 2 D∑ j=1\n( |k(1)|NDM 1\n2B ∣∣∣σ̄j − σ(m)j ∣∣∣+N ∣∣∣∣∣ µ̄jσ̄j + B − µ (m) j\nσ (m) j + B\n∣∣∣∣∣ ) .\n(59)\nWe can see that it is equivalent to show that |σ̄j − σ(m)j |\nη(m) 2 and\n|µ̄j − µ(m)j |\nη(m) 2 have constant upper\nbounds because all other terms in the right-hand side of (59) are finite constants.\nBy (38), we have\n|σ̄j − σ(m)j | ≤ |k(1)| · M̃L̄,M\nC\n∞∑ i=m α(i) i∑ j=1 η(j) + σ̄j + |k(1)||C̄| C ∞∑ n=m+1 α(n).\nNote that we have η(m) = ζ\nϑ+m and thus η(m)\n2 = O( 1m2 ). Therefore, (57) implies that\n1\nη(m) 2 ∞∑ i=m i∑ n=1 α(i)η(n) <∞. (60)\nInequality (60) implies 1\nη(m) 2 ∞∑ i=m+1 α(i) <∞. (61)\nThis is by the fact that we assume ∑∞ n=1 η\n(n) =∞ in Assumption 4.3. We now apply the same kind of analysis to |µ̄j − µ(m)j | to establish∣∣∣µ(m)j − µ̄j ∣∣∣\n=(1− α(1))...(1− α(m)) ∣∣∣∣∣ µ (m) j (1− α(1))...(1− α(m)) − µ̄j (1− α(1))...(1− α(m)) ∣∣∣∣∣ ≤(1− α(1))...(1− α(m))[ ∣∣∣∣∣ µ (m) j (1− α(1))...(1− α(m)) − µ̄j (1− α(1))...(1− α(∞))\n∣∣∣∣∣+∣∣∣∣ µ̄j(1− α(1))...(1− α(m)) − µ̄j(1− α(1))...(1− α(∞)) ∣∣∣∣]\n≤ ∣∣∣µ̃(m)j − µ̃(∞)j ∣∣∣+ ∣∣∣∣ µ̄j(1− α(1))...(1− α(m)) − µ̃(∞)j ∣∣∣∣ .\n(62)\nWe define Am := ∣∣∣µ̃(m)j − µ̃(∞)j ∣∣∣ and Bm := ∣∣∣∣ µ̄j(1− α(1))...(1− α(m)) − µ̃(∞)j ∣∣∣∣. Recall from Theorem 4.6 that {µ(m)j } is a Cauchy series. By (7), we have\n|µ̃(p)j − µ̃ (q) j | ≤ M̃L̄,M · q∑ m=p m∑ n=1 α(m)η(n).\nTherefore, the first term in (62) is bounded by\n|µ̃(m)j − µ̃ ∞ j | ≤ M̃L̄,M · ∞∑ i=m i∑ n=1 α(i)η(n) <∞.\nFor the second term in (62), we first define C := (1− α(1))...(1− α(u))... . Then we have C · ∣∣∣∣ µ̄j(1− α(1))...(1− α(m)) − µ̃(∞)j ∣∣∣∣ =µ̄j |1− (1− α(m+1))...(1− α(∞))|\n≤µ̄j ∞∑\ni=m+1\nα(i),\nwhere the last inequality can be easily checked by induction. Therefore, the second term in (62) is bounded by ∣∣∣∣ µ̄j(1− α(1))...(1− α(m)) − µ̃(∞)j ∣∣∣∣ ≤ µ̄jC ∞∑\ni=m+1\nα(i).\nHence (60) and (61) ensure |µ̄j − µ(m)j |\nη(m) 2 to be finite.\nFor an upper bound of am η(m) , by (23), we have\nam η(m) = M1\n∑∞ i=m ∑i j=1 α (i)η(j) +M2 ∑∞ i=m α (i)\nη(m) .\nWe know that\nM1 ∑∞ i=m ∑i j=1 α (i)η(j)\nη(m) < M1\n1\nη(m) 2 ∞∑ i=m i∑ j=1 α(i)η(j) <∞ (63)\nand M2 ∑∞ i=m α (i)\nη(m) < M2\n1\nη(m) 2 ∞∑ i=m α(i) <∞. (64)\nThe second inequalities in (63) and (64) are by (60) and (61). Note that given that η(m) = 1/m, (60) is equivalent to\n∞∑ i=m i∑ j=1 α(i) 1 j < ∞∑ i=m α(i) ln(i) < ∞∑ i=1 α(i) ln(i) <∞\nThis concludes the proof.\nLemma 7.16 Under the assumptions of Lemma 7.15, Theorem 5.2 holds.\nThe proof for this Lemma of the high level follows the proof of Theorem 4.7 in Bottou et al. [6].\nProof. Assumption 5.1 implies that\nf̄(θ̃, λ) ≥ f̄(θ̂, λ) +∇f̄(θ̂, λ)T (θ̃ − θ̂) + 1 2 c‖θ̃ − θ̂‖22,∀θ̃, θ̂.\nTherefore, f̄ has a unique minimizer f̄∗ := f̄(θ∗, λ) for any λ fixed. Note that θ∗ = θ∗(λ) but this dependency is irrelevant in the rest of the proof. Standard convex analysis argument establishes\n2c ( f̄(θ(m), λ)− f̄(θ∗, λ) ) ≤ ‖∇f̄(θ(m), λ)‖22. (65)\nRecall that ∆(m+1)1 := f̄(θ (m+1), λ(m+1))− f̄(θ(m+1), λ̄). We then have\nf̄(θ(m+1), λ(m+1))− f̄(θ(m), λ(m)) = [ f̄(θ(m+1), λ(m+1))− f̄(θ(m+1), λ̄) ] − [ f̄(θ(m), λ(m))− f̄(θ(m), λ̄) ] + f̄(θ(m+1), λ̄)− f̄(θ(m), λ̄)\n≤|∆(m+1)1 |+ |∆ (m) 1 |+ f̄(θ(m+1), λ̄)− f̄(θ(m), λ̄).\n(66)\nTherefore,\nf̄(θ(m+1), λ̄)− f̄(θ(m), λ̄)\n≤− η(m)‖∇f̄(θ(m), λ̄)‖22 + η(m)L̄M √ n2am + 1\n2 η(m)\n2 NL̄M\n≤− η(m)c(f̄(θ(m), λ̄)− f̄(θ∗, λ̄)) + η(m)L̄M √ n2am + 1\n2 η(m)\n2 NL̄M\n=− η(m)c ( f̄(θ(m), λ(m))− f̄(θ∗, λ̄) + f̄(θ(m), λ̄)− f̄(θ(m), λ(m)) ) + η(m)L̄M √ n2am + 1\n2 η(m)\n2 NL̄M\n≤− η(m)c ( f̄(θ(m), λ(m))− f̄(θ∗, λ̄) ) + η(m)c ∣∣∣f̄(θ(m), λ̄)− f̄(θ(m), λ(m))∣∣∣ + η(m)L̄M √ n2am + 1\n2 η(m)\n2 NL̄M\n=− η(m)c ( f̄(θ(m), λ(m))− f̄(θ∗, λ̄) ) + η(m)c|∆(m)1 |\n+ η(m)L̄M √ n2am + 1\n2 η(m)\n2 NL̄M.\n(67)\nThe first inequality is by Proposition 7.8, while the second inequality is by the strong convexity property (65). Combining (66) and (67) yields\nf̄(θ(m+1), λ(m+1))− f̄(θ(m), λ(m)) ≤− η(m)c ( f̄(θ(m), λ(m))− f̄(θ∗, λ̄) ) + |∆(m+1)1 |+ (1 + η(m)c)|∆ (m) 1 |\n+ η(m)L̄M √ n2am + 1\n2 η(m)\n2 NL̄M.\nBy Lemma 7.15, there exists an upper bound M4 such that for all m sufficiently large,\n|∆(m+1)1 |+ (1 + η(m)c)|∆ (m) 1 |+ η(m)L̄M √ n2am\n1 2η\n(m)2 ≤M4.\nBy subtracting f̄(θ∗, λ̄) from both side of (7.6), we obtain\nf̄(θ(m+1), λ(m+1))− f̄(θ∗, λ̄)\n≤(1− η(m)c)(f̄(θ(m), λ(m))− f̄(θ∗, λ̄)) + 1 2 η(m) 2 (NL̄M +M4).\n(68)\nInequality (68) has the exact same form used in classic convergence proofs for the strongly convex, diminishing step size case.\nWe finally show by induction that\nf̄(θm, λm)− f̄(θ∗, λ̄) ≤ v\nϑ+m (69)\nholds for all m, where\nv := max{ζ 2(NL̄M +M4)\n2(ζc− 1) , (ϑ+ 1)[f̄(θ(1), λ(1))− f̄(θ∗, λ̄)]}.\nFirst, the definition of ζ ensures that it holds for m = 1. Assuming (69) holds for some m ≥ 1, it follows from (68) that\nf̄(θ(m+1), λ(m+1))− f̄(θ∗, λ̄) ≤ (1− η(m)c)(f̄(θ(m), λ(m))− f̄(θ∗, λ̄)) + 1 2 η(m) 2 (LM +M4)\n≤ (1− η(m)c) v ϑ+m + 1 2 η(m) 2 (LM +M4)\n= (1− ζc ϑ+m ) v ϑ+m + ζ2(LM +M4) 2(ϑ+m)2\n= ϑ+m− ζc (ϑ+m)2 v + ζ2(LM +M4) 2(ϑ+m)2\n= ϑ+m− 1 (ϑ+m)2\nv − (\nζc− 1 (ϑ+m)2 v\n) + ζ2(LM +M4)\n2(ϑ+m)2\n≤ ϑ+m− 1 (ϑ+m)2 v ≤ v ϑ+m+ 1 .\nThe first inequality is by (68), the second inequality is by the definition of η(m), the third inequality is by the definition of v, the sum of the latter two terms is non-positive, and the fourth inequality is because (ϑ + m)2 ≥ (ϑ + m + 1)(ϑ + m − 1). This shows that the algorithm converges at a sublinear rate.\n8 Appendix B: Discussions of conditions for stepsizes\nHere we discuss the actual conditions for η(m) and α(m) to satisfy the assumptions of Theorem 4.6, Lemma 4.7 and Theorem 5.2, respectively. We only consider the cases η(m) = 1\nmk and α(m) = 1 mh ,\nbut the same analysis applies to the cases η(m) = O( 1 mk ) and α(m) = O( 1 mh ).\n8.1 Assumptions of Theorem 4.6\nFor the assumptions of Theorem 4.6, the first condition ∞∑ m=1 α(m) <∞ requires h > 1.\nBesides, the second condition ∞∑ m=1 m∑ n=1 α(m)η(n) = ∞∑ n=1 ∞∑ m=n α(m)η(n) = ∞∑ n=1 η(n) ∞∑ m=n α(m)\n≈ 1 h− 1 ∞∑ n=1 η(n) 1 nh−1 = 1 h− 1 ∞∑ n=1\n1\nnk+h−1 <∞\nrequires k + h > 2. The approximation comes from the fact that for every p > 1, we have ∞∑ k=n k−p ≈ ∫ ∞ k=n k−pdx = 1 1− p x1−p ∣∣∣∣∞ n = 1 p− 1 1 np−1 . Since k ≥ 1 due to Assumption 4.3, we conclude that k + h > 2.\nTherefore, the conditions for η(m) and α(m) to satisfy the assumptions of Theorem 4.6 are h > 1 and k ≥ 1.\n8.2 Assumptions of Lemma 4.7\nFor the assumptions of Theorem 4.6, the first condition ∞∑ m=1 ∞∑ n=m α(n) ≈ ∞∑ m=1 1 mh−1 <∞\nrequires h > 2.\nBesides, the second condition is\n∞∑ m=1 ∞∑ i=m i∑ n=1 α(i)η(n) = ∞∑ m=1 ∞∑ i=m α(i) i∑ n=1 η(n) ≤ C ∞∑ m=1 ∞∑ i=m α(i) <∞.\nThe inequality holds because for any p > 1, we have n∑ k=1 k−p ≈ ∫ n k=1 k−pdk = 1 1− p k1−p ∣∣∣∣n 1 = 1 p− 1 (1− n1−p) ≤ C\nTherefore, the conditions for η(m) and α(m) to satisfy the assumptions of Lemma 4.7 are h > 2 and k ≥ 1.\n8.3 Assumptions of Theorem 5.2\nRecall that we have let η(m) = 1/m. For the assumptions of Theorem 5.2, the condition ∞∑ m=1 α(m) ln(m) <∞\nrequires h > 1. To see this, note that ln(m) ≤ Cm for any > 0. Thus ∞∑ m=1 α(m) ln(m) ≤ C ∞∑ m=1 m−hm <∞\nif − h < −1. This yields h > 1.\nTherefore, the condition for α(m) to satisfy the assumptions of Theorem 5.2 is h > 1."
    } ],
    "references" : [ {
      "title" : "Normalization Propagation: A Parametric Technique for Removing Internal Covariate Shift in Deep Networks",
      "author" : [ "Devansh Arpit", "Yingbo Zhou", "Bhargava U. Kota", "Venu Govindaraju" ],
      "venue" : "In International Conference on Machine Learning,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2016
    }, {
      "title" : "Incremental gradient, subgradient, and proximal methods for convex optimization: A Survey. Optimization for Machine",
      "author" : [ "Dimitri P. Bertsekas" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2010
    }, {
      "title" : "Gradient Convergence in Gradient Methods with Errors",
      "author" : [ "Dimitri P. Bertsekas", "John N. Tsitsiklis" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2000
    }, {
      "title" : "Optimization Methods for Large-Scale Machine Learning",
      "author" : [ "Léon Bottou", "Frank E. Curtis", "Jorge Nocedal" ],
      "venue" : "arXiv preprint arXiv:1606.04838,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2016
    }, {
      "title" : "Recurrent Batch Normalization",
      "author" : [ "Tim Cooijmans", "Nicolas Ballas", "César Laurent", "Aaron Courville" ],
      "venue" : "arXiv preprint arXiv:1603.09025,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2016
    }, {
      "title" : "Adaptive Subgradient Methods for Online Learning and Stochastic Optimization",
      "author" : [ "Yoram Duchi", "John", "Hazan", "Elad", "Singer" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2011
    }, {
      "title" : "A Class of Unconstrained Minimization Methods for Neural Network Training",
      "author" : [ "L. Grippo" ],
      "venue" : "Optimization Methods and Software,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1994
    }, {
      "title" : "Knowledge Matters: Importance of Prior Information for Optimization",
      "author" : [ "Çaglar Gülçehre", "Yoshua Bengio" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2016
    }, {
      "title" : "Deep Residual Learning for Image Recognition",
      "author" : [ "Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun" ],
      "venue" : "In Computer Vision and Pattern Recognition,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2016
    }, {
      "title" : "Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift",
      "author" : [ "Sergey Ioffe", "Christian Szegedy" ],
      "venue" : "In International Conference on Machine Learning,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2015
    }, {
      "title" : "Learning Multiple Layers of Features from Tiny Images",
      "author" : [ "Alex Krizhevsky", "Geoffrey E. Hinton" ],
      "venue" : "PhD thesis,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2009
    }, {
      "title" : "Imagenet Classification with Deep Convolutional Neural Networks",
      "author" : [ "Alex Krizhevsky", "Ilya Sutskever", "Geoffrey E. Hinton" ],
      "venue" : "In Advances in neural information processing systems,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2012
    }, {
      "title" : "Gradient-based learning applied to document recognition",
      "author" : [ "Yann LeCun", "Léon Bottou", "Yoshua Bengio" ],
      "venue" : "Proceedings of the IEEE,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1998
    }, {
      "title" : "Neural Networks: Tricks of the Trade",
      "author" : [ "Genevieve B. Orr", "Klaus-Robert Müller" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2003
    }, {
      "title" : "Introduction to optimization. Translations series in mathematics and engineering",
      "author" : [ "B.T. Polyak" ],
      "venue" : "Optimization Software,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1987
    }, {
      "title" : "Pseudogradient Adaption and Training Algorithms",
      "author" : [ "B.T. Polyak", "Y.Z. Tsypkin" ],
      "venue" : "Automation and Remote Control,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1973
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "Ioffe and Szegedy [12] identified an important problem involved in training deep networks, internal covariate shift, and then proposed batch normalization (BN) to decrease this phenomenon.",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 3,
      "context" : "It is now a standard practice [6, 11].",
      "startOffset" : 30,
      "endOffset" : 37
    }, {
      "referenceID" : 8,
      "context" : "It is now a standard practice [6, 11].",
      "startOffset" : 30,
      "endOffset" : 37
    }, {
      "referenceID" : 3,
      "context" : "[6].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 13,
      "context" : "In fact, Orr and Müller [16] show that preprocessing the data by subtracting the mean, normalizing the variance, and decorrelating the input has various beneficial effects for back-propagation.",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 11,
      "context" : "[14] propose a method called local response normalization which is inspired by computational neuroscience and acts as a form of lateral inhibition, i.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "Gülçehre and Bengio [10] propose a standardization layer that bears significant resemblance to batch normalization, except that the two methods are motivated by very different goals and perform different tasks.",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "Normalization propagation [2] uses data-independent estimations for the mean and standard deviation in every layer to reduce the internal covariate shift and make the estimation more accurate for the validation phase.",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 4,
      "context" : "[7] propose a new way to apply batch normalization to RNN and LSTM models.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "For classical convergence results with a nonconvex objective function and diminishing learning rate, we refer to survey papers [4, 5, 6].",
      "startOffset" : 127,
      "endOffset" : 136
    }, {
      "referenceID" : 2,
      "context" : "For classical convergence results with a nonconvex objective function and diminishing learning rate, we refer to survey papers [4, 5, 6].",
      "startOffset" : 127,
      "endOffset" : 136
    }, {
      "referenceID" : 3,
      "context" : "For classical convergence results with a nonconvex objective function and diminishing learning rate, we refer to survey papers [4, 5, 6].",
      "startOffset" : 127,
      "endOffset" : 136
    }, {
      "referenceID" : 2,
      "context" : "Bertsekas and Tsitsiklis [5] provide a convergence result with deterministic gradient with errors.",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 3,
      "context" : "[6] provide a convergence result with stochastic gradient.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "The classic analyses showing the norm of gradients of the objective function going to zero date back to [9, 18, 17].",
      "startOffset" : 104,
      "endOffset" : 115
    }, {
      "referenceID" : 15,
      "context" : "The classic analyses showing the norm of gradients of the objective function going to zero date back to [9, 18, 17].",
      "startOffset" : 104,
      "endOffset" : 115
    }, {
      "referenceID" : 14,
      "context" : "The classic analyses showing the norm of gradients of the objective function going to zero date back to [9, 18, 17].",
      "startOffset" : 104,
      "endOffset" : 115
    }, {
      "referenceID" : 3,
      "context" : "For strongly convex objective functions with a diminishing learning rate, we learn the classic convergence results from [6].",
      "startOffset" : 120,
      "endOffset" : 123
    }, {
      "referenceID" : 3,
      "context" : "This result is similar to the classical convergence rate analysis for the non-convex objective function with diminishing stepsizes, which can be found in [6].",
      "startOffset" : 154,
      "endOffset" : 157
    }, {
      "referenceID" : 3,
      "context" : "[6].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 12,
      "context" : "We use MNIST [15], CIFAR-10 [13] and Network Intrusion (NI) [1] datasets to compare the performance between DBN and the original BN algorithm.",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 10,
      "context" : "We use MNIST [15], CIFAR-10 [13] and Network Intrusion (NI) [1] datasets to compare the performance between DBN and the original BN algorithm.",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 5,
      "context" : "We use AdaGrad [8] to update the learning rates η for trainable parameters, starting from 0.",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 0,
      "context" : "[2] Devansh Arpit, Yingbo Zhou, Bhargava U.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "[4] Dimitri P.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "[5] Dimitri P.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 3,
      "context" : "[6] Léon Bottou, Frank E.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[7] Tim Cooijmans, Nicolas Ballas, César Laurent, and Aaron Courville.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "[8] Yoram Duchi, John and Hazan, Elad and Singer.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "[9] L.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "[10] Çaglar Gülçehre and Yoshua Bengio.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 8,
      "context" : "[11] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 9,
      "context" : "[12] Sergey Ioffe and Christian Szegedy.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[13] Alex Krizhevsky and Geoffrey E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "[14] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "[15] Yann LeCun, Léon Bottou, and Yoshua Bengio.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 13,
      "context" : "[16] Genevieve B.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 14,
      "context" : "[17] B.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 15,
      "context" : "[18] B.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 3,
      "context" : "This is a known result of the Lipschitz-continuous condition that can be found in [6].",
      "startOffset" : 82,
      "endOffset" : 85
    }, {
      "referenceID" : 2,
      "context" : "8 This proof is similar to the the proof by Bertsekas and Tsitsiklis [5].",
      "startOffset" : 69,
      "endOffset" : 72
    }, {
      "referenceID" : 2,
      "context" : "This lemma has been proven by Bertsekas and Tsitsiklis [5].",
      "startOffset" : 55,
      "endOffset" : 58
    }, {
      "referenceID" : 3,
      "context" : "[6].",
      "startOffset" : 0,
      "endOffset" : 3
    } ],
    "year" : 2017,
    "abstractText" : "Batch normalization (BN) is very effective in accelerating the convergence of a neural network training phase that it has become a common practice. We propose a generalization of BN, the diminishing batch normalization (DBN) algorithm. We provide an analysis of the convergence of the DBN algorithm that converges to a stationary point with respect to trainable parameters. We analyze a two layer model with linear activation. The main challenge of the analysis is the fact that some parameters are updated by gradient while others are not. In the numerical experiments, we use models with more layers and ReLU activation. We observe that DBN outperforms the original BN algorithm on MNIST, NI and CIFAR-10 datasets with reasonable complex FNN and CNN models.",
    "creator" : "LaTeX with hyperref package"
  }
}