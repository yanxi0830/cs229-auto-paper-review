{
  "name" : "1405.2878.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Approximate Policy Iteration Schemes: A Comparison",
    "authors" : [ "Bruno Scherrer" ],
    "emails" : [ "BRUNO.SCHERRER@INRIA.FR" ],
    "sections" : [ {
      "heading" : null,
      "text" : "We consider the infinite-horizon discounted optimal control problem formalized by Markov Decision Processes. We focus on several approximate variations of the Policy Iteration algorithm: Approximate Policy Iteration (API) (Bertsekas & Tsitsiklis, 1996), Conservative Policy Iteration (CPI) (Kakade & Langford, 2002), a natural adaptation of the Policy Search by Dynamic Programming algorithm (Bagnell et al., 2003) to the infinite-horizon case (PSDP∞), and the recently proposed Non-Stationary Policy Iteration (NSPI(m)) (Scherrer & Lesner, 2012). For all algorithms, we describe performance bounds with respect the per-iteration error , and make a comparison by paying a particular attention to the concentrability constants involved, the number of iterations and the memory required. Our analysis highlights the following points: 1) The performance guarantee of CPI can be arbitrarily better than that of API, but this comes at the cost of a relative—exponential in 1 —increase of the number of iterations. 2) PSDP∞ enjoys the best of both worlds: its performance guarantee is similar to that of CPI, but within a number of iterations similar to that of API. 3) Contrary to API that requires a constant memory, the memory needed by CPI and PSDP∞ is proportional to their number of iterations, which may be problematic when the discount factor γ is close to 1 or the approximation error is close to 0; we show that the NSPI(m) algorithm allows to make an overall trade-off between memory and performance. Simulations with these schemes confirm our analysis.\nProceedings of the 31 st International Conference on Machine Learning, Beijing, China, 2014. JMLR: W&CP volume 32. Copyright 2014 by the author(s)."
    }, {
      "heading" : "1. Introduction",
      "text" : "We consider an infinite-horizon discounted Markov Decision Process (MDP) (Puterman, 1994; Bertsekas & Tsitsiklis, 1996) (S,A, P, r, γ), where S is a possibly infinite state space, A is a finite action space, P (ds′|s, a), for all (s, a), is a probability kernel on S, r : S → [−Rmax, Rmax] is a reward function bounded byRmax, and γ ∈ (0, 1) is a discount factor. A stationary deterministic policy π : S → A maps states to actions. We write Pπ(ds\n′|s) = P (ds′|s, π(s)) for the stochastic kernel associated to policy π. The value vπ of a policy π is a function mapping states to the expected discounted sum of rewards received when following π from these states: for all s ∈ S,\nvπ(s) = E [ ∞∑ t=0 γtr(st) ∣∣∣∣∣s0 = s, st+1 ∼ Pπ(·|st) ] .\nThe value vπ is clearly bounded by Vmax = Rmax/(1−γ). It is well-known that vπ can be characterized as the unique fixed point of the linear Bellman operator associated to a policy π: Tπ : v 7→ r+ γPπv. Similarly, the Bellman optimality operator T : v 7→ maxπ Tπv has as unique fixed point the optimal value v∗ = maxπ vπ . A policy π is greedy w.r.t. a value function v if Tπv = Tv, the set of such greedy policies is written Gv. Finally, a policy π∗ is optimal, with value vπ∗ = v∗, iff π∗ ∈ Gv∗, or equivalently Tπ∗v∗ = v∗.\nThe goal of this paper is to study and compare several approximate Policy Iteration schemes. In the literature, such schemes can be seen as implementing an approximate greedy operator, G , that takes as input a distribution ν and a function v : S → R and returns a policy π that is ( , ν)approximately greedy with respect to v in the sense that:\nν(Tv − Tπv) = ν(max π′ Tπ′v − Tπv) ≤ . (1)\nwhere for all x, νx denotes Es∼ν [x(s)]. In practice, this approximation of the greedy operator can be achieved through a `p-regression of the so-called Q-function—the stateaction value function—(a direct regression is suggested by Kakade & Langford (2002), a fixed-point LSTD approach is used by Lagoudakis & Parr (2003b)) or through a\nar X\niv :1\n40 5.\n28 78\nv1 [\ncs .A\nI] 1\n2 M\nay 2\n01 4\n(cost-sensitive) classification problem (Lagoudakis & Parr, 2003a; Lazaric et al., 2010). With this operator in hand, we shall describe several Policy Iteration schemes in Section 2. Then Section 3 will provide a detailed comparative analysis of their performance guarantees, time complexities, and memory requirements. Section 4 will go on by providing experiments that will illustrate their behavior, and confirm our analysis. Finally, Section 5 will conclude and present future work."
    }, {
      "heading" : "2. Algorithms",
      "text" : "API We begin by describing the standard Approximate Policy Iteration (API) (Bertsekas & Tsitsiklis, 1996). At each iteration k, the algorithm switches to the policy that is approximately greedy with respect to the value of the previous policy for some distribution ν:\nπk+1 ← G k+1(ν, vπk). (2)\nIf there is no error ( k = 0) and ν assigns a positive weights to every state, it can easily be seen that this algorithm generates the same sequence of policies as exact Policy Iterations since from Equation (1) the policies are exactly greedy.\nCPI/CPI(α)/API(α) We now turn to the description of Conservative Policy Iteration (CPI) proposed by (Kakade & Langford, 2002). At iteration k, CPI (described in Equation (3)) uses the distribution dπk,ν = (1 − γ)ν(I − γPπk)\n−1—the discounted cumulative occupancy measure induced by πk when starting from ν—for calling the approximate greedy operator, and uses a stepsize αk to generate a stochastic mixture of all the policies that are returned by the successive calls to the approximate greedy operator, which explains the adjective “conservative”:\nπk+1 ← (1− αk+1)πk + αk+1G k+1(dπk,ν , vπk) (3)\nThe stepsize αk+1 can be chosen in such a way that the above step leads to an improvement of the expected value of the policy given that the process is initialized according to the distribution ν (Kakade & Langford, 2002). The original article also describes a criterion for deciding whether to stop or to continue. Though the adaptive stepsize and the stopping condition allows to derive a nice analysis, they are in practice conservative: the stepsize αk should be implemented with a line-search mechanism, or be fixed to some small value α. We will refer to this latter variation of CPI as CPI(α).\nIt is natural to also consider the algorithm API(α) (mentioned by Lagoudakis & Parr (2003a)), a variation of API that is conservative like CPI(α) in the sense that it mixes the new policy with the previous ones with weights α and\n1−α, but that directly uses the distribution ν in the approximate greedy step:\nπk+1 ← (1− α)πk + αG k+1(ν, vπk) (4)\nBecause it uses ν instead of dπk,ν , API(α) is simpler to implement than CPI(α)1.\nPSDP∞ We are now going to describe an algorithm that has a flavour similar to API—in the sense that at each step it does a full step towards a new deterministic policy— but also has a conservative flavour like CPI—in the sense that the policies considered evolve more and more slowly. This algorithm is a natural variation of the Policy Search by Dynamic Programming algorithm (PSDP) of Bagnell et al. (2003), originally proposed to tackle finite-horizon problems, to the infinite-horizon case; we thus refer to it as PSDP∞. To the best of our knowledge however, this variation has never been used in an infinite-horizon context.\nThe algorithm is based on finite-horizon non-stationary policies. Given a sequence of stationary deterministic policies (πk) that the algorithm will generate, we will write σk = πkπk−1 . . . π1 the k-horizon policy that makes the first action according to πk, then the second action according to πk−1, etc. Its value is vσk = TπkTπk−1 . . . Tπ1r. We will write ∅ the “empty” non-stationary policy. Note that v∅ = r and that any infinite-horizon policy that begins with σk = πkπk−1 . . . π1, which we will (somewhat abusively) denote “σk . . . ” has a value vσk... ≥ vσk −γkVmax. Starting from σ0 = ∅, the algorithm implicitely builds a sequence of non-stationary policies (σk) by iteratively concatenating the policies that are returned by the approximate greedy operator:\nπk+1 ← G k+1(ν, vσk) (5)\nWhile the standard PSDP algorithm of Bagnell et al. (2003) considers a horizon T and makes T iterations, the algorithm we consider here has an indefinite number of iterations. The algorithm can be stopped at any step k. The theory that we are about to describe suggests that one may return any policy that starts by the non-stationary policy σk. Since σk is an approximately good finite-horizon policy, and as we consider an infinite-horizon problem, a natural output that one may want to use in practice is the infinitehorizon policy that loops over σk, that we shall denote (σk) ∞.\n1In practice, controlling the greedy step with respect to dπk,ν requires to generate samples from this very distribution. As explained by Kakade & Langford (2002), one such sample can be done by running one trajectory starting from ν and following πk, stopping at each step with probability 1 − γ. In particular, one sample from dπk,ν requires on average 1 1−γ samples from the underlying MDP. With this respect, API(α) is much simpler to implement.\nFrom a practical point of view, PSDP∞ and CPI need to store all the (stationary deterministic) policies generated from the start. The memory required by the algorithmic scheme is thus proportional to the number of iterations, which may be prohibitive. The aim of the next paragraph, that presents the last algorithm of this article, is to describe a solution to this potential memory issue.\nNSPI(m) We originally devised the algorithmic scheme of Equation (5) (PSDP∞) as a simplified variation of the Non-Stationary PI algorithm with a growing period algorithm (NSPI-growing) (Scherrer & Lesner, 2012)2. With respect to Equation (5), the only difference of NSPIgrowing resides in the fact that the approximate greedy step is done with respect to the value v(σk)∞ of the policy that loops infinitely over σk (formally the algorithm does πk+1 ← G k+1(ν, v(σk)∞)) instead of the value vσk of only the first k steps here. Following the intuition that when k is big, these two values will be close to each other, we ended up considering PSDP∞ because it is simpler. NSPIgrowing suffers from the same memory drawback as CPI and PSDP∞. Interestingly, the work of Scherrer & Lesner (2012) contains another algorithm, Non-Stationary PI with a fixed period (NSPI(m)), that has a parameter that directly controls the number of policies stored in memory.\nSimilarly to PSDP∞, NSPI(m) is based on non-stationary policies. It takes as an input a parameter m. It requires a set of m initial deterministic stationary policies πm−1, πm−2, . . . , π0 and iteratively generates new policies π1, π2, . . . . For any k ≥ 0, we shall denote σmk the m-horizon non-stationary policy that runs in reverse order the last m policies, which one may write formally: σmk = πk πk−1 . . . πk−m+1. Also, we shall denote (σmk )\n∞ the m-periodic infinite-horizon nonstationary policy that loops over σmk . Starting from σ m 0 = π0π1 . . . πm−1, the algorithm iterates as follows:\nπk+1 ← G k+1(ν, v(σmk )∞) (6)\nEach iteration requires to compute an approximate greedy policy πk+1 with respect to the value v(σmk )∞ of (σ m k ) ∞, that is the fixed point of the compound operator3:\n∀v, Tk,mv = TπkTπk−1 . . . Tπk−m+1v.\nWhen one goes from iterations k to k+ 1, the process consists in adding πk+1 at the front of the (m − 1)-horizon policy πkπk−1 . . . πk−m+2, thus forming a new m-horizon\n2We later realized that it was in fact a very natural variation of PSDP. To ”give Caesar his due and God his”, we kept as the main reference the older work and gave the name PSDP∞.\n3Implementing this algorithm in practice can trivially be done through cost-sensitive classification in a way similar to Lazaric et al. (2010). It could also be done with a straight-forward extension of LSTD(λ) to non-stationary policies.\npolicy σmk+1. Doing so, we forget about the oldest policy πk−m+1 of σmk and keep a constant memory of size m. At any step k, the algorithm can be stopped, and the output is the policy πk,m = (σmk )\n∞ that loops on σmk . It is easy to see that NSPI(m) reduces to API when m = 1. Furthermore, if we assume that the reward function is positive, add “stop actions” in every state of the model that lead to a terminal absorbing state with a null reward, and initialize with an infinite sequence of policies that only take this “stop action”, then NSPI(m) with m =∞ reduces to PSDP∞."
    }, {
      "heading" : "3. Analysis",
      "text" : "For all considered algorithms, we are going to describe bounds on the expected loss Es∼µ[vπ∗(s) − vπ(s)] = µ(vπ∗ − vπ) of using the (possibly stochastic or nonstationary) policy π ouput by the algorithms instead of the optimal policy π∗ from some initial distribution µ of interest as a function of an upper bound on all errors ( k). In order to derive these theoretical guarantees, we will first need to introduce a few concentrability coefficients that relate the distribution µ with which one wants to have a guarantee, and the distribution ν used by the algorithms4.\nDefinition 1. Let c(1), c(2), . . . be the smallest coefficients in [1,∞)∪{∞} such that for all i and all sets of deterministic stationary policies π1, π2, . . . , πi, µPπ1Pπ2 . . . Pπi ≤ c(i)ν. For all m, k, we define the following coefficients in [1,∞) ∪ {∞}:\nC(1,k) = (1− γ) ∞∑ i=0 γic(i+ k),\nC(2,m,k) = (1− γ)(1− γm) ∞∑ i=0 ∞∑ j=0 γi+jmc(i+ jm+ k).\nSimilarly, let cπ∗(1), cπ∗(2), . . . be the smallest coefficients in [1,∞)∪{∞} such that for all i, µ(Pπ∗)i ≤ cπ∗(i)ν. We define:\nC(1)π∗ = (1− γ) ∞∑ i=0 γicπ∗(i).\nFinally let Cπ∗ be the smallest coefficient in [1,∞) ∪ {∞} such that dπ∗,µ = (1− γ)µ(I − γPπ∗)−1 ≤ Cπ∗ν.\nWith these notations in hand, our first contribution is to provide a thorough comparison of all the algorithms. This is done in Table 1. For each algorithm, we describe some performance bounds and the required number of iterations and memory. To make things clear, we only display the dependence with respect to the concentrability constants, the\n4The expected loss corresponds to some weighted `1-norm of the loss vπ∗ − vπ . Relaxing the goal to controlling the weighted `p-norm for some p ≥ 2 allows to introduce some finer coefficients (Farahmand et al., 2010; Scherrer et al., 2012). Due to lack of space, we do not consider this here.\ndiscount factor γ, the quality of the approximate greedy operator, and—if applicable—the main parameters α/m of the algorithms. For API(α), CPI(α), CPI and PSDP∞, the required memory matches the number of iterations. All but two bounds are to our knowledge original. The derivation of the new results are given in Appendix A.\nOur second contribution, that is complementary with the comparative list of bounds, is that we can show that there exists a hierarchy among the constants that appear in all the bounds of Table 1. In the directed graph of Figure 1, a constant B is a descendent of A if and only if the implication {B < ∞ ⇒ A < ∞} holds5. The “if and only if” is important here: it means that if A is a parent of B, and B is not a parent of A, then there exists an MDP for which A\n5Dotted arrows are used to underline the fact that the comparison of coefficients is restricted to the case where the parameter m is finite.\nis finite while B is infinite; in other words, an algorithm that has a guarantee with respect to A has a guarantee that can be arbitrarily better than that with constant B. Thus, the overall best concentrability constant is Cπ∗ , while the worst are C(2,1,0) and C(2,m,0). To make the picture complete, we should add that for any MDP and any distribution µ, it is possible to find an input distribution ν for the algorithm (recall that the concentrability coefficients depend on ν and µ) such that Cπ∗ is finite, though it is not the case for C (1) π∗ (and as a consequence all the other coefficients). The derivation of this order relations is done in Appendix B.\nThe standard API algorithm has guarantees expressed in terms of C(2,1,0) and C(1,0) only. Since CPI’s analysis can be done with respect to Cπ∗ , it has a performance guarantee that can be arbitrarily better than that of API, though the opposite is not true. This, however, comes at the cost of an exponential increase of time complexity since CPI may require a number of iterations that scales inO ( 1 2 ) , while the\nguarantee of API only requires O ( log 1 ) iterations. When the analysis of CPI is relaxed so that the performance guarantee is expressed in terms of the (worse) coefficient C(1,0) (obtained also for API), we can slightly improve the rate— to Õ ( 1 ) —, though it is still exponentially slower than that of API. This second result for CPI was proved with a technique that was also used for CPI(α) and API(α). We conjecture that it can be improved for CPI(α), that should be as good as CPI when α is sufficiently small.\nPSDP∞ enjoys two guarantees that have a fast rate like those of API. One bound has a better dependency with respect to 11−γ , but is expressed in terms of the worse coefficient C(1)π∗ . The second guarantee is almost as good as that\nof CPI since it only contains an extra log 1 term, but it has the nice property that it holds quickly with respect to : in timeO(log 1 ) instead ofO( 1 2 ), that is exponentially faster. PSDP∞ is thus theoretically better than both CPI (as good but faster) and API (better and as fast).\nNow, from a practical point of view, PSDP∞ and CPI need to store all the policies generated from the start. The memory required by these algorithms is thus proportional to the number of iterations. Even if PSDP∞ may require much fewer iterations than CPI, the corresponding memory requirement may still be prohibitive in situations where is small or γ is close to 1. We explained that NSPI(m) can be seen as making a bridge between API and PSDP∞. Since (i) both have a nice time complexity, (ii) API has the best memory requirement, and (iii) NSPI(m) has the best performance guarantee, NSPI(m) is a good candidate for making a standard performance/memory trade-off. If the first two bounds of NSPI(m) in Table 1 extends those of API, the other two are made of two terms: the left terms are identical to those obtained for PSDP∞, while the two possible right terms are new, but are controlled by γm, which can thus be made arbitrarily small by increasing the memory parameter m. Our analysis thus confirms our intuition that NSPI(m) allows to make a performance/memory trade-off in between API (small memory) and PSDP∞ (best performance). In other words, as soon as memory becomes a constraint, NSPI(m) is the natural alternative to PSDP∞."
    }, {
      "heading" : "4. Experiments",
      "text" : "In this section, we present some experiments in order to illustrate the empirical behavior of the different algorithms discussed in the paper. We considered the standard API as a baseline. CPI, as it is described by Kakade & Langford (2002), is very slow (in one sample experiment on a 100 state problem, it made very slow progress and took several millions of iterations before it stopped) and we did not evaluate it further. Instead, we considered two variations: CPI+ that is identical to CPI except that it chooses the step αk at each iteration by doing a line-search towards the policy output by the greedy operator6, and CPI(α) with α = 0.1, that makes “relatively but not too small” steps at each iteration. To assess the utility for CPI to use the distribution dν,π for the approximate greedy step, we also considered API(α) with α = 0.1, the variation of API described in Equation (4) that makes small steps, and that only differs from CPI(α) by the fact that the approximate greedy step uses the distribution ν instead of dπk,ν . In addition to these algorithms, we considered PSDP∞ and NSPI(m) for the values m ∈ {5, 10, 30}.\n6We implemented a crude line-search mechanism, that looks on the set 2iα where α is the minimal step estimated by CPI to ensure improvement.\nIn order to assess their quality, we consider finite problems where the exact value function can be computed. More precisely, we consider Garnet problems first introduced by Archibald et al. (1995), which are a class of randomly constructed finite MDPs. They do not correspond to any specific application, but remain representative of the kind of MDP that might be encountered in practice. In brief, we consider Garnet problems with |S| ∈ {50, 100, 200}, |A| ∈ {2, 5, 10} and branching factors in {1, 2, 10}. The greedy step used by all algorithms is approximated by an exact greedy operator applied to a noisy orthogonal projection on a linear space of dimension |S|10 with respect to the quadratic norm weighted by ν or dν,π (for CPI+ and CPI(α)) where ν is uniform.\nFor each of these 33 = 27 parameter instances, we generated 30 i.i.d. Garnet MDPs (Mi)1≤i≤30. For each such MDP Mi, we ran API, API(0.1), CPI+, CPI(0.1), NSPI(m) for m ∈ {5, 10, 30} and PSDP∞ 30 times. For each run j and algorithm, we compute for all iterations k ∈ (1, 100) the performance, i.e. the loss Lj,k = µ(vπ∗ − vπk) with respect to the optimal policy. Figure 2 displays statistics about these random variables. For each algorithm, we display a learning curve with confidence regions that account for the variability across runs and problems. The supplementary material contains statistics that are respectively conditioned on the values of nS , nA and b, which gives some insight on the influence of these parameters.\nFrom these experiments and statistics, we can make a series of observations. The standard API scheme is much more variable than the other algorithms and tends to provide the worst performance on average. CPI+ and CPI(α) display about the same asymptotic performance on average. If CPI(α) has slightly less variability, it is much slower than CPI+, that always converges in very few iterations (most of the time less than 10, and always less than 20). API(α)— the naive conservative variation of API that is also simpler than CPI(α)—is empirically close to CPI(α), while being on average slightly worse. CPI+, CPI(α) and PSDP∞ have a similar average performance, but the variability of PSDP∞ is significantly smaller. PSDP∞ is the algorithm that overall gives the best results. NSPI(m) does indeed provide a bridge between API and PSDP∞. By increasing m, the behavior gets closer to that of PSDP∞. With m = 30, NSPI(m) is overall better than API(α), CPI+, and CPI(α), and close to PSDP∞. The above relative observations are stable with respect to the number of states nS and actions nA. Interestingly, the differences between the algorithms tend to vanish when the dynamics of the problem gets more and more stochastic (when the branching factor increases). This complies with our analysis based on concentrability coefficients: there are all finite when the dynamics mixes a lot, and their relative difference are the biggest in deterministic instances."
    }, {
      "heading" : "5. Discussion, Summary and Future Work",
      "text" : "We have considered several variations of the Policy Iteration schemes for infinite-horizon problems: API, CPI, NSPI(m), API(α) and PSDP∞7. We have in particular explained the fact—to our knowledge so far unknown— that the recently introduced NSPI(m) algorithm generalizes API (that is obtained when m=1) and PSDP∞ (that is very similar whenm =∞). Figure 1 synthesized the theoretical guarantees about these algorithms. Most of the bounds are to our knowledge new.\nOne of the first important message of our work is that what is usually hidden in the constants of the performance bounds does matter. The constants involved in the bounds for API, CPI, PSDP∞ and for the main (left) terms of NSPI(m) can be sorted from the worst to the best as follows: C(2,1,0), C(1,0), C(1)π∗ , Cπ∗ . A detailed hierarchy of all constants was depicted in Figure 1. This is to our knowledge the first time that such an in-depth comparison of the bounds is done, and our hierarchy of constants has interesting implications that go beyond the Policy Iteration schemes we have been focusing on in this paper. As a matter of fact, several other dynamic programming algorithms, namely AVI (Munos, 2007), λPI (Scherrer, 2013), AMPI (Scherrer et al., 2012), come with guarantees involv-\n7We recall that to our knowledge, the use of PSDP∞ (PSDP in an infinite-horizon context) is not documented in the literature.\ning the worst constant C(2,1,0), which suggests that they should not be competitive with the best algorithms we have described here.\nAt the purely technical level, several of our bounds come in pair; this is due to the fact that we have introduced a new proof technique. This led to a new bound for API, that improves the state of the art in the sense that it involves the constant C(1,0) instead of C(2,1,0). It also enabled us to derive new bounds for CPI (and its natural algorithmic variant CPI(α)) that is worse in terms of guarantee but has a better time complexity (Õ( 1 ) instead of O( 1 2 )). We believe this new technique may be helpful in the future for the analysis of other MDP algorithms.\nLet us sum up the main insights of our analysis. 1) The guarantee for CPI can be arbitrarily stronger than that of API/API(α), because it is expressed with respect to the best concentrability constant Cπ∗ , but this comes at the cost of a relative—exponential in 1 —increase of the number of iterations. 2) PSDP∞ enjoys the best of both worlds: its performance guarantee is similar to that of CPI, but within a number of iterations similar to that of API. 3) Contrary to API that requires a constant memory, the memory needed by CPI and PSDP∞ is proportional to their number of iterations, which may be problematic in particular when the discount factor γ is close to 1 or the approximation error is close to 0; we showed that the NSPI(m) algorithm allows to make an overall trade-off between memory and perfor-\nmance.\nThe main assumption of this work is that all algorithms have at disposal an -approximate greedy operator. It may be unreasonable to compare all algorithms on this basis, since the underlying optimization problems may have different complexities: for instance, methods like CPI look in a space of stochastic policies while API moves in a space of deterministic policies. Digging and understanding in more depth what is potentially hidden in the term —as we have done here for the concentrability constants—constitutes a very natural research direction.\nLast but not least, we have run numerical experiments that support our worst-case analysis. On simulations on about 800 Garnet MDPs with various characteristics, CPI(α), CPI+ (CPI with a crude line-search mechanism), PSDP∞ and NSPI(m) were shown to always perform significantly better than the standard API. CPI+, CPI(α) and PSDP∞ performed similarly on average, but PSDP∞ showed much less variability and is thus the best algorithm in terms of overall performance. Finally, NSPI(m) allows to make a bridge between API and PSDP∞, reaching an overall performance close to that of PSDP∞ with a controlled memory. Implementing other instances of these algorithmic schemes, running and analyzing experiments on bigger domains constitutes interesting future work."
    }, {
      "heading" : "A. Proofs for Table 1",
      "text" : "PSDP∞: For all k, we have\nvπ∗ − vσk = Tπ∗vπ∗ − Tπ∗vσk−1 + Tπ∗vσk−1 − Tπkvσk−1\n≤ γPπ∗(vπ − vσk−1) + ek\nwhere we defined ek = maxπ′ Tπ′vσk−1 − Tπkvσk−1 . As Pπ∗ is non negative, we deduce by induction:\nvπ∗ − vσk ≤ k−1∑ i=0 (γPπ∗) iek−i + γ kVmax.\nBy multiplying both sides by µ, using the definition of the coefficients cπ∗(i) and the fact that νej ≤ j ≤ , we get:\nµ(vπ∗ − vσk) ≤ k−1∑ i=0 µ(γPπ∗) iek−i + γ kVmax (7)\n≤ k−1∑ i=0 γicπ∗(i) k−i + γ kVmax\n≤ ( k−1∑ i=0 γicπ∗(i) ) + γkVmax.\nThe bound with respect toC(1)π∗ is obtained by using the fact that vσk... ≥ vσk − γkVmax and taking k ≥ ⌈ log 2Vmax 1−γ ⌉ .\nStarting back in Equation (7) and using the definition of Cπ∗ (in particular the fact that for all i, µ(γPπ∗)\ni ≤ 1\n1−γ dπ∗,µ ≤ Cπ∗ 1−γ ν) and the fact that νej ≤ j , we get:\nµ(vπ∗ − vσk) ≤ k−1∑ i=0 µ(γPπ∗) iek−i + γ kVmax\n≤ Cπ∗ 1− γ k∑ i=1 i + γ kVmax\nand the other bound is obtained by using the fact that vσk... ≥ vσk − γkVmax, ∑k i=1 i ≤ k , and considering\nthe number of iterations k = ⌈\nlog 2Vmax 1−γ\n⌉ .\nAPI/NSPI(m): API is identical to NSPI(1), and its bounds are particular cases of the first two bounds for NSPI(m), so we only consider NSPI(m). By following the proof technique of Scherrer & Lesner (2012), writing Γk,m = (γPπk)(γPπk−1) · · · (γPπk−m+1) and ek+1 = maxπ′ Tπ′vπk,m − Tπk+1vπk,m , one can show that: vπ∗ − vπk,m ≤ k−1∑ i=0 (γPπ∗) i(I − Γk−i,m)−1ek−i + γkVmax.\nMultiplying both sides by µ (and observing that ek ≥ 0) and the fact that νej ≤ j ≤ , we obtain:\nµ(vπ∗ − vπk)\n≤ k−1∑ i=0 µ(γPπ∗) i(I − Γk−i,m)−1ek−i + γkVmax (8) ≤ k−1∑ i=0  ∞∑ j=0 γi+jmc(i+ jm) k−i\n+ γkVmax (9) ≤ k−1∑ i=0 ∞∑ j=0 γi+jmc(i+ jm) + γkVmax, (10)\nwhich leads to the first bound by taking k ≥ ⌈\nlog 2Vmax 1−γ\n⌉ .\nStarting back on Equation (9), assuming for simplicity that −k = 0 for all k ≥ 0, we get:\nµ(vπ∗ − vπk )− γ kVmax\n≤ d k−1m e∑ l=0 m−1∑ h=0 ∞∑ j=0 γh+(l+j)mc(h+ (l + j)m) k−h−lm ≤ d k−1m e∑ l=0 m−1∑ h=0 ∞∑ j=l γh+jmc(h+ jm) max k−(l+1)m+1≤p≤k−lm p ≤ d k−1m e∑ l=0 m−1∑ h=0 ∞∑ j=0 γh+jmc(h+ jm) max k−(l+1)m+1≤p≤k−lm p\n= ( m−1∑ h=0 ∞∑ j=0 γh+jmc(h+ jm) ) d k−1m e∑ l=0 max l−(l+1)m+1≤p≤k−lm p\n≤ ( ∞∑ i=0 γic(i) )⌈ k − 1 m ⌉ , (11)\nwhich leads to the second bound by taking k =⌈ log 2Vmax\n1−γ\n⌉ . Last but not least, starting back on Equa-\ntion (8), and using the fact that (I − Γk−i,m)−1 = I + Γk−i,m(I − Γk−i,m)−1 we see that:\nµ(vπ∗ − vπk)− γkVmax ≤ k−1∑ i=0 µ(γPπ∗) iek−i +\n+ k−1∑ i=0 µ(γPπ∗) iΓk−i,m(I − Γk−i,m)−1ek−i.\nThe first term of the r.h.s. can be bounded exactly as for PSDP∞. For the second term, we have:\nk−1∑ i=0 µ(γPπ∗) iΓk−i,m(I − Γk−i,m)−1ek−i\n≤ k−1∑ i=0 ∞∑ j=1 γi+jmc(i+ jm) k−i = γm k−1∑ i=0 ∞∑ j=0 γi+jmc(i+ (j + 1)m) k−i,\nand we follow the same lines as above (from Equation (9) to Equations (10) and (11)) to conclude.\nCPI, CPI(α), API(α): Conservative steps are addressed by a tedious generalization of the proof for API by Munos (2003). Due to lack of space, the proof is deferred to the Supplementary Material."
    }, {
      "heading" : "B. Proofs for Figure 1",
      "text" : "We here provide details on the order relation for the concentrability coefficients.\nCπ∗ → C (1) π∗ : (i) We have Cπ∗ ≤ C (1) π∗ because dπ∗,µ = (1− γ)µ(I − γPπ∗)−1 = (1− γ) ∞∑ i=0 γiµ(Pπ∗) i\n≤ (1− γ) ∞∑ i=0 γicπ∗(i)ν = C (1) π∗ ν\nand Cπ∗ is the smallest coefficient C satisfying dπ∗,µ ≤ Cν. (ii) We may have Cπ∗ <∞ and C (1) π∗ =∞ by design-\ning a MDP on N where π∗ induces a deterministic transition from state i to state i+ 1.\nC (1) π∗ → C(1,0): (i) We have C (1) π∗ ≤ C(1,0) because for all i, cπ∗(i) ≤ c(i). (ii) It is easy to obtain C (1) π∗ < ∞ and C(1,0) = ∞ since C(1)π∗ only depends on one policy while C (1) π∗ depends on all policies.\nC(1,0) → C(2,m,0) and C(1,m) → C(2,m,m): (i) C(1,m) ≤ 11−γmC (2,m,m) holds because\nC(1,m) 1− γ = ∞∑ i=0 γic(i+m) ≤ ∞∑ i=0 ∞∑ j=0 γi+jmc(i+ (j + 1)m)\n= 1\n(1− γ)(1− γm)C (2,m,m).\n(ii) One may have C(1,m) < ∞ and C(2,m,m) = ∞ when c(i) = Θ( 1i2γi ), since the generic term of C\n(1,m) is Θ( 1i2 ) (the sum converges) while that of C(2,m,m) is Θ( 1i ) (the sum diverges). The reasoning is similar for the other relation.\nC(1,m) → C(1,0) and C(2,m,m) → C(2,m,0): We here assume that m < ∞. (i) We have C(1,m) ≤ 1γmC\n(1,0) and C(2,m,m) ≤ 1γmC\n(2,m,0). (ii) It suffices that c(j) = ∞ for some j < m to have C(2,m,0) = ∞ while C(2,m,m) < ∞, or to have C(1,0) =∞ while C(1,m) <∞.\nC(2,1,0) ↔ C(2,m,0): (i) We clearly have C(2,m,0) ≤ 1−γm 1−γ C (2,1,0). (ii) C(2,m,0) can be rewritten as follows:\nC(2,m,0) = (1− γ)(1− γm) ∞∑ i=0 ( 1 + ⌊ i m ⌋) γic(i).\nThen, using the fact that 1 + ⌊ i m ⌋ ≥ max ( 1, im ) , we have\n1− γ 1− γm C(2,m,0) ≥ ∞∑ i=0 max ( 1, i m ) γic(i)\n≥ m−1∑ i=0 γic(i) + ∞∑ i=m i m γic(i)\n≥ m−1∑ i=0 γic(i) + m m+ 1 ∞∑ i=m i+ 1 m γic(i)\n= m−1∑ i=0 γic(i) + m m+ 1\n( C(2,1,0) −\nm−1∑ i=0 γic(i)\n)\n= m\nm+ 1 C(2,1,0) +\n1\nm+ 1 m−1∑ i=0 γic(i).\nThus, when m is finite, C(2,m,0) <∞⇒ C(2,1,0) <∞."
    }, {
      "heading" : "C. Proof for CPI, CPI(α), API(α)",
      "text" : "We begin by proving the following result:\nTheorem 1. At each iteration k < k∗ of CPI (Equation (3)), the expected loss satisfies:\nµ(vπ∗ − vπk) ≤ C(1,0) (1− γ)2 k∑ i=1 αi i + e {(1−γ)∑ki=1 αi}Vmax.\nProof. Using the facts that Tπk+1vπk = (1 − αk+1)vπk + αk+1Tπk+1vπk and the notation ek+1 = maxπ′ Tπ′vπk − Tπ′k+1vπk , we have:\nvπ∗ − vπk+1 = vπ∗ − Tπk+1vπk + Tπk+1vπk − Tπk+1vπk+1 = vπ∗ − (1− αk+1)vπk − αk+1Tπ′k+1vπk + γPπk+1(vπk − vπk+1)\n= (1− αk+1)(vπ∗ − vπk) + αk+1(Tπ∗vπ∗ − Tπ∗vπk) + αk+1(Tπ∗vπk − Tπ′k+1vπk) + γPπk+1(vπk − vπk+1)\n≤ [(1− αk+1)I + αk+1γPπ∗ ] (vπ − vπk) + αk+1ek+1 + γPπk+1(vπk − vπk+1). (12)\nUsing the fact that vπk+1 = (I − γPπk+1)−1r, and the fact that (I − γPπk+1)−1 is non-negative, we can see that\nvπk − vπk+1 = (I − γPπk+1)−1(vπk − γPπk+1vπk − r) = (I − γPπk+1)−1(Tπkvπk − Tπk+1vπk) ≤ (I − γPπk+1)−1αk+1ek+1.\nPutting this back in Equation (12), we obtain:\nvπ∗ − vπk+1 ≤ [(1− αk+1)I + αk+1γPπ∗ ] (vπ − vπk) + αk+1(I − γPπk+1)−1ek+1.\nDefine the matrix Qk = [(1− αk)I + αkγPπ∗ ], the set Ni,k = {j; k − i + 1 ≤ j ≤ k} (this set contains exactly i elements), the matrix Ri,k = ∏ j∈Ni,k Qj , and the coefficients βk = 1 − αk(1 − γ) and δk = ∏k i=1 βk. By repeatedly using the fact that the matrices Qk are non-negative, we get by induction\nvπ∗ − vπk ≤ k−1∑ i=0 Ri,kαk−i(I − γPπk−i)−1ek−i + δkVmax. (13)\nLet Pj(Ni,k) be the set of subsets of Ni,k of size j. With this notation we have\nRi,k = i∑ j=0 ∑ I∈Pj(Ni,k) ζI,i,k(γPπ∗) j\nwhere for all subset I of Ni,k, we wrote\nζI,i,k = (∏ n∈I αn ) ∏ n∈Ni,k\\I (1− αn)  . Therefore, by multiplying Equation (13) by µ, using the definition of the coefficients c(i), and the facts that ν ≤ (1 −\nγ)dν,πk+1 , we obtain:\nµ(vπ∗ − vπk) ≤ 1\n1− γ k−1∑ i=0 i∑ j=0 ∞∑ l=0 ∑ I∈Pj(Ni,k) ζI,i,kγ j+lc(j + l)αk−i k−i + δkVmax.\n= 1\n1− γ k−1∑ i=0 i∑ j=0 ∞∑ l=j ∑ I∈Pj(Ni,k) ζI,i,kγ lc(l)αk−i k−i + δkVmax\n≤ 1 1− γ k−1∑ i=0 i∑ j=0 ∞∑ l=0 ∑ I∈Pj(Ni,k) ζI,i,kγ lc(l)αk−i k−i + δkVmax\n= 1\n1− γ ( ∞∑ l=0 γlc(l) ) k−1∑ i=0  i∑ j=0 ∑ I∈Pj(Ni,k) ζI,i,k αk−i k−i + δkVmax = 1\n1− γ ( ∞∑ l=0 γlc(l) ) k−1∑ i=0  ∏ j∈Ni,k (1− αj + αj) αk−i k−i + δkVmax = 1\n1− γ ( ∞∑ l=0 γlc(l) )( k−1∑ i=0 αk−i k−i ) + δkVmax.\nNow, using the fact that for x ∈ (0, 1), log(1− x) ≤ −x, we can observe that\nlog δk = log k∏ i=1 βi = k∑ i=1 log βi = k∑ i=1 log(1− αi(1− γ)) ≤ −(1− γ) k∑ i=1 αi.\nAs a consequence, we get δk ≤ e−(1−γ) ∑k i=1 αi .\nIn the analysis of CPI, Kakade & Langford (2002) show that the learning steps that ensure the nice performance guarantee of CPI satisfy αk ≥ (1−γ) 12γVmax , the right term e {(1−γ)∑ki=1 αi} above tends 0 exponentially fast, and we get the following corollary that shows that CPI has a performance bound with the coefficient C(1,0) of API in a number of iterations O ( log 1 ) .\nCorollary 1. The smallest (random) iteration k† such that log Vmax 1−γ ≤ ∑k† i=1 αi ≤ log Vmax 1−γ + 1 is such that k\n† ≤ 12γVmax log Vmax\n(1−γ)2 and the policy πk† satisfies:\nµ(vπ∗ − vπk† ) ≤\nC(1,0) (∑k† i=1 αi ) (1− γ)2 + 1  ≤ (C(1,0) (log Vmax + 1) (1− γ)3 + 1 ) .\nSince the proof is based on a generalization of the analysis of API and thus does not use any of the specific properties of CPI, it turns out that the results we have just given can straightforwardly be specialized to CPI(α).\nCorollary 2. Assume we run CPI(α) for some α ∈ (0, 1), that is CPI (Equation (3)) with αk = α for all k.\nIf k = ⌈ log Vmax α(1− γ) ⌉ , then µ(vπ∗ − vπk) ≤ α(k + 1)C(1,0) (1− γ)2 ≤ ( C(1,0) ( log Vmax + 1 ) (1− γ)3 + 1 ) .\nThe above bound for CPI(α) involves the factor 1(1−γ)3 . A precise examination of the proof shows that this amplification is due to the fact that the approximate greedy operator uses the distribution dπk,ν ≥ (1− γ)ν instead of ν (for API). In fact, using a very similar proof, it is easy to show that API(α) satisfies the following result.\nCorollary 3. Assume API(α) is run for some α ∈ (0, 1).\nIf k = ⌈ log Vmax α(1− γ) ⌉ , then µ(vπ∗ − vπk) ≤ α(k + 1)C(1,0) (1− γ) ≤ ( C(1,0) ( log Vmax + 1 ) (1− γ)2 + 1 ) ."
    }, {
      "heading" : "D. More details on the Numerical Simulations",
      "text" : "Domain and Approximations In our experiments, a Garnet is parameterized by 4 parameters and is written G(nS , nA, b, p): nS is the number of states, nA is the number of actions, b is a branching factor specifying how many possible next states are possible for each state-action pair (b states are chosen uniformly at random and transition probabilities are set by sampling uniform random b − 1 cut points between 0 and 1) and p is the number of features (for linear function approximation). The reward is state-dependent: for a given randomly generated Garnet problem, the reward for each state is uniformly sampled between 0 and 1. Features are chosen randomly: Φ is a nS×p feature matrix of which each component is randomly and uniformly sampled between 0 and 1. The discount factor γ is set to 0.99 in all experiments.\nAll the algorithms we have discussed in the paper need to repeatedly compute G (ρ, v) for some distribution ρ = ν or ρ = dπ,ν . In other words, they must be able to make calls to an approximate greedy operator applied to the value v of some policy for some distribution ρ. To implement this operator, we compute a noisy estimate of the value v with a uniform white noise u(ι) of amplitude ι, then projects this estimate onto the space spanned by Φ with respect to the ρ-quadratic norm (projection that we write ΠΦ,ρ), and then applies the (exact) greedy operator on this projected estimate. In a nutshell, one call to the approximate greedy operator G (ρ, v) amounts to compute GΠΦ,ρ(v + u(ι)).\nSimulations We have run series of experiments, in which we callibrated the perturbations (noise, approximations) so that the algorithm are significantly perturbed but no too much (we do not want their behavior to become too erratic). After trial and error, we ended up considering the following setting. We used Garnet problems G(nS , nA, b, p) with the number of states nS ∈ {50, 100, 200}, the number of actions nA ∈ {2, 5, 10}, the branching factor b ∈ {1, 2, 10}} (b = 1 corresponds to deterministic problems), the number of features to approximate the value p = nS10 , and the noise level ι = 0.1 (10%).\nIn addition to Figure 2 that shows the statistics overall for the all the parameter instances, Figure 3, 4 and 5 display statistics that are respectively conditioned on the values of nS , nA and b, which gives some insight on the influence of these parameters."
    } ],
    "references" : [ {
      "title" : "On the Generation of Markov Decision Processes",
      "author" : [ "T. References Archibald", "K. McKinnon", "L. Thomas" ],
      "venue" : "Journal of the Operational Research Society,",
      "citeRegEx" : "Archibald et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Archibald et al\\.",
      "year" : 1995
    }, {
      "title" : "Policy search by dynamic programming",
      "author" : [ "J.A. Bagnell", "S.M. Kakade", "A. Ng", "J. Schneider" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "Bagnell et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Bagnell et al\\.",
      "year" : 2003
    }, {
      "title" : "Error propagation for approximate policy and value iteration (extended version)",
      "author" : [ "A.M. Farahmand", "R. Munos", "Szepesvári", "Cs" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "Farahmand et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Farahmand et al\\.",
      "year" : 2010
    }, {
      "title" : "Conservative and Greedy Approaches to Classification-based Policy Iteration",
      "author" : [ "M. Ghavamzadeh", "A. Lazaric" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "Ghavamzadeh and Lazaric,? \\Q2012\\E",
      "shortCiteRegEx" : "Ghavamzadeh and Lazaric",
      "year" : 2012
    }, {
      "title" : "Approximately optimal approximate reinforcement learning",
      "author" : [ "Kakade", "Sham", "Langford", "John" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Kakade et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Kakade et al\\.",
      "year" : 2002
    }, {
      "title" : "Reinforcement Learning as Classification: Leveraging Modern Classifiers",
      "author" : [ "M. Lagoudakis", "R. Parr" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Lagoudakis and Parr,? \\Q2003\\E",
      "shortCiteRegEx" : "Lagoudakis and Parr",
      "year" : 2003
    }, {
      "title" : "Least-squares policy iteration",
      "author" : [ "M.G. Lagoudakis", "R. Parr" ],
      "venue" : "Journal of Machine Learning Research (JMLR),",
      "citeRegEx" : "Lagoudakis and Parr,? \\Q2003\\E",
      "shortCiteRegEx" : "Lagoudakis and Parr",
      "year" : 2003
    }, {
      "title" : "Analysis of a Classification-based Policy Iteration Algorithm",
      "author" : [ "A. Lazaric", "M. Ghavamzadeh", "R. Munos" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Lazaric et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Lazaric et al\\.",
      "year" : 2010
    }, {
      "title" : "Error Bounds for Approximate Policy Iteration",
      "author" : [ "R. Munos" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Munos,? \\Q2003\\E",
      "shortCiteRegEx" : "Munos",
      "year" : 2003
    }, {
      "title" : "Performance Bounds in Lp norm for Approximate Value Iteration",
      "author" : [ "R. Munos" ],
      "venue" : "SIAM J. Control and Optimization,",
      "citeRegEx" : "Munos,? \\Q2007\\E",
      "shortCiteRegEx" : "Munos",
      "year" : 2007
    }, {
      "title" : "Performance Bounds for Lambda Policy Iteration and Application to the Game of Tetris",
      "author" : [ "B. Scherrer" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Scherrer,? \\Q2013\\E",
      "shortCiteRegEx" : "Scherrer",
      "year" : 2013
    }, {
      "title" : "On the Use of Non-Stationary Policies for Stationary Infinite-Horizon Markov Decision Processes",
      "author" : [ "B. Scherrer", "B. Lesner" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "Scherrer and Lesner,? \\Q2012\\E",
      "shortCiteRegEx" : "Scherrer and Lesner",
      "year" : 2012
    }, {
      "title" : "Approximate Modified Policy Iteration",
      "author" : [ "Scherrer", "Bruno", "Ghavamzadeh", "Mohammad", "Gabillon", "Victor", "Geist", "Matthieu" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Scherrer et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Scherrer et al\\.",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : "We focus on several approximate variations of the Policy Iteration algorithm: Approximate Policy Iteration (API) (Bertsekas & Tsitsiklis, 1996), Conservative Policy Iteration (CPI) (Kakade & Langford, 2002), a natural adaptation of the Policy Search by Dynamic Programming algorithm (Bagnell et al., 2003) to the infinite-horizon case (PSDP∞), and the recently proposed Non-Stationary Policy Iteration (NSPI(m)) (Scherrer & Lesner, 2012).",
      "startOffset" : 283,
      "endOffset" : 305
    }, {
      "referenceID" : 7,
      "context" : "Approximate Policy Iteration Schemes: A Comparison (cost-sensitive) classification problem (Lagoudakis & Parr, 2003a; Lazaric et al., 2010).",
      "startOffset" : 91,
      "endOffset" : 139
    }, {
      "referenceID" : 6,
      "context" : "Approximate Policy Iteration Schemes: A Comparison (cost-sensitive) classification problem (Lagoudakis & Parr, 2003a; Lazaric et al., 2010). With this operator in hand, we shall describe several Policy Iteration schemes in Section 2. Then Section 3 will provide a detailed comparative analysis of their performance guarantees, time complexities, and memory requirements. Section 4 will go on by providing experiments that will illustrate their behavior, and confirm our analysis. Finally, Section 5 will conclude and present future work. 2. Algorithms API We begin by describing the standard Approximate Policy Iteration (API) (Bertsekas & Tsitsiklis, 1996). At each iteration k, the algorithm switches to the policy that is approximately greedy with respect to the value of the previous policy for some distribution ν: πk+1 ← G k+1(ν, vπk). (2) If there is no error ( k = 0) and ν assigns a positive weights to every state, it can easily be seen that this algorithm generates the same sequence of policies as exact Policy Iterations since from Equation (1) the policies are exactly greedy. CPI/CPI(α)/API(α) We now turn to the description of Conservative Policy Iteration (CPI) proposed by (Kakade & Langford, 2002). At iteration k, CPI (described in Equation (3)) uses the distribution dπk,ν = (1 − γ)ν(I − γPπk) −1—the discounted cumulative occupancy measure induced by πk when starting from ν—for calling the approximate greedy operator, and uses a stepsize αk to generate a stochastic mixture of all the policies that are returned by the successive calls to the approximate greedy operator, which explains the adjective “conservative”: πk+1 ← (1− αk+1)πk + αk+1G k+1(dπk,ν , vπk) (3) The stepsize αk+1 can be chosen in such a way that the above step leads to an improvement of the expected value of the policy given that the process is initialized according to the distribution ν (Kakade & Langford, 2002). The original article also describes a criterion for deciding whether to stop or to continue. Though the adaptive stepsize and the stopping condition allows to derive a nice analysis, they are in practice conservative: the stepsize αk should be implemented with a line-search mechanism, or be fixed to some small value α. We will refer to this latter variation of CPI as CPI(α). It is natural to also consider the algorithm API(α) (mentioned by Lagoudakis & Parr (2003a)), a variation of API that is conservative like CPI(α) in the sense that it mixes the new policy with the previous ones with weights α and 1−α, but that directly uses the distribution ν in the approximate greedy step: πk+1 ← (1− α)πk + αG k+1(ν, vπk) (4) Because it uses ν instead of dπk,ν , API(α) is simpler to implement than CPI(α)1.",
      "startOffset" : 118,
      "endOffset" : 2382
    }, {
      "referenceID" : 1,
      "context" : "This algorithm is a natural variation of the Policy Search by Dynamic Programming algorithm (PSDP) of Bagnell et al. (2003), originally proposed to tackle finite-horizon problems, to the infinite-horizon case; we thus refer to it as PSDP∞.",
      "startOffset" : 102,
      "endOffset" : 124
    }, {
      "referenceID" : 1,
      "context" : "This algorithm is a natural variation of the Policy Search by Dynamic Programming algorithm (PSDP) of Bagnell et al. (2003), originally proposed to tackle finite-horizon problems, to the infinite-horizon case; we thus refer to it as PSDP∞. To the best of our knowledge however, this variation has never been used in an infinite-horizon context. The algorithm is based on finite-horizon non-stationary policies. Given a sequence of stationary deterministic policies (πk) that the algorithm will generate, we will write σk = πkπk−1 . . . π1 the k-horizon policy that makes the first action according to πk, then the second action according to πk−1, etc. Its value is vσk = TπkTπk−1 . . . Tπ1r. We will write ∅ the “empty” non-stationary policy. Note that v∅ = r and that any infinite-horizon policy that begins with σk = πkπk−1 . . . π1, which we will (somewhat abusively) denote “σk . . . ” has a value vσk... ≥ vσk −γVmax. Starting from σ0 = ∅, the algorithm implicitely builds a sequence of non-stationary policies (σk) by iteratively concatenating the policies that are returned by the approximate greedy operator: πk+1 ← G k+1(ν, vσk) (5) While the standard PSDP algorithm of Bagnell et al. (2003) considers a horizon T and makes T iterations, the algorithm we consider here has an indefinite number of iterations.",
      "startOffset" : 102,
      "endOffset" : 1201
    }, {
      "referenceID" : 1,
      "context" : "This algorithm is a natural variation of the Policy Search by Dynamic Programming algorithm (PSDP) of Bagnell et al. (2003), originally proposed to tackle finite-horizon problems, to the infinite-horizon case; we thus refer to it as PSDP∞. To the best of our knowledge however, this variation has never been used in an infinite-horizon context. The algorithm is based on finite-horizon non-stationary policies. Given a sequence of stationary deterministic policies (πk) that the algorithm will generate, we will write σk = πkπk−1 . . . π1 the k-horizon policy that makes the first action according to πk, then the second action according to πk−1, etc. Its value is vσk = TπkTπk−1 . . . Tπ1r. We will write ∅ the “empty” non-stationary policy. Note that v∅ = r and that any infinite-horizon policy that begins with σk = πkπk−1 . . . π1, which we will (somewhat abusively) denote “σk . . . ” has a value vσk... ≥ vσk −γVmax. Starting from σ0 = ∅, the algorithm implicitely builds a sequence of non-stationary policies (σk) by iteratively concatenating the policies that are returned by the approximate greedy operator: πk+1 ← G k+1(ν, vσk) (5) While the standard PSDP algorithm of Bagnell et al. (2003) considers a horizon T and makes T iterations, the algorithm we consider here has an indefinite number of iterations. The algorithm can be stopped at any step k. The theory that we are about to describe suggests that one may return any policy that starts by the non-stationary policy σk. Since σk is an approximately good finite-horizon policy, and as we consider an infinite-horizon problem, a natural output that one may want to use in practice is the infinitehorizon policy that loops over σk, that we shall denote (σk) ∞. In practice, controlling the greedy step with respect to dπk,ν requires to generate samples from this very distribution. As explained by Kakade & Langford (2002), one such sample can be done by running one trajectory starting from ν and following πk, stopping at each step with probability 1 − γ.",
      "startOffset" : 102,
      "endOffset" : 1888
    }, {
      "referenceID" : 9,
      "context" : "NSPI(m) We originally devised the algorithmic scheme of Equation (5) (PSDP∞) as a simplified variation of the Non-Stationary PI algorithm with a growing period algorithm (NSPI-growing) (Scherrer & Lesner, 2012)2. With respect to Equation (5), the only difference of NSPIgrowing resides in the fact that the approximate greedy step is done with respect to the value v(σk)∞ of the policy that loops infinitely over σk (formally the algorithm does πk+1 ← G k+1(ν, v(σk)∞)) instead of the value vσk of only the first k steps here. Following the intuition that when k is big, these two values will be close to each other, we ended up considering PSDP∞ because it is simpler. NSPIgrowing suffers from the same memory drawback as CPI and PSDP∞. Interestingly, the work of Scherrer & Lesner (2012) contains another algorithm, Non-Stationary PI with a fixed period (NSPI(m)), that has a parameter that directly controls the number of policies stored in memory.",
      "startOffset" : 186,
      "endOffset" : 790
    }, {
      "referenceID" : 7,
      "context" : "Implementing this algorithm in practice can trivially be done through cost-sensitive classification in a way similar to Lazaric et al. (2010). It could also be done with a straight-forward extension of LSTD(λ) to non-stationary policies.",
      "startOffset" : 120,
      "endOffset" : 142
    }, {
      "referenceID" : 2,
      "context" : "Relaxing the goal to controlling the weighted `p-norm for some p ≥ 2 allows to introduce some finer coefficients (Farahmand et al., 2010; Scherrer et al., 2012).",
      "startOffset" : 113,
      "endOffset" : 160
    }, {
      "referenceID" : 12,
      "context" : "Relaxing the goal to controlling the weighted `p-norm for some p ≥ 2 allows to introduce some finer coefficients (Farahmand et al., 2010; Scherrer et al., 2012).",
      "startOffset" : 113,
      "endOffset" : 160
    }, {
      "referenceID" : 7,
      "context" : "(2)) C 1 (1−γ)2 1 1−γ log 1 1 (Lazaric et al., 2010) (= NSPI(1)) C 1 (1−γ)2 log 1 API(α) (Eq.",
      "startOffset" : 30,
      "endOffset" : 52
    }, {
      "referenceID" : 7,
      "context" : "(2)) C 1 (1−γ)2 1 1−γ log 1 1 (Lazaric et al., 2010) (= NSPI(1)) C 1 (1−γ)2 log 1 API(α) (Eq. (4) C 1 (1−γ)2 1 α(1−γ) log 1 CPI(α) C 1 (1−γ)3 1 α(1−γ) log 1 CPI (Eq. (3)) C (1,0) 1 (1−γ)3 log 1 1 1−γ 1 log 1 Cπ∗ 1 (1−γ)2 γ 2 (Kakade & Langford, 2002) PSDP∞ (Eq. (5)) Cπ∗ 1 (1−γ)2 log 1 1 1−γ log 1 (' NSPI(∞)) C (1) π∗ 1 1−γ 1 1−γ log 1 NSPI(m) (Eq. (6)) C 1 (1−γ)(1−γm) 1 1−γ log 1 m C m 1 (1−γ)2(1−γm) log 1 1 1−γ log 1 C (1) π∗ + γ mC 1−γm 1 1−γ 1 1−γ log 1 Cπ∗ + γ m C m(1−γm) 1 (1−γ)2 log 1 1 1−γ log 1 Table 1. Upper bounds on the performance guarantees for the algorithms. Except when references are given, the bounds are to our knowledge new. A comparison of API and CPI based on the two known bounds was done by Ghavamzadeh & Lazaric (2012). The first bound of NSPI(m) can be seen as an adaptation of that provided by Scherrer & Lesner (2012) for the more restrictive `∞-norm setting.",
      "startOffset" : 31,
      "endOffset" : 750
    }, {
      "referenceID" : 7,
      "context" : "(2)) C 1 (1−γ)2 1 1−γ log 1 1 (Lazaric et al., 2010) (= NSPI(1)) C 1 (1−γ)2 log 1 API(α) (Eq. (4) C 1 (1−γ)2 1 α(1−γ) log 1 CPI(α) C 1 (1−γ)3 1 α(1−γ) log 1 CPI (Eq. (3)) C (1,0) 1 (1−γ)3 log 1 1 1−γ 1 log 1 Cπ∗ 1 (1−γ)2 γ 2 (Kakade & Langford, 2002) PSDP∞ (Eq. (5)) Cπ∗ 1 (1−γ)2 log 1 1 1−γ log 1 (' NSPI(∞)) C (1) π∗ 1 1−γ 1 1−γ log 1 NSPI(m) (Eq. (6)) C 1 (1−γ)(1−γm) 1 1−γ log 1 m C m 1 (1−γ)2(1−γm) log 1 1 1−γ log 1 C (1) π∗ + γ mC 1−γm 1 1−γ 1 1−γ log 1 Cπ∗ + γ m C m(1−γm) 1 (1−γ)2 log 1 1 1−γ log 1 Table 1. Upper bounds on the performance guarantees for the algorithms. Except when references are given, the bounds are to our knowledge new. A comparison of API and CPI based on the two known bounds was done by Ghavamzadeh & Lazaric (2012). The first bound of NSPI(m) can be seen as an adaptation of that provided by Scherrer & Lesner (2012) for the more restrictive `∞-norm setting.",
      "startOffset" : 31,
      "endOffset" : 852
    }, {
      "referenceID" : 0,
      "context" : "More precisely, we consider Garnet problems first introduced by Archibald et al. (1995), which are a class of randomly constructed finite MDPs.",
      "startOffset" : 64,
      "endOffset" : 88
    }, {
      "referenceID" : 9,
      "context" : "As a matter of fact, several other dynamic programming algorithms, namely AVI (Munos, 2007), λPI (Scherrer, 2013), AMPI (Scherrer et al.",
      "startOffset" : 78,
      "endOffset" : 91
    }, {
      "referenceID" : 10,
      "context" : "As a matter of fact, several other dynamic programming algorithms, namely AVI (Munos, 2007), λPI (Scherrer, 2013), AMPI (Scherrer et al.",
      "startOffset" : 97,
      "endOffset" : 113
    }, {
      "referenceID" : 12,
      "context" : "As a matter of fact, several other dynamic programming algorithms, namely AVI (Munos, 2007), λPI (Scherrer, 2013), AMPI (Scherrer et al., 2012), come with guarantees involvWe recall that to our knowledge, the use of PSDP∞ (PSDP in an infinite-horizon context) is not documented in the literature.",
      "startOffset" : 120,
      "endOffset" : 143
    }, {
      "referenceID" : 10,
      "context" : "By following the proof technique of Scherrer & Lesner (2012), writing Γk,m = (γPπk)(γPπk−1) · · · (γPπk−m+1) and ek+1 = maxπ′ Tπ′vπk,m − Tπk+1vπk,m , one can show that: vπ∗ − vπk,m ≤ k−1 ∑ i=0 (γPπ∗) (I − Γk−i,m)ek−i + γVmax.",
      "startOffset" : 36,
      "endOffset" : 61
    }, {
      "referenceID" : 8,
      "context" : "CPI, CPI(α), API(α): Conservative steps are addressed by a tedious generalization of the proof for API by Munos (2003). Due to lack of space, the proof is deferred to the Supplementary Material.",
      "startOffset" : 106,
      "endOffset" : 119
    } ],
    "year" : 2014,
    "abstractText" : "We consider the infinite-horizon discounted optimal control problem formalized by Markov Decision Processes. We focus on several approximate variations of the Policy Iteration algorithm: Approximate Policy Iteration (API) (Bertsekas & Tsitsiklis, 1996), Conservative Policy Iteration (CPI) (Kakade & Langford, 2002), a natural adaptation of the Policy Search by Dynamic Programming algorithm (Bagnell et al., 2003) to the infinite-horizon case (PSDP∞), and the recently proposed Non-Stationary Policy Iteration (NSPI(m)) (Scherrer & Lesner, 2012). For all algorithms, we describe performance bounds with respect the per-iteration error , and make a comparison by paying a particular attention to the concentrability constants involved, the number of iterations and the memory required. Our analysis highlights the following points: 1) The performance guarantee of CPI can be arbitrarily better than that of API, but this comes at the cost of a relative—exponential in 1 —increase of the number of iterations. 2) PSDP∞ enjoys the best of both worlds: its performance guarantee is similar to that of CPI, but within a number of iterations similar to that of API. 3) Contrary to API that requires a constant memory, the memory needed by CPI and PSDP∞ is proportional to their number of iterations, which may be problematic when the discount factor γ is close to 1 or the approximation error is close to 0; we show that the NSPI(m) algorithm allows to make an overall trade-off between memory and performance. Simulations with these schemes confirm our analysis. Proceedings of the 31 st International Conference on Machine Learning, Beijing, China, 2014. JMLR: W&CP volume 32. Copyright 2014 by the author(s).",
    "creator" : "LaTeX with hyperref package"
  }
}