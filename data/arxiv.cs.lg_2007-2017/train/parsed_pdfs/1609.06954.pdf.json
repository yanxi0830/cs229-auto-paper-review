{
  "name" : "1609.06954.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Semiring Programming: A Framework for Search, Inference and Learning",
    "authors" : [ "Vaishak Belle", "Luc De Raedt" ],
    "emails" : [ "vaishak@cs.kuleuven.be", "luc.deraedt@cs.kuleuven.be" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 9.\n06 95\n4v 1\n[ cs\n.A I]\n2 1\nSe p\n20 16"
    }, {
      "heading" : "1 Introduction",
      "text" : "AI applications, such as robotics and logistics, rely on a variety of disciplines such as logic, probabilistic reasoning, machine learning and mathematical programming. These applications are often described in a combination of natural and mathematical language, and need to be engineered for the individual application. Formal languages that allow declarative specifications enable re-use and descriptive clarity.\nThe subfields of AI have contributed many formalisms for the declarative modeling and effective solving of problems. In knowledge representation and constraint programming, for example, languages such ASP (Brewka, Eiter, and Truszczyński 2011) and Essence (Frisch et al. 2008) are prominent, which use SAT, SMT and MIP technology. In machine learning and probabilistic reasoning, statistical relational learning systems and probabilistic programming languages such as Markov Logic (Richardson and Domingos 2006), Church (Goodman et al. 2008) and Problog (De Raedt, Kimmig, and Toivonen 2007) are prominent, which use sampling and model counting methodologies. Finally, in mathematical programming and optimization, disciplined programming (Grant and Boyd 2008) and AMPL (Fourer, Gay, and Kernighan 1993) have been developed.\nBe that as it may, it is widely accepted that solving realworld AI problems requires an integration of different disciplines. Consider, for example, that a robot may decide its course of action using a SAT-based planner, learn about the\nworld using Kalman filters, and grasp objects using geometric optimization technology (Srivastava et al. 2014). But contemporary declarative frameworks offer little support for such universality: KR and constraint formalisms mostly focus on model generation for discrete problems, probabilistic programming languages do not handle linear and arithmetic constraints, and finally, optimization frameworks work with linear algebra and algebraic constraints to specify the problem and thus are quite different from the high-level descriptions used in the other disciplines and do not support probabilistic or logical reasoning.\nWhat is lacking here is a universal modeling framework that allows us to declaratively specify problems involving logic and constraints, mathematical programs, as well as discrete and continuous probability distributions in a simple, uniform, modular and transparent manner. Such a framework would greatly simplify the development and understanding of AI systems with integrated capabilities, and would tame the model building process. In this paper, we propose a new declarative framework called semiring programming (SP) that is an attempt to fill this gap.\nEugene Freuder (1997) famously quipped: “constraint programming represents one of the closest approaches computer science has yet made to the Holy Grail of programming: the user states the problem, the computer solves it.” The underlying idea was summarized in the slogan:\n(constraint) program = model + solver\nThe vision of SP builds upon this equation in that:\n(semiring) program = logical theory + semiring + solver\nThus a model is expressed in a logical system in tandem with a semiring and a weight function. In its essence, semiring programming rests on three important developments:\n• Semirings have been successfully shown to unify specifications such as finding a solution versus counting the number of solutions (Bistarelli 2004).\n• Weighted model counting represents perhaps the simplest approach to reason about weights on possible worlds and elegantly decouples the logical representation from the weight function (Chavira and Darwiche 2008).\n• Probabilistic programming languages like Church can appeal to their host languages (e.g. LISP) to naturally support composition and abstraction.\nAs a framework, SP is set up to allow the modeler to freely choose the logical theory (syntax and semantics) and so everything from non-classical logical consequence to realarithmetic is fair game. Together with a semiring and these weights, a program computes the count. Our task will be to show that the usual suspects from AI disciplines, such as SAT, CSP, Bayesian inference, and convex optimization can be: (a) expressed as a program, and (b) count is a solution to the problem, that is, the count can be a {yes, no} answer in SAT, a probability in Bayesian inference, or a bound in convex optimization. In other words, the count is shown to provide abstractions for challenging AI tasks. We will also demonstrate a variety of more complex problems, such as matrix factorization, and one on compositionality.\nThe fundamental question, then, is this: how are to we provide a semantics for such a programming language? It is not possible to piggyback on mathematical accounts of optimization problems in an obvious way, because the language is allowed to be richer than what is usually assumed. That is a central focus of this paper.\nAt the outset, we remark that our concern here is on the formal nature and generality of the framework, in terms of its modeling capabilities. Ideas on solvers are left to a discussion, and their realizations to the future."
    }, {
      "heading" : "2 Preliminaries",
      "text" : ""
    }, {
      "heading" : "Logical Setup",
      "text" : "The framework is developed in a general way, agnostic about the meaning of sentences. We adopt (and assume familiarity with) terminology from predicate logic (Enderton 1972).\nDefinition 1: A theory T is a triple (L,M, |=), where L is a set of sentences called the language of the theory, M a set called the models of the theory, and |= a subset of M × L called the satisfiability relation.\nThe set L is implicitly assumed to be defined over a vocabulary vocab(L) of relation and function symbols, each with an associated arity. Constant symbols are 0-ary function symbols. Every L-model M ∈ M is a tuple containing a universe dom(M), and a relation (function) for each relation (function) symbol of vocab(L). For relation (constant) symbol p, the relation (universe element) corresponding to p in a model M is denoted pM . For φ ∈ L and M ∈ M, we write M |= φ to say that M satisfies φ. We let M(φ) denote {M ∈ M | M |= φ}. Finally, the set lits(L) denotes the literals in L, and we write l ∈ M to refer to the L-literals that are satisfied at M.\nThis formulation is henceforth used to instantiate a particular logical system, such as fragments/extensions of firstorder logic, as well as non-classical logical consequence.\nExample 2: Suppose T = (L,M, |=) is as follows: L is obtained using a set of 0-ary predicates P and Boolean connectives, M are {0, 1} assignments to the elements of P, and |= denotes satisfaction in propositional logic via the usual inductive rules. Then, we obtain a propositional theory.\nExample 3: Define a theory (L,M, |=) where L is the positive Horn fragment from a finite vocabulary, M the set of propositional interpretations, and for M ∈ M, φ ∈ L, define\nM |= φ iff M |=PL φ (i.e., satisfaction in propositional logic) and for all M′ ( M, M′ 6|=PL φ. This theory can be used to reason about the minimal models of a formula."
    }, {
      "heading" : "Weighted Model Counting",
      "text" : "Semiring programming draws from the conceptual simplicity of weighted model counting (WMC), which we briefly recap here. WMC is an extension of #SAT, where one simply counts the number of models of a propositional formula (Gomes, Sabharwal, and Selman 2009). In WMC, one accords a weight to a model in terms of the literals true at the model, and computes the sum of the weights of all models.\nDefinition 4: Suppose φ is a formula from a propositional language L with a finite vocabulary, and suppose M is the set of L-models. Suppose w: lits(L) → R≥0 is a weight function. Then:1\nWMC(φ,w) = ∑\nM|=φ\n∏\nl∈M\nw(l)\nis called the weighted model count (WMC) of φ.\nThe formulation elegantly decouples the logical sentence from the weight function. In this sense, it is clearly agnostic about how weights are specified in the modeling language, and thus, has emerged as an assembly language for Bayesian networks (Chavira and Darwiche 2008), and probabilistic programs (Fierens et al. 2011), among others."
    }, {
      "heading" : "Commutative Semirings",
      "text" : "Our programming model is based on algebraic structures called semirings (Kuich 1997); the essentials are as follows:\nDefinition 5: A (commutative) semiring S is a structure (S,⊕,⊗, 0, 1) where S is a set called the elements of the semiring, ⊕ and ⊗ are associative and commutative, 0 is the identity for ⊕, and 1 is the identity for ⊗.\nAbusing notation, when the multiplication operator is not used, we simply refer to the triple (S,⊕, 0) as a semiring.\nExample 6: The structure (N,+,×, 0, 1) is a commutative semiring in that for every a, b ∈ N, a + 0 = a, a × 1 = a, a + b = b + a, and so on."
    }, {
      "heading" : "3 Semiring Programming",
      "text" : "In essence, the semiring programming scheme is as follows:\n• Input: a theory T = (L,M, |=), a sentence φ ∈ L, a commutative semiring S, and a weight function w.\n• Output: the count, denoted #(φ,w).\nThe scope of these programs is broad, and so we will need different kinds of generality. Roughly, the distinction boils down to: (a) whether the set of models for a formula is finite or infinite, and (b) whether the weight function can be factorized over the literals or not (in which case the weight function directly labels the models of a theory). The thrust of this section is: (a) to show how these distinctions subsume important model generation notions in the literature,\n1In the context of L-models M, we simply write t = ∑\nM|=φ u to mean t = ∑\n{M∈M|M|=φ} u.\nand (b) providing rigorous definitions for the count operator. In terms of organization, we begin with the finite case, before turning to the infinite ones. We present an early preview of some of the models considered in Figure 1."
    }, {
      "heading" : "Finite",
      "text" : "Here, we generalize the WMC formulation to semiring labels, but also go beyond classical propositional logic.\nDefinition 7: We say the theory T = (L,M, |=) is finite if for every φ ∈ L, {M ∈ M | M |= φ} is finite.\nSo, a propositional language with a finite vocabulary is a finite theory, regardless of (say) standard or minimal models. Similarly, a first-order language with a finite Herbrand base is also a finite theory.\nDefinition 8: Suppose T = (L,M, |=) is a finite theory. Suppose S = (S,⊕,⊗, 0, 1) is a commutative semiring. Suppose w : M → S. For any φ ∈ L, we define:\n#(φ,w) = ⊕\nM|=φ\nw(M)\nIf w : lits(L) → S, then the problem is factorized, where:\nw(M) = ⊗\nl∈M\nw(l).\nEssentially, as in WMC, we sum over models and take products of the weights on literals but wrt a particular semiring.\nExample 9: We demonstrate SAT and #SAT. Consider a propositional theory T = (L,M, |=) where vocab(L) = {p, q} , and suppose φ = (p ∨ q). Letting M be standard Lmodels, clearly |M| = 4 and | {M ∈ M | M |= φ} | = 3. Suppose for every M ∈ M, w is function such that w(M) = 1. For the semiring ({0, 1} ,∨, 0):\n#(φ,w) = ∨\nM|=φ\nw(M) = 1 ∨ 1 ∨ 1 = 1.\nConsider the semiring (N,+, 0) instead. Then\n#(φ,w) = ∑\nM|=φ\nw(M) = 1 + 1 + 1 = 3.\nAs with Definition 4, the framework is agnostic about the modeling language. But for presentation purposes, programs are sometimes described using a notation inspired by the SMT-LIB standard (Barrett, Fontaine, and Tinelli 2015).\nExample 10: We demonstrate MPE (most probable explanation) and WMC. Consider the theory, semiring and weight function w from Figure 2, which specifies, for example, a vocabulary of two propositions p and q, w(p) = 1 and w(¬p) = 2. In accordance with that semiring, the weight of a model, say {p,¬q}, of the formula F is 1 × 4 = 4. Thus, for the semiring (N,max,×, 0, 1), we have:\n#(F,w) = max {6, 3, 4} = 6\nwhich finds the most probable assignment. Consider the semiring (N,+,×, 0, 1) instead. Then:\n#(F,w) = 6 + 3 + 4 = 13\nwhich gives us the weighted model count.\nExample 11 : Extending the discussion in (Hooker and Lama 1999), we consider a class of mathematical programs where linear constraints and propositional formulas can be combined freely. See Figure 3 for an example with non-linear objectives. Formally, quantifierfree linear integer arithmetic and propositional logic are specified as the underlying logical systems, and the domains of constants are typed. The program declares formulas F, G, and H.\nThe counting task is non-factorized, and our convention for assigning weights to models is by letting the declare-weight directive also take arbitrary formulas as arguments. Of course, TRUE holds in every model, and so, the weight of every model is determined by the evaluation of x1 ∗ x2 at the model, that is, for any M, its weight is ∗M(x1M , x2M). For example, a model that assigns 1 to x1 and 1 to x2 is accorded the weight 1∗1.Computing the count over (N,max, 0) then yields a model of H with the highest value for x1 ∗ x2.\nTo see this program in action, consider that every model of H must satisfy p2, and so must admit 3 ∗ x1 <= 4 and 2 ∗ x2 <= 5. Since {x1, x2} can only take values {1, . . . , 10}, given the constraints, the desired model must assign x1 and x2 to 1 and 2 respectively. Then, its weight is 1 ∗ 2.\nEncoding finite domain constraint satisfaction problems as propositional satisfiability is well-known. The benefit, then, of appealing to our framework is the ability to easily formulate counting instances:\nTheorem 12: Suppose Q is a CSP over variablesX, domains D and constraints C. There is a first-order theory (L,M, |=), a L-sentence φ and a weight function w such that #(φ,w) = 1 over ({0, 1} ,∨, 0) iff Q has a solution. Furthermore, Q has n solutions iff #(φ,w) = n over (N,+, 0).\nConstraints are Boolean-valued functions (Freuder and Mackworth 2006), and so constraints over X can be encoded as L-sentences. We omit the details, but do an example.\nExample 13: See Figure 4 for a counting instance of graph coloring: edge(x, y) determines there is an edge between x and y, node(x) says that x is a node, and color(x,y) says that node x is assigned the color y. The actual graph is provided using the formula DATA, which declares a fully connected 3-node graph. Also, CONS is a conjunction of the usual coloring constraints, e.g., an edge between nodes x and y means that they cannot be assigned the same color.\nLet M be a set of first-order structures for the vocabulary {edge, node, color}, respecting types from Figure 4. The interpretation of {edge, node} is assumed to be the same for all the models in M and is as given by DATA. Basically, then, the models differ in their interpretation of color. One model of φ = (DATA and CONS), for example, is {color(1, r), color(2, g), color(3, b)}. The weights of all models is 1, and so, for (N,+, 0) we get:2\n#(φ,w) = 6.\nTo summarize, the following result is easily shown for semiring programs:3\nTheorem 14: Suppose θ ∈ {SAT, #SAT,WMC,CSP, #CSP}. Suppose θ◦ is a solution to θ, in that θ◦ ∈ {0, 1} for SAT and CSP, and θ◦ ∈ R for the rest. Then for any θ, there is a T = (L,M, |=), S, w and φ ∈ L such that #(φ,w) = θ◦."
    }, {
      "heading" : "Infinite: Non-factorized",
      "text" : "Defining measures (Halmos 1950) on the predicate calculus is central to logical characterizations of probability theory (Halpern 1990; Chistikov, Dimitrova, and Majumdar 2015). We adapt this notion for semirings to introduce a general form of counting. For technical reasons, we assume that the universe of the semirings is R. (If required, the range of the weight function can always be restricted to any subset of R.)\n2In an analogous fashion, soft and weighted CSPs can be expressed using semirings (Bistarelli et al. 1999).\n3We remark that although the count operator in itself does not provide the variable assignments for SAT and CSP, we assume this can be retrieved from the satisfying interpretations.\nDefinition 15 : Let S = (R,⊕, 0) be any semiring and T = (L,M, |=) a theory. Let Σ be a σ-algebra over M in that (M,Σ) is a σ-finite measurable space wrt the measure µ:Σ → R respecting ⊕. That is, for all E ∈ Σ, µ(E) ≥ 0, µ({}) = 0 and µ is closed under complement and countable unions: for all pairwise disjoint countable sets E1, . . . ∈ Σ, we have\nµ( ∞ ⋃\nj=1\nE j) = ∞ ⊕\nj=1\nµ(E j).\nMoreover, because the spaces are σ-finite, M is the countable union of measurable sets with finite measure. Then for any φ ∈ L, #(φ, µ) = µ(M(φ)).\nExample 16: We demonstrate convex optimization. Suppose T = (L,M, |=) is a first-order theory only containing constants X = {x1, . . . , xk} with domains Di = R. Suppose φ(x1, . . . , xk) ∈ L is a conjunction of formulas of the form c1x1 + . . .+ ck xk ≤ d, for real numbers c1, . . . , ck, d, and thus describing a polyhedron. In other words, for every M ∈ M, dom(M) = R, and so, M is a real-valued assignment to X. In particular, if M |= φ, then xM1 , . . . , x M k is a point inside the polyhedron φ. Let Σ be a σ-algebra over M and so every E ∈ Σ is a measurable set of points.\nSuppose f (x1, . . . , xk):Rk → R is a convex function that we are to minimize. Consider the semiring (R, inf, 0) and a measure µ such that for any E ∈ Σ:\nµ(E) = inf { f (xM1 , . . . , x M k ) | M ∈ E }\nwhich finds the infimum of the f -values across the assignments in E. Then, µ(M(φ)) = #(φ, µ) gives the minimum of the convex function in the feasible region determined by φ.\nSuppose f is a concave function that is to be maximized. We would then use (R, sup, 0) instead, which finds the supremum of the f -values across assignments in E ∈ Σ.\nMore generally, the same construction is easily shown to be applicable for other families of mathematical programming (e.g., non-linear optimization) as follows:\nTheorem 17: Suppose {x1, . . . , xk} is a set of real-valued variables. Suppose P ⊂ Rk is the feasible region of an optimization problem of the form gi(x1, . . . , xk) ◦ di for i ∈ N,\nwhere ◦ ∈ {≤, <,≥, >} and gi:Rk → R. Suppose f :Rk → R is a function to be maximized (minimized). Then there is a T = (L,M, |=),S, µ and φ ∈ L such that #(φ, µ) is the maximum (minimum) value for f in the feasible region P.\nExample 18 : For a non-trivial example, consider the problem of matrix factorization, a fundamental concern in information retrieval and computer vision (Ding, Li, and Jordan 2010). Given a matrix I ∈ Rp×n, we are to compute matrices L ∈ Rp×k and R ∈ Rn×k, such that e = ||I − LRT || is minimized. (Here, || · || denotes the Frobenius Norm.) Using real arithmetic, we provide a formulation in Figure 5. (Free variables are assumed to be implicitly quantified from the outside.)\nLet T = (L,M, |=) be the theory of real arithmetic, where L includes the following function symbols: {input, left, right, app, err}.Here, input(x, y) is a realvalued function such that x ∈ {1, . . . , p} and y ∈ {1, . . . , n} in that input(m, n) is the entry at the mth row and the nth column of the matrix I; these entries are specified by DATA. Letting φ = (DATA and F and G), the set {M ∈ M | M |= φ} are those L-models whose interpretation of input is fixed by DATA.Basically, these models vary in their interpretations of {left, right}, which determines their interpretations for app and err. Here, app computes the product of the matrices left and right, and err computes the Frobenius Norm wrt app and input.\nLet Σ be a σ-algebra over M. The weight function in Figure 5 determines a measure µ such that for any E ∈ Σ:\nµ(E) = inf { errM | M ∈ E } .\nTherefore, #(φ, µ) yields the lowest err value; the model M such that errM = #(φ, µ) is one with the best factorization of matrix I."
    }, {
      "heading" : "Infinite: Factorized",
      "text" : "Despite the generality of the above definition, we would like to address the factorized setting for a number of applications, the most prominent being probabilistic inference in hybrid graphical models (Belle, Passerini, and Van den Broeck 2015). Consider, for example, a joint distribution on the probability space R × {0, 1}. Here, it is natural to define weights for\neach random variable separately, prompting a factorized formulation of counting. More generally, in many robotic applications, such hybrid spaces are common (Thrun, Burgard, and Fox 2005). The main idea then is to apply our definition for counting by measures to each variable independently, and construct a measure for the entire space by product measures (Halmos 1950).\nA second technicality is that in the finite case, the set of literals true at a model was finite by definition. This is no longer the case. For example, suppose x is a real-valued variable in a language L, and M is a L-model that assigns 3 to x. Then, M |= (x = 3) but also M |= (x , 3.1), M |= (x , 3.11), . . . , and so on. Thus, for technical reasons, we assume that L only consists of constant symbols X = {x1, . . . , xk} with fixed (possibly infinite) domains {D1, . . . , Dk}; the measures are defined for these domains.\nDefinition 19 : Let S = (R,⊕,⊗, 0, 1) be any semiring, T = (L,M, |=) any theory where vocab(L) = {x1, . . . , xk} over fixed domains Di. Suppose φ ∈ L. Suppose Σi is a σalgebra over Di in that (Di,Σi) is a σ-finite measurable space wrt the measure µi:Σi → R respecting ⊕ (as in Definition 15). Define the product measure µ∗ µ1 × · · · × µk on the measurable space (D1 × · · · × Dk,Σ1 × · · ·Σk) satisfying:4\nµ∗(E1 × · · · × Ek) = µ1(E1) ⊗ · · · ⊗ µk(Ek)\nfor all Ei ∈ Σi. Finally, define\n#(φ, µ∗) = µ∗([φ])\nwhere [φ] = {\nxM1 × . . . × x M k | M ∈ M(φ)\n}\n.\nIntuitively, E1 ∈ Σ1, . . . , Ek ∈ Σk capture sets of assignments, and the product measure considers the algebraic product of the weights on assignments to terms. As before, for Ei, E′i ∈ Σi, µi(Ei ∪ E ′ i ) = µi(Ei) ⊕ µi(E ′ i ). Finally, precisely because the measures are defined on the domains of the terms, we obtain these for all of the satisfying interpretations using the construction [φ].\nExample 20 : We demonstrate the problem of finding the volume of a polyhedron, needed in the static analysis of probabilistic programs (Sankaranarayanan, Chakarov, and Gulwani 2013; Chistikov, Dimitrova, and Majumdar 2015). Suppose T = (L,M, |=) and φ ∈ L is as in Example 16, that is, φ defines a polyhedron. For every 0-ary function symbol xi ∈ {x1, . . . , xk} with domain Di = R, let Σi be the set of all Borel subsets of R, and let µi be the Lebesgue measure. Thus, for any E ∈ Σi, µi(E) gives the length of this line. Then, for the semiring (R,+,×, 0, 1), the + operator sums the lengths of lines for each variable, and × computes the products of these lengths. Thus, #(φ, µ∗) is the volume of φ.\nTo see this in action, suppose φ = (2x ≤ 5)∧(x ≥ 1)∧(0 ≤ y ≤ 2). Then M(φ) = { 〈x → n, y → m〉 | n,m ∈ R, |= φx,yn,m }\n, that is, all assignments to x and y such that φx,yn,m is a valid expression in arithmetic. Therefore,\n[φ] = {(n,m) | n ∈ [1, 2.5],m ∈ [0, 2], n ∈ R,m ∈ R} .\n4The product measure is unique owing to the σ-finite assumption via the Hahn-Kolmogorov theorem (Halmos 1950).\nAssuming µx is the Lebesgue measure for all Borel subsets of the domain of x, we have\nµx({n | n ∈ [1, 2.5], n ∈ R}) = 1.5.\nAnalogously, µy({m | m ∈ [0, 2],m ∈ R}) = 2. Then, the volume is #(φ, µ∗) = µ∗([φ]) = 1.5 × 2 = 3.\nExample 21: We demonstrate probabilistic inference in hybrid models (Belle, Passerini, and Van den Broeck 2015) by extending Example 20. Consider a probabilistic program:\nX ∼ UNIFORM(0, 1) Y ∼ FLIP(0, 1) if (X > .6 AND Y , 1) then return DONE\nIn English: X is drawn uniformly from [0,1] and Y ∈ {0, 1} is the outcome of a coin toss. If X > .6 and Y is not 1, the program terminates successfully. Suppose we are interested in the probability of DONE, which is expressed as the formula:\nφ = (0 ≤ X ≤ 1) ∧ (Y = 0 ∨ Y = 1) ∧ (X > .6 ∧ Y , 1).\nSuppose T = (L,M, |=) is the theory of linear real arithmetic, with vocab(L) = {X, Y}, DX = R and DY = {0, 1} . As in Example 20, let ΣX be the set of all Borel subsets of R and µX the Lebesgue measure. Let ΣY be the set of all subsets of {0, 1} and µY be the counting measure, e.g., µY ({}) = 0, µY ({1}) = 1, and µY ({0, 1}) = 2. So M(φ) = { 〈X → n, Y → m〉 | n ∈ R,m ∈ {0, 1} , |= φX,Yn,m } and:\n[φ] = {(n,m) | n > .6, 0 ≤ n ≤ 1, n ∈ R,m ∈ {0, 1}} ∩ {(n,m) | 0 ≤ n ≤ 1, n ∈ R,m , 1,m ∈ {0, 1}} .\nThis means that µX({n | ∃m (n,m) ∈ [φ]}) = .4 and also µY ({m | ∃n (n,m) ∈ φ}) = 1. Thus, µ∗([φ]) = .4 × 1. Analogously, µ∗([φ ∨ ¬φ]) = 2. Therefore, the probability of DONE is .4/2 = .2.\nIn general, we have a variant of Theorem 17 (Hindi 2004):\nTheorem 22: Suppose {x1, . . . , xk} is any set of real-valued variables. Suppose D is any countable set. Suppose P ⊂ Rm × Dn, where m + n = k, is any region given by conjunctions of expressions of the form c1x1 + . . .+ ck xk ◦ e and xi ⋄d, where ◦ ∈ {≤, <,≥, >}, ⋄ ∈ {,,=}, ci, e ∈ R and d ∈ D. Then there is a T = (L,M, |=),S, µ and φ ∈ L such that #(φ, µ) is the volume of P."
    }, {
      "heading" : "4 Compositionality",
      "text" : "A noteworthy feature of many logic-based knowledge representation formalisms is their compositional nature. In semiring programming, using the expressiveness of predicate logic, it is fairly straightforward to combine theories over possibly different signatures (e.g., propositional logic and linear arithmetic), as seen, for example, in SMT solvers (Barrett et al. 2009).\nA more intricate flavor of compositionality is when the new specification becomes difficult (or impossible) to define using the original components. This is a common occurrence in large software repositories, and has received a lot of attention in the AI community (Lierler and Truszczynski 2015).\nIn this section, we do not attempt to duplicate such efforts, but propose a different account of compositionality that is\ncloser in spirit to semiring programming. It builds on similar ideas for CSPs (Bistarelli 2004), and is motivated by machine learning problems where learning (i.e., optimization) and inference (i.e., model counting) need to be addressed in tandem. More generally, the contribution here allows us to combine two semiring programs, possibly involving different semirings. For simplicity of presentation, we consider non-factorized and finite problems.\nDefinition 23 : Suppose S1 = (S1,⊕1, 01) and S2 = (S2,⊕2, 02) are any two semirings. We define their composition S = (S,⊕, 0) as:\n• S = {(a, b) | a ∈ S1, b ∈ S2}; • 0 = (01, 02); • for every c = (a, b) ∈ S and c′ = (a′, b′) ∈ S, let c ⊕ c′ =\n(a ⊕1 a′, b ⊕2 b′).\nThat is, the composition of the semirings is formed from the Cartesian product, respecting the summation operator for the individual structures.\nDefinition 24 : Suppose T1 = (L1,M1, |=1) and T2 = (L2,M2, |=2) are theories, where L1 and L2 do not share atoms, S1 and S2 semirings, and w1 and w2 weight functions for M1 and M2 respectively. Given the environments (T1,S1,w1) and (T2,S2,w2), we define its composition as (T ,S,w), where S is a composition of S1 and S2 and T = (L,M, |=):\n• φ ∈ L is obtained over Boolean connectives from L1∪L2. • M = {(M1, M2) | Mi ∈ Mi} . • The meaning of φ ∈ L is defined inductively:\n– (M1, M2) |= p for atom p iff M1 |=1 p if p ∈ L1 and M2 |=2 p otherwise;\n– (M1, M2) |= ¬φ iff (M1, M2) 6|= φ; – (M1, M2) |= φx ∧ φy iff (M1, M2) |= φi for i ∈ {x, y}.\n• For any (M1, M2) ∈ M, w((M1, M2)) = (w1(M1),w2(M2)).\nIn essence, the Cartesian product for the semirings is extended for arbitrary theories and weight functions. The meaning of formulas rests on the property that L1 and L2 do not share atoms.5 It is now easy to see that the counting for problem for T works as usual: that is, for any φ ∈ L,\n#(φ,w) = ⊕\n(M1,M2)|=φ\nw((M1, M2)).\nExample 25: We demonstrate a (simple) instance of combined learning and inference. Imagine a robot navigating a world by performing move actions, and believes its actuators need repairs. But before it alerts the technician, it would like to test this belief. A reasonable test, then, is to inspect its trajectory so far, and check whether the expected outcome of a move action in the current state matches the behavior of\n5This is analogous to SMT solvers for combinations of theories (Barrett et al. 2009). However, see (Lierler and Truszczynski 2015; Ensan and Ternovska 2015) for accounts of modularity based on first-order structures sharing vocabularies (and thus, atoms).\nthe very first move action. More precisely, the robot needs to appeal to linear regression to estimate its expected outcome, and query its beliefs based on the regression model. We proceed as follows.\nEnvironment 1 Let T1 = (L1,M1, |=1) be the theory of real arithmetic with vocab(L1) = {s0, s1, . . . , sk, a, b, e}. Suppose that by performing a move action, the robot’s position changes from si to si+1. Let φ1 ∈ L1 be as follows:\n(s0 = 1 ∧ s1 = 2 ∧ s2 = 3) ∧ e = ∑\ni(si+1 − b − a · si) 2\nThe idea is that the values of si are the explanatory variables in the regression model and si+1 are the response variables, that is, the trajectory data is of the form {(s0, s1), (s1, s2)}.\nConsider a weight function w1: M → eM . That is, the weight of a model M is the universe element corresponding to the constant e in M, analogous to Figure 3. (For simplicity, we assume that the coefficients of the regression model are natural numbers.) For the semiring S1 = (N,min,∞):\n#(φ1,w1) = min { eM | M |= φ1, M ∈ M1 } .\nIn other words, models in M1 interpret si as given by the data, and models differ in their interpretation of a, b and thus, e. For the data in φ1, we would have a model M where eM = 0, aM = 1 and bM = 1, and so #(φ1,w1) = 0.\nEnvironment 2 Let T2 = (L2,M2, |=2) be a propositional theory, where vocab(L2) = {repair} . Imagine a weight function w2 as follows: w2({repair}) = .7, and w2({¬repair}) = .3. That is, the robot believes that repairs are needed with a higher probability. Indeed, for the semiring (R,+, 0):\n#(repair,w2) = .7 versus #(¬repair,w2) = .3.\nComposition Let (T ,S,w) be the composition of the two environments with T = (L,M, |=) and S = (S,⊕, 0). Suppose φ ∈ L is as follows:\nφ1 ∧ (s3 = a · s2 + b) ∧ (s3 − s2) , (s1 − s0) ≡ repair.\nThe final conjunct basically checks whether the expected change in position matches what was happening initially, and if not, repair should be true.\nTo see Definition 24 in action, observe that for any M1 ∈ M1, M2 ∈ M2, (M1, M2) ∈ M, the formulas φ1 and those involving si are interpreted in M1, but repair in M2. The weight function is as follows. Given (M1, M2) ∈ M and (M′1, M ′ 2) ∈ M, we have:\nw((M1, M2)) ⊕ w((M′1, M ′ 2))\n= ( min(w1(M1),w1(M′1)), w2(M2) + w2(M ′ 2) ).\nThen the robot can obtain the weight of repair and φ using:\n#(φ ∧ repair,w) = (0, 0)\nwhere, of course, the first argument is the error of the regression model and the second is 0 because φ ∧ repair is inconsistent. That can be contrasted to the count below:\n#(φ ∧ ¬repair,w) = (0, .3).\nIt is also easy to see that #(φ,w) = (0, .3). As in WMC (Chavira and Darwiche 2008), suppose the robot obtains the probability of a query q given φ using:\n#(φ ∧ q,w) #(φ,w)\nwhere the division is carried out by ignoring the regression error. Then the probability of ¬repair given φ is 1. Thus, no repairs are needed."
    }, {
      "heading" : "5 Solver Construction",
      "text" : "The upshot of semiring programming is that it encourages us to inspect strategies for a unified inferential mechanism (Kautz 2004). This has to be done carefully, as we would like to build on scalable methodologies in the literature, by restricting logical theories where necessary. In this section, we discuss whether our programming model can be made to work well in practice.\nLet us consider two extremes:\n• Option 1: At one extreme is a solver strategy based on a single computational technique. Probabilistic programming languages, such as Church (Goodman et al. 2008), have made significant progress in that respect for generative stochastic processes by appealing to Markov Chain Monte Carlo sampling techniques. Unfortunately, such sampling techniques do not scale well on large problems and have little support for linear and logical constraints.\n• Option 2: At the other extreme is a solver strategy that is arbitrarily heterogeneous, where we develop unique solvers for specific environments, that is, (T ,S) pairs.\nOption 3: We believe the most interesting option is in between these two extremes. In other words, to identify the smallest set of computational techniques, and effectively integrate them is both challenging and insightful. This may mean that such a strategy is less optimal than Option 2 for the environment, but we would obtain a simpler and more compact execution model. To that end, let us make the following observations from our inventory of examples:\n• Finite versus infinite: variable assignments are taken from finite sets versus infinite or uncountable sets.\n• Non-factorized versus factorized: the former is usually an optimization problem with an objective function that is to be maximized or minimized. The latter is usually a counting problem, where we would need to identify one or all solutions.\n• Compositionality: locally consistent solutions (i.e., in each environment (T ,S)) need to be tested iteratively for global consistency.\nThus, Option 3 would be realized as follows:\n• Factorized problems need a methodology for effective enumeration, and therefore, advances in model counting (Gomes, Sabharwal, and Selman 2009), such as knowledge compilation, are the most relevant. For finite theories, we take our cue from the Problog family of languages (Fierens et al. 2011; Kimmig, Van den Broeck, and De Raedt 2011), that\nhave effectively applied arithmetic circuits for tasks such as WMC and MPE. In particular, it is shown in (Kimmig, Van den Broeck, and De Raedt 2012) how arbitrary semiring labels can be propagated in the circuit. See (Fargier, Marquis, and Niveau 2013; Fargier, Marquis, and Schmidt 2013) for progress on knowledge compilation in CSP-like environments.\nFor infinite theories, there is growing interest in effective model counting for linear arithmetic using SMT technology (Chistikov, Dimitrova, and Majumdar 2015; Belle, Passerini, and Van den Broeck 2015; Belle, Passerini, and Van den Broeck 2016). Like in (Kimmig, Van den Broeck, and De Raedt 2011), however, we would need to extend these counting approaches to arbitrary semirings.\n• For non-factorized problems, a natural candidate for handling semirings does not immediately present itself, making this is a worthwhile research direction.6 Appealing to off-the-shelf optimization software (Andrei 2013) is always an option, but they embody diverse techniques and the absence of a simple high-level solver strategy makes adapting them for our purposes less obvious. In that regard, solvers for optimization modulo theories (OMT) (Sebastiani and Tomasi 2015) are perhaps the most promising. OMT technology extends SMT technology in additionally including a cost function that is be maximized (minimized). In terms of expressiveness, CSPs (Nieuwenhuis and Oliveras 2006) and certain classes of mathematical programs can be expressed, even in the presence of logical connectives. In terms of a solver strategy, they use binary search in tandem with lower and upper bounds to find the maximum (minimum). This is not unlike DPLL traces in knowledge compilation, which makes that technology the most accessible for propagating arbitrary semiring labels.\n• Compositional settings are, of course, more intricate. Along with OMT, and classical iterative methods like expectation maximization (Koller and Friedman 2009), there are a number of recent approaches employing branch-and-bound search strategies to navigate between local and global consistency (Friesen and Domingos 2015). Which of these can be made amenable to compositions of SP programs remains to be seen however.\nOverall, we believe the most promising first step is to limit the vocabulary of the logical language to propositions and constants (i.e., 0-ary functions), which make appealing to knowledge compilation and OMT technology straightforward. It will also help us better characterize the complexity of the problems that SP attempts\n6Approaches like (Berre, Lonca, and Marquis 2014; Fargier, Marquis, and Schmidt 2013) on knowledge compilation for optimization and (Sanner and McAllester 2005) on circuits for linear constraints are compelling, but their applicability to non-trivial arithmetic and optimization problems remains to be explored.\nto solve.7 At first glance, SP is seen to naturally capture #P-complete problems in the factorized setting, both in the finite case (Gomes, Sabharwal, and Selman 2009) and the infinite one (Dyer and Frieze 1988). In the non-factorized setting, many results from OMT and mathematical programming are inherited depending on the nature of the objective function and the domains of the program variables (Kannan and Monma 1978; Barrett et al. 2009; Sebastiani and Tomasi 2015). By restricting the language as suggested, the applicability of these results can be explored more thoroughly."
    }, {
      "heading" : "6 Related Work",
      "text" : "Semiring programming is related to efforts from different disciplines within AI, and we discuss representative camps.\nStatistical modeling Formal languages for generative stochastic processes, such as Church (Goodman et al. 2008) and BLOG (Milch et al. 2005), have received a lot of attention in the learning community. Such languages provide mechanisms to compactly specify complex probability distributions, and appeal to sampling for inference.\nClosely related to such proposals are probabilistic logic programming languages such as Problog (De Raedt, Kimmig, and Toivonen 2007) that extends Prolog with probabilistic choices and uses WMC for inference (Fierens et al. 2011). In particular, a semiring generalization of Problog, called aProbLog (Kimmig, Van den Broeck, and De Raedt 2011), was the starting point for our work and employs a semiring variation of WMC for inference (Kimmig, Van den Broeck, and De Raedt 2012), but none addresses matrix factorization, convex optimization and compositionality.\nThe use of semirings in machine learning is not new to aProbLog, see e.g., (Goodman 1999), and programming languages such as Dyna (Eisner and Filardo 2011). Dyna is based on Datalog; our logical setting is strictly more expressive than Datalog and its extensions (e.g., non-Horn fragment, constraints over reals). Dyna also labels proofs but not interpretations, as would SP (thus capturing weighted model counting, for example).\nConstraints The constraints literature boasts a variety of modeling languages, such as Essence (Frisch et al. 2008), among others (Marriott et al. 2008; Van Hentenryck 2002). (See (Fontaine, Michel, and Van Hentenryck 2013), for example, for a proposal on combining heterogeneous solvers.) On the one hand, SP is more expressive from a logical viewpoint as constraints can be described using arbitrary formulas from predicate logic, and we address many problems beyond constraints, such as probabilistic reasoning. On the other hand, such constraint languages make it easier for nonexperts to specify problems while SP, in its current form, assumes a background in logic. Such languages, then, would be of interest for extending SP’s modeling features.\n7Richer fragments have to be considered carefully to avoid undecidable properties (Boerger, Grädel, and Gurevich 1997).\nA notable line of CSP research is by Bistarelli and his colleagues (Bistarelli et al. 1999; Bistarelli 2004). Here, semirings are used for diverse CSP specifications, which has also been realized in a CLP framework (Bistarelli, Montanari, and Rossi 2001). In particular, our account of compositionality is influenced by (Bistarelli 2004). Under some representational assumptions, SP and such accounts are related, but as noted, SP can formulate problems such as probabilistic inference in hybrid domains that does not have an obvious analogue in these accounts.\nOptimization Closely related to the constraints literature are the techniques embodied in mathematical programming more generally. There are three major traditions in this literature that are related to SP. Modeling languages such as AMPL (Fourer, Gay, and Kernighan 1993) are fairly close to constraint modeling languages, and even allow parametrized constraints, which are ground at the time of search. The field of disciplined programming (Grant and Boyd 2008) supports features such as objectoriented constraints. Finally, relational mathematical programming (Apsel, Kersting, and Mladenov 2014) attempts to exploit symmetries in parametrized constraints.\nFrom a solver construction perspective, these languages present interesting possibilities. From a framework point of view, however, there is little support for logical reasoning in a general way.\nKnowledge representation Declarative problem solving is a focus of many proposals, including ASP (Brewka, Eiter, and Truszczyński 2011), model expansion (Mitchell and Ternovska 2005; Ternovska and Mitchell 2009), among others (Cadoli and Mancini 2007). These proposals are (mostly) for problems in NP, and so do not capture #P-hard problems like model counting and WMC. Indeed, the most glaring difference is the absence of weight functions over possible worlds, which is central to the formulation of statistical models. Weighted extensions of these formalisms, e.g., (Baral, Gelfond, and Rushton 2009; Liu, Janhunen, and Niemelä 2012), are thus closer in spirit.\nThe generality of SP also allows us to instantiate many such proposals, including formalisms using linear arithmetic fragments (Belle, Passerini, and Van den Broeck 2015; Sebastiani and Tomasi 2015). Consider OMT for example. OMT can be used to express quantifier-free linear arithmetic sentences with a linear cost function, and a first-order structure that minimizes the cost function is sought. From a specification point of view, SP does not limit the logical language, does not require that objective functions be linear, and a variety of model comparisons, including counting, are possible via semirings. Compositionality in SP, moreover, goes quite beyond this technology.\nFinally, there is a longstanding interest in combining different (logical) environments in a single logical framework, as seen, for example, in modular and multi-context systems (Lierler and Truszczynski 2015; Ensan and Ternovska 2015). In such frameworks, it would be possible to get a ILP program and ASP program to com-\nmunicate their solutions, often by sharing atoms. In our view, Section 4 and these frameworks emphasize different aspects of compositionality. The SP scheme assumes the modeler will formalize a convex optimization problem and a SAT problem in the same programming language since they presumably arise in a single application (e.g., a task and motion planner); this allows model reuse and enables transparency. In contrast, modular systems essentially treat diverse environments as black-boxes, which is perhaps easier to realize. On the one hand, it would be interesting to see whether modular systems can address problems such as combined inference and learning. On the other, some applications may require that different environments share atoms, for which our account on compositionality could be extended by borrowing ideas from modular systems."
    }, {
      "heading" : "7 Conclusions",
      "text" : "In a nutshell, SP is a framework to declaratively specify three major concerns in AI applications:\n• logical reasoning;\n• discrete and continuous probabilistic inference;\n• discrete and continuous optimization.\nTo its strengths, we find that SP is universal (in the above sense) and generic (in terms of allowing instantiations to particular logical languages and semirings). Thus, we believe SP represents a simple, uniform, modular and transparent approach to the model building process of complex AI applications.\nSP comes with a rigorous semantics to give meaning to its programs. In that sense, we imagine future developments of SP would follow constraint programming languages and probabilistic programming languages in providing more intricate modeling features which, in the end, resort to the proposed semantics in the paper.\nPerhaps the most significant aspect of SP is that it also allows us to go beyond existing paradigms as the richness of the framework admits novel formulations that combine theories from these different fields, as illustrated by means of a combined regression and probabilistic inference example. In the long term, we hope SP will contribute to the bridge between learning and reasoning."
    } ],
    "references" : [ {
      "title" : "Lifting relational map-lps using cluster signatures",
      "author" : [ "Kersting Apsel", "U. Mladenov 2014] Apsel", "K. Kersting", "M. Mladenov" ],
      "venue" : null,
      "citeRegEx" : "Apsel et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Apsel et al\\.",
      "year" : 2014
    }, {
      "title" : "J",
      "author" : [ "C. Baral", "M. Gelfond", "Rushton" ],
      "venue" : "N.",
      "citeRegEx" : "Baral. Gelfond. and Rushton 2009",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "S",
      "author" : [ "C. Barrett", "R. Sebastiani", "Seshia" ],
      "venue" : "A.; and Tinelli, C.",
      "citeRegEx" : "Barrett et al. 2009",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "The SMT-LIB Standard: Version 2.5",
      "author" : [ "Fontaine Barrett", "C. Tinelli 2015] Barrett", "P. Fontaine", "C. Tinelli" ],
      "venue" : "Technical report, Department of Computer Science,",
      "citeRegEx" : "Barrett et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Barrett et al\\.",
      "year" : 2015
    }, {
      "title" : "Probabilistic inference in hybrid domains by weighted model integration",
      "author" : [ "Passerini Belle", "V. Van den Broeck 2015] Belle", "A. Passerini", "G. Van den Broeck" ],
      "venue" : "In IJCAI",
      "citeRegEx" : "Belle et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Belle et al\\.",
      "year" : 2015
    }, {
      "title" : "Towards component caching in hybrid domains",
      "author" : [ "Passerini Belle", "V. Van den Broeck 2016] Belle", "A. Passerini", "G. Van den Broeck" ],
      "venue" : null,
      "citeRegEx" : "Belle et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Belle et al\\.",
      "year" : 2016
    }, {
      "title" : "D",
      "author" : [ "Berre" ],
      "venue" : "L.; Lonca, E.; and Marquis, P.",
      "citeRegEx" : "Berre. Lonca. and Marquis 2014",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Semiring-based CSPs and valued CSPs: Frameworks, properties, and comparison",
      "author" : [ "Bistarelli" ],
      "venue" : null,
      "citeRegEx" : "Bistarelli,? \\Q1999\\E",
      "shortCiteRegEx" : "Bistarelli",
      "year" : 1999
    }, {
      "title" : "Semiring-based constraint logic programming: syntax and semantics",
      "author" : [ "Montanari Bistarelli", "S. Rossi 2001] Bistarelli", "U. Montanari", "F. Rossi" ],
      "venue" : null,
      "citeRegEx" : "Bistarelli et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Bistarelli et al\\.",
      "year" : 2001
    }, {
      "title" : "The classical decision problem",
      "author" : [ "Grädel Boerger", "E. Gurevich 1997] Boerger", "E. Grädel", "Y. Gurevich" ],
      "venue" : null,
      "citeRegEx" : "Boerger et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Boerger et al\\.",
      "year" : 1997
    }, {
      "title" : "Answer set programming at a glance. Communications of the ACM 54(12):92–103",
      "author" : [ "Eiter Brewka", "G. Truszczyński 2011] Brewka", "T. Eiter", "M. Truszczyński" ],
      "venue" : null,
      "citeRegEx" : "Brewka et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Brewka et al\\.",
      "year" : 2011
    }, {
      "title" : "and Mancini",
      "author" : [ "M. Cadoli" ],
      "venue" : "T.",
      "citeRegEx" : "Cadoli and Mancini 2007",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "and Darwiche",
      "author" : [ "M. Chavira" ],
      "venue" : "A.",
      "citeRegEx" : "Chavira and Darwiche 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Approximate counting in smt and value estimation for probabilistic programs",
      "author" : [ "Dimitrova Chistikov", "D. Majumdar 2015] Chistikov", "R. Dimitrova", "R. Majumdar" ],
      "venue" : "In TACAS,",
      "citeRegEx" : "Chistikov et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Chistikov et al\\.",
      "year" : 2015
    }, {
      "title" : "Problog: A probabilistic prolog and its application in link discovery",
      "author" : [ "Kimmig De Raedt", "L. Toivonen 2007] De Raedt", "A. Kimmig", "H. Toivonen" ],
      "venue" : "In Proc. IJCAI,",
      "citeRegEx" : "Raedt et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Raedt et al\\.",
      "year" : 2007
    }, {
      "title" : "M",
      "author" : [ "C.H.Q. Ding", "T. Li", "Jordan" ],
      "venue" : "I.",
      "citeRegEx" : "Ding. Li. and Jordan 2010",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "A",
      "author" : [ "M.E. Dyer", "Frieze" ],
      "venue" : "M.",
      "citeRegEx" : "Dyer and Frieze 1988",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "N",
      "author" : [ "J. Eisner", "Filardo" ],
      "venue" : "W.",
      "citeRegEx" : "Eisner and Filardo 2011",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "and Ternovska",
      "author" : [ "A. Ensan" ],
      "venue" : "E.",
      "citeRegEx" : "Ensan and Ternovska 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Towards a knowledge compilation map for heterogeneous representation languages",
      "author" : [ "Marquis Fargier", "H. Niveau 2013] Fargier", "P. Marquis", "A. Niveau" ],
      "venue" : null,
      "citeRegEx" : "Fargier et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Fargier et al\\.",
      "year" : 2013
    }, {
      "title" : "Semiring labelled decision diagrams, revisited: Canonicity and spatial efficiency issues",
      "author" : [ "Marquis Fargier", "H. Schmidt 2013] Fargier", "P. Marquis", "N. Schmidt" ],
      "venue" : "In IJCAI",
      "citeRegEx" : "Fargier et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Fargier et al\\.",
      "year" : 2013
    }, {
      "title" : "Inference in probabilistic logic programs using weighted CNF’s",
      "author" : [ "Fierens" ],
      "venue" : null,
      "citeRegEx" : "Fierens,? \\Q2011\\E",
      "shortCiteRegEx" : "Fierens",
      "year" : 2011
    }, {
      "title" : "Model combinators for hybrid optimization",
      "author" : [ "Michel Fontaine", "D. Van Hentenryck 2013] Fontaine", "L. Michel", "P. Van Hentenryck" ],
      "venue" : "In CP,",
      "citeRegEx" : "Fontaine et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Fontaine et al\\.",
      "year" : 2013
    }, {
      "title" : "B",
      "author" : [ "R. Fourer", "D.M. Gay", "Kernighan" ],
      "venue" : "W.",
      "citeRegEx" : "Fourer. Gay. and Kernighan 1993",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "A",
      "author" : [ "E.C. Freuder", "Mackworth" ],
      "venue" : "K.",
      "citeRegEx" : "Freuder and Mackworth 2006",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "and Domingos",
      "author" : [ "A. Friesen" ],
      "venue" : "P.",
      "citeRegEx" : "Friesen and Domingos 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "B",
      "author" : [ "A.M. Frisch", "W. Harvey", "C. Jefferson", "Hernández" ],
      "venue" : "M.; and Miguel, I.",
      "citeRegEx" : "Frisch et al. 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "C",
      "author" : [ "Gomes" ],
      "venue" : "P.; Sabharwal, A.; and Selman, B.",
      "citeRegEx" : "Gomes. Sabharwal. and Selman 2009",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "J",
      "author" : [ "N.D. Goodman", "V.K. Mansinghka", "D.M. Roy", "K. Bonawitz", "Tenenbaum" ],
      "venue" : "B.",
      "citeRegEx" : "Goodman et al. 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "and Boyd",
      "author" : [ "M. Grant" ],
      "venue" : "S.",
      "citeRegEx" : "Grant and Boyd 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "M",
      "author" : [ "J.N. Hooker", "Lama" ],
      "venue" : "A. O.",
      "citeRegEx" : "Hooker and Lama 1999",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "C",
      "author" : [ "R. Kannan", "Monma" ],
      "venue" : "L.",
      "citeRegEx" : "Kannan and Monma 1978",
      "shortCiteRegEx" : null,
      "year" : 1978
    }, {
      "title" : "Toward a universal inference engine. In LPNMR, volume 2923 of LNCS",
      "author" : [ "H. Kautz" ],
      "venue" : null,
      "citeRegEx" : "Kautz,? \\Q2004\\E",
      "shortCiteRegEx" : "Kautz",
      "year" : 2004
    }, {
      "title" : "An algebraic prolog for reasoning about possible worlds",
      "author" : [ "Van den Broeck Kimmig", "A. De Raedt 2011] Kimmig", "G. Van den Broeck", "L. De Raedt" ],
      "venue" : "In Proc. AAAI",
      "citeRegEx" : "Kimmig et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Kimmig et al\\.",
      "year" : 2011
    }, {
      "title" : "Algebraic model counting",
      "author" : [ "Van den Broeck Kimmig", "A. De Raedt 2012] Kimmig", "G. Van den Broeck", "L. De Raedt" ],
      "venue" : "CoRR abs/1211.4475",
      "citeRegEx" : "Kimmig et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Kimmig et al\\.",
      "year" : 2012
    }, {
      "title" : "and Friedman",
      "author" : [ "D. Koller" ],
      "venue" : "N.",
      "citeRegEx" : "Koller and Friedman 2009",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "and Truszczynski",
      "author" : [ "Y. Lierler" ],
      "venue" : "M.",
      "citeRegEx" : "Lierler and Truszczynski 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Answer set programming via mixed integer programming",
      "author" : [ "Janhunen Liu", "G. Niemelä 2012] Liu", "T. Janhunen", "I. Niemelä" ],
      "venue" : "In KR",
      "citeRegEx" : "Liu et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Liu et al\\.",
      "year" : 2012
    }, {
      "title" : "The design of the zinc modelling language. Constraints 13(3):229–267",
      "author" : [ "Marriott" ],
      "venue" : null,
      "citeRegEx" : "Marriott,? \\Q2008\\E",
      "shortCiteRegEx" : "Marriott",
      "year" : 2008
    }, {
      "title" : "D",
      "author" : [ "B. Milch", "B. Marthi", "S.J. Russell", "D. Sontag", "Ong" ],
      "venue" : "L.; and Kolobov, A.",
      "citeRegEx" : "Milch et al. 2005",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "and Ternovska",
      "author" : [ "D.G. Mitchell" ],
      "venue" : "E.",
      "citeRegEx" : "Mitchell and Ternovska 2005",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "A",
      "author" : [ "R. Nieuwenhuis", "Oliveras" ],
      "venue" : "2006. On sat modulo theories and optimization problems. In Theory and Applications of Satisfiability Testing-SAT",
      "citeRegEx" : "Nieuwenhuis and Oliveras 2006",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "and Domingos",
      "author" : [ "M. Richardson" ],
      "venue" : "P.",
      "citeRegEx" : "Richardson and Domingos 2006",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Static analysis for probabilistic programs: inferring whole program properties from finitely many paths",
      "author" : [ "Chakarov Sankaranarayanan", "A. Chakarov", "S. Gulwani" ],
      "venue" : "ACM SIGPLAN Notices",
      "citeRegEx" : "Sankaranarayanan et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Sankaranarayanan et al\\.",
      "year" : 2013
    }, {
      "title" : "D",
      "author" : [ "S. Sanner", "McAllester" ],
      "venue" : "A.",
      "citeRegEx" : "Sanner and McAllester 2005",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "and Tomasi",
      "author" : [ "R. Sebastiani" ],
      "venue" : "S.",
      "citeRegEx" : "Sebastiani and Tomasi 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "S",
      "author" : [ "S. Srivastava", "E. Fang", "L. Riano", "R. Chitnis", "Russell" ],
      "venue" : "J.; and Abbeel, P.",
      "citeRegEx" : "Srivastava et al. 2014",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "D",
      "author" : [ "E. Ternovska", "Mitchell" ],
      "venue" : "G.",
      "citeRegEx" : "Ternovska and Mitchell 2009",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Constraint and integer programming in OPL",
      "author" : [ ],
      "venue" : "INFORMS Journal on Computing",
      "citeRegEx" : "Hentenryck,? \\Q2002\\E",
      "shortCiteRegEx" : "Hentenryck",
      "year" : 2002
    } ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "To solve hard problems, AI relies on a variety of disciplines such as logic, probabilistic reasoning, machine learning and mathematical programming. Although it is widely accepted that solving real-world problems requires an integration amongst these, contemporary representation methodologies offer little support for this. In an attempt to alleviate this situation, we introduce a new declarative programming framework that provides abstractions of well-known problems such as SAT, Bayesian inference, generative models, and convex optimization. The semantics of programs is defined in terms of first-order structures with semiring labels, which allows us to freely combine and integrate problems from different AI disciplines.",
    "creator" : "LaTeX with hyperref package"
  }
}