{
  "name" : "1212.1824.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Stochastic Gradient Descent for Non-smooth Optimization: Convergence Results and Optimal Averaging Schemes",
    "authors" : [ "Ohad Shamir" ],
    "emails" : [ "ohadsh@microsoft.com", "tzhang@stat.rutgers.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "√ T ) for non-smooth\nconvex objective functions, and O(log(T )/T ) in the non-smooth strongly convex case. To the best of our knowledge, these are the first bounds of this kind, and almost match the minimax-optimal rates obtainable by appropriate averaging schemes. We also propose a new and simple averaging scheme, which not only attains optimal rates, but can also be easily computed on-the-fly (in contrast, the suffix averaging scheme proposed in Rakhlin et al. (2011) is not as simple to implement). Finally, we provide some experimental illustrations."
    }, {
      "heading" : "1 Introduction",
      "text" : "This paper considers one of the simplest and most popular stochastic optimization algorithms, namely Stochastic Gradient Descent (SGD). SGD can be used to optimize any convex function F over a convex domainW, given access only to unbiased estimates of F ’s subgradients. This feature makes it very useful for learning problems, where our goal is to minimize generalization error based only on a finite sampled training set. Moreover, SGD is extremely simple and highly scalable, making it particularly suitable for large-scale learning problems.\nThe algorithm itself proceeds in rounds, and can be described in just a few lines: We initialize w1 ∈ W (following common practice, we will assume w1 = 0). At round t = 1, 2, . . ., we obtain a random estimate ĝt of a subgradient gt ∈ ∂F (wt) so that Eĝt = gt, and update the iterate wt as follows:\nwt+1 = ΠW(wt − ηtĝt),\nwhere ηt is a suitably chosen step-size parameter, and ΠW denotes projection on W. In terms of theoretical analysis, SGD has been studied for decades (for instance, see Kushner & Yin (2003) and references therein), but perhaps surprisingly, there are still important gaps left in our understanding of this method. First of all, most classical results look at asymptotic convergence rates, which do not apply to a fixed iteration budget T . In recent years, more attention has been devoted to non-asymptotic bounds (e.g., Bach & Moulines (2011)). However, these classical convergence bounds often make non-trivial smoothness\nar X\niv :1\n21 2.\n18 24\nv1 [\ncs .L\nG ]\n8 D\nec 2\nassumptions on the function F , such as Lipschitz-continuity of the gradient or higher-order derivatives. In modern applications, these assumptions often do not hold. For example, if SGD is used to solve the supportvector machine optimization problem (with the standard non-smooth hinge-loss) on a finite training set, then the underlying objective function F is essentially non-smooth, even at the optimal solution. In general, for machine learning applications F may be non-smooth whenever one uses a non-smooth loss function, and thus a smoothness-based analysis is not appropriate.\nWithout assuming smoothness, most of the existing analysis has been carried out in the context of online learning - a more difficult setting than our stochastic setting, where the subgradients are assumed to be provided by an adversary. Using online-to-batch conversion, it is possible to show that after T iterations, the average of the iterates, (w1 + . . . + wT )/T , has O(log(T )/T ) optimization error for strongly-convex F (see precise definition in Sec. 2), and O(1/ √ T ) error for general convex F Zinkevich (2003); Hazan et al. (2007); Hazan & Kale (2011). However, Rakhlin et al. (2011) showed that simple averaging is provably suboptimal in a stochastic setting. Instead, they proposed averaging the last αT iterates of SGD (where α ∈ (0, 1), e.g. 1/2), and showed that this averaging scheme has an optimal O(1/T ) convergence rate. In comparison, in the non-smooth setting, there are Ω(1/ √ T ) and Ω(1/T ) lower bounds for convex and strongly-convex problems, respectively Agarwal et al. (2012). These results leave open several issues. First, they pertain to averaging significant parts of the iterates, although in practice averaging just over the last few iterates, or returning the last iterate wT , often works quite well (e.g. Shalev-Shwartz et al. (2011)). Unless F is smooth, the previous results cannot say much about the optimization error of individual iterates. For example, the results in Rakhlin et al. (2011) only imply an O(1/ √ T ) convergence rate for the last iterate wT with strongly-convex functions, and we are not aware of any results for the last iterate wT in the general convex case. In fact to the best of our knowledge, even for the simpler (non-stochastic) gradient descent method (where ĝt = gt), we do not know any existing results that can guarantee the performance of each individual iterate wT . Second, the theoretically optimal suffix-averaging scheme proposed in Rakhlin et al. (2011) has some practical limitations, since it cannot be computed on-the-fly: unless we can store all iterates w1, . . . ,wT in memory, one needs to know the stopping time T beforehand, in order to know when to start computing the suffix average. In practice, T is often not known in advance. This can be partially remedied with a so-called doubling trick, but it is still not a simple or natural procedure compared to just averaging all iterates, and the latter was shown to be suboptimal in Rakhlin et al. (2011).\nIn this paper, we investigate the convergence rate of SGD and the averaging schemes required to obtain them, with the following contributions:\n• We prove that the expected optimization error of every individual iterate wT is O(log(T )/T ) for strongly-convex F , and O(log(T )/ √ T ) for general convex F without smoothness assumptions on F .\nThese results show that the suboptimality of the last iterate is not much worse than the optimal rates obtainable by averaging schemes, and partially addresses an open problem posed in Shamir (2012). Moreover, the latter result is (to the best of our knowledge) the first finite-sample bound on individual iterates of SGD for non-smooth convex optimization. The proof relies on a technique to reduce results on averages of iterates to results on individual iterates, which was implicitly used in Zhang (2004) for a somewhat different setting.\n• We improve the existing expected error bound on the suffix averaging scheme of Rakhlin et al. (2011), from O((1 + log( 11−α ))/αT ) to O(log( 1 min{α,1−α} )/T ).\n• We propose a new and very simple running average scheme, called polynomial-decay averaging, and prove that it enjoys optimal rates of convergence. Unlike suffix-averaging, this new running average scheme can be easily computed on-the-fly.\n• We provide a simple experimental study of the averaging schemes discussed in the paper.\nWe emphasize that although there exist other algorithms with O(1/T ) convergence rate in the strongly convex case (e.g. Hazan & Kale (2011); Ouyang & Gray (2012)), our focus in this paper is on the simple and widely-used SGD algorithm."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We use bold-face letters to denote vectors. We let F denote a convex function over a (closed) convex domain W, which is a subset of some Hilbert space with an induced norm ‖ · ‖. We assume that F is minimized at some w∗ ∈ W. Besides general convex F , we will also consider the important sub-class of strongly-convex functions. Formally, we say that a function F is λ-strongly convex, if for all w,w′ ∈ W and any subgradient g of F at w, it holds that\nF (w′) ≥ F (w) + 〈g,w′ −w〉+ λ 2 ‖w′ −w‖2,\nwhere λ > 0. For a general convex function, the above inequality can always be satisfied with λ = 0. As discussed in the introduction, we consider the first-order stochastic optimization setting, where instead of having direct access to F , we only have access to an oracle, which given some w ∈ W, returns a random vector ĝ such that E[ĝ] ∈ ∂F (w). Our goal is to use a bounded number T of oracle calls, and compute some w̄ ∈ W such that the optimization error, F (w̄)− F (w∗), is as small as possible. It is well-known that this framework can be applied to learning problems (see for instance Shalev-Shwartz et al. (2009)): given a hypothesis class W and a set of T i.i.d. examples, we wish to find a predictor w whose expected loss F (w) is close to optimal over W. Since the examples are chosen i.i.d., the subgradient of the loss function with respect to any individual example can be shown to be an unbiased estimate of a subgradient of F . We will mostly consider bounds on the expected error (over the oracle’s and algorithm’s randomness) for simplicity, although it is possible to obtain high-probability bounds in some cases.\nIn terms of the step-size ηt in the strongly-convex case, we will generally assume it equals 1/(λt). We note that this is without much loss of generality, since if the step size is c/λt for some c ≥ 1, then it is equivalent to taking step sizes 1/(λ′t) where λ′ := λ/c ≤ λ is a lower-bound on the strong convexity parameter. Since any λ-strongly convex function is also λ′-strongly convex, we can use the analysis here to get upper bounds in terms of λ′, and if so desired, substitute λ/c instead of λ′ in the final bound.\nWhen we run SGD, we let ĝt denote the random vector obtained at round t (when we query at wt), and let gt = E[ĝt] denote the underlying subgradient of F . To facilitate our convergence bounds, we assume that E[‖ĝt‖2] ≤ G2 for some fixed G. Also, when optimizing general convex functions, we will assume that the diameter of W, namely supw,w′∈W ‖w −w′‖, is bounded by some constant D."
    }, {
      "heading" : "3 Convergence of Individual SGD Iterates",
      "text" : "We begin by considering the case of strongly convex F , and prove the following bound on the expected error of any individual iterate wT . In this theorem as well as later ones, we did not attempt to optimize constants.\nTheorem 1. Suppose F is λ-strongly convex, and that E[‖ĝt‖2] ≤ G2 for all t. Consider SGD with step sizes ηt = 1/λt. Then for any T > 1, it holds that\nE[F (wT )− F (w∗)] ≤ 17G2(1 + log(T ))\nλT .\nProof. The beginning of the proof is standard. By convexity of W, we have the following for any w ∈ W:\nE [ ‖wt+1 −w‖2 ] = E[‖ΠW(wt − ηtĝt)−w‖2]\n≤ E [ ‖wt − ηtĝt −w‖2 ] ≤ E [ ‖wt −w‖2 ] − 2ηtE[〈gt,wt −w〉] + η2tG2.\nLet k be an arbitrary element in {1, . . . , bT/2c}. Extracting the inner product, summing over all t =\nT − k, . . . , T , and rearranging, we get\nT∑ t=T−k E[〈gt,wt −w〉] ≤ 1 2ηT−k E[‖wT−k −w‖2]\n+ T∑ t=T−k+1 E[‖wt −w‖2] 2 ( 1 ηt − 1 ηt−1 ) + G2 2 T∑ t=T−k ηt. (1)\nBy convexity of F , we can lower bound 〈gt,wt −w〉 by F (wt) − F (w). Plugging this in and substituting ηt = 1/λt, we get\nE\n[ T∑\nt=T−k\n(F (wt)− F (w)) ] ≤ λ(T − k)\n2 E[‖wT−k −w‖2]\n+ λ\n2 T∑ t=T−k+1 E[‖wt −w‖2] + G2 2λ T∑ t=T−k 1 t . (2)\nNow comes the crucial trick: instead of picking w = w∗, as done in standard analysis (Hazan et al. (2007); Rakhlin et al. (2011)), we instead pick w = wT−k. We also use the fact that E [ ‖wt −w∗‖2 ] ≤ 4G 2\nλ2t (Rakhlin et al. (2011), Lemma 1), which implies that for any t ≥ T − k,\nE[‖wt −wT−k‖2] ≤2E [ ‖wt −w∗‖2 + ‖wT−k −w∗‖2 ] ≤ 8G 2\nλ2\n( 1\nt +\n1\nT − k\n) ≤ 16G 2\nλ2(T − k) ≤ 32G\n2\nλ2T .\nPlugging this back into Eq. (2), we get\nE\n[ T∑\nt=T−k\n(F (wt)− F (wT−k)) ] ≤ 16G 2k\nλT + G2 2λ T∑ t=T−k 1 t .\nLet Sk = 1 k+1 ∑T t=T−k E[F (wt)] be the expected average value of the last k + 1 iterates. The bound above implies that\n−E[F (wT−k)] ≤ −E[Sk] + G2\n2λ\n( 32\nT + T∑ t=T−k\n1\n(k + 1)t\n) .\nBy the definition of Sk and the inequality above, we have\nkE[Sk−1] = (k + 1)E[Sk]− E[F (wT−k)]\n≤ (k + 1)E[Sk]− E[Sk] + G2\n2λ\n( 32\nT + T∑ t=T−k\n1\n(k + 1)t\n) ,\nand dividing by k, implies\nE[Sk−1] ≤ E[Sk] + G2\n2λ\n( 32\nkT + T∑ t=T−k\n1\nk(k + 1)t\n) . (3)\nUsing this inequality repeatedly and summing from k = 1 to k = bT/2c, we have\nE[F (wT )] = E[S0] ≤ E[SbT/2c] + 16G2\nλT bT/2c∑ k=1 1 k\n+ G2\n2λ bT/2c∑ k=1 T∑ t=T−k\n1\nk(k + 1)t . (4)\nIt now just remains to bound these terms. E[ST/2] is the expected average value of the last bT/2c iterates, which was already analyzed in (Rakhlin et al. (2011), Theorem 5), yielding a bound of\nE[SbT/2c] ≤ F (w∗) + 10G2\nλT\nfor T > 1. Moreover, we have bT/2c∑ k=1 (1/k) ≤ 1 + log(T/2).\nFinally, we have\nbT/2c∑ k=1 T∑ t=T−k\n1 k(k + 1)t ≤ bT/2c∑ k=1\n1\nk(T − k)\n= 1\nT bT/2c∑ k=1 ( 1 k + 1 T − k ) ≤ (1 + log(T ))/T.\nThe result follows by substituting the above bounds into Eq. (4) and simplifying for readability.\nUsing a similar technique, we can also get an individual iterate bound, in the case of a general convex function F that may be non-smooth. We note that a similar technique was used in Zhang (2004), but for a different algorithm (one with constant learning rate), and the result was less explicit.\nTheorem 2. Suppose that F is convex, and that for some constants D,G, it holds that E[‖ĝt‖] ≤ G2 for all t, and supw,w′∈W ‖w−w′‖ ≤ D. Consider SGD with step sizes ηt = c/ √ t where c > 0 is a constant. Then for any T > 1, it holds that\nE[F (wT )− F (w∗)] ≤ ( D2\nc + cG2\n) 2 + log(T )√\nT .\nProof. The proof begins the same as in Thm. 1 (this time letting k be an element in {1, . . . , T − 1}), up to Eq. (1). Instead of substituting ηt = c/λt, we substitute ηt = c/ √ t, to get the, E[‖wt −w‖2] by D2, pick w = wT−k and slightly simplify to get\nE [〈gt,wt −wT−k〉]\n≤ D 2\n2c\n(√ T − √ T − k ) + G2\n2 T∑ t=T−k c√ t .\nBy convexity, we can lower bound 〈gt,wt −wT−k〉 by F (wt)− F (wT−k). Also, it is easy to verify (e.g. by\nintegration) that ∑T t=T−k 1√ t ≤ 2( √ T − √ T − k − 1), hence\nE\n[ T∑\nt=T−k\n(F (wt)− F (wT−k))\n]\n≤ ( D2\n2c + cG2\n)(√ T − √ T − k − 1 ) = ( D2\n2c + cG2\n) k + 1√\nT + √ T − k − 1 ≤ ( D2\n2c + cG2 ) k + 1√ T . (5)\nAs in the proof of Thm. 1, let Sk = 1 k+1 ∑T t=T−k E[F (wt)] be the expected average value of the last K + 1 iterates. The bound above implies that\n−E[F (wT−k)] ≤ −E[Sk] + D2/2c+ cG2√\nT .\nBy the definition of Sk and the inequality above, we have\nkE[Sk−1] = (k + 1)E[Sk]− E[F (wT−k)]\n≤ (k + 1)E[Sk]− E[Sk] + D2/2c+ cG2√\nT ,\nand dividing by k, implies\nE[Sk−1] ≤ E[Sk] + D2/2c+ cG2\nk √ T\n.\nUsing this inequality repeatedly and by summing over k = 1, . . . , T − 1, we have\nE[F (wT )] = E[S0] ≤ E[ST−1] + D2/2c+ cG2√\nT\nT−1∑ k=1 1 k . (6)\nIt now just remains to bound the terms on the right hand side. Using Eq. (1) with k = T − 1 and w = w∗, and upper bounding the norms by D, it is easy to calculate that\nE[ST−1]− F (w∗) = 1\nT E [ T∑ t=1 E[F (wt)− F (w∗) ]\n≤ ( D2\nc + cG2 ) 1√ T .\nAlso, we have ∑T−1 k=1 1/k ≤ (1 + log(T )). Plugging these upper bounds into Eq. (6) and simplifying for readability, we get the required bound."
    }, {
      "heading" : "4 Averaging Schemes",
      "text" : "The bounds shown in the previous section imply that individual iterates wT have O(log(T )/T ) expected error in the strongly convex case, and O(log(T )/ √ T ) expected error in the convex case. These bounds are close but not the same as the minimax optimal rates, which are O(1/T ) and O(1/ √ T ) respectively. In this section, we consider averaging schemes, which rather than return individual iterates, return some weighted combination of all iterates w1, . . . ,wT , attaining the minimax optimal rates. We mainly focus here on the\nstrongly-convex case, since simple averaging of all iterates is already known to be optimal (up to constants) in the general convex case.\nWe first examine the case of α-suffix averaging, defined as the average of the last αT iterates (where α ∈ (0, 1) is a constant, and αT is assumed to be an integer):\nw̄αT = 1\nαT T∑ t=(1−α)T+1 wt.\nIn Rakhlin et al. (2011), it was shown that this averaging scheme results in an optimization error of O((1 + log( 11−α ))/αT ), which is optimal in terms of T , but increases rapidly as we make α smaller. The following theorem shows a tighter upper bound of O(log( 1min{α,1−α} )/T ), which implies we can be much more flexible in choosing α. Besides being of independent interest, we will re-use this result in our proofs later on.\nTheorem 3. Under the conditions of Thm. 1, and assuming αT is an integer, it holds that E[F (w̄αT )−F (w∗)] is at most 17G2 ( 1 + log (\n1 min{α,(1+1/T )−α} )) λT .\nProof. Suppose first that αT ≤ bT/2c. The proof is mostly identical to that of Thm. 1, except that instead of using Eq. (3) to bound E[S0], we use it to bound E[SαT−1] = 1αT ∑T t=(1−α)T+1 F (wt), which by convexity upper bounds F (w̄αT ). We get:\nE[SαT−1] ≤ E[SbT/2c] + 16G2\nλT bT/2c∑ k=αT 1 k\n+ G2\n2λ bT/2c∑ k=αT T∑ t=T−k\n1\nk(k + 1)t ,\nUsing the same argument as in the proof of Thm. 1, and the fact that ∑βT k=αT 1 k ≤ 1 + log(β/α) for any integers αT, βT that are no larger than T , we can obtain the upper bounds\nE[SbT/2c ≤F (w∗) + 10G2/λT bT/2c∑ k=αT 1 k ≤1 + log(1/2α)\nand\nbT/2c∑ k=αT T∑ t=T−k\n1 k(k + 1)t ≤ 1 T bT/2c∑ k=αT ( 1 k + 1 T − k )\n≤ 1 T ((1 + log(1/2α)) + (1 + log(2(1− α)))) ≤ 1 T (2 + log(1/α)) .\nUsing the above estimates, with some simplifications for readability, we get that E[F (w̄αT ) − F (w∗)] is at most\n17 ( 1 + log ( 1\nα\n)) G2\nλT . (7)\nThis analysis assumed αT ≤ bT/2c. If α is larger, we can use the existing analysis (Rakhlin et al. (2011), Theorem 5), and get that E[F (w̄αT )− F (w∗)] is at most(\n4 + 5 log\n( 1\n1 + 1/T − α\n)) G2\nλT . (8)\nCombining Eq. (7) and Eq. (8) with a uniform upper bound which holds for all α, we get the required bound.\nWe note that in the general convex case without assuming strong convexity, one can use an analogous proof to show an upper bound of order log(1/α)/ √ T for α-suffix averaging. In contrast, existing techniques only imply a bound of order 1/ √ αT .\nAs discussed in the introduction, a limitation of suffix averaging is that unless we can store all iterates in memory, it requires us to guess the stopping time T in advance. For example, if we do 1/2-suffix averaging, we need to “know” when we got to iterate T/2 and should start averaging. In practice, the stopping time T is often not known in advance and is determined empirically (e.g. by estimating the error on held-out data till satisfactory performance is obtained). One way to handle this is to decide in advance on a fixed schedule of stopping times T (e.g. T0, 2T0, 2 2T0, 2 3T0, . . . for some T0) and maintain suffix-averages only for those times. However, this is still not very flexible. In contrast, maintaining the average of all iterates up to time t can be done on-the-fly: we initialize w̄1 = w1, and for any t > 1, we let\nw̄t =\n( 1− 1\nt\n) w̄t−1 + 1\nt wt. (9)\nUnfortunately, returning the average of all iterates as in Eq. (9) is provably suboptimal and can harm performance Rakhlin et al. (2011). Alternatively, we can easily maintain and return the current iterate wt, but the bound we have for it is only O(log(t)/t), worse than the minimax-optimal O(1/t) we can get with suffix averaging.\nIn the following, we analyze a new and very simple running average scheme, denoted as polynomial-decay averaging, and show that it combines the best of both worlds: it can easily be computed on the fly, and it gives an optimal rate. It is parameterized by a number η ≥ 0, which should be thought of as a small constant (e.g. η = 3), and the procedure is defined as follows: w̄η1 = w1, and for any t > 1,\nw̄ηt =\n( 1− η + 1\nt+ η\n) w̄ηt−1 + η + 1\nt+ η wt. (10)\nNote that for η = 0, this is exactly standard averaging (see Eq. (9)), whereas η > 0 reduces the weight of earlier iterates compared to later ones. Moreover, w̄ηt can be computed on-the-fly, just as easily as computing a standard average. An analysis of this averaging scheme in the strongly-convex case is provided in the theorem below.\nTheorem 4. Suppose F is λ-strongly convex, and that E[‖ĝt‖2] ≤ G2 for all t. Consider SGD initialized with w1 and step-sizes ηt = 1/λt. Also, let η ≥ 2 be an integer. Then E [F (wηT )− F (w∗)] is at most\n17 ( 1 + η\nT\n)( η(η + 1) + (η + 0.5)3(1 + log(T ))\nT\n) G2\nλT\nAssuming that η is an integer is merely for simplicity.\nProof. We can rewrite the recursion as\nw̄ηt = t− 1 t+ η w̄ηt−1 + η + 1 t+ η wt\nfor t ≥ 1 with w̄η0 = 0. Unwrapping the recursion, we have that for any T ≥ 1, w̄ η T = ∑T t=1 αtwt,, where\nαt = η + 1\nt+ η T∏ j=t+1 j − 1 j + η ,\nand at t = T , the convention that ∏T j=T+1((j − 1)/(j + η)) = 1 is used.\nWe now denote F ′(w) = F (w)−F (w∗). Since w̄ηT is a weighted average of w1, . . . ,wT , where the weights αt sum up to be 1, it follows by the convexity of F and Jensen’s inequality that F ′ (w̄ηT ) ≤ ∑T t=1 αtF ′(wt).\nLet S′k = ∑T t=T−k F ′(wt), and let α0 = 0, then we have\nF ′ (w̄ηT ) ≤ T∑ t=1 (αt − αt−1)S′T−t. (11)\nIt is not difficult to check that for all t ≥ 1:\nαt − αt−1 = η(η + 1)\n(t− 1 + η)(t+ η) T∏ j=t+1 j − 1 j + η\n= η(η + 1)\nT (T + 1) T+1∏ j=t\nj\nj − 1 + η\n≤  η(η+1)T (T+1) ( t−2+η T+η )η−1 if t ≤ T + 2− η\nη(η+1) T (T+1) otherwise\n≤ η(η + 1)(t+ η) T (T + 1)(T + 2) ,\nwhere the derivation of the last inequality has used η ≥ 2. As to S′T−t in Eq. (11), note that the upper bound proof of Thm. 3 equally applies to 1T−t+1S ′ T−t. Using this bound and substituting in Eq. (11), we obtain\nF ′ (w̄ηT )\n≤ T∑ t=1 αt(T − t+ 1) 17G2 log\n( Te\nmin{t,T−t+1} ) λT\n≤ dT/2e∑ t=1 2η(η + 1)(t+ η) T (T + 1)(T + 2) (T + η) 17G2 log (Te/t) λT ≤34G 2η(η + 1)(T + η)\nλT 2(T + 1)(T + 2) (A+B + C), (12)\nwhere\nA = dT/2e∑ t=1 η log(Te/t) ≤ ηT + 1 2 log(Te),\nand\nB = dT/2e∑ t=1 t log(Te) ≤ 0.5(dT/2e)(dT/2e+ 1) log(Te),\nand\nC ≤− dT/2e∑ t=1 t log(t) ≤ − ∫ dT/2e t=1 t log(t)dt\n=− [ 0.5t2 log t− 0.25t2 ] ∣∣dT/2e 1 =− 0.5dT/2e2 log(T/2) + 0.25dT/2e2 − 0.25.\nTherefore we have\nA+B + C\n≤(η + 0.5)T + 1 2 log(Te)\n+ 0.5 (T + 1)2\n4 log(2e1.5)− 0.25\n≤(η + 0.5)T + 1 2 log(Te) + 0.5(T + 1)(T + 2).\nPlugging this estimate into Eq. (12) and simplifying, we obtain the desired bound.\nNote that for a constant η, the bound is essentially optimal. We end by noting that using an identical proof technique, it holds in the case of general convex F (with assumptions similar to Thm. 2) that\nE [F (wηT )− F (w ∗)] ≤ O\n( η(D2/c+ cG2)√\nT\n) ,\nthis implies that polynomial-decay averaging is also optimal (up to constants) in the general convex case."
    }, {
      "heading" : "5 Experiments",
      "text" : "In this section, we study the behavior of the polynomial-decay averaging scheme on a few strongly-convex optimization problems. We chose the same 3 binary classification datasets ((ccat,cov1 and astro-ph) and experimental setup as in Rakhlin et al. (2011). For each dataset {xi, yi}mi=1, we ran SGD on the support vector machine optimization problem\nF (w) = λ 2 ‖w‖2 + 1 m m∑ i=1 max{0, 1− yi〈xi,w〉},\nwith the domainW = Rd, where the stochastic gradient given wt was computed by taking a single randomly drawn training example (xi, yi) and computing the gradient with respect to that example, i.e. ĝt = λwt − 1yi〈xi,wt〉≤1yixi. All algorithms were initialized at w1 = 0. Following previous work, we chose λ = 10\n−4 for ccat, λ = 10−6 for cov1, and λ = 5× 10−5 for astro-ph. The η parameter of polynomial-decay averaging was set to 3. For comparison, besides polynomial-decay averaging, we also ran suffix averaging with α = 1/2, and simple averaging of all iterates. The results are reported in the figure below. Each graph is a log-log plot representing the training error on one dataset over 10 repetitions, as a function of the number of iterations. We also experimented on the test set provided with each dataset, but omit the results as they are very similar.\nThe graphs below clearly indicate that polynomial-decay averaging work quite well. Achieving the best or almost-best performance in all cases. Suffix averaging performs performs similarly, although as discussed earlier, it is not as amenable to on-the-fly computation. Compared to these schemes, a simple average of all iterates is significantly suboptimal, matching the results of Rakhlin et al. (2011)."
    }, {
      "heading" : "6 Discussion",
      "text" : "In this paper, we investigated the convergence behavior of SGD, and the averaging schemes required to obtain optimal performance. In particular, we considered polynomial-decay averaging, which is as simple to compute as standard averaging of all iterates, but attains better performance theoretically and in practice. We also extended the existing analysis of SGD by providing new finite-sample bounds on individual SGD iterates, which hold without any smoothness assumptions, for both convex and strongly-convex problems.\nFinally, we provided new bounds for suffix averaging. While we focused on standard gradient descent, our techniques can be extended to the more general mirror descent framework and non-Euclidean norms.\nAn important open question is whether the O(log(T )/T ) rate we obtained on the individual iterate wT , for strongly-convex problems, is tight. This question is important, because running SGD for T iterations,\n0 2 4 6 8 10 12 −2\n0\n2\n4\n6\n8\n10\nlog(T)\nlo g(\nF (⋅)\n)\nASTRO\n0 2 4 6 8 10 12 −2\n0\n2\n4\n6\n8\nlog(T)\nlo g(\nF (⋅)\n)\nCCAT\n0 5 10 15\n0\n5\n10\nlog(T)\nlo g(\nF (⋅)\n)\nCOV1\nPoly. Decay Suffix Simple\nand returning the last iterate wT , is a very common heuristic. If the O(log(T )/T ) bound is tight, it means practitioners should not return the last iterate, since better O(1/T ) rates can be obtained by suffix averaging or polynomial-decay averaging. Alternatively, a O(1/T ) bound on the last iterate can indicate\nthat returning the last iterate is indeed justified. For a further discussion of this, see Shamir (2012). Another question is whether high-probability versions of our individual iterate bounds (Thm. 1 and Thm. 2) can be obtained, especially in the strongly-convex case. Again, this question has practical implications, since if a high-probability bound does not hold, it might imply that the last iterate can suffer from high variability, and should be used with caution. Finally, the tightness of Thm. 2 is still unclear. In fact, even for the simpler case of (non-stocahstic) gradient descent, we do not know whether the behavior of the last iterate proved in Thm. 2 is tight. In general, for an algorithm as simple and popular as SGD, we should have a better understanding of how it behaves and how it should be used in an optimal way."
    } ],
    "references" : [ {
      "title" : "Information-theoretic lower bounds on the oracle complexity of stochastic convex optimization",
      "author" : [ "A. Agarwal", "P. Bartlett", "P. Ravikumar", "M. Wainwright" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "Agarwal et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Agarwal et al\\.",
      "year" : 2012
    }, {
      "title" : "Non-asymptotic analysis of stochastic approximation algorithms for machine learning",
      "author" : [ "F. Bach", "E. Moulines" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "Bach and Moulines,? \\Q2011\\E",
      "shortCiteRegEx" : "Bach and Moulines",
      "year" : 2011
    }, {
      "title" : "Beyond the regret minimization barrier: An optimal algorithm for stochastic strongly-convex optimization",
      "author" : [ "E. Hazan", "S. Kale" ],
      "venue" : "In COLT,",
      "citeRegEx" : "Hazan and Kale,? \\Q2011\\E",
      "shortCiteRegEx" : "Hazan and Kale",
      "year" : 2011
    }, {
      "title" : "Logarithmic regret algorithms for online convex optimization",
      "author" : [ "E. Hazan", "A. Agarwal", "S. Kale" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Hazan et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Hazan et al\\.",
      "year" : 2007
    }, {
      "title" : "Stochastic Approximation and Recursive Algorithms and Applications",
      "author" : [ "H. Kushner", "G. Yin" ],
      "venue" : null,
      "citeRegEx" : "Kushner and Yin,? \\Q2003\\E",
      "shortCiteRegEx" : "Kushner and Yin",
      "year" : 2003
    }, {
      "title" : "Stochastic smoothing for nonsmooth minimizations: Accelerating sgd by exploiting structure",
      "author" : [ "H. Ouyang", "A. Gray" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Ouyang and Gray,? \\Q2012\\E",
      "shortCiteRegEx" : "Ouyang and Gray",
      "year" : 2012
    }, {
      "title" : "Making gradient descent optimal for strongly convex stochastic optimization",
      "author" : [ "A. Rakhlin", "O. Shamir", "K. Sridharan" ],
      "venue" : "CoRR, abs/1109.5647,",
      "citeRegEx" : "Rakhlin et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Rakhlin et al\\.",
      "year" : 2011
    }, {
      "title" : "Stochastic convex optimization",
      "author" : [ "S. Shalev-Shwartz", "O. Shamir", "N. Srebro", "K. Sridharan" ],
      "venue" : "In COLT,",
      "citeRegEx" : "Shalev.Shwartz et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Shalev.Shwartz et al\\.",
      "year" : 2009
    }, {
      "title" : "Pegasos: primal estimated sub-gradient solver for svm",
      "author" : [ "S. Shalev-Shwartz", "Y. Singer", "N. Srebro", "A. Cotter" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Shalev.Shwartz et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Shalev.Shwartz et al\\.",
      "year" : 2011
    }, {
      "title" : "Is averaging needed for strongly convex stochastic gradient descent? Open problem presented at COLT",
      "author" : [ "O. Shamir" ],
      "venue" : null,
      "citeRegEx" : "Shamir,? \\Q2012\\E",
      "shortCiteRegEx" : "Shamir",
      "year" : 2012
    }, {
      "title" : "Solving large scale linear prediction problems using stochastic gradient descent algorithms",
      "author" : [ "T. Zhang" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Zhang,? \\Q2004\\E",
      "shortCiteRegEx" : "Zhang",
      "year" : 2004
    }, {
      "title" : "Online convex programming and generalized infinitesimal gradient ascent",
      "author" : [ "M. Zinkevich" ],
      "venue" : "In ICML,",
      "citeRegEx" : "Zinkevich,? \\Q2003\\E",
      "shortCiteRegEx" : "Zinkevich",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "We also propose a new and simple averaging scheme, which not only attains optimal rates, but can also be easily computed on-the-fly (in contrast, the suffix averaging scheme proposed in Rakhlin et al. (2011) is not as simple to implement).",
      "startOffset" : 186,
      "endOffset" : 208
    }, {
      "referenceID" : 4,
      "context" : "2), and O(1/ √ T ) error for general convex F Zinkevich (2003); Hazan et al.",
      "startOffset" : 46,
      "endOffset" : 63
    }, {
      "referenceID" : 2,
      "context" : "2), and O(1/ √ T ) error for general convex F Zinkevich (2003); Hazan et al. (2007); Hazan & Kale (2011).",
      "startOffset" : 64,
      "endOffset" : 84
    }, {
      "referenceID" : 2,
      "context" : "2), and O(1/ √ T ) error for general convex F Zinkevich (2003); Hazan et al. (2007); Hazan & Kale (2011). However, Rakhlin et al.",
      "startOffset" : 64,
      "endOffset" : 105
    }, {
      "referenceID" : 2,
      "context" : "2), and O(1/ √ T ) error for general convex F Zinkevich (2003); Hazan et al. (2007); Hazan & Kale (2011). However, Rakhlin et al. (2011) showed that simple averaging is provably suboptimal in a stochastic setting.",
      "startOffset" : 64,
      "endOffset" : 137
    }, {
      "referenceID" : 0,
      "context" : "In comparison, in the non-smooth setting, there are Ω(1/ √ T ) and Ω(1/T ) lower bounds for convex and strongly-convex problems, respectively Agarwal et al. (2012). These results leave open several issues.",
      "startOffset" : 142,
      "endOffset" : 164
    }, {
      "referenceID" : 0,
      "context" : "In comparison, in the non-smooth setting, there are Ω(1/ √ T ) and Ω(1/T ) lower bounds for convex and strongly-convex problems, respectively Agarwal et al. (2012). These results leave open several issues. First, they pertain to averaging significant parts of the iterates, although in practice averaging just over the last few iterates, or returning the last iterate wT , often works quite well (e.g. Shalev-Shwartz et al. (2011)).",
      "startOffset" : 142,
      "endOffset" : 431
    }, {
      "referenceID" : 0,
      "context" : "In comparison, in the non-smooth setting, there are Ω(1/ √ T ) and Ω(1/T ) lower bounds for convex and strongly-convex problems, respectively Agarwal et al. (2012). These results leave open several issues. First, they pertain to averaging significant parts of the iterates, although in practice averaging just over the last few iterates, or returning the last iterate wT , often works quite well (e.g. Shalev-Shwartz et al. (2011)). Unless F is smooth, the previous results cannot say much about the optimization error of individual iterates. For example, the results in Rakhlin et al. (2011) only imply an O(1/ √ T ) convergence rate for the last iterate wT with strongly-convex functions, and we are not aware of any results for the last iterate wT in the general convex case.",
      "startOffset" : 142,
      "endOffset" : 593
    }, {
      "referenceID" : 0,
      "context" : "In comparison, in the non-smooth setting, there are Ω(1/ √ T ) and Ω(1/T ) lower bounds for convex and strongly-convex problems, respectively Agarwal et al. (2012). These results leave open several issues. First, they pertain to averaging significant parts of the iterates, although in practice averaging just over the last few iterates, or returning the last iterate wT , often works quite well (e.g. Shalev-Shwartz et al. (2011)). Unless F is smooth, the previous results cannot say much about the optimization error of individual iterates. For example, the results in Rakhlin et al. (2011) only imply an O(1/ √ T ) convergence rate for the last iterate wT with strongly-convex functions, and we are not aware of any results for the last iterate wT in the general convex case. In fact to the best of our knowledge, even for the simpler (non-stochastic) gradient descent method (where ĝt = gt), we do not know any existing results that can guarantee the performance of each individual iterate wT . Second, the theoretically optimal suffix-averaging scheme proposed in Rakhlin et al. (2011) has some practical limitations, since it cannot be computed on-the-fly: unless we can store all iterates w1, .",
      "startOffset" : 142,
      "endOffset" : 1091
    }, {
      "referenceID" : 0,
      "context" : "In comparison, in the non-smooth setting, there are Ω(1/ √ T ) and Ω(1/T ) lower bounds for convex and strongly-convex problems, respectively Agarwal et al. (2012). These results leave open several issues. First, they pertain to averaging significant parts of the iterates, although in practice averaging just over the last few iterates, or returning the last iterate wT , often works quite well (e.g. Shalev-Shwartz et al. (2011)). Unless F is smooth, the previous results cannot say much about the optimization error of individual iterates. For example, the results in Rakhlin et al. (2011) only imply an O(1/ √ T ) convergence rate for the last iterate wT with strongly-convex functions, and we are not aware of any results for the last iterate wT in the general convex case. In fact to the best of our knowledge, even for the simpler (non-stochastic) gradient descent method (where ĝt = gt), we do not know any existing results that can guarantee the performance of each individual iterate wT . Second, the theoretically optimal suffix-averaging scheme proposed in Rakhlin et al. (2011) has some practical limitations, since it cannot be computed on-the-fly: unless we can store all iterates w1, . . . ,wT in memory, one needs to know the stopping time T beforehand, in order to know when to start computing the suffix average. In practice, T is often not known in advance. This can be partially remedied with a so-called doubling trick, but it is still not a simple or natural procedure compared to just averaging all iterates, and the latter was shown to be suboptimal in Rakhlin et al. (2011). In this paper, we investigate the convergence rate of SGD and the averaging schemes required to obtain them, with the following contributions: • We prove that the expected optimization error of every individual iterate wT is O(log(T )/T ) for strongly-convex F , and O(log(T )/ √ T ) for general convex F without smoothness assumptions on F .",
      "startOffset" : 142,
      "endOffset" : 1600
    }, {
      "referenceID" : 0,
      "context" : "In comparison, in the non-smooth setting, there are Ω(1/ √ T ) and Ω(1/T ) lower bounds for convex and strongly-convex problems, respectively Agarwal et al. (2012). These results leave open several issues. First, they pertain to averaging significant parts of the iterates, although in practice averaging just over the last few iterates, or returning the last iterate wT , often works quite well (e.g. Shalev-Shwartz et al. (2011)). Unless F is smooth, the previous results cannot say much about the optimization error of individual iterates. For example, the results in Rakhlin et al. (2011) only imply an O(1/ √ T ) convergence rate for the last iterate wT with strongly-convex functions, and we are not aware of any results for the last iterate wT in the general convex case. In fact to the best of our knowledge, even for the simpler (non-stochastic) gradient descent method (where ĝt = gt), we do not know any existing results that can guarantee the performance of each individual iterate wT . Second, the theoretically optimal suffix-averaging scheme proposed in Rakhlin et al. (2011) has some practical limitations, since it cannot be computed on-the-fly: unless we can store all iterates w1, . . . ,wT in memory, one needs to know the stopping time T beforehand, in order to know when to start computing the suffix average. In practice, T is often not known in advance. This can be partially remedied with a so-called doubling trick, but it is still not a simple or natural procedure compared to just averaging all iterates, and the latter was shown to be suboptimal in Rakhlin et al. (2011). In this paper, we investigate the convergence rate of SGD and the averaging schemes required to obtain them, with the following contributions: • We prove that the expected optimization error of every individual iterate wT is O(log(T )/T ) for strongly-convex F , and O(log(T )/ √ T ) for general convex F without smoothness assumptions on F . These results show that the suboptimality of the last iterate is not much worse than the optimal rates obtainable by averaging schemes, and partially addresses an open problem posed in Shamir (2012). Moreover, the latter result is (to the best of our knowledge) the first finite-sample bound on individual iterates of SGD for non-smooth convex optimization.",
      "startOffset" : 142,
      "endOffset" : 2143
    }, {
      "referenceID" : 0,
      "context" : "In comparison, in the non-smooth setting, there are Ω(1/ √ T ) and Ω(1/T ) lower bounds for convex and strongly-convex problems, respectively Agarwal et al. (2012). These results leave open several issues. First, they pertain to averaging significant parts of the iterates, although in practice averaging just over the last few iterates, or returning the last iterate wT , often works quite well (e.g. Shalev-Shwartz et al. (2011)). Unless F is smooth, the previous results cannot say much about the optimization error of individual iterates. For example, the results in Rakhlin et al. (2011) only imply an O(1/ √ T ) convergence rate for the last iterate wT with strongly-convex functions, and we are not aware of any results for the last iterate wT in the general convex case. In fact to the best of our knowledge, even for the simpler (non-stochastic) gradient descent method (where ĝt = gt), we do not know any existing results that can guarantee the performance of each individual iterate wT . Second, the theoretically optimal suffix-averaging scheme proposed in Rakhlin et al. (2011) has some practical limitations, since it cannot be computed on-the-fly: unless we can store all iterates w1, . . . ,wT in memory, one needs to know the stopping time T beforehand, in order to know when to start computing the suffix average. In practice, T is often not known in advance. This can be partially remedied with a so-called doubling trick, but it is still not a simple or natural procedure compared to just averaging all iterates, and the latter was shown to be suboptimal in Rakhlin et al. (2011). In this paper, we investigate the convergence rate of SGD and the averaging schemes required to obtain them, with the following contributions: • We prove that the expected optimization error of every individual iterate wT is O(log(T )/T ) for strongly-convex F , and O(log(T )/ √ T ) for general convex F without smoothness assumptions on F . These results show that the suboptimality of the last iterate is not much worse than the optimal rates obtainable by averaging schemes, and partially addresses an open problem posed in Shamir (2012). Moreover, the latter result is (to the best of our knowledge) the first finite-sample bound on individual iterates of SGD for non-smooth convex optimization. The proof relies on a technique to reduce results on averages of iterates to results on individual iterates, which was implicitly used in Zhang (2004) for a somewhat different setting.",
      "startOffset" : 142,
      "endOffset" : 2453
    }, {
      "referenceID" : 0,
      "context" : "In comparison, in the non-smooth setting, there are Ω(1/ √ T ) and Ω(1/T ) lower bounds for convex and strongly-convex problems, respectively Agarwal et al. (2012). These results leave open several issues. First, they pertain to averaging significant parts of the iterates, although in practice averaging just over the last few iterates, or returning the last iterate wT , often works quite well (e.g. Shalev-Shwartz et al. (2011)). Unless F is smooth, the previous results cannot say much about the optimization error of individual iterates. For example, the results in Rakhlin et al. (2011) only imply an O(1/ √ T ) convergence rate for the last iterate wT with strongly-convex functions, and we are not aware of any results for the last iterate wT in the general convex case. In fact to the best of our knowledge, even for the simpler (non-stochastic) gradient descent method (where ĝt = gt), we do not know any existing results that can guarantee the performance of each individual iterate wT . Second, the theoretically optimal suffix-averaging scheme proposed in Rakhlin et al. (2011) has some practical limitations, since it cannot be computed on-the-fly: unless we can store all iterates w1, . . . ,wT in memory, one needs to know the stopping time T beforehand, in order to know when to start computing the suffix average. In practice, T is often not known in advance. This can be partially remedied with a so-called doubling trick, but it is still not a simple or natural procedure compared to just averaging all iterates, and the latter was shown to be suboptimal in Rakhlin et al. (2011). In this paper, we investigate the convergence rate of SGD and the averaging schemes required to obtain them, with the following contributions: • We prove that the expected optimization error of every individual iterate wT is O(log(T )/T ) for strongly-convex F , and O(log(T )/ √ T ) for general convex F without smoothness assumptions on F . These results show that the suboptimality of the last iterate is not much worse than the optimal rates obtainable by averaging schemes, and partially addresses an open problem posed in Shamir (2012). Moreover, the latter result is (to the best of our knowledge) the first finite-sample bound on individual iterates of SGD for non-smooth convex optimization. The proof relies on a technique to reduce results on averages of iterates to results on individual iterates, which was implicitly used in Zhang (2004) for a somewhat different setting. • We improve the existing expected error bound on the suffix averaging scheme of Rakhlin et al. (2011), from O((1 + log( 1 1−α ))/αT ) to O(log( 1 min{α,1−α} )/T ).",
      "startOffset" : 142,
      "endOffset" : 2590
    }, {
      "referenceID" : 0,
      "context" : "In comparison, in the non-smooth setting, there are Ω(1/ √ T ) and Ω(1/T ) lower bounds for convex and strongly-convex problems, respectively Agarwal et al. (2012). These results leave open several issues. First, they pertain to averaging significant parts of the iterates, although in practice averaging just over the last few iterates, or returning the last iterate wT , often works quite well (e.g. Shalev-Shwartz et al. (2011)). Unless F is smooth, the previous results cannot say much about the optimization error of individual iterates. For example, the results in Rakhlin et al. (2011) only imply an O(1/ √ T ) convergence rate for the last iterate wT with strongly-convex functions, and we are not aware of any results for the last iterate wT in the general convex case. In fact to the best of our knowledge, even for the simpler (non-stochastic) gradient descent method (where ĝt = gt), we do not know any existing results that can guarantee the performance of each individual iterate wT . Second, the theoretically optimal suffix-averaging scheme proposed in Rakhlin et al. (2011) has some practical limitations, since it cannot be computed on-the-fly: unless we can store all iterates w1, . . . ,wT in memory, one needs to know the stopping time T beforehand, in order to know when to start computing the suffix average. In practice, T is often not known in advance. This can be partially remedied with a so-called doubling trick, but it is still not a simple or natural procedure compared to just averaging all iterates, and the latter was shown to be suboptimal in Rakhlin et al. (2011). In this paper, we investigate the convergence rate of SGD and the averaging schemes required to obtain them, with the following contributions: • We prove that the expected optimization error of every individual iterate wT is O(log(T )/T ) for strongly-convex F , and O(log(T )/ √ T ) for general convex F without smoothness assumptions on F . These results show that the suboptimality of the last iterate is not much worse than the optimal rates obtainable by averaging schemes, and partially addresses an open problem posed in Shamir (2012). Moreover, the latter result is (to the best of our knowledge) the first finite-sample bound on individual iterates of SGD for non-smooth convex optimization. The proof relies on a technique to reduce results on averages of iterates to results on individual iterates, which was implicitly used in Zhang (2004) for a somewhat different setting. • We improve the existing expected error bound on the suffix averaging scheme of Rakhlin et al. (2011), from O((1 + log( 1 1−α ))/αT ) to O(log( 1 min{α,1−α} )/T ). • We propose a new and very simple running average scheme, called polynomial-decay averaging, and prove that it enjoys optimal rates of convergence. Unlike suffix-averaging, this new running average scheme can be easily computed on-the-fly. • We provide a simple experimental study of the averaging schemes discussed in the paper. We emphasize that although there exist other algorithms with O(1/T ) convergence rate in the strongly convex case (e.g. Hazan & Kale (2011); Ouyang & Gray (2012)), our focus in this paper is on the simple and widely-used SGD algorithm.",
      "startOffset" : 142,
      "endOffset" : 3123
    }, {
      "referenceID" : 0,
      "context" : "In comparison, in the non-smooth setting, there are Ω(1/ √ T ) and Ω(1/T ) lower bounds for convex and strongly-convex problems, respectively Agarwal et al. (2012). These results leave open several issues. First, they pertain to averaging significant parts of the iterates, although in practice averaging just over the last few iterates, or returning the last iterate wT , often works quite well (e.g. Shalev-Shwartz et al. (2011)). Unless F is smooth, the previous results cannot say much about the optimization error of individual iterates. For example, the results in Rakhlin et al. (2011) only imply an O(1/ √ T ) convergence rate for the last iterate wT with strongly-convex functions, and we are not aware of any results for the last iterate wT in the general convex case. In fact to the best of our knowledge, even for the simpler (non-stochastic) gradient descent method (where ĝt = gt), we do not know any existing results that can guarantee the performance of each individual iterate wT . Second, the theoretically optimal suffix-averaging scheme proposed in Rakhlin et al. (2011) has some practical limitations, since it cannot be computed on-the-fly: unless we can store all iterates w1, . . . ,wT in memory, one needs to know the stopping time T beforehand, in order to know when to start computing the suffix average. In practice, T is often not known in advance. This can be partially remedied with a so-called doubling trick, but it is still not a simple or natural procedure compared to just averaging all iterates, and the latter was shown to be suboptimal in Rakhlin et al. (2011). In this paper, we investigate the convergence rate of SGD and the averaging schemes required to obtain them, with the following contributions: • We prove that the expected optimization error of every individual iterate wT is O(log(T )/T ) for strongly-convex F , and O(log(T )/ √ T ) for general convex F without smoothness assumptions on F . These results show that the suboptimality of the last iterate is not much worse than the optimal rates obtainable by averaging schemes, and partially addresses an open problem posed in Shamir (2012). Moreover, the latter result is (to the best of our knowledge) the first finite-sample bound on individual iterates of SGD for non-smooth convex optimization. The proof relies on a technique to reduce results on averages of iterates to results on individual iterates, which was implicitly used in Zhang (2004) for a somewhat different setting. • We improve the existing expected error bound on the suffix averaging scheme of Rakhlin et al. (2011), from O((1 + log( 1 1−α ))/αT ) to O(log( 1 min{α,1−α} )/T ). • We propose a new and very simple running average scheme, called polynomial-decay averaging, and prove that it enjoys optimal rates of convergence. Unlike suffix-averaging, this new running average scheme can be easily computed on-the-fly. • We provide a simple experimental study of the averaging schemes discussed in the paper. We emphasize that although there exist other algorithms with O(1/T ) convergence rate in the strongly convex case (e.g. Hazan & Kale (2011); Ouyang & Gray (2012)), our focus in this paper is on the simple and widely-used SGD algorithm.",
      "startOffset" : 142,
      "endOffset" : 3145
    }, {
      "referenceID" : 7,
      "context" : "It is well-known that this framework can be applied to learning problems (see for instance Shalev-Shwartz et al. (2009)): given a hypothesis class W and a set of T i.",
      "startOffset" : 91,
      "endOffset" : 120
    }, {
      "referenceID" : 3,
      "context" : "Now comes the crucial trick: instead of picking w = w∗, as done in standard analysis (Hazan et al. (2007); Rakhlin et al.",
      "startOffset" : 86,
      "endOffset" : 106
    }, {
      "referenceID" : 3,
      "context" : "Now comes the crucial trick: instead of picking w = w∗, as done in standard analysis (Hazan et al. (2007); Rakhlin et al. (2011)), we instead pick w = wT−k.",
      "startOffset" : 86,
      "endOffset" : 129
    }, {
      "referenceID" : 3,
      "context" : "Now comes the crucial trick: instead of picking w = w∗, as done in standard analysis (Hazan et al. (2007); Rakhlin et al. (2011)), we instead pick w = wT−k. We also use the fact that E [ ‖wt −w∗‖2 ] ≤ 4G 2 λ2t (Rakhlin et al. (2011), Lemma 1), which implies that for any t ≥ T − k, E[‖wt −wT−k‖] ≤2E [ ‖wt −w∗‖2 + ‖wT−k −w∗‖2 ] ≤ 8G 2 λ2 ( 1 t + 1 T − k ) ≤ 16G 2 λ2(T − k) ≤ 32G 2 λ2T .",
      "startOffset" : 86,
      "endOffset" : 233
    }, {
      "referenceID" : 6,
      "context" : "E[ST/2] is the expected average value of the last bT/2c iterates, which was already analyzed in (Rakhlin et al. (2011), Theorem 5), yielding a bound of",
      "startOffset" : 97,
      "endOffset" : 119
    }, {
      "referenceID" : 10,
      "context" : "We note that a similar technique was used in Zhang (2004), but for a different algorithm (one with constant learning rate), and the result was less explicit.",
      "startOffset" : 45,
      "endOffset" : 58
    }, {
      "referenceID" : 6,
      "context" : "In Rakhlin et al. (2011), it was shown that this averaging scheme results in an optimization error of O((1 + log( 1 1−α ))/αT ), which is optimal in terms of T , but increases rapidly as we make α smaller.",
      "startOffset" : 3,
      "endOffset" : 25
    }, {
      "referenceID" : 6,
      "context" : "If α is larger, we can use the existing analysis (Rakhlin et al. (2011), Theorem 5), and get that E[F (w̄ T )− F (w∗)] is at most ( 4 + 5 log ( 1 1 + 1/T − α )) G λT .",
      "startOffset" : 50,
      "endOffset" : 72
    }, {
      "referenceID" : 6,
      "context" : "(9) is provably suboptimal and can harm performance Rakhlin et al. (2011). Alternatively, we can easily maintain and return the current iterate wt, but the bound we have for it is only O(log(t)/t), worse than the minimax-optimal O(1/t) we can get with suffix averaging.",
      "startOffset" : 52,
      "endOffset" : 74
    }, {
      "referenceID" : 6,
      "context" : "We chose the same 3 binary classification datasets ((ccat,cov1 and astro-ph) and experimental setup as in Rakhlin et al. (2011). For each dataset {xi, yi}i=1, we ran SGD on the support vector machine optimization problem",
      "startOffset" : 106,
      "endOffset" : 128
    }, {
      "referenceID" : 6,
      "context" : "Compared to these schemes, a simple average of all iterates is significantly suboptimal, matching the results of Rakhlin et al. (2011).",
      "startOffset" : 113,
      "endOffset" : 135
    } ],
    "year" : 2017,
    "abstractText" : "Stochastic Gradient Descent (SGD) is one of the simplest and most popular stochastic optimization methods. While it has already been theoretically studied for decades, the classical analysis usually required non-trivial smoothness assumptions, which do not apply to many modern applications of SGD with non-smooth objective functions such as support vector machines. In this paper, we investigate the performance of SGD without such smoothness assumptions, as well as a running average scheme to convert the SGD iterates to a solution with optimal optimization accuracy. In this framework, we prove that after T rounds, the suboptimality of the last SGD iterate scales as O(log(T )/ √ T ) for non-smooth convex objective functions, and O(log(T )/T ) in the non-smooth strongly convex case. To the best of our knowledge, these are the first bounds of this kind, and almost match the minimax-optimal rates obtainable by appropriate averaging schemes. We also propose a new and simple averaging scheme, which not only attains optimal rates, but can also be easily computed on-the-fly (in contrast, the suffix averaging scheme proposed in Rakhlin et al. (2011) is not as simple to implement). Finally, we provide some experimental illustrations.",
    "creator" : "LaTeX with hyperref package"
  }
}