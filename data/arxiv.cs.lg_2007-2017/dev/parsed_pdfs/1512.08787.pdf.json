{
  "name" : "1512.08787.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Matrix Completion Under Monotonic Single Index Models",
    "authors" : [ "Ravi Ganti", "Laura Balzano" ],
    "emails" : [ "gantimahapat@wisc.edu", "girasole@umich.edu", "rmwillett@wisc.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "In matrix completion, one has access to a matrix with only a few observed entries, and the task is to estimate the entire matrix using the observed entries. This problem has a plethora of applications such as collaborative filtering, recommender systems [1] and sensor networks [2]. Matrix completion has been well studied in machine learning, and we now know how to recover certain matrices given a few observed entries of the matrix [3, 4] when it is assumed to be low rank. Typical work in matrix completion assumes that the matrix to be recovered is incoherent, low rank, and entries are sampled uniformly at random [3, 4, 5, 6, 7, 8]. While recent work has focused on relaxing the incoherence and sampling conditions under which matrix completion succeeds, there has been little work for matrix completion when the underlying matrix is of high rank. More specifically, we shall assume that the matrix that we need to complete is obtained by applying some unknown, non-linear function to each element of an unknown low-rank matrix. Because of the application of a non-linear transformation, the resulting ratings matrix tends to have a large rank. To understand the effect of the application of non-linear transformation on a low-rank matrix, we shall consider the following simple experiment: Given an n ×m matrix X , let X = ∑m i=1 σiuiv > i be its SVD. The rank of the matrix X is the number of non-zero singular values. Given an ∈ (0, 1), define the effective rank of X as follows:\nr (X) = min { k ∈ N : √∑m j=k+1 σ 2 j∑m\nj=1 σ 2 j\n≤ } . (1)\nar X\niv :1\n51 2.\n08 78\n7v 1\n[ st\nat .M\nL ]\nThe effective rank of X tells us the rank k of the lowest rank approximator X̂ that satisfies\n||X̂ −X||F ||X||F ≤ . (2)\nIn figure (1), we show the effect of applying a non-linear monotonic function g?(z) = 11+exp(−cz) to the elements of a low-rank matrix Z. As c increases both the rank of X and its effective rank r (X) grow rapidly with c, rendering traditional matrix completion methods ineffective even in the presence of mild nonlinearities."
    }, {
      "heading" : "1.1 Our Model and contributions",
      "text" : "In this paper we consider the high-rank matrix completion problem where the data generating process is as follows: There is some unknown matrix Z? ∈ Rn×m with m ≤ n and of rank r m. A non-linear, monotonic, L- Lipschitz function g? is applied to each element of the matrix Z? to get another matrix M?. A noisy version of M?, which we call X , is observed on a subset of indices denoted by Ω ⊂ [n]× [m].\nM?i,j = g ?(Z?i,j), ∀i ∈ [n], j ∈ [m] (3)\nXΩ = (M ? +N)Ω (4)\nThe function g? is called the transfer function. We shall assume that E[N ] = 0, and the entries of N are i.i.d. We shall also assume that the index set Ω is generated uniformly at random with replacement from the set [n] × [m] 1. Our task is to reliably estimate the entire matrix M? given observations of X on Ω. We shall call the above model as Monotonic Matrix Completion (MMC). To illustrate our framework we shall consider the following two simple examples. In recommender systems users are required to provide discrete ratings of various objects. For example, in the Netflix problem users are required to rate movies on a scale of 1 − 5 2. These discrete scores can be thought of as obtained by applying a rounding function to some ideal real valued score matrix given by the users. This real-valued score matrix may be well modeled by a low-rank matrix, but the application of the rounding function 3 increases the rank of the original low-rank matrix. Another important example is that of completion of Gaussian kernel matrices. Gaussian kernel matrices are used in kernel based learning methods. The Gaussian kernel matrix of a set of n points is an n× n matrix obtained by applying the Gaussian function on an underlying Euclidean distance matrix. The Euclidean distance matrix is a low-rank matrix [9]. However, in many cases one cannot measure all pair-wise distances between objects, resulting in an incomplete Euclidean distance matrix and hence an incomplete kernel matrix. Completing the kernel matrix can then be viewed as completing a matrix of large rank.\nIn this paper we study this matrix completion problem and provide algorithms with provable error guarantees. Our contributions are as follows:\n1. In Section (3) we propose an optimization formulation to estimate matrices in the above described context. In order to do this we introduce two formulations, one using a squared\n1By [n] we denote the set {1, 2 . . . , n} 2This is typical of many other recommender engines such as Pandora.com, Last.fm and Amazon.com. 3Technically the rounding function is not a Lipschitz function but can be well approximated by a Lipschitz\nfunction.\nloss, which we call MMC - LS, and another using a calibrated loss function, which we call as MMC − c. For both these formulations we minimize w.r.t. M? and g?. This calibrated loss function has the property that the minimizer of the calibrated loss satisfies equation (3).\n2. We propose alternating minimization algorithms to solve our optimization problem. Our proposed algorithms, called MMC−c and MMC-LS, alternate between solving a quadratic program to estimate g? and performing projected gradient descent updates to estimate the matrix Z?. MMC outputs the matrix M̂ where M̂i,j = ĝ(Ẑi,j).\n3. In Section (4) we analyze the mean squared error (MSE) of the matrix M̂ returned by one step of the MMC− c algorithm. The upper bound on the MSE of the matrix M̂ output by MMC depends only on the rank r of the matrix Z? and not on the rank of matrix M?. This property makes our analysis useful because the matrix M? could be potentially high rank and our results imply reliable estimation of a high rank matrix with error guarantees that depend on the rank of the matrix Z?.\n4. We compare our proposed algorithms to state-of-art implementations of low rank matrix completion on both synthetic and real datasets (Section 5). We develop an ADMM algorithm to solve the quadratic program that is used to estimate g?. We believe that the proposed ADMM algorithm is useful in its own right and can be used in general isotonic regression problems elsewhere [10, 11]."
    }, {
      "heading" : "2 Related work",
      "text" : "Classical matrix completion with and without noise has been investigated by several authors [3, 4, 5, 6, 7, 8]. The recovery techniques proposed in these papers solve a convex optimization problem that minimizes the nuclear norm of the matrix subject to convex constraints. Progress has also been made on designing efficient algorithms to solve the ensuing convex optimization problem [12, 13, 14, 15]. Recovery techniques based on nuclear norm minimization guarantee matrix recovery under the condition that a) the matrix is low rank, b) the matrix is incoherent or not very spiky, and c) the entries are observed uniformly at random. Literature on high rank matrix completion is relatively sparse. When columns or rows of the matrix belong to a union of subspaces, then the matrix tends to be of high rank. For such high rank matrix completion problems algorithms have been proposed that exploit the fact that multiple low-rank subspaces can be learned by clustering the columns or rows and learning subspaces from each of the clusters. While Eriksson et al. [16] suggested looking at the neighbourhood of each incomplete point for completion, [17] used a combination of spectral clustering techniques as done in [18, 19] along with learning sparse representations via convex optimization to estimate the incomplete matrix. Singh et al. [20] consider a certain specific class of high-rank matrices that are obtained from ultra-metrics. In [21] the authors consider a model similar to ours, but instead of learning a single monotonic function, they learn multiple monotonic functions, one for each row of the matrix. However, unlike in this paper, their focus is on a ranking problem and their proposed algorithms lack theoretical guarantees.\nDavenport et al [22] studied the one-bit matrix completion problem. Their model is a special case of the matrix completion model considered in this paper. In the one-bit matrix completion problem we assume that g? is known and is the CDF of an appropriate probability distribution, and the matrix X is a boolean matrix where each entry takes the value 1 with probability Mi,j , and 0 with probability 1−Mi,j . Since g? is known, the focus in one-bit matrix completion problems is accurate estimation of Z?.\nTo the best of our knowledge the MMC model considered in this paper has not been investigated before. The MMC model is inspired by the single-index model (SIM) that has been studied both in statistics [10, 11] and econometrics for regression problems [23, 24]. Our MMC model can be thought of as an extension of SIM to matrix completion problems."
    }, {
      "heading" : "3 Algorithms for matrix completion",
      "text" : "Our goal is to estimate g? and Z? from the model in equations (3- 4). We approach this problem via mathematical optimization. Before we discuss our algorithms, we mention in brief an algorithm\nfor the problem of learning Lipschitz, monotonic functions in 1- dimension. This algorithm will be used for learning the link function in MMC.\nThe LPAV algorithm: Suppose we are given data (p1, y1), . . . (pn, yn), where p1 ≤ p2 . . . ≤ pn, and y1, . . . , yn are real numbers. Let G def = {g : R → R, g is L-Lipschitz and monotonic}. The\nLPAV 4 algorithm introduced in [11] outputs the best function ĝ in G that minimizes ∑n i=1(g(pi)− yi) 2. In order to do this, the LPAV first solves the following optimization problem:\nẑ = arg min z∈Rn\n‖z − y‖22 s.t. 0 ≤ zj − zi ≤ L(pj − pi) if pi ≤ pj (5)\nwhere, ĝ(pi) def = ẑi. This gives us the value of ĝ on a discrete set of points p1, . . . , pn. To get ĝ everywhere else on the real line, we simply perform linear interpolation as follows:\nĝ(ζ) =  ẑ1, if ζ ≤ p1 ẑn, if ζ ≥ pn µẑi + (1− µ)ẑi+1 if ζ = µpi + (1− µ)pi+1\n(6)"
    }, {
      "heading" : "3.1 Squared loss minimization",
      "text" : "A natural approach to the monotonic matrix completion problem is to learn g?, Z? via squared loss minimization. In order to do this we need to solve the following optimization problem:\nmin g,Z ∑ Ω (g(Zi,j)−Xi,j)2\ng : R→ R is L-Lipschitz and monotonic rank(Z) ≤ r.\n(7)\nThe problem is a non-convex optimization problem individually in parameters g, Z. A reasonable approach to solve this optimization problem would be to perform optimization w.r.t. each variable while keeping the other variable fixed. For instance, in iteration t, while estimating Z one would keep g fixed, to say gt−1, and then perform projected gradient descent w.r.t. Z. This leads to the following updates for Z:\nZti,j ← Zt−1i,j − η(g t−1(Zt−1i,j )−Xi,j)(g t−1)′(Zt−1i,j ) ,∀(i, j) ∈ Ω (8) Zt ← Pr(Zt) (9)\nwhere η > 0 is a step-size used in our projected gradient descent procedure, and Pr is projection on the rank r cone. The above update involves both the function gt−1 and its derivative (gt−1)′. Since our link function is monotonic, one can use the LPAV algorithm to estimate this link function gt−1. Furthermore since LPAV estimates gt−1 as a piece-wise linear function, the function has a sub-differential everywhere and the sub-differential (gt−1)′ can be obtained very cheaply. Hence, the projected gradient update shown in equation (8) along with the LPAV algorithm can be iteratively used to learn estimates forZ? and g?. We shall call this algorithm as MMC−LS. Incorrect estimation of gt−1 will also lead to incorrect estimation of the derivative (gt−1)′. Hence, we would expect MMC− LS to be less accurate than a learning algorithm that does not have to estimate (gt−1)′. We next outline an approach that provides a principled way to derive updates for Zt and gt that does not require us to estimate derivatives of the transfer function, as in MMC− LS."
    }, {
      "heading" : "3.2 Minimization of a calibrated loss function and the MMC algorithm.",
      "text" : "Let Φ : R → R be a differentiable function that satisfies Φ′ = g?. Furthermore, since g? is a monotonic function, Φ will be a convex loss function. Now, suppose g? (and hence Φ) is known. Consider the following function of Z\nL(Z; Φ,Ω) = EX  ∑ (i,j)∈Ω Φ(Zi,j)−Xi,jZi,j  . (10) 4LPAV stands for Lipschitz Pool Adjacent Violator\nThe above loss function is convex in Z, since Φ is convex. Differentiating the expression on the R.H.S. of Equation 10 w.r.t. Z, and setting it to 0, we get∑\n(i,j)∈Ω\ng?(Zi,j)− EXi,j = 0. (11)\nThe MMC model shown in Equation (3) satisfies Equation (11) and is therefore a minimizer of the loss function L(Z; Φ,Ω). Hence, the loss function (10) is “calibrated” for the MMC model that we are interested in. The idea of using calibrated loss functions was first introduced for learning single index models [25]. When the transfer function is identity, Φ is a quadratic function and we get the squared loss approach that we discussed in section (3.1).\nThe above discussion assumes that g? is known. However in the MMC model this is not the case. To get around this problem, we consider the following optimization problem\nmin Φ,Z L(Φ, Z; Ω) = min Φ,Z EX ∑ (i,j)∈Ω Φ(Zi,j)−Xi,jZi,j (12)\nwhere Φ : R→ R is a convex function, with Φ′ = g and Z ∈ Rm×n is a low-rank matrix. Since, we know that g? is a Lipschitz, monotonic function, we shall solve a constrained optimization problem that enforces Lipschitz constraints on g and low rank constraints on Z. We consider the sample version of the optimization problem shown in equation (12).\nmin Φ\nrank(Z)≤r\nL(Φ, Z; Ω) = min Φ,Z ∑ (i,j)∈Ω Φ(Zi,j)−Xi,jZi,j (13)\nThe pseudo-code of our algorithm MMC that solves the above optimization problem (13) is shown in algorithm (1). MMC optimizes for Φ and Z alternatively, where we fix one variable and update another.\nAt the start of iteration t, we have at our disposal iterates ĝt−1, and Zt−1. To update our estimate of Z, we perform gradient descent with fixed Φ such that Φ′ = ĝt−1. Notice that the objective in equation (13) is convex w.r.t. Z. This is in contrast to the least squares objective where the objective in equation (7) is non-convex w.r.t. Z. The gradient of L(Z; Φ) w.r.t. Z is\n∇Zi,jL(Z; Φ) = ∑\n(i,j)∈Ω\nĝt−1(Ẑt−1i,j )−Xi,j . (14)\nGradient descent updates on Ẑt−1 using the above gradient calculation leads to an update of the form\nẐti,j ← Ẑt−1i,j − η(ĝ t−1(Ẑt−1i,j )−Xi,j)1(i,j)∈Ω\nẐt ← Pr(Ẑt) (15)\nEquation (15) projects matrix Ẑt onto a cone of matrices of rank r. This entails performing SVD on Ẑt and retaining the top r singular vectors and singular values while discarding the rest. This is done in steps 4, 5 of Algorithm (1). As can be seen from the above equation we do not need to estimate derivative of ĝt−1. This, along with the convexity of the optimization problem in Equation (13) w.r.t. Z for a given Φ are two of the key advantages of using a calibrated loss function over the previously proposed squared loss minimization formulation.\nOptimization over Φ. In round t of algorithm (1), we have Ẑt after performing steps 4, 5. Differentiating the objective function in equation (13) w.r.t. Z, we get that the optimal Φ function should satisfy ∑\n(i,j)∈Ω\nĝt(Ẑti,j)−Xi,j = 0, (16)\nwhere Φ′ = ĝt. This provides us with a strategy to calculate ĝt. Let, X̂i,j def = ĝt(Ẑti,j). Then solving the optimization problem in equation (16) is equivalent to solving the following optimization problem.\nmin X̂ ∑ (i,j)∈Ω (X̂i,j −Xi,j)2\nsubject to: 0 ≤ −X̂i,j + X̂k,l ≤ L(Ẑtk,l − Ẑti,j) if Ẑti,j ≤ Ẑtk,l, (i, j) ∈ Ω, (k, l) ∈ Ω (17)\nwhere L is the Lipschitz constant of g?. We shall assume that L is known and does not need to be estimated. The gradient, w.r.t. X̂ , of the objective function, in equation (17), when set to zero is the same as Equation (16). The constraints enforce monotonicity of ĝt and the Lipschitz property of ĝt. The above optimization routine is exactly the LPAV algorithm. The solution X̂ obtained from solving the LPAV problem can be used to define ĝt on XΩ. These two steps are repeated for T iterations. After T iterations we have ĝT defined on ẐTΩ . In order to define ĝ\nT everywhere else on the real line we perform linear interpolation as shown in equation (6).\nAlgorithm 1 Monotonic Matrix Completion (MMC) Input: Parameters η > 0, T > 0, r, Data:XΩ,Ω Output: M̂ = ĝT (ẐT )\n1: Initialize Ẑ0 = mn|Ω|XΩ, where XΩ is the matrix X with zeros filled in at the unobserved locations. 2: Initialize ĝ0(z) = |Ω|mnz 3: for t = 1, . . . , T do 4: Ẑti,j ← Ẑ t−1 i,j − η(ĝt−1(Ẑ t−1 i,j )−Xi,j)1(i,j)∈Ω 5: Ẑt ← Pr(Ẑt) 6: Solve the optimization problem in (17) to get X̂ 7: Set ĝt(Ẑti,j) = X̂i,j for all (i, j) ∈ Ω. 8: end for 9: Obtain ĝT on the entire real line using linear interpolation shown in equation (6).\nLet us now explain our initialization procedure. Define XΩ def = ∑|Ω| j=1X ◦ ∆j , where each ∆j is a boolean mask with zeros everywhere and a 1 at an index corresponding to the index of an observed entry. A ◦ B is the Hadamard product, i.e. entry-wise product of matrices A,B. We have |Ω| such boolean masks each corresponding to an observed entry. We initialize Ẑ0Ω to mn |Ω|XΩ = mn |Ω| ∑|Ω| j=1X ◦∆j . Because each observed index is assumed to be sampled uniformly at random with replacement, our initialization is guaranteed to be an unbiased estimate of X ."
    }, {
      "heading" : "4 MSE Analysis of MMC",
      "text" : "We shall analyze our algorithm, MMC, for the case of T = 1, under the modeling assumption shown in Equations (4) and (3). Additionally, we will assume that the matrices Z? and M? are bounded entry-wise in absolute value by 1. When T = 1, the MMC algorithm estimates Ẑ, ĝ and M̂ as follows\nẐ = Pr ( mnXΩ |Ω| ) . (18)\nĝ is obtained by solving the LPAV problem from Equation (17) with Ẑ shown in Equation (18). This allows us to define M̂i,j = ĝ(Ẑi,j),∀i = [n], j = [m].\nDefine the mean squared error (MSE) of our estimate M̂ as\nMSE(M̂) = E  1 mn n∑ i=1 m∑ j=1 (M̂i,j −Mi,j)2  . (19)\nDenote by ||M || the spectral norm of a matrix M . We need the following additional technical assumptions:\nA1. ‖Z?‖ = O( √ n). A2. σr+1(X) = Õ( √ n) with probability at least 1 − δ, where Õ hides terms logarithmic in\n1/δ.\nZ? has entries bounded in absolute value by 1. This means that in the worst case, ||Z?|| = √ mn. Assumption A1 requires that the spectral norm of Z? is not very large. Assumption A2 is a weak assumption on the decay of the spectrum of M?. By assumption X = M? + N . Applying Weyl’s inequality we get σr+1(X) ≤ σr+1(M?) + σ1(N). Since N is a zero-mean noise matrix with independent bounded entries, N is a matrix with sub-Gaussian entries. This means that σ1(N) = Õ( √ n) with high probability. Hence, assumption A2 can be interpreted as imposing the condition σr+1(M ?) = O( √ n). This means that while M? could be full rank, the (r + 1)th singular value of M? cannot be too large.\nTheorem 1. Let µ1 def = E||N ||, µ2 def = E||N ||2. Let α = ||M? − Z?||. Then, under assumptions A1 and A2, the MSE of the estimator output by MMC with T = 1 is given by\nMSE(M̂) = O\n(√ r\nm +\n√ mn log(n)\n|Ω| +\nmn\n|Ω|3/2 +\n√ r\nm √ n\n( µ1 +\nµ2√ n ) +√\nrα\nm √ n\n( 1 +\nα√ n\n) + √ rmn log2(n)\n|Ω|2\n) .\n(20)\nwhere O(·) notation hides universal constants, and the Lipschitz constant L of g?. We would like to mention that the result derived for MMC-1 can be made to hold true for T > 1, by an additional large deviation argument. The proof of our theorem is available in the appendix.\nInterpretation of our results: Our upper bounds on the MSE of MMC depends on the quantity α = ||M?−Z?||, and µ1, µ2. Since matrixN has independent zero-mean entries which are bounded in absolute value by 1, N is a sub-Gaussian matrix with independent entries. For such matrices µ1 = O( √ n), µ2 = O(n) (see Theorem 5.39 in [26]). With these settings we can simplify the expression in Equation (20) to\nMSE(M̂) = Õ\n(√ r\nm +\n√ mn log(n)\n|Ω| +\nmn\n|Ω|3/2 +\n√ rα\nm √ n\n( 1 +\nα√ n\n) + √ rmn log2(n)\n|Ω|2\n) .\nA remarkable fact about our sample complexity results is that the sample complexity is independent of the rank of matrix M?, which could be large. Instead it depends on the rank of matrix Z? which we assume to be small. The dependence on M? is via the term α = ||M?−Z?||. From equation (4) it is evident that the best error guarantees are obtained when α = O( √ n). For such values of α equation (4) reduces to,\nMSE(M̂) = Õ\n(√ r\nm +\n√ mn log(n)\n|Ω| +\nmn\n|Ω|3/2 +\n√ mn\n|Ω| +\n√ rmn log2(n)\n|Ω|2\n) .\nThis result can be converted into a sample complexity bound as follows. If we are given |Ω| = Õ( ( mn )2/3 ), then MSE(M̂) ≤ √ r m + ."
    }, {
      "heading" : "5 Experimental results",
      "text" : "We compare the performance of MMC−1, MMC− c, MMC- LS, and nuclear norm based low-rank matrix completion (LRMC) [4] on various synthetic and real world datasets. The objective metric that we use to compare different algorithms is the root mean squared error (RMSE) of the algorithms on unobserved, test indices of the incomplete matrix."
    }, {
      "heading" : "5.1 Efficient implementation of MMC",
      "text" : "The MMC algorithm consists of three main steps. A gradient descent step, a projection step onto the set of rank r matrices, and a QP optimization step. On top of these one has to find out the correct values for the rank r, and the step size η used in step 4 of MMC. A straight forward implementation of the above three steps can be coupled with a grid search over r and η. However, such an implementation would be inefficient and not scalable beyond small matrices. Since r is assumed to\nbe small one needs to find just the top few singular vectors of the intermediate matrices. We use PROPACK 5 package for an efficient SVD implementation. Rather than search for r on a grid, we use an increasing rank procedure to estimate r. The increasing rank procedure starts at a small value for r, say rmin and increases the current estimate of r, by rinc, whenever there is not much progress in the iterates. Precisely, the current estimate of r is increased by rinc if\n1− ||PΩ(X̂ t −X)||F\n||PΩ(X̂t−1 −X)||F ≤ , (21)\nfor some small > 0. As we expect r to be small, our estimate for r is not allowed to grow beyond a certain rmax. The increasing rank procedure was inspired by the work of [15], where they demonstrated that such procedures are suitable for low-rank approximation problems.\nAn ADMM implementation for LPAV problem. The LPAV problem shown in Equation (17) is solved in each iteration of MMC. Hence, it is crucial that we have an efficient implementation of LPAV so that the overall algorithm is efficient. For ease of notation, we shall frame the LPAV problem as follows: Suppose we have a 1-dimensional regression problem with covariates z1 ≤ z2 ≤ . . . ≤ zf and the corresponding targets x1, x2, . . . xf in R. The LPAV routine solves the problem\nmin y∈Rf f∑ i=1 (yi − xi)2\nsubject to: 0 ≤ yi+1 − yi ≤ L(zi+1 − zi), for all i = 1, . . . , f − 1.\n(22)\nOne could transform the above optimization problem into a box-constrained convex QP, by rewriting the objective and the constraints using the transformation δi = yi+1 − yi. Box constrained QPs are well studied optimization problems and a plethora of efficient solvers exist. However, the above transformation destroys the simple least-squares structure of the objective, and in our experience the resulting box-constrained QP turned out to be harder to solve than the original optimization problem (22). Instead we use the Alternating Direction Method of Multipliers (ADMM) algorithm for our problem [27] which allows us to exploit the rich structure present in problem (22). We shall now explain ADMM updates as applied to problem (22). Let b be a vector in Rf , with the jth component being bj = L(zj+1 − zj). Let M1,M2 be two matrices in Rf−1×f , constructed as follows. The ith row of M1 has 1 in the ith column and −1 in the i + 1th column. The ith row of M2 has −1 in the ith column and 1 in the i+ 1th column. Rest of the entries in M1,M2 are zeros. Let M = ( M1 M2 ) be a matrix in R2p−2×p. Finally let b̄ = [ 0 b ] be a 2f −2 dimensional vector whose first f − 1 entries are 0, and the last f − 1 entries are the first f − 1 entries of the vector b. With these definitions, problem (22) can be reformulated as\nmin y∈Rf f∑ i=1 (yi − xi)2\nsubject to: My ≤ b̄.\n(23)\nIn order to derive efficient ADMM updates, we shall convert the inequality constraints to equality by introducing slack variables. This gets us the following reformulation\nmin ȳ∈R3f−2 f∑ i=1 (ȳi − xi)2\nsubject to: M̄ȳ = b̄ [0f×f , If×f ]ȳ ≥ 0\n(24)\nwhere M̄ = [M2p−2×p, I2f−2×2f−2]. Note that this problem has 3f − 2 variables in contrast to the f − 1 variables in Equation (23). The extra 2f − 1 variables correpsond to the slack variables introduced when converting the inequality constraints in (23) to equality constraints in (24). The ADMM algorithm provides an iterative procedure for solving convex optimization problems of the form\nmin ȳ,z f(ȳ) + g(z)\nsubject to: Aȳ +Bz = 0. (25)\n5Look at http://svt.stanford.edu/code.html for download instructions.\nWe can cast the optimization problem in Equation (24) in the above form by defining A = −B = I ,\nf(ȳ) =\n{∑f i=1(ȳi − xi)2 if M̄ȳ = b\n∞ otherwise (26)\nand\ng(z) = { 0 if [0f×f , If×f ]z ≥ 0 ∞ otherwise.\nThe ADMM algorithm involves iteratively updating ȳ, z and some additional variables until convergence. In our practical implementations we follow the advice as mentioned in [27] and set abs and rel to 10−2. Any value less than 10−2 did not yield much change in results.\nUpdating ȳ: In order to update ȳ iteratively we need to solve the following optimization problem. Given two vectors zk, uk, and γ > 0, we solve\nȳk+1 = arg min ȳ f∑ i=1 (ȳi − xi)2 + γ 2 ||ȳ + uk − zk||2\nsubject to: M̄ȳ = b̄.\n(27)\nThis is an equality constrained QP, which can be solved in closed form by using the KKT conditions. The solution is obtained by solving the following set of sparse linear equations.[\nP3f−2×3f−2 + γI3f−2×3f−2 M̄ >\nM̄ 02f−2×2f−2\n] [ ȳk+1\nν\n] = [ −(q + γ(uk − zk))\nb̄,\n] (28)\nwhere P, q are defined as follows\nP = 2\n[ If×f 0f×2f−2\n02f−2×f 02f−2×2f−2\n] , q = −2 [ x\n02p−2\n] (29)\nThe above system of linear equations is very large with 5p − 4 equations in 5p − 4 unknowns but very sparse with 7p − 6 non-zeros in the matrix on the LHS of Equation (28). Such large, sparse system of equations can be solved very efficiently, and in our numerical experiments we simply use the backslash operator in MATLAB to solve them.\nUpdates for z: The ADMM updates applied to z yield the following optimization problem\nzk+1 = arg min z∈R3p−2, ||z − (yk+1 + uk)||2.\nsubject to: zk ≥ 0 for k ≥ p+ 1 (30)\nThe solution to the above optimization problem is trivial and can be written in closed form as follows\nzk+1j =\n{ yk+1j + u k j if j = 1, . . . p\nmax{yk+1j + ukj , 0} if j ≥ p+ 1 (31)\nUpdates for u: The update for the intermediate variable u is given by the equation\nuk+1 = uk + ȳk+1 − zk+1. (32)\nHence, the ADMM algorithm for the LPAV routine requires iteratively updating ȳ, z, u until desired tolerance levels."
    }, {
      "heading" : "5.2 Synthetic experiments",
      "text" : "For our synthetic experiments we generated a random 30 × 20 matrix Z? of rank 5 by taking the product of two random Gaussian matrices of size n × r, and r ×m, with n = 30,m = 20, r = 5. The matrix M? was generated using the function, g?(M?i,j) = 1/(1 + exp(−cZ?i,j)), where c > 0. By increasing c, we increase the Lipschitz constant of the function g?, making the matrix completion task harder. For large enough c,Mi,j ≈ sgn(Zi,j). We consider the noiseless version of the problem whereX = M?. Each entry in the matrixX was sampled with probability p, and the sampled entries\nare observed. This makes E|Ω| = mnp. For our implementations we assume that r is unknown, and estimate it either (i) via the use of a dedicated validation set in the case of MMC − 1 or (ii) adaptively, where we progressively increase the estimate of our rank until a sufficient decrease in error over the training set is achieved [15]. For an implementation of the LRMC algorithm we used a standard off-the-shelf implementation from TFOCS [28]. In order to speed up the run time of MMC, we also keep track of the training set error, and terminate iterations if the relative residual on the training set goes below a certain threshold 6. In the appendix we provide a plot that demonstrates that, for MMC−c, the RMSE on the training dataset has a decreasing trend and reaches the required threshold in at most 50 iterations. Hence, we set T = 50. Figure (2) show the RMSE of each method for different values of p, c. As one can see from figure (2), the RMSE of all the methods improves for any given c as p increases. This is expected since as p increases E|Ω| = pmn also increases. As c increases, g? becomes steeper increasing the effective rank of X . This makes matrix completion task hard. For small p, such as p = 0.2, MMC − 1 is competitive with MMC − c and MMC−LS and is often the best. In fact for small p, irrespective of the value of c, LRMC is far inferior to other methods. For larger p, MMC− c works the best achieving smaller RMSE over other methods."
    }, {
      "heading" : "5.3 Experiments on real datasets",
      "text" : "We performed experimental comparisons on four real world datasets: paper recommendation, Jester3, ML-100k, Cameraman. The source of our datasets is listed in the appendix. All of the above datasets, except the Cameraman dataset, are ratings datasets, where users have rated a few of the several different items. For the Jester-3 dataset we used 5 randomly chosen ratings for each user for training, 5 randomly chosen rating for validation and the remaining for testing. ML-100k comes with its own training and testing dataset. We used 20% of the training data for validation. For the Cameraman and the paper recommendation datasets 20% of the data was used for training, 20% for validation and the rest for testing. The baseline algorithm chosen for low rank matrix completion is LMaFit-A [15] 7.\nFor each of the datasets we report the RMSE of MMC − 1, MMC − c, and LMaFit-A on the test sets. We excluded MMC-LS from these experiments because in all of our datasets the number of observed entries is a very small fraction of the total number of entries, and from our results on synthetic datasets we know that MMC− LS is not the best performing algorithm in such cases. Table 1 shows the RMSE over the test set of the different matrix completion methods. As we see the RMSE of MMC− c is the smallest of all the methods, surpassing LMaFit-A by a large margin."
    }, {
      "heading" : "6 Conclusions and future work",
      "text" : "We have investigated a new framework for high rank matrix completion problems called monotonic matrix completion. We proposed and studied an algorithm called MMC based on minimizing a calibrated loss function. In the future we would like to investigate if one could relax the technical assumptions involved in establishing our theoretical results."
    }, {
      "heading" : "A Error Analysis of Monotonic Matrix Completion",
      "text" : "We shall analyze our algorithm, MMC−c, for the case of T = 1. Since for T = 1, MMC−c and MMC−LS are the same, we shall used the word MMC to refer to both the algorithms when T = 1. For T = 1, we have\nẐ = Pr ( mnXΩ |Ω| ) (33)\nĝ = LPAV (ẐΩ, XΩ) (34)\nM̂i,j = ĝ(Ẑi,j),∀i = [m], j = [n], (35)\nFinally, define the mean squared error (MSE) of our estimate M̂ can be defined as\nMSE(M̂) = E\n[ 1\nmn n∑ i=1 m∑ j=1\n(M̂i,j −Mi,j)2 ] . (36)\nWe are interested in analyzing the MSE of M̂ output by MMC for T = 1. We shall make the following assumptions"
    }, {
      "heading" : "B MMC model and technical assumptions",
      "text" : "A1 ‖Z?‖ = O( √ n), i.e. the spectral norm of Z? is of the order of √ n.\nA2. σr+1(X) = O( √ n) with probability at least 1− δ.\nThe MMC model makes the following assumptions. These assumptions are the same as in the main paper. We enumerate it here for the sake of convenience.\nM1. X = M? +N .\nM2. EN = 0. M3. M?i,j = g\n?(Z?i,j) ∀i = [n], j = [m]. M4. Assume that n ≥ m, and rank(Z?) = r m. M5. Boundedness assumption: |Z?i,j | ≤ 1, |Xi,j | ≤ 1 for all i ∈ [n], j ∈ [m]. M6. g? : R→ R is monotonic and L-Lipschitz. M7. The set Ω is generated by sampling uniformly at random with replacement from the index set [n] ×\n[m].\nB.1 Notation\nAll of our matrices, unless explicitly stated, will be n×m with n ≥ m. ||A|| is the spectral norm of matrix A, and ||A||? is the nuclear norm of matrix A.\nB.2 Towards proof of Theorem (1)\nWe begin with the following technical lemma that will be used in the proof. Lemma 1. Let G = {g|g : [−W,W ]→ [−1, 1] is monotonic and 1-Lipschitz}.With probability at least 1− δ over the sample z1, . . . , zn, the following statement is true for all g ∈ G∣∣∣∣ 1n∑(g(zi)− yi)2 − E(g(z)− y)2 ∣∣∣∣ = Õ (√ W n ) (37)\nwhere Õ hides logarithmic dependence on n,W, 1/δ.\nProof. Let R̂n(G) be the empirical Rademacher complexity of function class G, and let N∞( ,G) be the L∞ covering number of the function clas G. From [11, Lemma 6] we know that\nN∞( ,G) ≤ 1 2 2W . (38)\nThe above covering number allows us to bound the empirical Rademacher complexity of the function class G via Dudley’s entropy bound. Using [29, Lemma A.3], and the fact that N∞( ,G) ≥ N2( ,G, z1, . . . , zn) we get\nR̂n(G) ≤ inf α≥0 4α+ 10 ∫ 1 α √ logN∞( ,G) n d (39)\n≤ 4α+ 10 ∫ 1 α\n√ 2W\nlog( 1 )\nn d (40) ≤ 4α+ 10 √ 2W\nn ∫ 1 α 1 d (41)\n≤ 10 √ 2W\nn log\n( 4e\n10\n√ n\n2W\n) . (42)\nUsing a uniform convergence bound in terms of the Rademacher complexity of the function class [30, Theorem 8] we get the desired result.\nLemma 2. Let 2 = E[ 1mn ∑ i,j(Ẑi,j − Z ? i,j) 2]. Then, under assumptions A1-A8, we have\nMSE(M̂) ≤ O\n(√ mn log(n) |Ω| + √ n |Ω| + mn |Ω|3/2 + √ mn |Ω| + 2 + √ 2 )\nProof.\n1\nmn E [∑ i,j (M̂i,j −M?i,j)2 ] = 1 mn E [∑ i,j (ĝ(Ẑi,j)− g?(Z?i,j))2 ]\n(43)\n= 1\nmn E [∑ i,j ( ĝ(Ẑi,j)− g?(Ẑi,j) + g?(Ẑi,j)− g?(Z?i,j) )2] (44)\n≤ 2E\n[ 1\nmn ∑ i,j ( ĝ(Ẑi,j)− g?(Ẑi,j) )2] ︸ ︷︷ ︸\nT1\n+2E [ 1\nmn\n( g?(Ẑi,j)− g?(Z?i,j) )2] ︸ ︷︷ ︸\nT2\n(45)\n= 2T1 + 2T2. (46)\nWe shall bound T2 in terms of 2.\nBounding T2:\nT2 = 1 mn E ∑ i,j (g?(Ẑi,j)− g?(Z?i,j))2 (47)\n(a) ≤ 1 mn E ∑ i,j (Ẑi,j − Z?i,j)2 (48)\ndef = 2 (49)\nwhere inequality (a) follows from the fact that g? is 1-Lipschitz. Next we shall bound T1 in terms of 2 and other terms.\nBounding T1:\nE\n[ 1\nmn ∑ i,j ( ĝ(Ẑi,j)− g?(Ẑi,j) )2] = E [ 1 |Ω| ∑ Ω ( ĝ(Ẑi,j)− g?(Ẑi,j) )2] ︸ ︷︷ ︸\nT1,1\n+\nE\n[ 1\nmn ∑ i,j ( ĝ(Ẑi,j)− g?(Ẑi,j) )2] − E [ 1 |Ω| ∑ Ω ( ĝ(Ẑi,j)− g?(Ẑi,j) )2] ︸ ︷︷ ︸\n∆1\n(50)\nNext we shall bound T1,1 as follows. Let G = {g : R→ R|g is a monotonic and 1-Lipschitz function }. Since ĝ, g? by definition belong to G, and since ĝ solves the optimization problem\nĝ = arg min ∑ Ω (g(Ẑi,j)−Xi,j)2, (51)\nhence via the generalized Pythagorean inequality [31] we have∑ Ω (ĝ(Ẑi,j)−Xi,j)2 + ∑ Ω (ĝ(Ẑi,j)− g?(Ẑi,j))2 ≤ ∑ Ω (Xi,j − g?(Ẑi,j))2. (52)\nUsing Equation (52) we can bound T1,1 as follows\nT1,1 = E\n[ 1\n|Ω| ∑ Ω ( ĝ(Ẑi,j)− g?(Ẑi,j)\n)2]\n≤ E\n[ 1\n|Ω| ∑ Ω (Xi,j − g?(Ẑi,j))2 − 1 |Ω| ∑ Ω ( Xi,j − ĝ(Ẑi,j)\n)2]\n= E\n[ 1\n|Ω| ∑ Ω\n(Xi,j − g?(Ẑi,j))2 ] − E [ 1\n|Ω| ∑ Ω\n(Xi,j − g?(Z?i,j))2 ]\n︸ ︷︷ ︸ I1\n+\nE\n[ 1\nmn ∑ i,j\n(Xi,j − g?(Z?i,j))2 ] − E [ 1\nmn ∑ i,j\n(Xi,j − ĝ(Ẑi,j))2 ]\n︸ ︷︷ ︸ I2\n+\nE\n[ 1\n|Ω| ∑ Ω\n(Xi,j − g?(Z?i,j))2 ] − E [ 1\nmn ∑ i,j\n(Xi,j − g?(Z?i,j))2 ]\n︸ ︷︷ ︸ I3\n+\nE\n[ 1\nmn ∑ i,j\n(Xi,j − ĝ(Ẑi,j))2 ] − E [ 1\n|Ω| ∑ Ω\n(Xi,j − ĝ(Ẑi,j))2 ]\n︸ ︷︷ ︸ I4\n(53)\nWe shall look at each of the terms T2, T3, T4 and bound them separately. From assumption A1 we know that g?(Z?i,j) is the best estimator of Xi,j in mean squared. Hence, I2 ≤ 0. We next bound I1, I3, I4. |Z?|∞ ≤ 1, and |X?|∞ ≤ 1, hence |Xi,j −g?(Z?i,j)| ≤ 2. If we call ∆3 the random variable whose expectation is I3, then ∆3 ≤ 4 surely. Moreover we can apply lemma (1) to guarantee that ∆3 ≤ O (√ log(|Ω|/δ) |Ω| ) with probability at least 1− δ. Choose δ = 1√ |Ω| . We then have\nI3 = E∆3 ≤ 4δ + (1− δ)O (√ log(|Ω|/δ) |Ω| ) = O (√ log(|Ω|) |Ω| ) . (54)\nNext, we bound I4. This needs a slightly careful treatment, since Ẑi,j is random. Let A = 1p|Ω|X ◦ ∆. Let A = ∑ σiuiv > i be the SVD of A with σ1 ≥ σ2 ≥ · · ·σm. By definition Ẑ = Pr(A). Hence, A − Z =\n∑ i≥r+1 σiuiv > i . This means that\n|A− Ẑ|∞ ≤ ||A− Ẑ|| = || ∑ i≥r+1 σiuiv > i ||\n= σr+1\n≤ σ1(A−X) + σr+1(X) (55)\nWe shall now use the above bound on Ẑ −A to obtain upper bound on |Ẑ|∞ as follows\n|Ẑ|∞ (a) ≤ |Ẑ −A|∞ + |A−X|∞ + |X|∞ (56) (b) ≤ ||A−X||+ |X|∞ + ||A−X||+ σr+1(X) (57) = 2||A−X||+ |X|∞ + σr+1(X) (58) = 2||A−X||+ 1 + σr+1(X) (59) (c) ≤ 2||A−X||+ 1 + σr+1(X) (60)\nTo obtain inequality (a) we used the triangle inequality, and to obtain inequality (b) we used Equation (55). Now, consider the event\nE1 = ||A−X|| ≤ 2mn log ( m+n δ ) 3|Ω| + √ 2 log(m+n δ )mn |Ω|  . (61) From Lemma 5 we know that conditioned onX , P(E1) ≥ 1−δ over the randomness in Ω. Using equation (60) we get that on event E1\n|Ẑ|∞ = O ( σr+1(X) + mn log(m+n δ )\n|Ω| +\n√ mn log((m+ n)/δ)\n3|Ω|\n) def = b (62)\nNow let I ′4 be the term argument to the expectation operator in I4. Now let us define another event\nE11 = { I ′4 ≤ √ b log((m+ n)/δ)\n|Ω|\n} (63)\nUsing lemma (1), we get that P(E11) ≥ 1− δ over random choice of Ω. Notice that I ′4 ≤ 4 surely. We are now ready to calculate I4 as follows\nI4 = EXEΩ|XI ′4 (64) ≤ EXP(E1)EΩ|X,E1I ′ 4 + 4P(Ē1) (65)\n≤ EXP(E1)(P(E11)I ′4 + 4P(Ē11)) + 4P(Ē1) (66)\n≤ 8δ + EX\n√ b log((m+ n)/δ)\n|Ω| (67)\nSubstituting the value of b, and using δ = 1|Ω| , and using the assumption that σr+1(X) ≤ O( √ n) with high probability, we get that\nI4 = EXEΩ|XI ′4 (68)\n≤ 8δ + EX √√√√ 1 |Ω|O ( σr+1(X) + mn log((m+ n)|Ω|) |Ω| + √ mn log((m+ n)|Ω|) 3|Ω| ) (69)\n≤ O (√ mn\n|Ω|2 log 2 ((m+ n)|Ω|)\n) (70)\nNotice that ∆1 uses ĝ − g? which is a 2 Lipchitz function. By perfoming a similar analysis as in I4 it is easy to show that ∆1 = O(I4).\nBounding I1.\nI1 = E\n[ 1\n|Ω| ∑ Ω (Xi,j − g?(Ẑi,j))2 − 1 |Ω| ∑ Ω\n(Xi,j − g?(Z?i,j))2 ]\n(71)\n= E\n[ 1\n|Ω| ∑ Ω (g?(Z?i,j)− g?(Ẑi,j))(2Xi,j − g?(Ẑi,j)− g?(Z?i,j))\n] (72)\n(a) ≤ 4E 1|Ω| |g ?(Z?i,j)− g?(Ẑi,j)‖ (73)\n(b) ≤ 4E 1|Ω| ∑ Ω |Z?i,j − Ẑi,j | (74)\n= 4E 1 mn ∑ i,j |Z?i,j − Ẑi,j |+ 4 ( E 1|Ω| ∑ Ω |Z?i,j − Ẑi,j | − E 1 mn ∑ i,j |Z?i,j − Ẑi,j | ) ︸ ︷︷ ︸\n∆5\n(75)\n(c) ≤ 4E 1\nmn ∑ i,j |Z?i,j − Ẑi,j |+ 4∆5 (76)\n(d) ≤ 4 √\nE 1 mn ∑ i,j |Z?i,j − Ẑi,j |2 + 4∆5 = 4( √ 2 + ∆5) (77)\nwhere, to get inequality (a) we used the fact that |Xi,j | ≤ 1 and |g?| ≤ 1. To get inequality (b) we used the fact that g? is 1 Lipschitz. To get inequality (c) we used concentration of measure. Finally, to get inequality (d) we used Jensen’s inequality to bound E|x| ≤ √ Ex2. Our next step is to bound ∆5.\nBounding ∆5: The idea is to consider the event E1 as done during bounding the term I4. Once again we shall consider the event\nE1 = ||A−X|| ≤ 2mn log ( m+n δ ) 3|Ω| + √ 2 log(m+n δ )mn |Ω|  . (78) Similar to arguments there, we know from Equation (62) that on event E1\n|Ẑ|∞ = O ( σr+1(X) + mn log(m+n|Ω| )\n|Ω| +\n√ mn log((m+ n)/δ)\n3|Ω|\n) def = b\nConsider the collection of random variables ξ1, . . . , ξ|Ω|, where each ξk takes the value Z?i,j − Ẑi,j , where (i, j) is chosen u.a.r. with replacement from [n] × [m]. It is easy to see that each of ξk ∈ [0, b + 1] on E1. Applying Hoeffding inequality we get on E1 with probability at least 1 − δ over the random choice of Ω, and on event E1\n1 |Ω| ∑ Ω |Z?i,j − Ẑi,j | − ∑ i,j |Z?i,j − Ẑi,j | ≤\n√ (b+ 1)2\n2|Ω| log(1/δ) (79)\nBy arguments similar to the ones used in establishing bounds for I4, we get ∆5 ≤ O ( log ((m+ n)|Ω|) (√ n\n|Ω| + mn |Ω|3/2 +\n√ mn\n|Ω|\n)) . (80)\nThis concludes our first set of calculations. With this we have\nMSE(M̂) = O\n(√ mn log(n) |Ω| + √ n |Ω| + mn |Ω|3/2 + √ mn |Ω| + 2 + √ 2 ) (81)\nThe rest of the proof establishes upper bounds on 2.\nB.3 Bounding 2.\nIn order to establish upper bound on 2 we first need the following projection lemma. This lemma is similar in spirit to a lemma of S.Chatterjee [32, Lemma 3.5]. Before we establish this lemma, we would like to clarify the notation that we use. Given a matrix A ∈ Rn×m, with m ≤ n, denote by σ1(A) ≥ σ2(A) ≥ . . . ≥ σm(A) the singular values of A in decreasing order.\nLemma 3. Let A = ∑m i=1 σixiy > i be the SVD of a rectangular matrix A ∈ Rm×n, with the singular values σ1 ≥ σ2 . . . ≥ σm arranged in decreasing order. Let B be an unknown m× n matrix. Given 1 ≤ r ≤ m, let B̂ def = Pr(A) def = ∑r i=1 σixiy > i be the projection estimator of B. Then,\n||Pr(A)−B||F ≤ √ ||B||?(σr+1 + ||A−B||) + 2 √ 2r(σr+1 + ||A−B||). (82)\nProof. Let B = ∑m i=1 τiuiv > i be the SVD of B with τ1 ≥ τ2 ≥ . . . τm.\n||B̂ −B||F ≤ ||B̂ −G||F + ||G−B||F , (83)\nand ||G−B||2F = || ∑ i≥r+1 τiuiv > i ||2F = ∑ i≥r+1 τ2i ≤ ( max i≥r+1 τi)||B||?. (84)\nLet δ1 ≥ δ2 ≥ . . . be the singular values of A−B in decreasing order. Then from Weyl’s inequality we know that\nmax i |σi − τi| ≤ max i δi = ||A−B||. (85)\nHence, for i ≥ r + 1, τi ≤ σi + ||A−B|| ≤ σr+1(A) + ||A−B||. (86)\nThis allows us to conclude that maxi≥r+1 τi ≤ σr+1(A) + ||A−B||. Combined with Equation (84) we get\n||G−B||2F ≤ ||B||?(σr+1(A) + ||A−B||). (87)\nNext, we shall upper bound the quantity ||B̂ − G||F . By construction, both B̂ and G are rank r matrices and hence B̂ −G is a rank 2r matrix. This allows us to control the Frobenius norm of B̂ −G via its spectral norm as follows\n||B̂ −G||F ≤ √ 2r||B̂ −G|| (88)\nTo bound ||B̂ −G|| consider the following decomposition\n||B̂ −G|| ≤ ||B̂ −A||+ ||A−B||+ ||B −G||. (89)\nWe have ||B̂ −A|| = || ∑ i σixiy > i || ≤ σr+1. (90)\n||B −G|| = || ∑ i≥r+1 τiuiv > i || = τr+1 (a) ≤ σr+1 + ||A−B|| (91)\nwhere to get inequality (a) we used Equation (86). Combining Equations (89), (90), (91) we get\n||B̂ −G|| ≤ σr+1 + ||A−B||+ σr+1 + ||A−B|| = 2(σr+1 + ||A−B||) (92)\nand using Equation (88) we get\n||B̂ −G||F ≤ 2 √ 2r(σr+1 + ||A−B||) (93)\nFinally using Equation (87) and Equation (93) we get\n||B̂ −B||F ≤ 2 √ 2r(σr+1 + ||A−B||) + √ ||B||?(σr+1 + ||A−B||). (94)\nIn order to obtain an upper bound on 2 we shall use Lemma (3) with the following choices for matrices A,B: A def = 1\np|Ω|X ◦∆Ω, B def = Z?, Ẑ def = Pr(A).. We then get\n||Ẑ − Z?||F ≤ √ ||Z?||?(σr+1 + ||A− Z?||) + 2 √ 2r(σr+1 + ||A− Z?||). (95)\nSince Z? is of rank r, we have ||Z?||? ≤ r||Z?||. From triangle inequality ||A|| ≤ ||A−Z?||+ ||Z?||. These facts coupled with the fact that σr+1 ≤ σ1 allows us to obtain\nE||Ẑ − Z?||2F ≤ r||Z?||(2E||A− Z?||+ ||Z?||) + 8r(4E||A− Z?||2 + ||Z?||2). (96)\nNotice that 2 is a scaled version of E||Ẑ − Z?||2F . Let,\nβ1 def = E||A−X|| (97)\nβ2 def = E||A−X||2. (98)\nUsing the above definitions, Equation (96), the triangle inequality ||A−Z?|| ≤ ||A−X||+ ||X−Z?||, along with the elementary fact that (a+ b)2 ≤ 2a2 + 2b2, we obtain\nE||Ẑ − Z?||2F ≤ r||Z?||(2β1 + 2E||X − Z?||+ ||Z?||) + 8r(8β2 + 8E||X − Z?||2 + ||Z?||2) (99) = r||Z?||(2E||X − Z?||+ ||Z?||) + 8r(8E||X − Z?||2 + ||Z?||2) + r(2β1 + 64β2).\n(100)\nBounding β1, β2. In order to bound β1, β2 we need upper bounds on spectral norm of sums of random matrices. Towards this, the following Bernstein inequality is useful\nTheorem 2 (Bernstein’s inequality). Let S1, . . . Sk be independent, centered random matrices with common dimension n×m, and assume that each one of them is bounded\n||Sj || ≤ L for each j ≥ 1. (101)\nLet M = ∑k j=1 Sj , and let ν(M) denote the matrix variance statistic of the sum\nν(M) = max { || k∑ j=1 ESjS>j ||, || k∑ j=1 ES>j Sj || } . (102)\nThen\n1.\nP(||M || ≥ t) ≤ (m+ n) exp (\n−t2/2 ν(M) + Lt/3\n) , (103)\nFurthermore\n2.\nEZ ≤ √ 2ν(M) log(m+ n) + 1\n3 L log(m+ n). (104)\nWe shall bound β1 using part (ii) of Bernstein’s inequality, and β2 using part (ii) of Bernstein’s inequality. The next two lemma’s provide necessary material for bounding β1, β2.\nProposition 1. Let ∆ be a random mask of size n ×m, where a random location is chosen and set to 1, and rest of the entries are set to 0. Let X be a matrix of size n ×m with entries bounded in absolute value by 1. Define S = 1\np X ◦∆−X . Let p = 1 mn . Then,\n1. ||S|| ≤ ||X||+ 1 p\n2. ES>S = ESS> = X ◦X −XX>\nProof.\n||S|| = ||1 p X ◦∆−X|| ≤ ||X||+ ||1 p X ◦∆|| (a) ≤ ||X||+ 1 p . (105)\nIn the above set of inequalities in order to derive (a) we used the fact that X ◦ ∆ is an n ×m matrix with a single non-zero entry bounded in absolute value by 1. Hence the spectral norm of this matrix will be bounded by 1. To derive the second part of the proposition we proceed as follows\nESS> = E(1 p X ◦∆−X)(1 p X ◦∆−X)> = E[ 1 p2 (X ◦∆)(X ◦∆)> − 1 p (X ◦∆)X> − 1 p X(X ◦∆)> +XX>].\n(106)\nVia elementary calculations, it is easy to verify that E [ 1\np2 (X ◦∆)(X ◦∆)>\n] = X ◦X (107)\nE [ 1\np X(X ◦∆)>\n] = E [ 1\np (X ◦∆)X>\n] = XX>. (108)\nThese identities allow us to conclude part (ii) of this proposition.\nWe are now ready to bound the quantities β1, β2\nLemma 4. Let p = 1 mn . Then,\nβ1 = E ∥∥∥∥ 1p|Ω|X ◦∆Ω −X ∥∥∥∥ ≤ √ 2 log(m+ n)||X ◦X −XX>|| |Ω| + log(m+ n)(p||X||+ 1) 3p|Ω| . (109)\nProof.\n∥∥∥∥ 1p|Ω|X ◦∆Ω −X ∥∥∥∥ = 1|Ω| ∥∥∥∥∥∥∥ |Ω|∑ j=1 (X ◦∆j −X)︸ ︷︷ ︸ Sj ∥∥∥∥∥∥∥ (110) Here ∆1, . . . ,∆Ω are random i.i.d. boolean masks with each of them having exactly one non-zero, whose location is chosen uniformly at random from [n] × [m]. For this reason the matrices S1, . . . , S|Ω| are i.i.d. matrices. It is easy to see that ESj = 0 for each j ≥ 1. Applying Bernstein’s inequality (Theorem (2)) and using Proposition (1) to bound the necessary quantities we get that\nE ∥∥∥∥ 1p|Ω|X ◦∆Ω −X ∥∥∥∥ = 1|Ω| [√ 2 log(m+ n)|Ω|||X ◦X −XX>||+ log(m+ n) 3 (||X||+ 1 p ) ] (111)\n=\n√ 2 log(m+ n)||X ◦X −XX>||\n|Ω| + log(m+ n)(p||X||+ 1) 3p|Ω| (112)\nNext we bound β2.\nLemma 5. Let p = 1 mn . Then,\nβ2 = E ∥∥∥∥ 1p|Ω|X ◦∆Ω −X ∥∥∥∥2 ≤ 1 + (20mn log(n)3|Ω| )2 + 10 log(n) |Ω| ||X ◦X −XX >||. (113)\nProof. Using part (i) of Bernstein’s inequality we get that, for any δ > 0, with probability at least 1− δ,\n‖A−X‖ ≤ 2 log\n( m+n δ ) 3|Ω| ( ||X||+ 1 p ) + √ 2 log(m+n δ )||X ◦X −XX>|| |Ω| . (114)\nWorst case upper bound on ‖A−X‖ can be derived as follows\n‖A−X‖ = || 1 p|Ω|X ◦∆Ω −X|| (115)\n≤ 1 p|Ω| ||X ◦∆Ω||+ ||X|| (116)\n≤ 1 p|Ω| |Ω|∑ j=1 ||X ◦∆j ||+ ||X|| (117)\n≤ 1 p + ||X||. (118)\nUsing equations (114) and (115) we get\nE||A−X||2 ≤ (1−δ) 2 log (m+nδ ) 3|Ω| ( ||X||+ 1 p ) + √ 2 log(m+n δ )||X ◦X −XX>|| |Ω| 2+δ(1 p + ||X|| )2\n(119) Since each element of X is bounded by 1 in magnitude, we get that ||X|| ≤ √ mn. Now, replace p = 1\nmn\nand choose δ = 1 (mn+ √ mn)2 . Using the inequality (a+ b)2 < 2a2 + 2b2 and over-approximating we get the desired result.\nFinal bound on 2. We are now ready to establish a bound on 2. In the next bound we shall no longer keep track of explicit constants. Instead in the following calculations we shall use a universal constant C > 0 whose value can change from one line to another.\nLemma 6. Let µ1 = E||N ||, µ2 = E||N ||2. Then, for some universal constant C > 0 we have 2 ≤ O ( r\nm √ n\n(||M? − Z?||+ µ1) + r||M? − Z?||2 mn + rµ2 mn + r m + rmn log2(n) |Ω|2\n) (120)\nProof. From Equation (99) we have\n2 ≤ r||Z?||(2E||X − Z?||+ ||Z?||) + 8r(8E||X − Z?||2 + ||Z?||2) + r(2β1 + 64β2). (121)\nNow, using Lemma (4) and (5) to bound β1, β2, we get\n2 ≤ Cr mn E [ ||Z?|| ||X − Z?||+ ||X − Z?||2 + ||Z?||2 +\n√ log(n)||X ◦X −XX>||\n|Ω| +\nlog(n) 3|Ω| (||X||+mn) + 1 + m2n2 log2(n) |Ω|2 + log(n) |Ω| ||X ◦X −XX >|| ] .\n(122)\nIn the above expectation the expectation is being taken w.r.t. the randomness in X due to additive noise of our model. We shall now compute the remaining expectations. For notational convenience, define µ1 = E||N ||, and µ2 = E||N ||2. Using the fact that X = M? +N , we get\nE‖X ◦X −XX>‖ ≤ E||X ◦X‖+ E||XX>|| (123) (a) ≤ E||X||2 + E||(M? +N)(M? +N)>|| (124) (b) ≤ E[||M?||2 + ||N ||2 + 2||M?|| ||N ||+ ||M?(M?)>||+M?N> +N(M?)> +NN>]\n(125)\n= 2||M?||2 + 2µ2 + 4||M?||µ1 (126)\nwhere to obtain inequality (a) we used the fact that ||A ◦ B|| ≤ ||A||||B|| [33, Problem 1.6.13, page 23]. To obtain inequality (b) we used sub-additivity of norms, and the fact that spectral norm is sub-multiplicative. By Jensen’s inequality we get\nE √ ‖X ◦X −XX>‖ ≤ √ E‖X ◦X −XX>‖ ≤ √ 2||M?||2 + 2µ2 + 4µ1||M?|| (127)\nFinally using the sub-additivity of norms we get that\nE||X − Z?||2 = E||M? +N − Z?||2 ≤ 2||M? − Z?||2 + 2E||N ||2 = 2||M? − Z?||2 + 2µ2 (128) E||X − Z?|| = E||M? +N − Z?|| ≤ E||M? − Z?||+ E||N || = E||M? − Z?||+ µ1 (129)\nNow, putting together Equations (122), (123), (127), (128), and substituting the worst case bound ||M?|| = C √ mn, we get\n2 ≤ C [ r mn ||Z?|| (||M? − Z?||+ µ1) + r mn ||M? − Z?||2 + r mn (µ2 + ||Z?||2)+\nr\nmn\n√ log(n)\n|Ω| ( mn+ µ1 √ mn+ µ2 ) + rmn log2(n) |Ω|2 + r log(n) mn|Ω| (mn+ µ2 + µ1 √ mn) ] . (130)\nWe can further simplify the above expression, by noting that the entries of N are bounded by 1, and hence µ1 = O( √ mn), µ2 = O(mn). Note that in reality µ1, µ2 are much smaller, and one could lose a lot of information by considering their worst case values. However, in order to simplify the above bound for 2 and make it interpretable, we shall selectively replace µ1, µ2 by √ mn,mn respectively, This allows us to gauge which terms are lower order terms and drop them. This gets us\n2 ≤ O ( r\nm √ n\n(||M? − Z?||+ µ1) + r||M? − Z?||2 mn + rµ2 mn + r m + rmn log2(n) |Ω|2\n) (131)\nC Proof of Theorem (1)\nFrom Lemma (2) we have\nMSE(M̂) ≤ O\n(√ mn log(n) |Ω| + √ n |Ω| + mn |Ω|3/2 + √ mn |Ω| + 2 + √ 2 )\nFrom Lemma (6) we have 2 ≤ O ( r\nm √ n\n(||M? − Z?||+ µ1) + r||M? − Z?||2 mn + rµ2 mn + r m + rmn log2(n) |Ω|2\n) (132)\nPutting the above two equations together we get\nMSE(M̂) = O (√ r\nm +\n√ mn log(n)\n|Ω| + mn |Ω|3/2 +\n√ mn\n|Ω| +\n√ r\nm √ n\n( µ1 +\nµ2√ n ) +√\nrα\nm √ n\n( 1 +\nα√ n\n) + √ rmn log2(n) |Ω|2 ) (133)"
    }, {
      "heading" : "D Source for datasets",
      "text" : "Here is where one can download the real world datasets on which all of our experiments were performed.\n1. Paper recommendation dataset:http://www.comp.nus.edu.sg/˜sugiyama/ SchPaperRecData.html.\n2. Jester dataset: http://goldberg.berkeley.edu/jester-data/.\n3. Movie lens dataset: http://grouplens.org/datasets/movielens/\n4. Cameraman dataset: http://www.utdallas.edu/˜cxc123730/mh_bcs_spl.html"
    }, {
      "heading" : "E RMSE plots with iterations",
      "text" : "In Figure (3) we show how the RMSE of MMC−c algorithm changes with iterations. These plots were made on the synthetic datasets that were used in our experiments. The value of p was set to 0.35. As one can see, on an average, there is a decreasing trend in the RMSE. This decrease is almost linear for small values of c and sub-linear for larger values of c."
    } ],
    "references" : [ {
      "title" : "Recommender systems",
      "author" : [ "Prem Melville", "Vikas Sindhwani" ],
      "venue" : "In Encyclopedia of machine learning. Springer,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2010
    }, {
      "title" : "Graph realization and low-rank matrix completion",
      "author" : [ "Mihai Cucuringu" ],
      "venue" : "PhD thesis, Princeton University,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2012
    }, {
      "title" : "A simpler approach to matrix completion",
      "author" : [ "Benjamin Recht" ],
      "venue" : "JMLR, 12:3413–3430,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2011
    }, {
      "title" : "Exact matrix completion via convex optimization. FOCM",
      "author" : [ "Emmanuel J Candès", "Benjamin Recht" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2009
    }, {
      "title" : "Matrix completion with noise",
      "author" : [ "Emmanuel J Candes", "Yaniv Plan" ],
      "venue" : "Proceedings of the IEEE,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2010
    }, {
      "title" : "Restricted strong convexity and weighted matrix completion: Optimal bounds with noise",
      "author" : [ "Sahand Negahban", "Martin J Wainwright" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2012
    }, {
      "title" : "Matrix completion from a few entries",
      "author" : [ "Raghunandan H Keshavan", "Andrea Montanari", "Sewoong Oh" ],
      "venue" : "Information Theory, IEEE Transactions on,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2010
    }, {
      "title" : "Recovering low-rank matrices from few coefficients in any basis",
      "author" : [ "David Gross" ],
      "venue" : "Information Theory, IEEE Transactions on,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2011
    }, {
      "title" : "Convex optimization & Euclidean distance geometry",
      "author" : [ "Jon Dattorro" ],
      "venue" : "Lulu. com,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2010
    }, {
      "title" : "The isotron algorithm: High-dimensional isotonic regression",
      "author" : [ "Adam Tauman Kalai", "Ravi Sastry" ],
      "venue" : "In COLT,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2009
    }, {
      "title" : "Efficient learning of generalized linear and single index models with isotonic regression",
      "author" : [ "Sham M Kakade", "Varun Kanade", "Ohad Shamir", "Adam Kalai" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2011
    }, {
      "title" : "Low-rank matrix completion by riemannian optimization",
      "author" : [ "Bart Vandereycken" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2013
    }, {
      "title" : "Riemannian pursuit for big matrix recovery",
      "author" : [ "Mingkui Tan", "Ivor W Tsang", "Li Wang", "Bart Vandereycken", "Sinno J Pan" ],
      "venue" : "In ICML,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2014
    }, {
      "title" : "Rank-one matrix pursuit for matrix completion",
      "author" : [ "Zheng Wang", "Ming-Jun Lai", "Zhaosong Lu", "Wei Fan", "Hasan Davulcu", "Jieping Ye" ],
      "venue" : "In ICML,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2014
    }, {
      "title" : "Solving a low-rank factorization model for matrix completion by a nonlinear successive over-relaxation algorithm",
      "author" : [ "Zaiwen Wen", "Wotao Yin", "Yin Zhang" ],
      "venue" : "Mathematical Programming Computation,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2012
    }, {
      "title" : "High-rank matrix completion",
      "author" : [ "Brian Eriksson", "Laura Balzano", "Robert Nowak" ],
      "venue" : "In AISTATS,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2012
    }, {
      "title" : "Sparse subspace clustering with missing entries",
      "author" : [ "Congyuan Yang", "Daniel Robinson", "Rene Vidal" ],
      "venue" : "In ICML,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2015
    }, {
      "title" : "A geometric analysis of subspace clustering with outliers",
      "author" : [ "Mahdi Soltanolkotabi", "Emmanuel J Candes" ],
      "venue" : "The Annals of Statistics,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2012
    }, {
      "title" : "Sparse subspace clustering: Algorithm, theory, and applications",
      "author" : [ "Ehsan Elhamifar", "Rene Vidal" ],
      "venue" : null,
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2013
    }, {
      "title" : "Completion of high-rank ultrametric matrices using selective entries",
      "author" : [ "Aarti Singh", "Akshay Krishnamurthy", "Sivaraman Balakrishnan", "Min Xu" ],
      "venue" : "In SPCOM,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2012
    }, {
      "title" : "Retargeted matrix factorization for collaborative filtering",
      "author" : [ "Oluwasanmi Koyejo", "Sreangsu Acharyya", "Joydeep Ghosh" ],
      "venue" : "In Proceedings of the 7th ACM conference on Recommender systems,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2013
    }, {
      "title" : "1-bit matrix completion",
      "author" : [ "Mark A Davenport", "Yaniv Plan", "Ewout van den Berg", "Mary Wootters" ],
      "venue" : "Information and Inference,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2014
    }, {
      "title" : "Semiparametric least squares (sls) and weighted sls estimation of single-index models",
      "author" : [ "Hidehiko Ichimura" ],
      "venue" : "Journal of Econometrics,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1993
    }, {
      "title" : "Direct semiparametric estimation of single-index models with discrete covariates",
      "author" : [ "Joel L Horowitz", "Wolfgang Härdle" ],
      "venue" : "Journal of the American Statistical Association,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1996
    }, {
      "title" : "Least squares revisited: Scalable approaches for multi-class prediction",
      "author" : [ "Alekh Agarwal", "Sham Kakade", "Nikos Karampatziakis", "Le Song", "Gregory Valiant" ],
      "venue" : "In ICML,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2014
    }, {
      "title" : "Introduction to the non-asymptotic analysis of random matrices",
      "author" : [ "Roman Vershynin" ],
      "venue" : "arXiv preprint arXiv:1011.3027,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2010
    }, {
      "title" : "Distributed optimization and statistical learning via the alternating direction method of multipliers",
      "author" : [ "Stephen Boyd", "Neal Parikh", "Eric Chu", "Borja Peleato", "Jonathan Eckstein" ],
      "venue" : "Foundations and Trends R  © in Machine Learning,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2011
    }, {
      "title" : "Tfocs: Flexible first-order methods for rank minimization",
      "author" : [ "Stephen Becker", "E Candes", "M Grant" ],
      "venue" : "In Low-rank Matrix Optimization Symposium, SIAM Conference on Optimization,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2011
    }, {
      "title" : "Smoothness, low noise and fast rates",
      "author" : [ "Nathan Srebro", "Karthik Sridharan", "Ambuj Tewari" ],
      "venue" : "In Advances in neural information processing systems,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2010
    }, {
      "title" : "Rademacher and gaussian complexities: Risk bounds and structural results",
      "author" : [ "Peter L Bartlett", "Shahar Mendelson" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2003
    }, {
      "title" : "Prediction, learning, and games",
      "author" : [ "N. Cesa-Bianchi", "G. Lugosi" ],
      "venue" : null,
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2006
    }, {
      "title" : "Matrix estimation by universal singular value thresholding",
      "author" : [ "Sourav Chatterjee" ],
      "venue" : "The Annals of Statistics,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "This problem has a plethora of applications such as collaborative filtering, recommender systems [1] and sensor networks [2].",
      "startOffset" : 97,
      "endOffset" : 100
    }, {
      "referenceID" : 1,
      "context" : "This problem has a plethora of applications such as collaborative filtering, recommender systems [1] and sensor networks [2].",
      "startOffset" : 121,
      "endOffset" : 124
    }, {
      "referenceID" : 2,
      "context" : "Matrix completion has been well studied in machine learning, and we now know how to recover certain matrices given a few observed entries of the matrix [3, 4] when it is assumed to be low rank.",
      "startOffset" : 152,
      "endOffset" : 158
    }, {
      "referenceID" : 3,
      "context" : "Matrix completion has been well studied in machine learning, and we now know how to recover certain matrices given a few observed entries of the matrix [3, 4] when it is assumed to be low rank.",
      "startOffset" : 152,
      "endOffset" : 158
    }, {
      "referenceID" : 2,
      "context" : "Typical work in matrix completion assumes that the matrix to be recovered is incoherent, low rank, and entries are sampled uniformly at random [3, 4, 5, 6, 7, 8].",
      "startOffset" : 143,
      "endOffset" : 161
    }, {
      "referenceID" : 3,
      "context" : "Typical work in matrix completion assumes that the matrix to be recovered is incoherent, low rank, and entries are sampled uniformly at random [3, 4, 5, 6, 7, 8].",
      "startOffset" : 143,
      "endOffset" : 161
    }, {
      "referenceID" : 4,
      "context" : "Typical work in matrix completion assumes that the matrix to be recovered is incoherent, low rank, and entries are sampled uniformly at random [3, 4, 5, 6, 7, 8].",
      "startOffset" : 143,
      "endOffset" : 161
    }, {
      "referenceID" : 5,
      "context" : "Typical work in matrix completion assumes that the matrix to be recovered is incoherent, low rank, and entries are sampled uniformly at random [3, 4, 5, 6, 7, 8].",
      "startOffset" : 143,
      "endOffset" : 161
    }, {
      "referenceID" : 6,
      "context" : "Typical work in matrix completion assumes that the matrix to be recovered is incoherent, low rank, and entries are sampled uniformly at random [3, 4, 5, 6, 7, 8].",
      "startOffset" : 143,
      "endOffset" : 161
    }, {
      "referenceID" : 7,
      "context" : "Typical work in matrix completion assumes that the matrix to be recovered is incoherent, low rank, and entries are sampled uniformly at random [3, 4, 5, 6, 7, 8].",
      "startOffset" : 143,
      "endOffset" : 161
    }, {
      "referenceID" : 8,
      "context" : "The Euclidean distance matrix is a low-rank matrix [9].",
      "startOffset" : 51,
      "endOffset" : 54
    }, {
      "referenceID" : 9,
      "context" : "We believe that the proposed ADMM algorithm is useful in its own right and can be used in general isotonic regression problems elsewhere [10, 11].",
      "startOffset" : 137,
      "endOffset" : 145
    }, {
      "referenceID" : 10,
      "context" : "We believe that the proposed ADMM algorithm is useful in its own right and can be used in general isotonic regression problems elsewhere [10, 11].",
      "startOffset" : 137,
      "endOffset" : 145
    }, {
      "referenceID" : 2,
      "context" : "Classical matrix completion with and without noise has been investigated by several authors [3, 4, 5, 6, 7, 8].",
      "startOffset" : 92,
      "endOffset" : 110
    }, {
      "referenceID" : 3,
      "context" : "Classical matrix completion with and without noise has been investigated by several authors [3, 4, 5, 6, 7, 8].",
      "startOffset" : 92,
      "endOffset" : 110
    }, {
      "referenceID" : 4,
      "context" : "Classical matrix completion with and without noise has been investigated by several authors [3, 4, 5, 6, 7, 8].",
      "startOffset" : 92,
      "endOffset" : 110
    }, {
      "referenceID" : 5,
      "context" : "Classical matrix completion with and without noise has been investigated by several authors [3, 4, 5, 6, 7, 8].",
      "startOffset" : 92,
      "endOffset" : 110
    }, {
      "referenceID" : 6,
      "context" : "Classical matrix completion with and without noise has been investigated by several authors [3, 4, 5, 6, 7, 8].",
      "startOffset" : 92,
      "endOffset" : 110
    }, {
      "referenceID" : 7,
      "context" : "Classical matrix completion with and without noise has been investigated by several authors [3, 4, 5, 6, 7, 8].",
      "startOffset" : 92,
      "endOffset" : 110
    }, {
      "referenceID" : 11,
      "context" : "Progress has also been made on designing efficient algorithms to solve the ensuing convex optimization problem [12, 13, 14, 15].",
      "startOffset" : 111,
      "endOffset" : 127
    }, {
      "referenceID" : 12,
      "context" : "Progress has also been made on designing efficient algorithms to solve the ensuing convex optimization problem [12, 13, 14, 15].",
      "startOffset" : 111,
      "endOffset" : 127
    }, {
      "referenceID" : 13,
      "context" : "Progress has also been made on designing efficient algorithms to solve the ensuing convex optimization problem [12, 13, 14, 15].",
      "startOffset" : 111,
      "endOffset" : 127
    }, {
      "referenceID" : 14,
      "context" : "Progress has also been made on designing efficient algorithms to solve the ensuing convex optimization problem [12, 13, 14, 15].",
      "startOffset" : 111,
      "endOffset" : 127
    }, {
      "referenceID" : 15,
      "context" : "[16] suggested looking at the neighbourhood of each incomplete point for completion, [17] used a combination of spectral clustering techniques as done in [18, 19] along with learning sparse representations via convex optimization to estimate the incomplete matrix.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "[16] suggested looking at the neighbourhood of each incomplete point for completion, [17] used a combination of spectral clustering techniques as done in [18, 19] along with learning sparse representations via convex optimization to estimate the incomplete matrix.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 17,
      "context" : "[16] suggested looking at the neighbourhood of each incomplete point for completion, [17] used a combination of spectral clustering techniques as done in [18, 19] along with learning sparse representations via convex optimization to estimate the incomplete matrix.",
      "startOffset" : 154,
      "endOffset" : 162
    }, {
      "referenceID" : 18,
      "context" : "[16] suggested looking at the neighbourhood of each incomplete point for completion, [17] used a combination of spectral clustering techniques as done in [18, 19] along with learning sparse representations via convex optimization to estimate the incomplete matrix.",
      "startOffset" : 154,
      "endOffset" : 162
    }, {
      "referenceID" : 19,
      "context" : "[20] consider a certain specific class of high-rank matrices that are obtained from ultra-metrics.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "In [21] the authors consider a model similar to ours, but instead of learning a single monotonic function, they learn multiple monotonic functions, one for each row of the matrix.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 21,
      "context" : "Davenport et al [22] studied the one-bit matrix completion problem.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 9,
      "context" : "The MMC model is inspired by the single-index model (SIM) that has been studied both in statistics [10, 11] and econometrics for regression problems [23, 24].",
      "startOffset" : 99,
      "endOffset" : 107
    }, {
      "referenceID" : 10,
      "context" : "The MMC model is inspired by the single-index model (SIM) that has been studied both in statistics [10, 11] and econometrics for regression problems [23, 24].",
      "startOffset" : 99,
      "endOffset" : 107
    }, {
      "referenceID" : 22,
      "context" : "The MMC model is inspired by the single-index model (SIM) that has been studied both in statistics [10, 11] and econometrics for regression problems [23, 24].",
      "startOffset" : 149,
      "endOffset" : 157
    }, {
      "referenceID" : 23,
      "context" : "The MMC model is inspired by the single-index model (SIM) that has been studied both in statistics [10, 11] and econometrics for regression problems [23, 24].",
      "startOffset" : 149,
      "endOffset" : 157
    }, {
      "referenceID" : 10,
      "context" : "The LPAV 4 algorithm introduced in [11] outputs the best function ĝ in G that minimizes ∑n i=1(g(pi)− yi) .",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 24,
      "context" : "The idea of using calibrated loss functions was first introduced for learning single index models [25].",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 25,
      "context" : "39 in [26]).",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 3,
      "context" : "We compare the performance of MMC−1, MMC− c, MMC- LS, and nuclear norm based low-rank matrix completion (LRMC) [4] on various synthetic and real world datasets.",
      "startOffset" : 111,
      "endOffset" : 114
    }, {
      "referenceID" : 14,
      "context" : "The increasing rank procedure was inspired by the work of [15], where they demonstrated that such procedures are suitable for low-rank approximation problems.",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 26,
      "context" : "Instead we use the Alternating Direction Method of Multipliers (ADMM) algorithm for our problem [27] which allows us to exploit the rich structure present in problem (22).",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 26,
      "context" : "In our practical implementations we follow the advice as mentioned in [27] and set abs and rel to 10−2.",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 14,
      "context" : "For our implementations we assume that r is unknown, and estimate it either (i) via the use of a dedicated validation set in the case of MMC − 1 or (ii) adaptively, where we progressively increase the estimate of our rank until a sufficient decrease in error over the training set is achieved [15].",
      "startOffset" : 293,
      "endOffset" : 297
    }, {
      "referenceID" : 27,
      "context" : "For an implementation of the LRMC algorithm we used a standard off-the-shelf implementation from TFOCS [28].",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 14,
      "context" : "The baseline algorithm chosen for low rank matrix completion is LMaFit-A [15] 7.",
      "startOffset" : 73,
      "endOffset" : 77
    } ],
    "year" : 2015,
    "abstractText" : "Most recent results in matrix completion assume that the matrix under consideration is low-rank or that the columns are in a union of low-rank subspaces. In real-world settings, however, the linear structure underlying these models is distorted by a (typically unknown) nonlinear transformation. This paper addresses the challenge of matrix completion in the face of such nonlinearities. Given a few observations of a matrix that are obtained by applying a Lipschitz, monotonic function to a low rank matrix, our task is to estimate the remaining unobserved entries. We propose a novel matrix completion method that alternates between lowrank matrix estimation and monotonic function estimation to estimate the missing matrix elements. Mean squared error bounds provide insight into how well the matrix can be estimated based on the size, rank of the matrix and properties of the nonlinear transformation. Empirical results on synthetic and real-world datasets demonstrate the competitiveness of the proposed approach.",
    "creator" : "LaTeX with hyperref package"
  }
}