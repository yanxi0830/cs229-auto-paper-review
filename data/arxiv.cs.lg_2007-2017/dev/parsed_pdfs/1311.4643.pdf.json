{
  "name" : "1311.4643.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Near-Optimal Entrywise Sampling for Data Matrices",
    "authors" : [ "Dimitris Achlioptas", "Zohar Karnin" ],
    "emails" : [ "optas@cs.ucsc.edu", "zkarnin@ymail.com", "edo.liberty@ymail.com" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Given an m×n matrix A, it is often desirable to find a sparser matrix B that is a good proxy for A. Besides being a natural mathematical question, such sparsification has become a ubiquitous preprocessing step in a number of data analysis operations including approximate eigenvector computations [AM01, AHK06, AM07], semi-definite programming [AHK05, d’A08], and matrix completion problems [CR09, CT10].\nA fruitful measure for the approximation of A by B is the spectral norm of A−B, where for any matrix C its spectral norm is defined as ‖C‖2 = max‖x‖2=1 ‖Cx‖2. Randomization has been central in the context of matrix approximations and the overall problem is typically cast as follows: given a matrix A and a budget s, devise a distribution over matrices B such that the (expected) number of non-zero entries in B is at most s and ‖A−B‖2 is as small as possible.\nOur work is motivated by big data matrices that are generated by measurement processes. Each of the n matrix columns correspond to an observation of m attributes. Thus, we expect n m. Also we expect the total number of non-zero entries in A to exceed available memory. We assume that the original data matrix A is accessed in the streaming model where we know only very basic features of A a priori and the actual non-zero entries are presented to us one at a time in an arbitrary order. The streaming model is especially important for tasks like recommendation engines where user-item preferences become available one by one in an arbitrary order. But, it is also important in cases when A exists in durable storage and random access of its entries is prohibitively expensive.\nWe establish that for such matrices the following approach gives provably near-optimal sparsification. Assign to each element Aij of the matrix a weight that depends only on the elements in its row qij = |Aij |/‖A(i)‖1. Take ρ to be an (appropriate) distribution over the rows. Sample s i.i.d. entries from A using the distribution pij = ρiqij . Return B which is the mean of s matrices, each containing a single non zero entry Aij/pij in the selected location (i, j).\nAs we will see, this simple form of the probabilities pij falls out naturally from generic optimization considerations. The fact that each entry is kept with probability proportional to its magnitude, besides\nar X\niv :1\n31 1.\n46 43\nv1 [\ncs .L\nG ]\n1 9\nN ov\nbeing interesting on its own right, has a remarkably practical implication. Every non-zero in the i-th row of B will take the form kij(‖A(i)‖1/sρi) where |kij | is the number times Aij was sampled. Note that since we sample with replacement |kij | might, in rare occasions, be more than 1. The result is a matrix B which is representable in O(m log(n) + s log(n/s)) bits. This is because there is no reason to store floating point matrix entry values. We use O(m log(n)) bits to store all values ‖A(i)‖1/sρi and O(s log(n/s)) bits to store the non zero index offsets.1 Note that ∑ |kij | = s and that some of these offsets might be zero. In a simple experiment, we measured the average number of bits per sample (total size of the sketch divided by the number of samples s). The results were between 5 and 22 bits per sample depending on the matrix and s. It is important to note that the number of bits per sample is usually less than log2(n) + log2(m) which is the minimal number of bit required to represent a pair (i, j). Our experiments show a reduction of disc space by a factor of between 2 and 5 relative to the compressed size of the file representing the sample matrix B in the standard row-column-value list format.\nAnother insight of our work is that the distributions we propose are combinations of two L1-based distributions. Which distribution is more dominant is determined by the sampling budget. When the number of samples s is small, ρi is nearly linear in ‖A(i)‖1 resulting in pij ∝ |Aij |. However, as the number of samples grows, ρi tends towards ‖A(i)‖21 resulting in pij ∝ |Aij | · ‖A(i)‖1, a distribution we refer to as Row-L1 sampling. The dependence of the preferred distribution on the sample budget is also borne out in experiments, with sampling based on appropriately mixed distributions being consistently best. This highlights that the need to adapt the sampling distribution to the sample budget is a genuine phenomenon."
    }, {
      "heading" : "2 Measure of Error and Related Work",
      "text" : "We measure the difference between A and B with respect to the L2 (spectral) norm as it is highly revealing in the context of data analysis. Let us define a linear trend in the data of A as any tendency of the rows to align with a particular unit vector x. To examine the presence of such a trend, we need only multiply A with x: the ith coordinate of Ax is the projection of the ith row of A onto x. Thus, ‖Ax‖2 measures the strength of linear trend x in A, and ‖A‖2 measures the strongest linear trend in A. Thus, minimizing ‖A−B‖2 minimizes the strength of the strongest linear trend of A not captured by B. In contrast, measuring the difference using any entry-wise norm, e.g., the Frobenius norm, can be completely uninformative. This is because the best strategy would be to always pick the largest s matrix entries from A, a strategy that can easily be “fooled”. As a stark example, when the matrix entries are Aij ∈ {0, 1}, the quality of the approximation is completely independent of which elements of A we keep. This is clearly bad; as long as A contains even a modicum of structure certain approximations will be far better than others.\nBy using the spectral norm to measure error we get a natural and sophisticated target: to minimize ‖A − B‖2 is to make E = A − B a near-rotation, having only small variations in the amount by which it stretches different vectors. This idea that the error matrix E should be isotropic, thus packing as much Frobenius norm as possible for its L2 norm, motivated the first work on element-wise sampling of matrices by Achlioptas and McSherry [AM07]. Concretely, to minimize ‖E‖2 it is natural to aim for a matrix E that is both zero-mean, i.e., an unbiased estimator of A, and whose entries are formed by sampling the entries of A (and, thus, of E) independently. In the work of [AM07], E is a matrix of i.i.d. zero-mean random variables. The study of the spectral characteristics of such matrices goes back all the way to Wigner’s famous semi-circle law [Wig58]. Specifically, to bound ‖E‖2 in [AM07] a bound due to Alon Krivelevich and Vu [AKV02] was used, a refinement of a bound by Juhász [Juh81] and Füredi and Komlós [FK81]. The most salient feature of that bound is that it depends on the maximum entry-wise variance σ2 of A−B, and therefore the distribution optimizing the bound is the one in which the variance of all entries in E is the same. In turn, this means keeping each entry of A independently with probability pij ∝ A2ij (up to a small wrinkle discussed below).\nSeveral papers have since analyzed L2-sampling and variants [NDT09, NDT10, DZ11, GT09, AM07]. An inherent difficulty of L2-sampling based strategies is the need for a special handling of small entries. This is because when each item Aij is kept with probability pij ∝ A2ij , the resulting entry Bij in the sample matrix has magnitude |Aij/pij | ∝ 1/|Aij |. Thus, if an extremely small element Aij is accidentally picked,\n1It is harmless to assume any value in the matrix is kept using O(log(n)) bits of precision. Otherwise, truncating the trailing bits can be shown to be negligible.\nthe largest entry of the sample matrix “blows up”. In [AM07] this was addressed by sampling small entries with probability proportional to |Aij | rather than A2ij . In the work of Gittens and Tropp [GT09], small entries are not handled separately and the bound derived depends on the ratio between the largest and the smallest non-zero magnitude.\nRandom matrix theory has witnessed dramatic progress in the last few years and [AW02, RV07, Tro12a, Rec11] provide a good overview of the results. This progress motivated Drineas and Zouzias in [DZ11] to revisit L2-sampling but now using concentration results for sums of random matrices [Rec11], as we do here. (Note that this is somewhat different from the original setting of [AM07] since now E is not one random matrix with independent entries, but a sum of many independent matrices since the entries are chosen with replacement.) Their work improved upon all previous L2-based sampling results and also upon the L1-sampling result of Arora, Hazan and Kale [AHK06], discussed below, while admitting a remarkably compact proof. The issue of small entries was handled in [DZ11] by deterministically discarding all sufficiently small entries, a strategy that gives the strongest mathematical guarantee (but see the discussion regarding deterministic truncation in the experimental section).\nA completely different tack at the problem, avoiding random matrix theory altogether, was taken by Arora et al. [AHK06]. Their approximation keeps the largest entries in A deterministically (specifically all Aij ≥ ε/ √ n where the threshold ε needs be known a priori) and randomly rounds the remaining smaller entries to sign(Aij)ε/ √ n or 0. They exploit the simple fact ‖A − B‖ = sup‖x‖=1,‖y‖=1 xT (A − B)y by noting that as a scalar quantity its concentration around its expectation can be established by standard Bernstein-Bennet type inequalities. A union bound then allows them to prove that with high probability, xT (A − B)y ≤ ε for every x and y. The result of [AHK06] admits a relatively simple proof. However, it also requires a truncation that depends on the desired approximation ε. Rather interestingly, this time the truncation amounts to keeping every entry larger than some threshold."
    }, {
      "heading" : "3 Our Approach",
      "text" : "Following the discussion in Section 2 and in line with previous works, we: (i) measure the quality of B by ‖A− B‖2, (ii) sample the entries of A independently, and (iii) require B to be an unbiased estimator of A. We are therefore left with the task of determining a good probability distribution pij from which to sample the entries of A in order to get B. As discussed in Section 2 prior art makes heavy use of beautiful results in the theory of random matrices. Specifically, each work proposes a specific sampling distribution and then uses results from random matrix theory to demonstrate that it has good properties. In this work we reverse the approach, aiming for its logical conclusion. We start from a cornerstone result in random matrix theory and work backwards to reverse-engineer near-optimal distributions with respect to the notion of probabilistic deviations captured by the inequality. The inequality we use it the Matrix-Bernstein inequality for sums of independent random matrices (see e.g., [Tro12b], Theorem 1.6).\nTheorem 3.1 (Matrix Bernstein inequality). Consider a finite sequence {Xi} of i.i.d. random m × n matrices, where E[X1] = 0 and ‖X1‖ ≤ R. Let σ2 = max { ‖E[X1XT1 ]‖, ‖E[XT1 X1]‖ } .\nFor some fixed s ≥ 1, let X = (X1 + · · ·+Xs)/s. For all ε ≥ 0, Pr[‖X‖ ≥ ε] ≤ (m+ n) exp ( − sε 2\nσ2 +Rε/3\n) .\nTo get a feeling for our approach, fix any probability distribution p over the non-zero elements of A. Let B be a random m × n matrix with exactly one non-zero element, formed by sampling an element Aij of A according to p and letting Bij = Aij/pij . Observe that for every (i, j), regardless of the choice of p, we have E[Bij ] = Aij , and thus B is always an unbiased estimator of A. Clearly, the same is true if we repeat this s times taking i.i.d. samples B1, . . . , Bs and let our matrix B be their average. With this approach in mind, the goal is now to find a distribution p minimizing ‖E‖ = ‖A − (B1 + · · · + Bs)/s‖. Writing sE = (A−B1) + · · ·+ (A−Bs) we see that ‖sE‖ is the operator norm of a sum of i.i.d. zero-mean random matrices Xi = A−Bi, i.e., exactly the setting of Theorem 3.1. The relevant parameters are\nσ2 = max { ‖E[(A−B1)(A−B1)T ]‖, ‖E[(A−B1)T (A−B1)]‖ } (1)\nR = max ‖A−B1‖2 over all possible realizations of B1 . (2)\nEquations (1) and (2) mark the starting point of our work. Our goal is to find probability distributions over the elements of A that optimize (1) and (2) simultaneously with respect to their functional form in Theorem 3.1, thus yielding the strongest possible bound on ‖A − B‖2. A conceptual contribution of our work is the discovery that these distributions depend on the sample budget s, a fact also borne out in experiments. The fact that minimizing the deviation metric of Theorem 3.1, i.e., σ2 +R /3, suffices to bring out this non-linearity can be viewed as testament to the theorem’s sharpness.\nTheorem 3.1 is stated as a bound on the probability that the norm of the error matrix is greater than some target error ε given the number of samples s. Nevertheless, in practice the target error ε is not known in advance, but rather is the quantity to minimize given the matrix A, the number of samples s, and the target confidence δ. Specifically, for any given distribution p on the elements of A, define\nε1(p) = inf\n{ ε : (m+ n) exp ( − sε 2\nσ(p)2 +R(p)ε/3\n) ≤ δ } . (3)\nOur goal in the rest of the paper is to seek the distribution p∗ minimizing ε1. Our result is an easily computable distribution p which comes within a factor of 3 of ε1(p\n∗) and, as a result, within a factor of 9 in terms of sample complexity (in practice we expect this to be even smaller, as the factor of 3 comes from consolidating bounds for a number of different worst-case matrices). To put this in perspective note that the definition of p∗ does not place any restriction either on the access model for A while computing p∗, or on the amount of time needed to compute p∗. In other words, we are competing against an oracle which in order to determine p∗ has all of A in its purview at once and can spend an unbounded amount of computation to determine it.\nIn contrast, the only global information regarding A we will require are the ratios between the L1 norms of the rows of the matrix. Trivially, the exact L1 norms of the rows (and therefore their ratios) can be computed in a single pass over the matrix, yielding a 2-pass algorithm. Moreover, standard concentration of measure arguments imply that these ratios can be estimated very well by sampling only a small number of columns. In our setting, it is in fact reasonable to expect that good estimates of these ratios are available a priori. This is because different rows correspond to different attributes and the ratios between the row norms reflect the ratios between the average absolute values of these features. For example, if the matrix corresponds to text documents, knowing the ratios amounts to knowing global word frequencies. Moreover these ratios do not need to be known exactly to apply the algorithm, as even rough estimates of them give highly competitive results. Indeed, even disregarding this issue completely and simply assuming that all ratios equal 1, yields an algorithm that appears quite competitive in practice, as demonstrated by our experiments."
    }, {
      "heading" : "4 Data Matrices and Statement of Results",
      "text" : "Throughout A(i) and A (j) will denote the i-th row and j-th column of A, respectively. Also, we use the notation ‖A‖1 = ∑ i,j |Aij | and ‖A‖2F = ∑ i,j A 2 ij . Before we formally state our result we introduce a definition that expresses the class of matrices for which our results hold.\nDefinition 4.1. An m× n matrix A is a Data matrix if:\n1. mini ‖A(i)‖1 ≥ maxj ‖A(j)‖1.\n2. ‖A‖21/‖A‖22 ≥ 50m.\n3. m ≥ 50.\nRegarding Condition 1, recall that we think of A as being generated by a measurement process of a fixed number of attributes (rows), each column corresponding to an observation. As a result, columns have bounded L1 norm, i.e., ‖A(j)‖1 ≤ constant. While this constant may depend on the type of object and its dimensionality, it is independent of the number of objects. On the other hand, ‖A(i)‖1 grows linearly with the number of columns (objects). As a result, we can expect Definition 4.1 to hold for all large enough data sets. Regarding Condition 2, it is easy to verify that unless the values of the entries of A exhibit an unbounded variance, ‖A‖21/‖A‖22 grows as Ω(n) and Condition 2 follows from n m. Condition 3 if trivial.\nOut of the three conditions the essential one is Condition 1. The other two are merely technical and hold in all non-trivial cases where Condition 1 applies.\nAlgorithm 1 Construct a sketch B for a data matrix A\n1: Input: Data matrix A ∈ Rm×n, sampling budget s, acceptable failure probability δ 2: Set ρ← ComputeRowDistribution(A, s, δ) 3: Sample s elements of A with replacement, each Aij having probability pij = ρi · |Aij |/‖A(i)‖1 4: For each sample 〈i, j, Aij〉`, let entry (i, j) of B` be Aij/pij and zero otherwise. 5: Output: B = 1s ∑s `=1B`.\n6: function ComputeRowDistribution(A, s, δ) 7: Obtain z such that zi ∝ ‖A(i)‖1 for i ∈ [m] 8: Set α← √ log((m+ n)/δ)/s and β ← log((m+ n)/δ)/(3s)\n9: Define ρi(ζ) = ( αzi/2ζ + √ (αzi/2ζ) 2 + βzi/ζ )2 10: Find ζ1 such that ∑m i=1 ρi(ζ1) = 1 11: return ρ such that ρi = ρi(ζ1) for i ∈ [m]\nTo simplify the exposition of algorithm 1, we describe it in a the non-streaming setting. About the complexity of Algorithm 1, steps 6–11 compute a distribution ρ over the rows. Assuming step 7 can be implemented efficiently (or skipped altogether, see discussion at the bottom of Section 3) the running time of ComputeRowDistribution is independent of n. Finding ζ1 in step 10 can be done very efficiently by binary search because the function ∑ i ρi(ζ) is strictly decreasing in ζ. Conceptually, we see that the probability assigned to each element Aij in Step 3 is simply the probability ρi of its row times its intra-row weight |Aij |/‖A(i)‖1.\nNote that to apply Algorithm 1 the entries of A must be sampled with replacement in the streaming model. A simple way to achieve this using O(s) operations per matrix element and O(s) active memory was presented in [DKM06]. In fact, though, it is possible to implement such sampling far more efficiently.\nTheorem 4.2. For any matrix A, steps 3-5 in Algorithm 1 can be accomplished using O(log(s)) active memory, Õ(s) space, and O(1) operations per non zero element of A in the streaming model.\nWe are now able to state our main result.\nTheorem 4.3. If A is a Data matrix (per Definition 4.1) and p is the probability distribution defined in Algorithm 1, then ε1(p) ≤ 3 ε1(p∗), where p∗ is the minimizer of ε1.\nThe proof of Theorem 4.3 is outlined in Section 5. To understand the implications of Theorem 4.3 and to compare our result with previous ones we must first define several matrix metrics. Stable rank: Denoted as sr and defined as ‖A‖2F /‖A‖22. This is a smooth analog for the algebraic rank, always bounded by it from above, and resilient to small perturbations of the matrix. For data matrices we expect it to be small (even constant) and to capture the “inherent dimensionality” of the data. Numeric density: Denoted as nd and defined as ‖A‖21/‖A‖2F , this is a smooth analog of the number of non-zero entries nnz(A). For 0-1 matrices it equals nnz(A), but when there is variance in the magnitude of the entries it is smaller. Numeric row density: Denoted as nrd and defined as ∑ i ‖A(i)‖21/‖A‖2F ≤ n. In practice, it is often close to the average numeric density of a single row, a quantity typically much smaller than n.\nTheorem 4.4. Let A be a data matrix meeting the conditions of Definition 4.1. Let B be the matrix returned by Algorithm 1 for ε > 0 and\ns ≥ s0 = Θ(nrd · sr /ε2 · log(n/δ) + (sr ·nd /ε2 · log(n/δ))1/2) .\nThen ‖A−B‖ ≤ ε‖A‖ with probability at least 1− δ.\nThe table below shows the corresponding number of samples in previous works for constant success probability, in terms of the matrix metrics defined above. The fourth column presents the ratio of the samples needed by previous results divided by the samples needed by our method. To simplify the expressions, we present the ratio between our bound and [AHK06] only when the result of [AHK06] gives superior bounds to [DZ11]. That is, we always compare our bound to the stronger of the two bounds implied by these works.\nCitation Method Number of samples needed Improvement ratio of Theorem 4.4\n[AM07] L1, L2 sr ·(n/ε2) + n · polylog(n) [DZ11] L2 sr ·(n/ε2) log(n) nrd /n+ ( √ nd/n) · (ε/ √ sr log(n))\n[AHK06] L1 (nd ·n/ε2)1/2 √ sr · log(n)/n\nThis paper Bernstein nrd · sr /ε2 · log(n) + (sr ·nd /ε2 ·\nlog(n))1/2\nHolding ε and the stable rank constant we readily see that our method requires roughly 1/ √ n the samples needed by [AHK06]. In the comparison with [DZ11], the key parameter is the ratio nrd /n. This quantity is typically much smaller than 1 for data matrices but independent of n. As a point of reference for the assumptions, in the experimental Section 6 we provide the values of all relevant matrix metrics for all the real data matrices we worked with, wherein the ratio nrd /n is typically around 10−2. Considering this, one would expect that L2-sampling should experimentally fare better than L1-sampling. As we will see, quite the opposite is true. A potential explanation for this phenomenon is the relative looseness of the bound of [AHK06] for the performance of L1-sampling."
    }, {
      "heading" : "5 Proof of Theorem 4.4",
      "text" : "We start by iteratively replacing the objective functions (1) and (2) with increasingly simpler functions. Each replacement will incur a (small) loss in accuracy but will bring us closer to a function for which we can give a closed form solution. Recalling the definitions of α, β from Algorithm 1 and rewriting the requirement in (3) as a quadratic form in ε gives ε2 − εβR− (ασ)2 > 0. Our first step is to observe that for any c, d > 0, the equation ε2 − ε · c − d = 0 has one negative and one positive solution and that the latter is at least (c + √ d)/ √ 2 and at most c + √ d. Therefore, if we define2 ε2 := ασ + βR we see that 1/ √ 2 ≤ ε1/ε2 ≤ 1. Our next simplification encompasses Conditions 3, 2 of Definition 4.1. Let ε3 := ασ̃ + βR̃ where\nσ̃2 := max maxi ∑ j A2ij/pij , max j ∑ i A2ij/pij  R̃ := maxij |Aij |/pij . Lemma 5.1. For every matrix A satisfying Conditions 3 and 2 of Definition 4.1, for every probability distribution on the elements of A, |ε2/ε3 − 1| ≤ 1/50.\nProof. We start by providing an two auxiliary lemmas. Lemma 5.2. For any x, p ∈ Rn, if pi ≥ 0 and ‖p‖1 = 1, then maxk |xk|/pk ≥ ‖x‖1 and ∑ k x 2 k/pk ≥ ‖x‖21, with equality holding in both cases if and only if pk = |xk|/‖x‖1.\nProof. To prove maxk |xk|/pk ≥ ‖x‖1 we note that if |xi|/pi 6= |xj |/pj , then changing pi, pj to p′i, p′j such that p′i + p ′ j = pi + pj and |xi|/p′i = |xj |/p′j can only reduce the maximum. In order for all |xk|/pk to be equal it must be that pk = |xk|/‖x‖1 for all j, in which case maxk |xk|/pk = ‖x‖1. The second claim follows from applying Jensen’s inequality to the convex function x 7→ x2. Specifically, Jensen’s inequality shows that for any p,\nEi∼p[(|xi|/pi)2] ≥ Ei∼p[(|xi|/pi)]2 = ‖x‖21 2Here and in the following, to lighten notation, we will omit all arguments, i.e., p, σ(p), R(p), from the objective functions\nεi we seeks to optimize, as they are readily understood from context.\nThis inequality is met for pi = |xi|/‖x‖1.\nLemma 5.3. For any matrix A and any probability distribution p on the elements of A, we have |σ2/σ̃2−1| ≤ ‖A‖22∑ i ‖A(i)‖21 and |R/R̃− 1| ≤ ‖A‖2‖A‖1 .\nProof. Recall that B1 contains one non-zero element Aij/pij , while all its other entries are 0. Therefore, E[B1BT1 ] and E[BT1 B1] are both diagonal matrices where\nE[(B1BT1 )i,i] = ∑ j A2ij/pij and E[(BT1 B1)j,j ] = ∑ i A2ij/pij .\nSince the operator norm of a diagonal matrix equals its largest entry we see that\nσ̃2 := max maxi ∑ j A2ij/pij , max j ∑ i A2ij/pij  = max{‖E[B1BT1 ]‖, ‖E[BT1 B1]‖} . We will need to bound σ̃2 from below. Trivially, σ̃2 ≥ ‖E[B1BT1 ]‖ = maxi ∑ j A 2 ij/pij . Defining ρi :=∑\nj pij and qij := pij/ρi, the below second and third inequalities are a result of Lemma 5.2\nσ̃2 ≥ max i ∑ j A2ij pij = max i ρ−1i ∑ j A2ij qij ≥ max i ρ−1i ‖A(i)‖ 2 1 ≥ ∑ i ‖A(i)‖21 . (4)\nOn the other hand, σ2 = max{‖E[Z1ZT1 ]‖, ‖E[ZT1 Z1]‖}, where Z1 = B1 −A. Since E[B1] = A,\n‖E[Z1ZT1 ]‖ = ‖E[B1BT1 −ABT1 −B1AT +AAT ]‖ = ‖E[B1BT1 ]−AAT ‖\nand, analogously, ‖E[ZT1 Z1]‖ = ‖E[BT1 B1]− ATA‖. Therefore, by the triangle inequality, |σ2 − σ̃2| ≤ ‖A‖2 and the claim now follows from (4).\nRecall that B1 contains one non-zero entry Aij/pij and that R is the maximum of ‖B1 − A‖ over all possible realizations of p, i.e., choices of (i, j). Thus by the triangle inequality,"
    }, {
      "heading" : "R = max ‖B1 −A‖ ≤ max ‖B1‖+ ‖A‖ and R ≥ max ‖B1‖ − ‖A‖ .",
      "text" : "Since B1 has one non-zero entry, we see that max ‖B1‖2 = maxij |Aij |/pij = R̃ and, thus, |R/R̃ − 1| ≤ ‖A‖2/R̃. Applying Lemma 5.2 to A ∈ Rm×n with distribution p yields R̃ ≥ ‖A‖1.\nWe are now ready to prove lemma 5.1. It suffices to prove that both |σ2/σ̃2 − 1| and |R/R̃ − 1| are bounded by 1/50. Lemma 5.3 yields the first inequality below and Condition 2 of Definition 4.1 the second. The third inequality holds for every matrix A, with equality occurring when all rows have the same L1 norm.\n|σ2/σ̃2 − 1| ≤ ‖A‖ 2 2∑\ni ‖A(i)‖21 ≤ ‖A‖ 2 1 50m ∑ i ‖A(i)‖21 ≤ 1 50 .\nLemma 5.3 yields the first inequality below. The second inequality follows from rearranging the factors in the second inequality above. Condition 3 of Definition 4.1, i.e., m ≥ 50, implies the third.\n|R/R̃− 1| ≤ ‖A‖2 ‖A‖1 ≤ 1√ 50m ≤ 1 50 .\nThis allows us to optimize p with respect to ε3 instead of ε2. In minimizing ε3 we see that there is freedom to use different rows to optimize σ̃ and R̃. At a cost of a factor of 2, we will couple the two minimizations by minimizing ε4 = max{ε5, ε6} where\nε5 := max i\nα √√√√∑\nj\nA2ij pij + βmax j |Aij | pij  , ε6 := max j α √√√√∑\ni\nA2ij pij + βmax i |Aij | pij\n . (5)\nNote that the maximization of R̃ in ε5 (and ε6) is coupled with that of the σ̃-related term by constraining the optimization to consider only one row (column) at a time. Clearly, 1 ≤ ε3/ε4 ≤ 2.\nNext we focus on ε5, the first term in the maximization of ε4. We first present a lemma analyzing the distribution minimizing it. The lemma provides two important insights. First, it leads to an efficient algorithm for finding a distribution minimizing ε5 and second, it is key in proving that for all data matrices satisfying Condition 1 of Definition 4.1, by minimizing ε5 we also minimize ε4 = max{ε5, ε6}.\nLemma 5.4. A minimizer to the function ε5 can be found, to precision η in time logarithmic in η. Specifically the function ε5 is minimized by pij = ρiqij where qij = |Aij |/‖A(i)‖1. To define ρi let zi ∝ ‖A(i)‖1 and\ndefine ρi(ζ) = ( αzi/2ζ + √ (αzi/2ζ) 2 + βzi/ζ )2 . Let ζ1 > 0 be the unique solution to 3 ∑ i ρi(ζ1) = 1. We\nset ρi := ρi(ζ1).\nProof. To find the probability distribution p that minimizes ε5 we start by writing p = ρiqij , without loss of generality. That is, we decompose p to a distribution ρi ≥ 0 over the rows of the matrix, i.e., ∑ i ρi = 1,\nand a distribution qij ≥ 0 within each row i, i.e., ∑ j qij = 1, for all i. We first prove that (surprisingly) the optimal q has a closed form solution while the optimal ρ is efficiently computable. For any ρ, writing ε5 in terms of ρi, qij we see that ε5 is the maximum, over rows 1 ≤ i ≤ m , of\nα √ ρi √√√√∑ j A2ij qij + β ρi max j |Aij | qij . (6)\nObserve that since ρ is fixed, the only variables in the above expression for each row i are the qij . Lemma 5.2 implies that setting qij = |Aij |/‖A(i)‖1 simultaneously minimizes both terms in (6). This means that for every fixed probability distribution ρ, the minimizer of ε5 satisfies qij =\n|Aij | ‖A(i)‖1 . Thus, we are left\nto determine\nΦ(ρ) = max i\n[ α‖A(i)‖1√\nρi + β‖A(i)‖1 ρi\n] .\nUnlike the intrarow optimization, the two summands in Φ achieve their respective minima at different distributions ρ. To get some insight into the tradeoff, let us first consider the two extreme cases. When β = 0, minimizing the maximum over i requires equating all ‖A(i)‖1/ √ ρi, i.e., ρi ∝ ‖A(i)‖21, leading to the distribution we call “row-L1”, i.e., pij ∝ |Aij | · ‖A(i)‖1. When α = 0, equating the ‖A(i)‖1/ρi requires ρi ∝ ‖A(i)‖1, leading to the “plain-L1” distribution pij ∝ |Aij |. Nevertheless, since we wish to minimize the maximum over several functions, we can seek p under which all functions are equal, i.e., such that there exists ζ > 0 such that for all i,\nα‖A(i)‖1√ ρi + β‖A(i)‖1 ρi = ζ > 0 .\nSolving the resulting quadratic equation and selecting for the positive root yields equation (7), i.e.,\nρi(ζ) = α‖A(i)‖1 2ζ + √( α‖A(i)‖1 2ζ )2 + β‖A(i)‖1 ζ 2 . (7) Since the quantities under the square root in (7) are all positive we see that it is always possible to find ζ > 0 such that all equalities hold, and thus (7) does minimize ε5 for every matrix A. Moreover, since the right hand side of (7) is strictly decreasing in ζ, binary search finds the unique value of ζ such that ∑ ρi = 1.\nWe now prove that in order to minimize ε4 and thus approximately minimize the original function ε, it suffices, under appropriate conditions, to minimize ε5.\nLemma 5.5. For every matrix satisfying Condition 1 of Definition 4.1, argminp ε5 ⊆ argminp ε4. 3Notice that the function ∑ ρi(ζ) is monotonically decreasing for ζ > 0 hence the solution is indeed unique, and can be found via a binary search.\nProof. We begin with an auxiliary lemma.\nLemma 5.6. For any two functions f, g, if x0 = arg minx f(x) and g(x0) ≤ f(x0), then minx max{f(x), g(x)} = f(x0).\nProof. minx max{f(x), g(x)} ≥ minx f(x) = f(x0) = max{f(x0), g(x0)} ≥ minx max{f(x), g(x)}\nThus, it suffices to evaluate ε6 at the distribution p minimizing ε5 and check that ε6(p) ≤ ε5(p). We know that p is of the form pij = ρi|Aij |/‖A(i)‖1 for some distribution ρ. Substituting this form of p into ε6 gives (8). Condition 1 of Lemma 4.1, i.e., maxj ‖A(j)‖1 ≤ mini ‖A(i)‖1, allows us to pass from (9) to (10). Finally, to pass from (10) to (11) we note that the two maximizations over i in (10) involve the same expression, thus externalizing the maximization has no effect.\nε6(p) = max j α(∑ i ‖A(i)‖1 · |Aij | ρi )1/2 + βmax i ‖A(i)‖1 ρi  (8) ≤ max\nj α(max i ‖A(i)‖1 ρi · ∑ i |Aij | )1/2 + βmax i ‖A(i)‖1 ρi  = max\nj\n[ α ( max i ‖A(i)‖1 ρi · ‖A(j)‖1 )1/2 + βmax i ‖A(i)‖1 ρi ]\n≤ α (\nmax i ‖A(i)‖1 ρi ·max j ‖A(j)‖1\n)1/2 + βmax\ni ‖A(i)‖1 ρi\n(9)\n≤ α (\nmax i ‖A(i)‖1 ρi ·min i ‖A(i)‖1\n)1/2 + βmax\ni ‖A(i)‖1 ρi\n(10)\n≤ max i\n[ α (‖A(i)‖1 ρi ·min i ‖A(i)‖1 )1/2 + β ‖A(i)‖1 ρi ] (11)\n≤ max i\n[ α ‖A(i)‖1√\nρi + βmax i ‖A(i)‖1 ρi ] = ε5(p) .\nWe are now ready to prove our main Theorem.\nProof of Theorem 4.3. Recall that above we proved that\n1/ √ 2 ≤ ε1/ε2 ≤ 1, 49/50 ≤ ε2/ε3 ≤ 51/50, 1 ≤ ε3/ε4 ≤ 2.\nLet p be a minimizer of ε5. According to Lemma 5.5, it is also a minimizer of ε4. Hence, it holds that\nε(p)/min q {ε(q)} ≤\n√ 2 · 50\n49 · 51 50 · 2 ≤ 3\nas required\nWe finish with the proof of Theorem 4.4 analyzing the value of ε(p).\nProof of Theorem 4.4. We start by computing the value of ε1 as a function of s, δ, for the probability distribution P0 minimizing ε5. Recall that in deriving (7) we established that ε5(P0) = ζ0, where ζ0 is such that ∑m i=1 ρi(ζ0) = 1, i.e.,\n1 = m∑ i=1 α‖A(i)‖1 2ζ0 + √( α‖A(i)‖1 2ζ0 )2 + β‖A(i)‖1 ζ0 2 ≤ m∑ i=1 α2‖A(i)‖21 ζ20 + 2β‖A(i)‖1 ζ0 . (12)\nThis yields the following quadratic equation in ζ0 ζ20 − ζ0 · 2β‖A‖1 − α2 ∑ i ‖A(i)‖21 ≤ 1 (13)\nTreating (13) as an equality and bounding the larger root of the resulting quadratic equation we get\nζ0 = O β‖A‖1 + α√∑ i ‖A(i)‖21  = O  log (m+nδ ) ‖A‖1 s + √ log ( m+n δ )∑ i ‖A(i)‖21 s  (14) The second equality is obtain by replacing α, β with their corresponding expressions in Algorithm 1, line 8: α = √ log((m+ n)/δ)/s and β = log((m + n)/δ)/(3s). Recall that to prove Theorem 4.3 we proved that if A meets the conditions of Definition 4.1, then\nmin P ε1(p) = Θ(ζ0) .\nIt follows that for ε∗ = minP ε1(p),\ns = O\n( log((m+ n)/δ) ∑ i ‖A(i)‖1\nε∗ +\nlog((m+ n)/δ) ∑ i ‖A(i)‖21\n(ε∗)2 ) The theorem now follows by taking ε∗ = ε‖A‖."
    }, {
      "heading" : "6 Experiments",
      "text" : "We experimented with 4 matrices with different characteristics, these are summarized in the table below. See Section 4 for the definition of the different characteristics.\nMeasure m n nnz(A) ‖A‖1 ‖A‖F ‖A‖2 sr nd nrd Synthetic 1.0e+2 1.0e+4 5.0e+5 1.8e+7 3.2e+4 8.7e+3 1.3e+1 3.1e+5 3.2e+3\nEnron 1.3e+4 1.8e+5 7.2e+5 4.0e+9 5.8e+6 1.0e+6 3.2e+1 4.9e+5 1.5e+3 Images 5.1e+3 4.9e+5 2.5e+8 6.5e+9 2.0e+6 1.8e+6 1.3e+0 1.1e+7 2.3e+3 Wikipedia 4.4e+5 3.4e+6 5.3e+8 5.3e+9 7.5e+5 1.6e+5 2.1e+1 5.0e+7 1.9e+4\nEnron: Subject lines of emails in the Enron email corpus [Sty11]. Columns correspond to subject lines, rows to words, and entries to tf-idf values. This matrix is extremely sparse to begin with. Wikipedia: Term-document matrix of a fragment of Wikipedia in English. Entries are tf-idf values. Images: A collection of images of buildings from Oxford [PCI+07]. Each column represents the wavelet transform of a single 128× 128 pixel grayscale image. Synthetic: This synthetic matrix simulates a collaborative filtering matrix. Each row corresponds to an item and each column to a user. Each user and each item was first assigned a random latent vector (i.i.d. Gaussian). Each value in the matrix is the dot product of the corresponding latent vectors plus additional Gaussian noise. We simulated the fact that some items are more popular than others by retaining each entry of each item i with probability 1− i/m where i = 0, . . . ,m− 1."
    }, {
      "heading" : "6.1 Sampling techniques and quality measure",
      "text" : "The experiments report the accuracy of sampling according to four different distributions. In Figure 6.1, Bernstein denotes the distribution of this paper, defined in Lemma 5.4. The Row-L1 distribution is a simplified version of the Bernstein distribution, where pij ∝ |Aij | · ‖A(i)‖1. L1 and L2 refer to pij ∝ |Aij | and pij ∝ |Aij |2, respectively, as defined earlier in the paper. The case of L2 sampling was split into three sampling methods corresponding to different trimming thresholds. In the method referred to as L2 no trimming is made and pij ∝ |Aij |2. In the case referred to as L2 trim 0.1, pij ∝ |Aij |2 for any entry where\n|Aij |2 > 0.1 · Eij [|Aij |2] and pij = 0 otherwise. The sampling technique referred to as L2 trim 0.01 is analogous with threshold 0.01 · Eij [|Aij |2].\nAlthough to derive our sampling probability distributions we targeted minimizing ‖A − B‖2, in experiments it is more informative to consider a more sensitive measure of quality of approximation. The reason is that, due to scaling, for a number of values of s one has ‖A− B‖2 > ‖A‖2 which would suggest that the all zeros matrix is a better sketch for A than the sampled matrix. We will see that this is far from being the case. As a trivial example, consider the possibility B ≈ 10A. Clearly, B is very informative of A although ‖A−B‖ ≥ 9‖A‖. To avoid this pitfall, we measure ‖PBk A‖F /‖Ak‖F , where PBk is the projection on the top k left singular vectors of B. Here, Ak = P A k A is the optimal rank k approximation of A. Intuitively, this measures how well the top k left singular vectors of B capture A, compared to A’s own top-k left singular vectors. We also compute ‖AQBk ‖F /‖Ak‖F where QBk is the projection on the top k right singular vectors of A. Note that, for a given k, approximating the row-space is harder than approximating the column-space since it is of dimension n which is significantly larger than m, a fact also borne out in the experiments. In the experiments we made sure to choose a sufficiently wide range of sample sizes so that at least the best method for each matrix goes from poor to near-perfect both in approximating the row and the column space. In all cases we report on k = 20 which is close to the upper end of what could be efficiently computed on a single machine for matrices of this size. The results for all smaller values of k are qualitatively indistinguishable."
    }, {
      "heading" : "6.2 Insights",
      "text" : "The experiments demonstrate three main insights. First and most important, Bernstein-sampling is never worse than any of the other techniques and is often strictly better. A dramatic example of this is the Wikipedia matrix for which it is far superior to all other methods. The second insight is that L1-sampling, i.e., simply taking pij = |Aij |/‖A‖1, performs rather well in many cases. Hence, if it is impossible to perform more than one pass over the matrix and one can not even obtain an estimate of the ratios of the L1-weights of the rows, L1-sampling seems to be a highly viable option. The third insight is that for L2sampling, discarding small entries may drastically improve the performance. However, it is not clear which threshold should be chosen in advance. In any case, in all of the example matrices, both L1-sampling and Bernstein-sampling proved to outperform or perform equally to L2-sampling, even with the correct trimming threshold."
    }, {
      "heading" : "A Efficient Parallel Reservoir Sampling",
      "text" : "Assume we receive a stream of items each having weight wi. Further assume that we want to sample a single item from the stream with probability pi = wi/W where W = ∑ i wi. Reservoir sampling is the classic solution to this problem: select the very first item in the stream as the “current” sample and from then on have each successive item i replace the current sample with probability wi/Wi, where Wi = ∑ j≤i wj .\nAssume now that, instead, we wanted to take s > 1 items from the stream, but as if the stream was a set and we could sample it with replacement. One way to do this is to execute s independent reservoir samplers as above in parallel, as was pointed out in [DZ11]. This, however, requires O(s) active memory and O(s) randomized operations per item in the stream.\nIn the formation of the sketch matrix B a potentially large number of samples s = nnz(B) can make this approach impractical. Below we describe an algorithm that requires only O(log s) active memory and O(1) operations per item, instead of O(s) memory and O(s) operations per item, respectively. The first idea is to use the fact that samplers are independent. We can therefore simulate the process above by determining for each item, a, the (random) number of samplers, k, that would have replaced their current sample with a when it appeared. This random variable is Bernouli distributed and can be sampled efficiently. If this number is greater than zero, we write item a along with k to durable storage (disk) and process the next item in the stream. This processing generates a sketch of the stream on disk, the length of which can be shown to be bounded by O(s log(bN)), where b := maxi wi/mini wi. Here we can safely assume wi > 0.\nWhen the stream terminates, we process the sketch from end to beginning as follows: for each pair (a, k) we encounter in the sketch we process the k update operations as the throwing of k balls into s bins uniformly at random. This is because, whether item a replaces the current sample, a′, of a particular sampler is independent of a′. Notice that since we are going over the sketch backwards, the very first ball we place in a bin corresponds to the very last update of the sampler in the original execution. Thus, for each bin, we ignore all but the first ball placement and we stop as soon as each bin has received a ball (thus we also avoid simulating the “irrelevant” part of the naive computation). Performing this simulation only requires a bit-vector of length s in active memory.\nFinally, we can avoid even the cost of the bit-vector, as follows. Note that we do not care about the order of the samplers. Only the number of samplers that pick any item is important. Therefore, we can simply track the number of empty bins ` (samplers that are not committed yet) instead of the whole list and update it every time some balls fall into empty bins. The hypergeometric distribution hypergeometric(s, `, k) (see\nInput: An integer s and a stream (a1, w1), (a2, w2), ... W ← 0, T ← empty stack for (a,w) ∈ the stream do\nW ←W + w p = w/W k = binomial(s, p) . Number of reservoir samplers that would have picked item a. if k > 0 then\nPush (a, k) onto T\n` = s . ` holds the number of samplers that did not commit on an item yet. while ` > 0 do\n(a, k) = pop(T ) t = hypergeometric(s, `, k) if t > 0 then . t samplers committed to item a.\n` = `− t yield: (a, t)\ne.g [Ber07] for a more thorough overview) assigns each integer t probability ( ` t )( s−` k−t ) / ( s k ) . In words, assume we have s bins only ` of which are empty. If we throw k balls to k different bins uniformly at random, the number of balls that fall in empty bins distributes as hypergeometric(s, `, k)."
    } ],
    "references" : [ {
      "title" : "Fast algorithms for approximate semidefinite programming using the multiplicative weights update method",
      "author" : [ "Sanjeev Arora", "Elad Hazan", "Satyen Kale" ],
      "venue" : "In Foundations of Computer Science,",
      "citeRegEx" : "Arora et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Arora et al\\.",
      "year" : 2005
    }, {
      "title" : "A fast random sampling algorithm for sparsifying matrices. In Proceedings of the 9th international conference on Approximation Algorithms for Combinatorial Optimization Problems, and 10th international conference on Randomization and Computation, APPROX’06/RANDOM’06",
      "author" : [ "Sanjeev Arora", "Elad Hazan", "Satyen Kale" ],
      "venue" : null,
      "citeRegEx" : "Arora et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Arora et al\\.",
      "year" : 2006
    }, {
      "title" : "On the concentration of eigenvalues of random symmetric matrices. Israel",
      "author" : [ "Noga Alon", "Michael Krivelevich", "VanH. Vu" ],
      "venue" : "Journal of Mathematics,",
      "citeRegEx" : "Alon et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Alon et al\\.",
      "year" : 2002
    }, {
      "title" : "Fast computation of low rank matrix approximations",
      "author" : [ "Dimitris Achlioptas", "Frank McSherry" ],
      "venue" : "In Proceedings of the thirty-third annual ACM symposium on Theory of computing,",
      "citeRegEx" : "Achlioptas and McSherry.,? \\Q2001\\E",
      "shortCiteRegEx" : "Achlioptas and McSherry.",
      "year" : 2001
    }, {
      "title" : "Fast computation of low-rank matrix approximations",
      "author" : [ "Dimitris Achlioptas", "Frank Mcsherry" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "Achlioptas and Mcsherry.,? \\Q2007\\E",
      "shortCiteRegEx" : "Achlioptas and Mcsherry.",
      "year" : 2007
    }, {
      "title" : "Strong converse for identification via quantum channels",
      "author" : [ "Rudolf Ahlswede", "Andreas Winter" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "Ahlswede and Winter.,? \\Q2002\\E",
      "shortCiteRegEx" : "Ahlswede and Winter.",
      "year" : 2002
    }, {
      "title" : "Exact matrix completion via convex optimization",
      "author" : [ "Emmanuel J Candès", "Benjamin Recht" ],
      "venue" : "Foundations of Computational mathematics,",
      "citeRegEx" : "Candès and Recht.,? \\Q2009\\E",
      "shortCiteRegEx" : "Candès and Recht.",
      "year" : 2009
    }, {
      "title" : "The power of convex relaxation: Near-optimal matrix completion",
      "author" : [ "Emmanuel J Candès", "Terence Tao" ],
      "venue" : "Information Theory, IEEE Transactions on,",
      "citeRegEx" : "Candès and Tao.,? \\Q2010\\E",
      "shortCiteRegEx" : "Candès and Tao.",
      "year" : 2010
    }, {
      "title" : "Fast monte carlo algorithms for matrices; approximating matrix multiplication",
      "author" : [ "Petros Drineas", "Ravi Kannan", "Michael W. Mahoney" ],
      "venue" : "SIAM J. Comput.,",
      "citeRegEx" : "Drineas et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Drineas et al\\.",
      "year" : 2006
    }, {
      "title" : "A note on element-wise matrix sparsification via a matrixvalued bernstein inequality",
      "author" : [ "Petros Drineas", "Anastasios Zouzias" ],
      "venue" : "Inf. Process. Lett.,",
      "citeRegEx" : "Drineas and Zouzias.,? \\Q2011\\E",
      "shortCiteRegEx" : "Drineas and Zouzias.",
      "year" : 2011
    }, {
      "title" : "The eigenvalues of random symmetric matrices",
      "author" : [ "Z. Füredi", "J. Komlós" ],
      "venue" : null,
      "citeRegEx" : "Füredi and Komlós.,? \\Q1981\\E",
      "shortCiteRegEx" : "Füredi and Komlós.",
      "year" : 1981
    }, {
      "title" : "Error bounds for random matrix approximation schemes",
      "author" : [ "Alex Gittens", "Joel A Tropp" ],
      "venue" : "arXiv preprint arXiv:0911.4108,",
      "citeRegEx" : "Gittens and Tropp.,? \\Q2009\\E",
      "shortCiteRegEx" : "Gittens and Tropp.",
      "year" : 2009
    }, {
      "title" : "On the spectrum of a random graph. In Algebraic methods in graph theory, Vol. I, II (Szeged",
      "author" : [ "F. Juhász" ],
      "venue" : "Colloq. Math. Soc. János Bolyai,",
      "citeRegEx" : "Juhász.,? \\Q1981\\E",
      "shortCiteRegEx" : "Juhász.",
      "year" : 1981
    }, {
      "title" : "Matrix sparsification via the khintchine inequality",
      "author" : [ "NH Nguyen", "Petros Drineas", "TD Tran" ],
      "venue" : null,
      "citeRegEx" : "Nguyen et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Nguyen et al\\.",
      "year" : 2009
    }, {
      "title" : "Tensor sparsification via a bound on the spectral norm of random tensors",
      "author" : [ "Nam H Nguyen", "Petros Drineas", "Trac D Tran" ],
      "venue" : "arXiv preprint arXiv:1005.4732,",
      "citeRegEx" : "Nguyen et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Nguyen et al\\.",
      "year" : 2010
    }, {
      "title" : "Object retrieval with large vocabularies and fast spatial matching",
      "author" : [ "J. Philbin", "O. Chum", "M. Isard", "J. Sivic", "A. Zisserman" ],
      "venue" : "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
      "citeRegEx" : "Philbin et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Philbin et al\\.",
      "year" : 2007
    }, {
      "title" : "A simpler approach to matrix completion",
      "author" : [ "Benjamin Recht" ],
      "venue" : "J. Mach. Learn. Res.,",
      "citeRegEx" : "Recht.,? \\Q2011\\E",
      "shortCiteRegEx" : "Recht.",
      "year" : 2011
    }, {
      "title" : "Sampling from large matrices: An approach through geometric functional analysis",
      "author" : [ "Mark Rudelson", "Roman Vershynin" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "Rudelson and Vershynin.,? \\Q2007\\E",
      "shortCiteRegEx" : "Rudelson and Vershynin.",
      "year" : 2007
    }, {
      "title" : "The enronsent corpus",
      "author" : [ "Will Styler" ],
      "venue" : "Technical Report 01-2011,",
      "citeRegEx" : "Styler.,? \\Q2011\\E",
      "shortCiteRegEx" : "Styler.",
      "year" : 2011
    }, {
      "title" : "User-friendly tail bounds for sums of random matrices",
      "author" : [ "Joel A. Tropp" ],
      "venue" : "Foundations of Computational Mathematics,",
      "citeRegEx" : "Tropp.,? \\Q2012\\E",
      "shortCiteRegEx" : "Tropp.",
      "year" : 2012
    }, {
      "title" : "User-friendly tail bounds for sums of random matrices",
      "author" : [ "Joel A Tropp" ],
      "venue" : "Foundations of Computational Mathematics,",
      "citeRegEx" : "Tropp.,? \\Q2012\\E",
      "shortCiteRegEx" : "Tropp.",
      "year" : 2012
    }, {
      "title" : "On the distribution of the roots of certain symmetric matrices",
      "author" : [ "Eugene P. Wigner" ],
      "venue" : "Annals of Mathematics,",
      "citeRegEx" : "Wigner.,? \\Q1958\\E",
      "shortCiteRegEx" : "Wigner.",
      "year" : 1958
    } ],
    "referenceMentions" : [ ],
    "year" : 2013,
    "abstractText" : "We consider the problem of selecting non-zero entries of a matrix A in order to produce a sparse sketch of it, B, that minimizes ‖A−B‖2. For large m×n matrices, such that n m (for example, representing n observations over m attributes) we give sampling distributions that exhibit four important properties. First, they have closed forms computable from minimal information regarding A. Second, they allow sketching of matrices whose non-zeros are presented to the algorithm in arbitrary order as a stream, with O(1) computation per non-zero. Third, the resulting sketch matrices are not only sparse, but their non-zero entries are highly compressible. Lastly, and most importantly, under mild assumptions, our distributions are provably competitive with the optimal offline distribution. Note that the probabilities in the optimal offline distribution may be complex functions of all the entries in the matrix. Therefore, regardless of computational complexity, the optimal distribution might be impossible to compute in the streaming model.",
    "creator" : "LaTeX with hyperref package"
  }
}