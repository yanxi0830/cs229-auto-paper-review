{
  "name" : "1402.0915.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Learning Ordered Representations with Nested Dropout",
    "authors" : [ "Oren Rippel", "Michael A. Gelbart", "Ryan P. Adams" ],
    "emails" : [ "RIPPEL@MATH.MIT.EDU", "MGELBART@SEAS.HARVARD.EDU", "RPA@SEAS.HARVARD.EDU" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 2.\n09 15\nv1 [\nst at\n.M L\n] 5\nF eb"
    }, {
      "heading" : "1. Introduction",
      "text" : "The automatic discovery of representations is an increasingly important aspect of machine learning, motivated by a variety of considerations. For example, feature extraction is often a critical first step for supervised learning procedures. Representation learning enables one to avoid explicit feature engineering; indeed, approaches to deep feature\nlearning have often found representations that outperform their hand-crafted counterparts (e.g., Lecun & Bengio, 1995; Hinton & Salakhutdinov, 2006; Vincent et al., 2010; Coates et al., 2011). In other situations, unsupervised representation learning is useful for finding low-dimensional manifolds for visualization (e.g., Tenenbaum et al., 2000; Roweis & Saul, 2000; Van der Maaten & Hinton, 2008). There has also been increasing interest in exploiting such representations for information retrieval, leveraging the ability of unsupervised learning to discover compact and concise codes that can be used to build efficient data structures (e.g., Weiss et al., 2008; Salakhutdinov & Hinton, 2009; Krizhevsky & Hinton, 2011).\nOne frustration associated with current representation learning techniques, however, is redundancy from nonidentifiability in the resulting encoder/decoder. That is, under standard models such as autoencoders, restricted Boltzmann machines, and sparse coding, any given solution is part of an equivalence class of solutions that are equally optimal. This class emerges from the invariance of the models to various transformations of the parameters. Permutation is one clear example of such a transformation, leading to a combinatorial number of equivalent representations for a given dataset and architecture. There exist many more kinds of redundancies as well; the optimality of an autoencoder solution is preserved under any invertible linear transformation of the innermost set of weights (Bourlard & Kamp, 1987). This degeneracy also poses a difficulty when comparing experiments, due to the lack of repeatability: a solution attained by the optimization procedure is extremely sensitive to the choice of initialization.\nThis large number of equivalent representations has an advantage, however: it provides flexibility in architecture design. This freedom allows us to impose desirable structural constraints on the learned representations, without compromising their expressiveness. These constraints can imbue a number of useful properties, including the elimination of\npermutation non-identifiability. In this work we propose one such structural constraint: we specify a priori the quantity of information encapsulated in each dimension of the representation. This choice allows us to order the representation dimensions according to their information content.\nThe intuition behind our proposed approach to learning ordered representations is to train models such that the information contained in each dimension of the representation decreases as a function of the dimension index, following a pre-specified decay function. To this end, we introduce the nested dropout algorithm. As with the original dropout formulation (Hinton et al., 2012), nested dropout applies a stochastic mask over models. However, instead of imposing an independent distribution over each individual unit in a model, it assigns a distribution over nested subsets of representation units. More specifically, given a representation space of dimension K , we define a distribution pB(·) over the representation index subsets Sb = {1, . . . , b}, b = 1, . . . ,K. This has the property that if the j-th unit appears in a particular mask, then so do all “earlier” units 1, . . . , j − 1, allowing the j-th unit to depend on them. This nesting leads to an inherent ordering over the representation dimensions. The distribution pB(·) then governs the information capacity decay by modulating the relative frequencies of these masks.\nWe motivate such ordered representations in several ways:\nIdentifiability As discussed above, many current representation learning techniques suffer from nonidentifiability of the solutions. We can remedy this by introducing strict representation ordering, which enforces distinguishability. We rigorously demonstrate this for the simple case of a semi-linear autoencoder. We prove that the application of nested dropout leads to a significant reduction in the solution space complexity without harming the solution quality. Under an additional weak constraint, we further prove that the model has a single and unique global optimum. We show that this solution is exactly the set of eigenvalues of the covariance matrix of the data, ordered by eigenvalue magnitude. This demonstrates exact equivalence between semi-linear nested dropout autoencoders and principal component analysis (PCA).\nFast retrieval Current information retrieval procedures suffer from an intrinsic tradeoff between search speed and quality: representation dimensionality and dataset size must be sacrificed to gain search tractability (Grauman & Fergus (2013) offers an excellent overview of modern retrieval procedures). Given a query datum, a naı̈ve brute force retrieval based on Hamming distance requires a linear scan of the database, which has complexity O (KN) where K is the code length and N the database size. Semantic hashing (Salakhutdinov & Hinton, 2009) retrieves\nexamples within a Hamming neighborhood of radius R by directly scanning through all memory locations associated with them. This results in retrieval time complexity O( (\nK R\n)\n). While this is independent of the database size, it grows rapidly in K and therefore is computationally prohibitive even for codes tens of bits long; code length of 50 bits, for example, requires a petabyte of memory be addressed. Moreover, as the code length increases, it becomes very likely that many queries will not find any neighbors for any feasible radii. Locality sensitive hashing (Datar et al., 2004) seeks to preserve distance information by means of random projections; however, this can lead to very inefficient codes for high input dimensionality.\nBy imposing an ordering on the information represented in a deep model, we can learn hash functions that permit efficient retrieval. Because the importance of each successive coding dimension decays as we move through the ordering, we can naturally construct a binary tree data structure on the representation to capture a coarse-to-fine notion of similarity. This allows retrieval in time that is logarithmic with the dataset size and independent of the representation space dimensionality: the retrieval procedure adaptively selects the minimum number of code bits required for resolution. This enables very fast retrieval on large databases without sacrificing representation quality: we are able to consider codes hundreds of times longer than currently feasible with existing retrieval methods. For example, we perform retrieval on a dataset of a million entries of code length 2048 in an average time of 200µs per query—15,000 times faster than a linear scan or semantic hashing.\nAdaptive compression Ordered representations can also be used for “continuous-degradation” lossy compression systems: they give rise to a continuous range of bitrate/quality combinations, where each additional bit corresponds to a small incremental increase in quality. This property can in principle be applied to problems such as video streaming. The representation only needs to be encoded a single time; then, users of different bandwidths can be adaptively sent codes of different length that exactly match their bitrates. The inputs can then be reconstructed optimally for the users’ channel capacities."
    }, {
      "heading" : "2. Ordering with nested dropout",
      "text" : "Dropout (Hinton et al., 2012) is a regularization technique for neural networks that adds stochasticity to the architecture during training. At each iteration, unbiased coins are flipped independently for each unit in the network, determining whether it is “dropped” or not. Every dropped unit is deleted from the network for that iteration, and an optimization step is taken with respect to the resulting network.\nNested dropout diverges from this in two main ways. First,\nwe only drop units in the representation space. Second, instead of flipping independent coins for different units, we instead assign a prior distribution pB(·) over the representation indices 1, . . . ,K . We then sample an index b ∼ pB(·) and drop units b+ 1, . . . ,K. The sampled units then form nested subsets: if unit j appears in a network sample, then so do units 1, . . . , j − 1. This nesting results in an inherent importance ranking of the representation dimensions, as a particular unit can always rely on the presence of its predecessors. For pB(·) we select a geometric distribution: pB(b) = ρb−1(1− ρ). We make this choice due to the exponential decay of this distribution and its memoryless property (see Section 4.4).\nOur architecture resembles an autoencoder in its parametric composition of an encoder and a decoder. We are given a set of N training examples {yn}Nn=1 lying in space Y ⊆ RD . We then transform the data into the representation space X ⊆ RK via a parametric transformation fΘ : Y → X. We denote this function as the encoder, and label the representations as {xn}Nn=1 ⊂ X. The decoder map gΨ : X → Y then reconstructs the inputs from their representations as {ŷn}Nn=1.\nA single nested dropout sample Let us assume that we sample some b ∼ pB(·) and drop the last K − b representation units; we refer to this case as the b-truncation. This structure is equivalent to an autoencoder with a representation layer of dimension b. For a given representation x ∈ RK , we define x↓b as the truncation of vector x, namely a copy of x where the last K − b units are removed, or are equivalently set to 0.\nDenoting the reconstruction of the b-truncation as ŷ↓b = gΨ(fΘ(y)↓b), the reconstruction cost function associated with a b-truncation is then\nC↓b(Θ,Ψ) = 1\nN\nN ∑\nn=1\nL (yn, ŷn↓b) . (1)\nIn this work, we take the reconstruction loss L(·, ·) to be the L2 norm. Although we write this cost as a function of the full parametrization (Θ,Ψ), due to the truncation only a subset of the parameters will contribute to the objective.\nThe nested dropout problem Given our distribution pB(·), we consider the mixture of the different btruncation objectives:\nC(Θ,Ψ)=EB [C↓b(Θ,Ψ)]=\nK ∑\nb=1\npB(b)C↓b(Θ,Ψ). (2)\nWe formulate the nested dropout problem as the optimization of this mixture with respect to the model parameters:\n(Θ∗,Ψ∗) = argmin Θ,Ψ C(Θ,Ψ) . (3)"
    }, {
      "heading" : "2.1. Interpretation",
      "text" : "Nested dropout has a natural interpretation in terms of information content in representation units. It was shown by Vincent et al. (2010) that training an autoencoder corresponds to maximizing a lower bound on the mutual information I(y;x) between the input data and their representations. Specifically, the objective of the b-truncation problem can be written in the form\nC↓b(Θ,Ψ) ≈ Ey [ − log pY |X↓b (y |fΘ(y)↓b ; Ψ) ] (4)\nwhere we assume our data are sampled from the true distribution pY (·). The choice pY |X (y |x ; Ψ) = N (y ; gΨ(x), σ 2 ID), for example, leads to the familiar autoencoder L2 reconstruction penalty.\nNow, define Ĩb(y;x) := −C↓b(Θ,Ψ) ≤ I(y;x) as the approximation of the true mutual information which we maximize for a given b. Then we can write the (negative) nested dropout problem in the form of a telescopic sum:\n−C(Θ,Ψ) = K ∑\nb=1\npB(b)Ĩb(y;x) (5)\n= Ĩ1(y;x) + K ∑\nb=2\n[FB(K)− FB(b − 1)]∆b ,\nwhere FB(b) = ∑b b′=1 pB(b ′) is the cumulative distribution function of pB(·) , and ∆b := Ĩb(y;x) − Ĩb−1(y;x) is the marginal information gained from increasing the representation dimensionality from b units to b + 1.\nThis formulation provides a connection between the nested dropout objective and the optimal distribution of information across the representation dimensions. Note that the coefficients FB(K)− FB(b) of the marginal mutual information are positive and monotonically decrease as a function of b regardless of the choice of distribution pB(·). This establishes the ordering property intuitively sought by the nested dropout idea. We also see that if for some b we have pB(b) = 0, i.e., index b has no support under pB(·), then the ordering of representation dimensions b and b− 1 no longer matters. If we set pB(1) = 0, . . . , pB(K − 1) = 0 and pB(K) = 1, we recover the original order-free autoencoder formulation for K latent dimensions. In order to achieve strict ordering, then, the only assumption we must make is that pB(·) has support over all representation indices. Indeed, this will be a sufficient condition for our proofs in Section 3.2. Equation (5) informs us of how our prior choice of pB(·) dictates the optimal information allocation per unit."
    }, {
      "heading" : "3. Exact recovery of PCA",
      "text" : "In this section, we apply nested dropout to a semi-linear autoencoder. This model has a linear or a sigmoidal encoder,\nand a linear decoder. The relative simplicity of this case allows us to rigorously study the ordering property implied by nested dropout.\nFirst, we show that the class of optimal solutions of the nested dropout autoencoder is a subset of the class of optimal solutions of a standard autoencoder. This means that introducing nested dropout does not sacrifice the quality of the autoencoder solution. Second, we show that equipping an autoencoder with nested dropout significantly constrains its class of optimal solutions. We characterize these restrictions. Last, we show that under an additional orthonormality constraint, the model features a single, unique solution that is exactly the set of K eigenvectors with the largest magnitudes arising from the covariance matrix of the inputs, ordered by decreasing eigenvalue magnitude. Hence this recovers the PCA solution exactly. This is in contrast to a standard autoencoder, which recovers the PCA solution up to an invertible linear map."
    }, {
      "heading" : "3.1. Problem definitions and prior results",
      "text" : "The standard linear autoencoder problem Given our inputs, we apply the linear encoder fΘ(y) := Ωy + ω with parameters Ω ∈ RK×D and bias vector ω ∈ RK for K ≤ D. Our proofs further generalize to sigmoidal nonlinearities applied to the output of the encoder, but we omit these for clarity. The decoder map gΨ : X → Y is similarly taken to be gΨ(x) := Γx+ γ with parameters Γ ∈ RD×K and γ ∈ RD. We also define the design matrices Y and X whose columns consist of the observations and their representations, respectively.\nThe reconstruction of each datum is then defined as the composition of the encoder and decoder maps. Namely, ŷn = Γ(Ωyn + ω) + γ ∀n = 1, . . . , N . A semi-linear autoencoder seeks to minimize the reconstruction cost\nC(Θ,Ψ) =\nN ∑\nn=1\n‖yn − gΨ(fΘ(yn))‖ 2 (6)\n= ‖Y − (Γ(ΩY + ω) + γ)‖2F (7)\nwhere by ‖·‖F we denote the Frobenius matrix norm. From this point on, without loss of generality we assume that ω = 0, γ = 0, and that the data is zero-centered. All our results hold otherwise, but with added shifting constants.\nA single b-truncation problem We continue to consider the b-truncation problem, where the last K − b units of the representation are dropped. As before, for a given representation x ∈ RK , we define x↓b to be the truncation of vector x. Defining the truncation matrix Jm→n ∈ Rn×m as [Jm→n]ab = δab, then x↓b = JK→bx. The decoder is then written as gΨ↓b(x↓b) = Γ↓bx↓b, where we write Γ↓b = ΓJ T K→b in which the last K − b columns of Γ are\nremoved. The reconstruction cost function associated with a b-truncation is then\nC↓b(Θ↓b,Ψ↓b) = ‖Y − Γ↓bX↓b‖ 2 F . (8)\nWe define (Θ∗↓b,Ψ ∗ ↓b) = argminΘ↓b,Ψ↓b C↓b(Θ↓b,Ψ↓b) to be an optimal solution of the b-truncation problem; we label the corresponding optimal cost as C∗↓b. Also, let V Y = Y Y T be (proportional to) the empirical covariance matrix of {yn}Nn=1 with eigendecompositionV Y = QΣ\n2QT , whereΣ2 is the diagonal matrix constituting of the eigenvalues arranged in decreasing magnitude order, and Q the orthonormal matrix of the respective eigenvectors. Similarly, let R be the orthonormal eigenvector matrix of Y TY , arranged by decreasing order of eigenvalue magnitude.\nThe b-truncation problem exactly corresponds to the original semi-linear autoencoder problem, where the representation dimension is taken to be b in the first place. As such, we can apply known results about the form of the solution of a standard autoencoder. It was proven in Bourlard & Kamp (1987) that this optimal solution must be of the form\nX∗b = T bΣ↓bR T Γ∗b = Q↓bT −1 b (9)\nwhere T b ∈ Rb×b is an invertible matrix, Σ↓b = JK→bΣ ∈ Rb×D the matrix with the b largestmagnitude eigenvalues, and Q↓b = QJ T K→b ∈ R D×b the matrix with the b corresponding eigenvectors. This result was established for an autoencoder of representation dimension b; we reformulated the notation to suit the nested dropout problem we define in the next subsection.\nIt can be observed from Equation (9) that the semi-linear autoencoder has a strong connection to PCA. An autoencoder discovers the eigenvectors of the empirical covariance matrix of {yn}Nn=1 corresponding to its b eigenvalues of greatest magnitude; however, this is up to to an invertible linear transformation. This class includes rotations, scalings, reflections, index permutations, and so on. This nonidentifiability has an undesirable consequence: it begets a huge class of optimal solutions.\nThe nested dropout problem We now introduce the nested dropout problem. Here, we assign the distribution b ∼ pB(·) as a prior over b-truncations. For our proofs to hold our only assumption about this distribution is that it has support over the entire index set, i.e., pB(b) > 0, ∀b = 1, . . . ,K. To that end, we seek to minimize the nested dropout cost function, which we define as\nthe mixture of the K truncated models under pB(·):\nC(Θ,Ψ) = EB\n[\n‖Y − Γ↓bX↓b‖ 2 F\n]\n(10)\n=\nK ∑\nb=1\npB(b) ‖Y − Γ↓bX↓b‖ 2 F . (11)"
    }, {
      "heading" : "3.2. The nested dropout problem recovers PCA exactly",
      "text" : "Below we provide theoretical justification for the claims made in the beginning of this section. All of the proofs can be found in the appendix of this paper.\nTheorem 1. Every optimal solution of the nested dropout problem is necessarily an optimal solution of the standard autoencoder problem.\nDefinition. We define matrix T ∈ RK×K to be commutative in its truncation and inversion if each of its leading principal minors JK→bTJ T K→b, b = 1, . . . ,K is invertible, and the inverse of each of its leading principal minors is equal to the leading principal minor of the inverse T−1, namely\nJK→bT −1JTK→b = (JK→bTJ T K→b) −1 . (12)\nThe below theorem, combined with Lemma 1, establishes tight constraints on the class of optimal solutions of the nested dropout problem. For example, an immediate corollary of this is that T cannot be a permutation matrix, as for such a matrix there must exist some leading principal minor that is not invertible.\nTheorem 2. Every optimal solution of the nested dropout problem must be of the form\nX∗ = TΣRT Γ∗ = QT−1 , (13)\nfor some matrixT ∈ RK×K that is commutative in its truncation and inversion.\nDenote the column and row submatrices, respectively as Ab = [T1b, . . . , T(b−1),b] T and Bb = [Tb1, . . . , Tb,(b−1)]T . Lemma 1. Let T ∈ RK×K be commutative in its truncation and inversion. Then all the diagonal elements of T are nonzero, and for each b = 2, . . . ,K , either Ab = 0 or Bb = 0.\nIn the result below we see that nested dropout coupled with an orthonormality constraint effectively eliminates nonidentifiability. The added constraint pins down any possible rotations and scalings.\nTheorem 3. Under the orthonormality constraint ΓTΓ = IK , the nested dropout problem features a unique global optimum, and this solution is exactly the set of the K top eigenvectors of the covariance of Y , ordered by eigenvalue magnitude. Namely, X∗ = ΣRT ,Γ∗ = Q."
    }, {
      "heading" : "4. Training deep models with nested dropout",
      "text" : "In this section we discuss our extension of the nested dropout approach to deep architectures. Specifically, we applied this to deep autoencoders having tens of millions of parameters, which we trained on the 80 Million Tiny Images (80MTI) dataset (Torralba et al., 2008) on a cluster of GPUs. Training models with nested dropout introduces a number of unconventional technical challenges. In the proceeding sections we describe these challenges, and discuss strategies to overcome them.\nWe first describe our general architecture and optimization setup. The 80MTI are 79,302,017 color images of size 32× 32. We pre-processed the data by subtracting from each pixel its mean and normalizing by its variance across the dataset. We optimize our models with the nonlinear conjugate gradients algorithm and select step sizes using a strong Wolfe conditions line search. For retrieval-related tasks, we seek to produce binary representations. In light of this we use rectified linear units for all nonlinarities in our encoder, as we find this leads to better binarized representation (see Subsection 4.3). Glorot et al. (2011) features an in-depth discussion and motivation of rectified linear units. We train for 2 epochs on minibatches of size 10,000. We inject noise to promote robustness, as in (Vincent et al., 2010); namely, with probability 0.1 we independently corrupt input elements to 0. For all layers other than the representation layer, we apply standard dropout with probability 0.2. At each iteration, we sample nested dropout truncation indices for each example in our minibatch, and take a step with respect to the corresponding network mask."
    }, {
      "heading" : "4.1. Unit sweeping for decaying gradients",
      "text" : "By the virtue of the decaying distribution pB(·), it becomes increasingly improbable to sample higher representation indices during training. As such, we encounter a phenomenon where gradient magnitudes vanish as a function of representation unit index. This curvature pathology, in its raw formulation, means that training representation units of higher index can be extremely slow.\nIn order to combat this effect, we develop a technique we call unit sweeping. The idea stems from the observation that the covariance of two latent units sharply decreases as a function of the of the difference of their indices. When pB(·) is a geometric distribution, for example, the probability of observing both units i and j given that one of them is observed is P[b≥max(i, j) | b≥min(i, j)] = P[b≥|i−j|] = ρ−|i−j| by the memoryless property of the distribution. In other words, a particular latent unit becomes exponentially desensitized to values of units of higher index. As such, this unit will eventually converge during its training. Upon convergence, then, this unit can be fixed in place and its associated gradients can be omitted. Loosely speaking, this elimination reduces the “condition number” of the optimization. Applying this iteratively, we sweep through the latent units, fixing each once it converges. In Figure 1 we compare filters from training a nested dropout model with and without unit sweeping."
    }, {
      "heading" : "4.2. Adaptive regularization coefficients",
      "text" : "The gradient decay as a function of representation index poses a difficulty for regularization. In particular, the ratio of the magnitudes of the gradients of the reconstruction and the regularization vanishes as a function of the index. Therefore, a single regularization term such as λ\n∑K k=1 ‖Ωk‖L1 would not be appropriate for nested dropout, since the regularization gradient would dominate the high-index gradients. As such, the regularization must be decoupled as a function of representation index. For weight decay, for example, this would of the form ∑K\nk=1 λk ‖Ωk‖L1 . Choosing the coefficients λk manually is challenging, and to that end we assign them adaptively. We do this by fixing in advance the ratio between the magnitude of the reconstruction gradient and the regularization gradient, and choosing the λk to satisfy this ratio requirement. This corresponds to fixing the relative contributions of the terms at each step in the optimization procedure."
    }, {
      "heading" : "4.3. Code binarization",
      "text" : "For the task of retrieval, we would like to obtain binary representations. Several binarization methods have been proposed in prior work (Salakhutdinov & Hinton, 2009; Krizhevsky & Hinton, 2011). We have empirically\nachieved good performance by tying the weights of the encoder and decoder, and thresholding at the representation layer. Although the gradient itself cannot propagate past this threshold, some signal does: the encoder can be trained since it is linked to the decoder, and its modifications are then reflected in the objective. To attain fixed marginal distributions over the binarized representation units, i.e., xk ∼ Bern(β) for k = 1, . . . ,K, we compute the β quantile for each unit, and use this value for thresholding."
    }, {
      "heading" : "4.4. Code invariance",
      "text" : "We attain better retrieval results when we demand code invariance. That is, when we require that similar examples map to similar codes. Inspired by Rifai et al. (2011b;a), we perform this regularization stochastically by perturbing each input yn in our minibatch with some small εn ∼ N (0, ε̄ID), and introduce penalty term\nI = 1\nN\nN ∑\nn=1\n‖fΘ(yn + εn)− fΘ(yn)‖ 2\n‖εn‖ 2 . (14)\nIt can be shown via Taylor expansion that this corresponds to a stochastic formulation of the regularization of the Frobenius norm of the Jacobian of fΘ(·)."
    }, {
      "heading" : "5. Retrieval with ordered binary codes",
      "text" : "In this section we discuss how ordered representations can be exploited to construct data structures that permit fast retrieval while at the same time allowing for very long codes."
    }, {
      "heading" : "5.1. Binary tree on the representation space",
      "text" : "The ordering property, coupled with the ability to control information capacity decay across representation units, motivates the construction of a binary tree over large data sets. Each node in this tree contains pointers to the set of examples that share the same path down the tree up to that point. Guaranteeing that this tree is balanced is not feasible, as this is equivalent to completely characterizing the joint distribution over the representation space. However, by the properties of the training algorithm, we are able to\nfix the marginal distributions of all the representation bits as xk ∼ Bern(β) for some hyperparameter β ∈ (0, 1).\nConsistent with the training procedure, we encode our database as X = {xn}Nn=1 ⊆ {0, 1}\nK , xn = fΘ(yn). We then construct a binary tree on the resulting codes.\nGiven a query ȳ, we first encode it as x̄ = fΘ(ȳn). We then conduct retrieval by traveling down the binary tree with each decision determined by the next bit of x̄. We define the b-truncated Hamming neighborhood of x̄ as the set of all examples whose codes share the first b bits of x̄:\nNHb (x̄) = { y ∈ Y : ‖x↓b − x̄↓b‖H = 0 } . (15)\nIt is clear that NHb+1(x̄) ⊆ N H b (x̄) ∀b = 1, . . . ,K−1. Our retrieval procedure then corresponds to iterating through this family of nested neighborhoods. We expect the cardinality of these to decay approximately exponentially as a function of index. We terminate the retrieval procedure when ∣\n∣NHb (x̄) ∣\n∣ < R for some pre-specified terminal neighborhood cardinality, R ∈ N. It outputs the set NHb−1(x̄).\nAssuming marginals xk ∼ Bern(β) and neglecting dependence between the xk, this results in expected retrieval time O( logN/RH(Bern(β))) where H(Bern(β)) is the Bernoulli entropy. If β = 12 , for example, this reduces to the balanced tree travel time O(logN/R). This retrieval time is logarithmic in the database size N , and independent of the representation space dimensionality K . If one wishes to retrieve a fixed fraction of the dataset, this renders the retrieval complexity also independent of the dataset size.\nIn many existing retrieval methods, the similarity of two examples is measured by their Hamming distance. Here, similarity is rather measured by the number of leading bits they share. This is consistent with the training procedure, which produces codes with this property by demanding reconstructive ability under code truncation variation."
    }, {
      "heading" : "5.2. Empirical results",
      "text" : "We empirically studied the properties of the resulting codes and data structures in a number of ways. First, we applied ordered retrieval to a toy problem where we trained a tiny 2-16-32-16-2 autoencoder on 2D synthetic pinwheel data (Figure 2). Here we can visualize the nesting of neighborhood families for different queries. Note that, as expected, the nested neighborhood boundaries are orthogonal to the direction of local variation of the data. This follows from the model’s reconstruction loss function.\nWe then trained on 80MTI a binarized nested dropout autoencoder with layer widths 3072-2048-1024-512-1024- 2048-3072 with L1 weight decay and invariance regularization (see Section 4.4). We chose pB(·) ∼ Geom(0.97) and the binarization quantile β = 0.2.\nEmpirical retrieval speeds for various models are shown in Figure 3. We performed retrieval by measuring Hamming distance in a linear scan over the database, and by means of semantic hashing for a number of radii. We also performed ordered retrieval for a number of terminal neighborhood cardinalities. Although semantic hashing is independent of the database size, for a radius greater than 2 it requires more time than a brute force linear scan even for very short codes. In addition, as the code length increases, it becomes very likely that many queries will not find any neighbors for any feasible radii. It can be seen that ordered retrieval carries a very small computational cost which is independent of the code length. Note that each multiplicative variation in the terminal neighborhood size R, from 2 to 32 to 512, leads to a constant shift downward on the logarithmic scale plot. This observation is consistent with our earlier analysis that the retrieval time increases logarithmically with N/R.\nIn Figure 4, we show retrieval results for varying terminal neighborhood sizes. As we decrease the terminal neighborhood size, the similarity of the retrieved data to the query increases. As more bits are added to the representation in the process of retrieval, the resolution of the query increases, and thus it is better resolved from similar images."
    }, {
      "heading" : "6. Adaptive compression",
      "text" : "Another application of ordered representations is continuous-degradation lossy compression systems. By “continuous-degradation” we mean that the message can be decoded for any number, b, of bits received, and that the reconstruction error L(y, ŷ↓b) decreases monotonically with b. Such representations give rise to a continuous (up to a single bit) range of bitrate-quality combinations, where each additional bit corresponds to a small incremental increase in quality.\nThe continuous-degradation property is appealing in many situations. First, consider, a digital video signal that is broadcast to recipients with varying bandwidths. Assume further that the probability distribution over bandwidths for the population, pB(·), is known or can be estimated, and that a recipient with bandwidth b receives only the first b bits of the transmission. We can then pose the following problem: what broadcast signal minimizes the expected distortion over the population? This is formulated as\n(Θ∗,Ψ∗) = argmin Θ,Ψ EB [L (yn, ŷn↓b)] . (16)\nThis is precisely the optimization problem solved by our model; Equation (16) is simply a rewriting of Equation (3). This connection gives rise to an interpretation of pB(·), which we have set to the geometric distribution in our experiments. In particular, pB(·) can be interpreted as the distribution over recipient bandwidths such that the system minimizes the expected reconstruction error.\nThis intuition in principle applies as well to online video streaming, in which the transmitted signal is destined for only a single recipient. Given that different recipients have different bandwidths, it is acceptable to lower the image quality in order to attain real-time video buffering. Currently, one may specify in advance a small number of fixed encodings for various bandwidths: for example, YouTube offers seven different definitions (240p, 360p, 480p, 720p, 1080p, 1440p, and 2160p), and automatically selects one of these to match the viewer’s bitrate. Ordered representations\noffer the ability to fully utilize the recipient’s bandwidth by truncating the signal to highest possible bitrate. Instead of compressing a handful of variants, one needs only to compute the ordered representation once in advance, and truncate it to the appropriate length at transmission time. If this desired bitrate changes over time, the quality could be correspondingly adjusted in a smooth fashion. As above, given a distribution pB(·) of bandwidths, finding the ordered representation that solves Equation (16) minimizes the expected distortion over a population of recipients."
    }, {
      "heading" : "6.1. Empirical results",
      "text" : "In Figure 5(a), we qualitatively evaluate continuousdegradation lossy compression with ordered representations. We trained a single-layer 3072-1024-3072 autoencoder with nested dropout on CIFAR-10, and produced reconstructions for different code lengths. Each column represents a different image and each row represents a different code length. As the code length increases (downwards in the figure), the reconstruction quality increases. The images second-to-bottom row look very similar to the original uncompressed images in the bottom row (24576 bits each).\nFigure 5(b) shows ordered representation reconstruction rates as a function of code length for different approaches to the problem. In addition to the above, we also trained a standard autoencoder with the same architecture but without nested dropout. On this we applied 2 different truncation approaches. The first is a simple truncation on the unordered bits. The second is Optimal Brain Damage truncation (LeCun et al., 1990), which removes units in decreasing order of their influence on the reconstruction objective, measured in terms of the first and second order terms in its Taylor expansion. This is a clever way of ordering units, but is disjoint from the training procedure and is only applied retroactively. We also compare with JPEG compres-\nsion. We use the libjpeg library and vary the JPEG quality parameter. Higher quality parameters result in larger file sizes and lower reconstruction error. Note that JPEG is not suited for the 32x32 pixel images we use in this study; its assumptions about the spectra of natural images are violated by such highly down sampled images which have lost significant low frequency content. When the quality is extended to its maximum, the loss is approximately 0.0003, in the same units (not shown)."
    }, {
      "heading" : "7. Discussion and future work",
      "text" : "We have presented a novel technique for learning representations in which the dimensions have a known ordering. This procedure is exactly equivalent to PCA for shallow autoencoders, but can generalize to deep networks as well. This enables learned representations of data that are adaptive in the sense that they can be truncated with the assurance that the shorter codes contain as much information as possible. Such codes are of interest in applications such as retrieval and compression.\nThe ordered representation retrieval approach can also be used for efficient supervised learning. Namely, it allows performing k-nearest-neighbors on very long codes in logarithmic time in their cardinality. This idea can be combined with various existing approaches to metric learning of kNN and binarized representations (Norouzi et al., 2012; Salakhutdinov & Hinton, 2007; Weinberger & Saul, 2009). The purely unsupervised approaches we have described here have not been empirically competitive with state of the art supervised methods from deep learning. We are optimistic that nested dropout can be meaningfully combined with supervised learning, but leave that for future work.\nWe also note that ordered representations provide insight into how one might practically train models with an infinite number of latent dimensions, in the spirit of Bayesian nonparametric methods. For example, the distribution pB(·) can be chosen to have infinite support, while having finite mean and variance. Finally, the nesting idea can be generalized to more complicated dependency structures, such as those described in Tarlow et al. (2012).\nAcknowledgements We are grateful to Hugo Larochelle for insightful conversations. This work was partially funded by DARPA Young Faculty Award N66001-12-14219."
    }, {
      "heading" : "Appendix A. Proofs for Section 3.2",
      "text" : "Theorem 1. Every optimal solution of the nested dropout problem is necessarily an optimal solution of the standard autoencoder problem.\nProof. Let the nested dropout autoencoder be of latent dimension K . Recall that the nested dropout objective function in Equation (11) is a strictly positive mixture of the K different b-truncation problems. As described in Subsection 3.1, an optimal solution to each b-truncation must be of the form X∗b = T bΣ↓bR T ,Γ∗b = Q↓bT −1 b for some invertible transformation T b. We note that the PCA decomposition is a particular optimal solution for each b that is given for the choice T b = Ib. As such, the PCA decomposition exactly minimizes every term in the nested dropout mixture, and therefore must be a global solution of the nested dropout problem. This means that every optimal solution of the nested dropout problem must exactly minimize every term in the nested dropout mixture. In particular, one of these terms corresponds to the K-truncation problem, which is in fact the original autoencoder problem.\nDenote T ↓b = JK→bTJ T K→b as the b-th leading principal minor and its its bottom right corner as tb = Tbb. Lemma 1. Let T ∈ RK×K be commutative in its truncation and inversion. Then all the diagonal elements of T are nonzero, and for each b = 2, . . . ,K , either Ab = 0 or Bb = 0.\nProof. We have detT ↓b = detT ↓b−1 det(tb − BbT −1 ↓b−1Ab) 6= 0 since T ↓b−1 is invertible. Since T ↓b−1 is also invertible, then tb − BbT −1 ↓b−1Ab 6= 0. As such, we write T ↓b in terms of blocks T ↓b−1,Ab,Bb, tb, and apply blockwise matrix inversion to find that T−1↓b−1 = T−1↓b−1 + T −1 ↓b−1Ab(tb −BbT −1 ↓b−1Ab) −1BbT −1 ↓b−1 which reduces to AbBb = 0. Now, assume by contradiction that tb = 0. This means that either bottom row or the rightmost column of T ↓b must be all zeros, which contradicts with the invertibility of T ↓b.\nTheorem 2. Every optimal solution of the nested dropout problem must be of the form\nX∗ = TΣRT (17)\nΓ∗ = QT−1 , (18)\nfor some matrix T ∈ RK×K that is commutative in its truncation and inversion.\nProof. Consider an optimal solution X∗,Γ∗ of the nested dropout problem. For each b-truncation, as established in the proof of Theorem 1, it must hold that\nX∗b = T bJK→bΣR T (19)\nΓ∗b = QJ T K→bT −1 b . (20)\nHowever, it must also be true that Xb = X↓b,Γb = Γ↓b by the definition of the nested dropout objective in Equation (11). The first equation thus gives that T bJK→b =\nJK→bTK , and therefore T b = JK→bTKJ T K→b = T ↓b. This establishes the fact that the optimal solution for each b-truncation problem simply draws the b-th leading principal minor from the same “global” matrix T := TK . The second equation implies that for every b, it holds that JK→bT −1JTK→b = (JK→bTJ T K→b)\n−1 and as such T is commutative in its truncation and inversion.\nTheorem 3. Under the orthonormality constraint ΓTΓ = IK , there exists a unique optimal solution for the nested dropout problem, and this solution is exactly the set of the K top eigenvectors of the covariance of Y , ordered by eigenvalue magnitude. Namely, X∗ = ΣRT ,Γ∗ = Q.\nProof. The orthonormality constraint implies (T−1Q)TQT−1 = IK which gives T\nT = T−1. Hence every row and every column must have unit norm. We also have have that for every b = 1, . . . ,K\nT T↓b = (JK→bTJ T K→b) T (21)\n= JK→bT TJTK→b (22) = JK→bT −1JTK→b (23) = (JK→bTJ T K→b) −1 (24) = T−1↓b (25)\nwhere in the last equation we applied Lemma 1 to Theorem 2. As such, every leading principal minor is also orthonormal. For the sake of contradiction, assume there exist some m,n,m 6= n such that Tmn 6= 0. Without loss of generality assume m < n. Then\n∑n−1 p=1 T 2 mp < 1, but this violates\nthe orthonormality of T n−1. Thus it must be that the diagonal elements of T are all identically 1, and therefore T = IK . The result follows."
    } ],
    "references" : [ {
      "title" : "Auto-association by multilayer perceptrons and singular value decomposition",
      "author" : [ "H. Bourlard", "Y. Kamp" ],
      "venue" : "Manuscript M217,",
      "citeRegEx" : "Bourlard and Kamp,? \\Q1987\\E",
      "shortCiteRegEx" : "Bourlard and Kamp",
      "year" : 1987
    }, {
      "title" : "An analysis of singlelayer networks in unsupervised feature learning",
      "author" : [ "A. Coates", "H. Lee", "A.Y. Ng" ],
      "venue" : "In Proc. of AISTATS,",
      "citeRegEx" : "Coates et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Coates et al\\.",
      "year" : 2011
    }, {
      "title" : "Locality-sensitive hashing scheme based on p-stable distributions",
      "author" : [ "Datar", "Mayur", "Immorlica", "Nicole", "Indyk", "Piotr", "Mirrokni", "Vahab S" ],
      "venue" : "In Proceedings of the Twentieth Annual Symposium on Computational Geometry,",
      "citeRegEx" : "Datar et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Datar et al\\.",
      "year" : 2004
    }, {
      "title" : "Deep sparse rectifier neural networks",
      "author" : [ "Glorot", "Xavier", "Bordes", "Antoine", "Bengio", "Yoshua" ],
      "venue" : "In Proc. of AISTATS,",
      "citeRegEx" : "Glorot et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Glorot et al\\.",
      "year" : 2011
    }, {
      "title" : "Learning binary hash codes for large-scale image search. In Machine Learning for Computer Vision, volume 411 of Studies in Computational Intelligence, pp. 49–87",
      "author" : [ "Grauman", "Kristen", "Fergus", "Rob" ],
      "venue" : null,
      "citeRegEx" : "Grauman et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Grauman et al\\.",
      "year" : 2013
    }, {
      "title" : "Reducing the dimensionality of data with neural networks",
      "author" : [ "G E Hinton", "Salakhutdinov", "R R" ],
      "venue" : "Science,",
      "citeRegEx" : "Hinton et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Hinton et al\\.",
      "year" : 2006
    }, {
      "title" : "Improving neural networks by preventing co-adaptation of feature detectors",
      "author" : [ "Hinton", "Geoffrey E", "Srivastava", "Nitish", "Krizhevsky", "Alex", "Sutskever", "Ilya", "Salakhutdinov", "Ruslan" ],
      "venue" : null,
      "citeRegEx" : "Hinton et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hinton et al\\.",
      "year" : 2012
    }, {
      "title" : "Using very deep autoencoders for content-based image retrieval",
      "author" : [ "Krizhevsky", "Alex", "Hinton", "Geoffrey E" ],
      "venue" : "In ESANN,",
      "citeRegEx" : "Krizhevsky et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Krizhevsky et al\\.",
      "year" : 2011
    }, {
      "title" : "Convolutional Networks for Images, Speech and Time Series, pp. 255–258",
      "author" : [ "Lecun", "Yann", "Bengio", "Yoshua" ],
      "venue" : null,
      "citeRegEx" : "Lecun et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Lecun et al\\.",
      "year" : 1995
    }, {
      "title" : "Optimal brain damage",
      "author" : [ "LeCun", "Yann", "Denker", "John S", "Solla", "Sara A" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "LeCun et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "LeCun et al\\.",
      "year" : 1990
    }, {
      "title" : "Hamming distance metric learning",
      "author" : [ "Norouzi", "Mohammad", "Fleet", "David", "Salakhutdinov", "Ruslan" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Norouzi et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Norouzi et al\\.",
      "year" : 2012
    }, {
      "title" : "Higher order contractive auto-encoder",
      "author" : [ "Rifai", "Salah", "Mesnil", "Grégoire", "Vincent", "Pascal", "Muller", "Xavier", "Bengio", "Yoshua", "Dauphin", "Yann", "Glorot" ],
      "venue" : "In ECML/PKDD,",
      "citeRegEx" : "Rifai et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Rifai et al\\.",
      "year" : 2011
    }, {
      "title" : "Contractive auto-encoders: Explicit invariance during feature extraction",
      "author" : [ "Rifai", "Salah", "Vincent", "Pascal", "Muller", "Xavier", "Glorot", "Bengio", "Yoshua" ],
      "venue" : "In Proc. of ICML,",
      "citeRegEx" : "Rifai et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Rifai et al\\.",
      "year" : 2011
    }, {
      "title" : "Nonlinear dimensionality reduction by locally linear embedding",
      "author" : [ "Roweis", "Sam T", "Saul", "Lawrence K" ],
      "venue" : null,
      "citeRegEx" : "Roweis et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Roweis et al\\.",
      "year" : 2000
    }, {
      "title" : "Learning a nonlinear embedding by preserving class neighborhood structure",
      "author" : [ "Salakhutdinov", "Ruslan", "Hinton", "Geoffrey" ],
      "venue" : "In Proc. of AISTATS,",
      "citeRegEx" : "Salakhutdinov et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Salakhutdinov et al\\.",
      "year" : 2007
    }, {
      "title" : "Fast exact inference for recursive cardinality models",
      "author" : [ "Tarlow", "Daniel", "Swersky", "Kevin", "Zemel", "Richard S", "Adams", "Ryan P", "Frey", "Brendan" ],
      "venue" : "In 28th Conference on Uncertainty in Artificial Intelligence (UAI),",
      "citeRegEx" : "Tarlow et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Tarlow et al\\.",
      "year" : 2012
    }, {
      "title" : "A global geometric framework for nonlinear dimensionality reduction",
      "author" : [ "Tenenbaum", "Joshua B", "de Silva", "Vin", "Langford", "John C" ],
      "venue" : null,
      "citeRegEx" : "Tenenbaum et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Tenenbaum et al\\.",
      "year" : 2000
    }, {
      "title" : "80 million tiny images: A large data set for nonparametric object and scene recognition",
      "author" : [ "Torralba", "Antonio", "Fergus", "Robert", "Freeman", "William T" ],
      "venue" : "IEEE Trans. Pattern Anal. Mach. Intell.,",
      "citeRegEx" : "Torralba et al\\.,? \\Q1958\\E",
      "shortCiteRegEx" : "Torralba et al\\.",
      "year" : 1958
    }, {
      "title" : "Visualizing data using t-SNE",
      "author" : [ "Van der Maaten", "Laurens", "Hinton", "Geoffrey" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Maaten et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Maaten et al\\.",
      "year" : 2008
    }, {
      "title" : "Stacked denoising autoencoders: Learning useful representations in a deep network with a local denoising criterion",
      "author" : [ "Vincent", "Pascal", "Larochelle", "Hugo", "Lajoie", "Isabelle", "Bengio", "Yoshua", "Manzagol", "Pierre-Antoine" ],
      "venue" : "J. Mach. Learn. Res.,",
      "citeRegEx" : "Vincent et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Vincent et al\\.",
      "year" : 2010
    }, {
      "title" : "Distance metric learning for large margin nearest neighbor classification",
      "author" : [ "Weinberger", "Kilian Q", "Saul", "Lawrence K" ],
      "venue" : "J. Mach. Learn. Res.,",
      "citeRegEx" : "Weinberger et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Weinberger et al\\.",
      "year" : 2009
    }, {
      "title" : "Spectral hashing",
      "author" : [ "Weiss", "Yair", "Torralba", "Antonio", "Fergus", "Robert" ],
      "venue" : "In NIPS, pp. 1753–1760,",
      "citeRegEx" : "Weiss et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Weiss et al\\.",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 19,
      "context" : "Representation learning enables one to avoid explicit feature engineering; indeed, approaches to deep feature learning have often found representations that outperform their hand-crafted counterparts (e.g., Lecun & Bengio, 1995; Hinton & Salakhutdinov, 2006; Vincent et al., 2010; Coates et al., 2011).",
      "startOffset" : 200,
      "endOffset" : 301
    }, {
      "referenceID" : 1,
      "context" : "Representation learning enables one to avoid explicit feature engineering; indeed, approaches to deep feature learning have often found representations that outperform their hand-crafted counterparts (e.g., Lecun & Bengio, 1995; Hinton & Salakhutdinov, 2006; Vincent et al., 2010; Coates et al., 2011).",
      "startOffset" : 200,
      "endOffset" : 301
    }, {
      "referenceID" : 6,
      "context" : "As with the original dropout formulation (Hinton et al., 2012), nested dropout applies a stochastic mask over models.",
      "startOffset" : 41,
      "endOffset" : 62
    }, {
      "referenceID" : 2,
      "context" : "Locality sensitive hashing (Datar et al., 2004) seeks to preserve distance information by means of random projections; however, this can lead to very inefficient codes for high input dimensionality.",
      "startOffset" : 27,
      "endOffset" : 47
    }, {
      "referenceID" : 6,
      "context" : "Dropout (Hinton et al., 2012) is a regularization technique for neural networks that adds stochasticity to the architecture during training.",
      "startOffset" : 8,
      "endOffset" : 29
    }, {
      "referenceID" : 19,
      "context" : "It was shown by Vincent et al. (2010) that training an autoencoder corresponds to maximizing a lower bound on the mutual information I(y;x) between the input data and their representations.",
      "startOffset" : 16,
      "endOffset" : 38
    }, {
      "referenceID" : 19,
      "context" : "We inject noise to promote robustness, as in (Vincent et al., 2010); namely, with probability 0.",
      "startOffset" : 45,
      "endOffset" : 67
    }, {
      "referenceID" : 3,
      "context" : "Glorot et al. (2011) features an in-depth discussion and motivation of rectified linear units.",
      "startOffset" : 0,
      "endOffset" : 21
    }, {
      "referenceID" : 9,
      "context" : "The second is Optimal Brain Damage truncation (LeCun et al., 1990), which removes units in decreasing order of their influence on the reconstruction objective, measured in terms of the first and second order terms in its Taylor expansion.",
      "startOffset" : 46,
      "endOffset" : 66
    }, {
      "referenceID" : 10,
      "context" : "This idea can be combined with various existing approaches to metric learning of kNN and binarized representations (Norouzi et al., 2012; Salakhutdinov & Hinton, 2007; Weinberger & Saul, 2009).",
      "startOffset" : 115,
      "endOffset" : 192
    }, {
      "referenceID" : 15,
      "context" : "Finally, the nesting idea can be generalized to more complicated dependency structures, such as those described in Tarlow et al. (2012).",
      "startOffset" : 115,
      "endOffset" : 136
    } ],
    "year" : 2014,
    "abstractText" : "In this paper, we study ordered representations of data in which different dimensions have different degrees of importance. To learn these representations we introduce nested dropout, a procedure for stochastically removing coherent nested sets of hidden units in a neural network. We first present a sequence of theoretical results in the simple case of a semi-linear autoencoder. We rigorously show that the application of nested dropout enforces identifiability of the units, which leads to an exact equivalence with PCA. We then extend the algorithm to deep models and demonstrate the relevance of ordered representations to a number of applications. Specifically, we use the ordered property of the learned codes to construct hash-based data structures that permit very fast retrieval, achieving retrieval in time logarithmic in the database size and independent of the dimensionality of the representation. This allows codes that are hundreds of times longer than currently feasible for retrieval. We therefore avoid the diminished quality associated with short codes, while still performing retrieval that is competitive in speed with existing methods. We also show that ordered representations are a promising way to learn adaptive compression for efficient online data reconstruction.",
    "creator" : "LaTeX with hyperref package"
  }
}