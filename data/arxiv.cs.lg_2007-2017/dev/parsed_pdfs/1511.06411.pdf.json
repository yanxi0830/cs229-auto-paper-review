{
  "name" : "1511.06411.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "DIRECT LOSS MINIMIZATION FOR TRAINING DEEP NEURAL NETS",
    "authors" : [ "Yang Song", "Alexander G. Schwing", "Raquel Urtasun" ],
    "emails" : [ "songyang12@mails.tsinghua.edu.cn", "aschwing@cs.toronto.edu", "zemel@cs.toronto.edu", "urtasun@cs.toronto.edu" ],
    "sections" : [ {
      "heading" : "1 INTRODUCTION",
      "text" : "Supervised neural network training involves computing the gradient of the loss function with respect to the parameters of the model, and therefore requires the loss function to be differentiable. Many interesting loss functions are, however, not differentiable with respect to the output of the network. Notable examples are functions based on discrete outputs, as is common in labeling and ranking problems. In many cases these losses are also non-decomposable, in that they cannot be expressed as simple sums over the output units of the network.\nIn the context of structured prediction problems, in which the output is multi-dimensional, researchers have developed max-margin training methods that are capable of coping with such loss functions. Standard learning in this paradigm involves changing the model parameters such that the ground truth output has higher score than any other output. This is typically encoded by a constraint, enforcing that the ground truth score should be higher than a selected, contrastive output. The latter is defined as the result of performing inference in a modified score functionwhich combines the model score and the task loss. This encodes the fact that we penalize high scoring configurations that are less good in terms of the task loss, i.e., the metric that we care about for the application domain. Various efficient methods have been proposed for incorporating discrete and complicated loss functions into this approach (Yue et al., 2007; Volkovs & Zemel, 2009; Tarlow & Zemel, 2012; Mohapatra et al., 2014).\nHowever, this form of learning does not directly optimize the target function. An alternative approach, typically used in deep neural networks, is to train with a surrogate loss such as cross-entropy (LeCun & Huang, 2005; Bengio et al., 2015), that can be easily optimized. At test time we evaluate using the task loss. The problem of this procedure is that for many application domains the task loss differs significantly from the surrogate loss.\nIn this paper we propose to train deep neural nets to directly optimize the task loss, for structured, non-decomposable loss functions. In their seminal work, McAllester et al. (2010) showed that a form of structured prediction learning computes the gradients of the task loss. This work is, however, limited to linear models. In this paper we extend it to the non-linear case, proving that the\nar X\niv :1\n51 1.\n06 41\n1v 1\n[ cs\n.L G\n] 1\n9 N\nov 2\ntheoretical results hold in this more general setting. The result is a simple learning algorithm that can be applied to nonlinear, deep networks. We demonstrate the effectiveness of our approach in the context of optimizing the average precision (AP) in ranking tasks. This application is challenging as AP is neither decomposable nor smooth. Our experiments investigate the effectiveness of this algorithm, and the benefits of optimizing the task loss, in the context of action classification and object detection."
    }, {
      "heading" : "2 DIRECT LOSS MINIMIZATION FOR NEURAL NETWORKS",
      "text" : "In this section we present a formulation for learning neural networks by minimizing the task loss. Towards this goal, our first main result is a theorem extending direct loss minimization to deep non-linear networks.\nA neural network can be viewed as defining a composite scoring function F (x, y, w), which depends on the input data x ∈ X , some parameters w ∈ RA, and the output y ∈ Y . In the case of multiclass classification, the output refers to one of |Y| classes, i.e., y ∈ {1, . . . , |Y|}. Inference is then performed by picking the output with maximal score, i.e.:\nyw = arg max ŷ∈Y F (x, ŷ, w).\nGiven a dataset of input-output pairs D = {(x, y)}, a standard approach to learning is to optimize the parameters w of the scoring function F by minimizing cross-entropy. This is equivalent to maximizing the likelihood of the data, where the probability over each output configuration is given by the output of a softmax function in the last layer of the network.\nHowever, in many practical applications, we want prediction to succeed in an application-specific metric. This metric is typically referred to as the task loss, ∆(y, yw). In this paper we are thus interested in minimizing the task loss\nw∗ = arg min w E [∆(y, yw)] , (1)\nwhere E [·] denotes an expectation taken over the given dataset. Solving this program is non-trivial, as many loss functions of interest are non-decomposable and non-smooth, and thus are not amenable to gradient-based methods. Examples of such metrics include average precision (AP) from information retrieval, intersection-over-union which is used in image labeling, and normalized discounted cumulative gain (NDCG) which is popular in ranking. In general many metrics are discrete, are not simple sums over the network outputs, and are not readily differentiable.\nIt is hence common to employ a surrogate error metric where one can directly compute the gradients with respect to the parameters, such as cross-entropy or hinge-loss, during training of a classifier, while reporting results using the more appropriate measures. In the context of structured prediction models, several approaches have been developed to be able to optimize the structured hinge loss with non-decomposable task losses, e.g., Tarlow & Zemel (2012); Yue et al. (2007); Mohapatra et al. (2014). While these methods include the task loss in the objective, they are still not minimizing it. As a consequence, these surrogate losses are at best highly correlated with the desired metric. Finding efficient techniques to directly minimize the metric of choice is therefore desirable.\nMcAllester et al. (2010) showed that it is possible to asymptotically optimize the task-loss when the function F is linear in the parameters i.e., F (x, y, w) = w>φ(x, y). This work has produced encouraging results. For example, McAllester et al. (2010) used this technique for phoneme-to-speech alignment on the TIMIT dataset optimizing the τ -alignment loss and the τ -insensitive loss, while Keshet et al. (2011) illustrated applicability of the method to hidden Markov models for speech. Direct loss minimization was also shown to work well for inverse optimal control by Doerr et al. (2015).\nThe first contribution of our work is to generalize this theorem to arbitrary scoring functions, i.e., non-convex functions. This allow us to derive a new training algorithm for deep neural nets which directly minimizes the task loss.\nTheorem 1 (General Loss Gradient Theorem). When given a finite set Y , a scoring function F (x, y, w), a data distribution, as well as a task-loss ∆(y, ŷ), then, under some mild regularity\nconditions (see the Appendix for details), the direct loss gradient has the following form:\n∇wE [∆(y, yw)] = lim →0\ns\nE [∇wF (x, ydirect, w)−∇wF (x, yw, w)] , (2)\nwith\nyw = arg max ŷ∈Y F (x, ŷ, w),\nydirect = arg max ŷ∈Y F (x, ŷ, w) + s ∆(y, ŷ). (3)\nwhere s ∈ {+1,−1}.\nProof. We refer the reader to the Appendix Sec. 5.1, for a proof of the theorem.\nAccording to Theorem 1, to obtain the gradient we need to find the solution of two inference problems. The first computes yw, which is a standard inference task, solved by employing the forward propagation algorithm. The second inference problem is prediction using a scoring function which is perturbed by the task loss ∆(y, ŷ). This is typically non-trivial to solve, particularly when the task loss is not decomposable. We borrow terminology from the structured prediction literature, where this perturbed inference problem is commonly referred to as loss-augmented inference (Tsochantaridis et al., 2005; Chen et al., 2015). In the following section we derive an efficient dynamic programming algorithm to perform loss-augmented inference when the task loss is average precision.\nNote that loss-augmented inference, as specified in Eq. (3), can take the task loss into account in a positive or a negative way. Depending on the sign of s, the gradient direction changes. McAllester et al. (2010) provide a nice intuition for the two different directions. The positive update performs a step away from a worse configuration, while the negative direct loss gradient encourages moves towards better outputs. This can be seen when considering that maximization of the loss returns the worst output configuration, while maximization of its negation returns the label with the lowest loss. We explore both of these alternatives below. Further note the relationship between direct loss minimization and optimization of the hinge-loss. While we compute the gradient via a difference between the loss-augmented inference result and the prediction in the former case, the latter requires computation of the difference between the loss-augmented inference solution and ground truth.\nIn Fig. 1 we summarize the resulting learning algorithm, which consists of the following four steps. First we use a standard forward pass to evaluate F . We then perform inference and loss-augmented inference as specified in Eq. (3) to obtain the prediction yw and ydirect. We combine the predictions to obtain the gradient ∇wE [∆(y, yw)] via a single backward pass which is then used to update the parameters. For notational simplicity we omit details like momentum-based gradient updates, the use of mini-batches, etc."
    }, {
      "heading" : "3 DIRECT LOSS MINIMIZATION FOR AVERAGE PRECISION",
      "text" : "In order to directly optimize the task-loss we are required to compute the gradient defined in Eq. (2). As mentioned above, we need to solve both the standard inference task as well as the loss-augmented\ninference problem given in Eq. (3). While the former is typically easy, the latter depends on ∆ and might be very complex to solve, e.g., when the loss is not decomposable.\nIn this paper we consider ranking problems, where the desired task loss ∆ is average precision (AP). For the linear setting, efficient algorithms for positive loss-augmented inference with AP loss were proposed by Yue et al. (2007) and Mohapatra et al. (2014). Their results can be extended to the non-linear setting only in the positive case, where ydirect = arg maxŷ∈Y F (x, ŷ, w) + ∆(y, ŷ). For the negative setting inequalities required in their proof do not hold and thus their method is not applicable in this case. In this section we propose a more general algorithm that can handle both cases.\nTo compute the AP loss we are given a set of positive (i.e., relevant) and negative samples. The sample xi belongs to the positive class if i ∈ P = {1, . . . , |P|}, and xi is part of the negative class if i ∈ N = {|P|+ 1, . . . , |P|+ |N |}. We define the output to be composed of pairwise comparisons, with yi,j = 1 if sample i is ranked higher than j, yi,i = 0, and yi,j = −1 otherwise. We subsumed all these pairwise comparisons in y = (· · · , yi,j , · · · ). Similarly x = (x1, · · · , xN ) contains all inputs, with N = |P|+ |N | the total number of data points in the training set. In addition, we assume the ranking across all samples y to be complete, i.e., consistent. During inference we obtain a ranking by predicting scores φ(xi, w) for all data samples xi which are easily sorted afterwards.\nFor learning we generalize the feature function defined by Yue et al. (2007) and Mohapatra et al. (2014) to a non-linear scoring function, using\nF (x, y, w) = 1 |P||N | ∑\ni∈P,j∈N yi,j (φ(xi, w)− φ(xj , w)) .\nwhere φ(xi, w) is the output of the deep neural net when using the i-th example as input.\nAP is unfortunately a non-decomposable loss function, i.e., it does not decompose into functions dependent only on the individual yi,j . To define the non-decomposable AP loss formally, we construct a vector p̂ = rank(ŷ) ∈ {0, 1}|P|+|N | by sorting the data points according to the ranking defined by the configuration ŷ. This vector contains a 1 for each positive sample and a value 0 for each negative element. Using the rank operator we obtain the AP loss by comparing two vectors p = rank(y) and p̂ = rank(ŷ) via\n∆AP(p, p̂) = 1− 1 |P| ∑ j:p̂j=1 Prec@j, (4)\nwhere Prec@j is the percentage of relevant samples in the prediction p̂ that are ranked above position j.\nTo solve the loss-augmented inference task we have to solve the following program\narg max ŷ\nF (x, ŷ, w)± ∆AP(rank(y), rank(ŷ)), (5)\nIn the following we derive a dynamic programming algorithm that can handle both the positive and negative case and has the same complexity as Yue et al. (2007). Towards this goal, we first note that Observation 1 of Yue et al. (2007) holds for both the positive and the negative case. For completeness, we repeat their observation here and adapt it to our notation. Observation 1 (Yue et al. (2007)). Consider rankings which are constrained by fixing the relevance at each position in the ranking (e.g., the 3rd sample in the ranking must be relevant). Every ranking satisfying the same set of constraints will have the same ∆AP . If the positive samples are sorted by their scores in descending order, and the irrelevant samples are likewise sorted by their scores, then the interleaving of the two sorted lists satisfying the constraints will maximize Eq. (5) for that constrained set of rankings.\nObservation 1 means that we only need to consider the interleaving of two sorted lists of P and N to solve Eq. (5). From now on we therefore assume that the elements of P and N are sorted in descending order of their predicted score.\nWe next assert the optimal substructure property of our problem. Let the restriction to subsets of i positive and j negative examples be given by Pi = {1, . . . , i} and Nj = {|P| + 1, . . . , |P| + j}.\nThe cost function value obtained when restricting loss-augmented inference to the subsets can be computed as:\nh(i, j) = max ŷ\n1 |P||N | ∑ m∈Pi ∑ n∈Nj ŷm,n(φ(xm, w)− φ(xn, w))± ∆i,jAP (rank(y), rank(ŷ)), (6)\nwhere ∆i,jAP refers to the AP loss restricted to subsets of i positive and j negative elements. Lemma 1. Suppose that rank(ŷ∗) is the optimal ranking for Eq. (6) when restricted to i positive and j negative samples. Any of its sub-sequences starting at position 1 is then also an optimal ranking for the corresponding restricted sub-problem.\nWe provide the proof of this lemma in the Appendix, Sec. 5.2. Based on Lemma 1 we can construct Bellman equations to recursively fill in a matrix of size P × N , resulting in an overall time complexity of O(|P||N |). We can then obtain the optimal loss-augmented predicted ranking via back-tracking.\nThe Bellman recursion computes the optimal cost function value of the sub-sequence containing data from Pi and Nj , based on previously computed values as follows:\nh(i, j) = max\n{ h(i− 1, j)∓ 1|P| i i+j +B(i, j), i ≥ 1, j ≥ 0\nh(i, j − 1) +G(i, j), i ≥ 0, j ≥ 1 ,\nwith initial conditions h(1, 0) = ∓ 1|P| and h(0, 1) = 0. Note that we used the pre-computed matrices of scores\nB(i, j) = − 1 |P||N | ∑ k∈Nj (φ(xi, w)− φ(xk, w))\nG(i, j) = 1 |P||N | ∑ k∈Pi (φ(xk, w)− φ(xj , w)).\nIntuitively, the Bellman recursion considers two cases: (i) how does the maximum score h(i, j) for the solution restricted to sequences Pi and Nj change if we add a new positive sample; (ii) how does the maximum score h(i, j) change when adding a new negative sample. In both cases we need to add the respective scores B(i, j) or G(i, j). When adding a positive sample we additionally need to consider a contribution from the precision which contains i positive elements from a total of i+ j elements.\nThe matrices B(i, j) and G(i, j) store the additional contribution to Eq. (6) obtained when adding a positive or a negative sample respectively. They can be efficiently computed ahead of time using the recursion\nB(i, j) = B(i, j − 1)− 1 |P||N | (φ(xi, w)− φ(xj , w))\nG(i, j) = G(i− 1, j) + 1 |P||N | (φ(xi, w)− φ(xj , w)),\nwith initial conditions B(i, 0) = 0, G(0, j) = 0.\nWe summarize our dynamic programming algorithm for AP loss-augmented inference in Fig. 2. Note that after having completed the matrix h(i, j) we can backtrack to obtain the best lossaugmented ranking. We hence presented a general solution to solve positive and negative lossaugmented inference defined in Eq. (3) for the AP loss given in Eq. (4)."
    }, {
      "heading" : "4 EXPERIMENTAL EVALUATION",
      "text" : "To evaluate the performance of our approach we perform experiments on both synthetic and real datasets. We compare the positive and negative version of our direct loss minimization approach to a diverse set of baselines."
    }, {
      "heading" : "4.1 SYNTHETIC DATA",
      "text" : "Dataset: We generate synthetic data by randomly drawing the parameters of a 4-layer neural network with activations being rectified linear units. In particular, we use a normal distribution with zero mean and unit variance. We generate 20,000 input data points xi from a 10 dimensional standard Gaussian. We compute the score of each sample xi and sort them in descending order. The top 20% of the samples are assigned to the positive set P . We then randomly divide the generated data into a training set containing 10,000 elements and a test set containing the rest. To ensure that we don’t suffer from model misspecification we employ the same network structure when training the parameters from random initializations using different algorithms.\nAlgorithms: We evaluate the positive and negative versions of our direct loss minimization when using two different task losses: AP and 0-1 loss. For the latter we predict for each sample xi whether it is a member of the set P or whether it is part of the setN . We named these algorithms, “pos-AP,” “neg-AP,” “pos-01,” and “neg-01.” We also evaluate training the network using hinge loss, when employing AP and 0-1 loss as the task losses. We called these baselines “hinge-AP” and “hinge01.” We use the perceptron updates as additional baselines, which we call “per-AP” and “per-01.” Finally, the last baseline uses cross-entropy to train the network. We call this approach “logistic”. The parameters of all algorithms are individually determined via grid search to produce the best AP on the training set.\nResults: We report both AP and accuracy on the test set in Fig. 3. We observe that the perceptron update does not perform well, since it does not take the task loss into account. Contrary to the claim\nin (McAllester et al., 2010), the negative augmented inference is not competitive in our setting. This might be due to the fact that it tends to overly correct the classifier in noisy situations. We expect the negative update to lead to better performance in less noisy situations, e.g., if the data is nearly linearly separable. To verify this hypothesis we provide additional results in the appendix, Sec. 5.3.\nIt is important to note that when employing positive updates we outperformed all baselines by a large margin. Encouraged by the gain in performance we focus on positive non-linear direct loss minimization during the experimental evaluation on real datasets."
    }, {
      "heading" : "4.2 ACTION CLASSIFICATION TASK",
      "text" : "Dataset: In the next experiment we use the PASCAL VOC2012 action classification dataset provided by Everingham et al. (2014). The dataset contains 4588 images and 6278 “trainval” person bounding boxes. For each of the 10 target classes, we divide the trainval dataset into equally sized training, validation and test sets. We tuned the learning rate, regularization weight, and for all the algorithms based on their performance on our validation dataset, and report the results on the test set. For all algorithms we used the entire available training set in a single batch and performed 300 iterations.\nAlgorithms: We train our nonlinear direct loss minimization as well as all the baselines individually for each class. As baselines we use a deep network trained with cross entropy and hinge loss as baselines. The deep network used in those experiments follows the architecture of Krizhevsky et al. (2012), with the top dimension adjusted to 1 and the parameters initialized using weights trained on ILSVRC2012 (Russakovsky et al., 2015). Inspired by RCNN (Girshick et al., 2014), we cropped the regions of each image with a padding of 16 pixels and interpolated them to a size of 227× 227× 3 to fit the input data dimension of the network. All the algorithms we compare to as well as our approach use raw pixels as input.\nResults: We provide quantitative results in Tab. 1. Our direct AP loss minimization clearly outperforms the baselines by 1.9% and 3.1% respectively. This is quite significant for this task."
    }, {
      "heading" : "4.3 OBJECT DETECTION TASK",
      "text" : "Dataset: We use the PASCAL VOC2012 object detection dataset collected by Everingham et al. (2014). The dataset contains 5717 images for training, 5823 images for validation and 10991 images for test. Moreover, for each image, we use the fast mode of selective search by Uijlings et al. (2013) to produce around 2000 bounding boxes. We train algorithms on the training set and report results on the validation set.\nAlgorithms: On this dataset we follow the RCNN paradigm Girshick et al. (2014). For direct loss minimization, we adjust the dimension of the top layer of the network Krizhevsky et al. (2012) to be 1 and fine-tune using weights pre-trained on ILSVRC2012 (Russakovsky et al., 2015). We train direct loss minimization for all 20 classes separately. Different from the action classification task, we cannot calculate the overall AP in each iteration, because of the large number of bounding boxes.\nInstead, we use the AP on each mini-batch to approximate the overall AP. We find that using a batch size of 512 balances computational complexity and performance, though using a larger batch size (such as 2048) will generally result in better performance. For our final results, we use a learning rate of 0.1, a regularization parameter of 0.0000001, and = 0.1 for all classes.\nAs baselines, we use the fine-tuned softmax network of Girshick et al. (2014). Since this network was jointly trained for all classes, we also evaluate a network which uses cross-entropy and is trained separately for each class. We can thus evaluate whether a separate training of each class results in significant benefits. Again, the network structure was chosen to be identical and we use the parameters provided by Russakovsky et al. (2015) for initialization.\nResults: Tab. 2 shows that the logistic network trained independently for each class yields worse performance than the network trained jointly with softmax. Likely this is due to the fact that shared information benefits the softmax network. Importantly, we are also able to show competitive results of stochastic structured direct loss minimization, outperforming the strongest baseline by 1.5%."
    }, {
      "heading" : "5 CONCLUSION",
      "text" : "In this paper we have proposed a direct loss minimization approach to train deep neural networks. We have demonstrated the effectiveness of our approach in the context of maximizing average precision for ranking problems. This involves minimizing a non-smooth and non-decomposable loss. Towards this goal we have proposed a dynamic programing algorithm that can efficiently compute the weight updates. Our experiments showed that this is beneficial when compared to a large variety of baselines in the context of action classification and object detection. In the future, we plan to investigate direct loss minimization in the context of other non-decomposable loses such as intersection over union."
    }, {
      "heading" : "ACKNOWLEDGMENTS",
      "text" : "We thank David McAllester for discussions. This work was partially supported by ONR Grant N00014-14-1-0232, and a Google researcher award."
    }, {
      "heading" : "5.1 PROOF OF THE GENERAL LOSS GRADIENT THEOREM",
      "text" : "In order to lay the foundation for the proof of the general loss gradient theorem, we first show the following lemma. In short, it provides the bases for exchanging integral bounds when approaches 0 from above.\nLemma 2.\nlim →0+\n1 ∫ a +o( ) 0 ∫ ∞ b +o( ) f(x, y, )dxdy = lim →0+ 1 ∫ a +o( ) 0 ∫ ∞ 0 f(x, y, )dxdy\nProof. We have\nlim →0+\n1 ∫ a +o( ) 0 ∫ ∞ b +o( ) f(x, y, )dxdy\n= lim →0+\n1 ∫ a +o( ) 0 ∫ ∞ 0 f(x, y, )dxdy − lim →0+ 1 ∫ a +o( ) 0 ∫ b +o( ) 0 f(x, y, )dxdy.\nSuppose f is continuous w.r.t x, y, , then as → 0+, it can be bounded by some constant M . As a result, we have\n1 ∫ a +o( ) 0 ∫ b +o( ) 0 |f(x, y, )|dxdy ≤M(ab + ao( ) + bo( ) + o( )o( )/ ), (7)\nwhich means\nlim →0+\n1 ∫ a +o( ) 0 ∫ b +o( ) 0 f(x, y, )dxdy = 0. (8)\nRepeated application of Lemma 2 as demonstrated in the following is directly helpful for the proof of the general loss gradient theorem, which is why we state it explicitly:\nLemma 3. Let a > 0, then we assert\nlim →0+\n1 ∫ a +o( ) 0 ∫ ∞ b1 +o( ) · · · ∫ ∞ bn +o( ) f(x, y1, · · · , yn)dxdy1 · · · dyn\n= lim →0+\n1\na ∫ 0 ∫ ∞ 0 · · · ∫ ∞ 0 f(x, y1, · · · , yn)dxdy1 · · · dyn\nProof. Let f(x, y1, ) = ∫∞ b2 +o( ) · · · ∫∞ bn +o( )\nf(x, y1, · · · , yn)dy2 · · · dyn. Due to Lemma 2 we obtain the following:\nlim →0+\n1 ∫ a +o( ) 0 ∫ ∞ b1 +o( ) f(x, y1, )dxdy1 = lim →0+ 1 ∫ a +o( ) 0 ∫ ∞ 0 f(x, y1, )dxdy1\n= lim →0+\n1 ∫ a +o( ) 0 ∫ ∞ 0 ∫ ∞ b2 +o( ) · · · ∫ ∞ bn +o( ) f(x, y1, · · · , yn)dxdy1 · · · dyn.\nNow we denote f(x, y2, ) = ∫∞\n0 ∫∞ b3 +o( ) · · · ∫∞ bn +o( )\nf(x, y1, · · · , yn)dy1dy3 · · · dyn and follow a similar procedure:\nlim →0+\n1 ∫ a +o( ) 0 ∫ ∞ 0 ∫ ∞ b2 +o( ) · · · ∫ ∞ bn +o( ) f(x, y1, · · · , yn)dxdy1 · · · dyn\n= lim →0+\n1 ∫ a +o( ) 0 ∫ ∞ b2 +o( ) f(x, y2, )dxdy2\n= lim →0+\n1 ∫ a +o( ) 0 ∫ ∞ 0 f(x, y2, )dxdy2\n= · · · (following this procedure recursively)\n= lim →0+\n1 ∫ a +o( ) 0 ∫ ∞ 0 · · · ∫ ∞ 0 f(x, y1, · · · , yn)dxdy1 · · · dyn\n= lim →0+\na + o( )\nlim →0+\n1\na + o( ) ∫ a +o( ) 0 ∫ ∞ 0 · · · ∫ ∞ 0 f(x, y1, · · · , yn)dxdy1 · · · dyn\n= a lim →0+\n1\na + o( ) ∫ a +o( ) 0 ∫ ∞ 0 · · · ∫ ∞ 0 f(x, y1, · · · , yn)dxdy1 · · · dyn\n= a lim a +o( )→0+\n1\na + o( ) ∫ a +o( ) 0 ∫ ∞ 0 · · · ∫ ∞ 0 f(x, y1, · · · , yn)dxdy1 · · · dyn\n= lim →0+\n1\na ∫ 0 ∫ ∞ 0 · · · ∫ ∞ 0 f(x, y1, · · · , yn)dxdy1 · · · dyn.\nThis completes the proof.\nFor readability we repeat the main theorem:\nTheorem 1 (General Loss Gradient Theorem). When given a finite set Y , a scoring function F (x, y, w), a data distribution, as well as a task-loss ∆(y, ŷ), then, under some mild regularity conditions (see the proof for details), the direct loss gradient has the following form:\n∇wE [∆(y, yw)] = lim →0\n±1 E [∇wF (x, ydirect, w)−∇wF (x, yw, w)] ,\nwith\nyw = arg max ŷ∈Y F (x, ŷ, w),\nydirect = arg max ŷ∈Y\nF (x, ŷ, w)± ∆(y, ŷ).\nIn the following we prove the positive case and note that the negative case is easily proved using a similar procedure.\nProof. Without loss of generality, in this proof we assume Y = {1, 2, . . . , |Y|} and no tie in maximization.\nBy definition of the directional derivative we have\n∆wᵀ∇wE [L(y, yw(x)] = lim →0\nE [L(y, yw+ ∆w(x))]− E [L(y, yw(x))]\n.\nHence we need to prove the following equivalence:\nlim →0\nE [L(y, yw+ ∆w(x))− L(y, yw(x))]\n(9)\n= lim →0\n∆wᵀE [∇wF (x, ydirect, w)−∇wF (x, yw(x), w)]\n. (10)\nDenote ∆F i,jw (x) = F (x, i, w)−F (x, j, w), ∆L(y)i,j = L(y, i)−L(y, j). Note that ∆F i,iw (x) = 0 and ∆L(y)i,i = 0. Therefore we just have to consider terms where the classification result changes when moving fromw tow+ ∆w. To this end we decompose the expectation in Eq. (9) into pairwise terms to yield\nE [L(y, yw+ ∆w(x)− L(y, yw(x)))] = ∑ i 6=j E [ ∆L(y)i,j1{x∈Ai,j} ] ,\nwhere the indicator set for a change from class label i to category j when moving from w to w+∆w is given by\nAi,j = {x : yw+∆w(x) = i, yw(x) = j} = {x : ∆F i,kw+ ∆w > 0,∆F j,k w > 0, ∀k ∈ Y}\n= {x : ∆F i,kw + ∆wᵀ∇∆F i,kw + o( ) > 0,∆F j,kw > 0, ∀k ∈ Y} = {x : 0 < ∆F j,iw < − ∆wᵀ∇∆F j,iw + o( )\n∆F j,kw > 0, k 6= i ∆F i,kw > − ∆wᵀ∇∆F i,kw + o( ), k 6= j}.\nIntegrating the loss difference over the set, we obtain E [ ∆L(y)i,j1{x∈Ai,j} ] = Eµ [ ∆L(y)i,j ∫ ∆wᵀ∇∆F i,jw +o( ) 0 d∆F j,iw ∫ ∞ 0 d∆F j,1w · · · ∫ ∞ 0\nd∆F j,nw∫ ∞ − ∆wᵀ∇∆F i,1w +o( )\nd∆F i,1w · · ·∫ ∞ − ∆wᵀ∇∆F i,nw +o( ) f(∆F j,1w · · ·∆F i,nw | ∆L(y)i,j ,∆wᵀ∇∆F i,jw )d∆F i,nw ] .\nAs in (McAllester et al., 2010), we assume in the last equality above that any joint measure ρ on ∆F j,1w · · ·∆F i,nw ,∆L(y)i,j ,∆wᵀ∇∆F i,jw can be expressed as a measure µ on ∆L(y)i,j ,∆wᵀ∇∆F i,jw and a bounded continuous conditional density function f . Based on Lemma 3, we conclude that Eq. (9) is equivalent to\nlim →0+\n1 E [ ∆L(y)i,j1{x∈Ai,j} ] = Eµ [ ∆L(y)i,j(∆wᵀ∇∆F i,jw )+ lim\n→0+ 1 ∫ 0 d∆F j,iw ∫ ∞ 0 d∆F j,1w · · · ∫ ∞ 0\nd∆F j,nw∫ ∞ 0 d∆F i,1w · · · ∫ ∞ 0 f(∆F j,1w · · ·∆F i,nw |∆L(y)i,j ,∆wᵀ∇∆F i,jw )d∆F i,nw ] .\n(11)\nFollowing a similar procedure, we decompose the expectation in Eq. (10) to E [∆wᵀ∇F (x, ydirect, w)−∆wᵀ∇F (x, yw(x), w)] = ∑ i 6=j E [ ∆wᵀ∆∇F (x)i,j1{(x,y)∈Bi,j} ] ,\nwhere the indicator set for a change from label i to a configuration j when changing from w to loss augmented inference is given by\nBi,j = {(x, y) : ydirect = i, yw(x) = j} = {(x, y) : ∆F i,kw + ∆Li,k > 0,∆F j,kw > 0, k ∈ Y} = {(x, y) : 0 < ∆F j,iw < − ∆L(y)j,i\n∆F j,kw > 0, k 6= i ∆F i,kw > − ∆L(y)i,k, k 6= j}.\nIntegrating the directional derivative over the set of configuration changes, we obtain E [ ∆wᵀ∆∇F (x)i,j1{(x,y)∈Bi,j} ] = Eµ [ ∆wᵀ∆∇F (x)i,j ∫ ∆L(y)i,j 0 d∆F j,iw ∫ ∞ 0 d∆F j,1w · · · ∫ ∞ 0\nd∆F j,nw∫ ∞ − ∆L(y)i,1\nd∆F i,1w · · ·∫ ∞ − ∆L(y)i,n f(∆F j,1w · · ·∆F i,nw |∆wᵀ∆∇Fw(x)i,j ,∆L(y)j,i)d∆F i,nw ] .\nAssuming bounded data distribution and a bounded and continuous integrand we can exchange the limit operation and expectation to get\nlim →0+\n1 E [ ∆wᵀ∆∇F (x)i,j1{(x,y)∈Bi,j} ] = Eµ [ (∆L(y)i,j)+∆wᵀ∆∇F i,jw lim\n→0+ 1 ∫ 0 d∆F j,iw ∫ ∞ 0 d∆F j,1w · · · ∫ ∞ 0\nd∆F j,nw∫ ∞ 0 d∆F i,1w · · · ∫ ∞ 0 f(∆F j,1w · · ·∆F i,nw |∆wᵀ∆∇Fw(x)i,j ,∆L(y)j,i)d∆F i,nw ] .\n(12)\nNext we group expectations for a change from label i to configuration j and the reverse. To this end we first consider the resulting Eq. (11) obtained from rephrasing Eq. (9). Combining both label change directions yields\nlim →0+\n1 E [ ∆L(y)i,j1{x∈Ai,j} ] + lim →0+ 1 E [ ∆L(y)j,i1{x∈Aj,i} ] = Eµ [ ∆L(y)i,j(∆wᵀ∇∆F i,jw )+ lim\n→0+ 1 ∫ 0 d∆F j,iw ∫ ∞ 0 d∆F j,1w · · · ∫ ∞ 0\nd∆F j,nw∫ ∞ 0 d∆F i,1w · · · ∫ ∞ 0 f(∆F j,1w · · ·∆F i,nw |∆L(y)i,j ,∆wᵀ∇∆F i,jw )d∆F i,nw ]\n+ Eµ [ ∆L(y)j,i(∆wᵀ∇∆F j,iw )+ lim\n→0+ 1 ∫ 0 d∆F i,jw ∫ ∞ 0 d∆F i,1w · · · ∫ ∞ 0\nd∆F i,nw∫ ∞ 0 d∆F j,1w · · · ∫ ∞ 0 f(∆F j,1w · · ·∆F i,nw |∆L(y)i,j ,∆wᵀ∇∆F i,jw )d∆F i,nw ]\n= Eµ [ ∆L(y)i,j∆wᵀ∇∆F i,jw lim\n→0+ 1 ∫ 0 d∆F j,iw ∫ ∞ 0 d∆F j,1w · · · ∫ ∞ 0\nd∆F j,nw∫ ∞ 0 d∆F i,1w · · · ∫ ∞ 0 f(∆F j,1w · · ·∆F i,nw |∆L(y)i,j ,∆wᵀ∇∆F i,jw )d∆F i,nw ] .\n(13)\nSimilarly, we group expectations for both label change directions for the resulting Eq. (12) obtained from rephrasing Eq. (10), which yields\nlim →0+\n1 E [ ∆wᵀ∆∇F (x)i,j1{(x,y)∈Bi,j} ] + lim →0+ 1 E [ ∆wᵀ∆∇F (x)j,i1{(x,y)∈Bj,i} ] = Eµ [ ∆L(y)i,j∆wᵀ∆∇F i,jw lim\n→0+ 1 ∫ 0 d∆F j,iw ∫ ∞ 0 d∆F j,1w · · · ∫ ∞ 0\nd∆F j,nw∫ ∞ 0 d∆F i,1w · · · ∫ ∞ 0 f(∆F j,1w · · ·∆F i,nw |∆wᵀ∆∇Fw(x)i,j ,∆L(y)j,i)d∆F i,nw ] .\n(14)\nWe therefore have equivalence between Eq. (13) and Eq. (14) for a change from configuration i to j and the reverse. Since this holds for all pairwise configurations, Eq. (9) is identical to Eq. (10), which proves the theorem.\nThe conditions for the above results to hold are similar to the conditions for the proof for the binary linear case (McAllester et al., 2010). The conditions can be inferred from the proof above. We\nrequire that the joint measure ρ can be expressed as a measure µ and a corresponding bounded continuous conditional density function f . For exchangeability of limits and expectations, it is sufficient to require the integrand to be continuous and bounded as well as the range of integral to be bounded, i.e., the range of data is bounded. Further we require the scoring function F to have continuous derivatives w.r.t. w."
    }, {
      "heading" : "5.2 PROOF FOR LEMMA 1",
      "text" : "Next we provide the proof for Lemma 1 which we repeat for completeness. We note again that the cost function value obtained when restricting loss-augmented inference to the subsets can be computed as:\nh(i, j) = max ŷ\n1 |P||N | ∑ m∈Pi ∑ n∈Nj ŷm,n(φ(xm, w)− φ(xn, w))± ∆i,jAP (rank(y), rank(ŷ)), (15)\nwhere ∆i,jAP refers to the AP loss restricted to subsets of i positive and j negative elements. Lemma 1. Suppose that rank(ŷ∗) is the optimal ranking for Eq. (15) when restricted to i positive and j negative samples. Any of its sub-sequences starting at position 1 is then also an optimal ranking for the corresponding restricted sub-problem.\nProof. We consider the prefix r1, r2, · · · , rk, where k < |P| + |N | and (r1, r2, · · · , r|P|+|N |) := rank(ŷ∗). Suppose there are i relevant objects and j irrelevant objects in the prefix, and k = i+ j. What we need to prove is that r1, r2, · · · , ri+j is already an optimal ranking. Let\nh(i, j) = max ŷ\n1 |P||N | ∑ m∈Pi ∑ n∈Nj\nŷm,n(φ(xm, w)− φ(xn, w))± ∆i,jAP (rank(y), rank(ŷ))︸ ︷︷ ︸ :=s(i,j) .\nWe decompose the optimal value obtained when considering all samples, i.e., h(|P|, |N |), into three parts:\nh(|P|, |N |)\n= 1 |P||N | ∑ m∈Pi ∑ n∈Nj ŷ∗m,n(φ(xm, w)− φ(xn, w))± ∆ i,j AP(rank(y), rank(ŷ ∗))\n︸ ︷︷ ︸ Prefix terms = s(i, j)\n+ 1 |P||N | ∑\nm∈P\\Pi ∑ n∈N\\Nj ŷ∗m,n(φ(xm, w)− φ(xn, w))± ∆ ¬i,¬j AP (rank(y), rank(ŷ ∗))\n︸ ︷︷ ︸ Suffix terms\n+ 1\n|P||N |  ∑ m∈Pi ∑ n∈N\\Nj ŷ∗m,n(φ(xm, w)− φ(xn, w)) + ∑ m∈P\\Pi ∑ n∈Nj ŷ∗m,n(φ(xm, w)− φ(xn, w))  ︸ ︷︷ ︸\nCross terms\n.\nHere, ∆¬i,¬jAP (rank(y), rank(ŷ ∗)) refers to the loss obtained by considering all the samples not within the prefix.\nIntuitively, when changing the interleaving pattern of the prefix, the suffix terms and cross terms remain the same. This is true since the suffix terms are independent of the ranking of the prefix terms. In addition the cross terms only depend on the number and scores of positive and negative elements in the prefix but not their specific ranking.\nMore formally, suppose that f(i, j) 6= h(i, j), then we can substitute h(i, j) into the prefix term and get a larger value than h(|P|, |N |), contradicting the fact that h(|P|, |N |) is already the largest, which concludes the proof."
    }, {
      "heading" : "5.3 EXPERIMENTS ON LINEAR SYNTHETIC DATA",
      "text" : "To test the linear case, we generated two different datasets, one of which is linearly separable while the other one is not. We randomly generated 20,000 data points by sampling from a 10 dimensional standard Gaussian distribution. The data points with a sum of numbers in all dimensions being larger than 0 are assigned to the positive class while those having a negative sum are classified as the negative objects. We then divide the whole dataset into training set and test set of 10,000 elements each. To produce the non-linearly separable dataset, we randomly flip 20% of the binary labels. We select φ(x,w) = wᵀx in this linear setting. The results are depicted in Fig. 4 and Fig. 5.\nIn the noiseless linear case we observe the negative update to achieve a slightly better performance than the positive update. The perceptron method also performs well. We think this is the reason why McAllester et al. (2010) report the negative update to perform better. Note that Cheng et al. (2009) also reported good performance for the perceptron method on the TIMIT dataset, the same one used in McAllester et al. (2010).\nNegative and perceptron updates perform similarly on the noisy and not linearly separable dataset. They also do not perform well on our nonlinear datasets shown in the main paper."
    } ],
    "references" : [ {
      "title" : "Learning Deep Structured Models",
      "author" : [ "̃bengioy/dlbook. Chen", "L.-C", "A.G. Schwing", "A.L. Yuille", "R. Urtasun" ],
      "venue" : "Deep learning. Book in preparation for MIT Press,",
      "citeRegEx" : "Chen et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2015
    }, {
      "title" : "Matrix updates for perceptron training of continuous density hidden markov models",
      "author" : [ "Cheng", "C.-C", "F. Sha", "L.K. Saul" ],
      "venue" : "In Proc. ICML,",
      "citeRegEx" : "Cheng et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Cheng et al\\.",
      "year" : 2009
    }, {
      "title" : "Direct loss minimization inverse optimal control",
      "author" : [ "A. Doerr", "N. Ratliff", "J. Bohg", "M. Toussaint", "S. Schaal" ],
      "venue" : "Proc. of robotics: science and systems (R: SS),",
      "citeRegEx" : "Doerr et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Doerr et al\\.",
      "year" : 2015
    }, {
      "title" : "The pascal visual object classes challenge: A retrospective",
      "author" : [ "M. Everingham", "A.S.M. Eslami", "L. van Gool", "C.K.I. Williams", "J. Winn", "A. Zisserman" ],
      "venue" : null,
      "citeRegEx" : "Everingham et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Everingham et al\\.",
      "year" : 2014
    }, {
      "title" : "Rich feature hierarchies for accurate object detection and semantic segmentation",
      "author" : [ "R. Girshick", "J. Donahue", "T. Darrell", "J. Malik" ],
      "venue" : "In Proc. CVPR,",
      "citeRegEx" : "Girshick et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Girshick et al\\.",
      "year" : 2014
    }, {
      "title" : "Direct Error Rate Minimization of Hidden Markov Models",
      "author" : [ "J. Keshet", "Cheng", "C.-C", "M. Stoehr", "D. McAllester" ],
      "venue" : "In Proc. Interspeech,",
      "citeRegEx" : "Keshet et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Keshet et al\\.",
      "year" : 2011
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "A. Krizhevsky", "I. Sutskever", "G.E. Hinton" ],
      "venue" : "In Proc. NIPS,",
      "citeRegEx" : "Krizhevsky et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Krizhevsky et al\\.",
      "year" : 2012
    }, {
      "title" : "Loss Functions for Discriminative Training of Energy-Based Models",
      "author" : [ "Y. LeCun", "F.J. Huang" ],
      "venue" : "In Proc. AISTATS,",
      "citeRegEx" : "LeCun and Huang,? \\Q2005\\E",
      "shortCiteRegEx" : "LeCun and Huang",
      "year" : 2005
    }, {
      "title" : "Direct loss minimization for structured prediction",
      "author" : [ "D.A. McAllester", "J. Keshet", "T. Hazan" ],
      "venue" : "In Proc. NIPS,",
      "citeRegEx" : "McAllester et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "McAllester et al\\.",
      "year" : 2010
    }, {
      "title" : "Efficient Optimization for Average Precision SVM",
      "author" : [ "P. Mohapatra", "C.V. Jawahar", "M.P. Kumar" ],
      "venue" : "In Proc. NIPS,",
      "citeRegEx" : "Mohapatra et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Mohapatra et al\\.",
      "year" : 2014
    }, {
      "title" : "Structured Output Learning with High Order Loss Functions",
      "author" : [ "D. Tarlow", "R.S. Zemel" ],
      "venue" : "In Proc. AISTATS,",
      "citeRegEx" : "Tarlow and Zemel,? \\Q2012\\E",
      "shortCiteRegEx" : "Tarlow and Zemel",
      "year" : 2012
    }, {
      "title" : "Large Margin Methods for Structured and Interdependent Output Variables",
      "author" : [ "I. Tsochantaridis", "T. Joachims", "T. Hofmann", "Y. Altun" ],
      "venue" : null,
      "citeRegEx" : "Tsochantaridis et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Tsochantaridis et al\\.",
      "year" : 2005
    }, {
      "title" : "Selective search for object recognition",
      "author" : [ "J. Uijlings", "K. van de Sande", "T. Gevers", "A. Smeulders" ],
      "venue" : null,
      "citeRegEx" : "Uijlings et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Uijlings et al\\.",
      "year" : 2013
    }, {
      "title" : "BoltzRank: Learning to Maximize Expected Ranking Gain",
      "author" : [ "M.N. Volkovs", "R.S. Zemel" ],
      "venue" : "In Proc. ICML,",
      "citeRegEx" : "Volkovs and Zemel,? \\Q2009\\E",
      "shortCiteRegEx" : "Volkovs and Zemel",
      "year" : 2009
    }, {
      "title" : "A support vector method for optimizing average precision",
      "author" : [ "Y. Yue", "T. Finley", "F. Radlinski", "T. Joachims" ],
      "venue" : "In Proc. SIGIR,",
      "citeRegEx" : "Yue et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Yue et al\\.",
      "year" : 2007
    } ],
    "referenceMentions" : [ {
      "referenceID" : 14,
      "context" : "Various efficient methods have been proposed for incorporating discrete and complicated loss functions into this approach (Yue et al., 2007; Volkovs & Zemel, 2009; Tarlow & Zemel, 2012; Mohapatra et al., 2014).",
      "startOffset" : 122,
      "endOffset" : 209
    }, {
      "referenceID" : 9,
      "context" : "Various efficient methods have been proposed for incorporating discrete and complicated loss functions into this approach (Yue et al., 2007; Volkovs & Zemel, 2009; Tarlow & Zemel, 2012; Mohapatra et al., 2014).",
      "startOffset" : 122,
      "endOffset" : 209
    }, {
      "referenceID" : 8,
      "context" : "In their seminal work, McAllester et al. (2010) showed that a form of structured prediction learning computes the gradients of the task loss.",
      "startOffset" : 23,
      "endOffset" : 48
    }, {
      "referenceID" : 10,
      "context" : ", Tarlow & Zemel (2012); Yue et al. (2007); Mohapatra et al.",
      "startOffset" : 25,
      "endOffset" : 43
    }, {
      "referenceID" : 6,
      "context" : "(2007); Mohapatra et al. (2014). While these methods include the task loss in the objective, they are still not minimizing it.",
      "startOffset" : 8,
      "endOffset" : 32
    }, {
      "referenceID" : 6,
      "context" : "McAllester et al. (2010) showed that it is possible to asymptotically optimize the task-loss when the function F is linear in the parameters i.",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 6,
      "context" : "McAllester et al. (2010) showed that it is possible to asymptotically optimize the task-loss when the function F is linear in the parameters i.e., F (x, y, w) = w>φ(x, y). This work has produced encouraging results. For example, McAllester et al. (2010) used this technique for phoneme-to-speech alignment on the TIMIT dataset optimizing the τ -alignment loss and the τ -insensitive loss, while Keshet et al.",
      "startOffset" : 0,
      "endOffset" : 254
    }, {
      "referenceID" : 4,
      "context" : "(2010) used this technique for phoneme-to-speech alignment on the TIMIT dataset optimizing the τ -alignment loss and the τ -insensitive loss, while Keshet et al. (2011) illustrated applicability of the method to hidden Markov models for speech.",
      "startOffset" : 148,
      "endOffset" : 169
    }, {
      "referenceID" : 2,
      "context" : "Direct loss minimization was also shown to work well for inverse optimal control by Doerr et al. (2015). The first contribution of our work is to generalize this theorem to arbitrary scoring functions, i.",
      "startOffset" : 84,
      "endOffset" : 104
    }, {
      "referenceID" : 11,
      "context" : "We borrow terminology from the structured prediction literature, where this perturbed inference problem is commonly referred to as loss-augmented inference (Tsochantaridis et al., 2005; Chen et al., 2015).",
      "startOffset" : 156,
      "endOffset" : 204
    }, {
      "referenceID" : 0,
      "context" : "We borrow terminology from the structured prediction literature, where this perturbed inference problem is commonly referred to as loss-augmented inference (Tsochantaridis et al., 2005; Chen et al., 2015).",
      "startOffset" : 156,
      "endOffset" : 204
    }, {
      "referenceID" : 0,
      "context" : ", 2005; Chen et al., 2015). In the following section we derive an efficient dynamic programming algorithm to perform loss-augmented inference when the task loss is average precision. Note that loss-augmented inference, as specified in Eq. (3), can take the task loss into account in a positive or a negative way. Depending on the sign of s, the gradient direction changes. McAllester et al. (2010) provide a nice intuition for the two different directions.",
      "startOffset" : 8,
      "endOffset" : 398
    }, {
      "referenceID" : 13,
      "context" : "For the linear setting, efficient algorithms for positive loss-augmented inference with AP loss were proposed by Yue et al. (2007) and Mohapatra et al.",
      "startOffset" : 113,
      "endOffset" : 131
    }, {
      "referenceID" : 9,
      "context" : "(2007) and Mohapatra et al. (2014). Their results can be extended to the non-linear setting only in the positive case, where ydirect = arg maxŷ∈Y F (x, ŷ, w) + ∆(y, ŷ).",
      "startOffset" : 11,
      "endOffset" : 35
    }, {
      "referenceID" : 9,
      "context" : "(2007) and Mohapatra et al. (2014). Their results can be extended to the non-linear setting only in the positive case, where ydirect = arg maxŷ∈Y F (x, ŷ, w) + ∆(y, ŷ). For the negative setting inequalities required in their proof do not hold and thus their method is not applicable in this case. In this section we propose a more general algorithm that can handle both cases. To compute the AP loss we are given a set of positive (i.e., relevant) and negative samples. The sample xi belongs to the positive class if i ∈ P = {1, . . . , |P|}, and xi is part of the negative class if i ∈ N = {|P|+ 1, . . . , |P|+ |N |}. We define the output to be composed of pairwise comparisons, with yi,j = 1 if sample i is ranked higher than j, yi,i = 0, and yi,j = −1 otherwise. We subsumed all these pairwise comparisons in y = (· · · , yi,j , · · · ). Similarly x = (x1, · · · , xN ) contains all inputs, with N = |P|+ |N | the total number of data points in the training set. In addition, we assume the ranking across all samples y to be complete, i.e., consistent. During inference we obtain a ranking by predicting scores φ(xi, w) for all data samples xi which are easily sorted afterwards. For learning we generalize the feature function defined by Yue et al. (2007) and Mohapatra et al.",
      "startOffset" : 11,
      "endOffset" : 1261
    }, {
      "referenceID" : 9,
      "context" : "(2007) and Mohapatra et al. (2014). Their results can be extended to the non-linear setting only in the positive case, where ydirect = arg maxŷ∈Y F (x, ŷ, w) + ∆(y, ŷ). For the negative setting inequalities required in their proof do not hold and thus their method is not applicable in this case. In this section we propose a more general algorithm that can handle both cases. To compute the AP loss we are given a set of positive (i.e., relevant) and negative samples. The sample xi belongs to the positive class if i ∈ P = {1, . . . , |P|}, and xi is part of the negative class if i ∈ N = {|P|+ 1, . . . , |P|+ |N |}. We define the output to be composed of pairwise comparisons, with yi,j = 1 if sample i is ranked higher than j, yi,i = 0, and yi,j = −1 otherwise. We subsumed all these pairwise comparisons in y = (· · · , yi,j , · · · ). Similarly x = (x1, · · · , xN ) contains all inputs, with N = |P|+ |N | the total number of data points in the training set. In addition, we assume the ranking across all samples y to be complete, i.e., consistent. During inference we obtain a ranking by predicting scores φ(xi, w) for all data samples xi which are easily sorted afterwards. For learning we generalize the feature function defined by Yue et al. (2007) and Mohapatra et al. (2014) to a non-linear scoring function, using F (x, y, w) = 1 |P||N | ∑ i∈P,j∈N yi,j (φ(xi, w)− φ(xj , w)) .",
      "startOffset" : 11,
      "endOffset" : 1289
    }, {
      "referenceID" : 14,
      "context" : "To solve the loss-augmented inference task we have to solve the following program arg max ŷ F (x, ŷ, w)± ∆AP(rank(y), rank(ŷ)), (5) In the following we derive a dynamic programming algorithm that can handle both the positive and negative case and has the same complexity as Yue et al. (2007). Towards this goal, we first note that Observation 1 of Yue et al.",
      "startOffset" : 274,
      "endOffset" : 292
    }, {
      "referenceID" : 14,
      "context" : "To solve the loss-augmented inference task we have to solve the following program arg max ŷ F (x, ŷ, w)± ∆AP(rank(y), rank(ŷ)), (5) In the following we derive a dynamic programming algorithm that can handle both the positive and negative case and has the same complexity as Yue et al. (2007). Towards this goal, we first note that Observation 1 of Yue et al. (2007) holds for both the positive and the negative case.",
      "startOffset" : 274,
      "endOffset" : 366
    }, {
      "referenceID" : 14,
      "context" : "To solve the loss-augmented inference task we have to solve the following program arg max ŷ F (x, ŷ, w)± ∆AP(rank(y), rank(ŷ)), (5) In the following we derive a dynamic programming algorithm that can handle both the positive and negative case and has the same complexity as Yue et al. (2007). Towards this goal, we first note that Observation 1 of Yue et al. (2007) holds for both the positive and the negative case. For completeness, we repeat their observation here and adapt it to our notation. Observation 1 (Yue et al. (2007)).",
      "startOffset" : 274,
      "endOffset" : 531
    }, {
      "referenceID" : 8,
      "context" : "in (McAllester et al., 2010), the negative augmented inference is not competitive in our setting.",
      "startOffset" : 3,
      "endOffset" : 28
    }, {
      "referenceID" : 4,
      "context" : "Inspired by RCNN (Girshick et al., 2014), we cropped the regions of each image with a padding of 16 pixels and interpolated them to a size of 227× 227× 3 to fit the input data dimension of the network.",
      "startOffset" : 17,
      "endOffset" : 40
    }, {
      "referenceID" : 3,
      "context" : "2 ACTION CLASSIFICATION TASK Dataset: In the next experiment we use the PASCAL VOC2012 action classification dataset provided by Everingham et al. (2014). The dataset contains 4588 images and 6278 “trainval” person bounding boxes.",
      "startOffset" : 129,
      "endOffset" : 154
    }, {
      "referenceID" : 3,
      "context" : "2 ACTION CLASSIFICATION TASK Dataset: In the next experiment we use the PASCAL VOC2012 action classification dataset provided by Everingham et al. (2014). The dataset contains 4588 images and 6278 “trainval” person bounding boxes. For each of the 10 target classes, we divide the trainval dataset into equally sized training, validation and test sets. We tuned the learning rate, regularization weight, and for all the algorithms based on their performance on our validation dataset, and report the results on the test set. For all algorithms we used the entire available training set in a single batch and performed 300 iterations. Algorithms: We train our nonlinear direct loss minimization as well as all the baselines individually for each class. As baselines we use a deep network trained with cross entropy and hinge loss as baselines. The deep network used in those experiments follows the architecture of Krizhevsky et al. (2012), with the top dimension adjusted to 1 and the parameters initialized using weights trained on ILSVRC2012 (Russakovsky et al.",
      "startOffset" : 129,
      "endOffset" : 938
    }, {
      "referenceID" : 3,
      "context" : "2 ACTION CLASSIFICATION TASK Dataset: In the next experiment we use the PASCAL VOC2012 action classification dataset provided by Everingham et al. (2014). The dataset contains 4588 images and 6278 “trainval” person bounding boxes. For each of the 10 target classes, we divide the trainval dataset into equally sized training, validation and test sets. We tuned the learning rate, regularization weight, and for all the algorithms based on their performance on our validation dataset, and report the results on the test set. For all algorithms we used the entire available training set in a single batch and performed 300 iterations. Algorithms: We train our nonlinear direct loss minimization as well as all the baselines individually for each class. As baselines we use a deep network trained with cross entropy and hinge loss as baselines. The deep network used in those experiments follows the architecture of Krizhevsky et al. (2012), with the top dimension adjusted to 1 and the parameters initialized using weights trained on ILSVRC2012 (Russakovsky et al., 2015). Inspired by RCNN (Girshick et al., 2014), we cropped the regions of each image with a padding of 16 pixels and interpolated them to a size of 227× 227× 3 to fit the input data dimension of the network. All the algorithms we compare to as well as our approach use raw pixels as input. Results: We provide quantitative results in Tab. 1. Our direct AP loss minimization clearly outperforms the baselines by 1.9% and 3.1% respectively. This is quite significant for this task. 4.3 OBJECT DETECTION TASK Dataset: We use the PASCAL VOC2012 object detection dataset collected by Everingham et al. (2014). The dataset contains 5717 images for training, 5823 images for validation and 10991 images for test.",
      "startOffset" : 129,
      "endOffset" : 1669
    }, {
      "referenceID" : 3,
      "context" : "2 ACTION CLASSIFICATION TASK Dataset: In the next experiment we use the PASCAL VOC2012 action classification dataset provided by Everingham et al. (2014). The dataset contains 4588 images and 6278 “trainval” person bounding boxes. For each of the 10 target classes, we divide the trainval dataset into equally sized training, validation and test sets. We tuned the learning rate, regularization weight, and for all the algorithms based on their performance on our validation dataset, and report the results on the test set. For all algorithms we used the entire available training set in a single batch and performed 300 iterations. Algorithms: We train our nonlinear direct loss minimization as well as all the baselines individually for each class. As baselines we use a deep network trained with cross entropy and hinge loss as baselines. The deep network used in those experiments follows the architecture of Krizhevsky et al. (2012), with the top dimension adjusted to 1 and the parameters initialized using weights trained on ILSVRC2012 (Russakovsky et al., 2015). Inspired by RCNN (Girshick et al., 2014), we cropped the regions of each image with a padding of 16 pixels and interpolated them to a size of 227× 227× 3 to fit the input data dimension of the network. All the algorithms we compare to as well as our approach use raw pixels as input. Results: We provide quantitative results in Tab. 1. Our direct AP loss minimization clearly outperforms the baselines by 1.9% and 3.1% respectively. This is quite significant for this task. 4.3 OBJECT DETECTION TASK Dataset: We use the PASCAL VOC2012 object detection dataset collected by Everingham et al. (2014). The dataset contains 5717 images for training, 5823 images for validation and 10991 images for test. Moreover, for each image, we use the fast mode of selective search by Uijlings et al. (2013) to produce around 2000 bounding boxes.",
      "startOffset" : 129,
      "endOffset" : 1864
    }, {
      "referenceID" : 3,
      "context" : "2 ACTION CLASSIFICATION TASK Dataset: In the next experiment we use the PASCAL VOC2012 action classification dataset provided by Everingham et al. (2014). The dataset contains 4588 images and 6278 “trainval” person bounding boxes. For each of the 10 target classes, we divide the trainval dataset into equally sized training, validation and test sets. We tuned the learning rate, regularization weight, and for all the algorithms based on their performance on our validation dataset, and report the results on the test set. For all algorithms we used the entire available training set in a single batch and performed 300 iterations. Algorithms: We train our nonlinear direct loss minimization as well as all the baselines individually for each class. As baselines we use a deep network trained with cross entropy and hinge loss as baselines. The deep network used in those experiments follows the architecture of Krizhevsky et al. (2012), with the top dimension adjusted to 1 and the parameters initialized using weights trained on ILSVRC2012 (Russakovsky et al., 2015). Inspired by RCNN (Girshick et al., 2014), we cropped the regions of each image with a padding of 16 pixels and interpolated them to a size of 227× 227× 3 to fit the input data dimension of the network. All the algorithms we compare to as well as our approach use raw pixels as input. Results: We provide quantitative results in Tab. 1. Our direct AP loss minimization clearly outperforms the baselines by 1.9% and 3.1% respectively. This is quite significant for this task. 4.3 OBJECT DETECTION TASK Dataset: We use the PASCAL VOC2012 object detection dataset collected by Everingham et al. (2014). The dataset contains 5717 images for training, 5823 images for validation and 10991 images for test. Moreover, for each image, we use the fast mode of selective search by Uijlings et al. (2013) to produce around 2000 bounding boxes. We train algorithms on the training set and report results on the validation set. Algorithms: On this dataset we follow the RCNN paradigm Girshick et al. (2014). For direct loss minimization, we adjust the dimension of the top layer of the network Krizhevsky et al.",
      "startOffset" : 129,
      "endOffset" : 2064
    }, {
      "referenceID" : 3,
      "context" : "2 ACTION CLASSIFICATION TASK Dataset: In the next experiment we use the PASCAL VOC2012 action classification dataset provided by Everingham et al. (2014). The dataset contains 4588 images and 6278 “trainval” person bounding boxes. For each of the 10 target classes, we divide the trainval dataset into equally sized training, validation and test sets. We tuned the learning rate, regularization weight, and for all the algorithms based on their performance on our validation dataset, and report the results on the test set. For all algorithms we used the entire available training set in a single batch and performed 300 iterations. Algorithms: We train our nonlinear direct loss minimization as well as all the baselines individually for each class. As baselines we use a deep network trained with cross entropy and hinge loss as baselines. The deep network used in those experiments follows the architecture of Krizhevsky et al. (2012), with the top dimension adjusted to 1 and the parameters initialized using weights trained on ILSVRC2012 (Russakovsky et al., 2015). Inspired by RCNN (Girshick et al., 2014), we cropped the regions of each image with a padding of 16 pixels and interpolated them to a size of 227× 227× 3 to fit the input data dimension of the network. All the algorithms we compare to as well as our approach use raw pixels as input. Results: We provide quantitative results in Tab. 1. Our direct AP loss minimization clearly outperforms the baselines by 1.9% and 3.1% respectively. This is quite significant for this task. 4.3 OBJECT DETECTION TASK Dataset: We use the PASCAL VOC2012 object detection dataset collected by Everingham et al. (2014). The dataset contains 5717 images for training, 5823 images for validation and 10991 images for test. Moreover, for each image, we use the fast mode of selective search by Uijlings et al. (2013) to produce around 2000 bounding boxes. We train algorithms on the training set and report results on the validation set. Algorithms: On this dataset we follow the RCNN paradigm Girshick et al. (2014). For direct loss minimization, we adjust the dimension of the top layer of the network Krizhevsky et al. (2012) to be 1 and fine-tune using weights pre-trained on ILSVRC2012 (Russakovsky et al.",
      "startOffset" : 129,
      "endOffset" : 2176
    }, {
      "referenceID" : 4,
      "context" : "As baselines, we use the fine-tuned softmax network of Girshick et al. (2014). Since this network was jointly trained for all classes, we also evaluate a network which uses cross-entropy and is trained separately for each class.",
      "startOffset" : 55,
      "endOffset" : 78
    }, {
      "referenceID" : 4,
      "context" : "As baselines, we use the fine-tuned softmax network of Girshick et al. (2014). Since this network was jointly trained for all classes, we also evaluate a network which uses cross-entropy and is trained separately for each class. We can thus evaluate whether a separate training of each class results in significant benefits. Again, the network structure was chosen to be identical and we use the parameters provided by Russakovsky et al. (2015) for initialization.",
      "startOffset" : 55,
      "endOffset" : 445
    }, {
      "referenceID" : 8,
      "context" : "As in (McAllester et al., 2010), we assume in the last equality above that any joint measure ρ on ∆F j,1 w · · ·∆F i,n w ,∆L(y) ,∆wT∇∆F i,j w can be expressed as a measure μ on ∆L(y) ,∆wT∇∆F i,j w and a bounded continuous conditional density function f .",
      "startOffset" : 6,
      "endOffset" : 31
    }, {
      "referenceID" : 8,
      "context" : "The conditions for the above results to hold are similar to the conditions for the proof for the binary linear case (McAllester et al., 2010).",
      "startOffset" : 116,
      "endOffset" : 141
    }, {
      "referenceID" : 7,
      "context" : "We think this is the reason why McAllester et al. (2010) report the negative update to perform better.",
      "startOffset" : 32,
      "endOffset" : 57
    }, {
      "referenceID" : 1,
      "context" : "Note that Cheng et al. (2009) also reported good performance for the perceptron method on the TIMIT dataset, the same one used in McAllester et al.",
      "startOffset" : 10,
      "endOffset" : 30
    }, {
      "referenceID" : 1,
      "context" : "Note that Cheng et al. (2009) also reported good performance for the perceptron method on the TIMIT dataset, the same one used in McAllester et al. (2010). Negative and perceptron updates perform similarly on the noisy and not linearly separable dataset.",
      "startOffset" : 10,
      "endOffset" : 155
    } ],
    "year" : 2017,
    "abstractText" : "Supervised training of deep neural nets typically relies on minimizing crossentropy. However, in many domains, we are interested in performing well on specific application-specific metrics. In this paper we proposed a direct loss minimization approach to train deep neural networks, taking into account the application-specific loss functions. This can be non-trivial, when these functions are non-smooth and non-decomposable. We demonstrate the effectiveness of our approach in the context of maximizing average precision for ranking problems. Towards this goal, we propose a dynamic programming algorithm that can efficiently compute the weight updates. Our approach proves superior to a variety of baselines in the context of action classification and object detection.",
    "creator" : "LaTeX with hyperref package"
  }
}