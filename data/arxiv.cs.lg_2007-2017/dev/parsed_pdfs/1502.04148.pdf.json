{
  "name" : "1502.04148.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Pseudo-Euclidean Iteration for Optimal Recovery in Noisy ICA",
    "authors" : [ "James Voss", "Mikhail Belkin", "Luis Rademacher" ],
    "emails" : [ "vossj@cse.ohio-state.edu", "mbelkin@cse.ohio-state.edu", "lrademac@cse.ohio-state.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Our second contribution is combining PEGI with the analysis of objectives for optimal recovery in the noisy ICA model. It has been observed that the direct approach of demixing with the inverse of the mixing matrix is suboptimal for signal recovery in terms of the natural Signal to Interference plus Noise Ratio (SINR) criterion. There have been several partial solutions proposed in the ICA literature. It turns out that any solution to the mixing matrix reconstruction problem can be used to construct an SINR-optimal ICA demixing, despite the fact that SINR itself cannot be computed from data. That allows us to obtain a practical and provably SINR-optimal recovery method for ICA with arbitrary Gaussian noise."
    }, {
      "heading" : "1 Introduction",
      "text" : "Independent Component Analysis refers to a class of methods aiming at recovering statistically independent signals by observing their unknown linear combination. There is an extensive literature on this and a number of related problems [7].\nSpecifically, in the ICA model, we observe n-dimensional realizations x(1), . . . ,x(N) of a latent variable model X = ∑m k=1 SkAk = AS where Ak denotes the k\nth column of the n × m mixing matrix A and S = (S1, . . . , Sm)\nT is the unseen latent random vector of “signals”. It is assumed that S1, . . . , Sm are independent and non-Gaussian. The source signals and entries of A may be either real- or complex-valued. For simplicity, we will assume throughout that S has zero mean, as this may be achieved in practice by centering the observed data.\nMany ICA algorithms use the preprocessing “whitening” step whose goal is to orthogonalize the independent components. In the noiseless, case this is commonly done by computing the square root of the covariance matrix of X. Consider now the noisy ICA model X = AS+η with additive 0- mean noise η independent of S. It turns out that the introduction of noise makes accurate recovery of the signals significantly more involved. Specifically, whitening using the covariance matrix does not work in the noisy ICA model as the covariance matrix combines both signal and noise. For\n∗Department of Computer Science and Engineering, the Ohio State University\nar X\niv :1\n50 2.\n04 14\n8v 2\n[ cs\n.L G\n] 1\nO ct\n2 01\nthe case when the noise is Gaussian, matrices constructed from higher order statistics (specifically, cumulants) can be used instead of the covariance matrix. However, these matrices are not in general positive definite and thus the square root cannot always be extracted. This limits the applicability of several previous methods, such as [2, 9, 1]. The GI-ICA algorithm proposed in [21] addresses this issue by using a complicated quasi-orthogonalization step followed by an iterative method.\nIn this paper (section 2), we develop a simple and practical one-step algorithm, PEGI (for pseudo-Euclidean Gradient Iteration) for provably recovering A (up to the unavoidable ambiguities of the model) in the case when the noise is Gaussian (with an arbitrary, unknown covariance matrix). The main technical innovation of our approach is to formulate the recovery problem as a fixed point method in an indefinite “inner product” (pseudo-Euclidean) space.\nThe second contribution of the paper is combining PEGI with the analysis of objectives for optimal recovery in the noisy ICA model. In most applications of ICA (e.g., speech separation [18], MEG/EEG artifact removal [20] and others) one cares about recovering the signals s(1), . . . , s(N). This is known as the source recovery problem. This is typically done by first recovering the matrix A (up to an appropriate scaling of the column directions).\nAt first, source recovery and recovering the mixing matrix A appear to be essentially equivalent. In the noiseless ICA model, if A in invertible1 then s(t) = A−1x(t) recovers the sources. On the other hand, in the noisy model, the exact recovery of the latent sources s(t) becomes impossible even if A is known exactly. Part of the “noise” can be incorporated into the “signal” preserving the form of the model. Even worse, neither A nor S are defined uniquely as there is an inherent ambiguity in the setting. There could be many equivalent decompositions of the observed signal as X = A′S′ + η′ (see the discussion in section 3).\nWe consider recovered signals of the form Ŝ(B) := BX for a choice of m×n demixing matrix B. Signal recovery is considered optimal if the coordinates of Ŝ(B) = (Ŝ1(B), . . . , Ŝm(B)) maximize Signal to Interference plus Noise Ratio (SINR) within any fixed model X = AS + η. Note that the value of SINR depends on the decomposition of the observed data into “noise” and “signal”: X = A′S′ + η′.\nSurprisingly, the SINR optimal demixing matrix does not depend on the decomposition of data into signal plus noise. As such, SINR optimal ICA recovery is well defined given access to data despite the inherent ambiguity in the model. Further, it will be seen that the SINR optimal demixing can be constructed from cov(X) and the directions of the columns of A (which are also well-defined across signal/noise decompositions).\nOur SINR-optimal demixing approach combined with the PEGI algorithm provides a complete SINR-optimal recovery algorithm in the ICA model with arbitrary Gaussian noise. We note that the ICA papers of which we are aware that discuss optimal demixing do not observe that SINR optimal demixing is invariant to the choice of signal/noise decomposition. Instead, they propose more limited strategies for improving the demixing quality within a fixed ICA model. For instance, Joho et al. [14] show how SINR-optimal demixing can be approximated with extra sensors when assuming a white additive noise, and Koldovskỳ and Tichavskỳ [16] discuss how to achieve asymptotically low bias ICA demixing assuming white noise within a fixed ICA model. However, the invariance of the SINR-optimal demixing matrix appears in the array sensor systems literature [6].\nFinally, in section 4, we demonstrate experimentally that our proposed algorithm for ICA outperforms existing practical algorithms at the task of noisy signal recovery, including those specifically designed for beamforming, when given sufficiently many samples. Moreover, most existing practical algorithms for noisy source recovery have a bias and cannot recover the optimal demixing matrix even with infinite samples. We also show that PEGI requires significantly fewer samples\n1A−1 can be replaced with A† in the discussion below for over-determined ICA.\nthan GI-ICA [21] to perform ICA accurately."
    }, {
      "heading" : "1.1 The Indeterminacies of ICA",
      "text" : "Notation: We use M∗ to denote the entry-wise complex conjugate of a matrix M , MT to denote its transpose, and MH to denote its conjugate transpose.\nBefore proceeding with our results, we discuss the somewhat subtle issue of indeterminacies in ICA. These ambiguities arise from the fact that the observed X may have multiple decompositions into ICA models X = AS + η and X = A′S′ + η′.\nNoise-free ICA has two natural indeterminacies. For any nonzero constant α, the contribution of the kth component AkSk to the model can equivalently be obtained by replacing Ak with αAk and Sk with the rescaled signal 1 αSk. To lessen this scaling indeterminacy, we use the convention\n2 that cov(S) = I throughout this paper. As such, each source Sk (or equivalently each Ak) is defined up to a choice of sign (a unit modulus factor in the complex case). In addition, there is an ambiguity in the order of the latent signals. For any permutation π of [m] (where [m] := {1, . . . ,m}), the ICA models X = ∑m k=1 SkAk and X = ∑m k=1 Sπ(k)Aπ(k) are indistinguishable. In the noise free setting, A is said to be recovered if we recover each column of A up to a choice of sign (or up to a unit modulus factor in the complex case) and an unknown permutation. As the sources S1, . . . , Sm are only defined up to the same indeterminacies, inverting the recovered matrix Ã to obtain a demixing matrix works for signal recovery.\nIn the noisy ICA setting, there is an additional indeterminacy in the definition of the sources. Consider ξ to be 0-mean axis-aligned Gaussian random vector. Then, the noisy ICA model X = A(S + ξ) + η in which ξ is considered part of the latent source signal S′ = S + ξ, and the model X = AS + (Aξ + η) in which ξ is part of the noise are indistinguishable. In particular, the latent source S and its covariance are ill-defined. Due to this extra indeterminacy, the lengths of the columns of A no longer have a fully defined meaning even when we assume cov(S) = I. In the noisy setting, A is said to be recovered if we obtain the columns of A up to non-zero scalar multiplicative factors and an arbitrary permutation.\nThe last indeterminacy is the most troubling as it suggests that the power of each source signal is itself ill-defined in the noisy setting. Despite this indeterminacy, it is possible to perform an SINR-optimal demixing without additional assumptions about what portion of the signal is source and what portion is noise. In section 3, we will see that SINR-optimal source recovery takes on a simple form: Given any solution Ã which recovers A up to the inherent ambiguities of noisy ICA, then ÃH cov(X)† is an SINR-optimal demixing matrix."
    }, {
      "heading" : "1.2 Related Work and Contributions",
      "text" : "Independent Component Analysis is probably the most used model for Blind Signal Separation. It has seen numerous applications and has generated a vast literature, including in the noisy and underdetermined settings. We refer the reader to the books [13, 7] for a broad overview of the subject.\nIt was observed early on by Cardoso [4] that ICA algorithms based soley on higher order cumulant statistics are invariant to additive Gaussian noise. This observation has allowed the creation of many algorithms for recovering the ICA mixing matrix in the noisy and often underdetermined settings. Despite the significant work on noisy ICA algorithms, they remain less efficient, more specialized, or less practical than the most popular noise free ICA algorithms.\n2Alternatively, one may place the scaling information in the signals by setting ‖Ak‖ = 1 for each k.\nResearch on cumulant-based noisy ICA can largely be split into several lines of work which we only highlight here. Some algorithms such as FOOBI [4] and BIOME [1] directly use the tensor structure of higher order cumulants. In another line of work, De Lathauwer et al. [8] and Yeredor [23] have suggested algorithms which jointly diagonalize cumulant matrices in a manner reminiscent of the noise-free JADE algorithm [3]. In addition, Yeredor [22] and Goyal et al. [11] have proposed ICA algorithms based on random directional derivatives of the second characteristic function.\nEach line of work has its advantages and disadvantages. The joint diagonalization algorithms and the tensor based algorithms tend to be practical in the sense that they use redundant cumulant information in order to achieve more accurate results. However, they have a higher memory complexity than popular noise free ICA algorithms such as FastICA [12]. Moreover, the tensor methods (FOOBI and BIOME) require the latent source signals to have positive order 2k (k ≥ 2, a predetermined fixed integer) cumulants as they rely on taking a matrix square root. Finally, the methods based on random directional derivatives of the second characteristic function rely heavily upon randomness in a manner not required by the most popular noise free ICA algorithms.\nWe continue a line of research started by Arora et al. [2] and Voss et al. [21] on fully determined noisy ICA which addresses some of these practical issues by using a deflationary approach reminiscent of FastICA. Their algorithms thus have lower memory complexity and are more scalable to high dimensional data than the joint diagonalization and tensor methods. However, both works require a preprocessing step (quasi-orthogonalization) to orthogonalize the latent signals which is based on taking a matrix square root. Arora et al. [2] require each latent signal to have positive fourth cumulant in order to carry out this preprocessing step. In contrast, Voss et al. [21] are able to perform quasi-orthogonalization with source signals of mixed sign fourth cumulants; but their quase-orthogonalization step is more complicated and can run into numerical issues under sampling error. We demonstrate that quasi-orthogonalization is unnecessary. We introduce the PEGI algorithm to work within a (not necessarily positive definite) inner product space instead. Experimentally, this leads to improved demixing performance. In addition, we handle the case of complex signals.\nFinally, another line of work attempts to perform SINR-optimal source recovery in the noisy ICA setting. It was noted by Koldovskỳ and Tichavskỳ [15] that for noisy ICA, traditional ICA algorithms such as FastICA and JADE actually outperform algorithms which first recover A in the noisy setting and then use the resulting approximation of A† to perform demixing. It was further observed that A† is not the optimal demixing matrix for source recovery. Later, Koldovskỳ and Tichavskỳ [17] proposed an algorithm based on FastICA which performs a low SINR-bias beamforming."
    }, {
      "heading" : "2 Pseudo-Euclidean Gradient Iteration ICA",
      "text" : "In this section, we introduce the PEGI algorithm for recovering A in the “fully determined” noisy ICA setting where m ≤ n. PEGI relies on the idea of Gradient Iteration introduced Voss et al. [21]. However, unlike GI-ICA Voss et al. [21], PEGI does not require the source signals to be orthogonalized. As such, PEGI does not require the complicated quasi-orthogonalization preprocessing step of GI-ICA which can be inaccurate to compute in practice. We sketch the Gradient Iteration algorithm in Section 2.1, and then introduce PEGI in Section 2.2. For simplicity, we limit this discussion to the case of real-valued signals. We show how to construct PEGI for complex-valued signals in Appendix A.\nIn this section we assume a noisy ICA model X = AS + η such that η is arbitrary Gaussian and independent of S. We also assume that m ≤ n, that m is known, and that the columns of A\nare linearly independent."
    }, {
      "heading" : "2.1 Gradient Iteration with Orthogonality",
      "text" : "The gradient iteration relies on the properties of cumulants. We will focus on the fourth cumulant, though similar constructions may be given using other even order cumulants of higher order. For a zero-mean random variable X, the fourth order cumulant may be defined as κ4(X) := E[X4] − 3E[X2]2 [see 7, Chapter 5, Section 1.2]. Higher order cumulants have nice algebraic properties which make them useful for ICA. In particular, κ4 has the following properties: (1) (Independence) If X and Y are independent, then κ4(X +Y ) = κ4(X) +κ4(Y ). (2) (Homogeneity) If α is a scalar, then κ4(αX) = α\n4κ4(X). (3) (Vanishing Gaussians) If X is normally distributed then κ4(X) = 0. We consider the following function defined on the unit sphere: f(u) := κ4(〈X,u〉). Expanding\nf(u) using the above properties we obtain:\nf(u) = κ4 ( m∑ k=1 〈Ak,u〉Sk + 〈u,η〉 ) = m∑ k=1 〈Ak,u〉4κ4(Sk) .\nTaking derivatives we obtain:\n∇f(u) = 4 m∑ k=1 〈Ak,u〉3κ4(Sk)Ak (1)\nHf(u) = 12 m∑ k=1 〈Ak,u〉2κ4(Sk)AkATk = AD(u)AT (2)\nwhere D(u) is a diagonal matrix with entries D(u)kk = 12〈Ak,u〉2κ4(Sk). Voss et al. [21] introduced GI-ICA as a fixed point algorithm under the assumption that the columns of A are orthogonal but not necessarily unit vectors. The main idea is that the update u← ∇f(u)/‖∇f(u)‖ is a form of a generalized power iteration. From equation (1), each Ak may be considered as a direction in a hidden orthogonal basis of the space. During each iteration, the Ak coordinate of u is raised to the 3\nrd power and multiplied by a constant. Treating this iteration as a fixed point update, it was shown that given a random starting point, this iterative procedure converges rapidly to one of the columns of A (up to a choice of sign). The rate of convergence is cubic.\nHowever, the GI-ICA algorithm requires a somewhat complicated preprocessing step called quasi-orthogonalization to linearly transform the data to make columns of A orthogonal. Quasiorthogonalization makes use of evaluations of Hessians of the fourth cumulant function to construct a matrix of the form C = ADAT where D has all positive diagonal entries—a task which is complicated by the possibility that the latent signals Si may have fourth order cumulants of differing signs—and requires taking the matrix square root of a positive definite matrix of this form. However, the algorithm used for constructing C under sampling error is not always positive definite in practice, which can make the preprocessing step fail. We will show how our PEGI algorithm makes quasi-orthogonalization unnecessary, in particular, resolving this issue."
    }, {
      "heading" : "2.2 Gradient Iteration in a Pseudo-Euclidean Space",
      "text" : "We now show that the gradient iteration can be performed using in a pseudo-Euclidean space in which the columns of A are orthogonal. The natural candidate for the “inner product space” would be to use 〈·, ·〉∗ defined as 〈u,v〉∗ := uT (AAT )†v. Clearly, 〈Ai, Aj〉∗ = δij gives the desired\nAlgorithm 1 Recovers a column of A up to a scaling factor if u0 is generically chosen.\nInputs: Unit vector u0, C, ∇f k ← 1 repeat\nuk ← ∇f(C†uk−1)/‖∇f(C†uk−1)‖ k ← k + 1\nuntil Convergence (up to sign) return uk\northogonality property. However, there are two issues with this “inner product space”: First, it is only an inner product space when A is invertible. This turns out not to be a major issue, and we move forward largely ignoring this point. The second issue is more fundamental: We only have access to AAT in the noise free setting where cov(X) = AAT . In the noisy setting, we have access to matrices of the form Hf(u) = AD(u)AT from equation (2) instead. consider a pseudo-Euclidean inner product defined as follows: Let C = ADAT where D is a diagonal matrix with non-zero diagonal entries, and define 〈·, ·〉C by 〈u,v〉C = uTC†v. When D contains negative entries, this is not a proper inner product since C is not positive definite. In particular, 〈Ak, Ak〉C = ATk (ADA T )†Ak = d −1 kk may be negative. Nevertheless, when k 6= j, 〈Ak, Aj〉C = A T k (ADA\nT )†Aj = 0 gives that the columns of A are orthogonal in this space.\nWe define functions αk : Rn → R by αk(u) = (A†u)k such that for any u ∈ span(A1, . . . , Am), then u = ∑m i=1 αi(u)Ai is the expansion of u in its Ai basis. Continuing from equation (1), for\nany u ∈ Sn−1 we see ∇f(C†u) = 4 ∑n k=1〈Ak, C†u〉3κ4(Sk)Ak = 4 ∑n\nk=1〈Ak,u〉3Cκ4(Sk)Ak is the gradient iteration recast in the 〈·, ·〉C space. Expanding u in its Ak basis, we obtain\n∇f(C†u) = 4 m∑ k=1 (αk(u)〈Ak, Ak〉C)3κ4(Sk)Ak = 4 m∑ k=1 αk(u) 3(d−3kk κ4(Sk))Ak , (3)\nwhich is a power iteration in the unseen Ak coordinate system. As no assumptions are made upon the κ4(Sk) values, the d −3 kk scalings which were not present in eq. (1) cause no issues. Using this update, we obtain Alg. 1, a fixed point method for recovering a single column of A up to an unknown scaling.\nBefore proceeding, we should clarify the notion of fixed point convergence in Algorithm 1. We say that the sequence {uk}∞k=0 converges to v up to sign if there exists a sequence {ck}∞k=0 such that each ck ∈ {±1} and ckuk → v as k →∞. We have the following convergence guarantee.\nTheorem 1. If u0 is chosen uniformly at random from S n−1, then with probability 1, there exists ` ∈ [m] such that the sequence {uk}∞k=0 defined as in Algorithm 1 converges to A`/‖A`‖ up to sign. Further, the rate of convergence is cubic.\nDue to limited space, we omit the proof of Theorem 1. It is similar to the proof of [21, Theorem 4].\nIn practice, we test near convergence by checking if we are still making significant progress. In particular, for some predefined > 0, if there exists a sign value ck ∈ {±1} such that ‖uk − ckuk−1‖ < , then we declare convergence achieved and return the result. As there are only two choices for ck, this is easily checked, and we exit the loop if this condition is met. Full ICA Recovery Via the Pseudo-Euclidean GI-Update. We are able to recover a single column of A up to its unknown scale. However, for full recovery of A, we would like (given recovered columns A`1 , . . . , A`j ) to be able to recover a column Ak such that k 6∈ {`1, . . . , `j} on demand.\nAlgorithm 2 Full ICA matrix recovery algorithm. Returns two matrices: (1) Ã is the recovered mixing matrix for the noisy ICA model X = AS + η, and (2) B̃ is a running estimate of Ã†.\n1: Inputs: C, ∇f 2: Ã← 0, B̃ ← 0 3: for j ← 1 to m do 4: Draw u uniformly at random from Sn−1. 5: repeat 6: u← u− ÃB̃u 7: u← ∇f(C†u)/‖∇f(C†u)‖. 8: until Convergence (up to sign) 9: Ãj ← u\n10: B̃j· ← [C†Aj/((C†Aj)TAj)]T 11: end for 12: return Ã, B̃\nThe idea behind the simultaneous recovery of all columns of A is two-fold. First, instead of just finding columns of A using Algorithm 1, we simultaneously find rows of A†. Then, using the recovered columns of A and rows of A†, we project u onto the orthogonal complement of the recovered columns of A within the 〈·, ·〉C pseudo-inner product space.\nRecovering rows of A†. Suppose we have access to a column Ak (which may be achieved using Algorithm 1). Let A†k· denote the k th row of A†. Then, we note that C†Ak = (ADA T )†Ak = d−1kk (A T )†k = d −1 kk (A † k·) T recovers A†k· up to an arbitrary, unknown constant d −1 kk . However, the constant d−1kk may be recovered by noting that 〈Ak, Ak〉C = (C †Ak) TAk = d −1 kk . As such, we may estimate A†k· as [C †Ak/((C †Ak) TAk)]\nT . Enforcing Orthogonality During the GI Update. Given access to a vector u = ∑m k=1 αk(u)Ak + PA⊥u (where PA⊥ is the projection onto the orthogonal complements of the range of A), some recovered columns A`1 , . . . , A`r , and corresponding rows of A †, we may zero out the compo-\nnents of u corresponding to the recovered columns of A. Letting u′ = u − ∑r\nj=1A`jA † `j ·u, then u′ = ∑\nk∈[m]\\{`1,...,`r} αk(u)Ak + PA⊥u. In particular, u ′ is orthogonal (in the 〈·, ·〉C space) to the\npreviously recovered columns of A. This allows the non-orthogonal gradient iteration algorithm to recover a new column of A.\nUsing these ideas, we obtain Algorithm 2, which is the PEGI algorithm for recovery of the mixing matrix A in noisy ICA up to the inherent ambiguities of the problem. Within this Algorithm, step 6 enforces orthogonality with previously found columns of A, guaranteeing that convergence to a new column of A. Practical Construction of C. In our implementation, we set C = 112 ∑n k=1Hf(ek), as it can be\nshown from equation (2) that ∑n\nk=1Hf(ek) = ADAT with dkk = ‖Ak‖2κ4(Sk). This deterministically guarantees that each latent signal has a significant contribution to C."
    }, {
      "heading" : "3 SINR Optimal Recovery in Noisy ICA",
      "text" : "In this section, we demonstrate how to perform SINR optimal ICA within the noisy ICA framework given access to an algorithm (such as PEGI) to recover the directions of the columns of A. To this end, we first discuss the SINR optimal demixing solution within any decomposition of the ICA\nmodel into signal and noise as X = AS+η. We then demonstrate that the SINR optimal demixing matrix is actually the same across all possible model decompositions, and that it can be recovered. The results in this section hold in greater generality than in section 2. They hold even if m ≥ n (the underdetermined setting) and even if the additive noise η is non-Gaussian.\nConsider B an m × n demixing matrix, and define Ŝ(B) := BX the resulting approximation to S. It will also be convenient to estimate the source signal S one coordinate at a time: Given a row vector b, we define Ŝ(b) := bX. If b = Bk· (the k\nth row of B), then Ŝ(b) = [Ŝ(B)]k = Ŝk(B) is our estimate to the kth latent signal Sk. Within a specific ICA model X = AS + η, signal to intereference-plus-noise ratio (SINR) is defined by the following equation:\nSINRk(b) := var(bAkSk)\nvar(bAS− bAkSk) + var(bη) =\nvar(bAkSk)\nvar(bAX)− var(bAkSk) . (4)\nSINRk is the variance of the contribution of k th source divided by the variance of the noise and interference contributions within the signal. Given access to the mixing matrix A, we define Bopt = A\nH(AAH + cov(η))†. Since cov(X) = AAH +cov(η), this may be rewritten as Bopt = A\nH cov(X)†. Here, cov(X)† may be estimated from data, but due to the ambiguities of the noisy ICA model, A (and specifically its column norms) cannot be estimated from data.\nKoldovskỳ and Tichavskỳ [15] observed that when η is a white Gaussian noise, Bopt jointly maximizes SINRk for each k ∈ [m], i.e., SINRk takes on its maximal value at (Bopt)k·. Below in Proposition 2, we generalize this result to include arbitrary non-spherical, potentially non-Gaussian noise.\nIt is interesting to note that even after the data is whitened, i.e. cov(X) = I, the optimal SINR solution is different from the optimal solution in the noiseless case unless A is an orthogonal matrix, i.e. A† = AH . This is generally not the case, even if η is white Gaussian noise.\nProposition 2. For each k ∈ [m], (Bopt)k· is a maximizer of SINRk.\nThe proof of Proposition 2 is deferred to appendix B. Since SINR is scale invariant, Proposition 2 implies that any matrix of the form DBopt = DAH cov(X)† where D is a diagonal scaling matrix (with non-zero diagonal entries) is an SINRoptimal demixing matrix. More formally, we have the following result.\nTheorem 3. Let Ã be an n×m matrix containing the columns of A up to scale and an arbitrary permutation. That is, there exists a permutation π of [m] and non-zero constants α1, . . . , αm such that αkÃπ(k) = Ak for each k ∈ [m]. Then, (ÃH cov(X)†)π(k)· is a maximizer of SINRk.\nBy Theorem 3, given access to a matrix Ã which recovers the directions of the columns of A, then ÃH cov(X)† is the SINR-optimal demixing matrix. For ICA in the presence of Gaussian noise, the directions of the columns of A are well defined simply from X, that is, the directions of the columns of A do not depend on the decomposition of X into signal and noise (see the discussion in section 1.1 on ICA indeterminacies). The problem of SINR optimal demixing is thus well defined for ICA in the presence of Gaussian noise, and the SINR optimal demixing matrix can be estimated from data without any additional assumptions on the magnitude of the noise in the data.\nFinally, we note that in the noise-free case, the SINR-optimal source recovery simplifies to be Ã†.\nCorollary 4. Suppose that X = AS is a noise free (possibly underdetermined) ICA model. Suppose that Ã ∈ Rn×m contains the columns of A up to scale and permutation, i.e., there exists diagonal matrix D with non-zero entries and a permutation matrix Π such that Ã = ADΠ. Then Ã† is an SINR-optimal demixing matrix.\nSINR Comparison (d=14, Noise Power=0.67, mixed distr)\nSINR Loss Comparison (d=14, Sample Size=106 , mixed distr)\nProof. By Theorem 3, (AD−1Π)H cov(X)† is an SINR-optimal demixing matrix. Expanding, we obtain: (AD−1Π)H cov(X)† = ΠHD−1AH(AAH)† = ΠHD−1A† = (ADΠ)† = Ã†.\nCorollary 4 is consistent with known beamforming results. In particular, it is known that A† is an optimal (in terms of minimum mean squared error) beamforming matrix for underdetermined ICA [19, section 3B]."
    }, {
      "heading" : "4 Experimental Results",
      "text" : "We now compare the proposed PEGI algorithm with several existing ICA algorithms. In addition to qorth+GI-ICA (that is, GI-ICA with the quasi-orthogonalization preprocessing step), we use the following algorithmic baselines: JADE [3] is a popular fourth cumulant based ICA algorithm designed for the noise free setting. We use the implementation of Cardoso and Souloumiac [5]. FastICA [12] is a popular ICA algorithm designed for the noise free setting based on a deflationary approach of recovering one component at a time. We use the implementation of Gävert et al. [10]. 1FICA [16, 17] is a variation of FastICA with the tanh contrast function designed to have low bias for performing SINR-optimal beamforming in the presence of Gaussian noise. Ainv is the oracle demixing algorithm which uses A† as the demixing matrix. SINR-opt is the oracle demixing algorithm which demixes using AH cov(X)† to achieve an SINRoptimal demixing.\nWe compare these algorithms on simulated data with n = m. We constructed mixing matrices A with condition number 3 via a reverse singular value decomposition (A = UΛV T ). The matrices U and V were random orthogonal matrices, and Λ was chosen to have 1 as its minimum and 3 as its maximum singular values, with the intermediate singular values chosen uniformly at random. We drew data from a noisy ICA model X = AS+η where cov(η) = Σ was chosen to be malaligned with cov(AS) = AAT . We set Σ = p(10I − AAT ) where p is a constant defining the noise power. It can be shown that p = maxv var(v\nTη) maxv var(vTAS) is the ratio of the maximum directional noise variance\nto the maximum directional signal variance. We generated 100 matrices A for our experiments with 100 corresponding ICA data sets for each sample size and noise power. When reporting\nSINR Comparison (d=14, Noise Power=0.67, mixed distr)\nresults, we apply each algorithm to each of the 100 data sets for the corresponding sample size and noise power and we report the mean performance. The source distributions used in our ICA experiments were the Laplace and Bernoulli distribution with parameters 0.05 and 0.5 respectively, the t-distribution with 3 and 5 degrees of freedom respectively, the exponential distribution, and the uniform distribution. Each distribution was normalized to have unit variance, and the distributions were each used twice to create 14-dimensional data. We compare the algorithms using either SINR or the SINR loss from the optimal demixing matrix (defined by SINR Loss = [Optimal SINR − Achieved SINR]).\nIn Figure 1b, we compare our proprosed ICA algorithm with various ICA algorithms for signal recovery. In the PEGI-κ4+SINR algorithm, we use PEGI-κ4 to estimate A, and then perform demixing using the resulting estimate of AH cov(X)−1, the formula for SINR-optimal demixing. It is apparent that when given sufficient samples, PEGI-κ4+SINR provides the best SINR demixing. JADE, FastICA-tanh, and 1FICA each have a bias in the presence of additive Gaussian noise which keeps them from being SINR-optimal even when given many samples.\nn Figure 1a, we compare algorithms at various sample sizes. The PEGI-κ4+SINR algorithm relies more heavily on accurate estimates of fourth order statistics than JADE, and the FastICAtanh and 1FICA algorithms do not require the estimation of fourth order statistics. For this reason, PEGI-κ4+SINR requires more samples than the other algorithms in order to be run accurately. However, once sufficient samples are taken, PEGI-κ4+SINR outperforms the other algorithms including 1FICA which is designed to have low SINR bias.\nIn order to avoid clutter, we did not include qorth+GI-ICA-κ4+SINR (the SINR optimal demixing estimate constructed using qorth+GI-ICA-κ4 to estimate A) in the figures 1b and 1a. It is also assymptotically unbiased in estimating the directions of the columns of A, and similar conclusions could be drawn using qorth+GI-ICA-κ4 in place of PEGI-κ4. However, in Figure 2, we see that PEGI-κ4+SINR requires fewer samples than qorth+GI-ICA-κ4+SINR to achieve good performance. This is particularly highlighted in the medium sample regime.\nOn the Performance of Traditional ICA Algorithms for Noisy ICA. An interesting observation [first made in 15] is that the popular noise free ICA algorithms JADE and FastICA perform reasonably well in the noisy setting. In Figures 1b and 1a, they significantly outperform\ndemixing using A−1 for source recovery. It turns out that this may be explained by a shared preprocessing step. Both JADE and FastICA rely on a whitening preprocessing step in which the data are linearly transformed to have identity covariance. It can be shown in the noise free setting that after whitening, the mixing matrix A is a rotation matrix. These algorithms proceed by recovering an orthogonal matrix Ã to approximate the true mixing matrix A. Demixing is performed using Ã−1 = ÃH . Since the data is white (has identity covariance), then the demixing matrix ÃH = ÃH cov(X)−1 is an estimate of the SINR-optimal demixing matrix. Nevertheless, the traditional ICA algorithms give a biased estimate of A under additive Gaussian noise."
    }, {
      "heading" : "A PEGI for Complex Signals",
      "text" : "In Section 2, we showed how to perform gradient iteration ICA within a pseudo-Euclidean inner product space. In this appendix, we show how this PEGI algorithm can be extended to include complex valued signals. For clarity, we repeat the entire PEGI algorithmic construction from Section 2 with the necessary modifications to handle the complex setting.\nThroughout this appendix, we assume a noisy ICA model X = AS + η where η is an arbitrary Gaussian noise independent of S. We also assume that m ≤ n, that m is known, and that the columns of A are linearly dependent.\nA.1 Fourth Cumulants of Complex Variables\nThe gradient iteration relies on the properties of cumulants. We will focus on the fourth cumulant, though similar constructions may be given using other even order cumulants of higher order. We will use two versions of the fourth cumulant which capture slightly different fourth order information. For a zero-mean random variable X, they may be defined as κ4(X) := E[X4] − 3E[X2]2 and κ?4(X) := E[X2X∗2] − 2E[XX∗]2 − E[X2]E[X∗2]. For real random variables, these two definitions are equivalent, and they come from two different conjugation schemes when constructing the fourth order cumulant [see 7, Chapter 5, Section 1.2]. However, in general, only κ?4 is guaranteed to be real valued. The higher order cumulants have nice algebraic properties which make them useful for ICA:\n1. (Independence) If X and Y are independent random variables, then κ4(X + Y ) = κ4(X) + κ4(Y ) and κ ? 4(X + Y ) = κ4(X + Y ).\n2. (Homogeneity) If α is a scalar, then κ4(αX) = α 4κ4(X) and κ ? 4(αX) = |α| 4κ?4(X).\n3. (Vanishing Gaussians) If X is normally distributed then κ4(X) = 0 and κ ? 4(X) = 0.\nIn this appendix, we consider a noisy ICA model X = AS + η where η is a 0-mean (possibly complex) Gaussian and independent of S. We consider the following functions defined on the unit sphere: f(u) := κ4(〈X,u〉) and f?(u) := κ?4(〈X,u〉). Then, expanding using the above properties we obtain:\nf(u) = κ4 ( m∑ k=1 〈Ak,u〉Sk + 〈u,η〉 )\n= m∑ k=1 〈Ak,u〉4κ4(Sk)\nUsing similar reasoning, it can be seen that f?(u) = ∑m k=1 |〈Ak,u〉| 4κ?4(Sk).\nIt turns out that some slightly non-standard notions of derivatives are most useful in constructing the gradient iteration in the complex setting. We use real derivatives for the gradient and we use the complex Hessian. In particular, expanding uk = xk + iyk, we use the gradient operator ∇ := ∑n k=1 ek ∂ ∂xk . We make use of the operators ∂uk := 1 2( ∂ ∂xk − i ∂∂yk ) and ∂u ∗ k := 1 2( ∂ ∂xk + i ∂∂yk ) to\ndefine H := ∑n\nj=1 ∑n k=1 eke T j ∂uk∂u ∗ j . Applying this version of the Hessian is different than using\nreal derivatives as in the gradient operation. Taking derivatives, we obtain:\n∇f(u) = 4 m∑ k=1 〈Ak,u〉3κ4(Sk)Ak (5)\nHf?(u) = 4 m∑ k=1 |〈Ak,u〉|2κ?4(Sk)A∗kATk\n= A∗D(u)AT (6)\nwhere D(u) is a diagonal matrix with entries D(u)kk = 4|〈Ak,u〉|2κ?4(Sk).\nAlgorithm 3 Recovers a column of A up to an unknown scaling factor when u0 is generically chosen.\nInputs: u0 (A unit vector), C, ∇f k ← 1 repeat\nuk ← ∇f(C† ∗ uk−1)/‖∇f(C† ∗ uk−1)‖\nk ← k + 1 until Convergence (up to a unit modulus factor) return uk\nA.2 Gradient Iteration in a Pseudo-Euclidean Space\nWe now demonstrate that the gradient iteration can be performed using a generalized notion of an inner product space in which the columns of A are orthogonal. The natural candidate for the “inner product space” would be to use 〈·, ·〉∗ defined as 〈u,v〉∗ := uT (A∗AT )†v∗. Clearly, 〈Ai, Aj〉∗ = δij gives the desired orthogonality property. However, there are two issues with this “inner product space”: First, it is only an inner product space when A is non-singular (invertible). This turns out not to be a major issue, and we will move forward largely ignoring this point. The second issue is more fundamental: We only have access to the matrix A∗AT in the noise free setting where cov(X)T = (AAH)T = A∗AT . In the noisy setting, we have access to matrices of the form Hf?(u) = A∗D(u)AT from equation (6) instead.\nWe consider a pseudo-Euclidean inner product defined as follows: Let C = A∗DAT where D is a diagonal matrix with non-zero diagonal entries, and define 〈·, ·〉C by 〈u,v〉C = uTC†v∗. When D contains negative entries, this is not a proper inner product since C is not positive definite. In particular, 〈Ak, Ak〉C = ATk (A∗DAT )†A∗k = d −1 kk may be negative. Nevertheless, when k 6= j, 〈Ak, Aj〉C = ATk (A∗DAT )†A∗j = 0 gives that the columns of A are orthogonal in this space. We define functions αk : Cn → C by αk(u) = (A†u)k such that for any u ∈ span(A1, . . . , Am),\nthen u = ∑m\ni=1 αi(u)Ai is the expansion of u in its Ai basis. Continuing from equation (5), for any u ∈ Sn−1 we see\n∇f(C†∗u) = 4 n∑ k=1 〈Ak, C† ∗ u〉3κ4(Sk)Ak\n= 4 n∑ k=1 〈Ak,u〉3Cκ4(Sk)Ak\nis the gradient iteration recast in the 〈·, ·〉C space. Expanding u in its Ak basis, we obtain\n∇f(C†∗u) = 4 m∑ k=1 (αk(u)〈Ak, Ak〉C)3κ4(Sk)Ak\n= 4 m∑ k=1 αk(u) 3(d−3kk κ4(Sk))Ak , (7)\nwhich is a power iteration in the unseen Ak coordinate system. As no assumptions are made upon the κ4(Sk) values, the d −3 kk scalings which were not present in equation (5) cause no issues. Using this update, we obtain Algorithm 3, a fixed point method for recovering a single column of A up to an unknown scaling.\nBefore proceeding, we should clarify the notion of fixed point convergence in Algorithm 3. We say that the sequence {uk}∞k=0 converges to v up to a unit modulus factor if there exists a sequence of constants {ck}∞k=0 such that each |ck| = 1 and ckuk → v as k → ∞. We have the following convergence guarantee.\nTheorem 5. If u0 is chosen uniformly at random from S n−1. Then with probability 1, there exists ` ∈ [m] such that the sequence {uk}∞k=0 defined as in Algorithm 3 converges to a A`/‖A`‖ up to a unit modulus factor. Further, the rate of convergence is cubic.\nDue to space limitations, we omit the proof of Theorem 5. However, its proof is very similar that of an analogous result for the GI-ICA algorithm [21, Theorem 4].\nIn practice, we test near convergence by testing if we are still making significant progress. In particular, for some predefined > 0, if there exists a unit modulus constant ck such that ‖uk− ckuk−1‖ < , then we declare convergence achieved and return the result. We may determine ck using the following fact. Fact 6. Suppose that u and v are non-orthogonal unit modulus vectors. The expression ‖u−eiθv‖ is minimized by the choice of θ = atan2(Im(〈u,v〉),Re(〈u,v〉)).\nLetting θ = atan2(Im(〈uk,uk−1〉),Re(〈uk,uk−1〉), we exit the loop if ‖uk − eiθuk−1‖ < .\nA.3 Full ICA Recovery Via the Pseudo-Euclidean GI-Update\nWe are able to recover a single column of A in noisy ICA. However, for full matrix recovery, we would like (given recovered columns A`1 , . . . , A`j ) to be able to recover a column Ak such that k 6∈ {`1, . . . , `j} on demand.\nThe main idea behind the simultaneous recovery of all columns of A is two-fold. First, instead of just finding columns of A using Algorithm 3, we simultaneously find rows of A†. Then, using the recovered columns of A and rows of A†, we may project u onto the orthogonal complement of the recovered columns of A within the 〈·, ·〉C pseudo-Euclidean inner product space.\nRecovering rows of A†. Suppose we have access to a column Ak (which may be achieved using Algorithm 3). Let A†k· denote the k th row of A†. Then, we note that C†A∗k = (A ∗DAT )†A∗k = d−1kk (A T )†k = d −1 kk (A † k·) T recovers A†k· up to an arbitrary, unknown constant d −1 kk . However, the constant d−1kk may be recovered by noting that 〈Ak, Ak〉C = (C †Ak) TAk = d −1 kk . As such, we may estimate A†k· as [C †Ak/((C †Ak) TAk)] T . Enforcing Orthogonality During the GI Update. Given access to u = ∑m\nk=1 αk(u)Ak + PA⊥u, some recovered columns A`1 , . . . , A`r , and corresponding rows of A †, we may zero out the\ncomponents of u corresponding to the recovered columns of A. Letting u′ = u − ∑r\nj=1A`jA † `j ·u, then u′ = ∑\nk∈[m]\\{`1,...,`r} αk(u)Ak + PA⊥u. In particular, u ′ is orthogonal (in the 〈·, ·〉C space)\nto the previously recovered columns of A. This allows us to modify the non-orthogonal gradient iteration algorithm to recover a new column of A.\nUsing these ideas, we obtain the Algorithm 4 for recovery of the ICA mixing matrix. Within this Algorithm, step 6 enforces orthogonality with previously found columns of A, guaranteeing that convergence is to a new column of A. Practical Construction of C We suggest the choice of C = 14 ∑n\nk=1Hf?(ek), as it can be shown from equation (6) that ∑n k=1Hf?(ek) = A∗DAT with dkk = ‖Ak‖2κ?4(Sk). This deterministically guarantees that each latent signal has a significant contribution to C.\nAlgorithm 4 Full ICA matrix recovery algorithm. Estimates and returns two matrices: (1) Ã is the recovered mixing matrix for the noisy ICA model X = AS+η, and (2) B̃ is a running estimate of Ã†.\n1: Inputs: C, ∇f 2: Ã← 0, B̃ ← 0 3: for j ← 1 to m do 4: Draw u uniformly at random from Sn−1. 5: repeat 6: u← u− ÃB̃u 7: u← ∇f(C†∗u)/‖∇f(C†∗u)‖. 8: until Convergence (up to a unit modulus factor) 9: Ãj ← u\n10: B̃j· ← [C†Aj/((C†Aj)TAj)]T 11: end for 12: return Ã, B̃"
    }, {
      "heading" : "B Proof of Proposition 2",
      "text" : "Proof. This proof is based on the connection between two notions of optimality, minimum mean squared error and SINR. The mean squared error of the recovered signal Ŝ(b) from kth latent signal is defined as MSEk(b) := E[|Sk − Ŝ(b)| 2 ]. It has been shown [14, equation 39] that Bopt jointly minimizes the mean squared errors of the recovered signals. In particular, if b = (Bopt)k·, then b is a minimizer of MSEk(b).\nWe will first show that finding a matrix B which minimizes the mean squared error has the side effect of maximizing the magnitude of the Pearson correlations ρSk,Ŝk(B) for each k ∈ [m], where ρSk,Ŝk(B) := E[SkŜ∗k(B)] σSkσŜk(B)\n. We will then demonstrate that if B is a maximizer of |ρSk,Ŝk(B)|, then Bk· is a maximizer of SINRk. These two facts imply the desired result. We will use the convention that ρSk,Ŝk(B) is 0 if σŜk(B) = 0.\nWe fix a k ∈ [m]. We have:\nMSEk(b) = E[SkS∗k − 2 Re(SkŜ∗(b)) + Ŝ(b)Ŝ∗(b)] = 1− 2σŜ(b) Re(ρSk,Ŝ(b)) + σ 2 Ŝ(b) .\nLetting ω = sgn(ρSk,Ŝ(b)), we obtain\nρSk,Ŝ(ωb) = E[SkŜ∗(ωb)] σSkσŜ(ωb) = ω∗ E[SkŜ∗(b)] σSkσŜ(b) = |ρSk,Ŝ(b)| . (8)\nFurther, MSEk(ωb) = 1− 2σŜ(b)|ρSk,Ŝ(b)|+ σ 2 Ŝ(b) ≤ MSEk(b) with equality if and only if ρSk,Ŝ(b) is real and non-negative. As such, all global minima of MSEk are contained in the set A = {b | ρSk,Ŝ(b) ∈ [0, 1]}, and we may restrict our investigation to this set.\nWe define a function g(x, y) := 1−2xy+y2 such that under the change of variable x(b) = σŜ(b) and y(b) = ρSk,Ŝ(b), we obtain MSEk(b) = g(x, y). Let M = maxb∈A ρSk,Ŝ(b) and let y0 ∈ [0,M ] be fixed. Then, arg minx∈R g(x, y0) = y0 with the resulting value g(y0, y0) = 1 − y20. As such, the minimum of g(x, y) over the domain R × [0,M ] occurs when x = y = M . If M = 0, then the\nchoice of ξ = 0 satisfies that x(ξ) = y(ξ) = 0, making MSEk(ξ) = g(x, y) the global minimum of MSEk. If M 6= 0, then we may choose ξ such that y(ξ) = ρSk,Ŝ(ξ) = M . As σŜ(ξ) > 0 must hold, it follows that there exists α ∈ (0,∞) such that setting ζ = αξ, we obtain (σŜ(ζ) =)x(ζ) = y(ξ). Since y(b) = ρSk,Ŝ(b) is scale invariant, we obtain that x(ζ) = y(ζ) = y(ξ) = M , making ζ a global minimum of MSEk. In both cases, it follows that if b minimizes MSEk(b), then b maximizes ρSk,Ŝ(b) over A.\nFrom equation (8), we see that maxb∈Cn |ρSk,Ŝ(b)| = maxb∈A ρSk,Ŝ(b). Thus if b is a minimizer of MSEk(ωb), then b is also a maximizer of |ρSk,Ŝ(b)| as claimed.\nWe now demonstrate that b is a maximizer of |ρSk,Ŝ(b)| if and only if it is also a maximizer of SINRk(b). Under the conventions that x 0 = +∞ when x > 0 and that 0 0 = s∞ where s = −1 for maximization problems and s = +1 for minimization problems, the following problems have equivalent solution sets over choices of b:\nmax b SINRk(b) ≡ max b E[|bAkSk|2] var(Ŝ(b))− E[|bAkSk|2] ≡ max b\n|E[SkŜ∗(b)]| 2\nvar(Ŝ(b))− |E[SkŜ∗(b)]| 2\n≡ min b\nvar(Ŝ(b))− |E[SkŜ∗(b)]| 2\n|E[SkŜ∗(b)]| 2 ≡ minb\nvar(Ŝ(b))\n|E[SkŜ∗(b)]| 2\n≡ max b\n|E[SkŜ∗(b)]| 2\nvar(Ŝ(b)) ≡ max b |ρSk,Ŝ(b)| 2 .\nIn the above, the first equivalence is a rewriting of equation (4). To see the second equivalence, we note that |E[SkŜ∗(b)]| 2\n= |E[Sk(bAS + bη)∗]|2 = |bAk|2 using the independence of Sk from all other terms. Then, noting that |bAk|2 = E[|bAkSk|2] gives the equivalence. The fourth equivalence is only changing the problem by the additive constant −1."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : "Independent Component Analysis (ICA) is a popular model for blind signal separation. The<lb>ICA model assumes that a number of independent source signals are linearly mixed to form the<lb>observed signals. We propose a new algorithm, PEGI (for pseudo-Euclidean Gradient Iteration),<lb>for provable model recovery for ICA with Gaussian noise. The main technical innovation of the<lb>algorithm is to use a fixed point iteration in a pseudo-Euclidean (indefinite “inner product”)<lb>space. The use of this indefinite “inner product” resolves technical issues common to several<lb>existing algorithms for noisy ICA. This leads to an algorithm which is conceptually simple,<lb>efficient and accurate in testing.<lb>Our second contribution is combining PEGI with the analysis of objectives for optimal re-<lb>covery in the noisy ICA model. It has been observed that the direct approach of demixing with<lb>the inverse of the mixing matrix is suboptimal for signal recovery in terms of the natural Signal<lb>to Interference plus Noise Ratio (SINR) criterion. There have been several partial solutions<lb>proposed in the ICA literature. It turns out that any solution to the mixing matrix reconstruc-<lb>tion problem can be used to construct an SINR-optimal ICA demixing, despite the fact that<lb>SINR itself cannot be computed from data. That allows us to obtain a practical and provably<lb>SINR-optimal recovery method for ICA with arbitrary Gaussian noise.",
    "creator" : "LaTeX with hyperref package"
  }
}