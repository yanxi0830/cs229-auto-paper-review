{
  "name" : "1703.02721.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "On Approximation Guarantees for Greedy Low Rank Optimization",
    "authors" : [ "Rajiv Khanna", "Ethan R. Elenberg", "Alexandros G. Dimakis", "Sahand Negahban" ],
    "emails" : [ "rajivak@utexas.edu,", "elenberg@utexas.edu,", "dimakis@austin.utexas.edu", "sahand.negahban@yale.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Low rank matrix estimation stands as a major tool in modern dimensionality reduction and unsupervised learning. The singular value decomposition can be used when the optimization objective is rotationally invariant to the parameters. However, if we wish to optimize over more complex objectives we must choose to either optimize over the non-convex space (which have seen recent theoretical success) [1, 2, 3, 4, 5] or rely on convex relaxations to the non-convex optimization [6, 7, 8].\nMore concretely, in the low-rank matrix optimization problem we wish to solve\narg max Θ\n`(Θ) s.t. rank(Θ) ≤ r, (1)\nand rather than perform the computationally intractable optimization above researchers have studied convex relaxations of the form\narg max Θ\n`(Θ)− λ|||Θ|||nuc.\nUnfortunately, the above optimization can be computationally taxing. General purpose solvers for the above optimization problem that rely on semidefinite programming require Θ(n3d3) computation, which is prohibitive. Gradient descent techniques require Θ( −1/2(n3 +d3)) computational cost for an epsilon accurate solution. This improvement is sizeable in comparison to SDP solvers. Unfortunately, it is still prohibitive for large scale matrix estimation.\nTo alleviate some of the computational issues an alternate vein of research has focused on directly optimizing the non-convex problem in (1). To that end, authors have studied the convergence properties of\narg max U∈Rn×r,V∈Rd×r\n`(UVT ).\nar X\niv :1\n70 3.\n02 72\n1v 1\n[ st\nat .M\nL ]\nSolving the problem above automatically forces the solution to be low rank and recent results have shown promising behavior. An alternative approach is to optimize via rank one updates to the current estimate [9, 10]. This approach has also been studied in more general contexts such as boosting [11], coordinate descent [12, 13], and incremental atomic norm optimization [14, 15, 16, 17]."
    }, {
      "heading" : "1.1 Set Function Optimization and Coordinate Descent",
      "text" : "The perspective that we take is treating low rank matrix estimation as a set optimization over an infinite set of atoms. Specifically, we wish to optimize\narg max {X1,...Xk}∈A ` ( k∑ i=1 αiXi ) ,\nwhere the set of atoms A is the set of all rank one matrices with unit operator norm. This settings is analogous to that taken in the results studying atomic norm optimization, coordinate descent via the norm in total variation, and Frank-Wolfe style algorithms for atomic optimization. This formulation allows us to connect the problem of low rank matrix estimation to that of submodular set function optimization, which we discuss in the sequel. Before proceeding we discuss related work and an informal statement of our result."
    }, {
      "heading" : "1.2 Informal Result and Related Work",
      "text" : "Our result demonstrates an exponential decrease in the amount of error suffered by greedily adding rank one matrices to the low rank matrix approximation.\nTheorem 1 (Approximation Guarantee, Informal). If we let Θk be our estimate of the rank r matrix Θ∗ at iteration k, then for some universal constant c related to the restricted condition number of the problem we have\n`(Θk)− `(0) ≥ (1− exp(−ck/r))(`(Θ∗)− `(0)).\nNote that after k iterations the matrix Θk will be at most rank k. Now, we can contrast this result to related work.\nRelated work: There has been a wide array of studies looking at the computational and statistical benefits of rank one updates to estimating a low rank matrix. At its most basic, the singular value decomposition will keep adding rank one approximations through deflation steps. Below we discuss a few of the results.\nThe work can be generally segmented into to sets of results. Those results that present sublinear rates of convergence and those that obtain linear rates. Interestingly, parallel lines of work have also demonstrated similar convergence bounds for more general atomic or dictionary element approximations [11, 14, 15, 16]. For space constraints, we will summarize these results into two categories rather than explicitly state the results for each individual paper.\nIf we define the atomic norm of a matrix M ∈ Rn×d to be |||M|||nuc to be the sum of the singular values of that matrix, then the bounds establish in the sublinear convergence cases behave as\n`(Θ∗)− `(Θk) ≤ |||Θ∗|||2nuc\nk ,\nwhere we take Θ∗ to be the best rank k solution. What we then see is convergence towards the optimal bound. However, we expect our statistical error to behave as r(n+ d)/n where n is the number of samples that we have received from our statistical model and Θ∗ is rank r [7, 8]. We can take |||Θ∗|||nuc ≈ r, which would then imply that we would need k to behave as n/(n+ d). However, that would then imply that the rank of our matrix should grow linearly in the number of observations in order to achieve the same statistical error bounds. The above error bounds are “fast.” If we consider a model that yields slow error bounds, then we expect the error to behave like |||Θ∗|||nuc √ n+d n . In that case, we can take\nk ≥ |||Θ∗|||nuc √ n n+d , which looks better, but still requires significant growth in k as a function of n.\nTo overcome the above points, some authors have aimed to study similar greedy algorithms that then enjoy exponential rates of convergence as we show in our paper. These results share the most similarities with our own and behave as\n`(Θk) ≥ (1− γk)`(Θ∗)\nwhere Θ∗ is the best over all set of parameters. This result decays exponentially. However, when one looks at the behavior of γ it will typically act as exp (−1/min(n,d)), for an n× d matrix. As a result, we would need to take k on the order of the number of the dimensionality of the problem in order to begin to see gains. In contrast, for our result listed above, if we seek to only compare to the best rank r solution, then the gamma we find is γ = exp (−1/r). Of course, if we wish to find a solution with full-rank, then the bounds we stated above match the existing bounds.\nIn order to establish our results we rely on a notion introduced in the statistical community called restricted strong convexity. This assumption has connections to ideas such as the Restricted Isometry Property, Restricted Eigenvalue Condition, and Incoherence. In the work by Shalev-Shwartz, Gonen, and Shamir [9] they present results under a form of strong convexity condition imposed over matrices. Under that setting, the authors demonstrate that\n`(Θk) ≥ `(Θ∗)− `(0)r\nk\nwhere r is the rank of Θ∗. In contrast, our bound behaves as\n`(Θk) ≥ `(Θ∗) + (`(Θ∗)− `(0)) exp (−k/r)\nOur contributions: We improve upon the linear rates of convergence for low-rank approximation using rank one updates by connecting the coordinate descent problem to that of submodular optimization. We present this result in the sequel along with the algorithmic consequences. We demonstrate the good performance of these rank one updates in the experimental section."
    }, {
      "heading" : "2 Background",
      "text" : "We begin by fixing some notation. We represent sets using sans script fonts e.g. A,B. Vectors are represented using lower case bold letters e.g. x,y, and matrices are represented using upper case bold letters e.g. X,Y. Non-bold face letters are used for scalars e.g. j,M, r and function names e.g. f(·). The transpose of a vector or a matrix is represented by > e.g. X>. Define [p] := {1, 2, . . . , p}. For singleton sets, we write f(j) := f({j}). Size of a set S is denoted by |S|. 〈·, ·〉 is used for matrix inner product.\nOur goal is to analyze greedy algorithms for low rank estimation. Consider the classic greedy algorithm that picks up the next element myopically i.e. given the solution set built so far, the algorithm picks the next element as the one which maximizes the gain obtained by adding the said element into the solution set. Approximation guarantees for the greedy algorithm readily imply for the subclass of functions called submodular functions which we define next.\nDefinition 1. A set function f(·) : [p]→ R is submodular if for all A,B ⊆ [p],\nf(A) + f(B) ≥ f(A ∪ B) + f(A ∩ B).\nSubmodular set functions are well studied and have many desirable properties that allow for efficient minimization, and maximization with approximation guarantees. Our low rank estimation problem also falls under the purview of another class of functions called monotone functions. A function is called monotone if and only if f(A) ≤ f(B) for all A ⊆ B. For the specific case of maximizing monotone submodular set functions, it is known that the greedy algorithm run for (say) k iterations is guaranteed to return a solution that is within (1− 1/e) of the optimum set of size k [18]. Moreover, without further assumptions or knowledge of the function, no other polynomial time algorithm can provide a better approximation guarantee unless P=NP [19].\nMore recently, a line of works have shown that the greedy approximation guarantee that is typically applicable to monotone submodular functions can be extended to a larger class of functions called weakly submodular functions [20, 21]. Central to the notion of weak submodularity is the quantity submodularity ratio which we define next.\nDefinition 2 (Submodularity Ratio [22]). Let S, L ⊂ [p] be two disjoint sets, and f(·) : [p]→ R. The submodularity ratio of L with respect to S is given by\nγL,S := ∑ j∈S [f(L ∪ {j})− f(L)] f(L ∪ S)− f(L) . (2)\nThe submodularity ratio of a set U with respect to an integer k is given by\nγU,k := min L,S:L∩S=∅, L⊆U,|S|≤k γL,S. (3)\nIt is easy to show that f(·) is submodular if and only if γL,S ≥ 1 for all sets L and S. However, as noted by Das and Kempe [22], Elenberg et al. [20], an approximation guarantee is guaranteed when 0 < γL,S ∀L,S, thereby extending the applicability of the greedy algorithm to a much larger class of functions. The subset of monotone functions which have γL,S > 0 ∀L,S are called weakly submodular functions in the sense that even though the function is not submodular, it still provides provable bound for greedy selections.\nAlso vital to our analysis is the notion of restricted strong concavity and smoothness [23, 24].\nDefinition 3 (Low Rank Restricted Strong Concavity, Restricted Smoothness). A function ` : Rn×d → R is said to be restricted strong concave with parameter mΩ and restricted smooth with parameter MΩ if for all X,Y ∈ Ω ⊂ Rn×d,\n−mΩ 2 ‖Y −X‖2F ≥ `(Y)− `(X)− 〈∇`(X),Y −X〉\n≥ −MΩ 2 ‖Y −X‖2F .\nRemark 1. If a function `(·) has restricted strong concavity parameter m, then its negative −`(·) has restricted strong convexity parameter m. We choose to use the nomenclature of concavity for ease of exposition in terms of relationship to submodular maximization. Further, note that we define RSC/RSM conditions on the space of matrices rather than vectors.\nIt is straightforward to see that if Ω′ ⊆ Ω, then MΩ′ ≤MΩ and mΩ′ ≥ mΩ."
    }, {
      "heading" : "3 Setup",
      "text" : "In this section, we delineate our setup of low rank estimation. For the sake of convenience of relating to the framework of weak submodular maximization, we operate in the setting of maximization of a concave matrix variate function under a low rank constraint. This is equivalent to minimizing a convex matrix variate function under the low rank constraint as considered by Shalev-Shwartz et al. [9] or under nuclear norm constraint or regularization as considered by Jaggi and Sulovský [13]. The goal is to maximize a function l : Rn×d → R under a low rank constraint:\nmax rank(X)≤r `(X). (4)\nInstead of using a convex relaxation of the constrained problem (4), our approach is to enforce the rank constraint directly by adding rank 1 matrices greedily until X is of rank k. The rank 1 matrices to be added are obtained as outer product of vectors from the given vector sets U and V . e.g. U := {x ∈ Rn s.t. ‖x‖2 = 1} and V := {x ∈ Rd s.t. ‖x‖2 = 1}.\nThe problem (4) can be interpreted in a context of sparsity as long as U and V are enumerable. For example, by using the SVD theorem, it is known that we can rewrite X as ∑k i=1 αiuiv > i , where ∀i, ui ∈ U and vi ∈ V . By using enumeration of the sets U and V under a finite precision representation of real values, one can rethink of the optimization (4) as finding a sparse solution for the infinite dimensional vector α [9]. As a first step, we can define an optimization over specified support sets, similar to choosing support for classical sparsity in vectors. For a support set L,\nlet UL and VL be the matrices formed by stacking the chosen elements of U and V respectively. For the support L, we can define a set function that maximizes `(·) over L:\nf(L) = max H∈R|L|×|L|\n`(U>L HVL)− `(0). (5)\nWe will denote the optimizing matrix for a support set L as B(L). In other words, let ĤL be the argmax obtained in (5), then B(L) := U>L ĤLVL.\nThus, the low rank matrix estimation problem (4) can be reinterpreted as the following equivalent combinatorial optimization problem:\nmax |S|≤k f(S). (6)"
    }, {
      "heading" : "3.1 Algorithms",
      "text" : "We briefly state the algorithms. Our greedy algorithm is illustrated in Algorithm 1. The greedy algorithm builds the support set incrementally – adding a rank 1 matrix one at a time, so that at iteration i for 1 ≤ i ≤ k the size of the chosen support set and hence rank of the current iterate is i. We assume access to a subroutine GreedySel for the greedy selection (Step 4). This subroutine solves an inner optimization problem by calling a subroutine GreedySel which returns an atom s from the candidate support set that ensures\nf(SGi−1 ∪ {s})− f(SGi−1) ≥ τ ( f(SGi−1 ∪ {s?})− f(SGi−1) ) ,\nwhere\ns? ← arg max a∈(U×V)⊥SGi−1 f(SGi−1 ∪ {a})− f(SGi−1).\nIn words, the subroutine GreedySel ensures that the gain in f(·) obtained by using the selected atom is within τ ∈ (0, 1] multiplicative approximation to the atom with the best possible gain in f(·). The hyperparameter τ governs a tradeoff allowing a compromise in myopic gain for a possibly quicker selection.\nThe greedy selection requires to fit and score every candidate support, which is prohibitively expensive. An alternative is to choose the next atom by using the linear maximization oracle used by Frank-Wolfe [12] or Matching Pursuit algorithms [14]. This step replaces Step 4 of Algorithm 1 as illustrated in Algorithm 2. Let L = SOi−1 be the set constructed by the algorithm at iteration (i− 1). The linear oracle OMPSel returns an atom s for iteration i ensuring\n〈∇`(B(L)),usv>s 〉 ≥ τ max (u,v)∈(U×V)⊥SOi−1 〈∇`(B(L)),uv>〉.\nThe linear problem OMPSel can be considerably faster that GreedySel. OMPSel reduces to finding the left and right singular vectors of∇`(B(L)) corresponding to its largest singular value, which is O( t1−τ (log n+ log d)), where t is the number of non-zero entries of∇`(B(L)).\nAlgorithm 2 is the same as considered by Shalev-Shwartz et al. [9] as GECO (Greedy Efficient Component Optimization). However, as we shall see, our analysis provides stronger bounds than their Theorem 2.\nAlgorithm 1 GREEDY(U , V , k, τ ) 1: Input: sparsity parameter k, vector sets U , V 2: SG0 ← ∅ 3: for i = 1 . . . k do 4: s← GreedySel(τ) 5: SGi ← SGi−1 ∪ {s} 6: end for 7: return SGk , B(S G k ), f(SGk ).\nAlgorithm 2 GECO(U , V , k, τ ) same as Algorithm 1 except\n4: s← OMPSel(τ)\nRemark 2. We note that Step 5 of Algorithms 1,2 requires solving the RHS of (5) which is a matrix variate problem of size i2 at iteration i. This refitting is equivalent to the “fully-corrective” versions of Frank-Wolfe/Matching Pursuit algorithms which, intuitively speaking, extract out all the information w.r.t `(·) from the chosen set of atoms, thereby ensuring that the next rank 1 atom chosen has row and column space orthogonal to the previously chosen atoms. Thus the constrained maximization on the orthogonal complement of SGi in subroutines OMPSel and GreedySel need not be explicitly enforced, but is still shown for clarity."
    }, {
      "heading" : "4 Analysis",
      "text" : "In this section, we prove that low rank matrix optimization over the rank one atoms satisfies weak submodularity. This helps us bound the function value obtained till k greedy iterations vis-a-vis the function value at the optimal k sized selection.\nWe explicitly delineate some notation and assumptions. With slight abuse of notation, we assume `(·) is mi-strongly concave and Mi-smooth over matrices of rank i. For i ≤ j, note that mi ≥ mj and Mi ≤ Mj . Additionally, let Ω̃ := {(X,Y) : rank(X−Y) ≤ 1}, and assume `(·) is M̃1-smooth over Ω̃. It is easy to see M̃1 ≤M1.\nSince we obtain approximation bounds for the greedy algorithm similar to ones obtained using classical methods, we must also mention the corresponding assumptions in the submodular literature that further draws parallels to our analysis. Submodularity guarantees that greedy maximization of monotone normalized functions yields a (1 − 1/e) approximation. Since we are doing support selection, increasing the support size does not decrease the function value. Hence the set function we consider is monotone. Further, we also subtract `(0) to make sure f(∅) = 0 (see (5)) so that our set function is also normalized. We shall see that our bounds are of similar flavor as the classical submodularity bound.\nAs the first step, we prove that if the low rank RSC holds, then the submodularity ratio (Definition 2) is lowerbounded by the inverse condition number.\nTheorem 2. Let L be a set of k rank 1 atoms and S be a set of r rank 1 atoms where we sequentially orthogonalize the atoms against L. If `(·) is mi-strongly concave over matrices of rank i, and M̃1-smooth over the set Ω̃ := {(X,Y) : rank(X−Y) = 1}, then\nγL,r := ∑ a∈S [f(L ∪ {a})− f(L)] f(L ∪ S)− f(L) ≥ mr+k M̃1 .\nThe proof of Theorem 2 is structured around individually obtaining a lower bound for the numerator and an upper bound for the denominator of the submodularity ratio by exploiting the concavity and convexity conditions. Bounding the submodularity ratio is crucial to obtaining the approximation bounds for the greedy algorithm as we shall see in the sequel."
    }, {
      "heading" : "4.1 Greedy Improvement",
      "text" : "In this section, we obtain approximation guarantees for Algorithm 1.\nTheorem 3. Let S := SGk be the greedy solution set obtained by running Algorithm 1 for k iterations, and let S? be an optimal support set of size r. Let `(·) be mi strongly concave on the set of matrices with rank less than or equal to i, and M̃1 smooth on the set of matrices in the set Ω̃. Then,\nf(S) ≥ (1− 1 ec1 )f(S?)\n≥ (1− 1 ec2 )f(S?),\nwhere c1 = τγS,r kr and c2 = τ mr+k M̃1 k r .\nThe proof technique for the first inequality of Theorem 3 relies on lower bounding the progress made in each iteration of Algorithm 1. Intuitively, it exploits the weak submodularity to make sure that each iteration makes enough progress, and then applying an induction argument for r iterations. We also emphasize that the bounds in Theorem 3 are for normalized set function f(·) (which means f(∅) = 0). A more detailed proof is presented in the appendix.\nRemark 3. Theorem 3 provides the approximation guarantees for running the greedy selection algorithm up to k iterations to obtain a rank k matrix iterate vis-a-vis the best rank r approximation. For r = k, and τ = 1, we get an approximation bound (1− e−m/M) which is reminiscent of the greedy bound of (1− 1/e) under the framework of submodularity. Note that our analysis can not be used to establish classical submodularity. However, establishing weak submodularity that lower bounds γ is sufficient to provide slightly weaker than classical submodularity guarantees.\nRemark 4. Theorem 3 implies that to obtain (1− ) approximation guarantee in the worst case, running Algorithm 1 for k = rMmτ log 1 ) = O(r log\n1/ ) iterations suffices. This is useful when the application allows a tradeoff: compromising on the low rank constraint a little to achieve tighter approximation guarantees.\nRemark 5. Das and Kempe [22] considered the special case of greedily maximizing R2 statistic for linear regression, which corresponds to classical sparsity in vectors. They also obtain a bound of (1− 1/eγ), where γ is the submodularity ratio for their respective setup. This was generalized by Elenberg et al. [20] to general concave functions under sparsity constraints. Our analysis is for the low rank constraint, as opposed to sparsity in vectors that was considered by them."
    }, {
      "heading" : "4.2 GECO Improvement",
      "text" : "In this section, we obtain the approximation guarantees for Algorithm 2. The greedy search over the infinitely many candidate atoms is infeasible, especially when τ = 1. Thus while Algorithm 1 establishes interesting theoretical connections with submodularity, it is, in general, not practical. To obtain a tractable and practically useful algorithm, the greedy search is replaced by a Frank Wolfe or Matching Pursuit style linear optimization which can be easily implemented as finding the top singular vectors of the gradient at iteration i. In this section, we show that despite the speedup, we lose very little in terms of approximation guarantees. In fact, if the approximation factor τ in OMPSel() is 1, we get the same bounds as those obtained for the greedy algorithm.\nWe now present our main result for Algorithm 2.\nTheorem 4. Let S := SOk be the greedy solution set obtained using Algorithm 2 for k iterations, and let S? be the optimum size r support set. Let `(·) be mr+k strongly concave on the set of matrices with rank less than or equal to (r + k), and M̃1 smooth on the set of matrices with rank in the set Ω̃. Then,\nf(S) ≥ (1− 1 ec3 )f(S?),\nwhere c3 = τ2 mr+k M̃1 k r .\nThe proof of Theorem 4 follows along the lines of Theorem 3. The central idea is similar - to exploit the RSC conditions to make sure that each iteration makes sufficient progress, and then provide an induction argument for r iterations. Unlike the greedy algorithm, however, using the weak submodularity is no longer required. Note that the bound obtained in Theorem 4 is similar to Theorem 3, except the exponent on the approximation factor τ .\nRemark 6. Our proof technique for Theorem 4 can be applied for classical sparsity to improve the bounds obtained by Elenberg et al. [20] for OMP for support selection under RSC, and by Das and Kempe [22] for R2 statistic. If τ = 1, r = k, their bounds involve terms of the form O(m2/M2) in the exponent, as opposed to our bounds which only has m/M in the exponent."
    }, {
      "heading" : "5 Recovery Guarantees",
      "text" : "While understanding approximation guarantees are useful, providing parameter recovery bounds can further help us understand the practical utility of the greedy algorithm. In this section, we present a general theorem that provides us with recovery bounds of the true underlying low rank structure.\nTheorem 5. Suppose that an algorithm achieves the approximation guarantee:\nf(Sk) ≥ Cr,kf(S?r),\nwhere Sk is the set of size k at iteration k of the algorithm, S?r be the optimal solution for r-cardinality constrained maximization of f(·), and Cr,k be the corresponding approximation ratio guaranteed by the algorithm. Recall that we represent by US,VS the matrices formed by stacking the vectors represented by the support set S chosen from U ,V respectively, s.t. |S| = r. Then under mk+r RSC, with Br = U>S HVS for any H ∈ Rr×r, we have\n‖B(Sk) −Br‖2F ≤ 4(k + r) ‖∇`(Br)‖22 m2k+r\n+ 4(1− Cr,k) mk+r [`(Br)− `(0)]\nTheorem 5 can be applied for Br = B(S ? r), which is the argmax for maximizing `(·) under the low rank constraint. It is general - in the sense that it can be applied for getting recovery bounds from approximation guarantees for any algorithm, and hence is applicable for both Algorithms 1 and 2.\nFor specific function `(·) and statistical model, statistical recovery guarantees guarantees can be obtained from Theorem 5 for specific `(·) and statistical model, Consider the case of low rank matrix estimation from linear measurements. Say Xi ∈ Rm1×m2 for i ∈ [n] are generated so that each entry of Xi is N (0, 1). We observe yi = 〈Xi,Θ?〉 + ε, where Θ? is low rank, and say ε ∼ N (0, σ2). Let N = m1m2, and let ϕ(Θ) : Rm1×m2 → Rn be the linear operator so that [ϕ(Θ)]i = 〈Xi,Θ〉. Our corresponding function is now `(Θ) = − 1n‖y − ϕ(Θ)‖ 2 2. For this function, using arguments by Negahban et al. [23], we know ‖∇`(BS?r )‖22 ≤ logN n and `(B\nS?r )− `(0) ≤ (s+ 1) with high probability. It is also straightforward to apply their results to bound mk+r ≥ ( 1 32 − 162(k+r) logN n ) , and M1 ≤ 1, which gives explicit bounds as per Theorem 5 for Algorithms 1, 2 for the considered function and the design matrix."
    }, {
      "heading" : "6 Experiments",
      "text" : "In this section, we empirically evaluate the proposed algorithms."
    }, {
      "heading" : "6.1 Clustering under Stochastic Block Model",
      "text" : "In this section, we test empirically the performance of GECO (Algorithm 2) for a clustering task. We are provided with a graph with nodes and the respective edges between the nodes. The observed graph is assumed to have been noisily generated from a true underlying clustering. The goal is to recover the underlying clustering structure from the noisy graph provided to us. The adjacency matrix of the true underlying graph is low rank. As such, our greedy framework is applicable . We compare performance of Algorithm 2 on simulated data against standard baselines of spectral clustering which are commonly used for this task. We begin by describing a generative model for creating edges between nodes given the ground truth.\nThe Stochastic Block Model is a model to generate random graphs. It takes its input the set of n nodes, and a partition of [n] which form a set of disjoint clusters, and returns the graph with nodes and the generated edges. The model is also provided with generative probabilities (p, q) – so that a pair of nodes within the same cluster have an edge between them with probability p, while a pair of nodes belonging to different clusters have an edge between them with probability q. For simplicity we assume q = (1− p). The model then iterates over each pair of nodes. For each such\npair that belongs to same cluster, it samples an edge as Bernoulli(p), otherwise as Bernoulli(1− p). This provides us with a {0, 1} adjacency matrix.\nFor baselines, we compare against two versions of spectral clustering, which is a standard technique applied to find communities in a graph. The method takes as input the n× n adjacency matrix A, which is a {0, 1} matrix with an entry Aij = 1 if there is an edge between node i and j, and is 0 otherwise. From the adjacency matrix, the graph Laplacian L is constructed. The Laplacian may be unnormalized, in which case it is simply L = D −A, where D is the diagonal matrix of degrees of nodes. A normalized Laplacian is computed as Lnorm = D−\n1/2LD−1/2. After calculating the Laplacian, the algorithm solves for bottom k eigenvectors of the Laplacian, and then apply k-means clustering on the rows of the thus obtained eigenvector matrix. We refer to the works of Shi and Malik [25], Ng et al. [26] for the specific details of clustering algorithms using unnormalized and normalized graph Laplacian respectively.\nWe compare the spectral clustering algorithms with logistic PCA, which is a special case of the exponential family PCA [27]. The exponential family extension of classical PCA is analogous to the extension of the linear regression to generalized linear models (GLMs). For a given matrix X, the GLM generative model assumes that each cell Xij is independently drawn with likelihood proportional to exp 〈Θij ,Xij〉 −G(Θij), where Θ is the true underlying parameter, and G(·) is the partition function. It is easy to see we can apply our framework of greedy selection by defining `(·) as the log-likelihood:\n`(Θ) = 〈Θ,X〉 − ∑ i,j G(Θij),\nwhere Θ is the true parameter matrix of p and q that generates a realization of A. Since the true Θ is low rank, we get the low rank constrained optimization problem:\nmax rank(Θ)≤k `(Θ),\nwhere k is the hyperparameter that is suggestive of true number of clusters. Note that lack of knowledge of true value of k is not more restrictive than spectral clustering algorithms which typically also require the true value of k, albeit some subsequent works have tried to address tuning for k.\nHaving cast the clustering problem in the same form as (4), we can apply our greedy selection algorithm as opposed to the more costly alternating minimizing algorithms suggested by Collins et al. [27]. Since the given matrix is {0, 1} with each entry sampled from a Bernoulli, we use G(x) = log(1 + ex) which gives us logistic PCA.\nWe generate the data as follows. For n = 100 nodes, and fixed number of cluster k = 5, we vary the within cluster edge generation probability p from 0.55 to 0.95 in increments of 0.05, and use the Stochastic Block model to generate a noisy graph with each p. Note that smaller p means that the sampled graph will be more noisy and likely to be more different than the underlying clustering.\nWe compare against the spectral clustering algorithm using unnormalized Laplacian of Shi and Malik [25] which we label “Spectral unnorm{k}” for k = {3, 5, 10}, and the spectral clustering algorithm using normalized Laplacian of Ng et al. [26] which we label “Spectral norm{k}” for k = {3, 5, 10}. We use Algorithm 2 which we label “Greedy{k}” for k = {3, 5, 10}. For each of these models, the referred k is the supplied hyperparameter. We report the least squares error of the output from each model to the true underlying Θ (which we call the generalization error), and to the instantiation used for training X (which we call the reconstruction error). The results are presented in Figure 1.\nFigure 1 shows that the greedy logistic PCA performs well in not only re-creating the given noisy matrix (reconstruction) but also captures the true low rank structure better (generalization). Further, note that providing the true hyper parameter k is vital for spectral clustering algorithms, while on the other hand greedy is less sensitive to k which is very useful in practice as k is typically not known. So the spectral clustering algorithms typically would involve taking an SVD and re-running the k −means for different values of k to choose the best performing hyperparameter. The greedy factorization on the other hand is more robust, and moreover is incremental - it does not require to be re-run from scratch for different values of k."
    }, {
      "heading" : "6.2 Word Embeddings",
      "text" : "The task of embedding text into a vector space yields a representation that can have many advantages, such as using them as features for subsequent tasks as sentiment analysis. Mikolov et al. [28] proposed a context-based embedding\ncalled skip-gram or word2vec). The context of a word can be defined as a set of words before, around, or after the respective word. Their model strives to find an embedding of each word so that the representation predicts the embedding of each context word around it. In a recent paper, Levy and Goldberg [29] showed that the word embedding model proposed by Mikolov et al. [28] can be re-interpreted as matrix factorization of the PMI matrix constructed as follows. A word c is in context of w if it lies within the respective window of w. The PMI matrix is then calculated as\nPMIw,c = log ( p(w, c)\np(w)p(c)\n) .\nIn practice the probabilities p(w, c), p(w), p(c) are replaced by their empirical counterparts. Further, note that p(w, c) is 0 if words c and w do not co-exist in the same, context which yields −∞ for PMI. Levy and Goldberg [29] suggest using an alternative: PPMIw,c = max{PMIw,c, 0}. They also suggest variations of PMI hyper parameterized by k which corresponds to the number of negative samples in the training of skip gram model of Mikolov et al. [28].\nWe employ the binomial model on the normalized count matrix (instead of the PMI), in a manner similar to the clustering approach in Section 6.1. The normalized counts matrix is calculated simply as p(w,c)p(w) , without taking explicit logs unlike the PMI matrix. This gives us a probability matrix which has each entry between 0 and 1, which can be factorized under the binomial model greedily as per Algorithm 2, similar to the way we do it in Section 6.1.\nWe note that embeddings using the SVD is more scalable than our greedy approach because of advancements in linear algebraic techniques for SVD on sparse matrices that PPMI yields. Our experiments show that binomial PCA can be competitive to other existing embedding methods. Since our current implementation is not as scalable, we are further investigating this as on-going work.\nWe empirically study the embeddings obtained by binomial factorization on two tasks - word similarity and analogies. For word similarity, we use the W353 dataset [30] which has 353 queries and the MEN data [31] which has 3000 queries. Both these datasets contain words with human assigned similarity scores. We evaluate the embeddings by their cosine similarity, and measuring the correlation with the available human ratings. For the analogy task, we use the Microsoft Research (MSR) syntactic analogies [32] which has 8000 queries, and the Google mixed analogies dataset [33] with 19544 queries. To compute accuracy, we use the multiplication similarity metric as used by Levy and Goldberg [29]. To train the word embeddings, we use the 2013 news crawl datasethttp://www.statmt.org/wmt14/trainingmonolingual-news-crawl. We filter out stop words and non-ascii characters, and keep only the words which occurs atleast 2000 times which yields vocabulary of 6713. Note that since we filter only the most common words, several queries from the datasets are invalid because we do not have embeddings for words appearing in them. However, we do\ninclude them and report the overall average over the entire dataset, with metric being 0 by default for each query we are not able to process.\nTable 1 shows the empirical evaluation. SVD and PPMI are the models proposed by Levy and Goldberg [29], while SGNS is skipgram with negative sampling model of Mikolov et al. [28]. We run each of these for k = {5, 10, 15, 20} and report the best numbers. The results show that alternative factorizations such as our application of binomial PCA to those of taking SVD of the PPMI matrix can be more consistent and competitive with other embedding methods."
    }, {
      "heading" : "7 Conclusion",
      "text" : "We have connected the problem of greedy low-rank matrix estimation to that of submodular optimization. Through that connection we have provided improved exponential rates of convergence for the algorithm. An interesting area of future study will be to connect these ideas to general atoms or dictionary elements."
    }, {
      "heading" : "A Supplement",
      "text" : "In this section, we provide the missing proofs.\nA.1 Proof of Theorem 2 Proof. An important aspect of the assumptions is that the space of atoms spanned by S is orthogonal to the span of L. Furthermore, span(L ∪ S) ⊃ span(S). Let k̄ = k + r. We will first upper bound the denominator in the submodularity ratio. From strong concavity,\nmk̄ 2 ‖B(L∪S) −B(L)‖2F ≤ `(B(L))− `(B(L∪S)) + 〈∇`(B(L)),B(L∪S) −B(L)〉\nRearranging\n0 ≤ `(B(L∪S))− `(B(L)) ≤ 〈∇`(B(L)),B(L∪S) −B(L)〉 − mk̄ 2 ‖B(L∪S) −B(L)‖2F\n≤ arg max X:\nX=UL∪SHVL∪S H∈R|L∪S|×|L∪S|\n〈∇`(B(L)),X−B(L)〉 − mk̄ 2 ‖X−B(L)‖2F\n= arg max X:\nX=UL∪SHVL∪S H∈R|L∪S|×|L∪S|\n〈PUS(∇`(B(L)))PVS ,X−B(L)〉 − mk̄ 2 ‖X−B(L)‖2F ,\nwhere the last equality holds because 〈(∇`(B(L))), PULXPVL −B(L)〉 = 0. Solving the argmax problem, we get X = B(L) + 1mk̄ PUS(∇`(B(L)))PVS . Plugging in, we get,\n`(B(L∪S))− `(B(L)) ≤ 1 2mk̄ ‖PUS(∇`(B(L)))PVS‖2F\nWe next bound the numerator. Recall that the atoms in S are orthogonal to each other i.e. US and VS are both orthonormal.\nFor clarity, we define the shorthand, B(L∪S)ij = 〈uiv>j ,B(L∪S)〉uiv>j , for i, j ∈ [|L ∪ S|]. With an arbitrary i ∈ S, and arbitrary scalars αii, αij , αji for j ∈ L,\n`(B(L∪{i}))− `(B(L)) ≥ `(B(L) + αiiB(L∪S)ii + ∑ j∈L αijB (L∪S) ij + ∑ j∈L αjiB (L∪S) ji )− `(B (L))\n≥ 〈∇`(B(L)), αiiB(L∪S)ii + ∑ j∈L αijB (L∪S) ij + ∑ j∈L αjiB (L∪S) ji 〉\n− M̃1 2 α2ii‖B(L∪S)ii ‖2F +∑ j∈L α2ij‖B (L∪S) ij ‖ 2 F + ∑ j∈L α2ji‖B (L∪S) ji ‖ 2 F  . ≥ 〈∇`(B (L)),B (L∪S) ii 〉2\n2M̃1‖B(L∪S)ii ‖2F + ∑ j∈L\n( 〈∇`(B(L)),B(L∪S)ij 〉2\n2M̃1‖B(L∪S)ij ‖2F + 〈∇`(B(L)),B(L∪S)ji 〉2 2M̃1‖B(L∪S)ji ‖2F\n) ,\nwhere the last inequality follows by setting αij = 〈∇`(B(L)),B(L∪S)ij 〉 M̃1‖B(L∪S)ij ‖2F\nfor j ∈ L, and for j = i. Summing up for all i ∈ S, we get\n∑ i∈S `(B(L∪{i}))− `(B(L)) ≥ ∑ i∈S  〈∇`(B(L)),B(L∪S)ii 〉2 2M̃1‖B(L∪S)ii ‖2F + ∑ j∈L ( 〈∇`(B(L)),B(L∪S)ij 〉2 2M̃1‖B(L∪S)ij ‖2F + 〈∇`(B(L)),B(L∪S)ji 〉2 2M̃1‖B(L∪S)ji ‖2F ) = 1\n2M̃1 ‖PUS∇`(B(L))PVS‖2F\nA.2 Proofs for greedy improvement Let SGi be the support set formed by Algorithm 1 at iteration i. Define A(i) := f(S G i )− f(SGi−1) with A(0) = 0 as the greedy improvement. We also define B(i) := f(S∗)− f(SGi ) to be the remaining amount to improve, where S? is the optimum k-sized solution. We provide an auxiliary Lemma that uses the submodularity ratio to lower bound the greedy improvement in terms of best possible improvement from step i.\nLemma 1. At iteration i, the incremental gain of the greedy method (Algorithm 1) is\nA(i+ 1) ≥ τγSGi ,r\nr B(i).\nProof. Let S = SGi . Let S R be the sequential orthogonalization of the atoms in S∗ relative to S. Thus,\nrA(i+ 1) ≥ |SR|A(i+ 1) ≥ τ |SR|max a∈SR f(S ∪ {a})− f(S) ≥ τ ∑ a∈SR [f(S ∪ {a})− f(S)]\n≥ τγS,|SR|[f(S ∪ SR)− f(S)] ≥ τγS,|SR|B(i)\nNote that the last inequality follows because f(S ∪ SR) ≥ f(S∗). The penultimate inequality follows by the definition of weak submodularity, which applies in this case because the atoms in SR are orthogonal to eachother and are also orthogonal to S.\nUsing Lemma 1, one can prove an approximation guarantee for Algorithm 1.\nA.2.1 Proof of Theorem 3\nProof. From the notation used for Lemma 1, A(i+ 1) = B(i)−B(i+ 1). Let C = τγ SG i ,r\nr . From Lemma 1, we have,\nB(i+ 1) ≤ (1− C)B(i) ≤ (1− C)i+1B(0).\nFrom its definition, B(0) = f(S?)− f(∅). So we get,\n[f(S?)− f(∅)]− [ f(SGi )− f(∅) ] ≤ (1− C)i [f(S?)− f(∅)]\n=⇒ [ f(SGi )− f(∅) ] ≥ (1− (1− C)i) [f(S?)− f(∅)] ≥ ( 1− 1\ne τγ SG i ,r k r\n) [f(S?)− f(∅)]\nfrom which the result follows.\nA.3 Proof for GECO bounds Let SOi be the support set selected by the GECO procedure (Algorithm 2) at iteration i. Similar to the section on greedy improvement, we define some notation. Let D(i) := f(SOi ) − f(SOi−1) be the improvement made at step i, and as before we have B(i) = f(S?)− f(SOi ) be the remaining amount to improve.\nWe prove the following auxiliary lemma which lower bounds the gain after adding the atom selected by the subroutine OMPSelin terms of operator norm of the gradient of the current iterate and smoothness of the function.\nLemma 2. Assume that `(·) is mi-strongly concave and Mi-smooth over matrices of in the set Ω̃ := {(X,Y) : rank(X−Y) ≤ 1}. Then,\nD(i+ 1) ≥ τmr+k rM̃1 B(i).\nProof. For simplicity, say L = SOi . Recall that for a given support set L, f(L) = `(B (L)) i.e. we denote by B(L) the argmax for `(·) for a given support set L. Hence, by the optimality of B(L∪{i}),\nD(i+ 1) = `(B(L∪{i}))− `(B(L)) ≥ `(B(L) + αuv>)− `(B(L))\nfor an arbitrary α ∈ R, and the vectors u,v selected by OMPSel. Using the smoothness of the `(·), we get,\nD(i+ 1) ≥ α〈∇`(B(L)),uv>〉 − α2 M̃1 2\nPutting in α = τ M̃1 ‖∇`(B(L))‖2, and by τ -optimality of OMPSel, we get,\nD(i+ 1) ≥ τ 2\n2M̃1 ‖∇`(B(L))‖22\nLet SR be obtained from after sequentially orthogonalizing S? w.r.t. Si. By definition of the operator norm, we further get,\nD(i+ 1) ≥ τ 2\n2M̃1 ‖∇`(B(L))‖22\n≥ τ 2\n2rM̃1 ∑ i∈SR 〈uiv>i ,∇`(B(L))〉2\n= ‖PUSR∇`(B (L))PVSR ‖ 2 F ≥ τ 2mr+k\nrM̃1\n( `(BL∪S R )− `(B(L)) )\n≥ τ 2mr+k\nrM̃1\n( `(BS ? )− `(B(L)) )\n= τ2mr+k\nrM̃1 B(i)\nThe proof for Theorem 4 from Lemma 2 now follows using the same steps as for Theorem 3 from Lemma 2.\nA.4 Proof for recovery bounds A.4.1 Proof of Theorem 5\nFor clarity of representation, let C = Cr,k, and for an arbitrary H ∈ Rr×r, let Br = U>S HVS, and ∆ := B(Sr) −Bs. Note that ∆ has rank atmost (k + r). Recall that by the mk+r RSC (Definition 3),\n`(B(Sk))− `(Br)− 〈∇`(Br),∆〉 ≤ −mk+r\n2 ‖∆‖2F .\nFrom the approximation guarantee, we have,\n`(B(Sk))− `(Br) ≥ (1− C)[`(0)− `(Br)] =⇒ `(B(Sk))− `(Br)− 〈∇`(Br),∆〉 ≥ (1− C)[`(0)− `(Br)]− 〈∇`(Br),∆〉 =⇒ −mk+r 2 ‖∆‖2F ≥ (1− C)[`(0)− `(Br)]− 〈∇`(Br),∆〉\n≥ (1− C)[`(0)− `(Br)]− (k + r) 1/2‖∇`(Br)‖2‖∆‖F ,\nwhere the last inequality is due to generalized Holder’s inequality. Using 2ab ≤ ca2 + b 2\nc for any positive numbers a, b, c, we get\nmk+r 2 ‖∆‖2F ≤ (k + r) ‖∇`(Br)‖22 mk+r + mk+r‖∆‖2F 4 + (1− C)[`(Br)− `(0)],\nwhich completes the proof."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "<lb>We provide new approximation guarantees for greedy low rank matrix estimation under standard assumptions<lb>of restricted strong convexity and smoothness. Our novel analysis also uncovers previously unknown connections<lb>between the low rank estimation and combinatorial optimization, so much so that our bounds are reminiscent of<lb>corresponding approximation bounds in submodular maximization. Additionally, we also provide statistical recovery<lb>guarantees. Finally, we present empirical comparison of greedy estimation with established baselines on two important<lb>real-world problems.",
    "creator" : "LaTeX with hyperref package"
  }
}